grammar None_grammar {
    print_stmt <- or(
        | PrintStmt("print" test_list)
        | StreamPrintStmt("print" ">>" test "," test_list)
    )
    dotted_as_names <- (list*(or(dotted_as_name | dotted_name), ",") ?",")
    empty_test_list <- (list+(test, ",") ?",")
    try_stmt <- TryStmt(
        "try" ":" suite list+(ExceptPart(
            "except" ?AsNameNode(test ?"as" test) ":" suite
        )) ?else_part ?"finally" ":" suite
    )
    test_list <- (list*(test, ",") ?",")
    small_stmt <- or(
        | expr_stmt
        | print_stmt
        | del_stmt
        | pass_stmt
        | flow_stmt
        | import_stmt
        | global_stmt
        | exec_stmt
        | assert_stmt
    )
    expr_list <- (list*(expr, ",") ?",")
    number <- NumberLit(@Number)
    dict_assoc <- DictAssoc(test ":" test)
    return_stmt <- ReturnStmt("return" ?test_list)
    cat_string <- ConcatStringLit(string list*(string))
    not_test <- or(NotOp("not" not_test) | comparison)
    suite <- or(
        | discard(list+(nl))
        @Indent
        list*(discard(list+(nl)) stmt discard(list+(nl))) @Dedent
        | simple_stmt
    )
    string <- StringLit(@String)
    flow_stmt <- or(
        | break_stmt
        | continue_stmt
        | return_stmt
        | raise_stmt
        | yield_stmt
    )
    del_stmt <- DelStmt("del" expr_list)
    comp_if <- CompIf("if" test ?comp_iter)
    expr_stmt <- or(
        | AugAssignStmt(
            test_list Op(
                or(
                    | "+="
                    | "-="
                    | "*="
                    | "/="
                    | "%="
                    | "&="
                    | "|="
                    | "^="
                    | "<<="
                    | ">>="
                    | "**="
                    | "//="
                )
            ) or(yield_expr | test_list)
        )
        | AssignStmt(
            test_list list*("=" or(yield_expr | test_list))
        )
        | test_list
    )
    nl <- NL(@Newline)
    func_def <- FuncDef("def" name parameters ":" suite)
    parameters <- ("(" ?varargslist ")")
    continue_stmt <- ContinueStmt("continue")
    fpdef <- or(name | "(" name_list ")")
    shift_expr <- or(
        | ShiftExpr(shift_expr Op(or("<<" | ">>")) arith_expr)
        | arith_expr
    )
    atom_expr <- or(
        | DottedName(atom_expr "." name)
        | CallExpr(atom_expr "(" arg_list ")")
        | SubscriptExpr(atom_expr "[" subscript_list "]")
        | atom
    )
    name <- Id(@Identifier)
    dotted_as_name <- AsNameNode(dotted_name "as" name)
    list_iter <- or(list_for | list_if)
    list_if <- CompIf("if" test ?list_iter)
    factor <- or(Factor(Op(or("+" | "-" | "~")) factor) | power)
    test <- or(
        | lambdef
        | IfExpr(or_test "if" or_test "else" test)
        | or_test
    )
    global_stmt <- GlobalStmt("global" name_list)
    subscript <- or(
        | EllipsisExpr("." "." ".")
        | ExtSliceExpr(?test ":" ?test ":" ?test)
        | SliceExpr(?test ":" ?test)
        | test
    )
    with_item <- AsNameNode(test ?"as" expr)
    decorators <- list*(decorator)
    compound_stmt <- or(
        | if_stmt
        | while_stmt
        | for_stmt
        | try_stmt
        | with_stmt
        | func_def
        | class_def
        | decorated
    )
    exec_stmt <- ExecStmt("exec" expr ?"in" test_list)
    yield_stmt <- yield_expr
    dotted_name <- or(DottedName(dotted_name "." name) | name)
    yield_expr <- YieldExpr("yield" ?test_list)
    power <- or(Power(atom_expr "**" factor) | atom_expr)
    simple_stmt <- (or(small_stmt | list*(small_stmt, ";") ?";") @Newline)
    main_rule <- FileNode(
        list*(discard(list+(nl)) stmt discard(list+(nl))) @Termination
    )
    name_list <- (list*(name, ",") ?",")
    stmt <- or(simple_stmt | compound_stmt)
    import_from <- ImportFrom(
        "from"
        or(dotted_name | RelName(list*(dot) ?dotted_name)) "import" or(
            | ImportStar("*")
            | "(" import_as_names ")"
            | import_as_names
        )
    )
    assert_stmt <- AssertStmt("assert" test ?"," test)
    list_for <- CompForL(
        "for" expr_list "in" test_list ?list_iter
    )
    for_stmt <- ForStmt(
        "for" expr_list "in" test_list ":" suite ?else_part
    )
    break_stmt <- BreakStmt("break")
    else_part <- ElsePart("else" ":" suite)
    and_test <- or(AndOp(and_test "and" not_test) | not_test)
    lambdef <- LambdaDef("lambda" varargslist ":" test)
    atom <- or(
        | "(" yield_expr ")"
        | ListGen("(" test list_for ")")
        | TupleLit("(" ?test_list ")")
        | ListComp("[" test list_for "]")
        | ListLit("[" empty_test_list "]")
        | SetComp("{" test comp_for "}")
        | set_lit
        | DictComp("{" dict_assoc comp_for "}")
        | DictLit("{" list*(dict_assoc, ",") ?"," "}")
        | InlineEval("`" test_list "`")
        | name
        | number
        | cat_string
        | string
    )
    import_as_names <- (list*(or(as_name | name), ",") ?",")
    decorated <- Decorated(decorators or(class_def | func_def))
    raise_stmt <- RaiseStmt("raise" ?test_list)
    arg_list <- (list+(or(
        | ArgGen(test comp_for)
        | ArgAssoc(?test "=" test)
        | VarArgs("*" test)
        | KwArgs("**" test)
    ), ",") ?",")
    set_lit <- SetLit("{" empty_test_list "}")
    decorator <- Decorator(
        "@" dotted_name ?"(" arg_list ")" @Newline
    )
    pass_stmt <- PassStmt("pass")
    comparison <- or(
        | CompOp(
            comparison or(
                | CompOpKindLt("<")
                | CompOpKindGt(">")
                | CompOpKindEq("==")
                | CompOpKindGte(">=")
                | CompOpKindLte("<=")
                | CompOpKindDiamond("<>")
                | CompOpKindNoteq("!=")
                | CompOpKindIn("in")
                | CompOpKindNotin("not" "in")
                | CompOpKindIsnot("is" "not")
                | CompOpKindIs("is")
            ) expr
        )
        | expr
    )
    term <- or(
        | Term(term Op(or("*" | "/" | "%" | "//")) factor)
        | factor
    )
    comp_iter <- or(comp_for | comp_if)
    subscript_list <- (list*(subscript, ",") ?",")
    if_stmt <- IfStmt(
        "if"
        test
        ":"
        suite list+("elif" ElifBranch(test ":" suite)) ?else_part
    )
    arith_expr <- or(
        | ArithExpr(arith_expr Op(or("+" | "-")) term)
        | term
    )
    import_name <- ImportName("import" dotted_as_names)
    or_test <- or(OrOp(or_test "or" and_test) | and_test)
    class_def <- ClassDef(
        "class" name ?"(" ?test_list ")" ":" suite
    )
    with_stmt <- WithStmt("with" list*(with_item, ",") ":" suite)
    while_stmt <- WhileStmt("while" test ":" suite ?else_part)
    varargslist <- Params(
        list+(SingleParam(?"*" ?"**" fpdef ?"=" test), ",")
    )
    comp_for <- CompFor(
        "for" expr_list "in" or_test ?comp_iter
    )
    import_stmt <- or(import_name | import_from)
    expr <- or(OrExpr(expr "|" xor_expr) | xor_expr)
    xor_expr <- or(XorExpr(xor_expr "^" and_expr) | and_expr)
    and_expr <- or(
        | AndExpr(and_expr "&" shift_expr)
        | shift_expr
    )
    as_name <- AsNameNode(name "as" name)
    dot <- Dot(".")

}

@abstract class PythonNode {
}

@abstract class Arg : PythonNode {
}

class ArgAssoc : Arg {
    @parse_field name : Expr
    @parse_field expr : Expr
}

class ArgGen : Arg {
    @parse_field expr : Expr
    @parse_field comprehension : CompFor
}

class KwArgs : Arg {
    @parse_field expr : Expr
}

class VarArgs : Arg {
    @parse_field expr : Expr
}

class AsNameNode : PythonNode {
    @parse_field imported : Expr
    @parse_field as_name : Expr
}

class CompIf : PythonNode {
    @parse_field test : Expr
    @parse_field comp : PythonNode
}

@abstract @enum_node(Lt,
    Gt,
    Eq,
    Gte,
    Lte,
    Diamond,
    Noteq, In, Notin, Is, Isnot) class CompOpKind : PythonNode {
}

@abstract class Comprehension : PythonNode {
}

class CompFor : Comprehension {
    @parse_field exprs : ASTList[Expr]
    @parse_field target : Expr
    @parse_field comp : PythonNode
}

class CompForL : Comprehension {
    @parse_field exprs : ASTList[Expr]
    @parse_field target : ASTList[Expr]
    @parse_field comp : PythonNode
}

class Decorator : PythonNode {
    @parse_field dec_name : Name
    @parse_field arg_list : ASTList[Arg]
}

class DictAssoc : PythonNode {
    @parse_field key : Expr
    @parse_field value : Expr
}

class ElsePart : PythonNode {
    @parse_field statements : PythonNode
}

class ExceptPart : PythonNode {
    @parse_field as_name : AsNameNode
    @parse_field statements : PythonNode
}

@abstract class Expr : PythonNode {
}

class AndExpr : Expr {
    @parse_field left : Expr
    @parse_field right : Expr
}

class AndOp : Expr {
    @parse_field left : Expr
    @parse_field right : Expr
}

@abstract class BinOp : Expr {
    @parse_field left : Expr
    @parse_field op : Op
    @parse_field right : Expr
}

class ArithExpr : BinOp {
}

class ShiftExpr : BinOp {
}

class Term : BinOp {
}

class CallExpr : Expr {
    @parse_field prefix : Expr
    @parse_field suffix : ASTList[Arg]
}

class CompOp : Expr {
    @parse_field left : Expr
    @parse_field op : CompOpKind
    @parse_field right : Expr
}

class ConcatStringLit : Expr {
    @parse_field first_str : StringLit
    @parse_field subsequent_str : ASTList[StringLit]
}

class DictComp : Expr {
    @parse_field assoc : DictAssoc
    @parse_field comprehension : CompFor
}

class DictLit : Expr {
    @parse_field assocs : ASTList[DictAssoc]
}

class Dot : Expr {
}

class EllipsisExpr : Expr {
}

class Factor : Expr {
    @parse_field op : Op
    @parse_field expr : Expr
}

class IfExpr : Expr {
    @parse_field expr : Expr
    @parse_field cond : Expr
    @parse_field else_expr : Expr
}

class InlineEval : Expr {
    @parse_field exprs : ASTList[Expr]
}

class LambdaDef : Expr {
    @parse_field args : Params
    @parse_field expr : Expr
}

class ListComp : Expr {
    @parse_field expr : Expr
    @parse_field comprehension : CompForL
}

class ListGen : Expr {
    @parse_field expr : Expr
    @parse_field comprehension : CompForL
}

class ListLit : Expr {
    @parse_field exprs : ASTList[Expr]
}

@abstract class Name : Expr {
}

class DottedName : Name {
    @parse_field prefix : Expr
    @parse_field suffix : Id
}

class Id : Name {

    ## Shortcut to get the symbol of this node
    fun sym (): SymbolType = self.symbol
}

class NotOp : Expr {
    @parse_field expr : Expr
}

class NumberLit : Expr {
}

class OrExpr : Expr {
    @parse_field left : Expr
    @parse_field right : Expr
}

class OrOp : Expr {
    @parse_field left : Expr
    @parse_field right : Expr
}

class Power : Expr {
    @parse_field left : Expr
    @parse_field right : Expr
}

class SetComp : Expr {
    @parse_field expr : Expr
    @parse_field comprehension : CompFor
}

class SetLit : Expr {
    @parse_field exprs : ASTList[Expr]
}

class SliceExpr : Expr {
    @parse_field first : Expr
    @parse_field last : Expr
}

class ExtSliceExpr : SliceExpr {
    @parse_field stride : Expr
}

class StringLit : Expr {
}

class SubscriptExpr : Expr {
    @parse_field prefix : Expr
    @parse_field suffix : ASTList[Expr]
}

class TupleLit : Expr {
    @parse_field exprs : ASTList[Expr]
}

class XorExpr : Expr {
    @parse_field left : Expr
    @parse_field right : Expr
}

class YieldExpr : Expr {
    @parse_field exprs : ASTList[Expr]
}

class FileNode : PythonNode {
    @parse_field statements : ASTList[PythonNode]
}

class ImportStar : PythonNode {
}

@abstract @qualifier class KwArgsFlag : PythonNode {

    ## Return whether this is an instance of KwArgsFlagPresent
    @export fun as_bool (): Boolean
}

class NL : PythonNode {
}

class Op : PythonNode {
}

class Params : PythonNode {
    @parse_field single_params : ASTList[SingleParam]
}

class RelName : PythonNode {
    @parse_field dots : ASTList[Dot]
    @parse_field name : Name
}

class SingleParam : PythonNode {
    @parse_field is_varargs : VarArgsFlag
    @parse_field is_kwargs : KwArgsFlag
    @parse_field name : PythonNode
    @parse_field default_value : Expr
}

@abstract class Stmt : PythonNode {
}

class AssertStmt : Stmt {
    @parse_field test_expr : Expr
    @parse_field msg : Expr
}

class AssignStmt : Stmt {
    @parse_field l_value : ASTList[Expr]
    @parse_field r_values : ASTList[PythonNode]
}

class AugAssignStmt : Stmt {
    @parse_field l_value : ASTList[Expr]
    @parse_field op : Op
    @parse_field r_value : PythonNode
}

class BreakStmt : Stmt {
}

class ContinueStmt : Stmt {
}

class Decorated : Stmt {
    @parse_field decorators : ASTList[Decorator]
    @parse_field defn : DefStmt
}

@abstract class DefStmt : Stmt {
}

class ClassDef : DefStmt {
    @parse_field name : Id
    @parse_field bases : ASTList[Expr]
    @parse_field statements : PythonNode
}

class FuncDef : DefStmt {
    @parse_field name : Id
    @parse_field parameters : Params
    @parse_field body : PythonNode
}

class DelStmt : Stmt {
    @parse_field exprs : ASTList[Expr]
}

class ElifBranch : Stmt {
    @parse_field cond_test : Expr
    @parse_field statements : PythonNode
}

class ExecStmt : Stmt {
    @parse_field expr : Expr
    @parse_field in_list : ASTList[Expr]
}

class ForStmt : Stmt {
    @parse_field bindings : ASTList[Expr]
    @parse_field expr : ASTList[Expr]
    @parse_field statements : PythonNode
    @parse_field else_part : ElsePart
}

class GlobalStmt : Stmt {
    @parse_field names : ASTList[Id]
}

class IfStmt : Stmt {
    @parse_field cond_test : Expr
    @parse_field statements : PythonNode
    @parse_field elif_branchs : ASTList[ElifBranch]
    @parse_field else_part : ElsePart
}

class ImportFrom : Stmt {
    @parse_field rel_name : PythonNode
    @parse_field imported : PythonNode
}

class ImportName : Stmt {
    @parse_field imported_names : ASTList[PythonNode]
}

class PassStmt : Stmt {
}

class PrintStmt : Stmt {
    @parse_field exprs : ASTList[Expr]
}

class RaiseStmt : Stmt {
    @parse_field exprs : ASTList[Expr]
}

class ReturnStmt : Stmt {
    @parse_field exprs : ASTList[Expr]
}

class StreamPrintStmt : Stmt {
    @parse_field stream_expr : Expr
    @parse_field exprs : ASTList[Expr]
}

class TryStmt : Stmt {
    @parse_field statements : PythonNode
    @parse_field except_parts : ASTList[ExceptPart]
    @parse_field else_part : ElsePart
    @parse_field finally_part : PythonNode
}

class WhileStmt : Stmt {
    @parse_field cond_test : Expr
    @parse_field statements : PythonNode
    @parse_field else_part : ElsePart
}

class WithStmt : Stmt {
    @parse_field bindings : ASTList[AsNameNode]
    @parse_field statements : PythonNode
}

@abstract @qualifier class VarArgsFlag : PythonNode {

    ## Return whether this is an instance of VarArgsFlagPresent
    @export fun as_bool (): Boolean
}
