grammar None_grammar {
    main_rule <- list*(or(Def(@Def Name(@Identifier) expr) | expr))
    expr <- or(atom | plus)
    lit <- Lit(@Number)
    plus <- (@LPar Plus(expr @Plus expr) @RPar)
    atom <- or(lit | ref)
    ref <- Ref(@Identifier)

}

class FooNode {

    @export fun find_atoms (): Array[Entity[Atom]] = (
        match entity {
            # This should match Lit .. Ref
            case a : Atom => [a]
<<<<<<< HEAD
            case _ => null.to[Array[Entity[Atom]]]
=======
>>>>>>> RA22-015: Add initial support for unparsing comments.

            # This should match Def | Plus .. FooNode.list
            case _ => null
        }
    ) & (
        entity.children.mapcat((c) => c.find_atoms)
    )

    @export fun find_atoms_or_exprs (): Array[Entity[Expr]] = (
        match entity {
            # This should match Lit .. Ref
            case a : Atom => [a.to[Expr]]

            # This should match the only remaining expression: Plus
            case e : Expr => [e]
<<<<<<< HEAD
            case _ => null.to[Array[Entity[Expr]]]
=======
>>>>>>> RA22-015: Add initial support for unparsing comments.

            # This should match Def | FooNode.list
            case _ => null
        }
    ) & (
        entity.children.mapcat((c) => c.find_atoms_or_exprs)
    )

    @export fun find_exprs (): Array[Entity[Expr]] = (
        match entity {
            # This should match Lit .. Plus
            case e : Expr => [e]

            # This should match nothing (Atom is an Expr subclass), so emit a
            # warning.
            case a : Atom => [a.to[Expr]]
<<<<<<< HEAD
            case _ => null.to[Array[Entity[Expr]]]
=======
>>>>>>> RA22-015: Add initial support for unparsing comments.

            # This should match Def | FooNode.list
            case _ => null
        }
    ) & (
        entity.children.mapcat((c) => c.find_exprs)
    )
}

class Def : FooNode {
    @parse_field name : Name
    @parse_field expr : Expr
}

class Expr : FooNode {

    @export fun find_refs (): Array[Entity[Ref]] = (
        match entity {
            # This should match Ref
            case r : Ref => [r]
<<<<<<< HEAD
            case _ => null.to[Array[Entity[Ref]]]
=======
>>>>>>> RA22-015: Add initial support for unparsing comments.

            # This should match Lit
            case _ => null
        }
    ) & (
        entity.children.mapcat((c) => c.to[Expr]!.find_refs)
    )
}

class Atom : Expr {
}

class Lit : Atom {
}

class Ref : Atom {
}

class Plus : Expr {
    @parse_field lhs : Expr
    @parse_field rhs : Expr
}

class Name : FooNode {
}
