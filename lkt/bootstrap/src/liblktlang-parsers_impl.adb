
with Ada.Containers.Vectors;
with Ada.Exceptions;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;

with System;

with Liblktlang_Support.Bump_Ptr;    use Liblktlang_Support.Bump_Ptr;
with Liblktlang_Support.Diagnostics; use Liblktlang_Support.Diagnostics;
with Liblktlang_Support.Packrat;
with Liblktlang_Support.Slocs;       use Liblktlang_Support.Slocs;

pragma Warnings (Off, "referenced");
with Liblktlang_Support.Symbols; use Liblktlang_Support.Symbols;
pragma Warnings (On, "referenced");

with Liblktlang_Support.Text;        use Liblktlang_Support.Text;

with Liblktlang.Common;         use Liblktlang.Common;
with Liblktlang.Implementation; use Liblktlang.Implementation;
use Liblktlang.Implementation.Precomputed_Symbols;

pragma Warnings (Off, "referenced");
with Liblktlang.Private_Converters; use Liblktlang.Private_Converters;
pragma Warnings (On, "referenced");

with Liblktlang.Implementation.Extensions;



package body Liblktlang.Parsers_Impl is
   pragma Warnings (Off, "use clause");
   use all type Liblktlang_Support.Symbols.Symbol_Type;
   pragma Warnings (On, "use clause");

   --  Prepare packrat instantiations: one per enum type and onefor each kind
   --  of node (including lists). Likewise for bump ptr. allocators, except
   --  we need them only for non-abstract AST nodes.

   pragma Warnings (Off, "is not referenced");
      package Bare_Lkt_Node_Memos is new Liblktlang_Support.Packrat
        (Bare_Lkt_Node, Token_Index);

      package Bare_Base_Lexer_Case_Rule_Alt_Memos is new Liblktlang_Support.Packrat
        (Bare_Base_Lexer_Case_Rule_Alt, Token_Index);

      package Bare_Lexer_Case_Rule_Cond_Alt_Memos is new Liblktlang_Support.Packrat
        (Bare_Lexer_Case_Rule_Cond_Alt, Token_Index);

         
         subtype Subtype_For_Lexer_Case_Rule_Cond_Alt is
            Root_Node_Record (Lkt_Lexer_Case_Rule_Cond_Alt);
         type Access_To_Subtype_For_Lexer_Case_Rule_Cond_Alt is access all Subtype_For_Lexer_Case_Rule_Cond_Alt;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lexer_Case_Rule_Cond_Alt);
         package Bare_Lexer_Case_Rule_Cond_Alt_Alloc is new Alloc
           (Subtype_For_Lexer_Case_Rule_Cond_Alt, Access_To_Subtype_For_Lexer_Case_Rule_Cond_Alt);

         function Allocate_Lexer_Case_Rule_Cond_Alt
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Case_Rule_Cond_Alt;

         function Allocate_Lexer_Case_Rule_Cond_Alt
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Case_Rule_Cond_Alt
         is
            Result      : constant Access_To_Subtype_For_Lexer_Case_Rule_Cond_Alt := Bare_Lexer_Case_Rule_Cond_Alt_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lexer_Case_Rule_Cond_Alt;
            return Bare_Lexer_Case_Rule_Cond_Alt (Result);
         end Allocate_Lexer_Case_Rule_Cond_Alt;

      package Bare_Lexer_Case_Rule_Default_Alt_Memos is new Liblktlang_Support.Packrat
        (Bare_Lexer_Case_Rule_Default_Alt, Token_Index);

         
         subtype Subtype_For_Lexer_Case_Rule_Default_Alt is
            Root_Node_Record (Lkt_Lexer_Case_Rule_Default_Alt);
         type Access_To_Subtype_For_Lexer_Case_Rule_Default_Alt is access all Subtype_For_Lexer_Case_Rule_Default_Alt;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lexer_Case_Rule_Default_Alt);
         package Bare_Lexer_Case_Rule_Default_Alt_Alloc is new Alloc
           (Subtype_For_Lexer_Case_Rule_Default_Alt, Access_To_Subtype_For_Lexer_Case_Rule_Default_Alt);

         function Allocate_Lexer_Case_Rule_Default_Alt
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Case_Rule_Default_Alt;

         function Allocate_Lexer_Case_Rule_Default_Alt
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Case_Rule_Default_Alt
         is
            Result      : constant Access_To_Subtype_For_Lexer_Case_Rule_Default_Alt := Bare_Lexer_Case_Rule_Default_Alt_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lexer_Case_Rule_Default_Alt;
            return Bare_Lexer_Case_Rule_Default_Alt (Result);
         end Allocate_Lexer_Case_Rule_Default_Alt;

      package Bare_Block_String_Line_Memos is new Liblktlang_Support.Packrat
        (Bare_Block_String_Line, Token_Index);

         
         subtype Subtype_For_Block_String_Line is
            Root_Node_Record (Lkt_Block_String_Line);
         type Access_To_Subtype_For_Block_String_Line is access all Subtype_For_Block_String_Line;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Block_String_Line);
         package Bare_Block_String_Line_Alloc is new Alloc
           (Subtype_For_Block_String_Line, Access_To_Subtype_For_Block_String_Line);

         function Allocate_Block_String_Line
           (Pool : Bump_Ptr_Pool) return Bare_Block_String_Line;

         function Allocate_Block_String_Line
           (Pool : Bump_Ptr_Pool) return Bare_Block_String_Line
         is
            Result      : constant Access_To_Subtype_For_Block_String_Line := Bare_Block_String_Line_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Block_String_Line;
            return Bare_Block_String_Line (Result);
         end Allocate_Block_String_Line;

      package Bare_Class_Qualifier_Memos is new Liblktlang_Support.Packrat
        (Bare_Class_Qualifier, Token_Index);

      package Bare_Class_Qualifier_Absent_Memos is new Liblktlang_Support.Packrat
        (Bare_Class_Qualifier_Absent, Token_Index);

         
         subtype Subtype_For_Class_Qualifier_Absent is
            Root_Node_Record (Lkt_Class_Qualifier_Absent);
         type Access_To_Subtype_For_Class_Qualifier_Absent is access all Subtype_For_Class_Qualifier_Absent;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Class_Qualifier_Absent);
         package Bare_Class_Qualifier_Absent_Alloc is new Alloc
           (Subtype_For_Class_Qualifier_Absent, Access_To_Subtype_For_Class_Qualifier_Absent);

         function Allocate_Class_Qualifier_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Class_Qualifier_Absent;

         function Allocate_Class_Qualifier_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Class_Qualifier_Absent
         is
            Result      : constant Access_To_Subtype_For_Class_Qualifier_Absent := Bare_Class_Qualifier_Absent_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Class_Qualifier_Absent;
            return Bare_Class_Qualifier_Absent (Result);
         end Allocate_Class_Qualifier_Absent;

      package Bare_Class_Qualifier_Present_Memos is new Liblktlang_Support.Packrat
        (Bare_Class_Qualifier_Present, Token_Index);

         
         subtype Subtype_For_Class_Qualifier_Present is
            Root_Node_Record (Lkt_Class_Qualifier_Present);
         type Access_To_Subtype_For_Class_Qualifier_Present is access all Subtype_For_Class_Qualifier_Present;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Class_Qualifier_Present);
         package Bare_Class_Qualifier_Present_Alloc is new Alloc
           (Subtype_For_Class_Qualifier_Present, Access_To_Subtype_For_Class_Qualifier_Present);

         function Allocate_Class_Qualifier_Present
           (Pool : Bump_Ptr_Pool) return Bare_Class_Qualifier_Present;

         function Allocate_Class_Qualifier_Present
           (Pool : Bump_Ptr_Pool) return Bare_Class_Qualifier_Present
         is
            Result      : constant Access_To_Subtype_For_Class_Qualifier_Present := Bare_Class_Qualifier_Present_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Class_Qualifier_Present;
            return Bare_Class_Qualifier_Present (Result);
         end Allocate_Class_Qualifier_Present;

      package Bare_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Decl, Token_Index);

      package Bare_Base_Grammar_Rule_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Base_Grammar_Rule_Decl, Token_Index);

      package Bare_Grammar_Rule_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Rule_Decl, Token_Index);

         
         subtype Subtype_For_Grammar_Rule_Decl is
            Root_Node_Record (Lkt_Grammar_Rule_Decl);
         type Access_To_Subtype_For_Grammar_Rule_Decl is access all Subtype_For_Grammar_Rule_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Rule_Decl);
         package Bare_Grammar_Rule_Decl_Alloc is new Alloc
           (Subtype_For_Grammar_Rule_Decl, Access_To_Subtype_For_Grammar_Rule_Decl);

         function Allocate_Grammar_Rule_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Rule_Decl;

         function Allocate_Grammar_Rule_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Rule_Decl
         is
            Result      : constant Access_To_Subtype_For_Grammar_Rule_Decl := Bare_Grammar_Rule_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Rule_Decl;
            return Bare_Grammar_Rule_Decl (Result);
         end Allocate_Grammar_Rule_Decl;

      package Bare_Synthetic_Lexer_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Synthetic_Lexer_Decl, Token_Index);

         
         subtype Subtype_For_Synthetic_Lexer_Decl is
            Root_Node_Record (Lkt_Synthetic_Lexer_Decl);
         type Access_To_Subtype_For_Synthetic_Lexer_Decl is access all Subtype_For_Synthetic_Lexer_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Synthetic_Lexer_Decl);
         package Bare_Synthetic_Lexer_Decl_Alloc is new Alloc
           (Subtype_For_Synthetic_Lexer_Decl, Access_To_Subtype_For_Synthetic_Lexer_Decl);

         function Allocate_Synthetic_Lexer_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Lexer_Decl;

         function Allocate_Synthetic_Lexer_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Lexer_Decl
         is
            Result      : constant Access_To_Subtype_For_Synthetic_Lexer_Decl := Bare_Synthetic_Lexer_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Synthetic_Lexer_Decl;
            return Bare_Synthetic_Lexer_Decl (Result);
         end Allocate_Synthetic_Lexer_Decl;

      package Bare_Base_Val_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Base_Val_Decl, Token_Index);

      package Bare_Node_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Node_Decl, Token_Index);

         
         subtype Subtype_For_Node_Decl is
            Root_Node_Record (Lkt_Node_Decl);
         type Access_To_Subtype_For_Node_Decl is access all Subtype_For_Node_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Node_Decl);
         package Bare_Node_Decl_Alloc is new Alloc
           (Subtype_For_Node_Decl, Access_To_Subtype_For_Node_Decl);

         function Allocate_Node_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Node_Decl;

         function Allocate_Node_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Node_Decl
         is
            Result      : constant Access_To_Subtype_For_Node_Decl := Bare_Node_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Node_Decl;
            return Bare_Node_Decl (Result);
         end Allocate_Node_Decl;

      package Bare_Self_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Self_Decl, Token_Index);

         
         subtype Subtype_For_Self_Decl is
            Root_Node_Record (Lkt_Self_Decl);
         type Access_To_Subtype_For_Self_Decl is access all Subtype_For_Self_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Self_Decl);
         package Bare_Self_Decl_Alloc is new Alloc
           (Subtype_For_Self_Decl, Access_To_Subtype_For_Self_Decl);

         function Allocate_Self_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Self_Decl;

         function Allocate_Self_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Self_Decl
         is
            Result      : constant Access_To_Subtype_For_Self_Decl := Bare_Self_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Self_Decl;
            return Bare_Self_Decl (Result);
         end Allocate_Self_Decl;

      package Bare_User_Val_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_User_Val_Decl, Token_Index);

      package Bare_Enum_Lit_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Enum_Lit_Decl, Token_Index);

         
         subtype Subtype_For_Enum_Lit_Decl is
            Root_Node_Record (Lkt_Enum_Lit_Decl);
         type Access_To_Subtype_For_Enum_Lit_Decl is access all Subtype_For_Enum_Lit_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Enum_Lit_Decl);
         package Bare_Enum_Lit_Decl_Alloc is new Alloc
           (Subtype_For_Enum_Lit_Decl, Access_To_Subtype_For_Enum_Lit_Decl);

         function Allocate_Enum_Lit_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Lit_Decl;

         function Allocate_Enum_Lit_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Lit_Decl
         is
            Result      : constant Access_To_Subtype_For_Enum_Lit_Decl := Bare_Enum_Lit_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Enum_Lit_Decl;
            return Bare_Enum_Lit_Decl (Result);
         end Allocate_Enum_Lit_Decl;

      package Bare_Explicitly_Typed_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Explicitly_Typed_Decl, Token_Index);

      package Bare_Component_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Component_Decl, Token_Index);

      package Bare_Field_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Field_Decl, Token_Index);

         
         subtype Subtype_For_Field_Decl is
            Root_Node_Record (Lkt_Field_Decl);
         type Access_To_Subtype_For_Field_Decl is access all Subtype_For_Field_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Field_Decl);
         package Bare_Field_Decl_Alloc is new Alloc
           (Subtype_For_Field_Decl, Access_To_Subtype_For_Field_Decl);

         function Allocate_Field_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Field_Decl;

         function Allocate_Field_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Field_Decl
         is
            Result      : constant Access_To_Subtype_For_Field_Decl := Bare_Field_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Field_Decl;
            return Bare_Field_Decl (Result);
         end Allocate_Field_Decl;

      package Bare_Fun_Arg_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Fun_Arg_Decl, Token_Index);

         
         subtype Subtype_For_Fun_Arg_Decl is
            Root_Node_Record (Lkt_Fun_Arg_Decl);
         type Access_To_Subtype_For_Fun_Arg_Decl is access all Subtype_For_Fun_Arg_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Fun_Arg_Decl);
         package Bare_Fun_Arg_Decl_Alloc is new Alloc
           (Subtype_For_Fun_Arg_Decl, Access_To_Subtype_For_Fun_Arg_Decl);

         function Allocate_Fun_Arg_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Fun_Arg_Decl;

         function Allocate_Fun_Arg_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Fun_Arg_Decl
         is
            Result      : constant Access_To_Subtype_For_Fun_Arg_Decl := Bare_Fun_Arg_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Fun_Arg_Decl;
            return Bare_Fun_Arg_Decl (Result);
         end Allocate_Fun_Arg_Decl;

      package Bare_Lambda_Arg_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Lambda_Arg_Decl, Token_Index);

         
         subtype Subtype_For_Lambda_Arg_Decl is
            Root_Node_Record (Lkt_Lambda_Arg_Decl);
         type Access_To_Subtype_For_Lambda_Arg_Decl is access all Subtype_For_Lambda_Arg_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lambda_Arg_Decl);
         package Bare_Lambda_Arg_Decl_Alloc is new Alloc
           (Subtype_For_Lambda_Arg_Decl, Access_To_Subtype_For_Lambda_Arg_Decl);

         function Allocate_Lambda_Arg_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Lambda_Arg_Decl;

         function Allocate_Lambda_Arg_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Lambda_Arg_Decl
         is
            Result      : constant Access_To_Subtype_For_Lambda_Arg_Decl := Bare_Lambda_Arg_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lambda_Arg_Decl;
            return Bare_Lambda_Arg_Decl (Result);
         end Allocate_Lambda_Arg_Decl;

      package Bare_Dyn_Var_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Dyn_Var_Decl, Token_Index);

         
         subtype Subtype_For_Dyn_Var_Decl is
            Root_Node_Record (Lkt_Dyn_Var_Decl);
         type Access_To_Subtype_For_Dyn_Var_Decl is access all Subtype_For_Dyn_Var_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Dyn_Var_Decl);
         package Bare_Dyn_Var_Decl_Alloc is new Alloc
           (Subtype_For_Dyn_Var_Decl, Access_To_Subtype_For_Dyn_Var_Decl);

         function Allocate_Dyn_Var_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Dyn_Var_Decl;

         function Allocate_Dyn_Var_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Dyn_Var_Decl
         is
            Result      : constant Access_To_Subtype_For_Dyn_Var_Decl := Bare_Dyn_Var_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Dyn_Var_Decl;
            return Bare_Dyn_Var_Decl (Result);
         end Allocate_Dyn_Var_Decl;

      package Bare_Match_Val_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Match_Val_Decl, Token_Index);

         
         subtype Subtype_For_Match_Val_Decl is
            Root_Node_Record (Lkt_Match_Val_Decl);
         type Access_To_Subtype_For_Match_Val_Decl is access all Subtype_For_Match_Val_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Match_Val_Decl);
         package Bare_Match_Val_Decl_Alloc is new Alloc
           (Subtype_For_Match_Val_Decl, Access_To_Subtype_For_Match_Val_Decl);

         function Allocate_Match_Val_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Match_Val_Decl;

         function Allocate_Match_Val_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Match_Val_Decl
         is
            Result      : constant Access_To_Subtype_For_Match_Val_Decl := Bare_Match_Val_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Match_Val_Decl;
            return Bare_Match_Val_Decl (Result);
         end Allocate_Match_Val_Decl;

      package Bare_Val_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Val_Decl, Token_Index);

         
         subtype Subtype_For_Val_Decl is
            Root_Node_Record (Lkt_Val_Decl);
         type Access_To_Subtype_For_Val_Decl is access all Subtype_For_Val_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Val_Decl);
         package Bare_Val_Decl_Alloc is new Alloc
           (Subtype_For_Val_Decl, Access_To_Subtype_For_Val_Decl);

         function Allocate_Val_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Val_Decl;

         function Allocate_Val_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Val_Decl
         is
            Result      : constant Access_To_Subtype_For_Val_Decl := Bare_Val_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Val_Decl;
            return Bare_Val_Decl (Result);
         end Allocate_Val_Decl;

      package Bare_Fun_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Fun_Decl, Token_Index);

         
         subtype Subtype_For_Fun_Decl is
            Root_Node_Record (Lkt_Fun_Decl);
         type Access_To_Subtype_For_Fun_Decl is access all Subtype_For_Fun_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Fun_Decl);
         package Bare_Fun_Decl_Alloc is new Alloc
           (Subtype_For_Fun_Decl, Access_To_Subtype_For_Fun_Decl);

         function Allocate_Fun_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Fun_Decl;

         function Allocate_Fun_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Fun_Decl
         is
            Result      : constant Access_To_Subtype_For_Fun_Decl := Bare_Fun_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Fun_Decl;
            return Bare_Fun_Decl (Result);
         end Allocate_Fun_Decl;

      package Bare_Env_Spec_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Env_Spec_Decl, Token_Index);

         
         subtype Subtype_For_Env_Spec_Decl is
            Root_Node_Record (Lkt_Env_Spec_Decl);
         type Access_To_Subtype_For_Env_Spec_Decl is access all Subtype_For_Env_Spec_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Env_Spec_Decl);
         package Bare_Env_Spec_Decl_Alloc is new Alloc
           (Subtype_For_Env_Spec_Decl, Access_To_Subtype_For_Env_Spec_Decl);

         function Allocate_Env_Spec_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Env_Spec_Decl;

         function Allocate_Env_Spec_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Env_Spec_Decl
         is
            Result      : constant Access_To_Subtype_For_Env_Spec_Decl := Bare_Env_Spec_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Env_Spec_Decl;
            return Bare_Env_Spec_Decl (Result);
         end Allocate_Env_Spec_Decl;

      package Bare_Generic_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Generic_Decl, Token_Index);

         
         subtype Subtype_For_Generic_Decl is
            Root_Node_Record (Lkt_Generic_Decl);
         type Access_To_Subtype_For_Generic_Decl is access all Subtype_For_Generic_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Generic_Decl);
         package Bare_Generic_Decl_Alloc is new Alloc
           (Subtype_For_Generic_Decl, Access_To_Subtype_For_Generic_Decl);

         function Allocate_Generic_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Decl;

         function Allocate_Generic_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Decl
         is
            Result      : constant Access_To_Subtype_For_Generic_Decl := Bare_Generic_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Generic_Decl;
            return Bare_Generic_Decl (Result);
         end Allocate_Generic_Decl;

      package Bare_Grammar_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Decl, Token_Index);

         
         subtype Subtype_For_Grammar_Decl is
            Root_Node_Record (Lkt_Grammar_Decl);
         type Access_To_Subtype_For_Grammar_Decl is access all Subtype_For_Grammar_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Decl);
         package Bare_Grammar_Decl_Alloc is new Alloc
           (Subtype_For_Grammar_Decl, Access_To_Subtype_For_Grammar_Decl);

         function Allocate_Grammar_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Decl;

         function Allocate_Grammar_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Decl
         is
            Result      : constant Access_To_Subtype_For_Grammar_Decl := Bare_Grammar_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Decl;
            return Bare_Grammar_Decl (Result);
         end Allocate_Grammar_Decl;

      package Bare_Lexer_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Lexer_Decl, Token_Index);

         
         subtype Subtype_For_Lexer_Decl is
            Root_Node_Record (Lkt_Lexer_Decl);
         type Access_To_Subtype_For_Lexer_Decl is access all Subtype_For_Lexer_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lexer_Decl);
         package Bare_Lexer_Decl_Alloc is new Alloc
           (Subtype_For_Lexer_Decl, Access_To_Subtype_For_Lexer_Decl);

         function Allocate_Lexer_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Decl;

         function Allocate_Lexer_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Decl
         is
            Result      : constant Access_To_Subtype_For_Lexer_Decl := Bare_Lexer_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lexer_Decl;
            return Bare_Lexer_Decl (Result);
         end Allocate_Lexer_Decl;

      package Bare_Lexer_Family_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Lexer_Family_Decl, Token_Index);

         
         subtype Subtype_For_Lexer_Family_Decl is
            Root_Node_Record (Lkt_Lexer_Family_Decl);
         type Access_To_Subtype_For_Lexer_Family_Decl is access all Subtype_For_Lexer_Family_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lexer_Family_Decl);
         package Bare_Lexer_Family_Decl_Alloc is new Alloc
           (Subtype_For_Lexer_Family_Decl, Access_To_Subtype_For_Lexer_Family_Decl);

         function Allocate_Lexer_Family_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Family_Decl;

         function Allocate_Lexer_Family_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Family_Decl
         is
            Result      : constant Access_To_Subtype_For_Lexer_Family_Decl := Bare_Lexer_Family_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lexer_Family_Decl;
            return Bare_Lexer_Family_Decl (Result);
         end Allocate_Lexer_Family_Decl;

      package Bare_Synth_Arg_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Synth_Arg_Decl, Token_Index);

         
         subtype Subtype_For_Synth_Arg_Decl is
            Root_Node_Record (Lkt_Synth_Arg_Decl);
         type Access_To_Subtype_For_Synth_Arg_Decl is access all Subtype_For_Synth_Arg_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Synth_Arg_Decl);
         package Bare_Synth_Arg_Decl_Alloc is new Alloc
           (Subtype_For_Synth_Arg_Decl, Access_To_Subtype_For_Synth_Arg_Decl);

         function Allocate_Synth_Arg_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Synth_Arg_Decl;

         function Allocate_Synth_Arg_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Synth_Arg_Decl
         is
            Result      : constant Access_To_Subtype_For_Synth_Arg_Decl := Bare_Synth_Arg_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Synth_Arg_Decl;
            return Bare_Synth_Arg_Decl (Result);
         end Allocate_Synth_Arg_Decl;

      package Bare_Synth_Fun_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Synth_Fun_Decl, Token_Index);

         
         subtype Subtype_For_Synth_Fun_Decl is
            Root_Node_Record (Lkt_Synth_Fun_Decl);
         type Access_To_Subtype_For_Synth_Fun_Decl is access all Subtype_For_Synth_Fun_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Synth_Fun_Decl);
         package Bare_Synth_Fun_Decl_Alloc is new Alloc
           (Subtype_For_Synth_Fun_Decl, Access_To_Subtype_For_Synth_Fun_Decl);

         function Allocate_Synth_Fun_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Synth_Fun_Decl;

         function Allocate_Synth_Fun_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Synth_Fun_Decl
         is
            Result      : constant Access_To_Subtype_For_Synth_Fun_Decl := Bare_Synth_Fun_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Synth_Fun_Decl;
            return Bare_Synth_Fun_Decl (Result);
         end Allocate_Synth_Fun_Decl;

      package Bare_Type_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Type_Decl, Token_Index);

      package Bare_Any_Type_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Any_Type_Decl, Token_Index);

         
         subtype Subtype_For_Any_Type_Decl is
            Root_Node_Record (Lkt_Any_Type_Decl);
         type Access_To_Subtype_For_Any_Type_Decl is access all Subtype_For_Any_Type_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Any_Type_Decl);
         package Bare_Any_Type_Decl_Alloc is new Alloc
           (Subtype_For_Any_Type_Decl, Access_To_Subtype_For_Any_Type_Decl);

         function Allocate_Any_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Any_Type_Decl;

         function Allocate_Any_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Any_Type_Decl
         is
            Result      : constant Access_To_Subtype_For_Any_Type_Decl := Bare_Any_Type_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Any_Type_Decl;
            return Bare_Any_Type_Decl (Result);
         end Allocate_Any_Type_Decl;

      package Bare_Enum_Class_Alt_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Enum_Class_Alt_Decl, Token_Index);

         
         subtype Subtype_For_Enum_Class_Alt_Decl is
            Root_Node_Record (Lkt_Enum_Class_Alt_Decl);
         type Access_To_Subtype_For_Enum_Class_Alt_Decl is access all Subtype_For_Enum_Class_Alt_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Enum_Class_Alt_Decl);
         package Bare_Enum_Class_Alt_Decl_Alloc is new Alloc
           (Subtype_For_Enum_Class_Alt_Decl, Access_To_Subtype_For_Enum_Class_Alt_Decl);

         function Allocate_Enum_Class_Alt_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Alt_Decl;

         function Allocate_Enum_Class_Alt_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Alt_Decl
         is
            Result      : constant Access_To_Subtype_For_Enum_Class_Alt_Decl := Bare_Enum_Class_Alt_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Enum_Class_Alt_Decl;
            return Bare_Enum_Class_Alt_Decl (Result);
         end Allocate_Enum_Class_Alt_Decl;

      package Bare_Function_Type_Memos is new Liblktlang_Support.Packrat
        (Bare_Function_Type, Token_Index);

         
         subtype Subtype_For_Function_Type is
            Root_Node_Record (Lkt_Function_Type);
         type Access_To_Subtype_For_Function_Type is access all Subtype_For_Function_Type;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Function_Type);
         package Bare_Function_Type_Alloc is new Alloc
           (Subtype_For_Function_Type, Access_To_Subtype_For_Function_Type);

         function Allocate_Function_Type
           (Pool : Bump_Ptr_Pool) return Bare_Function_Type;

         function Allocate_Function_Type
           (Pool : Bump_Ptr_Pool) return Bare_Function_Type
         is
            Result      : constant Access_To_Subtype_For_Function_Type := Bare_Function_Type_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Function_Type;
            return Bare_Function_Type (Result);
         end Allocate_Function_Type;

      package Bare_Generic_Formal_Type_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Generic_Formal_Type_Decl, Token_Index);

         
         subtype Subtype_For_Generic_Formal_Type_Decl is
            Root_Node_Record (Lkt_Generic_Formal_Type_Decl);
         type Access_To_Subtype_For_Generic_Formal_Type_Decl is access all Subtype_For_Generic_Formal_Type_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Generic_Formal_Type_Decl);
         package Bare_Generic_Formal_Type_Decl_Alloc is new Alloc
           (Subtype_For_Generic_Formal_Type_Decl, Access_To_Subtype_For_Generic_Formal_Type_Decl);

         function Allocate_Generic_Formal_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Type_Decl;

         function Allocate_Generic_Formal_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Type_Decl
         is
            Result      : constant Access_To_Subtype_For_Generic_Formal_Type_Decl := Bare_Generic_Formal_Type_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Generic_Formal_Type_Decl;
            return Bare_Generic_Formal_Type_Decl (Result);
         end Allocate_Generic_Formal_Type_Decl;

      package Bare_Named_Type_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Named_Type_Decl, Token_Index);

      package Bare_Basic_Class_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Basic_Class_Decl, Token_Index);

      package Bare_Class_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Class_Decl, Token_Index);

         
         subtype Subtype_For_Class_Decl is
            Root_Node_Record (Lkt_Class_Decl);
         type Access_To_Subtype_For_Class_Decl is access all Subtype_For_Class_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Class_Decl);
         package Bare_Class_Decl_Alloc is new Alloc
           (Subtype_For_Class_Decl, Access_To_Subtype_For_Class_Decl);

         function Allocate_Class_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Class_Decl;

         function Allocate_Class_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Class_Decl
         is
            Result      : constant Access_To_Subtype_For_Class_Decl := Bare_Class_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Class_Decl;
            return Bare_Class_Decl (Result);
         end Allocate_Class_Decl;

      package Bare_Enum_Class_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Enum_Class_Decl, Token_Index);

         
         subtype Subtype_For_Enum_Class_Decl is
            Root_Node_Record (Lkt_Enum_Class_Decl);
         type Access_To_Subtype_For_Enum_Class_Decl is access all Subtype_For_Enum_Class_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Enum_Class_Decl);
         package Bare_Enum_Class_Decl_Alloc is new Alloc
           (Subtype_For_Enum_Class_Decl, Access_To_Subtype_For_Enum_Class_Decl);

         function Allocate_Enum_Class_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Decl;

         function Allocate_Enum_Class_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Decl
         is
            Result      : constant Access_To_Subtype_For_Enum_Class_Decl := Bare_Enum_Class_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Enum_Class_Decl;
            return Bare_Enum_Class_Decl (Result);
         end Allocate_Enum_Class_Decl;

      package Bare_Enum_Type_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Enum_Type_Decl, Token_Index);

         
         subtype Subtype_For_Enum_Type_Decl is
            Root_Node_Record (Lkt_Enum_Type_Decl);
         type Access_To_Subtype_For_Enum_Type_Decl is access all Subtype_For_Enum_Type_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Enum_Type_Decl);
         package Bare_Enum_Type_Decl_Alloc is new Alloc
           (Subtype_For_Enum_Type_Decl, Access_To_Subtype_For_Enum_Type_Decl);

         function Allocate_Enum_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Type_Decl;

         function Allocate_Enum_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Type_Decl
         is
            Result      : constant Access_To_Subtype_For_Enum_Type_Decl := Bare_Enum_Type_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Enum_Type_Decl;
            return Bare_Enum_Type_Decl (Result);
         end Allocate_Enum_Type_Decl;

      package Bare_Struct_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Struct_Decl, Token_Index);

         
         subtype Subtype_For_Struct_Decl is
            Root_Node_Record (Lkt_Struct_Decl);
         type Access_To_Subtype_For_Struct_Decl is access all Subtype_For_Struct_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Struct_Decl);
         package Bare_Struct_Decl_Alloc is new Alloc
           (Subtype_For_Struct_Decl, Access_To_Subtype_For_Struct_Decl);

         function Allocate_Struct_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Struct_Decl;

         function Allocate_Struct_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Struct_Decl
         is
            Result      : constant Access_To_Subtype_For_Struct_Decl := Bare_Struct_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Struct_Decl;
            return Bare_Struct_Decl (Result);
         end Allocate_Struct_Decl;

      package Bare_Trait_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Trait_Decl, Token_Index);

         
         subtype Subtype_For_Trait_Decl is
            Root_Node_Record (Lkt_Trait_Decl);
         type Access_To_Subtype_For_Trait_Decl is access all Subtype_For_Trait_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Trait_Decl);
         package Bare_Trait_Decl_Alloc is new Alloc
           (Subtype_For_Trait_Decl, Access_To_Subtype_For_Trait_Decl);

         function Allocate_Trait_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Trait_Decl;

         function Allocate_Trait_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Trait_Decl
         is
            Result      : constant Access_To_Subtype_For_Trait_Decl := Bare_Trait_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Trait_Decl;
            return Bare_Trait_Decl (Result);
         end Allocate_Trait_Decl;

      package Bare_Decl_Annotation_Memos is new Liblktlang_Support.Packrat
        (Bare_Decl_Annotation, Token_Index);

         
         subtype Subtype_For_Decl_Annotation is
            Root_Node_Record (Lkt_Decl_Annotation);
         type Access_To_Subtype_For_Decl_Annotation is access all Subtype_For_Decl_Annotation;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Decl_Annotation);
         package Bare_Decl_Annotation_Alloc is new Alloc
           (Subtype_For_Decl_Annotation, Access_To_Subtype_For_Decl_Annotation);

         function Allocate_Decl_Annotation
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Annotation;

         function Allocate_Decl_Annotation
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Annotation
         is
            Result      : constant Access_To_Subtype_For_Decl_Annotation := Bare_Decl_Annotation_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Decl_Annotation;
            return Bare_Decl_Annotation (Result);
         end Allocate_Decl_Annotation;

      package Bare_Decl_Annotation_Params_Memos is new Liblktlang_Support.Packrat
        (Bare_Decl_Annotation_Params, Token_Index);

         
         subtype Subtype_For_Decl_Annotation_Params is
            Root_Node_Record (Lkt_Decl_Annotation_Params);
         type Access_To_Subtype_For_Decl_Annotation_Params is access all Subtype_For_Decl_Annotation_Params;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Decl_Annotation_Params);
         package Bare_Decl_Annotation_Params_Alloc is new Alloc
           (Subtype_For_Decl_Annotation_Params, Access_To_Subtype_For_Decl_Annotation_Params);

         function Allocate_Decl_Annotation_Params
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Annotation_Params;

         function Allocate_Decl_Annotation_Params
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Annotation_Params
         is
            Result      : constant Access_To_Subtype_For_Decl_Annotation_Params := Bare_Decl_Annotation_Params_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Decl_Annotation_Params;
            return Bare_Decl_Annotation_Params (Result);
         end Allocate_Decl_Annotation_Params;

      package Bare_Dyn_Env_Wrapper_Memos is new Liblktlang_Support.Packrat
        (Bare_Dyn_Env_Wrapper, Token_Index);

         
         subtype Subtype_For_Dyn_Env_Wrapper is
            Root_Node_Record (Lkt_Dyn_Env_Wrapper);
         type Access_To_Subtype_For_Dyn_Env_Wrapper is access all Subtype_For_Dyn_Env_Wrapper;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Dyn_Env_Wrapper);
         package Bare_Dyn_Env_Wrapper_Alloc is new Alloc
           (Subtype_For_Dyn_Env_Wrapper, Access_To_Subtype_For_Dyn_Env_Wrapper);

         function Allocate_Dyn_Env_Wrapper
           (Pool : Bump_Ptr_Pool) return Bare_Dyn_Env_Wrapper;

         function Allocate_Dyn_Env_Wrapper
           (Pool : Bump_Ptr_Pool) return Bare_Dyn_Env_Wrapper
         is
            Result      : constant Access_To_Subtype_For_Dyn_Env_Wrapper := Bare_Dyn_Env_Wrapper_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Dyn_Env_Wrapper;
            return Bare_Dyn_Env_Wrapper (Result);
         end Allocate_Dyn_Env_Wrapper;

      package Bare_Elsif_Branch_Memos is new Liblktlang_Support.Packrat
        (Bare_Elsif_Branch, Token_Index);

         
         subtype Subtype_For_Elsif_Branch is
            Root_Node_Record (Lkt_Elsif_Branch);
         type Access_To_Subtype_For_Elsif_Branch is access all Subtype_For_Elsif_Branch;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Elsif_Branch);
         package Bare_Elsif_Branch_Alloc is new Alloc
           (Subtype_For_Elsif_Branch, Access_To_Subtype_For_Elsif_Branch);

         function Allocate_Elsif_Branch
           (Pool : Bump_Ptr_Pool) return Bare_Elsif_Branch;

         function Allocate_Elsif_Branch
           (Pool : Bump_Ptr_Pool) return Bare_Elsif_Branch
         is
            Result      : constant Access_To_Subtype_For_Elsif_Branch := Bare_Elsif_Branch_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Elsif_Branch;
            return Bare_Elsif_Branch (Result);
         end Allocate_Elsif_Branch;

      package Bare_Enum_Class_Case_Memos is new Liblktlang_Support.Packrat
        (Bare_Enum_Class_Case, Token_Index);

         
         subtype Subtype_For_Enum_Class_Case is
            Root_Node_Record (Lkt_Enum_Class_Case);
         type Access_To_Subtype_For_Enum_Class_Case is access all Subtype_For_Enum_Class_Case;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Enum_Class_Case);
         package Bare_Enum_Class_Case_Alloc is new Alloc
           (Subtype_For_Enum_Class_Case, Access_To_Subtype_For_Enum_Class_Case);

         function Allocate_Enum_Class_Case
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Case;

         function Allocate_Enum_Class_Case
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Case
         is
            Result      : constant Access_To_Subtype_For_Enum_Class_Case := Bare_Enum_Class_Case_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Enum_Class_Case;
            return Bare_Enum_Class_Case (Result);
         end Allocate_Enum_Class_Case;

      package Bare_Excludes_Null_Memos is new Liblktlang_Support.Packrat
        (Bare_Excludes_Null, Token_Index);

      package Bare_Excludes_Null_Absent_Memos is new Liblktlang_Support.Packrat
        (Bare_Excludes_Null_Absent, Token_Index);

         
         subtype Subtype_For_Excludes_Null_Absent is
            Root_Node_Record (Lkt_Excludes_Null_Absent);
         type Access_To_Subtype_For_Excludes_Null_Absent is access all Subtype_For_Excludes_Null_Absent;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Excludes_Null_Absent);
         package Bare_Excludes_Null_Absent_Alloc is new Alloc
           (Subtype_For_Excludes_Null_Absent, Access_To_Subtype_For_Excludes_Null_Absent);

         function Allocate_Excludes_Null_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Excludes_Null_Absent;

         function Allocate_Excludes_Null_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Excludes_Null_Absent
         is
            Result      : constant Access_To_Subtype_For_Excludes_Null_Absent := Bare_Excludes_Null_Absent_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Excludes_Null_Absent;
            return Bare_Excludes_Null_Absent (Result);
         end Allocate_Excludes_Null_Absent;

      package Bare_Excludes_Null_Present_Memos is new Liblktlang_Support.Packrat
        (Bare_Excludes_Null_Present, Token_Index);

         
         subtype Subtype_For_Excludes_Null_Present is
            Root_Node_Record (Lkt_Excludes_Null_Present);
         type Access_To_Subtype_For_Excludes_Null_Present is access all Subtype_For_Excludes_Null_Present;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Excludes_Null_Present);
         package Bare_Excludes_Null_Present_Alloc is new Alloc
           (Subtype_For_Excludes_Null_Present, Access_To_Subtype_For_Excludes_Null_Present);

         function Allocate_Excludes_Null_Present
           (Pool : Bump_Ptr_Pool) return Bare_Excludes_Null_Present;

         function Allocate_Excludes_Null_Present
           (Pool : Bump_Ptr_Pool) return Bare_Excludes_Null_Present
         is
            Result      : constant Access_To_Subtype_For_Excludes_Null_Present := Bare_Excludes_Null_Present_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Excludes_Null_Present;
            return Bare_Excludes_Null_Present (Result);
         end Allocate_Excludes_Null_Present;

      package Bare_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Expr, Token_Index);

      package Bare_Any_Of_Memos is new Liblktlang_Support.Packrat
        (Bare_Any_Of, Token_Index);

         
         subtype Subtype_For_Any_Of is
            Root_Node_Record (Lkt_Any_Of);
         type Access_To_Subtype_For_Any_Of is access all Subtype_For_Any_Of;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Any_Of);
         package Bare_Any_Of_Alloc is new Alloc
           (Subtype_For_Any_Of, Access_To_Subtype_For_Any_Of);

         function Allocate_Any_Of
           (Pool : Bump_Ptr_Pool) return Bare_Any_Of;

         function Allocate_Any_Of
           (Pool : Bump_Ptr_Pool) return Bare_Any_Of
         is
            Result      : constant Access_To_Subtype_For_Any_Of := Bare_Any_Of_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Any_Of;
            return Bare_Any_Of (Result);
         end Allocate_Any_Of;

      package Bare_Array_Literal_Memos is new Liblktlang_Support.Packrat
        (Bare_Array_Literal, Token_Index);

         
         subtype Subtype_For_Array_Literal is
            Root_Node_Record (Lkt_Array_Literal);
         type Access_To_Subtype_For_Array_Literal is access all Subtype_For_Array_Literal;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Array_Literal);
         package Bare_Array_Literal_Alloc is new Alloc
           (Subtype_For_Array_Literal, Access_To_Subtype_For_Array_Literal);

         function Allocate_Array_Literal
           (Pool : Bump_Ptr_Pool) return Bare_Array_Literal;

         function Allocate_Array_Literal
           (Pool : Bump_Ptr_Pool) return Bare_Array_Literal
         is
            Result      : constant Access_To_Subtype_For_Array_Literal := Bare_Array_Literal_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Array_Literal;
            return Bare_Array_Literal (Result);
         end Allocate_Array_Literal;

      package Bare_Base_Call_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Base_Call_Expr, Token_Index);

      package Bare_Call_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Call_Expr, Token_Index);

         
         subtype Subtype_For_Call_Expr is
            Root_Node_Record (Lkt_Call_Expr);
         type Access_To_Subtype_For_Call_Expr is access all Subtype_For_Call_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Call_Expr);
         package Bare_Call_Expr_Alloc is new Alloc
           (Subtype_For_Call_Expr, Access_To_Subtype_For_Call_Expr);

         function Allocate_Call_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Call_Expr;

         function Allocate_Call_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Call_Expr
         is
            Result      : constant Access_To_Subtype_For_Call_Expr := Bare_Call_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Call_Expr;
            return Bare_Call_Expr (Result);
         end Allocate_Call_Expr;

      package Bare_Logic_Call_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Logic_Call_Expr, Token_Index);

      package Bare_Logic_Predicate_Memos is new Liblktlang_Support.Packrat
        (Bare_Logic_Predicate, Token_Index);

         
         subtype Subtype_For_Logic_Predicate is
            Root_Node_Record (Lkt_Logic_Predicate);
         type Access_To_Subtype_For_Logic_Predicate is access all Subtype_For_Logic_Predicate;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Logic_Predicate);
         package Bare_Logic_Predicate_Alloc is new Alloc
           (Subtype_For_Logic_Predicate, Access_To_Subtype_For_Logic_Predicate);

         function Allocate_Logic_Predicate
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Predicate;

         function Allocate_Logic_Predicate
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Predicate
         is
            Result      : constant Access_To_Subtype_For_Logic_Predicate := Bare_Logic_Predicate_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Logic_Predicate;
            return Bare_Logic_Predicate (Result);
         end Allocate_Logic_Predicate;

      package Bare_Logic_Propagate_Call_Memos is new Liblktlang_Support.Packrat
        (Bare_Logic_Propagate_Call, Token_Index);

         
         subtype Subtype_For_Logic_Propagate_Call is
            Root_Node_Record (Lkt_Logic_Propagate_Call);
         type Access_To_Subtype_For_Logic_Propagate_Call is access all Subtype_For_Logic_Propagate_Call;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Logic_Propagate_Call);
         package Bare_Logic_Propagate_Call_Alloc is new Alloc
           (Subtype_For_Logic_Propagate_Call, Access_To_Subtype_For_Logic_Propagate_Call);

         function Allocate_Logic_Propagate_Call
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Propagate_Call;

         function Allocate_Logic_Propagate_Call
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Propagate_Call
         is
            Result      : constant Access_To_Subtype_For_Logic_Propagate_Call := Bare_Logic_Propagate_Call_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Logic_Propagate_Call;
            return Bare_Logic_Propagate_Call (Result);
         end Allocate_Logic_Propagate_Call;

      package Bare_Base_Dot_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Base_Dot_Expr, Token_Index);

      package Bare_Dot_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Dot_Expr, Token_Index);

         
         subtype Subtype_For_Dot_Expr is
            Root_Node_Record (Lkt_Dot_Expr);
         type Access_To_Subtype_For_Dot_Expr is access all Subtype_For_Dot_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Dot_Expr);
         package Bare_Dot_Expr_Alloc is new Alloc
           (Subtype_For_Dot_Expr, Access_To_Subtype_For_Dot_Expr);

         function Allocate_Dot_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Dot_Expr;

         function Allocate_Dot_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Dot_Expr
         is
            Result      : constant Access_To_Subtype_For_Dot_Expr := Bare_Dot_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Dot_Expr;
            return Bare_Dot_Expr (Result);
         end Allocate_Dot_Expr;

      package Bare_Null_Cond_Dotted_Name_Memos is new Liblktlang_Support.Packrat
        (Bare_Null_Cond_Dotted_Name, Token_Index);

         
         subtype Subtype_For_Null_Cond_Dotted_Name is
            Root_Node_Record (Lkt_Null_Cond_Dotted_Name);
         type Access_To_Subtype_For_Null_Cond_Dotted_Name is access all Subtype_For_Null_Cond_Dotted_Name;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Null_Cond_Dotted_Name);
         package Bare_Null_Cond_Dotted_Name_Alloc is new Alloc
           (Subtype_For_Null_Cond_Dotted_Name, Access_To_Subtype_For_Null_Cond_Dotted_Name);

         function Allocate_Null_Cond_Dotted_Name
           (Pool : Bump_Ptr_Pool) return Bare_Null_Cond_Dotted_Name;

         function Allocate_Null_Cond_Dotted_Name
           (Pool : Bump_Ptr_Pool) return Bare_Null_Cond_Dotted_Name
         is
            Result      : constant Access_To_Subtype_For_Null_Cond_Dotted_Name := Bare_Null_Cond_Dotted_Name_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Null_Cond_Dotted_Name;
            return Bare_Null_Cond_Dotted_Name (Result);
         end Allocate_Null_Cond_Dotted_Name;

      package Bare_Bin_Op_Memos is new Liblktlang_Support.Packrat
        (Bare_Bin_Op, Token_Index);

         
         subtype Subtype_For_Bin_Op is
            Root_Node_Record (Lkt_Bin_Op);
         type Access_To_Subtype_For_Bin_Op is access all Subtype_For_Bin_Op;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Bin_Op);
         package Bare_Bin_Op_Alloc is new Alloc
           (Subtype_For_Bin_Op, Access_To_Subtype_For_Bin_Op);

         function Allocate_Bin_Op
           (Pool : Bump_Ptr_Pool) return Bare_Bin_Op;

         function Allocate_Bin_Op
           (Pool : Bump_Ptr_Pool) return Bare_Bin_Op
         is
            Result      : constant Access_To_Subtype_For_Bin_Op := Bare_Bin_Op_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Bin_Op;
            return Bare_Bin_Op (Result);
         end Allocate_Bin_Op;

      package Bare_Block_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Block_Expr, Token_Index);

         
         subtype Subtype_For_Block_Expr is
            Root_Node_Record (Lkt_Block_Expr);
         type Access_To_Subtype_For_Block_Expr is access all Subtype_For_Block_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Block_Expr);
         package Bare_Block_Expr_Alloc is new Alloc
           (Subtype_For_Block_Expr, Access_To_Subtype_For_Block_Expr);

         function Allocate_Block_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Block_Expr;

         function Allocate_Block_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Block_Expr
         is
            Result      : constant Access_To_Subtype_For_Block_Expr := Bare_Block_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Block_Expr;
            return Bare_Block_Expr (Result);
         end Allocate_Block_Expr;

      package Bare_Cast_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Cast_Expr, Token_Index);

         
         subtype Subtype_For_Cast_Expr is
            Root_Node_Record (Lkt_Cast_Expr);
         type Access_To_Subtype_For_Cast_Expr is access all Subtype_For_Cast_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Cast_Expr);
         package Bare_Cast_Expr_Alloc is new Alloc
           (Subtype_For_Cast_Expr, Access_To_Subtype_For_Cast_Expr);

         function Allocate_Cast_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Cast_Expr;

         function Allocate_Cast_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Cast_Expr
         is
            Result      : constant Access_To_Subtype_For_Cast_Expr := Bare_Cast_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Cast_Expr;
            return Bare_Cast_Expr (Result);
         end Allocate_Cast_Expr;

      package Bare_Error_On_Null_Memos is new Liblktlang_Support.Packrat
        (Bare_Error_On_Null, Token_Index);

         
         subtype Subtype_For_Error_On_Null is
            Root_Node_Record (Lkt_Error_On_Null);
         type Access_To_Subtype_For_Error_On_Null is access all Subtype_For_Error_On_Null;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Error_On_Null);
         package Bare_Error_On_Null_Alloc is new Alloc
           (Subtype_For_Error_On_Null, Access_To_Subtype_For_Error_On_Null);

         function Allocate_Error_On_Null
           (Pool : Bump_Ptr_Pool) return Bare_Error_On_Null;

         function Allocate_Error_On_Null
           (Pool : Bump_Ptr_Pool) return Bare_Error_On_Null
         is
            Result      : constant Access_To_Subtype_For_Error_On_Null := Bare_Error_On_Null_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Error_On_Null;
            return Bare_Error_On_Null (Result);
         end Allocate_Error_On_Null;

      package Bare_Generic_Instantiation_Memos is new Liblktlang_Support.Packrat
        (Bare_Generic_Instantiation, Token_Index);

         
         subtype Subtype_For_Generic_Instantiation is
            Root_Node_Record (Lkt_Generic_Instantiation);
         type Access_To_Subtype_For_Generic_Instantiation is access all Subtype_For_Generic_Instantiation;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Generic_Instantiation);
         package Bare_Generic_Instantiation_Alloc is new Alloc
           (Subtype_For_Generic_Instantiation, Access_To_Subtype_For_Generic_Instantiation);

         function Allocate_Generic_Instantiation
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Instantiation;

         function Allocate_Generic_Instantiation
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Instantiation
         is
            Result      : constant Access_To_Subtype_For_Generic_Instantiation := Bare_Generic_Instantiation_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Generic_Instantiation;
            return Bare_Generic_Instantiation (Result);
         end Allocate_Generic_Instantiation;

      package Bare_Grammar_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Expr, Token_Index);

      package Bare_Grammar_Cut_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Cut, Token_Index);

         
         subtype Subtype_For_Grammar_Cut is
            Root_Node_Record (Lkt_Grammar_Cut);
         type Access_To_Subtype_For_Grammar_Cut is access all Subtype_For_Grammar_Cut;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Cut);
         package Bare_Grammar_Cut_Alloc is new Alloc
           (Subtype_For_Grammar_Cut, Access_To_Subtype_For_Grammar_Cut);

         function Allocate_Grammar_Cut
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Cut;

         function Allocate_Grammar_Cut
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Cut
         is
            Result      : constant Access_To_Subtype_For_Grammar_Cut := Bare_Grammar_Cut_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Cut;
            return Bare_Grammar_Cut (Result);
         end Allocate_Grammar_Cut;

      package Bare_Grammar_Discard_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Discard, Token_Index);

         
         subtype Subtype_For_Grammar_Discard is
            Root_Node_Record (Lkt_Grammar_Discard);
         type Access_To_Subtype_For_Grammar_Discard is access all Subtype_For_Grammar_Discard;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Discard);
         package Bare_Grammar_Discard_Alloc is new Alloc
           (Subtype_For_Grammar_Discard, Access_To_Subtype_For_Grammar_Discard);

         function Allocate_Grammar_Discard
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Discard;

         function Allocate_Grammar_Discard
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Discard
         is
            Result      : constant Access_To_Subtype_For_Grammar_Discard := Bare_Grammar_Discard_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Discard;
            return Bare_Grammar_Discard (Result);
         end Allocate_Grammar_Discard;

      package Bare_Grammar_Dont_Skip_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Dont_Skip, Token_Index);

         
         subtype Subtype_For_Grammar_Dont_Skip is
            Root_Node_Record (Lkt_Grammar_Dont_Skip);
         type Access_To_Subtype_For_Grammar_Dont_Skip is access all Subtype_For_Grammar_Dont_Skip;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Dont_Skip);
         package Bare_Grammar_Dont_Skip_Alloc is new Alloc
           (Subtype_For_Grammar_Dont_Skip, Access_To_Subtype_For_Grammar_Dont_Skip);

         function Allocate_Grammar_Dont_Skip
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Dont_Skip;

         function Allocate_Grammar_Dont_Skip
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Dont_Skip
         is
            Result      : constant Access_To_Subtype_For_Grammar_Dont_Skip := Bare_Grammar_Dont_Skip_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Dont_Skip;
            return Bare_Grammar_Dont_Skip (Result);
         end Allocate_Grammar_Dont_Skip;

      package Bare_Grammar_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_List, Token_Index);

         
         subtype Subtype_For_Grammar_List is
            Root_Node_Record (Lkt_Grammar_List);
         type Access_To_Subtype_For_Grammar_List is access all Subtype_For_Grammar_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_List);
         package Bare_Grammar_List_Alloc is new Alloc
           (Subtype_For_Grammar_List, Access_To_Subtype_For_Grammar_List);

         function Allocate_Grammar_List
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_List;

         function Allocate_Grammar_List
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_List
         is
            Result      : constant Access_To_Subtype_For_Grammar_List := Bare_Grammar_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_List;
            return Bare_Grammar_List (Result);
         end Allocate_Grammar_List;

      package Bare_Grammar_Null_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Null, Token_Index);

         
         subtype Subtype_For_Grammar_Null is
            Root_Node_Record (Lkt_Grammar_Null);
         type Access_To_Subtype_For_Grammar_Null is access all Subtype_For_Grammar_Null;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Null);
         package Bare_Grammar_Null_Alloc is new Alloc
           (Subtype_For_Grammar_Null, Access_To_Subtype_For_Grammar_Null);

         function Allocate_Grammar_Null
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Null;

         function Allocate_Grammar_Null
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Null
         is
            Result      : constant Access_To_Subtype_For_Grammar_Null := Bare_Grammar_Null_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Null;
            return Bare_Grammar_Null (Result);
         end Allocate_Grammar_Null;

      package Bare_Grammar_Opt_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Opt, Token_Index);

         
         subtype Subtype_For_Grammar_Opt is
            Root_Node_Record (Lkt_Grammar_Opt);
         type Access_To_Subtype_For_Grammar_Opt is access all Subtype_For_Grammar_Opt;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Opt);
         package Bare_Grammar_Opt_Alloc is new Alloc
           (Subtype_For_Grammar_Opt, Access_To_Subtype_For_Grammar_Opt);

         function Allocate_Grammar_Opt
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Opt;

         function Allocate_Grammar_Opt
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Opt
         is
            Result      : constant Access_To_Subtype_For_Grammar_Opt := Bare_Grammar_Opt_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Opt;
            return Bare_Grammar_Opt (Result);
         end Allocate_Grammar_Opt;

      package Bare_Grammar_Opt_Error_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Opt_Error, Token_Index);

         
         subtype Subtype_For_Grammar_Opt_Error is
            Root_Node_Record (Lkt_Grammar_Opt_Error);
         type Access_To_Subtype_For_Grammar_Opt_Error is access all Subtype_For_Grammar_Opt_Error;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Opt_Error);
         package Bare_Grammar_Opt_Error_Alloc is new Alloc
           (Subtype_For_Grammar_Opt_Error, Access_To_Subtype_For_Grammar_Opt_Error);

         function Allocate_Grammar_Opt_Error
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Opt_Error;

         function Allocate_Grammar_Opt_Error
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Opt_Error
         is
            Result      : constant Access_To_Subtype_For_Grammar_Opt_Error := Bare_Grammar_Opt_Error_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Opt_Error;
            return Bare_Grammar_Opt_Error (Result);
         end Allocate_Grammar_Opt_Error;

      package Bare_Grammar_Opt_Error_Group_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Opt_Error_Group, Token_Index);

         
         subtype Subtype_For_Grammar_Opt_Error_Group is
            Root_Node_Record (Lkt_Grammar_Opt_Error_Group);
         type Access_To_Subtype_For_Grammar_Opt_Error_Group is access all Subtype_For_Grammar_Opt_Error_Group;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Opt_Error_Group);
         package Bare_Grammar_Opt_Error_Group_Alloc is new Alloc
           (Subtype_For_Grammar_Opt_Error_Group, Access_To_Subtype_For_Grammar_Opt_Error_Group);

         function Allocate_Grammar_Opt_Error_Group
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Opt_Error_Group;

         function Allocate_Grammar_Opt_Error_Group
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Opt_Error_Group
         is
            Result      : constant Access_To_Subtype_For_Grammar_Opt_Error_Group := Bare_Grammar_Opt_Error_Group_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Opt_Error_Group;
            return Bare_Grammar_Opt_Error_Group (Result);
         end Allocate_Grammar_Opt_Error_Group;

      package Bare_Grammar_Opt_Group_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Opt_Group, Token_Index);

         
         subtype Subtype_For_Grammar_Opt_Group is
            Root_Node_Record (Lkt_Grammar_Opt_Group);
         type Access_To_Subtype_For_Grammar_Opt_Group is access all Subtype_For_Grammar_Opt_Group;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Opt_Group);
         package Bare_Grammar_Opt_Group_Alloc is new Alloc
           (Subtype_For_Grammar_Opt_Group, Access_To_Subtype_For_Grammar_Opt_Group);

         function Allocate_Grammar_Opt_Group
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Opt_Group;

         function Allocate_Grammar_Opt_Group
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Opt_Group
         is
            Result      : constant Access_To_Subtype_For_Grammar_Opt_Group := Bare_Grammar_Opt_Group_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Opt_Group;
            return Bare_Grammar_Opt_Group (Result);
         end Allocate_Grammar_Opt_Group;

      package Bare_Grammar_Or_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Or_Expr, Token_Index);

         
         subtype Subtype_For_Grammar_Or_Expr is
            Root_Node_Record (Lkt_Grammar_Or_Expr);
         type Access_To_Subtype_For_Grammar_Or_Expr is access all Subtype_For_Grammar_Or_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Or_Expr);
         package Bare_Grammar_Or_Expr_Alloc is new Alloc
           (Subtype_For_Grammar_Or_Expr, Access_To_Subtype_For_Grammar_Or_Expr);

         function Allocate_Grammar_Or_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Or_Expr;

         function Allocate_Grammar_Or_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Or_Expr
         is
            Result      : constant Access_To_Subtype_For_Grammar_Or_Expr := Bare_Grammar_Or_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Or_Expr;
            return Bare_Grammar_Or_Expr (Result);
         end Allocate_Grammar_Or_Expr;

      package Bare_Grammar_Pick_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Pick, Token_Index);

         
         subtype Subtype_For_Grammar_Pick is
            Root_Node_Record (Lkt_Grammar_Pick);
         type Access_To_Subtype_For_Grammar_Pick is access all Subtype_For_Grammar_Pick;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Pick);
         package Bare_Grammar_Pick_Alloc is new Alloc
           (Subtype_For_Grammar_Pick, Access_To_Subtype_For_Grammar_Pick);

         function Allocate_Grammar_Pick
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Pick;

         function Allocate_Grammar_Pick
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Pick
         is
            Result      : constant Access_To_Subtype_For_Grammar_Pick := Bare_Grammar_Pick_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Pick;
            return Bare_Grammar_Pick (Result);
         end Allocate_Grammar_Pick;

      package Bare_Grammar_Implicit_Pick_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Implicit_Pick, Token_Index);

         
         subtype Subtype_For_Grammar_Implicit_Pick is
            Root_Node_Record (Lkt_Grammar_Implicit_Pick);
         type Access_To_Subtype_For_Grammar_Implicit_Pick is access all Subtype_For_Grammar_Implicit_Pick;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Implicit_Pick);
         package Bare_Grammar_Implicit_Pick_Alloc is new Alloc
           (Subtype_For_Grammar_Implicit_Pick, Access_To_Subtype_For_Grammar_Implicit_Pick);

         function Allocate_Grammar_Implicit_Pick
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Implicit_Pick;

         function Allocate_Grammar_Implicit_Pick
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Implicit_Pick
         is
            Result      : constant Access_To_Subtype_For_Grammar_Implicit_Pick := Bare_Grammar_Implicit_Pick_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Implicit_Pick;
            return Bare_Grammar_Implicit_Pick (Result);
         end Allocate_Grammar_Implicit_Pick;

      package Bare_Grammar_Predicate_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Predicate, Token_Index);

         
         subtype Subtype_For_Grammar_Predicate is
            Root_Node_Record (Lkt_Grammar_Predicate);
         type Access_To_Subtype_For_Grammar_Predicate is access all Subtype_For_Grammar_Predicate;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Predicate);
         package Bare_Grammar_Predicate_Alloc is new Alloc
           (Subtype_For_Grammar_Predicate, Access_To_Subtype_For_Grammar_Predicate);

         function Allocate_Grammar_Predicate
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Predicate;

         function Allocate_Grammar_Predicate
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Predicate
         is
            Result      : constant Access_To_Subtype_For_Grammar_Predicate := Bare_Grammar_Predicate_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Predicate;
            return Bare_Grammar_Predicate (Result);
         end Allocate_Grammar_Predicate;

      package Bare_Grammar_Rule_Ref_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Rule_Ref, Token_Index);

         
         subtype Subtype_For_Grammar_Rule_Ref is
            Root_Node_Record (Lkt_Grammar_Rule_Ref);
         type Access_To_Subtype_For_Grammar_Rule_Ref is access all Subtype_For_Grammar_Rule_Ref;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Rule_Ref);
         package Bare_Grammar_Rule_Ref_Alloc is new Alloc
           (Subtype_For_Grammar_Rule_Ref, Access_To_Subtype_For_Grammar_Rule_Ref);

         function Allocate_Grammar_Rule_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Rule_Ref;

         function Allocate_Grammar_Rule_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Rule_Ref
         is
            Result      : constant Access_To_Subtype_For_Grammar_Rule_Ref := Bare_Grammar_Rule_Ref_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Rule_Ref;
            return Bare_Grammar_Rule_Ref (Result);
         end Allocate_Grammar_Rule_Ref;

      package Bare_Grammar_Skip_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Skip, Token_Index);

         
         subtype Subtype_For_Grammar_Skip is
            Root_Node_Record (Lkt_Grammar_Skip);
         type Access_To_Subtype_For_Grammar_Skip is access all Subtype_For_Grammar_Skip;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Skip);
         package Bare_Grammar_Skip_Alloc is new Alloc
           (Subtype_For_Grammar_Skip, Access_To_Subtype_For_Grammar_Skip);

         function Allocate_Grammar_Skip
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Skip;

         function Allocate_Grammar_Skip
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Skip
         is
            Result      : constant Access_To_Subtype_For_Grammar_Skip := Bare_Grammar_Skip_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Skip;
            return Bare_Grammar_Skip (Result);
         end Allocate_Grammar_Skip;

      package Bare_Grammar_Stop_Cut_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Stop_Cut, Token_Index);

         
         subtype Subtype_For_Grammar_Stop_Cut is
            Root_Node_Record (Lkt_Grammar_Stop_Cut);
         type Access_To_Subtype_For_Grammar_Stop_Cut is access all Subtype_For_Grammar_Stop_Cut;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Stop_Cut);
         package Bare_Grammar_Stop_Cut_Alloc is new Alloc
           (Subtype_For_Grammar_Stop_Cut, Access_To_Subtype_For_Grammar_Stop_Cut);

         function Allocate_Grammar_Stop_Cut
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Stop_Cut;

         function Allocate_Grammar_Stop_Cut
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Stop_Cut
         is
            Result      : constant Access_To_Subtype_For_Grammar_Stop_Cut := Bare_Grammar_Stop_Cut_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Stop_Cut;
            return Bare_Grammar_Stop_Cut (Result);
         end Allocate_Grammar_Stop_Cut;

      package Bare_Parse_Node_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Parse_Node_Expr, Token_Index);

         
         subtype Subtype_For_Parse_Node_Expr is
            Root_Node_Record (Lkt_Parse_Node_Expr);
         type Access_To_Subtype_For_Parse_Node_Expr is access all Subtype_For_Parse_Node_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Parse_Node_Expr);
         package Bare_Parse_Node_Expr_Alloc is new Alloc
           (Subtype_For_Parse_Node_Expr, Access_To_Subtype_For_Parse_Node_Expr);

         function Allocate_Parse_Node_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Parse_Node_Expr;

         function Allocate_Parse_Node_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Parse_Node_Expr
         is
            Result      : constant Access_To_Subtype_For_Parse_Node_Expr := Bare_Parse_Node_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Parse_Node_Expr;
            return Bare_Parse_Node_Expr (Result);
         end Allocate_Parse_Node_Expr;

      package Bare_Token_Lit_Memos is new Liblktlang_Support.Packrat
        (Bare_Token_Lit, Token_Index);

         
         subtype Subtype_For_Token_Lit is
            Root_Node_Record (Lkt_Token_Lit);
         type Access_To_Subtype_For_Token_Lit is access all Subtype_For_Token_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Token_Lit);
         package Bare_Token_Lit_Alloc is new Alloc
           (Subtype_For_Token_Lit, Access_To_Subtype_For_Token_Lit);

         function Allocate_Token_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Token_Lit;

         function Allocate_Token_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Token_Lit
         is
            Result      : constant Access_To_Subtype_For_Token_Lit := Bare_Token_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Token_Lit;
            return Bare_Token_Lit (Result);
         end Allocate_Token_Lit;

      package Bare_Token_No_Case_Lit_Memos is new Liblktlang_Support.Packrat
        (Bare_Token_No_Case_Lit, Token_Index);

         
         subtype Subtype_For_Token_No_Case_Lit is
            Root_Node_Record (Lkt_Token_No_Case_Lit);
         type Access_To_Subtype_For_Token_No_Case_Lit is access all Subtype_For_Token_No_Case_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Token_No_Case_Lit);
         package Bare_Token_No_Case_Lit_Alloc is new Alloc
           (Subtype_For_Token_No_Case_Lit, Access_To_Subtype_For_Token_No_Case_Lit);

         function Allocate_Token_No_Case_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Token_No_Case_Lit;

         function Allocate_Token_No_Case_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Token_No_Case_Lit
         is
            Result      : constant Access_To_Subtype_For_Token_No_Case_Lit := Bare_Token_No_Case_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Token_No_Case_Lit;
            return Bare_Token_No_Case_Lit (Result);
         end Allocate_Token_No_Case_Lit;

      package Bare_Token_Pattern_Concat_Memos is new Liblktlang_Support.Packrat
        (Bare_Token_Pattern_Concat, Token_Index);

         
         subtype Subtype_For_Token_Pattern_Concat is
            Root_Node_Record (Lkt_Token_Pattern_Concat);
         type Access_To_Subtype_For_Token_Pattern_Concat is access all Subtype_For_Token_Pattern_Concat;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Token_Pattern_Concat);
         package Bare_Token_Pattern_Concat_Alloc is new Alloc
           (Subtype_For_Token_Pattern_Concat, Access_To_Subtype_For_Token_Pattern_Concat);

         function Allocate_Token_Pattern_Concat
           (Pool : Bump_Ptr_Pool) return Bare_Token_Pattern_Concat;

         function Allocate_Token_Pattern_Concat
           (Pool : Bump_Ptr_Pool) return Bare_Token_Pattern_Concat
         is
            Result      : constant Access_To_Subtype_For_Token_Pattern_Concat := Bare_Token_Pattern_Concat_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Token_Pattern_Concat;
            return Bare_Token_Pattern_Concat (Result);
         end Allocate_Token_Pattern_Concat;

      package Bare_Token_Pattern_Lit_Memos is new Liblktlang_Support.Packrat
        (Bare_Token_Pattern_Lit, Token_Index);

         
         subtype Subtype_For_Token_Pattern_Lit is
            Root_Node_Record (Lkt_Token_Pattern_Lit);
         type Access_To_Subtype_For_Token_Pattern_Lit is access all Subtype_For_Token_Pattern_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Token_Pattern_Lit);
         package Bare_Token_Pattern_Lit_Alloc is new Alloc
           (Subtype_For_Token_Pattern_Lit, Access_To_Subtype_For_Token_Pattern_Lit);

         function Allocate_Token_Pattern_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Token_Pattern_Lit;

         function Allocate_Token_Pattern_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Token_Pattern_Lit
         is
            Result      : constant Access_To_Subtype_For_Token_Pattern_Lit := Bare_Token_Pattern_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Token_Pattern_Lit;
            return Bare_Token_Pattern_Lit (Result);
         end Allocate_Token_Pattern_Lit;

      package Bare_Token_Ref_Memos is new Liblktlang_Support.Packrat
        (Bare_Token_Ref, Token_Index);

         
         subtype Subtype_For_Token_Ref is
            Root_Node_Record (Lkt_Token_Ref);
         type Access_To_Subtype_For_Token_Ref is access all Subtype_For_Token_Ref;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Token_Ref);
         package Bare_Token_Ref_Alloc is new Alloc
           (Subtype_For_Token_Ref, Access_To_Subtype_For_Token_Ref);

         function Allocate_Token_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Token_Ref;

         function Allocate_Token_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Token_Ref
         is
            Result      : constant Access_To_Subtype_For_Token_Ref := Bare_Token_Ref_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Token_Ref;
            return Bare_Token_Ref (Result);
         end Allocate_Token_Ref;

      package Bare_Id_Memos is new Liblktlang_Support.Packrat
        (Bare_Id, Token_Index);

         
         subtype Subtype_For_Id is
            Root_Node_Record (Lkt_Id);
         type Access_To_Subtype_For_Id is access all Subtype_For_Id;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Id);
         package Bare_Id_Alloc is new Alloc
           (Subtype_For_Id, Access_To_Subtype_For_Id);

         function Allocate_Id
           (Pool : Bump_Ptr_Pool) return Bare_Id;

         function Allocate_Id
           (Pool : Bump_Ptr_Pool) return Bare_Id
         is
            Result      : constant Access_To_Subtype_For_Id := Bare_Id_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Id;
            return Bare_Id (Result);
         end Allocate_Id;

      package Bare_Def_Id_Memos is new Liblktlang_Support.Packrat
        (Bare_Def_Id, Token_Index);

         
         subtype Subtype_For_Def_Id is
            Root_Node_Record (Lkt_Def_Id);
         type Access_To_Subtype_For_Def_Id is access all Subtype_For_Def_Id;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Def_Id);
         package Bare_Def_Id_Alloc is new Alloc
           (Subtype_For_Def_Id, Access_To_Subtype_For_Def_Id);

         function Allocate_Def_Id
           (Pool : Bump_Ptr_Pool) return Bare_Def_Id;

         function Allocate_Def_Id
           (Pool : Bump_Ptr_Pool) return Bare_Def_Id
         is
            Result      : constant Access_To_Subtype_For_Def_Id := Bare_Def_Id_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Def_Id;
            return Bare_Def_Id (Result);
         end Allocate_Def_Id;

      package Bare_Module_Ref_Id_Memos is new Liblktlang_Support.Packrat
        (Bare_Module_Ref_Id, Token_Index);

         
         subtype Subtype_For_Module_Ref_Id is
            Root_Node_Record (Lkt_Module_Ref_Id);
         type Access_To_Subtype_For_Module_Ref_Id is access all Subtype_For_Module_Ref_Id;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Module_Ref_Id);
         package Bare_Module_Ref_Id_Alloc is new Alloc
           (Subtype_For_Module_Ref_Id, Access_To_Subtype_For_Module_Ref_Id);

         function Allocate_Module_Ref_Id
           (Pool : Bump_Ptr_Pool) return Bare_Module_Ref_Id;

         function Allocate_Module_Ref_Id
           (Pool : Bump_Ptr_Pool) return Bare_Module_Ref_Id
         is
            Result      : constant Access_To_Subtype_For_Module_Ref_Id := Bare_Module_Ref_Id_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Module_Ref_Id;
            return Bare_Module_Ref_Id (Result);
         end Allocate_Module_Ref_Id;

      package Bare_Ref_Id_Memos is new Liblktlang_Support.Packrat
        (Bare_Ref_Id, Token_Index);

         
         subtype Subtype_For_Ref_Id is
            Root_Node_Record (Lkt_Ref_Id);
         type Access_To_Subtype_For_Ref_Id is access all Subtype_For_Ref_Id;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Ref_Id);
         package Bare_Ref_Id_Alloc is new Alloc
           (Subtype_For_Ref_Id, Access_To_Subtype_For_Ref_Id);

         function Allocate_Ref_Id
           (Pool : Bump_Ptr_Pool) return Bare_Ref_Id;

         function Allocate_Ref_Id
           (Pool : Bump_Ptr_Pool) return Bare_Ref_Id
         is
            Result      : constant Access_To_Subtype_For_Ref_Id := Bare_Ref_Id_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Ref_Id;
            return Bare_Ref_Id (Result);
         end Allocate_Ref_Id;

      package Bare_If_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_If_Expr, Token_Index);

         
         subtype Subtype_For_If_Expr is
            Root_Node_Record (Lkt_If_Expr);
         type Access_To_Subtype_For_If_Expr is access all Subtype_For_If_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_If_Expr);
         package Bare_If_Expr_Alloc is new Alloc
           (Subtype_For_If_Expr, Access_To_Subtype_For_If_Expr);

         function Allocate_If_Expr
           (Pool : Bump_Ptr_Pool) return Bare_If_Expr;

         function Allocate_If_Expr
           (Pool : Bump_Ptr_Pool) return Bare_If_Expr
         is
            Result      : constant Access_To_Subtype_For_If_Expr := Bare_If_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_If_Expr;
            return Bare_If_Expr (Result);
         end Allocate_If_Expr;

      package Bare_Isa_Memos is new Liblktlang_Support.Packrat
        (Bare_Isa, Token_Index);

         
         subtype Subtype_For_Isa is
            Root_Node_Record (Lkt_Isa);
         type Access_To_Subtype_For_Isa is access all Subtype_For_Isa;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Isa);
         package Bare_Isa_Alloc is new Alloc
           (Subtype_For_Isa, Access_To_Subtype_For_Isa);

         function Allocate_Isa
           (Pool : Bump_Ptr_Pool) return Bare_Isa;

         function Allocate_Isa
           (Pool : Bump_Ptr_Pool) return Bare_Isa
         is
            Result      : constant Access_To_Subtype_For_Isa := Bare_Isa_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Isa;
            return Bare_Isa (Result);
         end Allocate_Isa;

      package Bare_Keep_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Keep_Expr, Token_Index);

         
         subtype Subtype_For_Keep_Expr is
            Root_Node_Record (Lkt_Keep_Expr);
         type Access_To_Subtype_For_Keep_Expr is access all Subtype_For_Keep_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Keep_Expr);
         package Bare_Keep_Expr_Alloc is new Alloc
           (Subtype_For_Keep_Expr, Access_To_Subtype_For_Keep_Expr);

         function Allocate_Keep_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Keep_Expr;

         function Allocate_Keep_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Keep_Expr
         is
            Result      : constant Access_To_Subtype_For_Keep_Expr := Bare_Keep_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Keep_Expr;
            return Bare_Keep_Expr (Result);
         end Allocate_Keep_Expr;

      package Bare_Lambda_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Lambda_Expr, Token_Index);

         
         subtype Subtype_For_Lambda_Expr is
            Root_Node_Record (Lkt_Lambda_Expr);
         type Access_To_Subtype_For_Lambda_Expr is access all Subtype_For_Lambda_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lambda_Expr);
         package Bare_Lambda_Expr_Alloc is new Alloc
           (Subtype_For_Lambda_Expr, Access_To_Subtype_For_Lambda_Expr);

         function Allocate_Lambda_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Lambda_Expr;

         function Allocate_Lambda_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Lambda_Expr
         is
            Result      : constant Access_To_Subtype_For_Lambda_Expr := Bare_Lambda_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lambda_Expr;
            return Bare_Lambda_Expr (Result);
         end Allocate_Lambda_Expr;

      package Bare_Lit_Memos is new Liblktlang_Support.Packrat
        (Bare_Lit, Token_Index);

      package Bare_Big_Num_Lit_Memos is new Liblktlang_Support.Packrat
        (Bare_Big_Num_Lit, Token_Index);

         
         subtype Subtype_For_Big_Num_Lit is
            Root_Node_Record (Lkt_Big_Num_Lit);
         type Access_To_Subtype_For_Big_Num_Lit is access all Subtype_For_Big_Num_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Big_Num_Lit);
         package Bare_Big_Num_Lit_Alloc is new Alloc
           (Subtype_For_Big_Num_Lit, Access_To_Subtype_For_Big_Num_Lit);

         function Allocate_Big_Num_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Big_Num_Lit;

         function Allocate_Big_Num_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Big_Num_Lit
         is
            Result      : constant Access_To_Subtype_For_Big_Num_Lit := Bare_Big_Num_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Big_Num_Lit;
            return Bare_Big_Num_Lit (Result);
         end Allocate_Big_Num_Lit;

      package Bare_Char_Lit_Memos is new Liblktlang_Support.Packrat
        (Bare_Char_Lit, Token_Index);

         
         subtype Subtype_For_Char_Lit is
            Root_Node_Record (Lkt_Char_Lit);
         type Access_To_Subtype_For_Char_Lit is access all Subtype_For_Char_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Char_Lit);
         package Bare_Char_Lit_Alloc is new Alloc
           (Subtype_For_Char_Lit, Access_To_Subtype_For_Char_Lit);

         function Allocate_Char_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Char_Lit;

         function Allocate_Char_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Char_Lit
         is
            Result      : constant Access_To_Subtype_For_Char_Lit := Bare_Char_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Char_Lit;
            return Bare_Char_Lit (Result);
         end Allocate_Char_Lit;

      package Bare_Null_Lit_Memos is new Liblktlang_Support.Packrat
        (Bare_Null_Lit, Token_Index);

         
         subtype Subtype_For_Null_Lit is
            Root_Node_Record (Lkt_Null_Lit);
         type Access_To_Subtype_For_Null_Lit is access all Subtype_For_Null_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Null_Lit);
         package Bare_Null_Lit_Alloc is new Alloc
           (Subtype_For_Null_Lit, Access_To_Subtype_For_Null_Lit);

         function Allocate_Null_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Null_Lit;

         function Allocate_Null_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Null_Lit
         is
            Result      : constant Access_To_Subtype_For_Null_Lit := Bare_Null_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Null_Lit;
            return Bare_Null_Lit (Result);
         end Allocate_Null_Lit;

      package Bare_Num_Lit_Memos is new Liblktlang_Support.Packrat
        (Bare_Num_Lit, Token_Index);

         
         subtype Subtype_For_Num_Lit is
            Root_Node_Record (Lkt_Num_Lit);
         type Access_To_Subtype_For_Num_Lit is access all Subtype_For_Num_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Num_Lit);
         package Bare_Num_Lit_Alloc is new Alloc
           (Subtype_For_Num_Lit, Access_To_Subtype_For_Num_Lit);

         function Allocate_Num_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Num_Lit;

         function Allocate_Num_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Num_Lit
         is
            Result      : constant Access_To_Subtype_For_Num_Lit := Bare_Num_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Num_Lit;
            return Bare_Num_Lit (Result);
         end Allocate_Num_Lit;

      package Bare_String_Lit_Memos is new Liblktlang_Support.Packrat
        (Bare_String_Lit, Token_Index);

      package Bare_Block_String_Lit_Memos is new Liblktlang_Support.Packrat
        (Bare_Block_String_Lit, Token_Index);

         
         subtype Subtype_For_Block_String_Lit is
            Root_Node_Record (Lkt_Block_String_Lit);
         type Access_To_Subtype_For_Block_String_Lit is access all Subtype_For_Block_String_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Block_String_Lit);
         package Bare_Block_String_Lit_Alloc is new Alloc
           (Subtype_For_Block_String_Lit, Access_To_Subtype_For_Block_String_Lit);

         function Allocate_Block_String_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Block_String_Lit;

         function Allocate_Block_String_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Block_String_Lit
         is
            Result      : constant Access_To_Subtype_For_Block_String_Lit := Bare_Block_String_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Block_String_Lit;
            return Bare_Block_String_Lit (Result);
         end Allocate_Block_String_Lit;

      package Bare_Single_Line_String_Lit_Memos is new Liblktlang_Support.Packrat
        (Bare_Single_Line_String_Lit, Token_Index);

         
         subtype Subtype_For_Single_Line_String_Lit is
            Root_Node_Record (Lkt_Single_Line_String_Lit);
         type Access_To_Subtype_For_Single_Line_String_Lit is access all Subtype_For_Single_Line_String_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Single_Line_String_Lit);
         package Bare_Single_Line_String_Lit_Alloc is new Alloc
           (Subtype_For_Single_Line_String_Lit, Access_To_Subtype_For_Single_Line_String_Lit);

         function Allocate_Single_Line_String_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Single_Line_String_Lit;

         function Allocate_Single_Line_String_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Single_Line_String_Lit
         is
            Result      : constant Access_To_Subtype_For_Single_Line_String_Lit := Bare_Single_Line_String_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Single_Line_String_Lit;
            return Bare_Single_Line_String_Lit (Result);
         end Allocate_Single_Line_String_Lit;

      package Bare_Pattern_Single_Line_String_Lit_Memos is new Liblktlang_Support.Packrat
        (Bare_Pattern_Single_Line_String_Lit, Token_Index);

         
         subtype Subtype_For_Pattern_Single_Line_String_Lit is
            Root_Node_Record (Lkt_Pattern_Single_Line_String_Lit);
         type Access_To_Subtype_For_Pattern_Single_Line_String_Lit is access all Subtype_For_Pattern_Single_Line_String_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Pattern_Single_Line_String_Lit);
         package Bare_Pattern_Single_Line_String_Lit_Alloc is new Alloc
           (Subtype_For_Pattern_Single_Line_String_Lit, Access_To_Subtype_For_Pattern_Single_Line_String_Lit);

         function Allocate_Pattern_Single_Line_String_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Pattern_Single_Line_String_Lit;

         function Allocate_Pattern_Single_Line_String_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Pattern_Single_Line_String_Lit
         is
            Result      : constant Access_To_Subtype_For_Pattern_Single_Line_String_Lit := Bare_Pattern_Single_Line_String_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Pattern_Single_Line_String_Lit;
            return Bare_Pattern_Single_Line_String_Lit (Result);
         end Allocate_Pattern_Single_Line_String_Lit;

      package Bare_Logic_Assign_Memos is new Liblktlang_Support.Packrat
        (Bare_Logic_Assign, Token_Index);

         
         subtype Subtype_For_Logic_Assign is
            Root_Node_Record (Lkt_Logic_Assign);
         type Access_To_Subtype_For_Logic_Assign is access all Subtype_For_Logic_Assign;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Logic_Assign);
         package Bare_Logic_Assign_Alloc is new Alloc
           (Subtype_For_Logic_Assign, Access_To_Subtype_For_Logic_Assign);

         function Allocate_Logic_Assign
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Assign;

         function Allocate_Logic_Assign
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Assign
         is
            Result      : constant Access_To_Subtype_For_Logic_Assign := Bare_Logic_Assign_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Logic_Assign;
            return Bare_Logic_Assign (Result);
         end Allocate_Logic_Assign;

      package Bare_Logic_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Logic_Expr, Token_Index);

         
         subtype Subtype_For_Logic_Expr is
            Root_Node_Record (Lkt_Logic_Expr);
         type Access_To_Subtype_For_Logic_Expr is access all Subtype_For_Logic_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Logic_Expr);
         package Bare_Logic_Expr_Alloc is new Alloc
           (Subtype_For_Logic_Expr, Access_To_Subtype_For_Logic_Expr);

         function Allocate_Logic_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Expr;

         function Allocate_Logic_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Expr
         is
            Result      : constant Access_To_Subtype_For_Logic_Expr := Bare_Logic_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Logic_Expr;
            return Bare_Logic_Expr (Result);
         end Allocate_Logic_Expr;

      package Bare_Logic_Propagate_Memos is new Liblktlang_Support.Packrat
        (Bare_Logic_Propagate, Token_Index);

         
         subtype Subtype_For_Logic_Propagate is
            Root_Node_Record (Lkt_Logic_Propagate);
         type Access_To_Subtype_For_Logic_Propagate is access all Subtype_For_Logic_Propagate;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Logic_Propagate);
         package Bare_Logic_Propagate_Alloc is new Alloc
           (Subtype_For_Logic_Propagate, Access_To_Subtype_For_Logic_Propagate);

         function Allocate_Logic_Propagate
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Propagate;

         function Allocate_Logic_Propagate
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Propagate
         is
            Result      : constant Access_To_Subtype_For_Logic_Propagate := Bare_Logic_Propagate_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Logic_Propagate;
            return Bare_Logic_Propagate (Result);
         end Allocate_Logic_Propagate;

      package Bare_Logic_Unify_Memos is new Liblktlang_Support.Packrat
        (Bare_Logic_Unify, Token_Index);

         
         subtype Subtype_For_Logic_Unify is
            Root_Node_Record (Lkt_Logic_Unify);
         type Access_To_Subtype_For_Logic_Unify is access all Subtype_For_Logic_Unify;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Logic_Unify);
         package Bare_Logic_Unify_Alloc is new Alloc
           (Subtype_For_Logic_Unify, Access_To_Subtype_For_Logic_Unify);

         function Allocate_Logic_Unify
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Unify;

         function Allocate_Logic_Unify
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Unify
         is
            Result      : constant Access_To_Subtype_For_Logic_Unify := Bare_Logic_Unify_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Logic_Unify;
            return Bare_Logic_Unify (Result);
         end Allocate_Logic_Unify;

      package Bare_Match_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Match_Expr, Token_Index);

         
         subtype Subtype_For_Match_Expr is
            Root_Node_Record (Lkt_Match_Expr);
         type Access_To_Subtype_For_Match_Expr is access all Subtype_For_Match_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Match_Expr);
         package Bare_Match_Expr_Alloc is new Alloc
           (Subtype_For_Match_Expr, Access_To_Subtype_For_Match_Expr);

         function Allocate_Match_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Match_Expr;

         function Allocate_Match_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Match_Expr
         is
            Result      : constant Access_To_Subtype_For_Match_Expr := Bare_Match_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Match_Expr;
            return Bare_Match_Expr (Result);
         end Allocate_Match_Expr;

      package Bare_Not_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Not_Expr, Token_Index);

         
         subtype Subtype_For_Not_Expr is
            Root_Node_Record (Lkt_Not_Expr);
         type Access_To_Subtype_For_Not_Expr is access all Subtype_For_Not_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Not_Expr);
         package Bare_Not_Expr_Alloc is new Alloc
           (Subtype_For_Not_Expr, Access_To_Subtype_For_Not_Expr);

         function Allocate_Not_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Not_Expr;

         function Allocate_Not_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Not_Expr
         is
            Result      : constant Access_To_Subtype_For_Not_Expr := Bare_Not_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Not_Expr;
            return Bare_Not_Expr (Result);
         end Allocate_Not_Expr;

      package Bare_Paren_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Paren_Expr, Token_Index);

         
         subtype Subtype_For_Paren_Expr is
            Root_Node_Record (Lkt_Paren_Expr);
         type Access_To_Subtype_For_Paren_Expr is access all Subtype_For_Paren_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Paren_Expr);
         package Bare_Paren_Expr_Alloc is new Alloc
           (Subtype_For_Paren_Expr, Access_To_Subtype_For_Paren_Expr);

         function Allocate_Paren_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Paren_Expr;

         function Allocate_Paren_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Paren_Expr
         is
            Result      : constant Access_To_Subtype_For_Paren_Expr := Bare_Paren_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Paren_Expr;
            return Bare_Paren_Expr (Result);
         end Allocate_Paren_Expr;

      package Bare_Raise_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Raise_Expr, Token_Index);

         
         subtype Subtype_For_Raise_Expr is
            Root_Node_Record (Lkt_Raise_Expr);
         type Access_To_Subtype_For_Raise_Expr is access all Subtype_For_Raise_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Raise_Expr);
         package Bare_Raise_Expr_Alloc is new Alloc
           (Subtype_For_Raise_Expr, Access_To_Subtype_For_Raise_Expr);

         function Allocate_Raise_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Raise_Expr;

         function Allocate_Raise_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Raise_Expr
         is
            Result      : constant Access_To_Subtype_For_Raise_Expr := Bare_Raise_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Raise_Expr;
            return Bare_Raise_Expr (Result);
         end Allocate_Raise_Expr;

      package Bare_Subscript_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Subscript_Expr, Token_Index);

         
         subtype Subtype_For_Subscript_Expr is
            Root_Node_Record (Lkt_Subscript_Expr);
         type Access_To_Subtype_For_Subscript_Expr is access all Subtype_For_Subscript_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Subscript_Expr);
         package Bare_Subscript_Expr_Alloc is new Alloc
           (Subtype_For_Subscript_Expr, Access_To_Subtype_For_Subscript_Expr);

         function Allocate_Subscript_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Subscript_Expr;

         function Allocate_Subscript_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Subscript_Expr
         is
            Result      : constant Access_To_Subtype_For_Subscript_Expr := Bare_Subscript_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Subscript_Expr;
            return Bare_Subscript_Expr (Result);
         end Allocate_Subscript_Expr;

      package Bare_Null_Cond_Subscript_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Null_Cond_Subscript_Expr, Token_Index);

         
         subtype Subtype_For_Null_Cond_Subscript_Expr is
            Root_Node_Record (Lkt_Null_Cond_Subscript_Expr);
         type Access_To_Subtype_For_Null_Cond_Subscript_Expr is access all Subtype_For_Null_Cond_Subscript_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Null_Cond_Subscript_Expr);
         package Bare_Null_Cond_Subscript_Expr_Alloc is new Alloc
           (Subtype_For_Null_Cond_Subscript_Expr, Access_To_Subtype_For_Null_Cond_Subscript_Expr);

         function Allocate_Null_Cond_Subscript_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Null_Cond_Subscript_Expr;

         function Allocate_Null_Cond_Subscript_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Null_Cond_Subscript_Expr
         is
            Result      : constant Access_To_Subtype_For_Null_Cond_Subscript_Expr := Bare_Null_Cond_Subscript_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Null_Cond_Subscript_Expr;
            return Bare_Null_Cond_Subscript_Expr (Result);
         end Allocate_Null_Cond_Subscript_Expr;

      package Bare_Try_Expr_Memos is new Liblktlang_Support.Packrat
        (Bare_Try_Expr, Token_Index);

         
         subtype Subtype_For_Try_Expr is
            Root_Node_Record (Lkt_Try_Expr);
         type Access_To_Subtype_For_Try_Expr is access all Subtype_For_Try_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Try_Expr);
         package Bare_Try_Expr_Alloc is new Alloc
           (Subtype_For_Try_Expr, Access_To_Subtype_For_Try_Expr);

         function Allocate_Try_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Try_Expr;

         function Allocate_Try_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Try_Expr
         is
            Result      : constant Access_To_Subtype_For_Try_Expr := Bare_Try_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Try_Expr;
            return Bare_Try_Expr (Result);
         end Allocate_Try_Expr;

      package Bare_Un_Op_Memos is new Liblktlang_Support.Packrat
        (Bare_Un_Op, Token_Index);

         
         subtype Subtype_For_Un_Op is
            Root_Node_Record (Lkt_Un_Op);
         type Access_To_Subtype_For_Un_Op is access all Subtype_For_Un_Op;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Un_Op);
         package Bare_Un_Op_Alloc is new Alloc
           (Subtype_For_Un_Op, Access_To_Subtype_For_Un_Op);

         function Allocate_Un_Op
           (Pool : Bump_Ptr_Pool) return Bare_Un_Op;

         function Allocate_Un_Op
           (Pool : Bump_Ptr_Pool) return Bare_Un_Op
         is
            Result      : constant Access_To_Subtype_For_Un_Op := Bare_Un_Op_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Un_Op;
            return Bare_Un_Op (Result);
         end Allocate_Un_Op;

      package Bare_Full_Decl_Memos is new Liblktlang_Support.Packrat
        (Bare_Full_Decl, Token_Index);

         
         subtype Subtype_For_Full_Decl is
            Root_Node_Record (Lkt_Full_Decl);
         type Access_To_Subtype_For_Full_Decl is access all Subtype_For_Full_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Full_Decl);
         package Bare_Full_Decl_Alloc is new Alloc
           (Subtype_For_Full_Decl, Access_To_Subtype_For_Full_Decl);

         function Allocate_Full_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Full_Decl;

         function Allocate_Full_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Full_Decl
         is
            Result      : constant Access_To_Subtype_For_Full_Decl := Bare_Full_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Full_Decl;
            return Bare_Full_Decl (Result);
         end Allocate_Full_Decl;

      package Bare_Grammar_List_Sep_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_List_Sep, Token_Index);

         
         subtype Subtype_For_Grammar_List_Sep is
            Root_Node_Record (Lkt_Grammar_List_Sep);
         type Access_To_Subtype_For_Grammar_List_Sep is access all Subtype_For_Grammar_List_Sep;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_List_Sep);
         package Bare_Grammar_List_Sep_Alloc is new Alloc
           (Subtype_For_Grammar_List_Sep, Access_To_Subtype_For_Grammar_List_Sep);

         function Allocate_Grammar_List_Sep
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_List_Sep;

         function Allocate_Grammar_List_Sep
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_List_Sep
         is
            Result      : constant Access_To_Subtype_For_Grammar_List_Sep := Bare_Grammar_List_Sep_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_List_Sep;
            return Bare_Grammar_List_Sep (Result);
         end Allocate_Grammar_List_Sep;

      package Bare_Import_Memos is new Liblktlang_Support.Packrat
        (Bare_Import, Token_Index);

         
         subtype Subtype_For_Import is
            Root_Node_Record (Lkt_Import);
         type Access_To_Subtype_For_Import is access all Subtype_For_Import;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Import);
         package Bare_Import_Alloc is new Alloc
           (Subtype_For_Import, Access_To_Subtype_For_Import);

         function Allocate_Import
           (Pool : Bump_Ptr_Pool) return Bare_Import;

         function Allocate_Import
           (Pool : Bump_Ptr_Pool) return Bare_Import
         is
            Result      : constant Access_To_Subtype_For_Import := Bare_Import_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Import;
            return Bare_Import (Result);
         end Allocate_Import;

      package Bare_Langkit_Root_Memos is new Liblktlang_Support.Packrat
        (Bare_Langkit_Root, Token_Index);

         
         subtype Subtype_For_Langkit_Root is
            Root_Node_Record (Lkt_Langkit_Root);
         type Access_To_Subtype_For_Langkit_Root is access all Subtype_For_Langkit_Root;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Langkit_Root);
         package Bare_Langkit_Root_Alloc is new Alloc
           (Subtype_For_Langkit_Root, Access_To_Subtype_For_Langkit_Root);

         function Allocate_Langkit_Root
           (Pool : Bump_Ptr_Pool) return Bare_Langkit_Root;

         function Allocate_Langkit_Root
           (Pool : Bump_Ptr_Pool) return Bare_Langkit_Root
         is
            Result      : constant Access_To_Subtype_For_Langkit_Root := Bare_Langkit_Root_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Langkit_Root;
            return Bare_Langkit_Root (Result);
         end Allocate_Langkit_Root;

      package Bare_Lexer_Case_Rule_Memos is new Liblktlang_Support.Packrat
        (Bare_Lexer_Case_Rule, Token_Index);

         
         subtype Subtype_For_Lexer_Case_Rule is
            Root_Node_Record (Lkt_Lexer_Case_Rule);
         type Access_To_Subtype_For_Lexer_Case_Rule is access all Subtype_For_Lexer_Case_Rule;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lexer_Case_Rule);
         package Bare_Lexer_Case_Rule_Alloc is new Alloc
           (Subtype_For_Lexer_Case_Rule, Access_To_Subtype_For_Lexer_Case_Rule);

         function Allocate_Lexer_Case_Rule
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Case_Rule;

         function Allocate_Lexer_Case_Rule
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Case_Rule
         is
            Result      : constant Access_To_Subtype_For_Lexer_Case_Rule := Bare_Lexer_Case_Rule_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lexer_Case_Rule;
            return Bare_Lexer_Case_Rule (Result);
         end Allocate_Lexer_Case_Rule;

      package Bare_Lexer_Case_Rule_Send_Memos is new Liblktlang_Support.Packrat
        (Bare_Lexer_Case_Rule_Send, Token_Index);

         
         subtype Subtype_For_Lexer_Case_Rule_Send is
            Root_Node_Record (Lkt_Lexer_Case_Rule_Send);
         type Access_To_Subtype_For_Lexer_Case_Rule_Send is access all Subtype_For_Lexer_Case_Rule_Send;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lexer_Case_Rule_Send);
         package Bare_Lexer_Case_Rule_Send_Alloc is new Alloc
           (Subtype_For_Lexer_Case_Rule_Send, Access_To_Subtype_For_Lexer_Case_Rule_Send);

         function Allocate_Lexer_Case_Rule_Send
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Case_Rule_Send;

         function Allocate_Lexer_Case_Rule_Send
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Case_Rule_Send
         is
            Result      : constant Access_To_Subtype_For_Lexer_Case_Rule_Send := Bare_Lexer_Case_Rule_Send_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lexer_Case_Rule_Send;
            return Bare_Lexer_Case_Rule_Send (Result);
         end Allocate_Lexer_Case_Rule_Send;

      package Bare_List_Kind_Memos is new Liblktlang_Support.Packrat
        (Bare_List_Kind, Token_Index);

      package Bare_List_Kind_One_Memos is new Liblktlang_Support.Packrat
        (Bare_List_Kind_One, Token_Index);

         
         subtype Subtype_For_List_Kind_One is
            Root_Node_Record (Lkt_List_Kind_One);
         type Access_To_Subtype_For_List_Kind_One is access all Subtype_For_List_Kind_One;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_List_Kind_One);
         package Bare_List_Kind_One_Alloc is new Alloc
           (Subtype_For_List_Kind_One, Access_To_Subtype_For_List_Kind_One);

         function Allocate_List_Kind_One
           (Pool : Bump_Ptr_Pool) return Bare_List_Kind_One;

         function Allocate_List_Kind_One
           (Pool : Bump_Ptr_Pool) return Bare_List_Kind_One
         is
            Result      : constant Access_To_Subtype_For_List_Kind_One := Bare_List_Kind_One_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_List_Kind_One;
            return Bare_List_Kind_One (Result);
         end Allocate_List_Kind_One;

      package Bare_List_Kind_Zero_Memos is new Liblktlang_Support.Packrat
        (Bare_List_Kind_Zero, Token_Index);

         
         subtype Subtype_For_List_Kind_Zero is
            Root_Node_Record (Lkt_List_Kind_Zero);
         type Access_To_Subtype_For_List_Kind_Zero is access all Subtype_For_List_Kind_Zero;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_List_Kind_Zero);
         package Bare_List_Kind_Zero_Alloc is new Alloc
           (Subtype_For_List_Kind_Zero, Access_To_Subtype_For_List_Kind_Zero);

         function Allocate_List_Kind_Zero
           (Pool : Bump_Ptr_Pool) return Bare_List_Kind_Zero;

         function Allocate_List_Kind_Zero
           (Pool : Bump_Ptr_Pool) return Bare_List_Kind_Zero
         is
            Result      : constant Access_To_Subtype_For_List_Kind_Zero := Bare_List_Kind_Zero_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_List_Kind_Zero;
            return Bare_List_Kind_Zero (Result);
         end Allocate_List_Kind_Zero;

      package Bare_Lkt_Node_Base_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Lkt_Node_Base_List, Token_Index);

      package Bare_Base_Lexer_Case_Rule_Alt_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Base_Lexer_Case_Rule_Alt_List, Token_Index);

         
         subtype Subtype_For_Base_Lexer_Case_Rule_Alt_List is
            Root_Node_Record (Lkt_Base_Lexer_Case_Rule_Alt_List);
         type Access_To_Subtype_For_Base_Lexer_Case_Rule_Alt_List is access all Subtype_For_Base_Lexer_Case_Rule_Alt_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Base_Lexer_Case_Rule_Alt_List);
         package Bare_Base_Lexer_Case_Rule_Alt_List_Alloc is new Alloc
           (Subtype_For_Base_Lexer_Case_Rule_Alt_List, Access_To_Subtype_For_Base_Lexer_Case_Rule_Alt_List);

         function Allocate_Base_Lexer_Case_Rule_Alt_List
           (Pool : Bump_Ptr_Pool) return Bare_Base_Lexer_Case_Rule_Alt_List;

         function Allocate_Base_Lexer_Case_Rule_Alt_List
           (Pool : Bump_Ptr_Pool) return Bare_Base_Lexer_Case_Rule_Alt_List
         is
            Result      : constant Access_To_Subtype_For_Base_Lexer_Case_Rule_Alt_List := Bare_Base_Lexer_Case_Rule_Alt_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Base_Lexer_Case_Rule_Alt_List;
            return Bare_Base_Lexer_Case_Rule_Alt_List (Result);
         end Allocate_Base_Lexer_Case_Rule_Alt_List;

      package Bare_Block_String_Line_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Block_String_Line_List, Token_Index);

         
         subtype Subtype_For_Block_String_Line_List is
            Root_Node_Record (Lkt_Block_String_Line_List);
         type Access_To_Subtype_For_Block_String_Line_List is access all Subtype_For_Block_String_Line_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Block_String_Line_List);
         package Bare_Block_String_Line_List_Alloc is new Alloc
           (Subtype_For_Block_String_Line_List, Access_To_Subtype_For_Block_String_Line_List);

         function Allocate_Block_String_Line_List
           (Pool : Bump_Ptr_Pool) return Bare_Block_String_Line_List;

         function Allocate_Block_String_Line_List
           (Pool : Bump_Ptr_Pool) return Bare_Block_String_Line_List
         is
            Result      : constant Access_To_Subtype_For_Block_String_Line_List := Bare_Block_String_Line_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Block_String_Line_List;
            return Bare_Block_String_Line_List (Result);
         end Allocate_Block_String_Line_List;

      package Bare_Call_Expr_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Call_Expr_List, Token_Index);

         
         subtype Subtype_For_Call_Expr_List is
            Root_Node_Record (Lkt_Call_Expr_List);
         type Access_To_Subtype_For_Call_Expr_List is access all Subtype_For_Call_Expr_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Call_Expr_List);
         package Bare_Call_Expr_List_Alloc is new Alloc
           (Subtype_For_Call_Expr_List, Access_To_Subtype_For_Call_Expr_List);

         function Allocate_Call_Expr_List
           (Pool : Bump_Ptr_Pool) return Bare_Call_Expr_List;

         function Allocate_Call_Expr_List
           (Pool : Bump_Ptr_Pool) return Bare_Call_Expr_List
         is
            Result      : constant Access_To_Subtype_For_Call_Expr_List := Bare_Call_Expr_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Call_Expr_List;
            return Bare_Call_Expr_List (Result);
         end Allocate_Call_Expr_List;

      package Bare_Decl_Annotation_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Decl_Annotation_List, Token_Index);

         
         subtype Subtype_For_Decl_Annotation_List is
            Root_Node_Record (Lkt_Decl_Annotation_List);
         type Access_To_Subtype_For_Decl_Annotation_List is access all Subtype_For_Decl_Annotation_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Decl_Annotation_List);
         package Bare_Decl_Annotation_List_Alloc is new Alloc
           (Subtype_For_Decl_Annotation_List, Access_To_Subtype_For_Decl_Annotation_List);

         function Allocate_Decl_Annotation_List
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Annotation_List;

         function Allocate_Decl_Annotation_List
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Annotation_List
         is
            Result      : constant Access_To_Subtype_For_Decl_Annotation_List := Bare_Decl_Annotation_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Decl_Annotation_List;
            return Bare_Decl_Annotation_List (Result);
         end Allocate_Decl_Annotation_List;

      package Bare_Elsif_Branch_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Elsif_Branch_List, Token_Index);

         
         subtype Subtype_For_Elsif_Branch_List is
            Root_Node_Record (Lkt_Elsif_Branch_List);
         type Access_To_Subtype_For_Elsif_Branch_List is access all Subtype_For_Elsif_Branch_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Elsif_Branch_List);
         package Bare_Elsif_Branch_List_Alloc is new Alloc
           (Subtype_For_Elsif_Branch_List, Access_To_Subtype_For_Elsif_Branch_List);

         function Allocate_Elsif_Branch_List
           (Pool : Bump_Ptr_Pool) return Bare_Elsif_Branch_List;

         function Allocate_Elsif_Branch_List
           (Pool : Bump_Ptr_Pool) return Bare_Elsif_Branch_List
         is
            Result      : constant Access_To_Subtype_For_Elsif_Branch_List := Bare_Elsif_Branch_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Elsif_Branch_List;
            return Bare_Elsif_Branch_List (Result);
         end Allocate_Elsif_Branch_List;

      package Bare_Enum_Class_Alt_Decl_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Enum_Class_Alt_Decl_List, Token_Index);

         
         subtype Subtype_For_Enum_Class_Alt_Decl_List is
            Root_Node_Record (Lkt_Enum_Class_Alt_Decl_List);
         type Access_To_Subtype_For_Enum_Class_Alt_Decl_List is access all Subtype_For_Enum_Class_Alt_Decl_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Enum_Class_Alt_Decl_List);
         package Bare_Enum_Class_Alt_Decl_List_Alloc is new Alloc
           (Subtype_For_Enum_Class_Alt_Decl_List, Access_To_Subtype_For_Enum_Class_Alt_Decl_List);

         function Allocate_Enum_Class_Alt_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Alt_Decl_List;

         function Allocate_Enum_Class_Alt_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Alt_Decl_List
         is
            Result      : constant Access_To_Subtype_For_Enum_Class_Alt_Decl_List := Bare_Enum_Class_Alt_Decl_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Enum_Class_Alt_Decl_List;
            return Bare_Enum_Class_Alt_Decl_List (Result);
         end Allocate_Enum_Class_Alt_Decl_List;

      package Bare_Enum_Class_Case_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Enum_Class_Case_List, Token_Index);

         
         subtype Subtype_For_Enum_Class_Case_List is
            Root_Node_Record (Lkt_Enum_Class_Case_List);
         type Access_To_Subtype_For_Enum_Class_Case_List is access all Subtype_For_Enum_Class_Case_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Enum_Class_Case_List);
         package Bare_Enum_Class_Case_List_Alloc is new Alloc
           (Subtype_For_Enum_Class_Case_List, Access_To_Subtype_For_Enum_Class_Case_List);

         function Allocate_Enum_Class_Case_List
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Case_List;

         function Allocate_Enum_Class_Case_List
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Case_List
         is
            Result      : constant Access_To_Subtype_For_Enum_Class_Case_List := Bare_Enum_Class_Case_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Enum_Class_Case_List;
            return Bare_Enum_Class_Case_List (Result);
         end Allocate_Enum_Class_Case_List;

      package Bare_Enum_Lit_Decl_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Enum_Lit_Decl_List, Token_Index);

         
         subtype Subtype_For_Enum_Lit_Decl_List is
            Root_Node_Record (Lkt_Enum_Lit_Decl_List);
         type Access_To_Subtype_For_Enum_Lit_Decl_List is access all Subtype_For_Enum_Lit_Decl_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Enum_Lit_Decl_List);
         package Bare_Enum_Lit_Decl_List_Alloc is new Alloc
           (Subtype_For_Enum_Lit_Decl_List, Access_To_Subtype_For_Enum_Lit_Decl_List);

         function Allocate_Enum_Lit_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Lit_Decl_List;

         function Allocate_Enum_Lit_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Lit_Decl_List
         is
            Result      : constant Access_To_Subtype_For_Enum_Lit_Decl_List := Bare_Enum_Lit_Decl_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Enum_Lit_Decl_List;
            return Bare_Enum_Lit_Decl_List (Result);
         end Allocate_Enum_Lit_Decl_List;

      package Bare_Expr_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Expr_List, Token_Index);

         
         subtype Subtype_For_Expr_List is
            Root_Node_Record (Lkt_Expr_List);
         type Access_To_Subtype_For_Expr_List is access all Subtype_For_Expr_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Expr_List);
         package Bare_Expr_List_Alloc is new Alloc
           (Subtype_For_Expr_List, Access_To_Subtype_For_Expr_List);

         function Allocate_Expr_List
           (Pool : Bump_Ptr_Pool) return Bare_Expr_List;

         function Allocate_Expr_List
           (Pool : Bump_Ptr_Pool) return Bare_Expr_List
         is
            Result      : constant Access_To_Subtype_For_Expr_List := Bare_Expr_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Expr_List;
            return Bare_Expr_List (Result);
         end Allocate_Expr_List;

      package Bare_Any_Of_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Any_Of_List, Token_Index);

         
         subtype Subtype_For_Any_Of_List is
            Root_Node_Record (Lkt_Any_Of_List);
         type Access_To_Subtype_For_Any_Of_List is access all Subtype_For_Any_Of_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Any_Of_List);
         package Bare_Any_Of_List_Alloc is new Alloc
           (Subtype_For_Any_Of_List, Access_To_Subtype_For_Any_Of_List);

         function Allocate_Any_Of_List
           (Pool : Bump_Ptr_Pool) return Bare_Any_Of_List;

         function Allocate_Any_Of_List
           (Pool : Bump_Ptr_Pool) return Bare_Any_Of_List
         is
            Result      : constant Access_To_Subtype_For_Any_Of_List := Bare_Any_Of_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Any_Of_List;
            return Bare_Any_Of_List (Result);
         end Allocate_Any_Of_List;

      package Bare_Full_Decl_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Full_Decl_List, Token_Index);

         
         subtype Subtype_For_Full_Decl_List is
            Root_Node_Record (Lkt_Full_Decl_List);
         type Access_To_Subtype_For_Full_Decl_List is access all Subtype_For_Full_Decl_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Full_Decl_List);
         package Bare_Full_Decl_List_Alloc is new Alloc
           (Subtype_For_Full_Decl_List, Access_To_Subtype_For_Full_Decl_List);

         function Allocate_Full_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Full_Decl_List;

         function Allocate_Full_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Full_Decl_List
         is
            Result      : constant Access_To_Subtype_For_Full_Decl_List := Bare_Full_Decl_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Full_Decl_List;
            return Bare_Full_Decl_List (Result);
         end Allocate_Full_Decl_List;

      package Bare_Decl_Block_Memos is new Liblktlang_Support.Packrat
        (Bare_Decl_Block, Token_Index);

         
         subtype Subtype_For_Decl_Block is
            Root_Node_Record (Lkt_Decl_Block);
         type Access_To_Subtype_For_Decl_Block is access all Subtype_For_Decl_Block;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Decl_Block);
         package Bare_Decl_Block_Alloc is new Alloc
           (Subtype_For_Decl_Block, Access_To_Subtype_For_Decl_Block);

         function Allocate_Decl_Block
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Block;

         function Allocate_Decl_Block
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Block
         is
            Result      : constant Access_To_Subtype_For_Decl_Block := Bare_Decl_Block_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Decl_Block;
            return Bare_Decl_Block (Result);
         end Allocate_Decl_Block;

      package Bare_Generic_Formal_Decl_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Generic_Formal_Decl_List, Token_Index);

         
         subtype Subtype_For_Generic_Formal_Decl_List is
            Root_Node_Record (Lkt_Generic_Formal_Decl_List);
         type Access_To_Subtype_For_Generic_Formal_Decl_List is access all Subtype_For_Generic_Formal_Decl_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Generic_Formal_Decl_List);
         package Bare_Generic_Formal_Decl_List_Alloc is new Alloc
           (Subtype_For_Generic_Formal_Decl_List, Access_To_Subtype_For_Generic_Formal_Decl_List);

         function Allocate_Generic_Formal_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Decl_List;

         function Allocate_Generic_Formal_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Formal_Decl_List
         is
            Result      : constant Access_To_Subtype_For_Generic_Formal_Decl_List := Bare_Generic_Formal_Decl_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Generic_Formal_Decl_List;
            return Bare_Generic_Formal_Decl_List (Result);
         end Allocate_Generic_Formal_Decl_List;

      package Bare_Fun_Arg_Decl_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Fun_Arg_Decl_List, Token_Index);

         
         subtype Subtype_For_Fun_Arg_Decl_List is
            Root_Node_Record (Lkt_Fun_Arg_Decl_List);
         type Access_To_Subtype_For_Fun_Arg_Decl_List is access all Subtype_For_Fun_Arg_Decl_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Fun_Arg_Decl_List);
         package Bare_Fun_Arg_Decl_List_Alloc is new Alloc
           (Subtype_For_Fun_Arg_Decl_List, Access_To_Subtype_For_Fun_Arg_Decl_List);

         function Allocate_Fun_Arg_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Fun_Arg_Decl_List;

         function Allocate_Fun_Arg_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Fun_Arg_Decl_List
         is
            Result      : constant Access_To_Subtype_For_Fun_Arg_Decl_List := Bare_Fun_Arg_Decl_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Fun_Arg_Decl_List;
            return Bare_Fun_Arg_Decl_List (Result);
         end Allocate_Fun_Arg_Decl_List;

      package Bare_Grammar_Expr_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Expr_List, Token_Index);

         
         subtype Subtype_For_Grammar_Expr_List is
            Root_Node_Record (Lkt_Grammar_Expr_List);
         type Access_To_Subtype_For_Grammar_Expr_List is access all Subtype_For_Grammar_Expr_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Expr_List);
         package Bare_Grammar_Expr_List_Alloc is new Alloc
           (Subtype_For_Grammar_Expr_List, Access_To_Subtype_For_Grammar_Expr_List);

         function Allocate_Grammar_Expr_List
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Expr_List;

         function Allocate_Grammar_Expr_List
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Expr_List
         is
            Result      : constant Access_To_Subtype_For_Grammar_Expr_List := Bare_Grammar_Expr_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Expr_List;
            return Bare_Grammar_Expr_List (Result);
         end Allocate_Grammar_Expr_List;

      package Bare_Grammar_Expr_List_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Grammar_Expr_List_List, Token_Index);

         
         subtype Subtype_For_Grammar_Expr_List_List is
            Root_Node_Record (Lkt_Grammar_Expr_List_List);
         type Access_To_Subtype_For_Grammar_Expr_List_List is access all Subtype_For_Grammar_Expr_List_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Expr_List_List);
         package Bare_Grammar_Expr_List_List_Alloc is new Alloc
           (Subtype_For_Grammar_Expr_List_List, Access_To_Subtype_For_Grammar_Expr_List_List);

         function Allocate_Grammar_Expr_List_List
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Expr_List_List;

         function Allocate_Grammar_Expr_List_List
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Expr_List_List
         is
            Result      : constant Access_To_Subtype_For_Grammar_Expr_List_List := Bare_Grammar_Expr_List_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Expr_List_List;
            return Bare_Grammar_Expr_List_List (Result);
         end Allocate_Grammar_Expr_List_List;

      package Bare_Import_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Import_List, Token_Index);

         
         subtype Subtype_For_Import_List is
            Root_Node_Record (Lkt_Import_List);
         type Access_To_Subtype_For_Import_List is access all Subtype_For_Import_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Import_List);
         package Bare_Import_List_Alloc is new Alloc
           (Subtype_For_Import_List, Access_To_Subtype_For_Import_List);

         function Allocate_Import_List
           (Pool : Bump_Ptr_Pool) return Bare_Import_List;

         function Allocate_Import_List
           (Pool : Bump_Ptr_Pool) return Bare_Import_List
         is
            Result      : constant Access_To_Subtype_For_Import_List := Bare_Import_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Import_List;
            return Bare_Import_List (Result);
         end Allocate_Import_List;

      package Bare_Lambda_Arg_Decl_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Lambda_Arg_Decl_List, Token_Index);

         
         subtype Subtype_For_Lambda_Arg_Decl_List is
            Root_Node_Record (Lkt_Lambda_Arg_Decl_List);
         type Access_To_Subtype_For_Lambda_Arg_Decl_List is access all Subtype_For_Lambda_Arg_Decl_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lambda_Arg_Decl_List);
         package Bare_Lambda_Arg_Decl_List_Alloc is new Alloc
           (Subtype_For_Lambda_Arg_Decl_List, Access_To_Subtype_For_Lambda_Arg_Decl_List);

         function Allocate_Lambda_Arg_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Lambda_Arg_Decl_List;

         function Allocate_Lambda_Arg_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Lambda_Arg_Decl_List
         is
            Result      : constant Access_To_Subtype_For_Lambda_Arg_Decl_List := Bare_Lambda_Arg_Decl_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lambda_Arg_Decl_List;
            return Bare_Lambda_Arg_Decl_List (Result);
         end Allocate_Lambda_Arg_Decl_List;

      package Bare_Lkt_Node_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Lkt_Node_List, Token_Index);

         
         subtype Subtype_For_Lkt_Node_List is
            Root_Node_Record (Lkt_Lkt_Node_List);
         type Access_To_Subtype_For_Lkt_Node_List is access all Subtype_For_Lkt_Node_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lkt_Node_List);
         package Bare_Lkt_Node_List_Alloc is new Alloc
           (Subtype_For_Lkt_Node_List, Access_To_Subtype_For_Lkt_Node_List);

         function Allocate_Lkt_Node_List
           (Pool : Bump_Ptr_Pool) return Bare_Lkt_Node_List;

         function Allocate_Lkt_Node_List
           (Pool : Bump_Ptr_Pool) return Bare_Lkt_Node_List
         is
            Result      : constant Access_To_Subtype_For_Lkt_Node_List := Bare_Lkt_Node_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lkt_Node_List;
            return Bare_Lkt_Node_List (Result);
         end Allocate_Lkt_Node_List;

      package Bare_Block_Decl_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Block_Decl_List, Token_Index);

         
         subtype Subtype_For_Block_Decl_List is
            Root_Node_Record (Lkt_Block_Decl_List);
         type Access_To_Subtype_For_Block_Decl_List is access all Subtype_For_Block_Decl_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Block_Decl_List);
         package Bare_Block_Decl_List_Alloc is new Alloc
           (Subtype_For_Block_Decl_List, Access_To_Subtype_For_Block_Decl_List);

         function Allocate_Block_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Block_Decl_List;

         function Allocate_Block_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Block_Decl_List
         is
            Result      : constant Access_To_Subtype_For_Block_Decl_List := Bare_Block_Decl_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Block_Decl_List;
            return Bare_Block_Decl_List (Result);
         end Allocate_Block_Decl_List;

      package Bare_Match_Branch_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Match_Branch_List, Token_Index);

         
         subtype Subtype_For_Match_Branch_List is
            Root_Node_Record (Lkt_Match_Branch_List);
         type Access_To_Subtype_For_Match_Branch_List is access all Subtype_For_Match_Branch_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Match_Branch_List);
         package Bare_Match_Branch_List_Alloc is new Alloc
           (Subtype_For_Match_Branch_List, Access_To_Subtype_For_Match_Branch_List);

         function Allocate_Match_Branch_List
           (Pool : Bump_Ptr_Pool) return Bare_Match_Branch_List;

         function Allocate_Match_Branch_List
           (Pool : Bump_Ptr_Pool) return Bare_Match_Branch_List
         is
            Result      : constant Access_To_Subtype_For_Match_Branch_List := Bare_Match_Branch_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Match_Branch_List;
            return Bare_Match_Branch_List (Result);
         end Allocate_Match_Branch_List;

      package Bare_Param_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Param_List, Token_Index);

         
         subtype Subtype_For_Param_List is
            Root_Node_Record (Lkt_Param_List);
         type Access_To_Subtype_For_Param_List is access all Subtype_For_Param_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Param_List);
         package Bare_Param_List_Alloc is new Alloc
           (Subtype_For_Param_List, Access_To_Subtype_For_Param_List);

         function Allocate_Param_List
           (Pool : Bump_Ptr_Pool) return Bare_Param_List;

         function Allocate_Param_List
           (Pool : Bump_Ptr_Pool) return Bare_Param_List
         is
            Result      : constant Access_To_Subtype_For_Param_List := Bare_Param_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Param_List;
            return Bare_Param_List (Result);
         end Allocate_Param_List;

      package Bare_Ref_Id_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Ref_Id_List, Token_Index);

         
         subtype Subtype_For_Ref_Id_List is
            Root_Node_Record (Lkt_Ref_Id_List);
         type Access_To_Subtype_For_Ref_Id_List is access all Subtype_For_Ref_Id_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Ref_Id_List);
         package Bare_Ref_Id_List_Alloc is new Alloc
           (Subtype_For_Ref_Id_List, Access_To_Subtype_For_Ref_Id_List);

         function Allocate_Ref_Id_List
           (Pool : Bump_Ptr_Pool) return Bare_Ref_Id_List;

         function Allocate_Ref_Id_List
           (Pool : Bump_Ptr_Pool) return Bare_Ref_Id_List
         is
            Result      : constant Access_To_Subtype_For_Ref_Id_List := Bare_Ref_Id_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Ref_Id_List;
            return Bare_Ref_Id_List (Result);
         end Allocate_Ref_Id_List;

      package Bare_Type_Ref_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Type_Ref_List, Token_Index);

         
         subtype Subtype_For_Type_Ref_List is
            Root_Node_Record (Lkt_Type_Ref_List);
         type Access_To_Subtype_For_Type_Ref_List is access all Subtype_For_Type_Ref_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Type_Ref_List);
         package Bare_Type_Ref_List_Alloc is new Alloc
           (Subtype_For_Type_Ref_List, Access_To_Subtype_For_Type_Ref_List);

         function Allocate_Type_Ref_List
           (Pool : Bump_Ptr_Pool) return Bare_Type_Ref_List;

         function Allocate_Type_Ref_List
           (Pool : Bump_Ptr_Pool) return Bare_Type_Ref_List
         is
            Result      : constant Access_To_Subtype_For_Type_Ref_List := Bare_Type_Ref_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Type_Ref_List;
            return Bare_Type_Ref_List (Result);
         end Allocate_Type_Ref_List;

      package Bare_Isa_List_Memos is new Liblktlang_Support.Packrat
        (Bare_Isa_List, Token_Index);

         
         subtype Subtype_For_Isa_List is
            Root_Node_Record (Lkt_Isa_List);
         type Access_To_Subtype_For_Isa_List is access all Subtype_For_Isa_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Isa_List);
         package Bare_Isa_List_Alloc is new Alloc
           (Subtype_For_Isa_List, Access_To_Subtype_For_Isa_List);

         function Allocate_Isa_List
           (Pool : Bump_Ptr_Pool) return Bare_Isa_List;

         function Allocate_Isa_List
           (Pool : Bump_Ptr_Pool) return Bare_Isa_List
         is
            Result      : constant Access_To_Subtype_For_Isa_List := Bare_Isa_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Isa_List;
            return Bare_Isa_List (Result);
         end Allocate_Isa_List;

      package Bare_Match_Branch_Memos is new Liblktlang_Support.Packrat
        (Bare_Match_Branch, Token_Index);

         
         subtype Subtype_For_Match_Branch is
            Root_Node_Record (Lkt_Match_Branch);
         type Access_To_Subtype_For_Match_Branch is access all Subtype_For_Match_Branch;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Match_Branch);
         package Bare_Match_Branch_Alloc is new Alloc
           (Subtype_For_Match_Branch, Access_To_Subtype_For_Match_Branch);

         function Allocate_Match_Branch
           (Pool : Bump_Ptr_Pool) return Bare_Match_Branch;

         function Allocate_Match_Branch
           (Pool : Bump_Ptr_Pool) return Bare_Match_Branch
         is
            Result      : constant Access_To_Subtype_For_Match_Branch := Bare_Match_Branch_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Match_Branch;
            return Bare_Match_Branch (Result);
         end Allocate_Match_Branch;

      package Bare_Op_Memos is new Liblktlang_Support.Packrat
        (Bare_Op, Token_Index);

      package Bare_Op_Amp_Memos is new Liblktlang_Support.Packrat
        (Bare_Op_Amp, Token_Index);

         
         subtype Subtype_For_Op_Amp is
            Root_Node_Record (Lkt_Op_Amp);
         type Access_To_Subtype_For_Op_Amp is access all Subtype_For_Op_Amp;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Amp);
         package Bare_Op_Amp_Alloc is new Alloc
           (Subtype_For_Op_Amp, Access_To_Subtype_For_Op_Amp);

         function Allocate_Op_Amp
           (Pool : Bump_Ptr_Pool) return Bare_Op_Amp;

         function Allocate_Op_Amp
           (Pool : Bump_Ptr_Pool) return Bare_Op_Amp
         is
            Result      : constant Access_To_Subtype_For_Op_Amp := Bare_Op_Amp_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Amp;
            return Bare_Op_Amp (Result);
         end Allocate_Op_Amp;

      package Bare_Op_And_Memos is new Liblktlang_Support.Packrat
        (Bare_Op_And, Token_Index);

         
         subtype Subtype_For_Op_And is
            Root_Node_Record (Lkt_Op_And);
         type Access_To_Subtype_For_Op_And is access all Subtype_For_Op_And;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_And);
         package Bare_Op_And_Alloc is new Alloc
           (Subtype_For_Op_And, Access_To_Subtype_For_Op_And);

         function Allocate_Op_And
           (Pool : Bump_Ptr_Pool) return Bare_Op_And;

         function Allocate_Op_And
           (Pool : Bump_Ptr_Pool) return Bare_Op_And
         is
            Result      : constant Access_To_Subtype_For_Op_And := Bare_Op_And_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_And;
            return Bare_Op_And (Result);
         end Allocate_Op_And;

      package Bare_Op_Div_Memos is new Liblktlang_Support.Packrat
        (Bare_Op_Div, Token_Index);

         
         subtype Subtype_For_Op_Div is
            Root_Node_Record (Lkt_Op_Div);
         type Access_To_Subtype_For_Op_Div is access all Subtype_For_Op_Div;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Div);
         package Bare_Op_Div_Alloc is new Alloc
           (Subtype_For_Op_Div, Access_To_Subtype_For_Op_Div);

         function Allocate_Op_Div
           (Pool : Bump_Ptr_Pool) return Bare_Op_Div;

         function Allocate_Op_Div
           (Pool : Bump_Ptr_Pool) return Bare_Op_Div
         is
            Result      : constant Access_To_Subtype_For_Op_Div := Bare_Op_Div_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Div;
            return Bare_Op_Div (Result);
         end Allocate_Op_Div;

      package Bare_Op_Eq_Memos is new Liblktlang_Support.Packrat
        (Bare_Op_Eq, Token_Index);

         
         subtype Subtype_For_Op_Eq is
            Root_Node_Record (Lkt_Op_Eq);
         type Access_To_Subtype_For_Op_Eq is access all Subtype_For_Op_Eq;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Eq);
         package Bare_Op_Eq_Alloc is new Alloc
           (Subtype_For_Op_Eq, Access_To_Subtype_For_Op_Eq);

         function Allocate_Op_Eq
           (Pool : Bump_Ptr_Pool) return Bare_Op_Eq;

         function Allocate_Op_Eq
           (Pool : Bump_Ptr_Pool) return Bare_Op_Eq
         is
            Result      : constant Access_To_Subtype_For_Op_Eq := Bare_Op_Eq_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Eq;
            return Bare_Op_Eq (Result);
         end Allocate_Op_Eq;

      package Bare_Op_Gt_Memos is new Liblktlang_Support.Packrat
        (Bare_Op_Gt, Token_Index);

         
         subtype Subtype_For_Op_Gt is
            Root_Node_Record (Lkt_Op_Gt);
         type Access_To_Subtype_For_Op_Gt is access all Subtype_For_Op_Gt;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Gt);
         package Bare_Op_Gt_Alloc is new Alloc
           (Subtype_For_Op_Gt, Access_To_Subtype_For_Op_Gt);

         function Allocate_Op_Gt
           (Pool : Bump_Ptr_Pool) return Bare_Op_Gt;

         function Allocate_Op_Gt
           (Pool : Bump_Ptr_Pool) return Bare_Op_Gt
         is
            Result      : constant Access_To_Subtype_For_Op_Gt := Bare_Op_Gt_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Gt;
            return Bare_Op_Gt (Result);
         end Allocate_Op_Gt;

      package Bare_Op_Gte_Memos is new Liblktlang_Support.Packrat
        (Bare_Op_Gte, Token_Index);

         
         subtype Subtype_For_Op_Gte is
            Root_Node_Record (Lkt_Op_Gte);
         type Access_To_Subtype_For_Op_Gte is access all Subtype_For_Op_Gte;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Gte);
         package Bare_Op_Gte_Alloc is new Alloc
           (Subtype_For_Op_Gte, Access_To_Subtype_For_Op_Gte);

         function Allocate_Op_Gte
           (Pool : Bump_Ptr_Pool) return Bare_Op_Gte;

         function Allocate_Op_Gte
           (Pool : Bump_Ptr_Pool) return Bare_Op_Gte
         is
            Result      : constant Access_To_Subtype_For_Op_Gte := Bare_Op_Gte_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Gte;
            return Bare_Op_Gte (Result);
         end Allocate_Op_Gte;

      package Bare_Op_Logic_And_Memos is new Liblktlang_Support.Packrat
        (Bare_Op_Logic_And, Token_Index);

         
         subtype Subtype_For_Op_Logic_And is
            Root_Node_Record (Lkt_Op_Logic_And);
         type Access_To_Subtype_For_Op_Logic_And is access all Subtype_For_Op_Logic_And;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Logic_And);
         package Bare_Op_Logic_And_Alloc is new Alloc
           (Subtype_For_Op_Logic_And, Access_To_Subtype_For_Op_Logic_And);

         function Allocate_Op_Logic_And
           (Pool : Bump_Ptr_Pool) return Bare_Op_Logic_And;

         function Allocate_Op_Logic_And
           (Pool : Bump_Ptr_Pool) return Bare_Op_Logic_And
         is
            Result      : constant Access_To_Subtype_For_Op_Logic_And := Bare_Op_Logic_And_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Logic_And;
            return Bare_Op_Logic_And (Result);
         end Allocate_Op_Logic_And;

      package Bare_Op_Logic_Or_Memos is new Liblktlang_Support.Packrat
        (Bare_Op_Logic_Or, Token_Index);

         
         subtype Subtype_For_Op_Logic_Or is
            Root_Node_Record (Lkt_Op_Logic_Or);
         type Access_To_Subtype_For_Op_Logic_Or is access all Subtype_For_Op_Logic_Or;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Logic_Or);
         package Bare_Op_Logic_Or_Alloc is new Alloc
           (Subtype_For_Op_Logic_Or, Access_To_Subtype_For_Op_Logic_Or);

         function Allocate_Op_Logic_Or
           (Pool : Bump_Ptr_Pool) return Bare_Op_Logic_Or;

         function Allocate_Op_Logic_Or
           (Pool : Bump_Ptr_Pool) return Bare_Op_Logic_Or
         is
            Result      : constant Access_To_Subtype_For_Op_Logic_Or := Bare_Op_Logic_Or_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Logic_Or;
            return Bare_Op_Logic_Or (Result);
         end Allocate_Op_Logic_Or;

      package Bare_Op_Lt_Memos is new Liblktlang_Support.Packrat
        (Bare_Op_Lt, Token_Index);

         
         subtype Subtype_For_Op_Lt is
            Root_Node_Record (Lkt_Op_Lt);
         type Access_To_Subtype_For_Op_Lt is access all Subtype_For_Op_Lt;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Lt);
         package Bare_Op_Lt_Alloc is new Alloc
           (Subtype_For_Op_Lt, Access_To_Subtype_For_Op_Lt);

         function Allocate_Op_Lt
           (Pool : Bump_Ptr_Pool) return Bare_Op_Lt;

         function Allocate_Op_Lt
           (Pool : Bump_Ptr_Pool) return Bare_Op_Lt
         is
            Result      : constant Access_To_Subtype_For_Op_Lt := Bare_Op_Lt_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Lt;
            return Bare_Op_Lt (Result);
         end Allocate_Op_Lt;

      package Bare_Op_Lte_Memos is new Liblktlang_Support.Packrat
        (Bare_Op_Lte, Token_Index);

         
         subtype Subtype_For_Op_Lte is
            Root_Node_Record (Lkt_Op_Lte);
         type Access_To_Subtype_For_Op_Lte is access all Subtype_For_Op_Lte;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Lte);
         package Bare_Op_Lte_Alloc is new Alloc
           (Subtype_For_Op_Lte, Access_To_Subtype_For_Op_Lte);

         function Allocate_Op_Lte
           (Pool : Bump_Ptr_Pool) return Bare_Op_Lte;

         function Allocate_Op_Lte
           (Pool : Bump_Ptr_Pool) return Bare_Op_Lte
         is
            Result      : constant Access_To_Subtype_For_Op_Lte := Bare_Op_Lte_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Lte;
            return Bare_Op_Lte (Result);
         end Allocate_Op_Lte;

      package Bare_Op_Minus_Memos is new Liblktlang_Support.Packrat
        (Bare_Op_Minus, Token_Index);

         
         subtype Subtype_For_Op_Minus is
            Root_Node_Record (Lkt_Op_Minus);
         type Access_To_Subtype_For_Op_Minus is access all Subtype_For_Op_Minus;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Minus);
         package Bare_Op_Minus_Alloc is new Alloc
           (Subtype_For_Op_Minus, Access_To_Subtype_For_Op_Minus);

         function Allocate_Op_Minus
           (Pool : Bump_Ptr_Pool) return Bare_Op_Minus;

         function Allocate_Op_Minus
           (Pool : Bump_Ptr_Pool) return Bare_Op_Minus
         is
            Result      : constant Access_To_Subtype_For_Op_Minus := Bare_Op_Minus_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Minus;
            return Bare_Op_Minus (Result);
         end Allocate_Op_Minus;

      package Bare_Op_Mult_Memos is new Liblktlang_Support.Packrat
        (Bare_Op_Mult, Token_Index);

         
         subtype Subtype_For_Op_Mult is
            Root_Node_Record (Lkt_Op_Mult);
         type Access_To_Subtype_For_Op_Mult is access all Subtype_For_Op_Mult;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Mult);
         package Bare_Op_Mult_Alloc is new Alloc
           (Subtype_For_Op_Mult, Access_To_Subtype_For_Op_Mult);

         function Allocate_Op_Mult
           (Pool : Bump_Ptr_Pool) return Bare_Op_Mult;

         function Allocate_Op_Mult
           (Pool : Bump_Ptr_Pool) return Bare_Op_Mult
         is
            Result      : constant Access_To_Subtype_For_Op_Mult := Bare_Op_Mult_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Mult;
            return Bare_Op_Mult (Result);
         end Allocate_Op_Mult;

      package Bare_Op_Ne_Memos is new Liblktlang_Support.Packrat
        (Bare_Op_Ne, Token_Index);

         
         subtype Subtype_For_Op_Ne is
            Root_Node_Record (Lkt_Op_Ne);
         type Access_To_Subtype_For_Op_Ne is access all Subtype_For_Op_Ne;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Ne);
         package Bare_Op_Ne_Alloc is new Alloc
           (Subtype_For_Op_Ne, Access_To_Subtype_For_Op_Ne);

         function Allocate_Op_Ne
           (Pool : Bump_Ptr_Pool) return Bare_Op_Ne;

         function Allocate_Op_Ne
           (Pool : Bump_Ptr_Pool) return Bare_Op_Ne
         is
            Result      : constant Access_To_Subtype_For_Op_Ne := Bare_Op_Ne_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Ne;
            return Bare_Op_Ne (Result);
         end Allocate_Op_Ne;

      package Bare_Op_Or_Memos is new Liblktlang_Support.Packrat
        (Bare_Op_Or, Token_Index);

         
         subtype Subtype_For_Op_Or is
            Root_Node_Record (Lkt_Op_Or);
         type Access_To_Subtype_For_Op_Or is access all Subtype_For_Op_Or;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Or);
         package Bare_Op_Or_Alloc is new Alloc
           (Subtype_For_Op_Or, Access_To_Subtype_For_Op_Or);

         function Allocate_Op_Or
           (Pool : Bump_Ptr_Pool) return Bare_Op_Or;

         function Allocate_Op_Or
           (Pool : Bump_Ptr_Pool) return Bare_Op_Or
         is
            Result      : constant Access_To_Subtype_For_Op_Or := Bare_Op_Or_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Or;
            return Bare_Op_Or (Result);
         end Allocate_Op_Or;

      package Bare_Op_Or_Int_Memos is new Liblktlang_Support.Packrat
        (Bare_Op_Or_Int, Token_Index);

         
         subtype Subtype_For_Op_Or_Int is
            Root_Node_Record (Lkt_Op_Or_Int);
         type Access_To_Subtype_For_Op_Or_Int is access all Subtype_For_Op_Or_Int;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Or_Int);
         package Bare_Op_Or_Int_Alloc is new Alloc
           (Subtype_For_Op_Or_Int, Access_To_Subtype_For_Op_Or_Int);

         function Allocate_Op_Or_Int
           (Pool : Bump_Ptr_Pool) return Bare_Op_Or_Int;

         function Allocate_Op_Or_Int
           (Pool : Bump_Ptr_Pool) return Bare_Op_Or_Int
         is
            Result      : constant Access_To_Subtype_For_Op_Or_Int := Bare_Op_Or_Int_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Or_Int;
            return Bare_Op_Or_Int (Result);
         end Allocate_Op_Or_Int;

      package Bare_Op_Plus_Memos is new Liblktlang_Support.Packrat
        (Bare_Op_Plus, Token_Index);

         
         subtype Subtype_For_Op_Plus is
            Root_Node_Record (Lkt_Op_Plus);
         type Access_To_Subtype_For_Op_Plus is access all Subtype_For_Op_Plus;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Plus);
         package Bare_Op_Plus_Alloc is new Alloc
           (Subtype_For_Op_Plus, Access_To_Subtype_For_Op_Plus);

         function Allocate_Op_Plus
           (Pool : Bump_Ptr_Pool) return Bare_Op_Plus;

         function Allocate_Op_Plus
           (Pool : Bump_Ptr_Pool) return Bare_Op_Plus
         is
            Result      : constant Access_To_Subtype_For_Op_Plus := Bare_Op_Plus_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Plus;
            return Bare_Op_Plus (Result);
         end Allocate_Op_Plus;

      package Bare_Param_Memos is new Liblktlang_Support.Packrat
        (Bare_Param, Token_Index);

         
         subtype Subtype_For_Param is
            Root_Node_Record (Lkt_Param);
         type Access_To_Subtype_For_Param is access all Subtype_For_Param;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Param);
         package Bare_Param_Alloc is new Alloc
           (Subtype_For_Param, Access_To_Subtype_For_Param);

         function Allocate_Param
           (Pool : Bump_Ptr_Pool) return Bare_Param;

         function Allocate_Param
           (Pool : Bump_Ptr_Pool) return Bare_Param
         is
            Result      : constant Access_To_Subtype_For_Param := Bare_Param_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Param;
            return Bare_Param (Result);
         end Allocate_Param;

      package Bare_Type_Ref_Memos is new Liblktlang_Support.Packrat
        (Bare_Type_Ref, Token_Index);

      package Bare_Default_List_Type_Ref_Memos is new Liblktlang_Support.Packrat
        (Bare_Default_List_Type_Ref, Token_Index);

         
         subtype Subtype_For_Default_List_Type_Ref is
            Root_Node_Record (Lkt_Default_List_Type_Ref);
         type Access_To_Subtype_For_Default_List_Type_Ref is access all Subtype_For_Default_List_Type_Ref;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Default_List_Type_Ref);
         package Bare_Default_List_Type_Ref_Alloc is new Alloc
           (Subtype_For_Default_List_Type_Ref, Access_To_Subtype_For_Default_List_Type_Ref);

         function Allocate_Default_List_Type_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Default_List_Type_Ref;

         function Allocate_Default_List_Type_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Default_List_Type_Ref
         is
            Result      : constant Access_To_Subtype_For_Default_List_Type_Ref := Bare_Default_List_Type_Ref_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Default_List_Type_Ref;
            return Bare_Default_List_Type_Ref (Result);
         end Allocate_Default_List_Type_Ref;

      package Bare_Function_Type_Ref_Memos is new Liblktlang_Support.Packrat
        (Bare_Function_Type_Ref, Token_Index);

         
         subtype Subtype_For_Function_Type_Ref is
            Root_Node_Record (Lkt_Function_Type_Ref);
         type Access_To_Subtype_For_Function_Type_Ref is access all Subtype_For_Function_Type_Ref;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Function_Type_Ref);
         package Bare_Function_Type_Ref_Alloc is new Alloc
           (Subtype_For_Function_Type_Ref, Access_To_Subtype_For_Function_Type_Ref);

         function Allocate_Function_Type_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Function_Type_Ref;

         function Allocate_Function_Type_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Function_Type_Ref
         is
            Result      : constant Access_To_Subtype_For_Function_Type_Ref := Bare_Function_Type_Ref_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Function_Type_Ref;
            return Bare_Function_Type_Ref (Result);
         end Allocate_Function_Type_Ref;

      package Bare_Generic_Type_Ref_Memos is new Liblktlang_Support.Packrat
        (Bare_Generic_Type_Ref, Token_Index);

         
         subtype Subtype_For_Generic_Type_Ref is
            Root_Node_Record (Lkt_Generic_Type_Ref);
         type Access_To_Subtype_For_Generic_Type_Ref is access all Subtype_For_Generic_Type_Ref;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Generic_Type_Ref);
         package Bare_Generic_Type_Ref_Alloc is new Alloc
           (Subtype_For_Generic_Type_Ref, Access_To_Subtype_For_Generic_Type_Ref);

         function Allocate_Generic_Type_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Type_Ref;

         function Allocate_Generic_Type_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Type_Ref
         is
            Result      : constant Access_To_Subtype_For_Generic_Type_Ref := Bare_Generic_Type_Ref_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Generic_Type_Ref;
            return Bare_Generic_Type_Ref (Result);
         end Allocate_Generic_Type_Ref;

      package Bare_Simple_Type_Ref_Memos is new Liblktlang_Support.Packrat
        (Bare_Simple_Type_Ref, Token_Index);

         
         subtype Subtype_For_Simple_Type_Ref is
            Root_Node_Record (Lkt_Simple_Type_Ref);
         type Access_To_Subtype_For_Simple_Type_Ref is access all Subtype_For_Simple_Type_Ref;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Simple_Type_Ref);
         package Bare_Simple_Type_Ref_Alloc is new Alloc
           (Subtype_For_Simple_Type_Ref, Access_To_Subtype_For_Simple_Type_Ref);

         function Allocate_Simple_Type_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Simple_Type_Ref;

         function Allocate_Simple_Type_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Simple_Type_Ref
         is
            Result      : constant Access_To_Subtype_For_Simple_Type_Ref := Bare_Simple_Type_Ref_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Simple_Type_Ref;
            return Bare_Simple_Type_Ref (Result);
         end Allocate_Simple_Type_Ref;

      package Bare_Var_Bind_Memos is new Liblktlang_Support.Packrat
        (Bare_Var_Bind, Token_Index);

         
         subtype Subtype_For_Var_Bind is
            Root_Node_Record (Lkt_Var_Bind);
         type Access_To_Subtype_For_Var_Bind is access all Subtype_For_Var_Bind;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Var_Bind);
         package Bare_Var_Bind_Alloc is new Alloc
           (Subtype_For_Var_Bind, Access_To_Subtype_For_Var_Bind);

         function Allocate_Var_Bind
           (Pool : Bump_Ptr_Pool) return Bare_Var_Bind;

         function Allocate_Var_Bind
           (Pool : Bump_Ptr_Pool) return Bare_Var_Bind
         is
            Result      : constant Access_To_Subtype_For_Var_Bind := Bare_Var_Bind_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Var_Bind;
            return Bare_Var_Bind (Result);
         end Allocate_Var_Bind;

   pragma Warnings (On, "is not referenced");

   type Dontskip_Parser_Function is access function
     (Parser : in out Parser_Type;
      Pos    : Token_Index) return Bare_Lkt_Node;

   package Dont_Skip_Fn_Vectors
   is new Ada.Containers.Vectors (Natural, Dontskip_Parser_Function);

   type Free_Parse_List_Record;
   type Free_Parse_List is access all Free_Parse_List_Record;
   --  Cache of temporary lists of AST nodes used in List parsers

   type Free_Parse_List_Record is record
      Nodes : Bare_Lkt_Node_Vectors.Vector;
      Next  : Free_Parse_List;
   end record;

   type Parser_Private_Part_Type is record
      Parse_Lists : Free_Parse_List;

      
      Arith_1_Or_Parse1_Memo : Bare_Expr_Memos.Memo_Type;
      
      Arith_2_Or_Parse1_Memo : Bare_Expr_Memos.Memo_Type;
      
      Arith_3_Or_Parse1_Memo : Bare_Expr_Memos.Memo_Type;
      
      Array_Literal_Transform_Parse0_Memo : Bare_Array_Literal_Memos.Memo_Type;
      
      Bare_Decl_Or_Parse0_Memo : Bare_Decl_Memos.Memo_Type;
      
      Basic_Expr_Or_Parse0_Memo : Bare_Expr_Memos.Memo_Type;
      
      Basic_Name_Or_Parse0_Memo : Bare_Expr_Memos.Memo_Type;
      
      Big_Num_Lit_Transform_Parse0_Memo : Bare_Big_Num_Lit_Memos.Memo_Type;
      
      Block_String_Lit_Transform_Parse1_Memo : Bare_Block_String_Lit_Memos.Memo_Type;
      
      Block_Transform_Parse0_Memo : Bare_Block_Expr_Memos.Memo_Type;
      
      Callable_Ref_Or_Parse0_Memo : Bare_Expr_Memos.Memo_Type;
      
      Char_Lit_Transform_Parse0_Memo : Bare_Char_Lit_Memos.Memo_Type;
      
      Decl_Annotation_Params_Opt_Parse0_Memo : Bare_Decl_Annotation_Params_Memos.Memo_Type;
      
      Decl_Annotation_Transform_Parse0_Memo : Bare_Decl_Annotation_Memos.Memo_Type;
      
      Decl_Block_List_Parse0_Memo : Bare_Decl_Block_Memos.Memo_Type;
      
      Decl_Transform_Parse0_Memo : Bare_Full_Decl_Memos.Memo_Type;
      
      Decls_List_Parse0_Memo : Bare_Full_Decl_List_Memos.Memo_Type;
      
      Def_Id_Transform_Parse0_Memo : Bare_Def_Id_Memos.Memo_Type;
      
      Doc_Opt_Parse0_Memo : Bare_String_Lit_Memos.Memo_Type;
      
      Dynvar_Decl_Transform_Parse0_Memo : Bare_Dyn_Var_Decl_Memos.Memo_Type;
      
      Enum_Lit_Decl_Transform_Parse0_Memo : Bare_Enum_Lit_Decl_Memos.Memo_Type;
      
      Env_Spec_Action_Transform_Parse1_Memo : Bare_Call_Expr_Memos.Memo_Type;
      
      Env_Spec_Decl_Transform_Parse1_Memo : Bare_Env_Spec_Decl_Memos.Memo_Type;
      
      Eq_Or_Parse1_Memo : Bare_Expr_Memos.Memo_Type;
      
      Expr_Or_Parse1_Memo : Bare_Expr_Memos.Memo_Type;
      
      Field_Decl_Transform_Parse0_Memo : Bare_Field_Decl_Memos.Memo_Type;
      
      Fun_Arg_Decl_Transform_Parse0_Memo : Bare_Fun_Arg_Decl_Memos.Memo_Type;
      
      Fun_Arg_List_List_Parse0_Memo : Bare_Fun_Arg_Decl_List_Memos.Memo_Type;
      
      Fun_Decl_Transform_Parse0_Memo : Bare_Fun_Decl_Memos.Memo_Type;
      
      Generic_Decl_Transform_Parse0_Memo : Bare_Generic_Decl_Memos.Memo_Type;
      
      Generic_Formal_Type_Transform_Parse1_Memo : Bare_Full_Decl_Memos.Memo_Type;
      
      Grammar_Cut_Transform_Parse0_Memo : Bare_Grammar_Cut_Memos.Memo_Type;
      
      Grammar_Decl_Transform_Parse0_Memo : Bare_Grammar_Decl_Memos.Memo_Type;
      
      Grammar_Discard_Expr_Transform_Parse0_Memo : Bare_Grammar_Discard_Memos.Memo_Type;
      
      Grammar_Expr_Or_Parse0_Memo : Bare_Grammar_Expr_Memos.Memo_Type;
      
      Grammar_Implicit_Pick_Transform_Parse0_Memo : Bare_Grammar_Implicit_Pick_Memos.Memo_Type;
      
      Grammar_List_Expr_Transform_Parse3_Memo : Bare_Grammar_List_Memos.Memo_Type;
      
      Grammar_List_Sep_Transform_Parse0_Memo : Bare_Grammar_List_Sep_Memos.Memo_Type;
      
      Grammar_Null_Transform_Parse0_Memo : Bare_Grammar_Null_Memos.Memo_Type;
      
      Grammar_Opt_Error_Or_Parse0_Memo : Bare_Grammar_Expr_Memos.Memo_Type;
      
      Grammar_Opt_Or_Parse0_Memo : Bare_Grammar_Expr_Memos.Memo_Type;
      
      Grammar_Or_Expr_Transform_Parse0_Memo : Bare_Grammar_Or_Expr_Memos.Memo_Type;
      
      Grammar_Pick_Transform_Parse0_Memo : Bare_Grammar_Pick_Memos.Memo_Type;
      
      Grammar_Primary_Or_Parse0_Memo : Bare_Grammar_Expr_Memos.Memo_Type;
      
      Grammar_Rule_Ref_Transform_Parse0_Memo : Bare_Grammar_Rule_Ref_Memos.Memo_Type;
      
      Grammar_Rule_Transform_Parse0_Memo : Bare_Grammar_Rule_Decl_Memos.Memo_Type;
      
      Grammar_Skip_Transform_Parse0_Memo : Bare_Grammar_Skip_Memos.Memo_Type;
      
      Grammar_Stopcut_Transform_Parse0_Memo : Bare_Grammar_Stop_Cut_Memos.Memo_Type;
      
      Grammar_Token_Transform_Parse0_Memo : Bare_Token_Ref_Memos.Memo_Type;
      
      Id_Transform_Parse0_Memo : Bare_Id_Memos.Memo_Type;
      
      If_Expr_Transform_Parse1_Memo : Bare_If_Expr_Memos.Memo_Type;
      
      Import_Stmt_Transform_Parse1_Memo : Bare_Import_Memos.Memo_Type;
      
      Imports_List_Parse0_Memo : Bare_Import_List_Memos.Memo_Type;
      
      Isa_Or_Primary_Or_Parse0_Memo : Bare_Expr_Memos.Memo_Type;
      
      Lambda_Arg_Decl_Transform_Parse0_Memo : Bare_Lambda_Arg_Decl_Memos.Memo_Type;
      
      Lambda_Arg_List_List_Parse0_Memo : Bare_Lambda_Arg_Decl_List_Memos.Memo_Type;
      
      Lambda_Expr_Transform_Parse0_Memo : Bare_Lambda_Expr_Memos.Memo_Type;
      
      Lexer_Case_Alt_Or_Parse0_Memo : Bare_Base_Lexer_Case_Rule_Alt_Memos.Memo_Type;
      
      Lexer_Case_Rule_Transform_Parse0_Memo : Bare_Lexer_Case_Rule_Memos.Memo_Type;
      
      Lexer_Case_Send_Transform_Parse0_Memo : Bare_Lexer_Case_Rule_Send_Memos.Memo_Type;
      
      Lexer_Decl_Transform_Parse0_Memo : Bare_Lexer_Decl_Memos.Memo_Type;
      
      Lexer_Family_Decl_Transform_Parse1_Memo : Bare_Full_Decl_Memos.Memo_Type;
      
      Lexer_Rule_Or_Parse0_Memo : Bare_Lkt_Node_Memos.Memo_Type;
      
      Logic_Propagate_Call_Transform_Parse0_Memo : Bare_Logic_Propagate_Call_Memos.Memo_Type;
      
      Main_Rule_Transform_Parse0_Memo : Bare_Langkit_Root_Memos.Memo_Type;
      
      Match_Expr_Transform_Parse2_Memo : Bare_Match_Expr_Memos.Memo_Type;
      
      Null_Lit_Transform_Parse0_Memo : Bare_Null_Lit_Memos.Memo_Type;
      
      Num_Lit_Transform_Parse0_Memo : Bare_Num_Lit_Memos.Memo_Type;
      
      Param_Transform_Parse0_Memo : Bare_Param_Memos.Memo_Type;
      
      Params_List_Parse0_Memo : Bare_Param_List_Memos.Memo_Type;
      
      Parse_Node_Expr_Transform_Parse0_Memo : Bare_Parse_Node_Expr_Memos.Memo_Type;
      
      Primary_Or_Parse0_Memo : Bare_Expr_Memos.Memo_Type;
      
      Raise_Expr_Transform_Parse0_Memo : Bare_Raise_Expr_Memos.Memo_Type;
      
      Ref_Id_Transform_Parse0_Memo : Bare_Ref_Id_Memos.Memo_Type;
      
      Rel_Or_Parse0_Memo : Bare_Expr_Memos.Memo_Type;
      
      String_Lit_Or_Parse0_Memo : Bare_String_Lit_Memos.Memo_Type;
      
      Term_Or_Parse0_Memo : Bare_Expr_Memos.Memo_Type;
      
      Token_Literal_Transform_Parse0_Memo : Bare_Token_Lit_Memos.Memo_Type;
      
      Token_No_Case_Literal_Transform_Parse0_Memo : Bare_Token_No_Case_Lit_Memos.Memo_Type;
      
      Token_Pattern_Literal_Transform_Parse0_Memo : Bare_Token_Pattern_Lit_Memos.Memo_Type;
      
      Token_Pattern_Or_Parse0_Memo : Bare_Grammar_Expr_Memos.Memo_Type;
      
      Try_Expr_Transform_Parse0_Memo : Bare_Try_Expr_Memos.Memo_Type;
      
      Type_Decl_Or_Parse0_Memo : Bare_Named_Type_Decl_Memos.Memo_Type;
      
      Type_Expr_Or_Parse0_Memo : Bare_Expr_Memos.Memo_Type;
      
      Type_List_List_Parse0_Memo : Bare_Type_Ref_List_Memos.Memo_Type;
      
      Type_Member_Ref_Transform_Parse0_Memo : Bare_Dot_Expr_Memos.Memo_Type;
      
      Type_Ref_Id_Predicate_Parse0_Memo : Bare_Ref_Id_Memos.Memo_Type;
      
      Type_Ref_Or_Parse0_Memo : Bare_Type_Ref_Memos.Memo_Type;
      
      Val_Decl_Transform_Parse0_Memo : Bare_Val_Decl_Memos.Memo_Type;
      
      Var_Bind_Transform_Parse0_Memo : Bare_Var_Bind_Memos.Memo_Type;

      Dont_Skip : Dont_Skip_Fn_Vectors.Vector;
   end record;
   type Parser_Private_Part is access all Parser_Private_Part_Type;
   pragma No_Strict_Aliasing (Parser_Private_Part);
   function "+" is new Ada.Unchecked_Conversion
     (System.Address, Parser_Private_Part);
   function "+" is new Ada.Unchecked_Conversion
     (Parser_Private_Part, System.Address);

   
function Arith_1_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Arith_2_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Arith_3_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Array_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Array_Literal;

   
function Bare_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decl;

   
function Basic_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Basic_Name_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Big_Num_Lit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Big_Num_Lit;

   
function Block_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Block_Expr;

   
function Block_String_Lit_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Block_String_Lit;

   
function Callable_Ref_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Char_Lit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Char_Lit;

   
function Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Full_Decl;

   
function Decl_Annotation_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decl_Annotation;

   
function Decl_Annotation_Params_Opt_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decl_Annotation_Params;

   
function Decl_Block_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decl_Block;

   
function Decls_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Full_Decl_List;

   
function Def_Id_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Def_Id;

   
function Doc_Opt_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_String_Lit;

   
function Dynvar_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Dyn_Var_Decl;

   
function Enum_Lit_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Enum_Lit_Decl;

   
function Env_Spec_Action_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Call_Expr;

   
function Env_Spec_Decl_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Env_Spec_Decl;

   
function Eq_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Expr_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Field_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Field_Decl;

   
function Fun_Arg_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Fun_Arg_Decl;

   
function Fun_Arg_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Fun_Arg_Decl_List;

   
function Fun_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Fun_Decl;

   
function Generic_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Generic_Decl;

   
function Generic_Formal_Type_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Full_Decl;

   
function Grammar_Cut_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Cut;

   
function Grammar_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Decl;

   
function Grammar_Discard_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Discard;

   
function Grammar_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr;

   
function Grammar_Implicit_Pick_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Implicit_Pick;

   
function Grammar_List_Expr_Transform_Parse3
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_List;

   
function Grammar_List_Sep_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_List_Sep;

   
function Grammar_Null_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Null;

   
function Grammar_Opt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr;

   
function Grammar_Opt_Error_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr;

   
function Grammar_Or_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Or_Expr;

   
function Grammar_Pick_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Pick;

   
function Grammar_Primary_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr;

   
function Grammar_Rule_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Rule_Decl;

   
function Grammar_Rule_Ref_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Rule_Ref;

   
function Grammar_Skip_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Skip;

   
function Grammar_Stopcut_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Stop_Cut;

   
function Grammar_Token_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Token_Ref;

   
function Id_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Id;

   
function If_Expr_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_If_Expr;

   
function Import_Stmt_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Import;

   
function Imports_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Import_List;

   
function Isa_Or_Primary_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Lambda_Arg_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lambda_Arg_Decl;

   
function Lambda_Arg_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lambda_Arg_Decl_List;

   
function Lambda_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lambda_Expr;

   
function Lexer_Case_Alt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Lexer_Case_Rule_Alt;

   
function Lexer_Case_Rule_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lexer_Case_Rule;

   
function Lexer_Case_Send_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lexer_Case_Rule_Send;

   
function Lexer_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lexer_Decl;

   
function Lexer_Family_Decl_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Full_Decl;

   
function Lexer_Rule_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Logic_Propagate_Call_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Logic_Propagate_Call;

   
function Main_Rule_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Langkit_Root;

   
function Match_Expr_Transform_Parse2
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Match_Expr;

   
function Null_Lit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Null_Lit;

   
function Num_Lit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Num_Lit;

   
function Param_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Param;

   
function Params_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Param_List;

   
function Parse_Node_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Parse_Node_Expr;

   
function Primary_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Raise_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Raise_Expr;

   
function Ref_Id_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ref_Id;

   
function Rel_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function String_Lit_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_String_Lit;

   
function Term_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Token_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Token_Lit;

   
function Token_No_Case_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Token_No_Case_Lit;

   
function Token_Pattern_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr;

   
function Token_Pattern_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Token_Pattern_Lit;

   
function Try_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Try_Expr;

   
function Type_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Named_Type_Decl;

   
function Type_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Type_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Type_Ref_List;

   
function Type_Member_Ref_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Dot_Expr;

   
function Type_Ref_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Type_Ref;

   
function Type_Ref_Id_Predicate_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ref_Id;

   
function Val_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Val_Decl;

   
function Var_Bind_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Var_Bind;


   procedure Process_Parsing_Error
     (Parser         : in out Parser_Type;
      Check_Complete : Boolean := True);
   --  Helper for the user parsing function, to be called after a low-level
   --  parsing function. Check_Complete has the same semantics as in Parse. If
   --  the parsing failed (Parser.Current_Pos = No_Token_Index), append
   --  corresponding diagnostics to Parser.Diagnostics, do nothing instead.

   procedure Add_Last_Fail_Diagnostic (Parser : in out Parser_Type);
   --  Add a diagnostic for the last fail position of the parser

   pragma Warnings (Off, "is not referenced");

   function Get_Parse_List (Parser : Parser_Type) return Free_Parse_List;
   --  Get a free parse list, or allocate one if there is no free parse list in
   --  Parser. When done with the result, the caller must invoke
   --  Release_Parse_List.

   procedure Release_Parse_List
     (Parser : Parser_Type; List : in out Free_Parse_List);
   --  Release a parse list, putting it in Parsers' free list. Set List to
   --  null.

   procedure Initialize_List
     (Self   : Bare_Lkt_Node_Base_List;
      Parser : Parser_Type;
      Count  : Natural);
   --  Helper for parsers, to initialize the list of children in a freshly
   --  allocated list node.

   pragma Warnings (On, "is not referenced");

   ---------------------
   -- Initialize_List --
   ---------------------

   procedure Initialize_List
     (Self   : Bare_Lkt_Node_Base_List;
      Parser : Parser_Type;
      Count  : Natural) is
   begin
      Self.Count := Count;
      Self.Nodes := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, 0);
   end Initialize_List;

   -----------------
   -- Init_Parser --
   -----------------

   procedure Init_Parser
     (Input         : Internal_Lexer_Input;
      With_Trivia   : Boolean;
      Unit          : access Implementation.Analysis_Unit_Type;
      TDH           : Token_Data_Handler_Access;
      Parser        : in out Parser_Type;
      Old_TDH       : access constant Token_Data_Handler;
      Same_Contents : out Boolean)
   is
      --  Never try to use file readers for internal units: these are generally
      --  not actual source files, and file readers, which are external users
      --  of the generated library, have no reason to be aware of them.

      FR : constant Internal_File_Reader_Access :=
        (if Unit.Is_Internal
         then null
         else Unit.Context.File_Reader);
   begin
      Reset (Parser);
      Extract_Tokens
        (Input,
         With_Trivia,
         FR,
         TDH.all,
         Parser.Diagnostics,
         Old_TDH,
         Same_Contents);
      if Same_Contents then
         return;
      end if;
      Parser.Unit := Unit;
      Parser.TDH := TDH;
   end Init_Parser;

   ------------------------------
   -- Add_Last_Fail_Diagnostic --
   ------------------------------

   procedure Add_Last_Fail_Diagnostic (Parser : in out Parser_Type)
   is
      Last_Token : Stored_Token_Data renames
         Get_Token (Parser.TDH.all, Parser.Last_Fail.Pos);
      D : constant Diagnostic :=
        (if Parser.Last_Fail.Kind = Token_Fail then
          Create (Sloc_Range (Parser.TDH.all, Last_Token), To_Text
            ("Expected "
             & Token_Error_Image (Parser.Last_Fail.Expected_Token_Id)
             & ", got "
             & Token_Error_Image (Parser.Last_Fail.Found_Token_Id)))
         else
           Create (Sloc_Range (Parser.TDH.all, Last_Token),
                   To_Text (Parser.Last_Fail.Custom_Message.all)));
   begin
      Parser.Diagnostics.Append (D);
   end Add_Last_Fail_Diagnostic;

   ---------------------------
   -- Process_Parsing_Error --
   ---------------------------

   procedure Process_Parsing_Error
     (Parser         : in out Parser_Type;
      Check_Complete : Boolean := True) is
   begin

      if Parser.Current_Pos = No_Token_Index then
         Add_Last_Fail_Diagnostic (Parser);
      elsif Check_Complete
        and then Parser.Current_Pos /= Last_Token (Parser.TDH.all)
      then
         --  If the fail pos is the current position of the parser or after,
         --  it means that the longest parse is the correct result, and that we
         --  have some garbage afterwards.
         if Parser.Current_Pos >= Parser.Last_Fail.Pos then
            declare
               First_Garbage_Token : Stored_Token_Data renames
                  Get_Token (Parser.TDH.all, Parser.Current_Pos);
            begin
               Append
                 (Parser.Diagnostics,
                  Sloc_Range (Parser.TDH.all, First_Garbage_Token),
                  To_Text
                    ("End of input expected, got """
                     & Token_Kind_Name
                         (To_Token_Kind (First_Garbage_Token.Kind))
                     & """"));
            end;

         --  Else, the last fail pos is further down the line, and we want to
         --  have the diagnostic of what exactly failed.
         else
            Add_Last_Fail_Diagnostic (Parser);
         end if;
      end if;

   end Process_Parsing_Error;

   -----------
   -- Parse --
   -----------

   function Parse
     (Parser         : in out Parser_Type;
      Check_Complete : Boolean := True;
      Rule           : Grammar_Rule) return Parsed_Node
   is
      Result : Bare_Lkt_Node;
   begin
      case Rule is
         when Main_Rule_Rule =>
            Result := Main_Rule_Transform_Parse0
              (Parser, First_Token_Index);
         when Id_Rule =>
            Result := Id_Transform_Parse0
              (Parser, First_Token_Index);
         when Ref_Id_Rule =>
            Result := Ref_Id_Transform_Parse0
              (Parser, First_Token_Index);
         when Type_Ref_Id_Rule =>
            Result := Type_Ref_Id_Predicate_Parse0
              (Parser, First_Token_Index);
         when Def_Id_Rule =>
            Result := Def_Id_Transform_Parse0
              (Parser, First_Token_Index);
         when Doc_Rule =>
            Result := Doc_Opt_Parse0
              (Parser, First_Token_Index);
         when Import_Stmt_Rule =>
            Result := Import_Stmt_Transform_Parse1
              (Parser, First_Token_Index);
         when Imports_Rule =>
            Result := Imports_List_Parse0
              (Parser, First_Token_Index);
         when Lexer_Decl_Rule =>
            Result := Lexer_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Decl_Rule =>
            Result := Grammar_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Rule_Rule =>
            Result := Grammar_Rule_Transform_Parse0
              (Parser, First_Token_Index);
         when Lexer_Rule_Rule =>
            Result := Lexer_Rule_Or_Parse0
              (Parser, First_Token_Index);
         when Lexer_Family_Decl_Rule =>
            Result := Lexer_Family_Decl_Transform_Parse1
              (Parser, First_Token_Index);
         when Lexer_Case_Rule_Rule =>
            Result := Lexer_Case_Rule_Transform_Parse0
              (Parser, First_Token_Index);
         when Lexer_Case_Alt_Rule =>
            Result := Lexer_Case_Alt_Or_Parse0
              (Parser, First_Token_Index);
         when Lexer_Case_Send_Rule =>
            Result := Lexer_Case_Send_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Primary_Rule =>
            Result := Grammar_Primary_Or_Parse0
              (Parser, First_Token_Index);
         when Grammar_Expr_Rule =>
            Result := Grammar_Expr_Or_Parse0
              (Parser, First_Token_Index);
         when Grammar_Pick_Rule =>
            Result := Grammar_Pick_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Implicit_Pick_Rule =>
            Result := Grammar_Implicit_Pick_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Opt_Rule =>
            Result := Grammar_Opt_Or_Parse0
              (Parser, First_Token_Index);
         when Grammar_Opt_Error_Rule =>
            Result := Grammar_Opt_Error_Or_Parse0
              (Parser, First_Token_Index);
         when Grammar_Cut_Rule =>
            Result := Grammar_Cut_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Stopcut_Rule =>
            Result := Grammar_Stopcut_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Or_Expr_Rule =>
            Result := Grammar_Or_Expr_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Discard_Expr_Rule =>
            Result := Grammar_Discard_Expr_Transform_Parse0
              (Parser, First_Token_Index);
         when Token_Literal_Rule =>
            Result := Token_Literal_Transform_Parse0
              (Parser, First_Token_Index);
         when Token_No_Case_Literal_Rule =>
            Result := Token_No_Case_Literal_Transform_Parse0
              (Parser, First_Token_Index);
         when Token_Pattern_Rule =>
            Result := Token_Pattern_Or_Parse0
              (Parser, First_Token_Index);
         when Token_Pattern_Literal_Rule =>
            Result := Token_Pattern_Literal_Transform_Parse0
              (Parser, First_Token_Index);
         when Parse_Node_Expr_Rule =>
            Result := Parse_Node_Expr_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Rule_Ref_Rule =>
            Result := Grammar_Rule_Ref_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_List_Expr_Rule =>
            Result := Grammar_List_Expr_Transform_Parse3
              (Parser, First_Token_Index);
         when Grammar_List_Sep_Rule =>
            Result := Grammar_List_Sep_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Skip_Rule =>
            Result := Grammar_Skip_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Null_Rule =>
            Result := Grammar_Null_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Token_Rule =>
            Result := Grammar_Token_Transform_Parse0
              (Parser, First_Token_Index);
         when Type_Decl_Rule =>
            Result := Type_Decl_Or_Parse0
              (Parser, First_Token_Index);
         when Generic_Decl_Rule =>
            Result := Generic_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Generic_Formal_Type_Rule =>
            Result := Generic_Formal_Type_Transform_Parse1
              (Parser, First_Token_Index);
         when Enum_Lit_Decl_Rule =>
            Result := Enum_Lit_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Fun_Decl_Rule =>
            Result := Fun_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Lambda_Arg_Decl_Rule =>
            Result := Lambda_Arg_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Fun_Arg_Decl_Rule =>
            Result := Fun_Arg_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Fun_Arg_List_Rule =>
            Result := Fun_Arg_List_List_Parse0
              (Parser, First_Token_Index);
         when Lambda_Arg_List_Rule =>
            Result := Lambda_Arg_List_List_Parse0
              (Parser, First_Token_Index);
         when Field_Decl_Rule =>
            Result := Field_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Bare_Decl_Rule =>
            Result := Bare_Decl_Or_Parse0
              (Parser, First_Token_Index);
         when Decl_Rule =>
            Result := Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Type_Member_Ref_Rule =>
            Result := Type_Member_Ref_Transform_Parse0
              (Parser, First_Token_Index);
         when Type_Expr_Rule =>
            Result := Type_Expr_Or_Parse0
              (Parser, First_Token_Index);
         when Type_Ref_Rule =>
            Result := Type_Ref_Or_Parse0
              (Parser, First_Token_Index);
         when Type_List_Rule =>
            Result := Type_List_List_Parse0
              (Parser, First_Token_Index);
         when Decls_Rule =>
            Result := Decls_List_Parse0
              (Parser, First_Token_Index);
         when Decl_Block_Rule =>
            Result := Decl_Block_List_Parse0
              (Parser, First_Token_Index);
         when Val_Decl_Rule =>
            Result := Val_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Dynvar_Decl_Rule =>
            Result := Dynvar_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Var_Bind_Rule =>
            Result := Var_Bind_Transform_Parse0
              (Parser, First_Token_Index);
         when Env_Spec_Action_Rule =>
            Result := Env_Spec_Action_Transform_Parse1
              (Parser, First_Token_Index);
         when Env_Spec_Decl_Rule =>
            Result := Env_Spec_Decl_Transform_Parse1
              (Parser, First_Token_Index);
         when Block_Rule =>
            Result := Block_Transform_Parse0
              (Parser, First_Token_Index);
         when Expr_Rule =>
            Result := Expr_Or_Parse1
              (Parser, First_Token_Index);
         when Rel_Rule =>
            Result := Rel_Or_Parse0
              (Parser, First_Token_Index);
         when Eq_Rule =>
            Result := Eq_Or_Parse1
              (Parser, First_Token_Index);
         when Arith_1_Rule =>
            Result := Arith_1_Or_Parse1
              (Parser, First_Token_Index);
         when Arith_2_Rule =>
            Result := Arith_2_Or_Parse1
              (Parser, First_Token_Index);
         when Arith_3_Rule =>
            Result := Arith_3_Or_Parse1
              (Parser, First_Token_Index);
         when Isa_Or_Primary_Rule =>
            Result := Isa_Or_Primary_Or_Parse0
              (Parser, First_Token_Index);
         when Logic_Propagate_Call_Rule =>
            Result := Logic_Propagate_Call_Transform_Parse0
              (Parser, First_Token_Index);
         when Primary_Rule =>
            Result := Primary_Or_Parse0
              (Parser, First_Token_Index);
         when Match_Expr_Rule =>
            Result := Match_Expr_Transform_Parse2
              (Parser, First_Token_Index);
         when Num_Lit_Rule =>
            Result := Num_Lit_Transform_Parse0
              (Parser, First_Token_Index);
         when Big_Num_Lit_Rule =>
            Result := Big_Num_Lit_Transform_Parse0
              (Parser, First_Token_Index);
         when String_Lit_Rule =>
            Result := String_Lit_Or_Parse0
              (Parser, First_Token_Index);
         when Block_String_Lit_Rule =>
            Result := Block_String_Lit_Transform_Parse1
              (Parser, First_Token_Index);
         when Char_Lit_Rule =>
            Result := Char_Lit_Transform_Parse0
              (Parser, First_Token_Index);
         when If_Expr_Rule =>
            Result := If_Expr_Transform_Parse1
              (Parser, First_Token_Index);
         when Raise_Expr_Rule =>
            Result := Raise_Expr_Transform_Parse0
              (Parser, First_Token_Index);
         when Try_Expr_Rule =>
            Result := Try_Expr_Transform_Parse0
              (Parser, First_Token_Index);
         when Array_Literal_Rule =>
            Result := Array_Literal_Transform_Parse0
              (Parser, First_Token_Index);
         when Callable_Ref_Rule =>
            Result := Callable_Ref_Or_Parse0
              (Parser, First_Token_Index);
         when Basic_Expr_Rule =>
            Result := Basic_Expr_Or_Parse0
              (Parser, First_Token_Index);
         when Term_Rule =>
            Result := Term_Or_Parse0
              (Parser, First_Token_Index);
         when Basic_Name_Rule =>
            Result := Basic_Name_Or_Parse0
              (Parser, First_Token_Index);
         when Lambda_Expr_Rule =>
            Result := Lambda_Expr_Transform_Parse0
              (Parser, First_Token_Index);
         when Null_Lit_Rule =>
            Result := Null_Lit_Transform_Parse0
              (Parser, First_Token_Index);
         when Param_Rule =>
            Result := Param_Transform_Parse0
              (Parser, First_Token_Index);
         when Params_Rule =>
            Result := Params_List_Parse0
              (Parser, First_Token_Index);
         when Decl_Annotation_Params_Rule =>
            Result := Decl_Annotation_Params_Opt_Parse0
              (Parser, First_Token_Index);
         when Decl_Annotation_Rule =>
            Result := Decl_Annotation_Transform_Parse0
              (Parser, First_Token_Index);
      end case;
      Process_Parsing_Error (Parser, Check_Complete);
      Set_Parents (Result, null);
      return Parsed_Node (Result);
   exception
      when Exc : Property_Error =>
         Append
           (Parser.Diagnostics,
            No_Source_Location_Range,
            To_Text ("Error during parsing: "
                     & Ada.Exceptions.Exception_Message (Exc)));
         return Parsed_Node (No_Bare_Lkt_Node);
   end Parse;

   


function Arith_1_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

      Row_Pos0 :
            Token_Index
               := No_Token_Index;
      Defer_Pos0 :
            Token_Index
               := No_Token_Index;
      Defer_Res0 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Row_Pos1 :
            Token_Index
               := No_Token_Index;
      Token_Pos0 :
            Token_Index
               := No_Token_Index;
      Token_Res0 :
            Token_Index
               := No_Token_Index;
      Transform_Res0 :
            Bare_Op_Plus
               := No_Bare_Lkt_Node;
      Transform_Diags0 :
            Ada.Containers.Count_Type;
      Row_Pos2 :
            Token_Index
               := No_Token_Index;
      Token_Pos1 :
            Token_Index
               := No_Token_Index;
      Token_Res1 :
            Token_Index
               := No_Token_Index;
      Transform_Res1 :
            Bare_Op_Minus
               := No_Bare_Lkt_Node;
      Transform_Diags1 :
            Ada.Containers.Count_Type;
      Row_Pos3 :
            Token_Index
               := No_Token_Index;
      Token_Pos2 :
            Token_Index
               := No_Token_Index;
      Token_Res2 :
            Token_Index
               := No_Token_Index;
      Transform_Res2 :
            Bare_Op_Amp
               := No_Bare_Lkt_Node;
      Transform_Diags2 :
            Ada.Containers.Count_Type;
      Or_Pos0 :
            Token_Index
               := No_Token_Index;
      Or_Res0 :
            Bare_Op
               := No_Bare_Lkt_Node;
      Defer_Pos1 :
            Token_Index
               := No_Token_Index;
      Defer_Res1 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res3 :
            Bare_Bin_Op
               := No_Bare_Lkt_Node;
      Transform_Diags3 :
            Ada.Containers.Count_Type;
      Defer_Pos2 :
            Token_Index
               := No_Token_Index;
      Defer_Res2 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Or_Pos1 :
            Token_Index
               := No_Token_Index;
      Or_Res1 :
            Bare_Expr
               := No_Bare_Lkt_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Expr := No_Bare_Lkt_Node;

   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Arith_1_Or_Parse1_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res1 := M.Instance;
      return Or_Res1;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res1;
   end if;

       Set (PP.Arith_1_Or_Parse1_Memo, False, Or_Res1, Pos, Mem_Pos);

       <<Try_Again>>



   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'arith_1') at parser.lkt:257:16>

Or_Pos1 := No_Token_Index;
Or_Res1 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareBinOp>) (root of 'arith_1') at parser.lkt:258:11>

Transform_Diags3 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'arith_1') at ???>

Row_Pos0 := Pos;



--  BEGIN <Defer (for 'arith_1') at parser.lkt:258:17>

Defer_Res0 :=
   Arith_1_Or_Parse1 (Parser, Row_Pos0);
Defer_Pos0 := Parser.Current_Pos;

--  END <Defer (for 'arith_1') at parser.lkt:258:17>




if Defer_Pos0 /= No_Token_Index then

   Row_Pos0 := Defer_Pos0;

else
   Row_Pos0 := No_Token_Index;
   goto Exit_Row0_0;

end if;


--  BEGIN <Or (root of 'arith_1') at parser.lkt:258:25>

Or_Pos0 := No_Token_Index;
Or_Res0 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareOpPlus>) (root of 'arith_1') at parser.lkt:258:28>

Transform_Diags0 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'arith_1') at parser.lkt:258:28>

Row_Pos1 := Row_Pos0;



--  BEGIN <Token(<WithText Plus>, ) (root of 'arith_1') at parser.lkt:258:36>

Token_Res0 := Row_Pos1;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res0));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Plus)
   then
       Token_Pos0 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos1 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos1,
             Expected_Token_Id => Lkt_Plus,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos0 := Row_Pos1 + 1;
   end if;
end;

--  END <Token(<WithText Plus>, ) (root of 'arith_1') at parser.lkt:258:36>




if Token_Pos0 /= No_Token_Index then

   Row_Pos1 := Token_Pos0;

else
   Row_Pos1 := No_Token_Index;
   goto Exit_Row1_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row1_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'arith_1') at parser.lkt:258:28>



if Row_Pos1 /= No_Token_Index then

   Transform_Res0 := Allocate_Op_Plus (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res0,
      Kind => Lkt_Op_Plus,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos0,
      Token_End_Index   => (if Row_Pos1 = Row_Pos0
                            then No_Token_Index
                            else Row_Pos1 - 1));




elsif Row_Pos1 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags0);
end if;

--  END <Transform(<CompiledType BareOpPlus>) (root of 'arith_1') at parser.lkt:258:28>

    if Row_Pos1 /= No_Token_Index then
        Or_Pos0 := Row_Pos1;
        Or_Res0 := Transform_Res0;
        goto Exit_Or1;
    end if;
    
--  BEGIN <Transform(<CompiledType BareOpMinus>) (root of 'arith_1') at parser.lkt:258:43>

Transform_Diags1 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'arith_1') at parser.lkt:258:43>

Row_Pos2 := Row_Pos0;



--  BEGIN <Token(<WithText Minus>, ) (root of 'arith_1') at parser.lkt:258:52>

Token_Res1 := Row_Pos2;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res1));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Minus)
   then
       Token_Pos1 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos2 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos2,
             Expected_Token_Id => Lkt_Minus,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos1 := Row_Pos2 + 1;
   end if;
end;

--  END <Token(<WithText Minus>, ) (root of 'arith_1') at parser.lkt:258:52>




if Token_Pos1 /= No_Token_Index then

   Row_Pos2 := Token_Pos1;

else
   Row_Pos2 := No_Token_Index;
   goto Exit_Row2_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row2_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'arith_1') at parser.lkt:258:43>



if Row_Pos2 /= No_Token_Index then

   Transform_Res1 := Allocate_Op_Minus (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res1,
      Kind => Lkt_Op_Minus,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos0,
      Token_End_Index   => (if Row_Pos2 = Row_Pos0
                            then No_Token_Index
                            else Row_Pos2 - 1));




elsif Row_Pos2 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags1);
end if;

--  END <Transform(<CompiledType BareOpMinus>) (root of 'arith_1') at parser.lkt:258:43>

    if Row_Pos2 /= No_Token_Index then
        Or_Pos0 := Row_Pos2;
        Or_Res0 := Transform_Res1;
        goto Exit_Or1;
    end if;
    
--  BEGIN <Transform(<CompiledType BareOpAmp>) (root of 'arith_1') at parser.lkt:258:59>

Transform_Diags2 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'arith_1') at parser.lkt:258:59>

Row_Pos3 := Row_Pos0;



--  BEGIN <Token(<WithText Amp>, ) (root of 'arith_1') at parser.lkt:258:66>

Token_Res2 := Row_Pos3;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res2));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Amp)
   then
       Token_Pos2 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos3 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos3,
             Expected_Token_Id => Lkt_Amp,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos2 := Row_Pos3 + 1;
   end if;
end;

--  END <Token(<WithText Amp>, ) (root of 'arith_1') at parser.lkt:258:66>




if Token_Pos2 /= No_Token_Index then

   Row_Pos3 := Token_Pos2;

else
   Row_Pos3 := No_Token_Index;
   goto Exit_Row3_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row3_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'arith_1') at parser.lkt:258:59>



if Row_Pos3 /= No_Token_Index then

   Transform_Res2 := Allocate_Op_Amp (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res2,
      Kind => Lkt_Op_Amp,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos0,
      Token_End_Index   => (if Row_Pos3 = Row_Pos0
                            then No_Token_Index
                            else Row_Pos3 - 1));




elsif Row_Pos3 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags2);
end if;

--  END <Transform(<CompiledType BareOpAmp>) (root of 'arith_1') at parser.lkt:258:59>

    if Row_Pos3 /= No_Token_Index then
        Or_Pos0 := Row_Pos3;
        Or_Res0 := Transform_Res2;
        goto Exit_Or1;
    end if;
<<Exit_Or1>>

--  END <Or (root of 'arith_1') at parser.lkt:258:25>




if Or_Pos0 /= No_Token_Index then

   Row_Pos0 := Or_Pos0;

else
   Row_Pos0 := No_Token_Index;
   goto Exit_Row0_0;

end if;


--  BEGIN <Defer (for 'arith_2') at parser.lkt:258:72>

Defer_Res1 :=
   Arith_2_Or_Parse1 (Parser, Row_Pos0);
Defer_Pos1 := Parser.Current_Pos;

--  END <Defer (for 'arith_2') at parser.lkt:258:72>




if Defer_Pos1 /= No_Token_Index then

   Row_Pos0 := Defer_Pos1;

else
   Row_Pos0 := No_Token_Index;
   goto Exit_Row0_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row0_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'arith_1') at ???>



if Row_Pos0 /= No_Token_Index then

   Transform_Res3 := Allocate_Bin_Op (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res3,
      Kind => Lkt_Bin_Op,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos0 = Pos
                            then No_Token_Index
                            else Row_Pos0 - 1));

      
      Initialize_Fields_For_Bin_Op
        (Self => Transform_Res3,
         Bin_Op_F_Left => Defer_Res0,
         Bin_Op_F_Op => Or_Res0,
         Bin_Op_F_Right => Defer_Res1);

         if Defer_Res0 /= null and then Is_Incomplete (Defer_Res0) then
            Transform_Res3.Last_Attempted_Child := 0;
         elsif Defer_Res0 /= null and then not Is_Ghost (Defer_Res0) then
            Transform_Res3.Last_Attempted_Child := -1;
         end if;
         if Or_Res0 /= null and then Is_Incomplete (Or_Res0) then
            Transform_Res3.Last_Attempted_Child := 0;
         elsif Or_Res0 /= null and then not Is_Ghost (Or_Res0) then
            Transform_Res3.Last_Attempted_Child := -1;
         end if;
         if Defer_Res1 /= null and then Is_Incomplete (Defer_Res1) then
            Transform_Res3.Last_Attempted_Child := 0;
         elsif Defer_Res1 /= null and then not Is_Ghost (Defer_Res1) then
            Transform_Res3.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos0 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags3);
end if;

--  END <Transform(<CompiledType BareBinOp>) (root of 'arith_1') at parser.lkt:258:11>

    if Row_Pos0 /= No_Token_Index then
        Or_Pos1 := Row_Pos0;
        Or_Res1 := Transform_Res3;
        goto Exit_Or0;
    end if;
    
--  BEGIN <Defer (for 'arith_2') at parser.lkt:259:11>

Defer_Res2 :=
   Arith_2_Or_Parse1 (Parser, Pos);
Defer_Pos2 := Parser.Current_Pos;

--  END <Defer (for 'arith_2') at parser.lkt:259:11>

    if Defer_Pos2 /= No_Token_Index then
        Or_Pos1 := Defer_Pos2;
        Or_Res1 := Defer_Res2;
        goto Exit_Or0;
    end if;
<<Exit_Or0>>

--  END <Or (root of 'arith_1') at parser.lkt:257:16>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos1 > Mem_Pos then
         Mem_Pos := Or_Pos1;
         Mem_Res := Or_Res1;
         Set
           (PP.Arith_1_Or_Parse1_Memo,
            Or_Pos1 /= No_Token_Index,
            Or_Res1,
            Pos,
            Or_Pos1);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res1 := Mem_Res;
         Or_Pos1 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (PP.Arith_1_Or_Parse1_Memo,
      Or_Pos1 /= No_Token_Index,
      Or_Res1,
      Pos,
      Or_Pos1);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos1;

   return Or_Res1;
end Arith_1_Or_Parse1;

   


function Arith_2_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

      Row_Pos4 :
            Token_Index
               := No_Token_Index;
      Defer_Pos3 :
            Token_Index
               := No_Token_Index;
      Defer_Res3 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Row_Pos5 :
            Token_Index
               := No_Token_Index;
      Token_Pos3 :
            Token_Index
               := No_Token_Index;
      Token_Res3 :
            Token_Index
               := No_Token_Index;
      Transform_Res4 :
            Bare_Op_Mult
               := No_Bare_Lkt_Node;
      Transform_Diags4 :
            Ada.Containers.Count_Type;
      Row_Pos6 :
            Token_Index
               := No_Token_Index;
      Token_Pos4 :
            Token_Index
               := No_Token_Index;
      Token_Res4 :
            Token_Index
               := No_Token_Index;
      Transform_Res5 :
            Bare_Op_Div
               := No_Bare_Lkt_Node;
      Transform_Diags5 :
            Ada.Containers.Count_Type;
      Or_Pos2 :
            Token_Index
               := No_Token_Index;
      Or_Res2 :
            Bare_Op
               := No_Bare_Lkt_Node;
      Defer_Pos4 :
            Token_Index
               := No_Token_Index;
      Defer_Res4 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res6 :
            Bare_Bin_Op
               := No_Bare_Lkt_Node;
      Transform_Diags6 :
            Ada.Containers.Count_Type;
      Defer_Pos5 :
            Token_Index
               := No_Token_Index;
      Defer_Res5 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Or_Pos3 :
            Token_Index
               := No_Token_Index;
      Or_Res3 :
            Bare_Expr
               := No_Bare_Lkt_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Expr := No_Bare_Lkt_Node;

   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Arith_2_Or_Parse1_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res3 := M.Instance;
      return Or_Res3;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res3;
   end if;

       Set (PP.Arith_2_Or_Parse1_Memo, False, Or_Res3, Pos, Mem_Pos);

       <<Try_Again>>



   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'arith_2') at parser.lkt:261:16>

Or_Pos3 := No_Token_Index;
Or_Res3 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareBinOp>) (root of 'arith_2') at parser.lkt:262:11>

Transform_Diags6 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'arith_2') at ???>

Row_Pos4 := Pos;



--  BEGIN <Defer (for 'arith_2') at parser.lkt:262:17>

Defer_Res3 :=
   Arith_2_Or_Parse1 (Parser, Row_Pos4);
Defer_Pos3 := Parser.Current_Pos;

--  END <Defer (for 'arith_2') at parser.lkt:262:17>




if Defer_Pos3 /= No_Token_Index then

   Row_Pos4 := Defer_Pos3;

else
   Row_Pos4 := No_Token_Index;
   goto Exit_Row4_0;

end if;


--  BEGIN <Or (root of 'arith_2') at parser.lkt:262:25>

Or_Pos2 := No_Token_Index;
Or_Res2 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareOpMult>) (root of 'arith_2') at parser.lkt:262:28>

Transform_Diags4 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'arith_2') at parser.lkt:262:28>

Row_Pos5 := Row_Pos4;



--  BEGIN <Token(<WithText Times>, ) (root of 'arith_2') at parser.lkt:262:36>

Token_Res3 := Row_Pos5;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res3));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Times)
   then
       Token_Pos3 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos5 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos5,
             Expected_Token_Id => Lkt_Times,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos3 := Row_Pos5 + 1;
   end if;
end;

--  END <Token(<WithText Times>, ) (root of 'arith_2') at parser.lkt:262:36>




if Token_Pos3 /= No_Token_Index then

   Row_Pos5 := Token_Pos3;

else
   Row_Pos5 := No_Token_Index;
   goto Exit_Row5_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row5_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'arith_2') at parser.lkt:262:28>



if Row_Pos5 /= No_Token_Index then

   Transform_Res4 := Allocate_Op_Mult (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res4,
      Kind => Lkt_Op_Mult,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos4,
      Token_End_Index   => (if Row_Pos5 = Row_Pos4
                            then No_Token_Index
                            else Row_Pos5 - 1));




elsif Row_Pos5 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags4);
end if;

--  END <Transform(<CompiledType BareOpMult>) (root of 'arith_2') at parser.lkt:262:28>

    if Row_Pos5 /= No_Token_Index then
        Or_Pos2 := Row_Pos5;
        Or_Res2 := Transform_Res4;
        goto Exit_Or3;
    end if;
    
--  BEGIN <Transform(<CompiledType BareOpDiv>) (root of 'arith_2') at parser.lkt:262:43>

Transform_Diags5 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'arith_2') at parser.lkt:262:43>

Row_Pos6 := Row_Pos4;



--  BEGIN <Token(<WithText Div>, ) (root of 'arith_2') at parser.lkt:262:50>

Token_Res4 := Row_Pos6;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res4));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Div)
   then
       Token_Pos4 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos6 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos6,
             Expected_Token_Id => Lkt_Div,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos4 := Row_Pos6 + 1;
   end if;
end;

--  END <Token(<WithText Div>, ) (root of 'arith_2') at parser.lkt:262:50>




if Token_Pos4 /= No_Token_Index then

   Row_Pos6 := Token_Pos4;

else
   Row_Pos6 := No_Token_Index;
   goto Exit_Row6_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row6_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'arith_2') at parser.lkt:262:43>



if Row_Pos6 /= No_Token_Index then

   Transform_Res5 := Allocate_Op_Div (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res5,
      Kind => Lkt_Op_Div,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos4,
      Token_End_Index   => (if Row_Pos6 = Row_Pos4
                            then No_Token_Index
                            else Row_Pos6 - 1));




elsif Row_Pos6 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags5);
end if;

--  END <Transform(<CompiledType BareOpDiv>) (root of 'arith_2') at parser.lkt:262:43>

    if Row_Pos6 /= No_Token_Index then
        Or_Pos2 := Row_Pos6;
        Or_Res2 := Transform_Res5;
        goto Exit_Or3;
    end if;
<<Exit_Or3>>

--  END <Or (root of 'arith_2') at parser.lkt:262:25>




if Or_Pos2 /= No_Token_Index then

   Row_Pos4 := Or_Pos2;

else
   Row_Pos4 := No_Token_Index;
   goto Exit_Row4_0;

end if;


--  BEGIN <Defer (for 'arith_3') at parser.lkt:262:56>

Defer_Res4 :=
   Arith_3_Or_Parse1 (Parser, Row_Pos4);
Defer_Pos4 := Parser.Current_Pos;

--  END <Defer (for 'arith_3') at parser.lkt:262:56>




if Defer_Pos4 /= No_Token_Index then

   Row_Pos4 := Defer_Pos4;

else
   Row_Pos4 := No_Token_Index;
   goto Exit_Row4_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row4_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'arith_2') at ???>



if Row_Pos4 /= No_Token_Index then

   Transform_Res6 := Allocate_Bin_Op (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res6,
      Kind => Lkt_Bin_Op,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos4 = Pos
                            then No_Token_Index
                            else Row_Pos4 - 1));

      
      Initialize_Fields_For_Bin_Op
        (Self => Transform_Res6,
         Bin_Op_F_Left => Defer_Res3,
         Bin_Op_F_Op => Or_Res2,
         Bin_Op_F_Right => Defer_Res4);

         if Defer_Res3 /= null and then Is_Incomplete (Defer_Res3) then
            Transform_Res6.Last_Attempted_Child := 0;
         elsif Defer_Res3 /= null and then not Is_Ghost (Defer_Res3) then
            Transform_Res6.Last_Attempted_Child := -1;
         end if;
         if Or_Res2 /= null and then Is_Incomplete (Or_Res2) then
            Transform_Res6.Last_Attempted_Child := 0;
         elsif Or_Res2 /= null and then not Is_Ghost (Or_Res2) then
            Transform_Res6.Last_Attempted_Child := -1;
         end if;
         if Defer_Res4 /= null and then Is_Incomplete (Defer_Res4) then
            Transform_Res6.Last_Attempted_Child := 0;
         elsif Defer_Res4 /= null and then not Is_Ghost (Defer_Res4) then
            Transform_Res6.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos4 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags6);
end if;

--  END <Transform(<CompiledType BareBinOp>) (root of 'arith_2') at parser.lkt:262:11>

    if Row_Pos4 /= No_Token_Index then
        Or_Pos3 := Row_Pos4;
        Or_Res3 := Transform_Res6;
        goto Exit_Or2;
    end if;
    
--  BEGIN <Defer (for 'arith_3') at parser.lkt:263:11>

Defer_Res5 :=
   Arith_3_Or_Parse1 (Parser, Pos);
Defer_Pos5 := Parser.Current_Pos;

--  END <Defer (for 'arith_3') at parser.lkt:263:11>

    if Defer_Pos5 /= No_Token_Index then
        Or_Pos3 := Defer_Pos5;
        Or_Res3 := Defer_Res5;
        goto Exit_Or2;
    end if;
<<Exit_Or2>>

--  END <Or (root of 'arith_2') at parser.lkt:261:16>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos3 > Mem_Pos then
         Mem_Pos := Or_Pos3;
         Mem_Res := Or_Res3;
         Set
           (PP.Arith_2_Or_Parse1_Memo,
            Or_Pos3 /= No_Token_Index,
            Or_Res3,
            Pos,
            Or_Pos3);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res3 := Mem_Res;
         Or_Pos3 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (PP.Arith_2_Or_Parse1_Memo,
      Or_Pos3 /= No_Token_Index,
      Or_Res3,
      Pos,
      Or_Pos3);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos3;

   return Or_Res3;
end Arith_2_Or_Parse1;

   


function Arith_3_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

      Row_Pos7 :
            Token_Index
               := No_Token_Index;
      Row_Pos8 :
            Token_Index
               := No_Token_Index;
      Token_Pos5 :
            Token_Index
               := No_Token_Index;
      Token_Res5 :
            Token_Index
               := No_Token_Index;
      Transform_Res7 :
            Bare_Op_Plus
               := No_Bare_Lkt_Node;
      Transform_Diags7 :
            Ada.Containers.Count_Type;
      Row_Pos9 :
            Token_Index
               := No_Token_Index;
      Token_Pos6 :
            Token_Index
               := No_Token_Index;
      Token_Res6 :
            Token_Index
               := No_Token_Index;
      Transform_Res8 :
            Bare_Op_Minus
               := No_Bare_Lkt_Node;
      Transform_Diags8 :
            Ada.Containers.Count_Type;
      Or_Pos4 :
            Token_Index
               := No_Token_Index;
      Or_Res4 :
            Bare_Op
               := No_Bare_Lkt_Node;
      Defer_Pos6 :
            Token_Index
               := No_Token_Index;
      Defer_Res6 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res9 :
            Bare_Un_Op
               := No_Bare_Lkt_Node;
      Transform_Diags9 :
            Ada.Containers.Count_Type;
      Defer_Pos7 :
            Token_Index
               := No_Token_Index;
      Defer_Res7 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Or_Pos5 :
            Token_Index
               := No_Token_Index;
      Or_Res5 :
            Bare_Expr
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Arith_3_Or_Parse1_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res5 := M.Instance;
      return Or_Res5;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res5;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'arith_3') at parser.lkt:265:16>

Or_Pos5 := No_Token_Index;
Or_Res5 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareUnOp>) (root of 'arith_3') at parser.lkt:266:11>

Transform_Diags9 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'arith_3') at ???>

Row_Pos7 := Pos;



--  BEGIN <Or (root of 'arith_3') at parser.lkt:266:16>

Or_Pos4 := No_Token_Index;
Or_Res4 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareOpPlus>) (root of 'arith_3') at parser.lkt:266:19>

Transform_Diags7 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'arith_3') at parser.lkt:266:19>

Row_Pos8 := Row_Pos7;



--  BEGIN <Token(<WithText Plus>, ) (root of 'arith_3') at parser.lkt:266:27>

Token_Res5 := Row_Pos8;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res5));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Plus)
   then
       Token_Pos5 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos8 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos8,
             Expected_Token_Id => Lkt_Plus,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos5 := Row_Pos8 + 1;
   end if;
end;

--  END <Token(<WithText Plus>, ) (root of 'arith_3') at parser.lkt:266:27>




if Token_Pos5 /= No_Token_Index then

   Row_Pos8 := Token_Pos5;

else
   Row_Pos8 := No_Token_Index;
   goto Exit_Row8_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row8_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'arith_3') at parser.lkt:266:19>



if Row_Pos8 /= No_Token_Index then

   Transform_Res7 := Allocate_Op_Plus (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res7,
      Kind => Lkt_Op_Plus,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos7,
      Token_End_Index   => (if Row_Pos8 = Row_Pos7
                            then No_Token_Index
                            else Row_Pos8 - 1));




elsif Row_Pos8 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags7);
end if;

--  END <Transform(<CompiledType BareOpPlus>) (root of 'arith_3') at parser.lkt:266:19>

    if Row_Pos8 /= No_Token_Index then
        Or_Pos4 := Row_Pos8;
        Or_Res4 := Transform_Res7;
        goto Exit_Or5;
    end if;
    
--  BEGIN <Transform(<CompiledType BareOpMinus>) (root of 'arith_3') at parser.lkt:266:34>

Transform_Diags8 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'arith_3') at parser.lkt:266:34>

Row_Pos9 := Row_Pos7;



--  BEGIN <Token(<WithText Minus>, ) (root of 'arith_3') at parser.lkt:266:43>

Token_Res6 := Row_Pos9;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res6));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Minus)
   then
       Token_Pos6 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos9 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos9,
             Expected_Token_Id => Lkt_Minus,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos6 := Row_Pos9 + 1;
   end if;
end;

--  END <Token(<WithText Minus>, ) (root of 'arith_3') at parser.lkt:266:43>




if Token_Pos6 /= No_Token_Index then

   Row_Pos9 := Token_Pos6;

else
   Row_Pos9 := No_Token_Index;
   goto Exit_Row9_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row9_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'arith_3') at parser.lkt:266:34>



if Row_Pos9 /= No_Token_Index then

   Transform_Res8 := Allocate_Op_Minus (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res8,
      Kind => Lkt_Op_Minus,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos7,
      Token_End_Index   => (if Row_Pos9 = Row_Pos7
                            then No_Token_Index
                            else Row_Pos9 - 1));




elsif Row_Pos9 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags8);
end if;

--  END <Transform(<CompiledType BareOpMinus>) (root of 'arith_3') at parser.lkt:266:34>

    if Row_Pos9 /= No_Token_Index then
        Or_Pos4 := Row_Pos9;
        Or_Res4 := Transform_Res8;
        goto Exit_Or5;
    end if;
<<Exit_Or5>>

--  END <Or (root of 'arith_3') at parser.lkt:266:16>




if Or_Pos4 /= No_Token_Index then

   Row_Pos7 := Or_Pos4;

else
   Row_Pos7 := No_Token_Index;
   goto Exit_Row7_0;

end if;


--  BEGIN <Defer (for 'isa_or_primary') at parser.lkt:266:49>

Defer_Res6 :=
   Isa_Or_Primary_Or_Parse0 (Parser, Row_Pos7);
Defer_Pos6 := Parser.Current_Pos;

--  END <Defer (for 'isa_or_primary') at parser.lkt:266:49>




if Defer_Pos6 /= No_Token_Index then

   Row_Pos7 := Defer_Pos6;

else
   Row_Pos7 := No_Token_Index;
   goto Exit_Row7_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row7_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'arith_3') at ???>



if Row_Pos7 /= No_Token_Index then

   Transform_Res9 := Allocate_Un_Op (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res9,
      Kind => Lkt_Un_Op,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos7 = Pos
                            then No_Token_Index
                            else Row_Pos7 - 1));

      
      Initialize_Fields_For_Un_Op
        (Self => Transform_Res9,
         Un_Op_F_Op => Or_Res4,
         Un_Op_F_Expr => Defer_Res6);

         if Or_Res4 /= null and then Is_Incomplete (Or_Res4) then
            Transform_Res9.Last_Attempted_Child := 0;
         elsif Or_Res4 /= null and then not Is_Ghost (Or_Res4) then
            Transform_Res9.Last_Attempted_Child := -1;
         end if;
         if Defer_Res6 /= null and then Is_Incomplete (Defer_Res6) then
            Transform_Res9.Last_Attempted_Child := 0;
         elsif Defer_Res6 /= null and then not Is_Ghost (Defer_Res6) then
            Transform_Res9.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos7 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags9);
end if;

--  END <Transform(<CompiledType BareUnOp>) (root of 'arith_3') at parser.lkt:266:11>

    if Row_Pos7 /= No_Token_Index then
        Or_Pos5 := Row_Pos7;
        Or_Res5 := Transform_Res9;
        goto Exit_Or4;
    end if;
    
--  BEGIN <Defer (for 'isa_or_primary') at parser.lkt:267:11>

Defer_Res7 :=
   Isa_Or_Primary_Or_Parse0 (Parser, Pos);
Defer_Pos7 := Parser.Current_Pos;

--  END <Defer (for 'isa_or_primary') at parser.lkt:267:11>

    if Defer_Pos7 /= No_Token_Index then
        Or_Pos5 := Defer_Pos7;
        Or_Res5 := Defer_Res7;
        goto Exit_Or4;
    end if;
<<Exit_Or4>>

--  END <Or (root of 'arith_3') at parser.lkt:265:16>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Arith_3_Or_Parse1_Memo,
      Or_Pos5 /= No_Token_Index,
      Or_Res5,
      Pos,
      Or_Pos5);


   Parser.Current_Pos := Or_Pos5;

   return Or_Res5;
end Arith_3_Or_Parse1;

   


function Array_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Array_Literal
is
   use Bare_Array_Literal_Memos;

      Row_Pos10 :
            Token_Index
               := No_Token_Index;
      Token_Pos7 :
            Token_Index
               := No_Token_Index;
      Token_Res7 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos0 :
            Token_Index
               := No_Token_Index;
      Tmp_List0 :
            Free_Parse_List;
      Defer_Pos8 :
            Token_Index
               := No_Token_Index;
      Defer_Res8 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos8 :
            Token_Index
               := No_Token_Index;
      Token_Res8 :
            Token_Index
               := No_Token_Index;
      List_Pos0 :
            Token_Index
               := No_Token_Index;
      List_Res0 :
            Bare_Expr_List
               := No_Bare_Lkt_Node;
      Token_Pos9 :
            Token_Index
               := No_Token_Index;
      Token_Res9 :
            Token_Index
               := No_Token_Index;
      Row_Pos11 :
            Token_Index
               := No_Token_Index;
      Token_Pos10 :
            Token_Index
               := No_Token_Index;
      Token_Res10 :
            Token_Index
               := No_Token_Index;
      Defer_Pos9 :
            Token_Index
               := No_Token_Index;
      Defer_Res9 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Transform_Res10 :
            Bare_Array_Literal
               := No_Bare_Lkt_Node;
      Transform_Diags10 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Array_Literal_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res10 := M.Instance;
      return Transform_Res10;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res10;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareArrayLiteral>) (root of 'array_literal') at parser.lkt:312:22>

Transform_Diags10 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'array_literal') at ???>

Row_Pos10 := Pos;



--  BEGIN <Token(<WithText LBrack>, ) (root of 'array_literal') at parser.lkt:312:35>

Token_Res7 := Row_Pos10;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res7));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos7 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos10 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos10,
             Expected_Token_Id => Lkt_L_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos7 := Row_Pos10 + 1;
   end if;
end;

--  END <Token(<WithText LBrack>, ) (root of 'array_literal') at parser.lkt:312:35>




if Token_Pos7 /= No_Token_Index then

   Row_Pos10 := Token_Pos7;

else
   Row_Pos10 := No_Token_Index;
   goto Exit_Row10_0;

end if;


--  BEGIN <List (root of 'array_literal') at parser.lkt:312:39>

    List_Pos0 := Row_Pos10;



Lst_Cpos0 := Row_Pos10;
Tmp_List0 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'expr') at parser.lkt:312:45>

Defer_Res8 :=
   Expr_Or_Parse1 (Parser, Lst_Cpos0);
Defer_Pos8 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:312:45>


   exit when Defer_Pos8 = No_Token_Index;

   List_Pos0 := Defer_Pos8;
   Lst_Cpos0 := List_Pos0;

   Tmp_List0.Nodes.Append (Defer_Res8);

      
--  BEGIN <Token(<WithText Comma>, ) (root of 'array_literal') at parser.lkt:312:51>

Token_Res8 := Lst_Cpos0;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res8));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos8 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos0 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos0,
             Expected_Token_Id => Lkt_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos8 := Lst_Cpos0 + 1;
   end if;
end;

--  END <Token(<WithText Comma>, ) (root of 'array_literal') at parser.lkt:312:51>


      exit when Token_Pos8 = No_Token_Index;

      Lst_Cpos0 := Token_Pos8;

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List0.Nodes.Length;
begin
   List_Res0 := Allocate_Expr_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos10;
      Token_End := (if Lst_Cpos0 = Row_Pos10
                    then Row_Pos10
                    else List_Pos0 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos10, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res0,
      Kind              => Lkt_Expr_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res0,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List0.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res0.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List0);

--  END <List (root of 'array_literal') at parser.lkt:312:39>




if List_Pos0 /= No_Token_Index then

   Row_Pos10 := List_Pos0;

else
   Row_Pos10 := No_Token_Index;
   goto Exit_Row10_0;

end if;


--  BEGIN <Token(<WithText RBrack>, ) (root of 'array_literal') at parser.lkt:312:56>

Token_Res9 := Row_Pos10;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res9));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos9 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos10 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos10,
             Expected_Token_Id => Lkt_R_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos9 := Row_Pos10 + 1;
   end if;
end;

--  END <Token(<WithText RBrack>, ) (root of 'array_literal') at parser.lkt:312:56>




if Token_Pos9 /= No_Token_Index then

   Row_Pos10 := Token_Pos9;

else
   Row_Pos10 := No_Token_Index;
   goto Exit_Row10_0;

end if;


--  BEGIN <Opt (root of 'array_literal') at parser.lkt:312:60>












--  BEGIN <_Extract (root of 'array_literal') at parser.lkt:312:61>

--  BEGIN <_Row (root of 'array_literal') at ???>

Row_Pos11 := Row_Pos10;



--  BEGIN <Token(<WithText Colon>, ) (root of 'array_literal') at parser.lkt:312:66>

Token_Res10 := Row_Pos11;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res10));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos10 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos11 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos11,
             Expected_Token_Id => Lkt_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos10 := Row_Pos11 + 1;
   end if;
end;

--  END <Token(<WithText Colon>, ) (root of 'array_literal') at parser.lkt:312:66>




if Token_Pos10 /= No_Token_Index then

   Row_Pos11 := Token_Pos10;

else
   Row_Pos11 := No_Token_Index;
   goto Exit_Row11_0;

end if;


--  BEGIN <Defer (for 'type_ref') at parser.lkt:312:70>

Defer_Res9 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos11);
Defer_Pos9 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:312:70>




if Defer_Pos9 /= No_Token_Index then

   Row_Pos11 := Defer_Pos9;

else
   Row_Pos11 := No_Token_Index;
   goto Exit_Row11_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row11_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'array_literal') at ???>

--  END <_Extract (root of 'array_literal') at parser.lkt:312:61>


if Row_Pos11 = No_Token_Index then

         
   Defer_Res9 := No_Bare_Lkt_Node;



       
   Row_Pos11 := Row_Pos10;



end if;

--  END <Opt (root of 'array_literal') at parser.lkt:312:60>




if Row_Pos11 /= No_Token_Index then

   Row_Pos10 := Row_Pos11;

else
   Row_Pos10 := No_Token_Index;
   goto Exit_Row10_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row10_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'array_literal') at ???>



if Row_Pos10 /= No_Token_Index then

   Transform_Res10 := Allocate_Array_Literal (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res10,
      Kind => Lkt_Array_Literal,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos10 = Pos
                            then No_Token_Index
                            else Row_Pos10 - 1));

      
      Initialize_Fields_For_Array_Literal
        (Self => Transform_Res10,
         Array_Literal_F_Exprs => List_Res0,
         Array_Literal_F_Element_Type => Defer_Res9);

         if List_Res0 /= null and then Is_Incomplete (List_Res0) then
            Transform_Res10.Last_Attempted_Child := 0;
         elsif List_Res0 /= null and then not Is_Ghost (List_Res0) then
            Transform_Res10.Last_Attempted_Child := -1;
         end if;
         if Defer_Res9 /= null and then Is_Incomplete (Defer_Res9) then
            Transform_Res10.Last_Attempted_Child := 0;
         elsif Defer_Res9 /= null and then not Is_Ghost (Defer_Res9) then
            Transform_Res10.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos10 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags10);
end if;

--  END <Transform(<CompiledType BareArrayLiteral>) (root of 'array_literal') at parser.lkt:312:22>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Array_Literal_Transform_Parse0_Memo,
      Row_Pos10 /= No_Token_Index,
      Transform_Res10,
      Pos,
      Row_Pos10);


   Parser.Current_Pos := Row_Pos10;

   return Transform_Res10;
end Array_Literal_Transform_Parse0;

   


function Bare_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decl
is
   use Bare_Decl_Memos;

      Defer_Pos10 :
            Token_Index
               := No_Token_Index;
      Defer_Res10 :
            Bare_Generic_Decl
               := No_Bare_Lkt_Node;
      Defer_Pos11 :
            Token_Index
               := No_Token_Index;
      Defer_Res11 :
            Bare_Named_Type_Decl
               := No_Bare_Lkt_Node;
      Defer_Pos12 :
            Token_Index
               := No_Token_Index;
      Defer_Res12 :
            Bare_Fun_Decl
               := No_Bare_Lkt_Node;
      Defer_Pos13 :
            Token_Index
               := No_Token_Index;
      Defer_Res13 :
            Bare_Lexer_Decl
               := No_Bare_Lkt_Node;
      Defer_Pos14 :
            Token_Index
               := No_Token_Index;
      Defer_Res14 :
            Bare_Grammar_Decl
               := No_Bare_Lkt_Node;
      Defer_Pos15 :
            Token_Index
               := No_Token_Index;
      Defer_Res15 :
            Bare_Field_Decl
               := No_Bare_Lkt_Node;
      Defer_Pos16 :
            Token_Index
               := No_Token_Index;
      Defer_Res16 :
            Bare_Val_Decl
               := No_Bare_Lkt_Node;
      Defer_Pos17 :
            Token_Index
               := No_Token_Index;
      Defer_Res17 :
            Bare_Env_Spec_Decl
               := No_Bare_Lkt_Node;
      Defer_Pos18 :
            Token_Index
               := No_Token_Index;
      Defer_Res18 :
            Bare_Grammar_Rule_Decl
               := No_Bare_Lkt_Node;
      Defer_Pos19 :
            Token_Index
               := No_Token_Index;
      Defer_Res19 :
            Bare_Dyn_Var_Decl
               := No_Bare_Lkt_Node;
      Or_Pos6 :
            Token_Index
               := No_Token_Index;
      Or_Res6 :
            Bare_Decl
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Bare_Decl_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res6 := M.Instance;
      return Or_Res6;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res6;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'bare_decl') at parser.lkt:193:18>

Or_Pos6 := No_Token_Index;
Or_Res6 := No_Bare_Lkt_Node;
    
--  BEGIN <Defer (for 'generic_decl') at parser.lkt:194:11>

Defer_Res10 :=
   Generic_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos10 := Parser.Current_Pos;

--  END <Defer (for 'generic_decl') at parser.lkt:194:11>

    if Defer_Pos10 /= No_Token_Index then
        Or_Pos6 := Defer_Pos10;
        Or_Res6 := Defer_Res10;
        goto Exit_Or6;
    end if;
    
--  BEGIN <Defer (for 'type_decl') at parser.lkt:195:11>

Defer_Res11 :=
   Type_Decl_Or_Parse0 (Parser, Pos);
Defer_Pos11 := Parser.Current_Pos;

--  END <Defer (for 'type_decl') at parser.lkt:195:11>

    if Defer_Pos11 /= No_Token_Index then
        Or_Pos6 := Defer_Pos11;
        Or_Res6 := Defer_Res11;
        goto Exit_Or6;
    end if;
    
--  BEGIN <Defer (for 'fun_decl') at parser.lkt:196:11>

Defer_Res12 :=
   Fun_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos12 := Parser.Current_Pos;

--  END <Defer (for 'fun_decl') at parser.lkt:196:11>

    if Defer_Pos12 /= No_Token_Index then
        Or_Pos6 := Defer_Pos12;
        Or_Res6 := Defer_Res12;
        goto Exit_Or6;
    end if;
    
--  BEGIN <Defer (for 'lexer_decl') at parser.lkt:197:11>

Defer_Res13 :=
   Lexer_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos13 := Parser.Current_Pos;

--  END <Defer (for 'lexer_decl') at parser.lkt:197:11>

    if Defer_Pos13 /= No_Token_Index then
        Or_Pos6 := Defer_Pos13;
        Or_Res6 := Defer_Res13;
        goto Exit_Or6;
    end if;
    
--  BEGIN <Defer (for 'grammar_decl') at parser.lkt:198:11>

Defer_Res14 :=
   Grammar_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos14 := Parser.Current_Pos;

--  END <Defer (for 'grammar_decl') at parser.lkt:198:11>

    if Defer_Pos14 /= No_Token_Index then
        Or_Pos6 := Defer_Pos14;
        Or_Res6 := Defer_Res14;
        goto Exit_Or6;
    end if;
    
--  BEGIN <Defer (for 'field_decl') at parser.lkt:199:11>

Defer_Res15 :=
   Field_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos15 := Parser.Current_Pos;

--  END <Defer (for 'field_decl') at parser.lkt:199:11>

    if Defer_Pos15 /= No_Token_Index then
        Or_Pos6 := Defer_Pos15;
        Or_Res6 := Defer_Res15;
        goto Exit_Or6;
    end if;
    
--  BEGIN <Defer (for 'val_decl') at parser.lkt:200:11>

Defer_Res16 :=
   Val_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos16 := Parser.Current_Pos;

--  END <Defer (for 'val_decl') at parser.lkt:200:11>

    if Defer_Pos16 /= No_Token_Index then
        Or_Pos6 := Defer_Pos16;
        Or_Res6 := Defer_Res16;
        goto Exit_Or6;
    end if;
    
--  BEGIN <Defer (for 'env_spec_decl') at parser.lkt:201:11>

Defer_Res17 :=
   Env_Spec_Decl_Transform_Parse1 (Parser, Pos);
Defer_Pos17 := Parser.Current_Pos;

--  END <Defer (for 'env_spec_decl') at parser.lkt:201:11>

    if Defer_Pos17 /= No_Token_Index then
        Or_Pos6 := Defer_Pos17;
        Or_Res6 := Defer_Res17;
        goto Exit_Or6;
    end if;
    
--  BEGIN <Defer (for 'grammar_rule') at parser.lkt:202:11>

Defer_Res18 :=
   Grammar_Rule_Transform_Parse0 (Parser, Pos);
Defer_Pos18 := Parser.Current_Pos;

--  END <Defer (for 'grammar_rule') at parser.lkt:202:11>

    if Defer_Pos18 /= No_Token_Index then
        Or_Pos6 := Defer_Pos18;
        Or_Res6 := Defer_Res18;
        goto Exit_Or6;
    end if;
    
--  BEGIN <Defer (for 'dynvar_decl') at parser.lkt:203:11>

Defer_Res19 :=
   Dynvar_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos19 := Parser.Current_Pos;

--  END <Defer (for 'dynvar_decl') at parser.lkt:203:11>

    if Defer_Pos19 /= No_Token_Index then
        Or_Pos6 := Defer_Pos19;
        Or_Res6 := Defer_Res19;
        goto Exit_Or6;
    end if;
<<Exit_Or6>>

--  END <Or (root of 'bare_decl') at parser.lkt:193:18>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Bare_Decl_Or_Parse0_Memo,
      Or_Pos6 /= No_Token_Index,
      Or_Res6,
      Pos,
      Or_Pos6);


   Parser.Current_Pos := Or_Pos6;

   return Or_Res6;
end Bare_Decl_Or_Parse0;

   


function Basic_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

      Nobt0 :
            Boolean
               := False;
      Row_Pos12 :
            Token_Index
               := No_Token_Index;
      Defer_Pos20 :
            Token_Index
               := No_Token_Index;
      Defer_Res20 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos11 :
            Token_Index
               := No_Token_Index;
      Token_Res11 :
            Token_Index
               := No_Token_Index;
      Defer_Pos21 :
            Token_Index
               := No_Token_Index;
      Defer_Res21 :
            Bare_Param_List
               := No_Bare_Lkt_Node;
      Token_Pos12 :
            Token_Index
               := No_Token_Index;
      Token_Res12 :
            Token_Index
               := No_Token_Index;
      Transform_Res11 :
            Bare_Call_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags11 :
            Ada.Containers.Count_Type;
      Row_Pos13 :
            Token_Index
               := No_Token_Index;
      Defer_Pos22 :
            Token_Index
               := No_Token_Index;
      Defer_Res22 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos13 :
            Token_Index
               := No_Token_Index;
      Token_Res13 :
            Token_Index
               := No_Token_Index;
      Defer_Pos23 :
            Token_Index
               := No_Token_Index;
      Defer_Res23 :
            Bare_Type_Ref_List
               := No_Bare_Lkt_Node;
      Token_Pos14 :
            Token_Index
               := No_Token_Index;
      Token_Res14 :
            Token_Index
               := No_Token_Index;
      Transform_Res12 :
            Bare_Generic_Instantiation
               := No_Bare_Lkt_Node;
      Transform_Diags12 :
            Ada.Containers.Count_Type;
      Row_Pos14 :
            Token_Index
               := No_Token_Index;
      Defer_Pos24 :
            Token_Index
               := No_Token_Index;
      Defer_Res24 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos15 :
            Token_Index
               := No_Token_Index;
      Token_Res15 :
            Token_Index
               := No_Token_Index;
      Defer_Pos25 :
            Token_Index
               := No_Token_Index;
      Defer_Res25 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos16 :
            Token_Index
               := No_Token_Index;
      Token_Res16 :
            Token_Index
               := No_Token_Index;
      Transform_Res13 :
            Bare_Subscript_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags13 :
            Ada.Containers.Count_Type;
      Row_Pos15 :
            Token_Index
               := No_Token_Index;
      Defer_Pos26 :
            Token_Index
               := No_Token_Index;
      Defer_Res26 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos17 :
            Token_Index
               := No_Token_Index;
      Token_Res17 :
            Token_Index
               := No_Token_Index;
      Token_Pos18 :
            Token_Index
               := No_Token_Index;
      Token_Res18 :
            Token_Index
               := No_Token_Index;
      Defer_Pos27 :
            Token_Index
               := No_Token_Index;
      Defer_Res27 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos19 :
            Token_Index
               := No_Token_Index;
      Token_Res19 :
            Token_Index
               := No_Token_Index;
      Transform_Res14 :
            Bare_Null_Cond_Subscript_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags14 :
            Ada.Containers.Count_Type;
      Row_Pos16 :
            Token_Index
               := No_Token_Index;
      Defer_Pos28 :
            Token_Index
               := No_Token_Index;
      Defer_Res28 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos20 :
            Token_Index
               := No_Token_Index;
      Token_Res20 :
            Token_Index
               := No_Token_Index;
      Transform_Res15 :
            Bare_Error_On_Null
               := No_Bare_Lkt_Node;
      Transform_Diags15 :
            Ada.Containers.Count_Type;
      Row_Pos17 :
            Token_Index
               := No_Token_Index;
      Defer_Pos29 :
            Token_Index
               := No_Token_Index;
      Defer_Res29 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos21 :
            Token_Index
               := No_Token_Index;
      Token_Res21 :
            Token_Index
               := No_Token_Index;
      Token_Pos22 :
            Token_Index
               := No_Token_Index;
      Token_Res22 :
            Token_Index
               := No_Token_Index;
      Token_Pos23 :
            Token_Index
               := No_Token_Index;
      Token_Res23 :
            Token_Index
               := No_Token_Index;
      Defer_Pos30 :
            Token_Index
               := No_Token_Index;
      Defer_Res30 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Token_Pos24 :
            Token_Index
               := No_Token_Index;
      Token_Res24 :
            Token_Index
               := No_Token_Index;
      Transform_Res16 :
            Bare_Keep_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags16 :
            Ada.Containers.Count_Type;
      Row_Pos18 :
            Token_Index
               := No_Token_Index;
      Defer_Pos31 :
            Token_Index
               := No_Token_Index;
      Defer_Res31 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos25 :
            Token_Index
               := No_Token_Index;
      Token_Res25 :
            Token_Index
               := No_Token_Index;
      Token_Pos26 :
            Token_Index
               := No_Token_Index;
      Token_Res26 :
            Token_Index
               := No_Token_Index;
      Token_Pos27 :
            Token_Index
               := No_Token_Index;
      Token_Res27 :
            Token_Index
               := No_Token_Index;
      Opt_Res0 :
            Bare_Excludes_Null
               := No_Bare_Lkt_Node;
      Token_Pos28 :
            Token_Index
               := No_Token_Index;
      Token_Res28 :
            Token_Index
               := No_Token_Index;
      Defer_Pos32 :
            Token_Index
               := No_Token_Index;
      Defer_Res32 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Token_Pos29 :
            Token_Index
               := No_Token_Index;
      Token_Res29 :
            Token_Index
               := No_Token_Index;
      Transform_Res17 :
            Bare_Cast_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags17 :
            Ada.Containers.Count_Type;
      Row_Pos19 :
            Token_Index
               := No_Token_Index;
      Defer_Pos33 :
            Token_Index
               := No_Token_Index;
      Defer_Res33 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos30 :
            Token_Index
               := No_Token_Index;
      Token_Res30 :
            Token_Index
               := No_Token_Index;
      Token_Pos31 :
            Token_Index
               := No_Token_Index;
      Token_Res31 :
            Token_Index
               := No_Token_Index;
      Defer_Pos34 :
            Token_Index
               := No_Token_Index;
      Defer_Res34 :
            Bare_Param_List
               := No_Bare_Lkt_Node;
      Token_Pos32 :
            Token_Index
               := No_Token_Index;
      Token_Res32 :
            Token_Index
               := No_Token_Index;
      Transform_Res18 :
            Bare_Logic_Predicate
               := No_Bare_Lkt_Node;
      Transform_Diags18 :
            Ada.Containers.Count_Type;
      Row_Pos20 :
            Token_Index
               := No_Token_Index;
      Defer_Pos35 :
            Token_Index
               := No_Token_Index;
      Defer_Res35 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos33 :
            Token_Index
               := No_Token_Index;
      Token_Res33 :
            Token_Index
               := No_Token_Index;
      Defer_Pos36 :
            Token_Index
               := No_Token_Index;
      Defer_Res36 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Row_Progress0 :
            Integer
               := 0;
      Transform_Res19 :
            Bare_Dot_Expr
               := No_Bare_Lkt_Node;
      Transform_Has_Failed0 :
            Boolean
               := False;
      Transform_Diags19 :
            Ada.Containers.Count_Type;
      Row_Pos21 :
            Token_Index
               := No_Token_Index;
      Defer_Pos37 :
            Token_Index
               := No_Token_Index;
      Defer_Res37 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos34 :
            Token_Index
               := No_Token_Index;
      Token_Res34 :
            Token_Index
               := No_Token_Index;
      Token_Pos35 :
            Token_Index
               := No_Token_Index;
      Token_Res35 :
            Token_Index
               := No_Token_Index;
      Defer_Pos38 :
            Token_Index
               := No_Token_Index;
      Defer_Res38 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Transform_Res20 :
            Bare_Null_Cond_Dotted_Name
               := No_Bare_Lkt_Node;
      Transform_Diags20 :
            Ada.Containers.Count_Type;
      Row_Pos22 :
            Token_Index
               := No_Token_Index;
      Token_Pos36 :
            Token_Index
               := No_Token_Index;
      Token_Res36 :
            Token_Index
               := No_Token_Index;
      Row_Pos23 :
            Token_Index
               := No_Token_Index;
      Defer_Pos39 :
            Token_Index
               := No_Token_Index;
      Defer_Res39 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Token_Pos37 :
            Token_Index
               := No_Token_Index;
      Token_Res37 :
            Token_Index
               := No_Token_Index;
      Defer_Pos40 :
            Token_Index
               := No_Token_Index;
      Defer_Res40 :
            Bare_Param_List
               := No_Bare_Lkt_Node;
      Token_Pos38 :
            Token_Index
               := No_Token_Index;
      Token_Res38 :
            Token_Index
               := No_Token_Index;
      Transform_Res21 :
            Bare_Call_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags21 :
            Ada.Containers.Count_Type;
      Transform_Res22 :
            Bare_Logic_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags22 :
            Ada.Containers.Count_Type;
      Row_Pos24 :
            Token_Index
               := No_Token_Index;
      Token_Pos39 :
            Token_Index
               := No_Token_Index;
      Token_Res39 :
            Token_Index
               := No_Token_Index;
      Defer_Pos41 :
            Token_Index
               := No_Token_Index;
      Defer_Res41 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Transform_Res23 :
            Bare_Logic_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags23 :
            Ada.Containers.Count_Type;
      Defer_Pos42 :
            Token_Index
               := No_Token_Index;
      Defer_Res42 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Or_Pos7 :
            Token_Index
               := No_Token_Index;
      Or_Res7 :
            Bare_Expr
               := No_Bare_Lkt_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Expr := No_Bare_Lkt_Node;

   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Basic_Expr_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res7 := M.Instance;
      return Or_Res7;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res7;
   end if;

       Set (PP.Basic_Expr_Or_Parse0_Memo, False, Or_Res7, Pos, Mem_Pos);

       <<Try_Again>>

      Nobt0 := False;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'basic_expr') at parser.lkt:314:19>

Or_Pos7 := No_Token_Index;
Or_Res7 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareCallExpr>) (root of 'basic_expr') at parser.lkt:315:11>

Transform_Diags11 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'basic_expr') at ???>

Row_Pos12 := Pos;



--  BEGIN <Defer (for 'basic_expr') at parser.lkt:315:20>

Defer_Res20 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos12);
Defer_Pos20 := Parser.Current_Pos;

--  END <Defer (for 'basic_expr') at parser.lkt:315:20>




if Defer_Pos20 /= No_Token_Index then

   Row_Pos12 := Defer_Pos20;

else
   Row_Pos12 := No_Token_Index;
   goto Exit_Row12_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'basic_expr') at parser.lkt:315:31>

Token_Res11 := Row_Pos12;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res11));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos11 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos12 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos12,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos11 := Row_Pos12 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'basic_expr') at parser.lkt:315:31>




if Token_Pos11 /= No_Token_Index then

   Row_Pos12 := Token_Pos11;

else
   Row_Pos12 := No_Token_Index;
   goto Exit_Row12_0;

end if;


--  BEGIN <Defer (for 'params') at parser.lkt:315:35>

Defer_Res21 :=
   Params_List_Parse0 (Parser, Row_Pos12);
Defer_Pos21 := Parser.Current_Pos;

--  END <Defer (for 'params') at parser.lkt:315:35>




if Defer_Pos21 /= No_Token_Index then

   Row_Pos12 := Defer_Pos21;

else
   Row_Pos12 := No_Token_Index;
   goto Exit_Row12_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'basic_expr') at parser.lkt:315:42>

Token_Res12 := Row_Pos12;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res12));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos12 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos12 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos12,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos12 := Row_Pos12 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'basic_expr') at parser.lkt:315:42>




if Token_Pos12 /= No_Token_Index then

   Row_Pos12 := Token_Pos12;

else
   Row_Pos12 := No_Token_Index;
   goto Exit_Row12_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row12_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'basic_expr') at ???>



if Row_Pos12 /= No_Token_Index then

   Transform_Res11 := Allocate_Call_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res11,
      Kind => Lkt_Call_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos12 = Pos
                            then No_Token_Index
                            else Row_Pos12 - 1));

      
      Initialize_Fields_For_Call_Expr
        (Self => Transform_Res11,
         Base_Call_Expr_F_Name => Defer_Res20,
         Base_Call_Expr_F_Args => Defer_Res21);

         if Defer_Res20 /= null and then Is_Incomplete (Defer_Res20) then
            Transform_Res11.Last_Attempted_Child := 0;
         elsif Defer_Res20 /= null and then not Is_Ghost (Defer_Res20) then
            Transform_Res11.Last_Attempted_Child := -1;
         end if;
         if Defer_Res21 /= null and then Is_Incomplete (Defer_Res21) then
            Transform_Res11.Last_Attempted_Child := 0;
         elsif Defer_Res21 /= null and then not Is_Ghost (Defer_Res21) then
            Transform_Res11.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos12 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags11);
end if;

--  END <Transform(<CompiledType BareCallExpr>) (root of 'basic_expr') at parser.lkt:315:11>

    if Row_Pos12 /= No_Token_Index then
        Or_Pos7 := Row_Pos12;
        Or_Res7 := Transform_Res11;
        goto Exit_Or7;
    end if;
    
--  BEGIN <Transform(<CompiledType BareGenericInstantiation>) (root of 'basic_expr') at parser.lkt:316:11>

Transform_Diags12 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'basic_expr') at ???>

Row_Pos13 := Pos;



--  BEGIN <Defer (for 'basic_expr') at parser.lkt:316:32>

Defer_Res22 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos13);
Defer_Pos22 := Parser.Current_Pos;

--  END <Defer (for 'basic_expr') at parser.lkt:316:32>




if Defer_Pos22 /= No_Token_Index then

   Row_Pos13 := Defer_Pos22;

else
   Row_Pos13 := No_Token_Index;
   goto Exit_Row13_0;

end if;


--  BEGIN <Token(<WithText LBrack>, ) (root of 'basic_expr') at parser.lkt:316:43>

Token_Res13 := Row_Pos13;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res13));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos13 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos13 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos13,
             Expected_Token_Id => Lkt_L_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos13 := Row_Pos13 + 1;
   end if;
end;

--  END <Token(<WithText LBrack>, ) (root of 'basic_expr') at parser.lkt:316:43>




if Token_Pos13 /= No_Token_Index then

   Row_Pos13 := Token_Pos13;

else
   Row_Pos13 := No_Token_Index;
   goto Exit_Row13_0;

end if;


--  BEGIN <Defer (for 'type_list') at parser.lkt:316:47>

Defer_Res23 :=
   Type_List_List_Parse0 (Parser, Row_Pos13);
Defer_Pos23 := Parser.Current_Pos;

--  END <Defer (for 'type_list') at parser.lkt:316:47>




if Defer_Pos23 /= No_Token_Index then

   Row_Pos13 := Defer_Pos23;

else
   Row_Pos13 := No_Token_Index;
   goto Exit_Row13_0;

end if;


--  BEGIN <Token(<WithText RBrack>, ) (root of 'basic_expr') at parser.lkt:316:57>

Token_Res14 := Row_Pos13;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res14));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos14 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos13 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos13,
             Expected_Token_Id => Lkt_R_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos14 := Row_Pos13 + 1;
   end if;
end;

--  END <Token(<WithText RBrack>, ) (root of 'basic_expr') at parser.lkt:316:57>




if Token_Pos14 /= No_Token_Index then

   Row_Pos13 := Token_Pos14;

else
   Row_Pos13 := No_Token_Index;
   goto Exit_Row13_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row13_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'basic_expr') at ???>



if Row_Pos13 /= No_Token_Index then

   Transform_Res12 := Allocate_Generic_Instantiation (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res12,
      Kind => Lkt_Generic_Instantiation,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos13 = Pos
                            then No_Token_Index
                            else Row_Pos13 - 1));

      
      Initialize_Fields_For_Generic_Instantiation
        (Self => Transform_Res12,
         Generic_Instantiation_F_Name => Defer_Res22,
         Generic_Instantiation_F_Args => Defer_Res23);

         if Defer_Res22 /= null and then Is_Incomplete (Defer_Res22) then
            Transform_Res12.Last_Attempted_Child := 0;
         elsif Defer_Res22 /= null and then not Is_Ghost (Defer_Res22) then
            Transform_Res12.Last_Attempted_Child := -1;
         end if;
         if Defer_Res23 /= null and then Is_Incomplete (Defer_Res23) then
            Transform_Res12.Last_Attempted_Child := 0;
         elsif Defer_Res23 /= null and then not Is_Ghost (Defer_Res23) then
            Transform_Res12.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos13 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags12);
end if;

--  END <Transform(<CompiledType BareGenericInstantiation>) (root of 'basic_expr') at parser.lkt:316:11>

    if Row_Pos13 /= No_Token_Index then
        Or_Pos7 := Row_Pos13;
        Or_Res7 := Transform_Res12;
        goto Exit_Or7;
    end if;
    
--  BEGIN <Transform(<CompiledType BareSubscriptExpr>) (root of 'basic_expr') at parser.lkt:317:11>

Transform_Diags13 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'basic_expr') at ???>

Row_Pos14 := Pos;



--  BEGIN <Defer (for 'basic_expr') at parser.lkt:317:25>

Defer_Res24 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos14);
Defer_Pos24 := Parser.Current_Pos;

--  END <Defer (for 'basic_expr') at parser.lkt:317:25>




if Defer_Pos24 /= No_Token_Index then

   Row_Pos14 := Defer_Pos24;

else
   Row_Pos14 := No_Token_Index;
   goto Exit_Row14_0;

end if;


--  BEGIN <Token(<WithText LBrack>, ) (root of 'basic_expr') at parser.lkt:317:36>

Token_Res15 := Row_Pos14;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res15));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos15 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos14 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos14,
             Expected_Token_Id => Lkt_L_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos15 := Row_Pos14 + 1;
   end if;
end;

--  END <Token(<WithText LBrack>, ) (root of 'basic_expr') at parser.lkt:317:36>




if Token_Pos15 /= No_Token_Index then

   Row_Pos14 := Token_Pos15;

else
   Row_Pos14 := No_Token_Index;
   goto Exit_Row14_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:317:40>

Defer_Res25 :=
   Expr_Or_Parse1 (Parser, Row_Pos14);
Defer_Pos25 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:317:40>




if Defer_Pos25 /= No_Token_Index then

   Row_Pos14 := Defer_Pos25;

else
   Row_Pos14 := No_Token_Index;
   goto Exit_Row14_0;

end if;


--  BEGIN <Token(<WithText RBrack>, ) (root of 'basic_expr') at parser.lkt:317:45>

Token_Res16 := Row_Pos14;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res16));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos16 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos14 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos14,
             Expected_Token_Id => Lkt_R_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos16 := Row_Pos14 + 1;
   end if;
end;

--  END <Token(<WithText RBrack>, ) (root of 'basic_expr') at parser.lkt:317:45>




if Token_Pos16 /= No_Token_Index then

   Row_Pos14 := Token_Pos16;

else
   Row_Pos14 := No_Token_Index;
   goto Exit_Row14_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row14_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'basic_expr') at ???>



if Row_Pos14 /= No_Token_Index then

   Transform_Res13 := Allocate_Subscript_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res13,
      Kind => Lkt_Subscript_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos14 = Pos
                            then No_Token_Index
                            else Row_Pos14 - 1));

      
      Initialize_Fields_For_Subscript_Expr
        (Self => Transform_Res13,
         Subscript_Expr_F_Prefix => Defer_Res24,
         Subscript_Expr_F_Index => Defer_Res25);

         if Defer_Res24 /= null and then Is_Incomplete (Defer_Res24) then
            Transform_Res13.Last_Attempted_Child := 0;
         elsif Defer_Res24 /= null and then not Is_Ghost (Defer_Res24) then
            Transform_Res13.Last_Attempted_Child := -1;
         end if;
         if Defer_Res25 /= null and then Is_Incomplete (Defer_Res25) then
            Transform_Res13.Last_Attempted_Child := 0;
         elsif Defer_Res25 /= null and then not Is_Ghost (Defer_Res25) then
            Transform_Res13.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos14 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags13);
end if;

--  END <Transform(<CompiledType BareSubscriptExpr>) (root of 'basic_expr') at parser.lkt:317:11>

    if Row_Pos14 /= No_Token_Index then
        Or_Pos7 := Row_Pos14;
        Or_Res7 := Transform_Res13;
        goto Exit_Or7;
    end if;
    
--  BEGIN <Transform(<CompiledType BareNullCondSubscriptExpr>) (root of 'basic_expr') at parser.lkt:318:11>

Transform_Diags14 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'basic_expr') at ???>

Row_Pos15 := Pos;



--  BEGIN <Defer (for 'basic_expr') at parser.lkt:318:33>

Defer_Res26 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos15);
Defer_Pos26 := Parser.Current_Pos;

--  END <Defer (for 'basic_expr') at parser.lkt:318:33>




if Defer_Pos26 /= No_Token_Index then

   Row_Pos15 := Defer_Pos26;

else
   Row_Pos15 := No_Token_Index;
   goto Exit_Row15_0;

end if;


--  BEGIN <Token(<WithText IntMark>, ) (root of 'basic_expr') at parser.lkt:318:44>

Token_Res17 := Row_Pos15;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res17));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Int_Mark)
   then
       Token_Pos17 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos15 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos15,
             Expected_Token_Id => Lkt_Int_Mark,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos17 := Row_Pos15 + 1;
   end if;
end;

--  END <Token(<WithText IntMark>, ) (root of 'basic_expr') at parser.lkt:318:44>




if Token_Pos17 /= No_Token_Index then

   Row_Pos15 := Token_Pos17;

else
   Row_Pos15 := No_Token_Index;
   goto Exit_Row15_0;

end if;


--  BEGIN <Token(<WithText LBrack>, ) (root of 'basic_expr') at parser.lkt:318:48>

Token_Res18 := Row_Pos15;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res18));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos18 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos15 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos15,
             Expected_Token_Id => Lkt_L_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos18 := Row_Pos15 + 1;
   end if;
end;

--  END <Token(<WithText LBrack>, ) (root of 'basic_expr') at parser.lkt:318:48>




if Token_Pos18 /= No_Token_Index then

   Row_Pos15 := Token_Pos18;

else
   Row_Pos15 := No_Token_Index;
   goto Exit_Row15_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:318:52>

Defer_Res27 :=
   Expr_Or_Parse1 (Parser, Row_Pos15);
Defer_Pos27 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:318:52>




if Defer_Pos27 /= No_Token_Index then

   Row_Pos15 := Defer_Pos27;

else
   Row_Pos15 := No_Token_Index;
   goto Exit_Row15_0;

end if;


--  BEGIN <Token(<WithText RBrack>, ) (root of 'basic_expr') at parser.lkt:318:57>

Token_Res19 := Row_Pos15;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res19));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos19 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos15 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos15,
             Expected_Token_Id => Lkt_R_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos19 := Row_Pos15 + 1;
   end if;
end;

--  END <Token(<WithText RBrack>, ) (root of 'basic_expr') at parser.lkt:318:57>




if Token_Pos19 /= No_Token_Index then

   Row_Pos15 := Token_Pos19;

else
   Row_Pos15 := No_Token_Index;
   goto Exit_Row15_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row15_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'basic_expr') at ???>



if Row_Pos15 /= No_Token_Index then

   Transform_Res14 := Allocate_Null_Cond_Subscript_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res14,
      Kind => Lkt_Null_Cond_Subscript_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos15 = Pos
                            then No_Token_Index
                            else Row_Pos15 - 1));

      
      Initialize_Fields_For_Null_Cond_Subscript_Expr
        (Self => Transform_Res14,
         Subscript_Expr_F_Prefix => Defer_Res26,
         Subscript_Expr_F_Index => Defer_Res27);

         if Defer_Res26 /= null and then Is_Incomplete (Defer_Res26) then
            Transform_Res14.Last_Attempted_Child := 0;
         elsif Defer_Res26 /= null and then not Is_Ghost (Defer_Res26) then
            Transform_Res14.Last_Attempted_Child := -1;
         end if;
         if Defer_Res27 /= null and then Is_Incomplete (Defer_Res27) then
            Transform_Res14.Last_Attempted_Child := 0;
         elsif Defer_Res27 /= null and then not Is_Ghost (Defer_Res27) then
            Transform_Res14.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos15 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags14);
end if;

--  END <Transform(<CompiledType BareNullCondSubscriptExpr>) (root of 'basic_expr') at parser.lkt:318:11>

    if Row_Pos15 /= No_Token_Index then
        Or_Pos7 := Row_Pos15;
        Or_Res7 := Transform_Res14;
        goto Exit_Or7;
    end if;
    
--  BEGIN <Transform(<CompiledType BareErrorOnNull>) (root of 'basic_expr') at parser.lkt:319:11>

Transform_Diags15 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'basic_expr') at ???>

Row_Pos16 := Pos;



--  BEGIN <Defer (for 'basic_expr') at parser.lkt:319:23>

Defer_Res28 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos16);
Defer_Pos28 := Parser.Current_Pos;

--  END <Defer (for 'basic_expr') at parser.lkt:319:23>




if Defer_Pos28 /= No_Token_Index then

   Row_Pos16 := Defer_Pos28;

else
   Row_Pos16 := No_Token_Index;
   goto Exit_Row16_0;

end if;


--  BEGIN <Token(<WithText ExclMark>, ) (root of 'basic_expr') at parser.lkt:319:34>

Token_Res20 := Row_Pos16;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res20));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Excl_Mark)
   then
       Token_Pos20 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos16 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos16,
             Expected_Token_Id => Lkt_Excl_Mark,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos20 := Row_Pos16 + 1;
   end if;
end;

--  END <Token(<WithText ExclMark>, ) (root of 'basic_expr') at parser.lkt:319:34>




if Token_Pos20 /= No_Token_Index then

   Row_Pos16 := Token_Pos20;

else
   Row_Pos16 := No_Token_Index;
   goto Exit_Row16_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row16_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'basic_expr') at ???>



if Row_Pos16 /= No_Token_Index then

   Transform_Res15 := Allocate_Error_On_Null (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res15,
      Kind => Lkt_Error_On_Null,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos16 = Pos
                            then No_Token_Index
                            else Row_Pos16 - 1));

      
      Initialize_Fields_For_Error_On_Null
        (Self => Transform_Res15,
         Error_On_Null_F_Expr => Defer_Res28);

         if Defer_Res28 /= null and then Is_Incomplete (Defer_Res28) then
            Transform_Res15.Last_Attempted_Child := 0;
         elsif Defer_Res28 /= null and then not Is_Ghost (Defer_Res28) then
            Transform_Res15.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos16 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags15);
end if;

--  END <Transform(<CompiledType BareErrorOnNull>) (root of 'basic_expr') at parser.lkt:319:11>

    if Row_Pos16 /= No_Token_Index then
        Or_Pos7 := Row_Pos16;
        Or_Res7 := Transform_Res15;
        goto Exit_Or7;
    end if;
    
--  BEGIN <Transform(<CompiledType BareKeepExpr>) (root of 'basic_expr') at parser.lkt:320:11>

Transform_Diags16 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'basic_expr') at ???>

Row_Pos17 := Pos;



--  BEGIN <Defer (for 'basic_expr') at parser.lkt:320:20>

Defer_Res29 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos17);
Defer_Pos29 := Parser.Current_Pos;

--  END <Defer (for 'basic_expr') at parser.lkt:320:20>




if Defer_Pos29 /= No_Token_Index then

   Row_Pos17 := Defer_Pos29;

else
   Row_Pos17 := No_Token_Index;
   goto Exit_Row17_0;

end if;


--  BEGIN <Token(<WithText Dot>, ) (root of 'basic_expr') at parser.lkt:320:31>

Token_Res21 := Row_Pos17;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res21));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dot)
   then
       Token_Pos21 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos17 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos17,
             Expected_Token_Id => Lkt_Dot,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos21 := Row_Pos17 + 1;
   end if;
end;

--  END <Token(<WithText Dot>, ) (root of 'basic_expr') at parser.lkt:320:31>




if Token_Pos21 /= No_Token_Index then

   Row_Pos17 := Token_Pos21;

else
   Row_Pos17 := No_Token_Index;
   goto Exit_Row17_0;

end if;


--  BEGIN <Token(<WithSymbol Identifier>, keep) (root of 'basic_expr') at parser.lkt:320:35>

Token_Res22 := Row_Pos17;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res22));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Keep)
   then
       Token_Pos22 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos17 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos17,
             Expected_Token_Id => Lkt_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos22 := Row_Pos17 + 1;
   end if;
end;

--  END <Token(<WithSymbol Identifier>, keep) (root of 'basic_expr') at parser.lkt:320:35>




if Token_Pos22 /= No_Token_Index then

   Row_Pos17 := Token_Pos22;

else
   Row_Pos17 := No_Token_Index;
   goto Exit_Row17_0;

end if;


--  BEGIN <Token(<WithText LBrack>, ) (root of 'basic_expr') at parser.lkt:320:55>

Token_Res23 := Row_Pos17;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res23));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos23 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos17 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos17,
             Expected_Token_Id => Lkt_L_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos23 := Row_Pos17 + 1;
   end if;
end;

--  END <Token(<WithText LBrack>, ) (root of 'basic_expr') at parser.lkt:320:55>




if Token_Pos23 /= No_Token_Index then

   Row_Pos17 := Token_Pos23;

else
   Row_Pos17 := No_Token_Index;
   goto Exit_Row17_0;

end if;


--  BEGIN <Defer (for 'type_ref') at parser.lkt:320:59>

Defer_Res30 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos17);
Defer_Pos30 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:320:59>




if Defer_Pos30 /= No_Token_Index then

   Row_Pos17 := Defer_Pos30;

else
   Row_Pos17 := No_Token_Index;
   goto Exit_Row17_0;

end if;


--  BEGIN <Token(<WithText RBrack>, ) (root of 'basic_expr') at parser.lkt:320:68>

Token_Res24 := Row_Pos17;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res24));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos24 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos17 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos17,
             Expected_Token_Id => Lkt_R_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos24 := Row_Pos17 + 1;
   end if;
end;

--  END <Token(<WithText RBrack>, ) (root of 'basic_expr') at parser.lkt:320:68>




if Token_Pos24 /= No_Token_Index then

   Row_Pos17 := Token_Pos24;

else
   Row_Pos17 := No_Token_Index;
   goto Exit_Row17_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row17_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'basic_expr') at ???>



if Row_Pos17 /= No_Token_Index then

   Transform_Res16 := Allocate_Keep_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res16,
      Kind => Lkt_Keep_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos17 = Pos
                            then No_Token_Index
                            else Row_Pos17 - 1));

      
      Initialize_Fields_For_Keep_Expr
        (Self => Transform_Res16,
         Keep_Expr_F_Expr => Defer_Res29,
         Keep_Expr_F_Keep_Type => Defer_Res30);

         if Defer_Res29 /= null and then Is_Incomplete (Defer_Res29) then
            Transform_Res16.Last_Attempted_Child := 0;
         elsif Defer_Res29 /= null and then not Is_Ghost (Defer_Res29) then
            Transform_Res16.Last_Attempted_Child := -1;
         end if;
         if Defer_Res30 /= null and then Is_Incomplete (Defer_Res30) then
            Transform_Res16.Last_Attempted_Child := 0;
         elsif Defer_Res30 /= null and then not Is_Ghost (Defer_Res30) then
            Transform_Res16.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos17 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags16);
end if;

--  END <Transform(<CompiledType BareKeepExpr>) (root of 'basic_expr') at parser.lkt:320:11>

    if Row_Pos17 /= No_Token_Index then
        Or_Pos7 := Row_Pos17;
        Or_Res7 := Transform_Res16;
        goto Exit_Or7;
    end if;
    
--  BEGIN <Transform(<CompiledType BareCastExpr>) (root of 'basic_expr') at parser.lkt:321:11>

Transform_Diags17 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'basic_expr') at ???>

Row_Pos18 := Pos;



--  BEGIN <Defer (for 'basic_expr') at parser.lkt:322:13>

Defer_Res31 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos18);
Defer_Pos31 := Parser.Current_Pos;

--  END <Defer (for 'basic_expr') at parser.lkt:322:13>




if Defer_Pos31 /= No_Token_Index then

   Row_Pos18 := Defer_Pos31;

else
   Row_Pos18 := No_Token_Index;
   goto Exit_Row18_0;

end if;


--  BEGIN <Token(<WithText Dot>, ) (root of 'basic_expr') at parser.lkt:322:24>

Token_Res25 := Row_Pos18;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res25));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dot)
   then
       Token_Pos25 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos18 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos18,
             Expected_Token_Id => Lkt_Dot,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos25 := Row_Pos18 + 1;
   end if;
end;

--  END <Token(<WithText Dot>, ) (root of 'basic_expr') at parser.lkt:322:24>




if Token_Pos25 /= No_Token_Index then

   Row_Pos18 := Token_Pos25;

else
   Row_Pos18 := No_Token_Index;
   goto Exit_Row18_0;

end if;


--  BEGIN <Token(<WithSymbol Identifier>, as) (root of 'basic_expr') at parser.lkt:322:28>

Token_Res26 := Row_Pos18;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res26));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_As)
   then
       Token_Pos26 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos18 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos18,
             Expected_Token_Id => Lkt_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos26 := Row_Pos18 + 1;
   end if;
end;

--  END <Token(<WithSymbol Identifier>, as) (root of 'basic_expr') at parser.lkt:322:28>




if Token_Pos26 /= No_Token_Index then

   Row_Pos18 := Token_Pos26;

else
   Row_Pos18 := No_Token_Index;
   goto Exit_Row18_0;

end if;


--  BEGIN <Opt (root of 'basic_expr') at parser.lkt:322:46>












--  BEGIN <Token(<WithText ExclMark>, ) (root of 'basic_expr') at parser.lkt:322:59>

Token_Res27 := Row_Pos18;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res27));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Excl_Mark)
   then
       Token_Pos27 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos18 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos18,
             Expected_Token_Id => Lkt_Excl_Mark,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos27 := Row_Pos18 + 1;
   end if;
end;

--  END <Token(<WithText ExclMark>, ) (root of 'basic_expr') at parser.lkt:322:59>


if Token_Pos27 = No_Token_Index then

         Opt_Res0 := Allocate_Excludes_Null_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res0,
            Kind              => Lkt_Excludes_Null_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos18,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos27 := Row_Pos18;


else

      Opt_Res0 := Allocate_Excludes_Null_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res0,
         Kind              => Lkt_Excludes_Null_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos18,
         Token_End_Index   => Token_Pos27 - 1);

end if;

--  END <Opt (root of 'basic_expr') at parser.lkt:322:46>




if Token_Pos27 /= No_Token_Index then

   Row_Pos18 := Token_Pos27;

else
   Row_Pos18 := No_Token_Index;
   goto Exit_Row18_0;

end if;


--  BEGIN <Token(<WithText LBrack>, ) (root of 'basic_expr') at parser.lkt:322:64>

Token_Res28 := Row_Pos18;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res28));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos28 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos18 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos18,
             Expected_Token_Id => Lkt_L_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos28 := Row_Pos18 + 1;
   end if;
end;

--  END <Token(<WithText LBrack>, ) (root of 'basic_expr') at parser.lkt:322:64>




if Token_Pos28 /= No_Token_Index then

   Row_Pos18 := Token_Pos28;

else
   Row_Pos18 := No_Token_Index;
   goto Exit_Row18_0;

end if;


--  BEGIN <Defer (for 'type_ref') at parser.lkt:322:68>

Defer_Res32 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos18);
Defer_Pos32 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:322:68>




if Defer_Pos32 /= No_Token_Index then

   Row_Pos18 := Defer_Pos32;

else
   Row_Pos18 := No_Token_Index;
   goto Exit_Row18_0;

end if;


--  BEGIN <Token(<WithText RBrack>, ) (root of 'basic_expr') at parser.lkt:322:77>

Token_Res29 := Row_Pos18;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res29));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos29 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos18 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos18,
             Expected_Token_Id => Lkt_R_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos29 := Row_Pos18 + 1;
   end if;
end;

--  END <Token(<WithText RBrack>, ) (root of 'basic_expr') at parser.lkt:322:77>




if Token_Pos29 /= No_Token_Index then

   Row_Pos18 := Token_Pos29;

else
   Row_Pos18 := No_Token_Index;
   goto Exit_Row18_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row18_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'basic_expr') at ???>



if Row_Pos18 /= No_Token_Index then

   Transform_Res17 := Allocate_Cast_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res17,
      Kind => Lkt_Cast_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos18 = Pos
                            then No_Token_Index
                            else Row_Pos18 - 1));

      
      Initialize_Fields_For_Cast_Expr
        (Self => Transform_Res17,
         Cast_Expr_F_Expr => Defer_Res31,
         Cast_Expr_F_Excludes_Null => Opt_Res0,
         Cast_Expr_F_Dest_Type => Defer_Res32);

         if Defer_Res31 /= null and then Is_Incomplete (Defer_Res31) then
            Transform_Res17.Last_Attempted_Child := 0;
         elsif Defer_Res31 /= null and then not Is_Ghost (Defer_Res31) then
            Transform_Res17.Last_Attempted_Child := -1;
         end if;
         if Opt_Res0 /= null and then Is_Incomplete (Opt_Res0) then
            Transform_Res17.Last_Attempted_Child := 0;
         elsif Opt_Res0 /= null and then not Is_Ghost (Opt_Res0) then
            Transform_Res17.Last_Attempted_Child := -1;
         end if;
         if Defer_Res32 /= null and then Is_Incomplete (Defer_Res32) then
            Transform_Res17.Last_Attempted_Child := 0;
         elsif Defer_Res32 /= null and then not Is_Ghost (Defer_Res32) then
            Transform_Res17.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos18 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags17);
end if;

--  END <Transform(<CompiledType BareCastExpr>) (root of 'basic_expr') at parser.lkt:321:11>

    if Row_Pos18 /= No_Token_Index then
        Or_Pos7 := Row_Pos18;
        Or_Res7 := Transform_Res17;
        goto Exit_Or7;
    end if;
    
--  BEGIN <Transform(<CompiledType BareLogicPredicate>) (root of 'basic_expr') at parser.lkt:324:11>

Transform_Diags18 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'basic_expr') at ???>

Row_Pos19 := Pos;



--  BEGIN <Defer (for 'basic_expr') at parser.lkt:324:26>

Defer_Res33 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos19);
Defer_Pos33 := Parser.Current_Pos;

--  END <Defer (for 'basic_expr') at parser.lkt:324:26>




if Defer_Pos33 /= No_Token_Index then

   Row_Pos19 := Defer_Pos33;

else
   Row_Pos19 := No_Token_Index;
   goto Exit_Row19_0;

end if;


--  BEGIN <Token(<WithText Percent>, ) (root of 'basic_expr') at parser.lkt:324:37>

Token_Res30 := Row_Pos19;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res30));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Percent)
   then
       Token_Pos30 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos19 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos19,
             Expected_Token_Id => Lkt_Percent,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos30 := Row_Pos19 + 1;
   end if;
end;

--  END <Token(<WithText Percent>, ) (root of 'basic_expr') at parser.lkt:324:37>




if Token_Pos30 /= No_Token_Index then

   Row_Pos19 := Token_Pos30;

else
   Row_Pos19 := No_Token_Index;
   goto Exit_Row19_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'basic_expr') at parser.lkt:324:41>

Token_Res31 := Row_Pos19;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res31));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos31 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos19 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos19,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos31 := Row_Pos19 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'basic_expr') at parser.lkt:324:41>




if Token_Pos31 /= No_Token_Index then

   Row_Pos19 := Token_Pos31;

else
   Row_Pos19 := No_Token_Index;
   goto Exit_Row19_0;

end if;


--  BEGIN <Defer (for 'params') at parser.lkt:324:45>

Defer_Res34 :=
   Params_List_Parse0 (Parser, Row_Pos19);
Defer_Pos34 := Parser.Current_Pos;

--  END <Defer (for 'params') at parser.lkt:324:45>




if Defer_Pos34 /= No_Token_Index then

   Row_Pos19 := Defer_Pos34;

else
   Row_Pos19 := No_Token_Index;
   goto Exit_Row19_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'basic_expr') at parser.lkt:324:52>

Token_Res32 := Row_Pos19;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res32));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos32 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos19 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos19,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos32 := Row_Pos19 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'basic_expr') at parser.lkt:324:52>




if Token_Pos32 /= No_Token_Index then

   Row_Pos19 := Token_Pos32;

else
   Row_Pos19 := No_Token_Index;
   goto Exit_Row19_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row19_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'basic_expr') at ???>



if Row_Pos19 /= No_Token_Index then

   Transform_Res18 := Allocate_Logic_Predicate (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res18,
      Kind => Lkt_Logic_Predicate,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos19 = Pos
                            then No_Token_Index
                            else Row_Pos19 - 1));

      
      Initialize_Fields_For_Logic_Predicate
        (Self => Transform_Res18,
         Base_Call_Expr_F_Name => Defer_Res33,
         Base_Call_Expr_F_Args => Defer_Res34);

         if Defer_Res33 /= null and then Is_Incomplete (Defer_Res33) then
            Transform_Res18.Last_Attempted_Child := 0;
         elsif Defer_Res33 /= null and then not Is_Ghost (Defer_Res33) then
            Transform_Res18.Last_Attempted_Child := -1;
         end if;
         if Defer_Res34 /= null and then Is_Incomplete (Defer_Res34) then
            Transform_Res18.Last_Attempted_Child := 0;
         elsif Defer_Res34 /= null and then not Is_Ghost (Defer_Res34) then
            Transform_Res18.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos19 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags18);
end if;

--  END <Transform(<CompiledType BareLogicPredicate>) (root of 'basic_expr') at parser.lkt:324:11>

    if Row_Pos19 /= No_Token_Index then
        Or_Pos7 := Row_Pos19;
        Or_Res7 := Transform_Res18;
        goto Exit_Or7;
    end if;
    
--  BEGIN <Transform(<CompiledType BareDotExpr>) (root of 'basic_expr') at parser.lkt:325:11>

Transform_Diags19 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'basic_expr') at ???>

Row_Pos20 := Pos;



--  BEGIN <Defer (for 'basic_expr') at parser.lkt:325:19>

Defer_Res35 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos20);
Defer_Pos35 := Parser.Current_Pos;

--  END <Defer (for 'basic_expr') at parser.lkt:325:19>



Row_Progress0 := 1;

if Defer_Pos35 /= No_Token_Index then

   Row_Pos20 := Defer_Pos35;

else
   Row_Pos20 := No_Token_Index;
   goto Exit_Row20_0;

end if;


--  BEGIN <Token(<WithText Dot>, ) (root of 'basic_expr') at parser.lkt:325:30>

Token_Res33 := Row_Pos20;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res33));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dot)
   then
       Token_Pos33 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos20 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos20,
             Expected_Token_Id => Lkt_Dot,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos33 := Row_Pos20 + 1;
   end if;
end;

--  END <Token(<WithText Dot>, ) (root of 'basic_expr') at parser.lkt:325:30>



Row_Progress0 := 2;

if Token_Pos33 /= No_Token_Index then

   Row_Pos20 := Token_Pos33;

else
   Row_Pos20 := No_Token_Index;
   goto Exit_Row20_0;

end if;


--  BEGIN <Cut (root of 'basic_expr') at ???>
Nobt0 := True;
--  END <Cut (root of 'basic_expr') at ???>


   Nobt0 := Nobt0;

Row_Progress0 := 3;

if Row_Pos20 /= No_Token_Index then

   Row_Pos20 := Row_Pos20;

else
   Row_Pos20 := No_Token_Index;
   goto Exit_Row20_0;

end if;


--  BEGIN <Defer (for 'ref_id') at parser.lkt:325:36>

Defer_Res36 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos20);
Defer_Pos36 := Parser.Current_Pos;

--  END <Defer (for 'ref_id') at parser.lkt:325:36>



Row_Progress0 := 4;

if Defer_Pos36 /= No_Token_Index then

   Row_Pos20 := Defer_Pos36;

else
   Row_Pos20 := No_Token_Index;
   goto Exit_Row20_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row20_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'basic_expr') at ???>


if Row_Pos20 = No_Token_Index and then Nobt0 then

   Row_Pos20 := Parser.Last_Fail.Pos;

   Transform_Has_Failed0 := True;
end if;

if Row_Pos20 /= No_Token_Index then

   Transform_Res19 := Allocate_Dot_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res19,
      Kind => Lkt_Dot_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos20 = Pos
                            then No_Token_Index
                            else Row_Pos20 - 1));

      
      Initialize_Fields_For_Dot_Expr
        (Self => Transform_Res19,
         Base_Dot_Expr_F_Prefix => Defer_Res35,
         Base_Dot_Expr_F_Suffix => Defer_Res36);

         if Defer_Res35 /= null and then Is_Incomplete (Defer_Res35) then
            Transform_Res19.Last_Attempted_Child := 0;
         elsif Defer_Res35 /= null and then not Is_Ghost (Defer_Res35) then
            Transform_Res19.Last_Attempted_Child := -1;
         end if;
         if Defer_Res36 /= null and then Is_Incomplete (Defer_Res36) then
            Transform_Res19.Last_Attempted_Child := 0;
         elsif Defer_Res36 /= null and then not Is_Ghost (Defer_Res36) then
            Transform_Res19.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed0 then
      Transform_Res19.Last_Attempted_Child :=
         Row_Progress0;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <basic_expr>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos20 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags19);
end if;

--  END <Transform(<CompiledType BareDotExpr>) (root of 'basic_expr') at parser.lkt:325:11>

    if Row_Pos20 /= No_Token_Index then
        Or_Pos7 := Row_Pos20;
        Or_Res7 := Transform_Res19;
        goto Exit_Or7;
    end if;
    
--  BEGIN <Transform(<CompiledType BareNullCondDottedName>) (root of 'basic_expr') at parser.lkt:326:11>

Transform_Diags20 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'basic_expr') at ???>

Row_Pos21 := Pos;



--  BEGIN <Defer (for 'basic_expr') at parser.lkt:326:30>

Defer_Res37 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos21);
Defer_Pos37 := Parser.Current_Pos;

--  END <Defer (for 'basic_expr') at parser.lkt:326:30>




if Defer_Pos37 /= No_Token_Index then

   Row_Pos21 := Defer_Pos37;

else
   Row_Pos21 := No_Token_Index;
   goto Exit_Row21_0;

end if;


--  BEGIN <Token(<WithText IntMark>, ) (root of 'basic_expr') at parser.lkt:326:41>

Token_Res34 := Row_Pos21;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res34));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Int_Mark)
   then
       Token_Pos34 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos21 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos21,
             Expected_Token_Id => Lkt_Int_Mark,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos34 := Row_Pos21 + 1;
   end if;
end;

--  END <Token(<WithText IntMark>, ) (root of 'basic_expr') at parser.lkt:326:41>




if Token_Pos34 /= No_Token_Index then

   Row_Pos21 := Token_Pos34;

else
   Row_Pos21 := No_Token_Index;
   goto Exit_Row21_0;

end if;


--  BEGIN <Token(<WithText Dot>, ) (root of 'basic_expr') at parser.lkt:326:45>

Token_Res35 := Row_Pos21;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res35));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dot)
   then
       Token_Pos35 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos21 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos21,
             Expected_Token_Id => Lkt_Dot,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos35 := Row_Pos21 + 1;
   end if;
end;

--  END <Token(<WithText Dot>, ) (root of 'basic_expr') at parser.lkt:326:45>




if Token_Pos35 /= No_Token_Index then

   Row_Pos21 := Token_Pos35;

else
   Row_Pos21 := No_Token_Index;
   goto Exit_Row21_0;

end if;


--  BEGIN <Defer (for 'ref_id') at parser.lkt:326:49>

Defer_Res38 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos21);
Defer_Pos38 := Parser.Current_Pos;

--  END <Defer (for 'ref_id') at parser.lkt:326:49>




if Defer_Pos38 /= No_Token_Index then

   Row_Pos21 := Defer_Pos38;

else
   Row_Pos21 := No_Token_Index;
   goto Exit_Row21_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row21_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'basic_expr') at ???>



if Row_Pos21 /= No_Token_Index then

   Transform_Res20 := Allocate_Null_Cond_Dotted_Name (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res20,
      Kind => Lkt_Null_Cond_Dotted_Name,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos21 = Pos
                            then No_Token_Index
                            else Row_Pos21 - 1));

      
      Initialize_Fields_For_Null_Cond_Dotted_Name
        (Self => Transform_Res20,
         Base_Dot_Expr_F_Prefix => Defer_Res37,
         Base_Dot_Expr_F_Suffix => Defer_Res38);

         if Defer_Res37 /= null and then Is_Incomplete (Defer_Res37) then
            Transform_Res20.Last_Attempted_Child := 0;
         elsif Defer_Res37 /= null and then not Is_Ghost (Defer_Res37) then
            Transform_Res20.Last_Attempted_Child := -1;
         end if;
         if Defer_Res38 /= null and then Is_Incomplete (Defer_Res38) then
            Transform_Res20.Last_Attempted_Child := 0;
         elsif Defer_Res38 /= null and then not Is_Ghost (Defer_Res38) then
            Transform_Res20.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos21 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags20);
end if;

--  END <Transform(<CompiledType BareNullCondDottedName>) (root of 'basic_expr') at parser.lkt:326:11>

    if Row_Pos21 /= No_Token_Index then
        Or_Pos7 := Row_Pos21;
        Or_Res7 := Transform_Res20;
        goto Exit_Or7;
    end if;
    
--  BEGIN <Transform(<CompiledType BareLogicExpr>) (root of 'basic_expr') at parser.lkt:327:11>

Transform_Diags22 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'basic_expr') at ???>

Row_Pos22 := Pos;



--  BEGIN <Token(<WithText Percent>, ) (root of 'basic_expr') at parser.lkt:327:21>

Token_Res36 := Row_Pos22;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res36));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Percent)
   then
       Token_Pos36 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos22 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos22,
             Expected_Token_Id => Lkt_Percent,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos36 := Row_Pos22 + 1;
   end if;
end;

--  END <Token(<WithText Percent>, ) (root of 'basic_expr') at parser.lkt:327:21>




if Token_Pos36 /= No_Token_Index then

   Row_Pos22 := Token_Pos36;

else
   Row_Pos22 := No_Token_Index;
   goto Exit_Row22_0;

end if;


--  BEGIN <Transform(<CompiledType BareCallExpr>) (root of 'basic_expr') at parser.lkt:327:25>

Transform_Diags21 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'basic_expr') at ???>

Row_Pos23 := Row_Pos22;



--  BEGIN <Defer (for 'ref_id') at parser.lkt:327:34>

Defer_Res39 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos23);
Defer_Pos39 := Parser.Current_Pos;

--  END <Defer (for 'ref_id') at parser.lkt:327:34>




if Defer_Pos39 /= No_Token_Index then

   Row_Pos23 := Defer_Pos39;

else
   Row_Pos23 := No_Token_Index;
   goto Exit_Row23_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'basic_expr') at parser.lkt:327:41>

Token_Res37 := Row_Pos23;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res37));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos37 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos23 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos23,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos37 := Row_Pos23 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'basic_expr') at parser.lkt:327:41>




if Token_Pos37 /= No_Token_Index then

   Row_Pos23 := Token_Pos37;

else
   Row_Pos23 := No_Token_Index;
   goto Exit_Row23_0;

end if;


--  BEGIN <Defer (for 'params') at parser.lkt:327:45>

Defer_Res40 :=
   Params_List_Parse0 (Parser, Row_Pos23);
Defer_Pos40 := Parser.Current_Pos;

--  END <Defer (for 'params') at parser.lkt:327:45>




if Defer_Pos40 /= No_Token_Index then

   Row_Pos23 := Defer_Pos40;

else
   Row_Pos23 := No_Token_Index;
   goto Exit_Row23_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'basic_expr') at parser.lkt:327:52>

Token_Res38 := Row_Pos23;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res38));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos38 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos23 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos23,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos38 := Row_Pos23 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'basic_expr') at parser.lkt:327:52>




if Token_Pos38 /= No_Token_Index then

   Row_Pos23 := Token_Pos38;

else
   Row_Pos23 := No_Token_Index;
   goto Exit_Row23_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row23_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'basic_expr') at ???>



if Row_Pos23 /= No_Token_Index then

   Transform_Res21 := Allocate_Call_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res21,
      Kind => Lkt_Call_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos22,
      Token_End_Index   => (if Row_Pos23 = Row_Pos22
                            then No_Token_Index
                            else Row_Pos23 - 1));

      
      Initialize_Fields_For_Call_Expr
        (Self => Transform_Res21,
         Base_Call_Expr_F_Name => Defer_Res39,
         Base_Call_Expr_F_Args => Defer_Res40);

         if Defer_Res39 /= null and then Is_Incomplete (Defer_Res39) then
            Transform_Res21.Last_Attempted_Child := 0;
         elsif Defer_Res39 /= null and then not Is_Ghost (Defer_Res39) then
            Transform_Res21.Last_Attempted_Child := -1;
         end if;
         if Defer_Res40 /= null and then Is_Incomplete (Defer_Res40) then
            Transform_Res21.Last_Attempted_Child := 0;
         elsif Defer_Res40 /= null and then not Is_Ghost (Defer_Res40) then
            Transform_Res21.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos23 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags21);
end if;

--  END <Transform(<CompiledType BareCallExpr>) (root of 'basic_expr') at parser.lkt:327:25>




if Row_Pos23 /= No_Token_Index then

   Row_Pos22 := Row_Pos23;

else
   Row_Pos22 := No_Token_Index;
   goto Exit_Row22_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row22_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'basic_expr') at ???>



if Row_Pos22 /= No_Token_Index then

   Transform_Res22 := Allocate_Logic_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res22,
      Kind => Lkt_Logic_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos22 = Pos
                            then No_Token_Index
                            else Row_Pos22 - 1));

      
      Initialize_Fields_For_Logic_Expr
        (Self => Transform_Res22,
         Logic_Expr_F_Expr => Transform_Res21);

         if Transform_Res21 /= null and then Is_Incomplete (Transform_Res21) then
            Transform_Res22.Last_Attempted_Child := 0;
         elsif Transform_Res21 /= null and then not Is_Ghost (Transform_Res21) then
            Transform_Res22.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos22 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags22);
end if;

--  END <Transform(<CompiledType BareLogicExpr>) (root of 'basic_expr') at parser.lkt:327:11>

    if Row_Pos22 /= No_Token_Index then
        Or_Pos7 := Row_Pos22;
        Or_Res7 := Transform_Res22;
        goto Exit_Or7;
    end if;
    
--  BEGIN <Transform(<CompiledType BareLogicExpr>) (root of 'basic_expr') at parser.lkt:328:11>

Transform_Diags23 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'basic_expr') at ???>

Row_Pos24 := Pos;



--  BEGIN <Token(<WithText Percent>, ) (root of 'basic_expr') at parser.lkt:328:21>

Token_Res39 := Row_Pos24;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res39));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Percent)
   then
       Token_Pos39 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos24 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos24,
             Expected_Token_Id => Lkt_Percent,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos39 := Row_Pos24 + 1;
   end if;
end;

--  END <Token(<WithText Percent>, ) (root of 'basic_expr') at parser.lkt:328:21>




if Token_Pos39 /= No_Token_Index then

   Row_Pos24 := Token_Pos39;

else
   Row_Pos24 := No_Token_Index;
   goto Exit_Row24_0;

end if;


--  BEGIN <Defer (for 'ref_id') at parser.lkt:328:25>

Defer_Res41 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos24);
Defer_Pos41 := Parser.Current_Pos;

--  END <Defer (for 'ref_id') at parser.lkt:328:25>




if Defer_Pos41 /= No_Token_Index then

   Row_Pos24 := Defer_Pos41;

else
   Row_Pos24 := No_Token_Index;
   goto Exit_Row24_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row24_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'basic_expr') at ???>



if Row_Pos24 /= No_Token_Index then

   Transform_Res23 := Allocate_Logic_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res23,
      Kind => Lkt_Logic_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos24 = Pos
                            then No_Token_Index
                            else Row_Pos24 - 1));

      
      Initialize_Fields_For_Logic_Expr
        (Self => Transform_Res23,
         Logic_Expr_F_Expr => Defer_Res41);

         if Defer_Res41 /= null and then Is_Incomplete (Defer_Res41) then
            Transform_Res23.Last_Attempted_Child := 0;
         elsif Defer_Res41 /= null and then not Is_Ghost (Defer_Res41) then
            Transform_Res23.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos24 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags23);
end if;

--  END <Transform(<CompiledType BareLogicExpr>) (root of 'basic_expr') at parser.lkt:328:11>

    if Row_Pos24 /= No_Token_Index then
        Or_Pos7 := Row_Pos24;
        Or_Res7 := Transform_Res23;
        goto Exit_Or7;
    end if;
    
--  BEGIN <Defer (for 'term') at parser.lkt:329:11>

Defer_Res42 :=
   Term_Or_Parse0 (Parser, Pos);
Defer_Pos42 := Parser.Current_Pos;

--  END <Defer (for 'term') at parser.lkt:329:11>

    if Defer_Pos42 /= No_Token_Index then
        Or_Pos7 := Defer_Pos42;
        Or_Res7 := Defer_Res42;
        goto Exit_Or7;
    end if;
<<Exit_Or7>>

--  END <Or (root of 'basic_expr') at parser.lkt:314:19>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos7 > Mem_Pos then
         Mem_Pos := Or_Pos7;
         Mem_Res := Or_Res7;
         Set
           (PP.Basic_Expr_Or_Parse0_Memo,
            Or_Pos7 /= No_Token_Index,
            Or_Res7,
            Pos,
            Or_Pos7);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res7 := Mem_Res;
         Or_Pos7 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (PP.Basic_Expr_Or_Parse0_Memo,
      Or_Pos7 /= No_Token_Index,
      Or_Res7,
      Pos,
      Or_Pos7);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos7;

   return Or_Res7;
end Basic_Expr_Or_Parse0;

   


function Basic_Name_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

      Nobt1 :
            Boolean
               := False;
      Row_Pos25 :
            Token_Index
               := No_Token_Index;
      Defer_Pos43 :
            Token_Index
               := No_Token_Index;
      Defer_Res43 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos40 :
            Token_Index
               := No_Token_Index;
      Token_Res40 :
            Token_Index
               := No_Token_Index;
      Defer_Pos44 :
            Token_Index
               := No_Token_Index;
      Defer_Res44 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Row_Progress1 :
            Integer
               := 0;
      Transform_Res24 :
            Bare_Dot_Expr
               := No_Bare_Lkt_Node;
      Transform_Has_Failed1 :
            Boolean
               := False;
      Transform_Diags24 :
            Ada.Containers.Count_Type;
      Defer_Pos45 :
            Token_Index
               := No_Token_Index;
      Defer_Res45 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Or_Pos8 :
            Token_Index
               := No_Token_Index;
      Or_Res8 :
            Bare_Expr
               := No_Bare_Lkt_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Expr := No_Bare_Lkt_Node;

   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Basic_Name_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res8 := M.Instance;
      return Or_Res8;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res8;
   end if;

       Set (PP.Basic_Name_Or_Parse0_Memo, False, Or_Res8, Pos, Mem_Pos);

       <<Try_Again>>

      Nobt1 := False;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'basic_name') at parser.lkt:343:19>

Or_Pos8 := No_Token_Index;
Or_Res8 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareDotExpr>) (root of 'basic_name') at parser.lkt:343:22>

Transform_Diags24 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'basic_name') at ???>

Row_Pos25 := Pos;



--  BEGIN <Defer (for 'basic_name') at parser.lkt:343:30>

Defer_Res43 :=
   Basic_Name_Or_Parse0 (Parser, Row_Pos25);
Defer_Pos43 := Parser.Current_Pos;

--  END <Defer (for 'basic_name') at parser.lkt:343:30>



Row_Progress1 := 1;

if Defer_Pos43 /= No_Token_Index then

   Row_Pos25 := Defer_Pos43;

else
   Row_Pos25 := No_Token_Index;
   goto Exit_Row25_0;

end if;


--  BEGIN <Token(<WithText Dot>, ) (root of 'basic_name') at parser.lkt:343:41>

Token_Res40 := Row_Pos25;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res40));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dot)
   then
       Token_Pos40 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos25 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos25,
             Expected_Token_Id => Lkt_Dot,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos40 := Row_Pos25 + 1;
   end if;
end;

--  END <Token(<WithText Dot>, ) (root of 'basic_name') at parser.lkt:343:41>



Row_Progress1 := 2;

if Token_Pos40 /= No_Token_Index then

   Row_Pos25 := Token_Pos40;

else
   Row_Pos25 := No_Token_Index;
   goto Exit_Row25_0;

end if;


--  BEGIN <Cut (root of 'basic_name') at ???>
Nobt1 := True;
--  END <Cut (root of 'basic_name') at ???>


   Nobt1 := Nobt1;

Row_Progress1 := 3;

if Row_Pos25 /= No_Token_Index then

   Row_Pos25 := Row_Pos25;

else
   Row_Pos25 := No_Token_Index;
   goto Exit_Row25_0;

end if;


--  BEGIN <Defer (for 'ref_id') at parser.lkt:343:47>

Defer_Res44 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos25);
Defer_Pos44 := Parser.Current_Pos;

--  END <Defer (for 'ref_id') at parser.lkt:343:47>



Row_Progress1 := 4;

if Defer_Pos44 /= No_Token_Index then

   Row_Pos25 := Defer_Pos44;

else
   Row_Pos25 := No_Token_Index;
   goto Exit_Row25_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row25_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'basic_name') at ???>


if Row_Pos25 = No_Token_Index and then Nobt1 then

   Row_Pos25 := Parser.Last_Fail.Pos;

   Transform_Has_Failed1 := True;
end if;

if Row_Pos25 /= No_Token_Index then

   Transform_Res24 := Allocate_Dot_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res24,
      Kind => Lkt_Dot_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos25 = Pos
                            then No_Token_Index
                            else Row_Pos25 - 1));

      
      Initialize_Fields_For_Dot_Expr
        (Self => Transform_Res24,
         Base_Dot_Expr_F_Prefix => Defer_Res43,
         Base_Dot_Expr_F_Suffix => Defer_Res44);

         if Defer_Res43 /= null and then Is_Incomplete (Defer_Res43) then
            Transform_Res24.Last_Attempted_Child := 0;
         elsif Defer_Res43 /= null and then not Is_Ghost (Defer_Res43) then
            Transform_Res24.Last_Attempted_Child := -1;
         end if;
         if Defer_Res44 /= null and then Is_Incomplete (Defer_Res44) then
            Transform_Res24.Last_Attempted_Child := 0;
         elsif Defer_Res44 /= null and then not Is_Ghost (Defer_Res44) then
            Transform_Res24.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed1 then
      Transform_Res24.Last_Attempted_Child :=
         Row_Progress1;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <basic_name>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos25 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags24);
end if;

--  END <Transform(<CompiledType BareDotExpr>) (root of 'basic_name') at parser.lkt:343:22>

    if Row_Pos25 /= No_Token_Index then
        Or_Pos8 := Row_Pos25;
        Or_Res8 := Transform_Res24;
        goto Exit_Or8;
    end if;
    
--  BEGIN <Defer (for 'ref_id') at parser.lkt:343:57>

Defer_Res45 :=
   Ref_Id_Transform_Parse0 (Parser, Pos);
Defer_Pos45 := Parser.Current_Pos;

--  END <Defer (for 'ref_id') at parser.lkt:343:57>

    if Defer_Pos45 /= No_Token_Index then
        Or_Pos8 := Defer_Pos45;
        Or_Res8 := Defer_Res45;
        goto Exit_Or8;
    end if;
<<Exit_Or8>>

--  END <Or (root of 'basic_name') at parser.lkt:343:19>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos8 > Mem_Pos then
         Mem_Pos := Or_Pos8;
         Mem_Res := Or_Res8;
         Set
           (PP.Basic_Name_Or_Parse0_Memo,
            Or_Pos8 /= No_Token_Index,
            Or_Res8,
            Pos,
            Or_Pos8);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res8 := Mem_Res;
         Or_Pos8 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (PP.Basic_Name_Or_Parse0_Memo,
      Or_Pos8 /= No_Token_Index,
      Or_Res8,
      Pos,
      Or_Pos8);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos8;

   return Or_Res8;
end Basic_Name_Or_Parse0;

   


function Big_Num_Lit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Big_Num_Lit
is
   use Bare_Big_Num_Lit_Memos;

      Row_Pos26 :
            Token_Index
               := No_Token_Index;
      Token_Pos41 :
            Token_Index
               := No_Token_Index;
      Token_Res41 :
            Token_Index
               := No_Token_Index;
      Transform_Res25 :
            Bare_Big_Num_Lit
               := No_Bare_Lkt_Node;
      Transform_Diags25 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Big_Num_Lit_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res25 := M.Instance;
      return Transform_Res25;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res25;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareBigNumLit>) (root of 'big_num_lit') at parser.lkt:291:20>

Transform_Diags25 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'big_num_lit') at ???>

Row_Pos26 := Pos;



--  BEGIN <Token(<WithText BigNumber>, ) (root of 'big_num_lit') at parser.lkt:291:30>

Token_Res41 := Row_Pos26;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res41));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Big_Number)
   then
       Token_Pos41 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos26 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos26,
             Expected_Token_Id => Lkt_Big_Number,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos41 := Row_Pos26 + 1;
   end if;
end;

--  END <Token(<WithText BigNumber>, ) (root of 'big_num_lit') at parser.lkt:291:30>




if Token_Pos41 /= No_Token_Index then

   Row_Pos26 := Token_Pos41;

else
   Row_Pos26 := No_Token_Index;
   goto Exit_Row26_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row26_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'big_num_lit') at ???>



if Row_Pos26 /= No_Token_Index then

   Transform_Res25 := Allocate_Big_Num_Lit (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res25,
      Kind => Lkt_Big_Num_Lit,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos26 = Pos
                            then No_Token_Index
                            else Row_Pos26 - 1));

      
      Initialize_Fields_For_Big_Num_Lit
        (Self => Transform_Res25);



elsif Row_Pos26 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags25);
end if;

--  END <Transform(<CompiledType BareBigNumLit>) (root of 'big_num_lit') at parser.lkt:291:20>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Big_Num_Lit_Transform_Parse0_Memo,
      Row_Pos26 /= No_Token_Index,
      Transform_Res25,
      Pos,
      Row_Pos26);


   Parser.Current_Pos := Row_Pos26;

   return Transform_Res25;
end Big_Num_Lit_Transform_Parse0;

   


function Block_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Block_Expr
is
   use Bare_Block_Expr_Memos;

      Row_Pos27 :
            Token_Index
               := No_Token_Index;
      Token_Pos42 :
            Token_Index
               := No_Token_Index;
      Token_Res42 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos1 :
            Token_Index
               := No_Token_Index;
      Tmp_List1 :
            Free_Parse_List;
      Defer_Pos46 :
            Token_Index
               := No_Token_Index;
      Defer_Res46 :
            Bare_Val_Decl
               := No_Bare_Lkt_Node;
      Defer_Pos47 :
            Token_Index
               := No_Token_Index;
      Defer_Res47 :
            Bare_Var_Bind
               := No_Bare_Lkt_Node;
      Or_Pos9 :
            Token_Index
               := No_Token_Index;
      Or_Res9 :
            Bare_Lkt_Node
               := No_Bare_Lkt_Node;
      Token_Pos43 :
            Token_Index
               := No_Token_Index;
      Token_Res43 :
            Token_Index
               := No_Token_Index;
      List_Pos1 :
            Token_Index
               := No_Token_Index;
      List_Res1 :
            Bare_Block_Decl_List
               := No_Bare_Lkt_Node;
      Token_Pos44 :
            Token_Index
               := No_Token_Index;
      Token_Res44 :
            Token_Index
               := No_Token_Index;
      Defer_Pos48 :
            Token_Index
               := No_Token_Index;
      Defer_Res48 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos45 :
            Token_Index
               := No_Token_Index;
      Token_Res45 :
            Token_Index
               := No_Token_Index;
      Transform_Res26 :
            Bare_Block_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags26 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Block_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res26 := M.Instance;
      return Transform_Res26;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res26;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareBlockExpr>) (root of 'block') at parser.lkt:223:14>

Transform_Diags26 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'block') at ???>

Row_Pos27 := Pos;



--  BEGIN <Token(<WithText LBrace>, ) (root of 'block') at parser.lkt:225:9>

Token_Res42 := Row_Pos27;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res42));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos42 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos27 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos27,
             Expected_Token_Id => Lkt_L_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos42 := Row_Pos27 + 1;
   end if;
end;

--  END <Token(<WithText LBrace>, ) (root of 'block') at parser.lkt:225:9>




if Token_Pos42 /= No_Token_Index then

   Row_Pos27 := Token_Pos42;

else
   Row_Pos27 := No_Token_Index;
   goto Exit_Row27_0;

end if;


--  BEGIN <List (root of 'block') at parser.lkt:225:13>

    List_Pos1 := No_Token_Index;



Lst_Cpos1 := Row_Pos27;
Tmp_List1 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Or (root of 'block') at parser.lkt:225:28>

Or_Pos9 := No_Token_Index;
Or_Res9 := No_Bare_Lkt_Node;
    
--  BEGIN <Defer (for 'val_decl') at parser.lkt:225:31>

Defer_Res46 :=
   Val_Decl_Transform_Parse0 (Parser, Lst_Cpos1);
Defer_Pos46 := Parser.Current_Pos;

--  END <Defer (for 'val_decl') at parser.lkt:225:31>

    if Defer_Pos46 /= No_Token_Index then
        Or_Pos9 := Defer_Pos46;
        Or_Res9 := Defer_Res46;
        goto Exit_Or9;
    end if;
    
--  BEGIN <Defer (for 'var_bind') at parser.lkt:225:42>

Defer_Res47 :=
   Var_Bind_Transform_Parse0 (Parser, Lst_Cpos1);
Defer_Pos47 := Parser.Current_Pos;

--  END <Defer (for 'var_bind') at parser.lkt:225:42>

    if Defer_Pos47 /= No_Token_Index then
        Or_Pos9 := Defer_Pos47;
        Or_Res9 := Defer_Res47;
        goto Exit_Or9;
    end if;
<<Exit_Or9>>

--  END <Or (root of 'block') at parser.lkt:225:28>


   exit when Or_Pos9 = No_Token_Index;

   List_Pos1 := Or_Pos9;
   Lst_Cpos1 := List_Pos1;

   Tmp_List1.Nodes.Append (Or_Res9);

      
--  BEGIN <Token(<WithText Semicolon>, ) (root of 'block') at parser.lkt:225:53>

Token_Res43 := Lst_Cpos1;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res43));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Semicolon)
   then
       Token_Pos43 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos1 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos1,
             Expected_Token_Id => Lkt_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos43 := Lst_Cpos1 + 1;
   end if;
end;

--  END <Token(<WithText Semicolon>, ) (root of 'block') at parser.lkt:225:53>


      exit when Token_Pos43 = No_Token_Index;

      Lst_Cpos1 := Token_Pos43;

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List1.Nodes.Length;
begin
   List_Res1 := Allocate_Block_Decl_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos27;
      Token_End := (if Lst_Cpos1 = Row_Pos27
                    then Row_Pos27
                    else List_Pos1 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos27, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res1,
      Kind              => Lkt_Block_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res1,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List1.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res1.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List1);

--  END <List (root of 'block') at parser.lkt:225:13>




if List_Pos1 /= No_Token_Index then

   Row_Pos27 := List_Pos1;

else
   Row_Pos27 := No_Token_Index;
   goto Exit_Row27_0;

end if;


--  BEGIN <Token(<WithText Semicolon>, ) (root of 'block') at parser.lkt:225:58>

Token_Res44 := Row_Pos27;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res44));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Semicolon)
   then
       Token_Pos44 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos27 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos27,
             Expected_Token_Id => Lkt_Semicolon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos44 := Row_Pos27 + 1;
   end if;
end;

--  END <Token(<WithText Semicolon>, ) (root of 'block') at parser.lkt:225:58>




if Token_Pos44 /= No_Token_Index then

   Row_Pos27 := Token_Pos44;

else
   Row_Pos27 := No_Token_Index;
   goto Exit_Row27_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:225:62>

Defer_Res48 :=
   Expr_Or_Parse1 (Parser, Row_Pos27);
Defer_Pos48 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:225:62>




if Defer_Pos48 /= No_Token_Index then

   Row_Pos27 := Defer_Pos48;

else
   Row_Pos27 := No_Token_Index;
   goto Exit_Row27_0;

end if;


--  BEGIN <Token(<WithText RBrace>, ) (root of 'block') at parser.lkt:225:67>

Token_Res45 := Row_Pos27;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res45));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos45 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos27 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos27,
             Expected_Token_Id => Lkt_R_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos45 := Row_Pos27 + 1;
   end if;
end;

--  END <Token(<WithText RBrace>, ) (root of 'block') at parser.lkt:225:67>




if Token_Pos45 /= No_Token_Index then

   Row_Pos27 := Token_Pos45;

else
   Row_Pos27 := No_Token_Index;
   goto Exit_Row27_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row27_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'block') at ???>



if Row_Pos27 /= No_Token_Index then

   Transform_Res26 := Allocate_Block_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res26,
      Kind => Lkt_Block_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos27 = Pos
                            then No_Token_Index
                            else Row_Pos27 - 1));

      
      Initialize_Fields_For_Block_Expr
        (Self => Transform_Res26,
         Block_Expr_F_Val_Defs => List_Res1,
         Block_Expr_F_Expr => Defer_Res48);

         if List_Res1 /= null and then Is_Incomplete (List_Res1) then
            Transform_Res26.Last_Attempted_Child := 0;
         elsif List_Res1 /= null and then not Is_Ghost (List_Res1) then
            Transform_Res26.Last_Attempted_Child := -1;
         end if;
         if Defer_Res48 /= null and then Is_Incomplete (Defer_Res48) then
            Transform_Res26.Last_Attempted_Child := 0;
         elsif Defer_Res48 /= null and then not Is_Ghost (Defer_Res48) then
            Transform_Res26.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos27 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags26);
end if;

--  END <Transform(<CompiledType BareBlockExpr>) (root of 'block') at parser.lkt:223:14>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Block_Transform_Parse0_Memo,
      Row_Pos27 /= No_Token_Index,
      Transform_Res26,
      Pos,
      Row_Pos27);


   Parser.Current_Pos := Row_Pos27;

   return Transform_Res26;
end Block_Transform_Parse0;

   


function Block_String_Lit_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Block_String_Lit
is
   use Bare_Block_String_Lit_Memos;

      Row_Pos28 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos2 :
            Token_Index
               := No_Token_Index;
      Tmp_List2 :
            Free_Parse_List;
      Row_Pos29 :
            Token_Index
               := No_Token_Index;
      Token_Pos46 :
            Token_Index
               := No_Token_Index;
      Token_Res46 :
            Token_Index
               := No_Token_Index;
      Transform_Res27 :
            Bare_Block_String_Line
               := No_Bare_Lkt_Node;
      Transform_Diags27 :
            Ada.Containers.Count_Type;
      List_Pos2 :
            Token_Index
               := No_Token_Index;
      List_Res2 :
            Bare_Block_String_Line_List
               := No_Bare_Lkt_Node;
      Transform_Res28 :
            Bare_Block_String_Lit
               := No_Bare_Lkt_Node;
      Transform_Diags28 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Block_String_Lit_Transform_Parse1_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res28 := M.Instance;
      return Transform_Res28;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res28;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareBlockStringLit>) (root of 'block_string_lit') at parser.lkt:297:25>

Transform_Diags28 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'block_string_lit') at ???>

Row_Pos28 := Pos;



--  BEGIN <List (root of 'block_string_lit') at parser.lkt:298:9>

    List_Pos2 := No_Token_Index;



Lst_Cpos2 := Row_Pos28;
Tmp_List2 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Transform(<CompiledType BareBlockStringLine>) (root of 'block_string_lit') at parser.lkt:298:15>

Transform_Diags27 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'block_string_lit') at ???>

Row_Pos29 := Lst_Cpos2;



--  BEGIN <Token(<WithText BlockStringLine>, ) (root of 'block_string_lit') at parser.lkt:298:31>

Token_Res46 := Row_Pos29;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res46));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Block_String_Line)
   then
       Token_Pos46 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos29 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos29,
             Expected_Token_Id => Lkt_Block_String_Line,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos46 := Row_Pos29 + 1;
   end if;
end;

--  END <Token(<WithText BlockStringLine>, ) (root of 'block_string_lit') at parser.lkt:298:31>




if Token_Pos46 /= No_Token_Index then

   Row_Pos29 := Token_Pos46;

else
   Row_Pos29 := No_Token_Index;
   goto Exit_Row29_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row29_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'block_string_lit') at ???>



if Row_Pos29 /= No_Token_Index then

   Transform_Res27 := Allocate_Block_String_Line (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res27,
      Kind => Lkt_Block_String_Line,
      Unit => Parser.Unit,

      Token_Start_Index => Lst_Cpos2,
      Token_End_Index   => (if Row_Pos29 = Lst_Cpos2
                            then No_Token_Index
                            else Row_Pos29 - 1));




elsif Row_Pos29 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags27);
end if;

--  END <Transform(<CompiledType BareBlockStringLine>) (root of 'block_string_lit') at parser.lkt:298:15>


   exit when Row_Pos29 = No_Token_Index;

   List_Pos2 := Row_Pos29;
   Lst_Cpos2 := List_Pos2;

   Tmp_List2.Nodes.Append (Transform_Res27);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List2.Nodes.Length;
begin
   List_Res2 := Allocate_Block_String_Line_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos28;
      Token_End := (if Lst_Cpos2 = Row_Pos28
                    then Row_Pos28
                    else List_Pos2 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos28, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res2,
      Kind              => Lkt_Block_String_Line_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res2,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List2.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res2.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List2);

--  END <List (root of 'block_string_lit') at parser.lkt:298:9>




if List_Pos2 /= No_Token_Index then

   Row_Pos28 := List_Pos2;

else
   Row_Pos28 := No_Token_Index;
   goto Exit_Row28_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row28_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'block_string_lit') at ???>



if Row_Pos28 /= No_Token_Index then

   Transform_Res28 := Allocate_Block_String_Lit (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res28,
      Kind => Lkt_Block_String_Lit,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos28 = Pos
                            then No_Token_Index
                            else Row_Pos28 - 1));

      
      Initialize_Fields_For_Block_String_Lit
        (Self => Transform_Res28,
         Block_String_Lit_F_Lines => List_Res2);

         if List_Res2 /= null and then Is_Incomplete (List_Res2) then
            Transform_Res28.Last_Attempted_Child := 0;
         elsif List_Res2 /= null and then not Is_Ghost (List_Res2) then
            Transform_Res28.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos28 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags28);
end if;

--  END <Transform(<CompiledType BareBlockStringLit>) (root of 'block_string_lit') at parser.lkt:297:25>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Block_String_Lit_Transform_Parse1_Memo,
      Row_Pos28 /= No_Token_Index,
      Transform_Res28,
      Pos,
      Row_Pos28);


   Parser.Current_Pos := Row_Pos28;

   return Transform_Res28;
end Block_String_Lit_Transform_Parse1;

   


function Callable_Ref_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

      Row_Pos30 :
            Token_Index
               := No_Token_Index;
      Defer_Pos49 :
            Token_Index
               := No_Token_Index;
      Defer_Res49 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos47 :
            Token_Index
               := No_Token_Index;
      Token_Res47 :
            Token_Index
               := No_Token_Index;
      Defer_Pos50 :
            Token_Index
               := No_Token_Index;
      Defer_Res50 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Transform_Res29 :
            Bare_Dot_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags29 :
            Ada.Containers.Count_Type;
      Defer_Pos51 :
            Token_Index
               := No_Token_Index;
      Defer_Res51 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Or_Pos10 :
            Token_Index
               := No_Token_Index;
      Or_Res10 :
            Bare_Expr
               := No_Bare_Lkt_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Expr := No_Bare_Lkt_Node;

   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Callable_Ref_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res10 := M.Instance;
      return Or_Res10;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res10;
   end if;

       Set (PP.Callable_Ref_Or_Parse0_Memo, False, Or_Res10, Pos, Mem_Pos);

       <<Try_Again>>



   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'callable_ref') at parser.lkt:313:21>

Or_Pos10 := No_Token_Index;
Or_Res10 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareDotExpr>) (root of 'callable_ref') at parser.lkt:313:24>

Transform_Diags29 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'callable_ref') at ???>

Row_Pos30 := Pos;



--  BEGIN <Defer (for 'callable_ref') at parser.lkt:313:32>

Defer_Res49 :=
   Callable_Ref_Or_Parse0 (Parser, Row_Pos30);
Defer_Pos49 := Parser.Current_Pos;

--  END <Defer (for 'callable_ref') at parser.lkt:313:32>




if Defer_Pos49 /= No_Token_Index then

   Row_Pos30 := Defer_Pos49;

else
   Row_Pos30 := No_Token_Index;
   goto Exit_Row30_0;

end if;


--  BEGIN <Token(<WithText Dot>, ) (root of 'callable_ref') at parser.lkt:313:45>

Token_Res47 := Row_Pos30;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res47));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dot)
   then
       Token_Pos47 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos30 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos30,
             Expected_Token_Id => Lkt_Dot,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos47 := Row_Pos30 + 1;
   end if;
end;

--  END <Token(<WithText Dot>, ) (root of 'callable_ref') at parser.lkt:313:45>




if Token_Pos47 /= No_Token_Index then

   Row_Pos30 := Token_Pos47;

else
   Row_Pos30 := No_Token_Index;
   goto Exit_Row30_0;

end if;


--  BEGIN <Defer (for 'ref_id') at parser.lkt:313:49>

Defer_Res50 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos30);
Defer_Pos50 := Parser.Current_Pos;

--  END <Defer (for 'ref_id') at parser.lkt:313:49>




if Defer_Pos50 /= No_Token_Index then

   Row_Pos30 := Defer_Pos50;

else
   Row_Pos30 := No_Token_Index;
   goto Exit_Row30_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row30_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'callable_ref') at ???>



if Row_Pos30 /= No_Token_Index then

   Transform_Res29 := Allocate_Dot_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res29,
      Kind => Lkt_Dot_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos30 = Pos
                            then No_Token_Index
                            else Row_Pos30 - 1));

      
      Initialize_Fields_For_Dot_Expr
        (Self => Transform_Res29,
         Base_Dot_Expr_F_Prefix => Defer_Res49,
         Base_Dot_Expr_F_Suffix => Defer_Res50);

         if Defer_Res49 /= null and then Is_Incomplete (Defer_Res49) then
            Transform_Res29.Last_Attempted_Child := 0;
         elsif Defer_Res49 /= null and then not Is_Ghost (Defer_Res49) then
            Transform_Res29.Last_Attempted_Child := -1;
         end if;
         if Defer_Res50 /= null and then Is_Incomplete (Defer_Res50) then
            Transform_Res29.Last_Attempted_Child := 0;
         elsif Defer_Res50 /= null and then not Is_Ghost (Defer_Res50) then
            Transform_Res29.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos30 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags29);
end if;

--  END <Transform(<CompiledType BareDotExpr>) (root of 'callable_ref') at parser.lkt:313:24>

    if Row_Pos30 /= No_Token_Index then
        Or_Pos10 := Row_Pos30;
        Or_Res10 := Transform_Res29;
        goto Exit_Or10;
    end if;
    
--  BEGIN <Defer (for 'ref_id') at parser.lkt:313:59>

Defer_Res51 :=
   Ref_Id_Transform_Parse0 (Parser, Pos);
Defer_Pos51 := Parser.Current_Pos;

--  END <Defer (for 'ref_id') at parser.lkt:313:59>

    if Defer_Pos51 /= No_Token_Index then
        Or_Pos10 := Defer_Pos51;
        Or_Res10 := Defer_Res51;
        goto Exit_Or10;
    end if;
<<Exit_Or10>>

--  END <Or (root of 'callable_ref') at parser.lkt:313:21>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos10 > Mem_Pos then
         Mem_Pos := Or_Pos10;
         Mem_Res := Or_Res10;
         Set
           (PP.Callable_Ref_Or_Parse0_Memo,
            Or_Pos10 /= No_Token_Index,
            Or_Res10,
            Pos,
            Or_Pos10);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res10 := Mem_Res;
         Or_Pos10 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (PP.Callable_Ref_Or_Parse0_Memo,
      Or_Pos10 /= No_Token_Index,
      Or_Res10,
      Pos,
      Or_Pos10);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos10;

   return Or_Res10;
end Callable_Ref_Or_Parse0;

   


function Char_Lit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Char_Lit
is
   use Bare_Char_Lit_Memos;

      Row_Pos31 :
            Token_Index
               := No_Token_Index;
      Token_Pos48 :
            Token_Index
               := No_Token_Index;
      Token_Res48 :
            Token_Index
               := No_Token_Index;
      Transform_Res30 :
            Bare_Char_Lit
               := No_Bare_Lkt_Node;
      Transform_Diags30 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Char_Lit_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res30 := M.Instance;
      return Transform_Res30;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res30;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareCharLit>) (root of 'char_lit') at parser.lkt:300:17>

Transform_Diags30 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'char_lit') at ???>

Row_Pos31 := Pos;



--  BEGIN <Token(<WithText Char>, ) (root of 'char_lit') at parser.lkt:300:25>

Token_Res48 := Row_Pos31;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res48));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Char)
   then
       Token_Pos48 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos31 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos31,
             Expected_Token_Id => Lkt_Char,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos48 := Row_Pos31 + 1;
   end if;
end;

--  END <Token(<WithText Char>, ) (root of 'char_lit') at parser.lkt:300:25>




if Token_Pos48 /= No_Token_Index then

   Row_Pos31 := Token_Pos48;

else
   Row_Pos31 := No_Token_Index;
   goto Exit_Row31_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row31_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'char_lit') at ???>



if Row_Pos31 /= No_Token_Index then

   Transform_Res30 := Allocate_Char_Lit (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res30,
      Kind => Lkt_Char_Lit,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos31 = Pos
                            then No_Token_Index
                            else Row_Pos31 - 1));

      
      Initialize_Fields_For_Char_Lit
        (Self => Transform_Res30);



elsif Row_Pos31 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags30);
end if;

--  END <Transform(<CompiledType BareCharLit>) (root of 'char_lit') at parser.lkt:300:17>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Char_Lit_Transform_Parse0_Memo,
      Row_Pos31 /= No_Token_Index,
      Transform_Res30,
      Pos,
      Row_Pos31);


   Parser.Current_Pos := Row_Pos31;

   return Transform_Res30;
end Char_Lit_Transform_Parse0;

   


function Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Full_Decl
is
   use Bare_Full_Decl_Memos;

      Row_Pos32 :
            Token_Index
               := No_Token_Index;
      Defer_Pos52 :
            Token_Index
               := No_Token_Index;
      Defer_Res52 :
            Bare_String_Lit
               := No_Bare_Lkt_Node;
      Lst_Cpos3 :
            Token_Index
               := No_Token_Index;
      Tmp_List3 :
            Free_Parse_List;
      Defer_Pos53 :
            Token_Index
               := No_Token_Index;
      Defer_Res53 :
            Bare_Decl_Annotation
               := No_Bare_Lkt_Node;
      List_Pos3 :
            Token_Index
               := No_Token_Index;
      List_Res3 :
            Bare_Decl_Annotation_List
               := No_Bare_Lkt_Node;
      Defer_Pos54 :
            Token_Index
               := No_Token_Index;
      Defer_Res54 :
            Bare_Decl
               := No_Bare_Lkt_Node;
      Transform_Res31 :
            Bare_Full_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags31 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Decl_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res31 := M.Instance;
      return Transform_Res31;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res31;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareFullDecl>) (root of 'decl') at parser.lkt:205:13>

Transform_Diags31 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'decl') at ???>

Row_Pos32 := Pos;



--  BEGIN <Defer (for 'doc') at parser.lkt:205:22>

Defer_Res52 :=
   Doc_Opt_Parse0 (Parser, Row_Pos32);
Defer_Pos52 := Parser.Current_Pos;

--  END <Defer (for 'doc') at parser.lkt:205:22>




if Defer_Pos52 /= No_Token_Index then

   Row_Pos32 := Defer_Pos52;

else
   Row_Pos32 := No_Token_Index;
   goto Exit_Row32_0;

end if;


--  BEGIN <List (root of 'decl') at parser.lkt:205:26>

    List_Pos3 := Row_Pos32;



Lst_Cpos3 := Row_Pos32;
Tmp_List3 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'decl_annotation') at parser.lkt:205:32>

Defer_Res53 :=
   Decl_Annotation_Transform_Parse0 (Parser, Lst_Cpos3);
Defer_Pos53 := Parser.Current_Pos;

--  END <Defer (for 'decl_annotation') at parser.lkt:205:32>


   exit when Defer_Pos53 = No_Token_Index;

   List_Pos3 := Defer_Pos53;
   Lst_Cpos3 := List_Pos3;

   Tmp_List3.Nodes.Append (Defer_Res53);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List3.Nodes.Length;
begin
   List_Res3 := Allocate_Decl_Annotation_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos32;
      Token_End := (if Lst_Cpos3 = Row_Pos32
                    then Row_Pos32
                    else List_Pos3 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos32, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res3,
      Kind              => Lkt_Decl_Annotation_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res3,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List3.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res3.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List3);

--  END <List (root of 'decl') at parser.lkt:205:26>




if List_Pos3 /= No_Token_Index then

   Row_Pos32 := List_Pos3;

else
   Row_Pos32 := No_Token_Index;
   goto Exit_Row32_0;

end if;


--  BEGIN <Defer (for 'bare_decl') at parser.lkt:205:49>

Defer_Res54 :=
   Bare_Decl_Or_Parse0 (Parser, Row_Pos32);
Defer_Pos54 := Parser.Current_Pos;

--  END <Defer (for 'bare_decl') at parser.lkt:205:49>




if Defer_Pos54 /= No_Token_Index then

   Row_Pos32 := Defer_Pos54;

else
   Row_Pos32 := No_Token_Index;
   goto Exit_Row32_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row32_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'decl') at ???>



if Row_Pos32 /= No_Token_Index then

   Transform_Res31 := Allocate_Full_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res31,
      Kind => Lkt_Full_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos32 = Pos
                            then No_Token_Index
                            else Row_Pos32 - 1));

      
      Initialize_Fields_For_Full_Decl
        (Self => Transform_Res31,
         Full_Decl_F_Doc => Defer_Res52,
         Full_Decl_F_Decl_Annotations => List_Res3,
         Full_Decl_F_Decl => Defer_Res54);

         if Defer_Res52 /= null and then Is_Incomplete (Defer_Res52) then
            Transform_Res31.Last_Attempted_Child := 0;
         elsif Defer_Res52 /= null and then not Is_Ghost (Defer_Res52) then
            Transform_Res31.Last_Attempted_Child := -1;
         end if;
         if List_Res3 /= null and then Is_Incomplete (List_Res3) then
            Transform_Res31.Last_Attempted_Child := 0;
         elsif List_Res3 /= null and then not Is_Ghost (List_Res3) then
            Transform_Res31.Last_Attempted_Child := -1;
         end if;
         if Defer_Res54 /= null and then Is_Incomplete (Defer_Res54) then
            Transform_Res31.Last_Attempted_Child := 0;
         elsif Defer_Res54 /= null and then not Is_Ghost (Defer_Res54) then
            Transform_Res31.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos32 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags31);
end if;

--  END <Transform(<CompiledType BareFullDecl>) (root of 'decl') at parser.lkt:205:13>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Decl_Transform_Parse0_Memo,
      Row_Pos32 /= No_Token_Index,
      Transform_Res31,
      Pos,
      Row_Pos32);


   Parser.Current_Pos := Row_Pos32;

   return Transform_Res31;
end Decl_Transform_Parse0;

   


function Decl_Annotation_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decl_Annotation
is
   use Bare_Decl_Annotation_Memos;

      Row_Pos33 :
            Token_Index
               := No_Token_Index;
      Token_Pos49 :
            Token_Index
               := No_Token_Index;
      Token_Res49 :
            Token_Index
               := No_Token_Index;
      Defer_Pos55 :
            Token_Index
               := No_Token_Index;
      Defer_Res55 :
            Bare_Id
               := No_Bare_Lkt_Node;
      Defer_Pos56 :
            Token_Index
               := No_Token_Index;
      Defer_Res56 :
            Bare_Decl_Annotation_Params
               := No_Bare_Lkt_Node;
      Transform_Res32 :
            Bare_Decl_Annotation
               := No_Bare_Lkt_Node;
      Transform_Diags32 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Decl_Annotation_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res32 := M.Instance;
      return Transform_Res32;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res32;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareDeclAnnotation>) (root of 'decl_annotation') at parser.lkt:351:24>

Transform_Diags32 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'decl_annotation') at ???>

Row_Pos33 := Pos;



--  BEGIN <Token(<WithText At>, ) (root of 'decl_annotation') at parser.lkt:351:39>

Token_Res49 := Row_Pos33;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res49));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_At)
   then
       Token_Pos49 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos33 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos33,
             Expected_Token_Id => Lkt_At,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos49 := Row_Pos33 + 1;
   end if;
end;

--  END <Token(<WithText At>, ) (root of 'decl_annotation') at parser.lkt:351:39>




if Token_Pos49 /= No_Token_Index then

   Row_Pos33 := Token_Pos49;

else
   Row_Pos33 := No_Token_Index;
   goto Exit_Row33_0;

end if;


--  BEGIN <Defer (for 'id') at parser.lkt:351:43>

Defer_Res55 :=
   Id_Transform_Parse0 (Parser, Row_Pos33);
Defer_Pos55 := Parser.Current_Pos;

--  END <Defer (for 'id') at parser.lkt:351:43>




if Defer_Pos55 /= No_Token_Index then

   Row_Pos33 := Defer_Pos55;

else
   Row_Pos33 := No_Token_Index;
   goto Exit_Row33_0;

end if;


--  BEGIN <Defer (for 'decl_annotation_params') at parser.lkt:351:46>

Defer_Res56 :=
   Decl_Annotation_Params_Opt_Parse0 (Parser, Row_Pos33);
Defer_Pos56 := Parser.Current_Pos;

--  END <Defer (for 'decl_annotation_params') at parser.lkt:351:46>




if Defer_Pos56 /= No_Token_Index then

   Row_Pos33 := Defer_Pos56;

else
   Row_Pos33 := No_Token_Index;
   goto Exit_Row33_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row33_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'decl_annotation') at ???>



if Row_Pos33 /= No_Token_Index then

   Transform_Res32 := Allocate_Decl_Annotation (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res32,
      Kind => Lkt_Decl_Annotation,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos33 = Pos
                            then No_Token_Index
                            else Row_Pos33 - 1));

      
      Initialize_Fields_For_Decl_Annotation
        (Self => Transform_Res32,
         Decl_Annotation_F_Name => Defer_Res55,
         Decl_Annotation_F_Params => Defer_Res56);

         if Defer_Res55 /= null and then Is_Incomplete (Defer_Res55) then
            Transform_Res32.Last_Attempted_Child := 0;
         elsif Defer_Res55 /= null and then not Is_Ghost (Defer_Res55) then
            Transform_Res32.Last_Attempted_Child := -1;
         end if;
         if Defer_Res56 /= null and then Is_Incomplete (Defer_Res56) then
            Transform_Res32.Last_Attempted_Child := 0;
         elsif Defer_Res56 /= null and then not Is_Ghost (Defer_Res56) then
            Transform_Res32.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos33 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags32);
end if;

--  END <Transform(<CompiledType BareDeclAnnotation>) (root of 'decl_annotation') at parser.lkt:351:24>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Decl_Annotation_Transform_Parse0_Memo,
      Row_Pos33 /= No_Token_Index,
      Transform_Res32,
      Pos,
      Row_Pos33);


   Parser.Current_Pos := Row_Pos33;

   return Transform_Res32;
end Decl_Annotation_Transform_Parse0;

   


function Decl_Annotation_Params_Opt_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decl_Annotation_Params
is
   use Bare_Decl_Annotation_Params_Memos;

      Row_Pos34 :
            Token_Index
               := No_Token_Index;
      Token_Pos50 :
            Token_Index
               := No_Token_Index;
      Token_Res50 :
            Token_Index
               := No_Token_Index;
      Defer_Pos57 :
            Token_Index
               := No_Token_Index;
      Defer_Res57 :
            Bare_Param_List
               := No_Bare_Lkt_Node;
      Token_Pos51 :
            Token_Index
               := No_Token_Index;
      Token_Res51 :
            Token_Index
               := No_Token_Index;
      Transform_Res33 :
            Bare_Decl_Annotation_Params
               := No_Bare_Lkt_Node;
      Transform_Diags33 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Decl_Annotation_Params_Opt_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res33 := M.Instance;
      return Transform_Res33;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res33;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Opt (root of 'decl_annotation_params') at parser.lkt:350:31>












--  BEGIN <Transform(<CompiledType BareDeclAnnotationParams>) (root of 'decl_annotation_params') at parser.lkt:350:32>

Transform_Diags33 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'decl_annotation_params') at ???>

Row_Pos34 := Pos;



--  BEGIN <Token(<WithText LPar>, ) (root of 'decl_annotation_params') at parser.lkt:350:53>

Token_Res50 := Row_Pos34;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res50));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos50 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos34 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos34,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos50 := Row_Pos34 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'decl_annotation_params') at parser.lkt:350:53>




if Token_Pos50 /= No_Token_Index then

   Row_Pos34 := Token_Pos50;

else
   Row_Pos34 := No_Token_Index;
   goto Exit_Row34_0;

end if;


--  BEGIN <Defer (for 'params') at parser.lkt:350:57>

Defer_Res57 :=
   Params_List_Parse0 (Parser, Row_Pos34);
Defer_Pos57 := Parser.Current_Pos;

--  END <Defer (for 'params') at parser.lkt:350:57>




if Defer_Pos57 /= No_Token_Index then

   Row_Pos34 := Defer_Pos57;

else
   Row_Pos34 := No_Token_Index;
   goto Exit_Row34_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'decl_annotation_params') at parser.lkt:350:64>

Token_Res51 := Row_Pos34;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res51));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos51 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos34 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos34,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos51 := Row_Pos34 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'decl_annotation_params') at parser.lkt:350:64>




if Token_Pos51 /= No_Token_Index then

   Row_Pos34 := Token_Pos51;

else
   Row_Pos34 := No_Token_Index;
   goto Exit_Row34_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row34_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'decl_annotation_params') at ???>



if Row_Pos34 /= No_Token_Index then

   Transform_Res33 := Allocate_Decl_Annotation_Params (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res33,
      Kind => Lkt_Decl_Annotation_Params,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos34 = Pos
                            then No_Token_Index
                            else Row_Pos34 - 1));

      
      Initialize_Fields_For_Decl_Annotation_Params
        (Self => Transform_Res33,
         Decl_Annotation_Params_F_Params => Defer_Res57);

         if Defer_Res57 /= null and then Is_Incomplete (Defer_Res57) then
            Transform_Res33.Last_Attempted_Child := 0;
         elsif Defer_Res57 /= null and then not Is_Ghost (Defer_Res57) then
            Transform_Res33.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos34 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags33);
end if;

--  END <Transform(<CompiledType BareDeclAnnotationParams>) (root of 'decl_annotation_params') at parser.lkt:350:32>


if Row_Pos34 = No_Token_Index then

         
   Transform_Res33 := No_Bare_Lkt_Node;



       
   Row_Pos34 := Pos;



end if;

--  END <Opt (root of 'decl_annotation_params') at parser.lkt:350:31>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Decl_Annotation_Params_Opt_Parse0_Memo,
      Row_Pos34 /= No_Token_Index,
      Transform_Res33,
      Pos,
      Row_Pos34);


   Parser.Current_Pos := Row_Pos34;

   return Transform_Res33;
end Decl_Annotation_Params_Opt_Parse0;

   


function Decl_Block_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decl_Block
is
   use Bare_Decl_Block_Memos;

      Lst_Cpos4 :
            Token_Index
               := No_Token_Index;
      Tmp_List4 :
            Free_Parse_List;
      Defer_Pos58 :
            Token_Index
               := No_Token_Index;
      Defer_Res58 :
            Bare_Full_Decl
               := No_Bare_Lkt_Node;
      List_Pos4 :
            Token_Index
               := No_Token_Index;
      List_Res4 :
            Bare_Decl_Block
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Decl_Block_List_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res4 := M.Instance;
      return List_Res4;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return List_Res4;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <List (root of 'decl_block') at parser.lkt:215:19>

    List_Pos4 := Pos;



Lst_Cpos4 := Pos;
Tmp_List4 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'decl') at parser.lkt:215:30>

Defer_Res58 :=
   Decl_Transform_Parse0 (Parser, Lst_Cpos4);
Defer_Pos58 := Parser.Current_Pos;

--  END <Defer (for 'decl') at parser.lkt:215:30>


   exit when Defer_Pos58 = No_Token_Index;

   List_Pos4 := Defer_Pos58;
   Lst_Cpos4 := List_Pos4;

   Tmp_List4.Nodes.Append (Defer_Res58);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List4.Nodes.Length;
begin
   List_Res4 := Allocate_Decl_Block (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos4 = Pos
                    then Pos
                    else List_Pos4 - 1);

   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res4,
      Kind              => Lkt_Decl_Block,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res4,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List4.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res4.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List4);

--  END <List (root of 'decl_block') at parser.lkt:215:19>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Decl_Block_List_Parse0_Memo,
      List_Pos4 /= No_Token_Index,
      List_Res4,
      Pos,
      List_Pos4);


   Parser.Current_Pos := List_Pos4;

   return List_Res4;
end Decl_Block_List_Parse0;

   


function Decls_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Full_Decl_List
is
   use Bare_Full_Decl_List_Memos;

      Lst_Cpos5 :
            Token_Index
               := No_Token_Index;
      Tmp_List5 :
            Free_Parse_List;
      Defer_Pos59 :
            Token_Index
               := No_Token_Index;
      Defer_Res59 :
            Bare_Full_Decl
               := No_Bare_Lkt_Node;
      List_Pos5 :
            Token_Index
               := No_Token_Index;
      List_Res5 :
            Bare_Full_Decl_List
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Decls_List_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res5 := M.Instance;
      return List_Res5;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return List_Res5;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <List (root of 'decls') at parser.lkt:214:14>

    List_Pos5 := Pos;



Lst_Cpos5 := Pos;
Tmp_List5 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'decl') at parser.lkt:214:20>

Defer_Res59 :=
   Decl_Transform_Parse0 (Parser, Lst_Cpos5);
Defer_Pos59 := Parser.Current_Pos;

--  END <Defer (for 'decl') at parser.lkt:214:20>


   exit when Defer_Pos59 = No_Token_Index;

   List_Pos5 := Defer_Pos59;
   Lst_Cpos5 := List_Pos5;

   Tmp_List5.Nodes.Append (Defer_Res59);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List5.Nodes.Length;
begin
   List_Res5 := Allocate_Full_Decl_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos5 = Pos
                    then Pos
                    else List_Pos5 - 1);

   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res5,
      Kind              => Lkt_Full_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res5,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List5.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res5.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List5);

--  END <List (root of 'decls') at parser.lkt:214:14>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Decls_List_Parse0_Memo,
      List_Pos5 /= No_Token_Index,
      List_Res5,
      Pos,
      List_Pos5);


   Parser.Current_Pos := List_Pos5;

   return List_Res5;
end Decls_List_Parse0;

   


function Def_Id_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Def_Id
is
   use Bare_Def_Id_Memos;

      Row_Pos35 :
            Token_Index
               := No_Token_Index;
      Token_Pos52 :
            Token_Index
               := No_Token_Index;
      Token_Res52 :
            Token_Index
               := No_Token_Index;
      Transform_Res34 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Transform_Diags34 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Def_Id_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res34 := M.Instance;
      return Transform_Res34;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res34;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareDefId>) (root of 'def_id') at parser.lkt:9:15>

Transform_Diags34 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'def_id') at ???>

Row_Pos35 := Pos;



--  BEGIN <Token(<WithSymbol Identifier>, ) (root of 'def_id') at parser.lkt:9:21>

Token_Res52 := Row_Pos35;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res52));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
   then
       Token_Pos52 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos35 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos35,
             Expected_Token_Id => Lkt_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos52 := Row_Pos35 + 1;
   end if;
end;

--  END <Token(<WithSymbol Identifier>, ) (root of 'def_id') at parser.lkt:9:21>




if Token_Pos52 /= No_Token_Index then

   Row_Pos35 := Token_Pos52;

else
   Row_Pos35 := No_Token_Index;
   goto Exit_Row35_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row35_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'def_id') at ???>



if Row_Pos35 /= No_Token_Index then

   Transform_Res34 := Allocate_Def_Id (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res34,
      Kind => Lkt_Def_Id,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos35 = Pos
                            then No_Token_Index
                            else Row_Pos35 - 1));

      
      Initialize_Fields_For_Def_Id
        (Self => Transform_Res34);



elsif Row_Pos35 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags34);
end if;

--  END <Transform(<CompiledType BareDefId>) (root of 'def_id') at parser.lkt:9:15>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Def_Id_Transform_Parse0_Memo,
      Row_Pos35 /= No_Token_Index,
      Transform_Res34,
      Pos,
      Row_Pos35);


   Parser.Current_Pos := Row_Pos35;

   return Transform_Res34;
end Def_Id_Transform_Parse0;

   


function Doc_Opt_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_String_Lit
is
   use Bare_String_Lit_Memos;

      Defer_Pos60 :
            Token_Index
               := No_Token_Index;
      Defer_Res60 :
            Bare_String_Lit
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Doc_Opt_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Defer_Res60 := M.Instance;
      return Defer_Res60;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Defer_Res60;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Opt (root of 'doc') at parser.lkt:10:12>












--  BEGIN <Defer (for 'string_lit') at parser.lkt:10:13>

Defer_Res60 :=
   String_Lit_Or_Parse0 (Parser, Pos);
Defer_Pos60 := Parser.Current_Pos;

--  END <Defer (for 'string_lit') at parser.lkt:10:13>


if Defer_Pos60 = No_Token_Index then

         
   Defer_Res60 := No_Bare_Lkt_Node;



       
   Defer_Pos60 := Pos;



end if;

--  END <Opt (root of 'doc') at parser.lkt:10:12>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Doc_Opt_Parse0_Memo,
      Defer_Pos60 /= No_Token_Index,
      Defer_Res60,
      Pos,
      Defer_Pos60);


   Parser.Current_Pos := Defer_Pos60;

   return Defer_Res60;
end Doc_Opt_Parse0;

   


function Dynvar_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Dyn_Var_Decl
is
   use Bare_Dyn_Var_Decl_Memos;

      Row_Pos36 :
            Token_Index
               := No_Token_Index;
      Token_Pos53 :
            Token_Index
               := No_Token_Index;
      Token_Res53 :
            Token_Index
               := No_Token_Index;
      Defer_Pos61 :
            Token_Index
               := No_Token_Index;
      Defer_Res61 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Token_Pos54 :
            Token_Index
               := No_Token_Index;
      Token_Res54 :
            Token_Index
               := No_Token_Index;
      Defer_Pos62 :
            Token_Index
               := No_Token_Index;
      Defer_Res62 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Transform_Res35 :
            Bare_Dyn_Var_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags35 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Dynvar_Decl_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res35 := M.Instance;
      return Transform_Res35;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res35;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareDynVarDecl>) (root of 'dynvar_decl') at parser.lkt:217:20>

Transform_Diags35 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'dynvar_decl') at ???>

Row_Pos36 := Pos;



--  BEGIN <Token(<WithText DynVarKw>, ) (root of 'dynvar_decl') at parser.lkt:217:31>

Token_Res53 := Row_Pos36;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res53));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dyn_Var_Kw)
   then
       Token_Pos53 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos36 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos36,
             Expected_Token_Id => Lkt_Dyn_Var_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos53 := Row_Pos36 + 1;
   end if;
end;

--  END <Token(<WithText DynVarKw>, ) (root of 'dynvar_decl') at parser.lkt:217:31>




if Token_Pos53 /= No_Token_Index then

   Row_Pos36 := Token_Pos53;

else
   Row_Pos36 := No_Token_Index;
   goto Exit_Row36_0;

end if;


--  BEGIN <Defer (for 'def_id') at parser.lkt:217:40>

Defer_Res61 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos36);
Defer_Pos61 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:217:40>




if Defer_Pos61 /= No_Token_Index then

   Row_Pos36 := Defer_Pos61;

else
   Row_Pos36 := No_Token_Index;
   goto Exit_Row36_0;

end if;


--  BEGIN <Token(<WithText Colon>, ) (root of 'dynvar_decl') at parser.lkt:217:47>

Token_Res54 := Row_Pos36;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res54));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos54 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos36 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos36,
             Expected_Token_Id => Lkt_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos54 := Row_Pos36 + 1;
   end if;
end;

--  END <Token(<WithText Colon>, ) (root of 'dynvar_decl') at parser.lkt:217:47>




if Token_Pos54 /= No_Token_Index then

   Row_Pos36 := Token_Pos54;

else
   Row_Pos36 := No_Token_Index;
   goto Exit_Row36_0;

end if;


--  BEGIN <Defer (for 'type_ref') at parser.lkt:217:51>

Defer_Res62 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos36);
Defer_Pos62 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:217:51>




if Defer_Pos62 /= No_Token_Index then

   Row_Pos36 := Defer_Pos62;

else
   Row_Pos36 := No_Token_Index;
   goto Exit_Row36_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row36_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'dynvar_decl') at ???>



if Row_Pos36 /= No_Token_Index then

   Transform_Res35 := Allocate_Dyn_Var_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res35,
      Kind => Lkt_Dyn_Var_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos36 = Pos
                            then No_Token_Index
                            else Row_Pos36 - 1));

      
      Initialize_Fields_For_Dyn_Var_Decl
        (Self => Transform_Res35,
         Dyn_Var_Decl_F_Syn_Name => Defer_Res61,
         Dyn_Var_Decl_F_Decl_Type => Defer_Res62);

         if Defer_Res61 /= null and then Is_Incomplete (Defer_Res61) then
            Transform_Res35.Last_Attempted_Child := 0;
         elsif Defer_Res61 /= null and then not Is_Ghost (Defer_Res61) then
            Transform_Res35.Last_Attempted_Child := -1;
         end if;
         if Defer_Res62 /= null and then Is_Incomplete (Defer_Res62) then
            Transform_Res35.Last_Attempted_Child := 0;
         elsif Defer_Res62 /= null and then not Is_Ghost (Defer_Res62) then
            Transform_Res35.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos36 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags35);
end if;

--  END <Transform(<CompiledType BareDynVarDecl>) (root of 'dynvar_decl') at parser.lkt:217:20>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Dynvar_Decl_Transform_Parse0_Memo,
      Row_Pos36 /= No_Token_Index,
      Transform_Res35,
      Pos,
      Row_Pos36);


   Parser.Current_Pos := Row_Pos36;

   return Transform_Res35;
end Dynvar_Decl_Transform_Parse0;

   


function Enum_Lit_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Enum_Lit_Decl
is
   use Bare_Enum_Lit_Decl_Memos;

      Row_Pos37 :
            Token_Index
               := No_Token_Index;
      Defer_Pos63 :
            Token_Index
               := No_Token_Index;
      Defer_Res63 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Transform_Res36 :
            Bare_Enum_Lit_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags36 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Enum_Lit_Decl_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res36 := M.Instance;
      return Transform_Res36;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res36;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareEnumLitDecl>) (root of 'enum_lit_decl') at parser.lkt:166:22>

Transform_Diags36 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'enum_lit_decl') at ???>

Row_Pos37 := Pos;



--  BEGIN <Defer (for 'def_id') at parser.lkt:166:34>

Defer_Res63 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos37);
Defer_Pos63 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:166:34>




if Defer_Pos63 /= No_Token_Index then

   Row_Pos37 := Defer_Pos63;

else
   Row_Pos37 := No_Token_Index;
   goto Exit_Row37_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row37_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'enum_lit_decl') at ???>



if Row_Pos37 /= No_Token_Index then

   Transform_Res36 := Allocate_Enum_Lit_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res36,
      Kind => Lkt_Enum_Lit_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos37 = Pos
                            then No_Token_Index
                            else Row_Pos37 - 1));

      
      Initialize_Fields_For_Enum_Lit_Decl
        (Self => Transform_Res36,
         Enum_Lit_Decl_F_Syn_Name => Defer_Res63);

         if Defer_Res63 /= null and then Is_Incomplete (Defer_Res63) then
            Transform_Res36.Last_Attempted_Child := 0;
         elsif Defer_Res63 /= null and then not Is_Ghost (Defer_Res63) then
            Transform_Res36.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos37 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags36);
end if;

--  END <Transform(<CompiledType BareEnumLitDecl>) (root of 'enum_lit_decl') at parser.lkt:166:22>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Enum_Lit_Decl_Transform_Parse0_Memo,
      Row_Pos37 /= No_Token_Index,
      Transform_Res36,
      Pos,
      Row_Pos37);


   Parser.Current_Pos := Row_Pos37;

   return Transform_Res36;
end Enum_Lit_Decl_Transform_Parse0;

   


function Env_Spec_Action_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Call_Expr
is
   use Bare_Call_Expr_Memos;

      Row_Pos38 :
            Token_Index
               := No_Token_Index;
      Row_Pos39 :
            Token_Index
               := No_Token_Index;
      Token_Pos55 :
            Token_Index
               := No_Token_Index;
      Token_Res55 :
            Token_Index
               := No_Token_Index;
      Transform_Res37 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Transform_Diags37 :
            Ada.Containers.Count_Type;
      Token_Pos56 :
            Token_Index
               := No_Token_Index;
      Token_Res56 :
            Token_Index
               := No_Token_Index;
      Defer_Pos64 :
            Token_Index
               := No_Token_Index;
      Defer_Res64 :
            Bare_Param_List
               := No_Bare_Lkt_Node;
      Token_Pos57 :
            Token_Index
               := No_Token_Index;
      Token_Res57 :
            Token_Index
               := No_Token_Index;
      Transform_Res38 :
            Bare_Call_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags38 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Env_Spec_Action_Transform_Parse1_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res38 := M.Instance;
      return Transform_Res38;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res38;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareCallExpr>) (root of 'env_spec_action') at parser.lkt:219:24>

Transform_Diags38 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'env_spec_action') at ???>

Row_Pos38 := Pos;



--  BEGIN <Transform(<CompiledType BareRefId>) (root of 'env_spec_action') at parser.lkt:219:33>

Transform_Diags37 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'env_spec_action') at ???>

Row_Pos39 := Row_Pos38;



--  BEGIN <Token(<WithSymbol Identifier>, ) (root of 'env_spec_action') at parser.lkt:219:39>

Token_Res55 := Row_Pos39;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res55));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
   then
       Token_Pos55 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos39 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos39,
             Expected_Token_Id => Lkt_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos55 := Row_Pos39 + 1;
   end if;
end;

--  END <Token(<WithSymbol Identifier>, ) (root of 'env_spec_action') at parser.lkt:219:39>




if Token_Pos55 /= No_Token_Index then

   Row_Pos39 := Token_Pos55;

else
   Row_Pos39 := No_Token_Index;
   goto Exit_Row39_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row39_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'env_spec_action') at ???>



if Row_Pos39 /= No_Token_Index then

   Transform_Res37 := Allocate_Ref_Id (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res37,
      Kind => Lkt_Ref_Id,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos38,
      Token_End_Index   => (if Row_Pos39 = Row_Pos38
                            then No_Token_Index
                            else Row_Pos39 - 1));

      
      Initialize_Fields_For_Ref_Id
        (Self => Transform_Res37);



elsif Row_Pos39 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags37);
end if;

--  END <Transform(<CompiledType BareRefId>) (root of 'env_spec_action') at parser.lkt:219:33>




if Row_Pos39 /= No_Token_Index then

   Row_Pos38 := Row_Pos39;

else
   Row_Pos38 := No_Token_Index;
   goto Exit_Row38_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'env_spec_action') at parser.lkt:219:52>

Token_Res56 := Row_Pos38;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res56));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos56 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos38 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos38,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos56 := Row_Pos38 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'env_spec_action') at parser.lkt:219:52>




if Token_Pos56 /= No_Token_Index then

   Row_Pos38 := Token_Pos56;

else
   Row_Pos38 := No_Token_Index;
   goto Exit_Row38_0;

end if;


--  BEGIN <Defer (for 'params') at parser.lkt:219:56>

Defer_Res64 :=
   Params_List_Parse0 (Parser, Row_Pos38);
Defer_Pos64 := Parser.Current_Pos;

--  END <Defer (for 'params') at parser.lkt:219:56>




if Defer_Pos64 /= No_Token_Index then

   Row_Pos38 := Defer_Pos64;

else
   Row_Pos38 := No_Token_Index;
   goto Exit_Row38_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'env_spec_action') at parser.lkt:219:63>

Token_Res57 := Row_Pos38;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res57));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos57 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos38 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos38,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos57 := Row_Pos38 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'env_spec_action') at parser.lkt:219:63>




if Token_Pos57 /= No_Token_Index then

   Row_Pos38 := Token_Pos57;

else
   Row_Pos38 := No_Token_Index;
   goto Exit_Row38_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row38_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'env_spec_action') at ???>



if Row_Pos38 /= No_Token_Index then

   Transform_Res38 := Allocate_Call_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res38,
      Kind => Lkt_Call_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos38 = Pos
                            then No_Token_Index
                            else Row_Pos38 - 1));

      
      Initialize_Fields_For_Call_Expr
        (Self => Transform_Res38,
         Base_Call_Expr_F_Name => Transform_Res37,
         Base_Call_Expr_F_Args => Defer_Res64);

         if Transform_Res37 /= null and then Is_Incomplete (Transform_Res37) then
            Transform_Res38.Last_Attempted_Child := 0;
         elsif Transform_Res37 /= null and then not Is_Ghost (Transform_Res37) then
            Transform_Res38.Last_Attempted_Child := -1;
         end if;
         if Defer_Res64 /= null and then Is_Incomplete (Defer_Res64) then
            Transform_Res38.Last_Attempted_Child := 0;
         elsif Defer_Res64 /= null and then not Is_Ghost (Defer_Res64) then
            Transform_Res38.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos38 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags38);
end if;

--  END <Transform(<CompiledType BareCallExpr>) (root of 'env_spec_action') at parser.lkt:219:24>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Env_Spec_Action_Transform_Parse1_Memo,
      Row_Pos38 /= No_Token_Index,
      Transform_Res38,
      Pos,
      Row_Pos38);


   Parser.Current_Pos := Row_Pos38;

   return Transform_Res38;
end Env_Spec_Action_Transform_Parse1;

   


function Env_Spec_Decl_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Env_Spec_Decl
is
   use Bare_Env_Spec_Decl_Memos;

      Row_Pos40 :
            Token_Index
               := No_Token_Index;
      Row_Pos41 :
            Token_Index
               := No_Token_Index;
      Token_Pos58 :
            Token_Index
               := No_Token_Index;
      Token_Res58 :
            Token_Index
               := No_Token_Index;
      Transform_Res39 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Transform_Diags39 :
            Ada.Containers.Count_Type;
      Token_Pos59 :
            Token_Index
               := No_Token_Index;
      Token_Res59 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos6 :
            Token_Index
               := No_Token_Index;
      Tmp_List6 :
            Free_Parse_List;
      Defer_Pos65 :
            Token_Index
               := No_Token_Index;
      Defer_Res65 :
            Bare_Call_Expr
               := No_Bare_Lkt_Node;
      List_Pos6 :
            Token_Index
               := No_Token_Index;
      List_Res6 :
            Bare_Call_Expr_List
               := No_Bare_Lkt_Node;
      Token_Pos60 :
            Token_Index
               := No_Token_Index;
      Token_Res60 :
            Token_Index
               := No_Token_Index;
      Transform_Res40 :
            Bare_Env_Spec_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags40 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Env_Spec_Decl_Transform_Parse1_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res40 := M.Instance;
      return Transform_Res40;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res40;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareEnvSpecDecl>) (root of 'env_spec_decl') at parser.lkt:220:22>

Transform_Diags40 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'env_spec_decl') at ???>

Row_Pos40 := Pos;



--  BEGIN <Transform(<CompiledType BareDefId>) (root of 'env_spec_decl') at parser.lkt:221:9>

Transform_Diags39 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'env_spec_decl') at ???>

Row_Pos41 := Row_Pos40;



--  BEGIN <Token(<WithSymbol Identifier>, env_spec) (root of 'env_spec_decl') at parser.lkt:221:15>

Token_Res58 := Row_Pos41;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res58));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Env_Spec)
   then
       Token_Pos58 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos41 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos41,
             Expected_Token_Id => Lkt_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos58 := Row_Pos41 + 1;
   end if;
end;

--  END <Token(<WithSymbol Identifier>, env_spec) (root of 'env_spec_decl') at parser.lkt:221:15>




if Token_Pos58 /= No_Token_Index then

   Row_Pos41 := Token_Pos58;

else
   Row_Pos41 := No_Token_Index;
   goto Exit_Row41_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row41_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'env_spec_decl') at ???>



if Row_Pos41 /= No_Token_Index then

   Transform_Res39 := Allocate_Def_Id (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res39,
      Kind => Lkt_Def_Id,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos40,
      Token_End_Index   => (if Row_Pos41 = Row_Pos40
                            then No_Token_Index
                            else Row_Pos41 - 1));

      
      Initialize_Fields_For_Def_Id
        (Self => Transform_Res39);



elsif Row_Pos41 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags39);
end if;

--  END <Transform(<CompiledType BareDefId>) (root of 'env_spec_decl') at parser.lkt:221:9>




if Row_Pos41 /= No_Token_Index then

   Row_Pos40 := Row_Pos41;

else
   Row_Pos40 := No_Token_Index;
   goto Exit_Row40_0;

end if;


--  BEGIN <Token(<WithText LBrace>, ) (root of 'env_spec_decl') at parser.lkt:221:40>

Token_Res59 := Row_Pos40;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res59));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos59 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos40 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos40,
             Expected_Token_Id => Lkt_L_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos59 := Row_Pos40 + 1;
   end if;
end;

--  END <Token(<WithText LBrace>, ) (root of 'env_spec_decl') at parser.lkt:221:40>




if Token_Pos59 /= No_Token_Index then

   Row_Pos40 := Token_Pos59;

else
   Row_Pos40 := No_Token_Index;
   goto Exit_Row40_0;

end if;


--  BEGIN <List (root of 'env_spec_decl') at parser.lkt:221:44>

    List_Pos6 := Row_Pos40;



Lst_Cpos6 := Row_Pos40;
Tmp_List6 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'env_spec_action') at parser.lkt:221:50>

Defer_Res65 :=
   Env_Spec_Action_Transform_Parse1 (Parser, Lst_Cpos6);
Defer_Pos65 := Parser.Current_Pos;

--  END <Defer (for 'env_spec_action') at parser.lkt:221:50>


   exit when Defer_Pos65 = No_Token_Index;

   List_Pos6 := Defer_Pos65;
   Lst_Cpos6 := List_Pos6;

   Tmp_List6.Nodes.Append (Defer_Res65);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List6.Nodes.Length;
begin
   List_Res6 := Allocate_Call_Expr_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos40;
      Token_End := (if Lst_Cpos6 = Row_Pos40
                    then Row_Pos40
                    else List_Pos6 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos40, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res6,
      Kind              => Lkt_Call_Expr_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res6,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List6.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res6.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List6);

--  END <List (root of 'env_spec_decl') at parser.lkt:221:44>




if List_Pos6 /= No_Token_Index then

   Row_Pos40 := List_Pos6;

else
   Row_Pos40 := No_Token_Index;
   goto Exit_Row40_0;

end if;


--  BEGIN <Token(<WithText RBrace>, ) (root of 'env_spec_decl') at parser.lkt:221:67>

Token_Res60 := Row_Pos40;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res60));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos60 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos40 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos40,
             Expected_Token_Id => Lkt_R_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos60 := Row_Pos40 + 1;
   end if;
end;

--  END <Token(<WithText RBrace>, ) (root of 'env_spec_decl') at parser.lkt:221:67>




if Token_Pos60 /= No_Token_Index then

   Row_Pos40 := Token_Pos60;

else
   Row_Pos40 := No_Token_Index;
   goto Exit_Row40_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row40_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'env_spec_decl') at ???>



if Row_Pos40 /= No_Token_Index then

   Transform_Res40 := Allocate_Env_Spec_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res40,
      Kind => Lkt_Env_Spec_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos40 = Pos
                            then No_Token_Index
                            else Row_Pos40 - 1));

      
      Initialize_Fields_For_Env_Spec_Decl
        (Self => Transform_Res40,
         Env_Spec_Decl_F_Syn_Name => Transform_Res39,
         Env_Spec_Decl_F_Actions => List_Res6);

         if Transform_Res39 /= null and then Is_Incomplete (Transform_Res39) then
            Transform_Res40.Last_Attempted_Child := 0;
         elsif Transform_Res39 /= null and then not Is_Ghost (Transform_Res39) then
            Transform_Res40.Last_Attempted_Child := -1;
         end if;
         if List_Res6 /= null and then Is_Incomplete (List_Res6) then
            Transform_Res40.Last_Attempted_Child := 0;
         elsif List_Res6 /= null and then not Is_Ghost (List_Res6) then
            Transform_Res40.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos40 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags40);
end if;

--  END <Transform(<CompiledType BareEnvSpecDecl>) (root of 'env_spec_decl') at parser.lkt:220:22>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Env_Spec_Decl_Transform_Parse1_Memo,
      Row_Pos40 /= No_Token_Index,
      Transform_Res40,
      Pos,
      Row_Pos40);


   Parser.Current_Pos := Row_Pos40;

   return Transform_Res40;
end Env_Spec_Decl_Transform_Parse1;

   


function Eq_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

      Row_Pos42 :
            Token_Index
               := No_Token_Index;
      Defer_Pos66 :
            Token_Index
               := No_Token_Index;
      Defer_Res66 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Row_Pos43 :
            Token_Index
               := No_Token_Index;
      Token_Pos61 :
            Token_Index
               := No_Token_Index;
      Token_Res61 :
            Token_Index
               := No_Token_Index;
      Transform_Res41 :
            Bare_Op_Lte
               := No_Bare_Lkt_Node;
      Transform_Diags41 :
            Ada.Containers.Count_Type;
      Row_Pos44 :
            Token_Index
               := No_Token_Index;
      Token_Pos62 :
            Token_Index
               := No_Token_Index;
      Token_Res62 :
            Token_Index
               := No_Token_Index;
      Transform_Res42 :
            Bare_Op_Lt
               := No_Bare_Lkt_Node;
      Transform_Diags42 :
            Ada.Containers.Count_Type;
      Row_Pos45 :
            Token_Index
               := No_Token_Index;
      Token_Pos63 :
            Token_Index
               := No_Token_Index;
      Token_Res63 :
            Token_Index
               := No_Token_Index;
      Transform_Res43 :
            Bare_Op_Gte
               := No_Bare_Lkt_Node;
      Transform_Diags43 :
            Ada.Containers.Count_Type;
      Row_Pos46 :
            Token_Index
               := No_Token_Index;
      Token_Pos64 :
            Token_Index
               := No_Token_Index;
      Token_Res64 :
            Token_Index
               := No_Token_Index;
      Transform_Res44 :
            Bare_Op_Gt
               := No_Bare_Lkt_Node;
      Transform_Diags44 :
            Ada.Containers.Count_Type;
      Row_Pos47 :
            Token_Index
               := No_Token_Index;
      Token_Pos65 :
            Token_Index
               := No_Token_Index;
      Token_Res65 :
            Token_Index
               := No_Token_Index;
      Transform_Res45 :
            Bare_Op_Eq
               := No_Bare_Lkt_Node;
      Transform_Diags45 :
            Ada.Containers.Count_Type;
      Row_Pos48 :
            Token_Index
               := No_Token_Index;
      Token_Pos66 :
            Token_Index
               := No_Token_Index;
      Token_Res66 :
            Token_Index
               := No_Token_Index;
      Transform_Res46 :
            Bare_Op_Ne
               := No_Bare_Lkt_Node;
      Transform_Diags46 :
            Ada.Containers.Count_Type;
      Or_Pos11 :
            Token_Index
               := No_Token_Index;
      Or_Res11 :
            Bare_Op
               := No_Bare_Lkt_Node;
      Defer_Pos67 :
            Token_Index
               := No_Token_Index;
      Defer_Res67 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res47 :
            Bare_Bin_Op
               := No_Bare_Lkt_Node;
      Transform_Diags47 :
            Ada.Containers.Count_Type;
      Defer_Pos68 :
            Token_Index
               := No_Token_Index;
      Defer_Res68 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Or_Pos12 :
            Token_Index
               := No_Token_Index;
      Or_Res12 :
            Bare_Expr
               := No_Bare_Lkt_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Expr := No_Bare_Lkt_Node;

   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Eq_Or_Parse1_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res12 := M.Instance;
      return Or_Res12;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res12;
   end if;

       Set (PP.Eq_Or_Parse1_Memo, False, Or_Res12, Pos, Mem_Pos);

       <<Try_Again>>



   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'eq') at parser.lkt:242:11>

Or_Pos12 := No_Token_Index;
Or_Res12 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareBinOp>) (root of 'eq') at parser.lkt:243:11>

Transform_Diags47 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'eq') at ???>

Row_Pos42 := Pos;



--  BEGIN <Defer (for 'eq') at parser.lkt:244:13>

Defer_Res66 :=
   Eq_Or_Parse1 (Parser, Row_Pos42);
Defer_Pos66 := Parser.Current_Pos;

--  END <Defer (for 'eq') at parser.lkt:244:13>




if Defer_Pos66 /= No_Token_Index then

   Row_Pos42 := Defer_Pos66;

else
   Row_Pos42 := No_Token_Index;
   goto Exit_Row42_0;

end if;


--  BEGIN <Or (root of 'eq') at parser.lkt:245:13>

Or_Pos11 := No_Token_Index;
Or_Res11 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareOpLte>) (root of 'eq') at parser.lkt:246:19>

Transform_Diags41 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'eq') at parser.lkt:246:19>

Row_Pos43 := Row_Pos42;



--  BEGIN <Token(<WithText LTE>, ) (root of 'eq') at parser.lkt:246:26>

Token_Res61 := Row_Pos43;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res61));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_T_E)
   then
       Token_Pos61 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos43 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos43,
             Expected_Token_Id => Lkt_L_T_E,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos61 := Row_Pos43 + 1;
   end if;
end;

--  END <Token(<WithText LTE>, ) (root of 'eq') at parser.lkt:246:26>




if Token_Pos61 /= No_Token_Index then

   Row_Pos43 := Token_Pos61;

else
   Row_Pos43 := No_Token_Index;
   goto Exit_Row43_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row43_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'eq') at parser.lkt:246:19>



if Row_Pos43 /= No_Token_Index then

   Transform_Res41 := Allocate_Op_Lte (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res41,
      Kind => Lkt_Op_Lte,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos42,
      Token_End_Index   => (if Row_Pos43 = Row_Pos42
                            then No_Token_Index
                            else Row_Pos43 - 1));




elsif Row_Pos43 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags41);
end if;

--  END <Transform(<CompiledType BareOpLte>) (root of 'eq') at parser.lkt:246:19>

    if Row_Pos43 /= No_Token_Index then
        Or_Pos11 := Row_Pos43;
        Or_Res11 := Transform_Res41;
        goto Exit_Or12;
    end if;
    
--  BEGIN <Transform(<CompiledType BareOpLt>) (root of 'eq') at parser.lkt:247:19>

Transform_Diags42 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'eq') at parser.lkt:247:19>

Row_Pos44 := Row_Pos42;



--  BEGIN <Token(<WithText LT>, ) (root of 'eq') at parser.lkt:247:25>

Token_Res62 := Row_Pos44;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res62));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_T)
   then
       Token_Pos62 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos44 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos44,
             Expected_Token_Id => Lkt_L_T,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos62 := Row_Pos44 + 1;
   end if;
end;

--  END <Token(<WithText LT>, ) (root of 'eq') at parser.lkt:247:25>




if Token_Pos62 /= No_Token_Index then

   Row_Pos44 := Token_Pos62;

else
   Row_Pos44 := No_Token_Index;
   goto Exit_Row44_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row44_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'eq') at parser.lkt:247:19>



if Row_Pos44 /= No_Token_Index then

   Transform_Res42 := Allocate_Op_Lt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res42,
      Kind => Lkt_Op_Lt,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos42,
      Token_End_Index   => (if Row_Pos44 = Row_Pos42
                            then No_Token_Index
                            else Row_Pos44 - 1));




elsif Row_Pos44 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags42);
end if;

--  END <Transform(<CompiledType BareOpLt>) (root of 'eq') at parser.lkt:247:19>

    if Row_Pos44 /= No_Token_Index then
        Or_Pos11 := Row_Pos44;
        Or_Res11 := Transform_Res42;
        goto Exit_Or12;
    end if;
    
--  BEGIN <Transform(<CompiledType BareOpGte>) (root of 'eq') at parser.lkt:248:19>

Transform_Diags43 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'eq') at parser.lkt:248:19>

Row_Pos45 := Row_Pos42;



--  BEGIN <Token(<WithText GTE>, ) (root of 'eq') at parser.lkt:248:26>

Token_Res63 := Row_Pos45;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res63));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_G_T_E)
   then
       Token_Pos63 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos45 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos45,
             Expected_Token_Id => Lkt_G_T_E,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos63 := Row_Pos45 + 1;
   end if;
end;

--  END <Token(<WithText GTE>, ) (root of 'eq') at parser.lkt:248:26>




if Token_Pos63 /= No_Token_Index then

   Row_Pos45 := Token_Pos63;

else
   Row_Pos45 := No_Token_Index;
   goto Exit_Row45_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row45_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'eq') at parser.lkt:248:19>



if Row_Pos45 /= No_Token_Index then

   Transform_Res43 := Allocate_Op_Gte (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res43,
      Kind => Lkt_Op_Gte,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos42,
      Token_End_Index   => (if Row_Pos45 = Row_Pos42
                            then No_Token_Index
                            else Row_Pos45 - 1));




elsif Row_Pos45 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags43);
end if;

--  END <Transform(<CompiledType BareOpGte>) (root of 'eq') at parser.lkt:248:19>

    if Row_Pos45 /= No_Token_Index then
        Or_Pos11 := Row_Pos45;
        Or_Res11 := Transform_Res43;
        goto Exit_Or12;
    end if;
    
--  BEGIN <Transform(<CompiledType BareOpGt>) (root of 'eq') at parser.lkt:249:19>

Transform_Diags44 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'eq') at parser.lkt:249:19>

Row_Pos46 := Row_Pos42;



--  BEGIN <Token(<WithText GT>, ) (root of 'eq') at parser.lkt:249:25>

Token_Res64 := Row_Pos46;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res64));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_G_T)
   then
       Token_Pos64 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos46 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos46,
             Expected_Token_Id => Lkt_G_T,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos64 := Row_Pos46 + 1;
   end if;
end;

--  END <Token(<WithText GT>, ) (root of 'eq') at parser.lkt:249:25>




if Token_Pos64 /= No_Token_Index then

   Row_Pos46 := Token_Pos64;

else
   Row_Pos46 := No_Token_Index;
   goto Exit_Row46_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row46_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'eq') at parser.lkt:249:19>



if Row_Pos46 /= No_Token_Index then

   Transform_Res44 := Allocate_Op_Gt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res44,
      Kind => Lkt_Op_Gt,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos42,
      Token_End_Index   => (if Row_Pos46 = Row_Pos42
                            then No_Token_Index
                            else Row_Pos46 - 1));




elsif Row_Pos46 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags44);
end if;

--  END <Transform(<CompiledType BareOpGt>) (root of 'eq') at parser.lkt:249:19>

    if Row_Pos46 /= No_Token_Index then
        Or_Pos11 := Row_Pos46;
        Or_Res11 := Transform_Res44;
        goto Exit_Or12;
    end if;
    
--  BEGIN <Transform(<CompiledType BareOpEq>) (root of 'eq') at parser.lkt:250:19>

Transform_Diags45 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'eq') at parser.lkt:250:19>

Row_Pos47 := Row_Pos42;



--  BEGIN <Token(<WithText EQ>, ) (root of 'eq') at parser.lkt:250:25>

Token_Res65 := Row_Pos47;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res65));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_E_Q)
   then
       Token_Pos65 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos47 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos47,
             Expected_Token_Id => Lkt_E_Q,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos65 := Row_Pos47 + 1;
   end if;
end;

--  END <Token(<WithText EQ>, ) (root of 'eq') at parser.lkt:250:25>




if Token_Pos65 /= No_Token_Index then

   Row_Pos47 := Token_Pos65;

else
   Row_Pos47 := No_Token_Index;
   goto Exit_Row47_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row47_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'eq') at parser.lkt:250:19>



if Row_Pos47 /= No_Token_Index then

   Transform_Res45 := Allocate_Op_Eq (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res45,
      Kind => Lkt_Op_Eq,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos42,
      Token_End_Index   => (if Row_Pos47 = Row_Pos42
                            then No_Token_Index
                            else Row_Pos47 - 1));




elsif Row_Pos47 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags45);
end if;

--  END <Transform(<CompiledType BareOpEq>) (root of 'eq') at parser.lkt:250:19>

    if Row_Pos47 /= No_Token_Index then
        Or_Pos11 := Row_Pos47;
        Or_Res11 := Transform_Res45;
        goto Exit_Or12;
    end if;
    
--  BEGIN <Transform(<CompiledType BareOpNe>) (root of 'eq') at parser.lkt:251:19>

Transform_Diags46 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'eq') at parser.lkt:251:19>

Row_Pos48 := Row_Pos42;



--  BEGIN <Token(<WithText NE>, ) (root of 'eq') at parser.lkt:251:25>

Token_Res66 := Row_Pos48;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res66));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_N_E)
   then
       Token_Pos66 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos48 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos48,
             Expected_Token_Id => Lkt_N_E,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos66 := Row_Pos48 + 1;
   end if;
end;

--  END <Token(<WithText NE>, ) (root of 'eq') at parser.lkt:251:25>




if Token_Pos66 /= No_Token_Index then

   Row_Pos48 := Token_Pos66;

else
   Row_Pos48 := No_Token_Index;
   goto Exit_Row48_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row48_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'eq') at parser.lkt:251:19>



if Row_Pos48 /= No_Token_Index then

   Transform_Res46 := Allocate_Op_Ne (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res46,
      Kind => Lkt_Op_Ne,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos42,
      Token_End_Index   => (if Row_Pos48 = Row_Pos42
                            then No_Token_Index
                            else Row_Pos48 - 1));




elsif Row_Pos48 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags46);
end if;

--  END <Transform(<CompiledType BareOpNe>) (root of 'eq') at parser.lkt:251:19>

    if Row_Pos48 /= No_Token_Index then
        Or_Pos11 := Row_Pos48;
        Or_Res11 := Transform_Res46;
        goto Exit_Or12;
    end if;
<<Exit_Or12>>

--  END <Or (root of 'eq') at parser.lkt:245:13>




if Or_Pos11 /= No_Token_Index then

   Row_Pos42 := Or_Pos11;

else
   Row_Pos42 := No_Token_Index;
   goto Exit_Row42_0;

end if;


--  BEGIN <Defer (for 'arith_1') at parser.lkt:253:13>

Defer_Res67 :=
   Arith_1_Or_Parse1 (Parser, Row_Pos42);
Defer_Pos67 := Parser.Current_Pos;

--  END <Defer (for 'arith_1') at parser.lkt:253:13>




if Defer_Pos67 /= No_Token_Index then

   Row_Pos42 := Defer_Pos67;

else
   Row_Pos42 := No_Token_Index;
   goto Exit_Row42_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row42_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'eq') at ???>



if Row_Pos42 /= No_Token_Index then

   Transform_Res47 := Allocate_Bin_Op (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res47,
      Kind => Lkt_Bin_Op,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos42 = Pos
                            then No_Token_Index
                            else Row_Pos42 - 1));

      
      Initialize_Fields_For_Bin_Op
        (Self => Transform_Res47,
         Bin_Op_F_Left => Defer_Res66,
         Bin_Op_F_Op => Or_Res11,
         Bin_Op_F_Right => Defer_Res67);

         if Defer_Res66 /= null and then Is_Incomplete (Defer_Res66) then
            Transform_Res47.Last_Attempted_Child := 0;
         elsif Defer_Res66 /= null and then not Is_Ghost (Defer_Res66) then
            Transform_Res47.Last_Attempted_Child := -1;
         end if;
         if Or_Res11 /= null and then Is_Incomplete (Or_Res11) then
            Transform_Res47.Last_Attempted_Child := 0;
         elsif Or_Res11 /= null and then not Is_Ghost (Or_Res11) then
            Transform_Res47.Last_Attempted_Child := -1;
         end if;
         if Defer_Res67 /= null and then Is_Incomplete (Defer_Res67) then
            Transform_Res47.Last_Attempted_Child := 0;
         elsif Defer_Res67 /= null and then not Is_Ghost (Defer_Res67) then
            Transform_Res47.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos42 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags47);
end if;

--  END <Transform(<CompiledType BareBinOp>) (root of 'eq') at parser.lkt:243:11>

    if Row_Pos42 /= No_Token_Index then
        Or_Pos12 := Row_Pos42;
        Or_Res12 := Transform_Res47;
        goto Exit_Or11;
    end if;
    
--  BEGIN <Defer (for 'arith_1') at parser.lkt:255:11>

Defer_Res68 :=
   Arith_1_Or_Parse1 (Parser, Pos);
Defer_Pos68 := Parser.Current_Pos;

--  END <Defer (for 'arith_1') at parser.lkt:255:11>

    if Defer_Pos68 /= No_Token_Index then
        Or_Pos12 := Defer_Pos68;
        Or_Res12 := Defer_Res68;
        goto Exit_Or11;
    end if;
<<Exit_Or11>>

--  END <Or (root of 'eq') at parser.lkt:242:11>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos12 > Mem_Pos then
         Mem_Pos := Or_Pos12;
         Mem_Res := Or_Res12;
         Set
           (PP.Eq_Or_Parse1_Memo,
            Or_Pos12 /= No_Token_Index,
            Or_Res12,
            Pos,
            Or_Pos12);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res12 := Mem_Res;
         Or_Pos12 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (PP.Eq_Or_Parse1_Memo,
      Or_Pos12 /= No_Token_Index,
      Or_Res12,
      Pos,
      Or_Pos12);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos12;

   return Or_Res12;
end Eq_Or_Parse1;

   


function Expr_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

      Row_Pos49 :
            Token_Index
               := No_Token_Index;
      Defer_Pos69 :
            Token_Index
               := No_Token_Index;
      Defer_Res69 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Row_Pos50 :
            Token_Index
               := No_Token_Index;
      Token_Pos67 :
            Token_Index
               := No_Token_Index;
      Token_Res67 :
            Token_Index
               := No_Token_Index;
      Token_Pos68 :
            Token_Index
               := No_Token_Index;
      Token_Res68 :
            Token_Index
               := No_Token_Index;
      Transform_Res48 :
            Bare_Op_Or_Int
               := No_Bare_Lkt_Node;
      Transform_Diags48 :
            Ada.Containers.Count_Type;
      Row_Pos51 :
            Token_Index
               := No_Token_Index;
      Token_Pos69 :
            Token_Index
               := No_Token_Index;
      Token_Res69 :
            Token_Index
               := No_Token_Index;
      Transform_Res49 :
            Bare_Op_Or
               := No_Bare_Lkt_Node;
      Transform_Diags49 :
            Ada.Containers.Count_Type;
      Row_Pos52 :
            Token_Index
               := No_Token_Index;
      Token_Pos70 :
            Token_Index
               := No_Token_Index;
      Token_Res70 :
            Token_Index
               := No_Token_Index;
      Transform_Res50 :
            Bare_Op_And
               := No_Bare_Lkt_Node;
      Transform_Diags50 :
            Ada.Containers.Count_Type;
      Row_Pos53 :
            Token_Index
               := No_Token_Index;
      Token_Pos71 :
            Token_Index
               := No_Token_Index;
      Token_Res71 :
            Token_Index
               := No_Token_Index;
      Token_Pos72 :
            Token_Index
               := No_Token_Index;
      Token_Res72 :
            Token_Index
               := No_Token_Index;
      Transform_Res51 :
            Bare_Op_Logic_And
               := No_Bare_Lkt_Node;
      Transform_Diags51 :
            Ada.Containers.Count_Type;
      Row_Pos54 :
            Token_Index
               := No_Token_Index;
      Token_Pos73 :
            Token_Index
               := No_Token_Index;
      Token_Res73 :
            Token_Index
               := No_Token_Index;
      Token_Pos74 :
            Token_Index
               := No_Token_Index;
      Token_Res74 :
            Token_Index
               := No_Token_Index;
      Transform_Res52 :
            Bare_Op_Logic_Or
               := No_Bare_Lkt_Node;
      Transform_Diags52 :
            Ada.Containers.Count_Type;
      Or_Pos13 :
            Token_Index
               := No_Token_Index;
      Or_Res13 :
            Bare_Op
               := No_Bare_Lkt_Node;
      Defer_Pos70 :
            Token_Index
               := No_Token_Index;
      Defer_Res70 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res53 :
            Bare_Bin_Op
               := No_Bare_Lkt_Node;
      Transform_Diags53 :
            Ada.Containers.Count_Type;
      Defer_Pos71 :
            Token_Index
               := No_Token_Index;
      Defer_Res71 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Or_Pos14 :
            Token_Index
               := No_Token_Index;
      Or_Res14 :
            Bare_Expr
               := No_Bare_Lkt_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Expr := No_Bare_Lkt_Node;

   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Expr_Or_Parse1_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res14 := M.Instance;
      return Or_Res14;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res14;
   end if;

       Set (PP.Expr_Or_Parse1_Memo, False, Or_Res14, Pos, Mem_Pos);

       <<Try_Again>>



   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'expr') at parser.lkt:227:13>

Or_Pos14 := No_Token_Index;
Or_Res14 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareBinOp>) (root of 'expr') at parser.lkt:228:11>

Transform_Diags53 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'expr') at ???>

Row_Pos49 := Pos;



--  BEGIN <Defer (for 'expr') at parser.lkt:229:13>

Defer_Res69 :=
   Expr_Or_Parse1 (Parser, Row_Pos49);
Defer_Pos69 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:229:13>




if Defer_Pos69 /= No_Token_Index then

   Row_Pos49 := Defer_Pos69;

else
   Row_Pos49 := No_Token_Index;
   goto Exit_Row49_0;

end if;


--  BEGIN <Or (root of 'expr') at parser.lkt:230:13>

Or_Pos13 := No_Token_Index;
Or_Res13 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareOpOrInt>) (root of 'expr') at parser.lkt:231:19>

Transform_Diags48 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'expr') at parser.lkt:231:19>

Row_Pos50 := Row_Pos49;



--  BEGIN <Token(<WithText OrKw>, ) (root of 'expr') at parser.lkt:231:28>

Token_Res67 := Row_Pos50;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res67));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Or_Kw)
   then
       Token_Pos67 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos50 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos50,
             Expected_Token_Id => Lkt_Or_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos67 := Row_Pos50 + 1;
   end if;
end;

--  END <Token(<WithText OrKw>, ) (root of 'expr') at parser.lkt:231:28>




if Token_Pos67 /= No_Token_Index then

   Row_Pos50 := Token_Pos67;

else
   Row_Pos50 := No_Token_Index;
   goto Exit_Row50_0;

end if;


--  BEGIN <Token(<WithText IntMark>, ) (root of 'expr') at parser.lkt:231:33>

Token_Res68 := Row_Pos50;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res68));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Int_Mark)
   then
       Token_Pos68 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos50 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos50,
             Expected_Token_Id => Lkt_Int_Mark,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos68 := Row_Pos50 + 1;
   end if;
end;

--  END <Token(<WithText IntMark>, ) (root of 'expr') at parser.lkt:231:33>




if Token_Pos68 /= No_Token_Index then

   Row_Pos50 := Token_Pos68;

else
   Row_Pos50 := No_Token_Index;
   goto Exit_Row50_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row50_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'expr') at parser.lkt:231:19>



if Row_Pos50 /= No_Token_Index then

   Transform_Res48 := Allocate_Op_Or_Int (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res48,
      Kind => Lkt_Op_Or_Int,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos49,
      Token_End_Index   => (if Row_Pos50 = Row_Pos49
                            then No_Token_Index
                            else Row_Pos50 - 1));




elsif Row_Pos50 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags48);
end if;

--  END <Transform(<CompiledType BareOpOrInt>) (root of 'expr') at parser.lkt:231:19>

    if Row_Pos50 /= No_Token_Index then
        Or_Pos13 := Row_Pos50;
        Or_Res13 := Transform_Res48;
        goto Exit_Or14;
    end if;
    
--  BEGIN <Transform(<CompiledType BareOpOr>) (root of 'expr') at parser.lkt:232:19>

Transform_Diags49 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'expr') at parser.lkt:232:19>

Row_Pos51 := Row_Pos49;



--  BEGIN <Token(<WithText OrKw>, ) (root of 'expr') at parser.lkt:232:25>

Token_Res69 := Row_Pos51;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res69));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Or_Kw)
   then
       Token_Pos69 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos51 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos51,
             Expected_Token_Id => Lkt_Or_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos69 := Row_Pos51 + 1;
   end if;
end;

--  END <Token(<WithText OrKw>, ) (root of 'expr') at parser.lkt:232:25>




if Token_Pos69 /= No_Token_Index then

   Row_Pos51 := Token_Pos69;

else
   Row_Pos51 := No_Token_Index;
   goto Exit_Row51_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row51_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'expr') at parser.lkt:232:19>



if Row_Pos51 /= No_Token_Index then

   Transform_Res49 := Allocate_Op_Or (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res49,
      Kind => Lkt_Op_Or,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos49,
      Token_End_Index   => (if Row_Pos51 = Row_Pos49
                            then No_Token_Index
                            else Row_Pos51 - 1));




elsif Row_Pos51 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags49);
end if;

--  END <Transform(<CompiledType BareOpOr>) (root of 'expr') at parser.lkt:232:19>

    if Row_Pos51 /= No_Token_Index then
        Or_Pos13 := Row_Pos51;
        Or_Res13 := Transform_Res49;
        goto Exit_Or14;
    end if;
    
--  BEGIN <Transform(<CompiledType BareOpAnd>) (root of 'expr') at parser.lkt:233:19>

Transform_Diags50 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'expr') at parser.lkt:233:19>

Row_Pos52 := Row_Pos49;



--  BEGIN <Token(<WithText AndKw>, ) (root of 'expr') at parser.lkt:233:26>

Token_Res70 := Row_Pos52;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res70));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_And_Kw)
   then
       Token_Pos70 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos52 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos52,
             Expected_Token_Id => Lkt_And_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos70 := Row_Pos52 + 1;
   end if;
end;

--  END <Token(<WithText AndKw>, ) (root of 'expr') at parser.lkt:233:26>




if Token_Pos70 /= No_Token_Index then

   Row_Pos52 := Token_Pos70;

else
   Row_Pos52 := No_Token_Index;
   goto Exit_Row52_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row52_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'expr') at parser.lkt:233:19>



if Row_Pos52 /= No_Token_Index then

   Transform_Res50 := Allocate_Op_And (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res50,
      Kind => Lkt_Op_And,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos49,
      Token_End_Index   => (if Row_Pos52 = Row_Pos49
                            then No_Token_Index
                            else Row_Pos52 - 1));




elsif Row_Pos52 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags50);
end if;

--  END <Transform(<CompiledType BareOpAnd>) (root of 'expr') at parser.lkt:233:19>

    if Row_Pos52 /= No_Token_Index then
        Or_Pos13 := Row_Pos52;
        Or_Res13 := Transform_Res50;
        goto Exit_Or14;
    end if;
    
--  BEGIN <Transform(<CompiledType BareOpLogicAnd>) (root of 'expr') at parser.lkt:234:19>

Transform_Diags51 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'expr') at parser.lkt:234:19>

Row_Pos53 := Row_Pos49;



--  BEGIN <Token(<WithText Percent>, ) (root of 'expr') at parser.lkt:234:31>

Token_Res71 := Row_Pos53;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res71));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Percent)
   then
       Token_Pos71 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos53 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos53,
             Expected_Token_Id => Lkt_Percent,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos71 := Row_Pos53 + 1;
   end if;
end;

--  END <Token(<WithText Percent>, ) (root of 'expr') at parser.lkt:234:31>




if Token_Pos71 /= No_Token_Index then

   Row_Pos53 := Token_Pos71;

else
   Row_Pos53 := No_Token_Index;
   goto Exit_Row53_0;

end if;


--  BEGIN <Token(<WithText AndKw>, ) (root of 'expr') at parser.lkt:234:35>

Token_Res72 := Row_Pos53;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res72));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_And_Kw)
   then
       Token_Pos72 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos53 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos53,
             Expected_Token_Id => Lkt_And_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos72 := Row_Pos53 + 1;
   end if;
end;

--  END <Token(<WithText AndKw>, ) (root of 'expr') at parser.lkt:234:35>




if Token_Pos72 /= No_Token_Index then

   Row_Pos53 := Token_Pos72;

else
   Row_Pos53 := No_Token_Index;
   goto Exit_Row53_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row53_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'expr') at parser.lkt:234:19>



if Row_Pos53 /= No_Token_Index then

   Transform_Res51 := Allocate_Op_Logic_And (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res51,
      Kind => Lkt_Op_Logic_And,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos49,
      Token_End_Index   => (if Row_Pos53 = Row_Pos49
                            then No_Token_Index
                            else Row_Pos53 - 1));




elsif Row_Pos53 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags51);
end if;

--  END <Transform(<CompiledType BareOpLogicAnd>) (root of 'expr') at parser.lkt:234:19>

    if Row_Pos53 /= No_Token_Index then
        Or_Pos13 := Row_Pos53;
        Or_Res13 := Transform_Res51;
        goto Exit_Or14;
    end if;
    
--  BEGIN <Transform(<CompiledType BareOpLogicOr>) (root of 'expr') at parser.lkt:235:19>

Transform_Diags52 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'expr') at parser.lkt:235:19>

Row_Pos54 := Row_Pos49;



--  BEGIN <Token(<WithText Percent>, ) (root of 'expr') at parser.lkt:235:30>

Token_Res73 := Row_Pos54;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res73));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Percent)
   then
       Token_Pos73 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos54 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos54,
             Expected_Token_Id => Lkt_Percent,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos73 := Row_Pos54 + 1;
   end if;
end;

--  END <Token(<WithText Percent>, ) (root of 'expr') at parser.lkt:235:30>




if Token_Pos73 /= No_Token_Index then

   Row_Pos54 := Token_Pos73;

else
   Row_Pos54 := No_Token_Index;
   goto Exit_Row54_0;

end if;


--  BEGIN <Token(<WithText OrKw>, ) (root of 'expr') at parser.lkt:235:34>

Token_Res74 := Row_Pos54;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res74));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Or_Kw)
   then
       Token_Pos74 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos54 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos54,
             Expected_Token_Id => Lkt_Or_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos74 := Row_Pos54 + 1;
   end if;
end;

--  END <Token(<WithText OrKw>, ) (root of 'expr') at parser.lkt:235:34>




if Token_Pos74 /= No_Token_Index then

   Row_Pos54 := Token_Pos74;

else
   Row_Pos54 := No_Token_Index;
   goto Exit_Row54_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row54_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'expr') at parser.lkt:235:19>



if Row_Pos54 /= No_Token_Index then

   Transform_Res52 := Allocate_Op_Logic_Or (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res52,
      Kind => Lkt_Op_Logic_Or,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos49,
      Token_End_Index   => (if Row_Pos54 = Row_Pos49
                            then No_Token_Index
                            else Row_Pos54 - 1));




elsif Row_Pos54 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags52);
end if;

--  END <Transform(<CompiledType BareOpLogicOr>) (root of 'expr') at parser.lkt:235:19>

    if Row_Pos54 /= No_Token_Index then
        Or_Pos13 := Row_Pos54;
        Or_Res13 := Transform_Res52;
        goto Exit_Or14;
    end if;
<<Exit_Or14>>

--  END <Or (root of 'expr') at parser.lkt:230:13>




if Or_Pos13 /= No_Token_Index then

   Row_Pos49 := Or_Pos13;

else
   Row_Pos49 := No_Token_Index;
   goto Exit_Row49_0;

end if;


--  BEGIN <Defer (for 'rel') at parser.lkt:237:13>

Defer_Res70 :=
   Rel_Or_Parse0 (Parser, Row_Pos49);
Defer_Pos70 := Parser.Current_Pos;

--  END <Defer (for 'rel') at parser.lkt:237:13>




if Defer_Pos70 /= No_Token_Index then

   Row_Pos49 := Defer_Pos70;

else
   Row_Pos49 := No_Token_Index;
   goto Exit_Row49_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row49_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'expr') at ???>



if Row_Pos49 /= No_Token_Index then

   Transform_Res53 := Allocate_Bin_Op (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res53,
      Kind => Lkt_Bin_Op,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos49 = Pos
                            then No_Token_Index
                            else Row_Pos49 - 1));

      
      Initialize_Fields_For_Bin_Op
        (Self => Transform_Res53,
         Bin_Op_F_Left => Defer_Res69,
         Bin_Op_F_Op => Or_Res13,
         Bin_Op_F_Right => Defer_Res70);

         if Defer_Res69 /= null and then Is_Incomplete (Defer_Res69) then
            Transform_Res53.Last_Attempted_Child := 0;
         elsif Defer_Res69 /= null and then not Is_Ghost (Defer_Res69) then
            Transform_Res53.Last_Attempted_Child := -1;
         end if;
         if Or_Res13 /= null and then Is_Incomplete (Or_Res13) then
            Transform_Res53.Last_Attempted_Child := 0;
         elsif Or_Res13 /= null and then not Is_Ghost (Or_Res13) then
            Transform_Res53.Last_Attempted_Child := -1;
         end if;
         if Defer_Res70 /= null and then Is_Incomplete (Defer_Res70) then
            Transform_Res53.Last_Attempted_Child := 0;
         elsif Defer_Res70 /= null and then not Is_Ghost (Defer_Res70) then
            Transform_Res53.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos49 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags53);
end if;

--  END <Transform(<CompiledType BareBinOp>) (root of 'expr') at parser.lkt:228:11>

    if Row_Pos49 /= No_Token_Index then
        Or_Pos14 := Row_Pos49;
        Or_Res14 := Transform_Res53;
        goto Exit_Or13;
    end if;
    
--  BEGIN <Defer (for 'rel') at parser.lkt:239:11>

Defer_Res71 :=
   Rel_Or_Parse0 (Parser, Pos);
Defer_Pos71 := Parser.Current_Pos;

--  END <Defer (for 'rel') at parser.lkt:239:11>

    if Defer_Pos71 /= No_Token_Index then
        Or_Pos14 := Defer_Pos71;
        Or_Res14 := Defer_Res71;
        goto Exit_Or13;
    end if;
<<Exit_Or13>>

--  END <Or (root of 'expr') at parser.lkt:227:13>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos14 > Mem_Pos then
         Mem_Pos := Or_Pos14;
         Mem_Res := Or_Res14;
         Set
           (PP.Expr_Or_Parse1_Memo,
            Or_Pos14 /= No_Token_Index,
            Or_Res14,
            Pos,
            Or_Pos14);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res14 := Mem_Res;
         Or_Pos14 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (PP.Expr_Or_Parse1_Memo,
      Or_Pos14 /= No_Token_Index,
      Or_Res14,
      Pos,
      Or_Pos14);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos14;

   return Or_Res14;
end Expr_Or_Parse1;

   


function Field_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Field_Decl
is
   use Bare_Field_Decl_Memos;

      Row_Pos55 :
            Token_Index
               := No_Token_Index;
      Defer_Pos72 :
            Token_Index
               := No_Token_Index;
      Defer_Res72 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Token_Pos75 :
            Token_Index
               := No_Token_Index;
      Token_Res75 :
            Token_Index
               := No_Token_Index;
      Defer_Pos73 :
            Token_Index
               := No_Token_Index;
      Defer_Res73 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Row_Pos56 :
            Token_Index
               := No_Token_Index;
      Token_Pos76 :
            Token_Index
               := No_Token_Index;
      Token_Res76 :
            Token_Index
               := No_Token_Index;
      Defer_Pos74 :
            Token_Index
               := No_Token_Index;
      Defer_Res74 :
            Bare_Dot_Expr
               := No_Bare_Lkt_Node;
      Row_Pos57 :
            Token_Index
               := No_Token_Index;
      Token_Pos77 :
            Token_Index
               := No_Token_Index;
      Token_Res77 :
            Token_Index
               := No_Token_Index;
      Defer_Pos75 :
            Token_Index
               := No_Token_Index;
      Defer_Res75 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res54 :
            Bare_Field_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags54 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Field_Decl_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res54 := M.Instance;
      return Transform_Res54;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res54;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareFieldDecl>) (root of 'field_decl') at parser.lkt:186:19>

Transform_Diags54 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'field_decl') at ???>

Row_Pos55 := Pos;



--  BEGIN <Defer (for 'def_id') at parser.lkt:187:9>

Defer_Res72 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos55);
Defer_Pos72 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:187:9>




if Defer_Pos72 /= No_Token_Index then

   Row_Pos55 := Defer_Pos72;

else
   Row_Pos55 := No_Token_Index;
   goto Exit_Row55_0;

end if;


--  BEGIN <Token(<WithText Colon>, ) (root of 'field_decl') at parser.lkt:188:9>

Token_Res75 := Row_Pos55;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res75));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos75 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos55 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos55,
             Expected_Token_Id => Lkt_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos75 := Row_Pos55 + 1;
   end if;
end;

--  END <Token(<WithText Colon>, ) (root of 'field_decl') at parser.lkt:188:9>




if Token_Pos75 /= No_Token_Index then

   Row_Pos55 := Token_Pos75;

else
   Row_Pos55 := No_Token_Index;
   goto Exit_Row55_0;

end if;


--  BEGIN <Defer (for 'type_ref') at parser.lkt:189:9>

Defer_Res73 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos55);
Defer_Pos73 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:189:9>




if Defer_Pos73 /= No_Token_Index then

   Row_Pos55 := Defer_Pos73;

else
   Row_Pos55 := No_Token_Index;
   goto Exit_Row55_0;

end if;


--  BEGIN <Opt (root of 'field_decl') at parser.lkt:190:9>












--  BEGIN <_Extract (root of 'field_decl') at parser.lkt:190:10>

--  BEGIN <_Row (root of 'field_decl') at ???>

Row_Pos56 := Row_Pos55;



--  BEGIN <Token(<WithText ImplementsKw>, ) (root of 'field_decl') at parser.lkt:190:15>

Token_Res76 := Row_Pos56;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res76));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Implements_Kw)
   then
       Token_Pos76 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos56 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos56,
             Expected_Token_Id => Lkt_Implements_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos76 := Row_Pos56 + 1;
   end if;
end;

--  END <Token(<WithText ImplementsKw>, ) (root of 'field_decl') at parser.lkt:190:15>




if Token_Pos76 /= No_Token_Index then

   Row_Pos56 := Token_Pos76;

else
   Row_Pos56 := No_Token_Index;
   goto Exit_Row56_0;

end if;


--  BEGIN <Defer (for 'type_member_ref') at parser.lkt:190:28>

Defer_Res74 :=
   Type_Member_Ref_Transform_Parse0 (Parser, Row_Pos56);
Defer_Pos74 := Parser.Current_Pos;

--  END <Defer (for 'type_member_ref') at parser.lkt:190:28>




if Defer_Pos74 /= No_Token_Index then

   Row_Pos56 := Defer_Pos74;

else
   Row_Pos56 := No_Token_Index;
   goto Exit_Row56_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row56_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'field_decl') at ???>

--  END <_Extract (root of 'field_decl') at parser.lkt:190:10>


if Row_Pos56 = No_Token_Index then

         
   Defer_Res74 := No_Bare_Lkt_Node;



       
   Row_Pos56 := Row_Pos55;



end if;

--  END <Opt (root of 'field_decl') at parser.lkt:190:9>




if Row_Pos56 /= No_Token_Index then

   Row_Pos55 := Row_Pos56;

else
   Row_Pos55 := No_Token_Index;
   goto Exit_Row55_0;

end if;


--  BEGIN <Opt (root of 'field_decl') at parser.lkt:191:9>












--  BEGIN <_Extract (root of 'field_decl') at parser.lkt:191:10>

--  BEGIN <_Row (root of 'field_decl') at ???>

Row_Pos57 := Row_Pos55;



--  BEGIN <Token(<WithText Equal>, ) (root of 'field_decl') at parser.lkt:191:15>

Token_Res77 := Row_Pos57;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res77));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Equal)
   then
       Token_Pos77 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos57 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos57,
             Expected_Token_Id => Lkt_Equal,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos77 := Row_Pos57 + 1;
   end if;
end;

--  END <Token(<WithText Equal>, ) (root of 'field_decl') at parser.lkt:191:15>




if Token_Pos77 /= No_Token_Index then

   Row_Pos57 := Token_Pos77;

else
   Row_Pos57 := No_Token_Index;
   goto Exit_Row57_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:191:19>

Defer_Res75 :=
   Expr_Or_Parse1 (Parser, Row_Pos57);
Defer_Pos75 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:191:19>




if Defer_Pos75 /= No_Token_Index then

   Row_Pos57 := Defer_Pos75;

else
   Row_Pos57 := No_Token_Index;
   goto Exit_Row57_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row57_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'field_decl') at ???>

--  END <_Extract (root of 'field_decl') at parser.lkt:191:10>


if Row_Pos57 = No_Token_Index then

         
   Defer_Res75 := No_Bare_Lkt_Node;



       
   Row_Pos57 := Row_Pos55;



end if;

--  END <Opt (root of 'field_decl') at parser.lkt:191:9>




if Row_Pos57 /= No_Token_Index then

   Row_Pos55 := Row_Pos57;

else
   Row_Pos55 := No_Token_Index;
   goto Exit_Row55_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row55_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'field_decl') at ???>



if Row_Pos55 /= No_Token_Index then

   Transform_Res54 := Allocate_Field_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res54,
      Kind => Lkt_Field_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos55 = Pos
                            then No_Token_Index
                            else Row_Pos55 - 1));

      
      Initialize_Fields_For_Field_Decl
        (Self => Transform_Res54,
         Field_Decl_F_Syn_Name => Defer_Res72,
         Field_Decl_F_Decl_Type => Defer_Res73,
         Field_Decl_F_Trait_Ref => Defer_Res74,
         Field_Decl_F_Default_Val => Defer_Res75);

         if Defer_Res72 /= null and then Is_Incomplete (Defer_Res72) then
            Transform_Res54.Last_Attempted_Child := 0;
         elsif Defer_Res72 /= null and then not Is_Ghost (Defer_Res72) then
            Transform_Res54.Last_Attempted_Child := -1;
         end if;
         if Defer_Res73 /= null and then Is_Incomplete (Defer_Res73) then
            Transform_Res54.Last_Attempted_Child := 0;
         elsif Defer_Res73 /= null and then not Is_Ghost (Defer_Res73) then
            Transform_Res54.Last_Attempted_Child := -1;
         end if;
         if Defer_Res74 /= null and then Is_Incomplete (Defer_Res74) then
            Transform_Res54.Last_Attempted_Child := 0;
         elsif Defer_Res74 /= null and then not Is_Ghost (Defer_Res74) then
            Transform_Res54.Last_Attempted_Child := -1;
         end if;
         if Defer_Res75 /= null and then Is_Incomplete (Defer_Res75) then
            Transform_Res54.Last_Attempted_Child := 0;
         elsif Defer_Res75 /= null and then not Is_Ghost (Defer_Res75) then
            Transform_Res54.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos55 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags54);
end if;

--  END <Transform(<CompiledType BareFieldDecl>) (root of 'field_decl') at parser.lkt:186:19>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Field_Decl_Transform_Parse0_Memo,
      Row_Pos55 /= No_Token_Index,
      Transform_Res54,
      Pos,
      Row_Pos55);


   Parser.Current_Pos := Row_Pos55;

   return Transform_Res54;
end Field_Decl_Transform_Parse0;

   


function Fun_Arg_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Fun_Arg_Decl
is
   use Bare_Fun_Arg_Decl_Memos;

      Row_Pos58 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos7 :
            Token_Index
               := No_Token_Index;
      Tmp_List7 :
            Free_Parse_List;
      Defer_Pos76 :
            Token_Index
               := No_Token_Index;
      Defer_Res76 :
            Bare_Decl_Annotation
               := No_Bare_Lkt_Node;
      List_Pos7 :
            Token_Index
               := No_Token_Index;
      List_Res7 :
            Bare_Decl_Annotation_List
               := No_Bare_Lkt_Node;
      Defer_Pos77 :
            Token_Index
               := No_Token_Index;
      Defer_Res77 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Token_Pos78 :
            Token_Index
               := No_Token_Index;
      Token_Res78 :
            Token_Index
               := No_Token_Index;
      Defer_Pos78 :
            Token_Index
               := No_Token_Index;
      Defer_Res78 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Row_Pos59 :
            Token_Index
               := No_Token_Index;
      Token_Pos79 :
            Token_Index
               := No_Token_Index;
      Token_Res79 :
            Token_Index
               := No_Token_Index;
      Defer_Pos79 :
            Token_Index
               := No_Token_Index;
      Defer_Res79 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res55 :
            Bare_Fun_Arg_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags55 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Fun_Arg_Decl_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res55 := M.Instance;
      return Transform_Res55;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res55;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareFunArgDecl>) (root of 'fun_arg_decl') at parser.lkt:181:21>

Transform_Diags55 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'fun_arg_decl') at ???>

Row_Pos58 := Pos;



--  BEGIN <List (root of 'fun_arg_decl') at parser.lkt:182:9>

    List_Pos7 := Row_Pos58;



Lst_Cpos7 := Row_Pos58;
Tmp_List7 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'decl_annotation') at parser.lkt:182:15>

Defer_Res76 :=
   Decl_Annotation_Transform_Parse0 (Parser, Lst_Cpos7);
Defer_Pos76 := Parser.Current_Pos;

--  END <Defer (for 'decl_annotation') at parser.lkt:182:15>


   exit when Defer_Pos76 = No_Token_Index;

   List_Pos7 := Defer_Pos76;
   Lst_Cpos7 := List_Pos7;

   Tmp_List7.Nodes.Append (Defer_Res76);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List7.Nodes.Length;
begin
   List_Res7 := Allocate_Decl_Annotation_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos58;
      Token_End := (if Lst_Cpos7 = Row_Pos58
                    then Row_Pos58
                    else List_Pos7 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos58, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res7,
      Kind              => Lkt_Decl_Annotation_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res7,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List7.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res7.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List7);

--  END <List (root of 'fun_arg_decl') at parser.lkt:182:9>




if List_Pos7 /= No_Token_Index then

   Row_Pos58 := List_Pos7;

else
   Row_Pos58 := No_Token_Index;
   goto Exit_Row58_0;

end if;


--  BEGIN <Defer (for 'def_id') at parser.lkt:182:32>

Defer_Res77 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos58);
Defer_Pos77 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:182:32>




if Defer_Pos77 /= No_Token_Index then

   Row_Pos58 := Defer_Pos77;

else
   Row_Pos58 := No_Token_Index;
   goto Exit_Row58_0;

end if;


--  BEGIN <Token(<WithText Colon>, ) (root of 'fun_arg_decl') at parser.lkt:182:39>

Token_Res78 := Row_Pos58;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res78));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos78 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos58 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos58,
             Expected_Token_Id => Lkt_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos78 := Row_Pos58 + 1;
   end if;
end;

--  END <Token(<WithText Colon>, ) (root of 'fun_arg_decl') at parser.lkt:182:39>




if Token_Pos78 /= No_Token_Index then

   Row_Pos58 := Token_Pos78;

else
   Row_Pos58 := No_Token_Index;
   goto Exit_Row58_0;

end if;


--  BEGIN <Defer (for 'type_ref') at parser.lkt:182:43>

Defer_Res78 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos58);
Defer_Pos78 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:182:43>




if Defer_Pos78 /= No_Token_Index then

   Row_Pos58 := Defer_Pos78;

else
   Row_Pos58 := No_Token_Index;
   goto Exit_Row58_0;

end if;


--  BEGIN <Opt (root of 'fun_arg_decl') at parser.lkt:182:52>












--  BEGIN <_Extract (root of 'fun_arg_decl') at parser.lkt:182:53>

--  BEGIN <_Row (root of 'fun_arg_decl') at ???>

Row_Pos59 := Row_Pos58;



--  BEGIN <Token(<WithText Equal>, ) (root of 'fun_arg_decl') at parser.lkt:182:58>

Token_Res79 := Row_Pos59;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res79));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Equal)
   then
       Token_Pos79 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos59 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos59,
             Expected_Token_Id => Lkt_Equal,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos79 := Row_Pos59 + 1;
   end if;
end;

--  END <Token(<WithText Equal>, ) (root of 'fun_arg_decl') at parser.lkt:182:58>




if Token_Pos79 /= No_Token_Index then

   Row_Pos59 := Token_Pos79;

else
   Row_Pos59 := No_Token_Index;
   goto Exit_Row59_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:182:62>

Defer_Res79 :=
   Expr_Or_Parse1 (Parser, Row_Pos59);
Defer_Pos79 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:182:62>




if Defer_Pos79 /= No_Token_Index then

   Row_Pos59 := Defer_Pos79;

else
   Row_Pos59 := No_Token_Index;
   goto Exit_Row59_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row59_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'fun_arg_decl') at ???>

--  END <_Extract (root of 'fun_arg_decl') at parser.lkt:182:53>


if Row_Pos59 = No_Token_Index then

         
   Defer_Res79 := No_Bare_Lkt_Node;



       
   Row_Pos59 := Row_Pos58;



end if;

--  END <Opt (root of 'fun_arg_decl') at parser.lkt:182:52>




if Row_Pos59 /= No_Token_Index then

   Row_Pos58 := Row_Pos59;

else
   Row_Pos58 := No_Token_Index;
   goto Exit_Row58_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row58_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'fun_arg_decl') at ???>



if Row_Pos58 /= No_Token_Index then

   Transform_Res55 := Allocate_Fun_Arg_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res55,
      Kind => Lkt_Fun_Arg_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos58 = Pos
                            then No_Token_Index
                            else Row_Pos58 - 1));

      
      Initialize_Fields_For_Fun_Arg_Decl
        (Self => Transform_Res55,
         Fun_Arg_Decl_F_Decl_Annotations => List_Res7,
         Fun_Arg_Decl_F_Syn_Name => Defer_Res77,
         Fun_Arg_Decl_F_Decl_Type => Defer_Res78,
         Fun_Arg_Decl_F_Default_Val => Defer_Res79);

         if List_Res7 /= null and then Is_Incomplete (List_Res7) then
            Transform_Res55.Last_Attempted_Child := 0;
         elsif List_Res7 /= null and then not Is_Ghost (List_Res7) then
            Transform_Res55.Last_Attempted_Child := -1;
         end if;
         if Defer_Res77 /= null and then Is_Incomplete (Defer_Res77) then
            Transform_Res55.Last_Attempted_Child := 0;
         elsif Defer_Res77 /= null and then not Is_Ghost (Defer_Res77) then
            Transform_Res55.Last_Attempted_Child := -1;
         end if;
         if Defer_Res78 /= null and then Is_Incomplete (Defer_Res78) then
            Transform_Res55.Last_Attempted_Child := 0;
         elsif Defer_Res78 /= null and then not Is_Ghost (Defer_Res78) then
            Transform_Res55.Last_Attempted_Child := -1;
         end if;
         if Defer_Res79 /= null and then Is_Incomplete (Defer_Res79) then
            Transform_Res55.Last_Attempted_Child := 0;
         elsif Defer_Res79 /= null and then not Is_Ghost (Defer_Res79) then
            Transform_Res55.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos58 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags55);
end if;

--  END <Transform(<CompiledType BareFunArgDecl>) (root of 'fun_arg_decl') at parser.lkt:181:21>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Fun_Arg_Decl_Transform_Parse0_Memo,
      Row_Pos58 /= No_Token_Index,
      Transform_Res55,
      Pos,
      Row_Pos58);


   Parser.Current_Pos := Row_Pos58;

   return Transform_Res55;
end Fun_Arg_Decl_Transform_Parse0;

   


function Fun_Arg_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Fun_Arg_Decl_List
is
   use Bare_Fun_Arg_Decl_List_Memos;

      Lst_Cpos8 :
            Token_Index
               := No_Token_Index;
      Tmp_List8 :
            Free_Parse_List;
      Defer_Pos80 :
            Token_Index
               := No_Token_Index;
      Defer_Res80 :
            Bare_Fun_Arg_Decl
               := No_Bare_Lkt_Node;
      Token_Pos80 :
            Token_Index
               := No_Token_Index;
      Token_Res80 :
            Token_Index
               := No_Token_Index;
      List_Pos8 :
            Token_Index
               := No_Token_Index;
      List_Res8 :
            Bare_Fun_Arg_Decl_List
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Fun_Arg_List_List_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res8 := M.Instance;
      return List_Res8;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return List_Res8;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <List (root of 'fun_arg_list') at parser.lkt:184:21>

    List_Pos8 := Pos;



Lst_Cpos8 := Pos;
Tmp_List8 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'fun_arg_decl') at parser.lkt:184:27>

Defer_Res80 :=
   Fun_Arg_Decl_Transform_Parse0 (Parser, Lst_Cpos8);
Defer_Pos80 := Parser.Current_Pos;

--  END <Defer (for 'fun_arg_decl') at parser.lkt:184:27>


   exit when Defer_Pos80 = No_Token_Index;

   List_Pos8 := Defer_Pos80;
   Lst_Cpos8 := List_Pos8;

   Tmp_List8.Nodes.Append (Defer_Res80);

      
--  BEGIN <Token(<WithText Comma>, ) (root of 'fun_arg_list') at parser.lkt:184:41>

Token_Res80 := Lst_Cpos8;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res80));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos80 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos8 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos8,
             Expected_Token_Id => Lkt_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos80 := Lst_Cpos8 + 1;
   end if;
end;

--  END <Token(<WithText Comma>, ) (root of 'fun_arg_list') at parser.lkt:184:41>


      exit when Token_Pos80 = No_Token_Index;

      Lst_Cpos8 := Token_Pos80;

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List8.Nodes.Length;
begin
   List_Res8 := Allocate_Fun_Arg_Decl_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos8 = Pos
                    then Pos
                    else List_Pos8 - 1);

   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res8,
      Kind              => Lkt_Fun_Arg_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res8,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List8.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res8.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List8);

--  END <List (root of 'fun_arg_list') at parser.lkt:184:21>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Fun_Arg_List_List_Parse0_Memo,
      List_Pos8 /= No_Token_Index,
      List_Res8,
      Pos,
      List_Pos8);


   Parser.Current_Pos := List_Pos8;

   return List_Res8;
end Fun_Arg_List_List_Parse0;

   


function Fun_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Fun_Decl
is
   use Bare_Fun_Decl_Memos;

      Row_Pos60 :
            Token_Index
               := No_Token_Index;
      Token_Pos81 :
            Token_Index
               := No_Token_Index;
      Token_Res81 :
            Token_Index
               := No_Token_Index;
      Defer_Pos81 :
            Token_Index
               := No_Token_Index;
      Defer_Res81 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Token_Pos82 :
            Token_Index
               := No_Token_Index;
      Token_Res82 :
            Token_Index
               := No_Token_Index;
      Defer_Pos82 :
            Token_Index
               := No_Token_Index;
      Defer_Res82 :
            Bare_Fun_Arg_Decl_List
               := No_Bare_Lkt_Node;
      Token_Pos83 :
            Token_Index
               := No_Token_Index;
      Token_Res83 :
            Token_Index
               := No_Token_Index;
      Token_Pos84 :
            Token_Index
               := No_Token_Index;
      Token_Res84 :
            Token_Index
               := No_Token_Index;
      Defer_Pos83 :
            Token_Index
               := No_Token_Index;
      Defer_Res83 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Row_Pos61 :
            Token_Index
               := No_Token_Index;
      Token_Pos85 :
            Token_Index
               := No_Token_Index;
      Token_Res85 :
            Token_Index
               := No_Token_Index;
      Defer_Pos84 :
            Token_Index
               := No_Token_Index;
      Defer_Res84 :
            Bare_Dot_Expr
               := No_Bare_Lkt_Node;
      Row_Pos62 :
            Token_Index
               := No_Token_Index;
      Token_Pos86 :
            Token_Index
               := No_Token_Index;
      Token_Res86 :
            Token_Index
               := No_Token_Index;
      Defer_Pos85 :
            Token_Index
               := No_Token_Index;
      Defer_Res85 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res56 :
            Bare_Fun_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags56 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Fun_Decl_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res56 := M.Instance;
      return Transform_Res56;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res56;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareFunDecl>) (root of 'fun_decl') at parser.lkt:167:17>

Transform_Diags56 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'fun_decl') at ???>

Row_Pos60 := Pos;



--  BEGIN <Token(<WithText FunKw>, ) (root of 'fun_decl') at parser.lkt:168:9>

Token_Res81 := Row_Pos60;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res81));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Fun_Kw)
   then
       Token_Pos81 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos60 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos60,
             Expected_Token_Id => Lkt_Fun_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos81 := Row_Pos60 + 1;
   end if;
end;

--  END <Token(<WithText FunKw>, ) (root of 'fun_decl') at parser.lkt:168:9>




if Token_Pos81 /= No_Token_Index then

   Row_Pos60 := Token_Pos81;

else
   Row_Pos60 := No_Token_Index;
   goto Exit_Row60_0;

end if;


--  BEGIN <Defer (for 'def_id') at parser.lkt:169:9>

Defer_Res81 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos60);
Defer_Pos81 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:169:9>




if Defer_Pos81 /= No_Token_Index then

   Row_Pos60 := Defer_Pos81;

else
   Row_Pos60 := No_Token_Index;
   goto Exit_Row60_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'fun_decl') at parser.lkt:170:9>

Token_Res82 := Row_Pos60;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res82));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos82 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos60 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos60,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos82 := Row_Pos60 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'fun_decl') at parser.lkt:170:9>




if Token_Pos82 /= No_Token_Index then

   Row_Pos60 := Token_Pos82;

else
   Row_Pos60 := No_Token_Index;
   goto Exit_Row60_0;

end if;


--  BEGIN <Defer (for 'fun_arg_list') at parser.lkt:171:9>

Defer_Res82 :=
   Fun_Arg_List_List_Parse0 (Parser, Row_Pos60);
Defer_Pos82 := Parser.Current_Pos;

--  END <Defer (for 'fun_arg_list') at parser.lkt:171:9>




if Defer_Pos82 /= No_Token_Index then

   Row_Pos60 := Defer_Pos82;

else
   Row_Pos60 := No_Token_Index;
   goto Exit_Row60_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'fun_decl') at parser.lkt:172:9>

Token_Res83 := Row_Pos60;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res83));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos83 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos60 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos60,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos83 := Row_Pos60 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'fun_decl') at parser.lkt:172:9>




if Token_Pos83 /= No_Token_Index then

   Row_Pos60 := Token_Pos83;

else
   Row_Pos60 := No_Token_Index;
   goto Exit_Row60_0;

end if;


--  BEGIN <Token(<WithText Colon>, ) (root of 'fun_decl') at parser.lkt:173:9>

Token_Res84 := Row_Pos60;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res84));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos84 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos60 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos60,
             Expected_Token_Id => Lkt_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos84 := Row_Pos60 + 1;
   end if;
end;

--  END <Token(<WithText Colon>, ) (root of 'fun_decl') at parser.lkt:173:9>




if Token_Pos84 /= No_Token_Index then

   Row_Pos60 := Token_Pos84;

else
   Row_Pos60 := No_Token_Index;
   goto Exit_Row60_0;

end if;


--  BEGIN <Defer (for 'type_ref') at parser.lkt:174:9>

Defer_Res83 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos60);
Defer_Pos83 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:174:9>




if Defer_Pos83 /= No_Token_Index then

   Row_Pos60 := Defer_Pos83;

else
   Row_Pos60 := No_Token_Index;
   goto Exit_Row60_0;

end if;


--  BEGIN <Opt (root of 'fun_decl') at parser.lkt:175:9>












--  BEGIN <_Extract (root of 'fun_decl') at parser.lkt:175:10>

--  BEGIN <_Row (root of 'fun_decl') at ???>

Row_Pos61 := Row_Pos60;



--  BEGIN <Token(<WithText ImplementsKw>, ) (root of 'fun_decl') at parser.lkt:175:15>

Token_Res85 := Row_Pos61;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res85));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Implements_Kw)
   then
       Token_Pos85 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos61 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos61,
             Expected_Token_Id => Lkt_Implements_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos85 := Row_Pos61 + 1;
   end if;
end;

--  END <Token(<WithText ImplementsKw>, ) (root of 'fun_decl') at parser.lkt:175:15>




if Token_Pos85 /= No_Token_Index then

   Row_Pos61 := Token_Pos85;

else
   Row_Pos61 := No_Token_Index;
   goto Exit_Row61_0;

end if;


--  BEGIN <Defer (for 'type_member_ref') at parser.lkt:175:28>

Defer_Res84 :=
   Type_Member_Ref_Transform_Parse0 (Parser, Row_Pos61);
Defer_Pos84 := Parser.Current_Pos;

--  END <Defer (for 'type_member_ref') at parser.lkt:175:28>




if Defer_Pos84 /= No_Token_Index then

   Row_Pos61 := Defer_Pos84;

else
   Row_Pos61 := No_Token_Index;
   goto Exit_Row61_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row61_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'fun_decl') at ???>

--  END <_Extract (root of 'fun_decl') at parser.lkt:175:10>


if Row_Pos61 = No_Token_Index then

         
   Defer_Res84 := No_Bare_Lkt_Node;



       
   Row_Pos61 := Row_Pos60;



end if;

--  END <Opt (root of 'fun_decl') at parser.lkt:175:9>




if Row_Pos61 /= No_Token_Index then

   Row_Pos60 := Row_Pos61;

else
   Row_Pos60 := No_Token_Index;
   goto Exit_Row60_0;

end if;


--  BEGIN <Opt (root of 'fun_decl') at parser.lkt:176:9>












--  BEGIN <_Extract (root of 'fun_decl') at parser.lkt:176:10>

--  BEGIN <_Row (root of 'fun_decl') at ???>

Row_Pos62 := Row_Pos60;



--  BEGIN <Token(<WithText Equal>, ) (root of 'fun_decl') at parser.lkt:176:15>

Token_Res86 := Row_Pos62;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res86));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Equal)
   then
       Token_Pos86 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos62 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos62,
             Expected_Token_Id => Lkt_Equal,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos86 := Row_Pos62 + 1;
   end if;
end;

--  END <Token(<WithText Equal>, ) (root of 'fun_decl') at parser.lkt:176:15>




if Token_Pos86 /= No_Token_Index then

   Row_Pos62 := Token_Pos86;

else
   Row_Pos62 := No_Token_Index;
   goto Exit_Row62_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:176:19>

Defer_Res85 :=
   Expr_Or_Parse1 (Parser, Row_Pos62);
Defer_Pos85 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:176:19>




if Defer_Pos85 /= No_Token_Index then

   Row_Pos62 := Defer_Pos85;

else
   Row_Pos62 := No_Token_Index;
   goto Exit_Row62_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row62_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'fun_decl') at ???>

--  END <_Extract (root of 'fun_decl') at parser.lkt:176:10>


if Row_Pos62 = No_Token_Index then

         
   Defer_Res85 := No_Bare_Lkt_Node;



       
   Row_Pos62 := Row_Pos60;



end if;

--  END <Opt (root of 'fun_decl') at parser.lkt:176:9>




if Row_Pos62 /= No_Token_Index then

   Row_Pos60 := Row_Pos62;

else
   Row_Pos60 := No_Token_Index;
   goto Exit_Row60_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row60_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'fun_decl') at ???>



if Row_Pos60 /= No_Token_Index then

   Transform_Res56 := Allocate_Fun_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res56,
      Kind => Lkt_Fun_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos60 = Pos
                            then No_Token_Index
                            else Row_Pos60 - 1));

      
      Initialize_Fields_For_Fun_Decl
        (Self => Transform_Res56,
         Fun_Decl_F_Syn_Name => Defer_Res81,
         Fun_Decl_F_Args => Defer_Res82,
         Fun_Decl_F_Return_Type => Defer_Res83,
         Fun_Decl_F_Trait_Ref => Defer_Res84,
         Fun_Decl_F_Body => Defer_Res85);

         if Defer_Res81 /= null and then Is_Incomplete (Defer_Res81) then
            Transform_Res56.Last_Attempted_Child := 0;
         elsif Defer_Res81 /= null and then not Is_Ghost (Defer_Res81) then
            Transform_Res56.Last_Attempted_Child := -1;
         end if;
         if Defer_Res82 /= null and then Is_Incomplete (Defer_Res82) then
            Transform_Res56.Last_Attempted_Child := 0;
         elsif Defer_Res82 /= null and then not Is_Ghost (Defer_Res82) then
            Transform_Res56.Last_Attempted_Child := -1;
         end if;
         if Defer_Res83 /= null and then Is_Incomplete (Defer_Res83) then
            Transform_Res56.Last_Attempted_Child := 0;
         elsif Defer_Res83 /= null and then not Is_Ghost (Defer_Res83) then
            Transform_Res56.Last_Attempted_Child := -1;
         end if;
         if Defer_Res84 /= null and then Is_Incomplete (Defer_Res84) then
            Transform_Res56.Last_Attempted_Child := 0;
         elsif Defer_Res84 /= null and then not Is_Ghost (Defer_Res84) then
            Transform_Res56.Last_Attempted_Child := -1;
         end if;
         if Defer_Res85 /= null and then Is_Incomplete (Defer_Res85) then
            Transform_Res56.Last_Attempted_Child := 0;
         elsif Defer_Res85 /= null and then not Is_Ghost (Defer_Res85) then
            Transform_Res56.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos60 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags56);
end if;

--  END <Transform(<CompiledType BareFunDecl>) (root of 'fun_decl') at parser.lkt:167:17>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Fun_Decl_Transform_Parse0_Memo,
      Row_Pos60 /= No_Token_Index,
      Transform_Res56,
      Pos,
      Row_Pos60);


   Parser.Current_Pos := Row_Pos60;

   return Transform_Res56;
end Fun_Decl_Transform_Parse0;

   


function Generic_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Generic_Decl
is
   use Bare_Generic_Decl_Memos;

      Row_Pos63 :
            Token_Index
               := No_Token_Index;
      Token_Pos87 :
            Token_Index
               := No_Token_Index;
      Token_Res87 :
            Token_Index
               := No_Token_Index;
      Token_Pos88 :
            Token_Index
               := No_Token_Index;
      Token_Res88 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos9 :
            Token_Index
               := No_Token_Index;
      Tmp_List9 :
            Free_Parse_List;
      Defer_Pos86 :
            Token_Index
               := No_Token_Index;
      Defer_Res86 :
            Bare_Full_Decl
               := No_Bare_Lkt_Node;
      Token_Pos89 :
            Token_Index
               := No_Token_Index;
      Token_Res89 :
            Token_Index
               := No_Token_Index;
      List_Pos9 :
            Token_Index
               := No_Token_Index;
      List_Res9 :
            Bare_Generic_Formal_Decl_List
               := No_Bare_Lkt_Node;
      Token_Pos90 :
            Token_Index
               := No_Token_Index;
      Token_Res90 :
            Token_Index
               := No_Token_Index;
      Defer_Pos87 :
            Token_Index
               := No_Token_Index;
      Defer_Res87 :
            Bare_Decl
               := No_Bare_Lkt_Node;
      Transform_Res57 :
            Bare_Generic_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags57 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Generic_Decl_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res57 := M.Instance;
      return Transform_Res57;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res57;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareGenericDecl>) (root of 'generic_decl') at parser.lkt:154:21>

Transform_Diags57 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'generic_decl') at ???>

Row_Pos63 := Pos;



--  BEGIN <Token(<WithText GenericKw>, ) (root of 'generic_decl') at parser.lkt:155:9>

Token_Res87 := Row_Pos63;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res87));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Generic_Kw)
   then
       Token_Pos87 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos63 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos63,
             Expected_Token_Id => Lkt_Generic_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos87 := Row_Pos63 + 1;
   end if;
end;

--  END <Token(<WithText GenericKw>, ) (root of 'generic_decl') at parser.lkt:155:9>




if Token_Pos87 /= No_Token_Index then

   Row_Pos63 := Token_Pos87;

else
   Row_Pos63 := No_Token_Index;
   goto Exit_Row63_0;

end if;


--  BEGIN <Token(<WithText LBrack>, ) (root of 'generic_decl') at parser.lkt:156:9>

Token_Res88 := Row_Pos63;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res88));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos88 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos63 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos63,
             Expected_Token_Id => Lkt_L_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos88 := Row_Pos63 + 1;
   end if;
end;

--  END <Token(<WithText LBrack>, ) (root of 'generic_decl') at parser.lkt:156:9>




if Token_Pos88 /= No_Token_Index then

   Row_Pos63 := Token_Pos88;

else
   Row_Pos63 := No_Token_Index;
   goto Exit_Row63_0;

end if;


--  BEGIN <List (root of 'generic_decl') at parser.lkt:157:9>

    List_Pos9 := No_Token_Index;



Lst_Cpos9 := Row_Pos63;
Tmp_List9 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'generic_formal_type') at parser.lkt:157:32>

Defer_Res86 :=
   Generic_Formal_Type_Transform_Parse1 (Parser, Lst_Cpos9);
Defer_Pos86 := Parser.Current_Pos;

--  END <Defer (for 'generic_formal_type') at parser.lkt:157:32>


   exit when Defer_Pos86 = No_Token_Index;

   List_Pos9 := Defer_Pos86;
   Lst_Cpos9 := List_Pos9;

   Tmp_List9.Nodes.Append (Defer_Res86);

      
--  BEGIN <Token(<WithText Comma>, ) (root of 'generic_decl') at parser.lkt:157:53>

Token_Res89 := Lst_Cpos9;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res89));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos89 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos9 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos9,
             Expected_Token_Id => Lkt_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos89 := Lst_Cpos9 + 1;
   end if;
end;

--  END <Token(<WithText Comma>, ) (root of 'generic_decl') at parser.lkt:157:53>


      exit when Token_Pos89 = No_Token_Index;

      Lst_Cpos9 := Token_Pos89;

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List9.Nodes.Length;
begin
   List_Res9 := Allocate_Generic_Formal_Decl_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos63;
      Token_End := (if Lst_Cpos9 = Row_Pos63
                    then Row_Pos63
                    else List_Pos9 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos63, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res9,
      Kind              => Lkt_Generic_Formal_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res9,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List9.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res9.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List9);

--  END <List (root of 'generic_decl') at parser.lkt:157:9>




if List_Pos9 /= No_Token_Index then

   Row_Pos63 := List_Pos9;

else
   Row_Pos63 := No_Token_Index;
   goto Exit_Row63_0;

end if;


--  BEGIN <Token(<WithText RBrack>, ) (root of 'generic_decl') at parser.lkt:158:9>

Token_Res90 := Row_Pos63;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res90));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos90 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos63 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos63,
             Expected_Token_Id => Lkt_R_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos90 := Row_Pos63 + 1;
   end if;
end;

--  END <Token(<WithText RBrack>, ) (root of 'generic_decl') at parser.lkt:158:9>




if Token_Pos90 /= No_Token_Index then

   Row_Pos63 := Token_Pos90;

else
   Row_Pos63 := No_Token_Index;
   goto Exit_Row63_0;

end if;


--  BEGIN <Defer (for 'bare_decl') at parser.lkt:159:9>

Defer_Res87 :=
   Bare_Decl_Or_Parse0 (Parser, Row_Pos63);
Defer_Pos87 := Parser.Current_Pos;

--  END <Defer (for 'bare_decl') at parser.lkt:159:9>




if Defer_Pos87 /= No_Token_Index then

   Row_Pos63 := Defer_Pos87;

else
   Row_Pos63 := No_Token_Index;
   goto Exit_Row63_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row63_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'generic_decl') at ???>



if Row_Pos63 /= No_Token_Index then

   Transform_Res57 := Allocate_Generic_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res57,
      Kind => Lkt_Generic_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos63 = Pos
                            then No_Token_Index
                            else Row_Pos63 - 1));

      
      Initialize_Fields_For_Generic_Decl
        (Self => Transform_Res57,
         Generic_Decl_F_Generic_Formal_Decls => List_Res9,
         Generic_Decl_F_Decl => Defer_Res87);

         if List_Res9 /= null and then Is_Incomplete (List_Res9) then
            Transform_Res57.Last_Attempted_Child := 0;
         elsif List_Res9 /= null and then not Is_Ghost (List_Res9) then
            Transform_Res57.Last_Attempted_Child := -1;
         end if;
         if Defer_Res87 /= null and then Is_Incomplete (Defer_Res87) then
            Transform_Res57.Last_Attempted_Child := 0;
         elsif Defer_Res87 /= null and then not Is_Ghost (Defer_Res87) then
            Transform_Res57.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos63 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags57);
end if;

--  END <Transform(<CompiledType BareGenericDecl>) (root of 'generic_decl') at parser.lkt:154:21>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Generic_Decl_Transform_Parse0_Memo,
      Row_Pos63 /= No_Token_Index,
      Transform_Res57,
      Pos,
      Row_Pos63);


   Parser.Current_Pos := Row_Pos63;

   return Transform_Res57;
end Generic_Decl_Transform_Parse0;

   


function Generic_Formal_Type_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Full_Decl
is
   use Bare_Full_Decl_Memos;

      Row_Pos64 :
            Token_Index
               := No_Token_Index;
      Defer_Pos88 :
            Token_Index
               := No_Token_Index;
      Defer_Res88 :
            Bare_String_Lit
               := No_Bare_Lkt_Node;
      Lst_Cpos10 :
            Token_Index
               := No_Token_Index;
      Tmp_List10 :
            Free_Parse_List;
      Defer_Pos89 :
            Token_Index
               := No_Token_Index;
      Defer_Res89 :
            Bare_Decl_Annotation
               := No_Bare_Lkt_Node;
      List_Pos10 :
            Token_Index
               := No_Token_Index;
      List_Res10 :
            Bare_Decl_Annotation_List
               := No_Bare_Lkt_Node;
      Row_Pos65 :
            Token_Index
               := No_Token_Index;
      Token_Pos91 :
            Token_Index
               := No_Token_Index;
      Token_Res91 :
            Token_Index
               := No_Token_Index;
      Opt_Res1 :
            Bare_Class_Qualifier
               := No_Bare_Lkt_Node;
      Defer_Pos90 :
            Token_Index
               := No_Token_Index;
      Defer_Res90 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Transform_Res58 :
            Bare_Generic_Formal_Type_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags58 :
            Ada.Containers.Count_Type;
      Transform_Res59 :
            Bare_Full_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags59 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Generic_Formal_Type_Transform_Parse1_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res59 := M.Instance;
      return Transform_Res59;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res59;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareFullDecl>) (root of 'generic_formal_type') at parser.lkt:161:28>

Transform_Diags59 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'generic_formal_type') at ???>

Row_Pos64 := Pos;



--  BEGIN <Defer (for 'doc') at parser.lkt:162:9>

Defer_Res88 :=
   Doc_Opt_Parse0 (Parser, Row_Pos64);
Defer_Pos88 := Parser.Current_Pos;

--  END <Defer (for 'doc') at parser.lkt:162:9>




if Defer_Pos88 /= No_Token_Index then

   Row_Pos64 := Defer_Pos88;

else
   Row_Pos64 := No_Token_Index;
   goto Exit_Row64_0;

end if;


--  BEGIN <List (root of 'generic_formal_type') at parser.lkt:163:9>

    List_Pos10 := Row_Pos64;



Lst_Cpos10 := Row_Pos64;
Tmp_List10 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'decl_annotation') at parser.lkt:163:15>

Defer_Res89 :=
   Decl_Annotation_Transform_Parse0 (Parser, Lst_Cpos10);
Defer_Pos89 := Parser.Current_Pos;

--  END <Defer (for 'decl_annotation') at parser.lkt:163:15>


   exit when Defer_Pos89 = No_Token_Index;

   List_Pos10 := Defer_Pos89;
   Lst_Cpos10 := List_Pos10;

   Tmp_List10.Nodes.Append (Defer_Res89);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List10.Nodes.Length;
begin
   List_Res10 := Allocate_Decl_Annotation_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos64;
      Token_End := (if Lst_Cpos10 = Row_Pos64
                    then Row_Pos64
                    else List_Pos10 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos64, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res10,
      Kind              => Lkt_Decl_Annotation_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res10,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List10.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res10.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List10);

--  END <List (root of 'generic_formal_type') at parser.lkt:163:9>




if List_Pos10 /= No_Token_Index then

   Row_Pos64 := List_Pos10;

else
   Row_Pos64 := No_Token_Index;
   goto Exit_Row64_0;

end if;


--  BEGIN <Transform(<CompiledType BareGenericFormalTypeDecl>) (root of 'generic_formal_type') at parser.lkt:164:9>

Transform_Diags58 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'generic_formal_type') at ???>

Row_Pos65 := Row_Pos64;



--  BEGIN <Opt (root of 'generic_formal_type') at parser.lkt:164:31>












--  BEGIN <Token(<WithText ClassKw>, ) (root of 'generic_formal_type') at parser.lkt:164:46>

Token_Res91 := Row_Pos65;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res91));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Class_Kw)
   then
       Token_Pos91 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos65 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos65,
             Expected_Token_Id => Lkt_Class_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos91 := Row_Pos65 + 1;
   end if;
end;

--  END <Token(<WithText ClassKw>, ) (root of 'generic_formal_type') at parser.lkt:164:46>


if Token_Pos91 = No_Token_Index then

         Opt_Res1 := Allocate_Class_Qualifier_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res1,
            Kind              => Lkt_Class_Qualifier_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos65,
            Token_End_Index   => No_Token_Index);


       
   Token_Pos91 := Row_Pos65;


else

      Opt_Res1 := Allocate_Class_Qualifier_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res1,
         Kind              => Lkt_Class_Qualifier_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos65,
         Token_End_Index   => Token_Pos91 - 1);

end if;

--  END <Opt (root of 'generic_formal_type') at parser.lkt:164:31>




if Token_Pos91 /= No_Token_Index then

   Row_Pos65 := Token_Pos91;

else
   Row_Pos65 := No_Token_Index;
   goto Exit_Row65_0;

end if;


--  BEGIN <Defer (for 'def_id') at parser.lkt:164:55>

Defer_Res90 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos65);
Defer_Pos90 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:164:55>




if Defer_Pos90 /= No_Token_Index then

   Row_Pos65 := Defer_Pos90;

else
   Row_Pos65 := No_Token_Index;
   goto Exit_Row65_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row65_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'generic_formal_type') at ???>



if Row_Pos65 /= No_Token_Index then

   Transform_Res58 := Allocate_Generic_Formal_Type_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res58,
      Kind => Lkt_Generic_Formal_Type_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos64,
      Token_End_Index   => (if Row_Pos65 = Row_Pos64
                            then No_Token_Index
                            else Row_Pos65 - 1));

      
      Initialize_Fields_For_Generic_Formal_Type_Decl
        (Self => Transform_Res58,
         Generic_Formal_Type_Decl_F_Has_Class => Opt_Res1,
         Generic_Formal_Type_Decl_F_Syn_Name => Defer_Res90);

         if Opt_Res1 /= null and then Is_Incomplete (Opt_Res1) then
            Transform_Res58.Last_Attempted_Child := 0;
         elsif Opt_Res1 /= null and then not Is_Ghost (Opt_Res1) then
            Transform_Res58.Last_Attempted_Child := -1;
         end if;
         if Defer_Res90 /= null and then Is_Incomplete (Defer_Res90) then
            Transform_Res58.Last_Attempted_Child := 0;
         elsif Defer_Res90 /= null and then not Is_Ghost (Defer_Res90) then
            Transform_Res58.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos65 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags58);
end if;

--  END <Transform(<CompiledType BareGenericFormalTypeDecl>) (root of 'generic_formal_type') at parser.lkt:164:9>




if Row_Pos65 /= No_Token_Index then

   Row_Pos64 := Row_Pos65;

else
   Row_Pos64 := No_Token_Index;
   goto Exit_Row64_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row64_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'generic_formal_type') at ???>



if Row_Pos64 /= No_Token_Index then

   Transform_Res59 := Allocate_Full_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res59,
      Kind => Lkt_Full_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos64 = Pos
                            then No_Token_Index
                            else Row_Pos64 - 1));

      
      Initialize_Fields_For_Full_Decl
        (Self => Transform_Res59,
         Full_Decl_F_Doc => Defer_Res88,
         Full_Decl_F_Decl_Annotations => List_Res10,
         Full_Decl_F_Decl => Transform_Res58);

         if Defer_Res88 /= null and then Is_Incomplete (Defer_Res88) then
            Transform_Res59.Last_Attempted_Child := 0;
         elsif Defer_Res88 /= null and then not Is_Ghost (Defer_Res88) then
            Transform_Res59.Last_Attempted_Child := -1;
         end if;
         if List_Res10 /= null and then Is_Incomplete (List_Res10) then
            Transform_Res59.Last_Attempted_Child := 0;
         elsif List_Res10 /= null and then not Is_Ghost (List_Res10) then
            Transform_Res59.Last_Attempted_Child := -1;
         end if;
         if Transform_Res58 /= null and then Is_Incomplete (Transform_Res58) then
            Transform_Res59.Last_Attempted_Child := 0;
         elsif Transform_Res58 /= null and then not Is_Ghost (Transform_Res58) then
            Transform_Res59.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos64 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags59);
end if;

--  END <Transform(<CompiledType BareFullDecl>) (root of 'generic_formal_type') at parser.lkt:161:28>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Generic_Formal_Type_Transform_Parse1_Memo,
      Row_Pos64 /= No_Token_Index,
      Transform_Res59,
      Pos,
      Row_Pos64);


   Parser.Current_Pos := Row_Pos64;

   return Transform_Res59;
end Generic_Formal_Type_Transform_Parse1;

   


function Grammar_Cut_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Cut
is
   use Bare_Grammar_Cut_Memos;

      Row_Pos66 :
            Token_Index
               := No_Token_Index;
      Token_Pos92 :
            Token_Index
               := No_Token_Index;
      Token_Res92 :
            Token_Index
               := No_Token_Index;
      Transform_Res60 :
            Bare_Grammar_Cut
               := No_Bare_Lkt_Node;
      Transform_Diags60 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Grammar_Cut_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res60 := M.Instance;
      return Transform_Res60;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res60;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareGrammarCut>) (root of 'grammar_cut') at parser.lkt:80:20>

Transform_Diags60 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_cut') at ???>

Row_Pos66 := Pos;



--  BEGIN <Token(<WithText Div>, ) (root of 'grammar_cut') at parser.lkt:80:31>

Token_Res92 := Row_Pos66;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res92));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Div)
   then
       Token_Pos92 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos66 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos66,
             Expected_Token_Id => Lkt_Div,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos92 := Row_Pos66 + 1;
   end if;
end;

--  END <Token(<WithText Div>, ) (root of 'grammar_cut') at parser.lkt:80:31>




if Token_Pos92 /= No_Token_Index then

   Row_Pos66 := Token_Pos92;

else
   Row_Pos66 := No_Token_Index;
   goto Exit_Row66_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row66_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_cut') at ???>



if Row_Pos66 /= No_Token_Index then

   Transform_Res60 := Allocate_Grammar_Cut (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res60,
      Kind => Lkt_Grammar_Cut,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos66 = Pos
                            then No_Token_Index
                            else Row_Pos66 - 1));

      
      Initialize_Fields_For_Grammar_Cut
        (Self => Transform_Res60);



elsif Row_Pos66 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags60);
end if;

--  END <Transform(<CompiledType BareGrammarCut>) (root of 'grammar_cut') at parser.lkt:80:20>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Grammar_Cut_Transform_Parse0_Memo,
      Row_Pos66 /= No_Token_Index,
      Transform_Res60,
      Pos,
      Row_Pos66);


   Parser.Current_Pos := Row_Pos66;

   return Transform_Res60;
end Grammar_Cut_Transform_Parse0;

   


function Grammar_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Decl
is
   use Bare_Grammar_Decl_Memos;

      Row_Pos67 :
            Token_Index
               := No_Token_Index;
      Token_Pos93 :
            Token_Index
               := No_Token_Index;
      Token_Res93 :
            Token_Index
               := No_Token_Index;
      Defer_Pos91 :
            Token_Index
               := No_Token_Index;
      Defer_Res91 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Token_Pos94 :
            Token_Index
               := No_Token_Index;
      Token_Res94 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos11 :
            Token_Index
               := No_Token_Index;
      Tmp_List11 :
            Free_Parse_List;
      Defer_Pos92 :
            Token_Index
               := No_Token_Index;
      Defer_Res92 :
            Bare_Full_Decl
               := No_Bare_Lkt_Node;
      List_Pos11 :
            Token_Index
               := No_Token_Index;
      List_Res11 :
            Bare_Full_Decl_List
               := No_Bare_Lkt_Node;
      Token_Pos95 :
            Token_Index
               := No_Token_Index;
      Token_Res95 :
            Token_Index
               := No_Token_Index;
      Transform_Res61 :
            Bare_Grammar_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags61 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Grammar_Decl_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res61 := M.Instance;
      return Transform_Res61;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res61;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareGrammarDecl>) (root of 'grammar_decl') at parser.lkt:16:21>

Transform_Diags61 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_decl') at ???>

Row_Pos67 := Pos;



--  BEGIN <Token(<WithText GrammarKw>, ) (root of 'grammar_decl') at parser.lkt:16:33>

Token_Res93 := Row_Pos67;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res93));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Grammar_Kw)
   then
       Token_Pos93 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos67 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos67,
             Expected_Token_Id => Lkt_Grammar_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos93 := Row_Pos67 + 1;
   end if;
end;

--  END <Token(<WithText GrammarKw>, ) (root of 'grammar_decl') at parser.lkt:16:33>




if Token_Pos93 /= No_Token_Index then

   Row_Pos67 := Token_Pos93;

else
   Row_Pos67 := No_Token_Index;
   goto Exit_Row67_0;

end if;


--  BEGIN <Defer (for 'def_id') at parser.lkt:16:43>

Defer_Res91 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos67);
Defer_Pos91 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:16:43>




if Defer_Pos91 /= No_Token_Index then

   Row_Pos67 := Defer_Pos91;

else
   Row_Pos67 := No_Token_Index;
   goto Exit_Row67_0;

end if;


--  BEGIN <Token(<WithText LBrace>, ) (root of 'grammar_decl') at parser.lkt:16:50>

Token_Res94 := Row_Pos67;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res94));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos94 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos67 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos67,
             Expected_Token_Id => Lkt_L_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos94 := Row_Pos67 + 1;
   end if;
end;

--  END <Token(<WithText LBrace>, ) (root of 'grammar_decl') at parser.lkt:16:50>




if Token_Pos94 /= No_Token_Index then

   Row_Pos67 := Token_Pos94;

else
   Row_Pos67 := No_Token_Index;
   goto Exit_Row67_0;

end if;


--  BEGIN <List (root of 'grammar_decl') at parser.lkt:16:54>

    List_Pos11 := Row_Pos67;



Lst_Cpos11 := Row_Pos67;
Tmp_List11 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'decl') at parser.lkt:16:60>

Defer_Res92 :=
   Decl_Transform_Parse0 (Parser, Lst_Cpos11);
Defer_Pos92 := Parser.Current_Pos;

--  END <Defer (for 'decl') at parser.lkt:16:60>


   exit when Defer_Pos92 = No_Token_Index;

   List_Pos11 := Defer_Pos92;
   Lst_Cpos11 := List_Pos11;

   Tmp_List11.Nodes.Append (Defer_Res92);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List11.Nodes.Length;
begin
   List_Res11 := Allocate_Full_Decl_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos67;
      Token_End := (if Lst_Cpos11 = Row_Pos67
                    then Row_Pos67
                    else List_Pos11 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos67, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res11,
      Kind              => Lkt_Full_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res11,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List11.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res11.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List11);

--  END <List (root of 'grammar_decl') at parser.lkt:16:54>




if List_Pos11 /= No_Token_Index then

   Row_Pos67 := List_Pos11;

else
   Row_Pos67 := No_Token_Index;
   goto Exit_Row67_0;

end if;


--  BEGIN <Token(<WithText RBrace>, ) (root of 'grammar_decl') at parser.lkt:16:66>

Token_Res95 := Row_Pos67;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res95));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos95 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos67 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos67,
             Expected_Token_Id => Lkt_R_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos95 := Row_Pos67 + 1;
   end if;
end;

--  END <Token(<WithText RBrace>, ) (root of 'grammar_decl') at parser.lkt:16:66>




if Token_Pos95 /= No_Token_Index then

   Row_Pos67 := Token_Pos95;

else
   Row_Pos67 := No_Token_Index;
   goto Exit_Row67_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row67_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_decl') at ???>



if Row_Pos67 /= No_Token_Index then

   Transform_Res61 := Allocate_Grammar_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res61,
      Kind => Lkt_Grammar_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos67 = Pos
                            then No_Token_Index
                            else Row_Pos67 - 1));

      
      Initialize_Fields_For_Grammar_Decl
        (Self => Transform_Res61,
         Grammar_Decl_F_Syn_Name => Defer_Res91,
         Grammar_Decl_F_Rules => List_Res11);

         if Defer_Res91 /= null and then Is_Incomplete (Defer_Res91) then
            Transform_Res61.Last_Attempted_Child := 0;
         elsif Defer_Res91 /= null and then not Is_Ghost (Defer_Res91) then
            Transform_Res61.Last_Attempted_Child := -1;
         end if;
         if List_Res11 /= null and then Is_Incomplete (List_Res11) then
            Transform_Res61.Last_Attempted_Child := 0;
         elsif List_Res11 /= null and then not Is_Ghost (List_Res11) then
            Transform_Res61.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos67 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags61);
end if;

--  END <Transform(<CompiledType BareGrammarDecl>) (root of 'grammar_decl') at parser.lkt:16:21>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Grammar_Decl_Transform_Parse0_Memo,
      Row_Pos67 /= No_Token_Index,
      Transform_Res61,
      Pos,
      Row_Pos67);


   Parser.Current_Pos := Row_Pos67;

   return Transform_Res61;
end Grammar_Decl_Transform_Parse0;

   


function Grammar_Discard_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Discard
is
   use Bare_Grammar_Discard_Memos;

      Row_Pos68 :
            Token_Index
               := No_Token_Index;
      Token_Pos96 :
            Token_Index
               := No_Token_Index;
      Token_Res96 :
            Token_Index
               := No_Token_Index;
      Token_Pos97 :
            Token_Index
               := No_Token_Index;
      Token_Res97 :
            Token_Index
               := No_Token_Index;
      Defer_Pos93 :
            Token_Index
               := No_Token_Index;
      Defer_Res93 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      Token_Pos98 :
            Token_Index
               := No_Token_Index;
      Token_Res98 :
            Token_Index
               := No_Token_Index;
      Transform_Res62 :
            Bare_Grammar_Discard
               := No_Bare_Lkt_Node;
      Transform_Diags62 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Grammar_Discard_Expr_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res62 := M.Instance;
      return Transform_Res62;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res62;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareGrammarDiscard>) (root of 'grammar_discard_expr') at parser.lkt:87:29>

Transform_Diags62 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_discard_expr') at ???>

Row_Pos68 := Pos;



--  BEGIN <Token(<WithText DiscardKw>, ) (root of 'grammar_discard_expr') at parser.lkt:87:44>

Token_Res96 := Row_Pos68;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res96));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Discard_Kw)
   then
       Token_Pos96 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos68 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos68,
             Expected_Token_Id => Lkt_Discard_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos96 := Row_Pos68 + 1;
   end if;
end;

--  END <Token(<WithText DiscardKw>, ) (root of 'grammar_discard_expr') at parser.lkt:87:44>




if Token_Pos96 /= No_Token_Index then

   Row_Pos68 := Token_Pos96;

else
   Row_Pos68 := No_Token_Index;
   goto Exit_Row68_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_discard_expr') at parser.lkt:87:54>

Token_Res97 := Row_Pos68;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res97));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos97 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos68 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos68,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos97 := Row_Pos68 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'grammar_discard_expr') at parser.lkt:87:54>




if Token_Pos97 /= No_Token_Index then

   Row_Pos68 := Token_Pos97;

else
   Row_Pos68 := No_Token_Index;
   goto Exit_Row68_0;

end if;


--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:87:58>

Defer_Res93 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos68);
Defer_Pos93 := Parser.Current_Pos;

--  END <Defer (for 'grammar_expr') at parser.lkt:87:58>




if Defer_Pos93 /= No_Token_Index then

   Row_Pos68 := Defer_Pos93;

else
   Row_Pos68 := No_Token_Index;
   goto Exit_Row68_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_discard_expr') at parser.lkt:87:71>

Token_Res98 := Row_Pos68;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res98));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos98 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos68 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos68,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos98 := Row_Pos68 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'grammar_discard_expr') at parser.lkt:87:71>




if Token_Pos98 /= No_Token_Index then

   Row_Pos68 := Token_Pos98;

else
   Row_Pos68 := No_Token_Index;
   goto Exit_Row68_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row68_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_discard_expr') at ???>



if Row_Pos68 /= No_Token_Index then

   Transform_Res62 := Allocate_Grammar_Discard (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res62,
      Kind => Lkt_Grammar_Discard,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos68 = Pos
                            then No_Token_Index
                            else Row_Pos68 - 1));

      
      Initialize_Fields_For_Grammar_Discard
        (Self => Transform_Res62,
         Grammar_Discard_F_Expr => Defer_Res93);

         if Defer_Res93 /= null and then Is_Incomplete (Defer_Res93) then
            Transform_Res62.Last_Attempted_Child := 0;
         elsif Defer_Res93 /= null and then not Is_Ghost (Defer_Res93) then
            Transform_Res62.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos68 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags62);
end if;

--  END <Transform(<CompiledType BareGrammarDiscard>) (root of 'grammar_discard_expr') at parser.lkt:87:29>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Grammar_Discard_Expr_Transform_Parse0_Memo,
      Row_Pos68 /= No_Token_Index,
      Transform_Res62,
      Pos,
      Row_Pos68);


   Parser.Current_Pos := Row_Pos68;

   return Transform_Res62;
end Grammar_Discard_Expr_Transform_Parse0;

   


function Grammar_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr
is
   use Bare_Grammar_Expr_Memos;

      Row_Pos69 :
            Token_Index
               := No_Token_Index;
      Defer_Pos94 :
            Token_Index
               := No_Token_Index;
      Defer_Res94 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      Token_Pos99 :
            Token_Index
               := No_Token_Index;
      Token_Res99 :
            Token_Index
               := No_Token_Index;
      Token_Pos100 :
            Token_Index
               := No_Token_Index;
      Token_Res100 :
            Token_Index
               := No_Token_Index;
      Token_Pos101 :
            Token_Index
               := No_Token_Index;
      Token_Res101 :
            Token_Index
               := No_Token_Index;
      Defer_Pos95 :
            Token_Index
               := No_Token_Index;
      Defer_Res95 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      Token_Pos102 :
            Token_Index
               := No_Token_Index;
      Token_Res102 :
            Token_Index
               := No_Token_Index;
      Transform_Res63 :
            Bare_Grammar_Dont_Skip
               := No_Bare_Lkt_Node;
      Transform_Diags63 :
            Ada.Containers.Count_Type;
      Row_Pos70 :
            Token_Index
               := No_Token_Index;
      Defer_Pos96 :
            Token_Index
               := No_Token_Index;
      Defer_Res96 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      Token_Pos103 :
            Token_Index
               := No_Token_Index;
      Token_Res103 :
            Token_Index
               := No_Token_Index;
      Token_Pos104 :
            Token_Index
               := No_Token_Index;
      Token_Res104 :
            Token_Index
               := No_Token_Index;
      Token_Pos105 :
            Token_Index
               := No_Token_Index;
      Token_Res105 :
            Token_Index
               := No_Token_Index;
      Defer_Pos97 :
            Token_Index
               := No_Token_Index;
      Defer_Res97 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos106 :
            Token_Index
               := No_Token_Index;
      Token_Res106 :
            Token_Index
               := No_Token_Index;
      Transform_Res64 :
            Bare_Grammar_Predicate
               := No_Bare_Lkt_Node;
      Transform_Diags64 :
            Ada.Containers.Count_Type;
      Defer_Pos98 :
            Token_Index
               := No_Token_Index;
      Defer_Res98 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      Or_Pos15 :
            Token_Index
               := No_Token_Index;
      Or_Res15 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Grammar_Expr := No_Bare_Lkt_Node;

   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Grammar_Expr_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res15 := M.Instance;
      return Or_Res15;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res15;
   end if;

       Set (PP.Grammar_Expr_Or_Parse0_Memo, False, Or_Res15, Pos, Mem_Pos);

       <<Try_Again>>



   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'grammar_expr') at parser.lkt:59:21>

Or_Pos15 := No_Token_Index;
Or_Res15 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareGrammarDontSkip>) (root of 'grammar_expr') at parser.lkt:60:11>

Transform_Diags63 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_expr') at ???>

Row_Pos69 := Pos;



--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:61:13>

Defer_Res94 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos69);
Defer_Pos94 := Parser.Current_Pos;

--  END <Defer (for 'grammar_expr') at parser.lkt:61:13>




if Defer_Pos94 /= No_Token_Index then

   Row_Pos69 := Defer_Pos94;

else
   Row_Pos69 := No_Token_Index;
   goto Exit_Row69_0;

end if;


--  BEGIN <Token(<WithText Dot>, ) (root of 'grammar_expr') at parser.lkt:61:26>

Token_Res99 := Row_Pos69;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res99));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dot)
   then
       Token_Pos99 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos69 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos69,
             Expected_Token_Id => Lkt_Dot,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos99 := Row_Pos69 + 1;
   end if;
end;

--  END <Token(<WithText Dot>, ) (root of 'grammar_expr') at parser.lkt:61:26>




if Token_Pos99 /= No_Token_Index then

   Row_Pos69 := Token_Pos99;

else
   Row_Pos69 := No_Token_Index;
   goto Exit_Row69_0;

end if;


--  BEGIN <Token(<WithSymbol Identifier>, dont_skip) (root of 'grammar_expr') at parser.lkt:61:30>

Token_Res100 := Row_Pos69;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res100));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Dont_Skip)
   then
       Token_Pos100 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos69 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos69,
             Expected_Token_Id => Lkt_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos100 := Row_Pos69 + 1;
   end if;
end;

--  END <Token(<WithSymbol Identifier>, dont_skip) (root of 'grammar_expr') at parser.lkt:61:30>




if Token_Pos100 /= No_Token_Index then

   Row_Pos69 := Token_Pos100;

else
   Row_Pos69 := No_Token_Index;
   goto Exit_Row69_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_expr') at parser.lkt:61:55>

Token_Res101 := Row_Pos69;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res101));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos101 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos69 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos69,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos101 := Row_Pos69 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'grammar_expr') at parser.lkt:61:55>




if Token_Pos101 /= No_Token_Index then

   Row_Pos69 := Token_Pos101;

else
   Row_Pos69 := No_Token_Index;
   goto Exit_Row69_0;

end if;


--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:61:59>

Defer_Res95 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos69);
Defer_Pos95 := Parser.Current_Pos;

--  END <Defer (for 'grammar_expr') at parser.lkt:61:59>




if Defer_Pos95 /= No_Token_Index then

   Row_Pos69 := Defer_Pos95;

else
   Row_Pos69 := No_Token_Index;
   goto Exit_Row69_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_expr') at parser.lkt:61:72>

Token_Res102 := Row_Pos69;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res102));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos102 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos69 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos69,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos102 := Row_Pos69 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'grammar_expr') at parser.lkt:61:72>




if Token_Pos102 /= No_Token_Index then

   Row_Pos69 := Token_Pos102;

else
   Row_Pos69 := No_Token_Index;
   goto Exit_Row69_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row69_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_expr') at ???>



if Row_Pos69 /= No_Token_Index then

   Transform_Res63 := Allocate_Grammar_Dont_Skip (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res63,
      Kind => Lkt_Grammar_Dont_Skip,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos69 = Pos
                            then No_Token_Index
                            else Row_Pos69 - 1));

      
      Initialize_Fields_For_Grammar_Dont_Skip
        (Self => Transform_Res63,
         Grammar_Dont_Skip_F_Expr => Defer_Res94,
         Grammar_Dont_Skip_F_Dont_Skip => Defer_Res95);

         if Defer_Res94 /= null and then Is_Incomplete (Defer_Res94) then
            Transform_Res63.Last_Attempted_Child := 0;
         elsif Defer_Res94 /= null and then not Is_Ghost (Defer_Res94) then
            Transform_Res63.Last_Attempted_Child := -1;
         end if;
         if Defer_Res95 /= null and then Is_Incomplete (Defer_Res95) then
            Transform_Res63.Last_Attempted_Child := 0;
         elsif Defer_Res95 /= null and then not Is_Ghost (Defer_Res95) then
            Transform_Res63.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos69 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags63);
end if;

--  END <Transform(<CompiledType BareGrammarDontSkip>) (root of 'grammar_expr') at parser.lkt:60:11>

    if Row_Pos69 /= No_Token_Index then
        Or_Pos15 := Row_Pos69;
        Or_Res15 := Transform_Res63;
        goto Exit_Or15;
    end if;
    
--  BEGIN <Transform(<CompiledType BareGrammarPredicate>) (root of 'grammar_expr') at parser.lkt:63:11>

Transform_Diags64 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_expr') at ???>

Row_Pos70 := Pos;



--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:64:13>

Defer_Res96 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos70);
Defer_Pos96 := Parser.Current_Pos;

--  END <Defer (for 'grammar_expr') at parser.lkt:64:13>




if Defer_Pos96 /= No_Token_Index then

   Row_Pos70 := Defer_Pos96;

else
   Row_Pos70 := No_Token_Index;
   goto Exit_Row70_0;

end if;


--  BEGIN <Token(<WithText Comb>, ) (root of 'grammar_expr') at parser.lkt:64:26>

Token_Res103 := Row_Pos70;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res103));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comb)
   then
       Token_Pos103 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos70 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos70,
             Expected_Token_Id => Lkt_Comb,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos103 := Row_Pos70 + 1;
   end if;
end;

--  END <Token(<WithText Comb>, ) (root of 'grammar_expr') at parser.lkt:64:26>




if Token_Pos103 /= No_Token_Index then

   Row_Pos70 := Token_Pos103;

else
   Row_Pos70 := No_Token_Index;
   goto Exit_Row70_0;

end if;


--  BEGIN <Token(<WithSymbol Identifier>, when) (root of 'grammar_expr') at parser.lkt:64:31>

Token_Res104 := Row_Pos70;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res104));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_When)
   then
       Token_Pos104 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos70 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos70,
             Expected_Token_Id => Lkt_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos104 := Row_Pos70 + 1;
   end if;
end;

--  END <Token(<WithSymbol Identifier>, when) (root of 'grammar_expr') at parser.lkt:64:31>




if Token_Pos104 /= No_Token_Index then

   Row_Pos70 := Token_Pos104;

else
   Row_Pos70 := No_Token_Index;
   goto Exit_Row70_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_expr') at parser.lkt:64:51>

Token_Res105 := Row_Pos70;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res105));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos105 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos70 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos70,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos105 := Row_Pos70 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'grammar_expr') at parser.lkt:64:51>




if Token_Pos105 /= No_Token_Index then

   Row_Pos70 := Token_Pos105;

else
   Row_Pos70 := No_Token_Index;
   goto Exit_Row70_0;

end if;


--  BEGIN <Defer (for 'basic_name') at parser.lkt:64:55>

Defer_Res97 :=
   Basic_Name_Or_Parse0 (Parser, Row_Pos70);
Defer_Pos97 := Parser.Current_Pos;

--  END <Defer (for 'basic_name') at parser.lkt:64:55>




if Defer_Pos97 /= No_Token_Index then

   Row_Pos70 := Defer_Pos97;

else
   Row_Pos70 := No_Token_Index;
   goto Exit_Row70_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_expr') at parser.lkt:64:66>

Token_Res106 := Row_Pos70;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res106));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos106 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos70 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos70,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos106 := Row_Pos70 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'grammar_expr') at parser.lkt:64:66>




if Token_Pos106 /= No_Token_Index then

   Row_Pos70 := Token_Pos106;

else
   Row_Pos70 := No_Token_Index;
   goto Exit_Row70_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row70_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_expr') at ???>



if Row_Pos70 /= No_Token_Index then

   Transform_Res64 := Allocate_Grammar_Predicate (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res64,
      Kind => Lkt_Grammar_Predicate,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos70 = Pos
                            then No_Token_Index
                            else Row_Pos70 - 1));

      
      Initialize_Fields_For_Grammar_Predicate
        (Self => Transform_Res64,
         Grammar_Predicate_F_Expr => Defer_Res96,
         Grammar_Predicate_F_Prop_Ref => Defer_Res97);

         if Defer_Res96 /= null and then Is_Incomplete (Defer_Res96) then
            Transform_Res64.Last_Attempted_Child := 0;
         elsif Defer_Res96 /= null and then not Is_Ghost (Defer_Res96) then
            Transform_Res64.Last_Attempted_Child := -1;
         end if;
         if Defer_Res97 /= null and then Is_Incomplete (Defer_Res97) then
            Transform_Res64.Last_Attempted_Child := 0;
         elsif Defer_Res97 /= null and then not Is_Ghost (Defer_Res97) then
            Transform_Res64.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos70 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags64);
end if;

--  END <Transform(<CompiledType BareGrammarPredicate>) (root of 'grammar_expr') at parser.lkt:63:11>

    if Row_Pos70 /= No_Token_Index then
        Or_Pos15 := Row_Pos70;
        Or_Res15 := Transform_Res64;
        goto Exit_Or15;
    end if;
    
--  BEGIN <Defer (for 'grammar_primary') at parser.lkt:66:11>

Defer_Res98 :=
   Grammar_Primary_Or_Parse0 (Parser, Pos);
Defer_Pos98 := Parser.Current_Pos;

--  END <Defer (for 'grammar_primary') at parser.lkt:66:11>

    if Defer_Pos98 /= No_Token_Index then
        Or_Pos15 := Defer_Pos98;
        Or_Res15 := Defer_Res98;
        goto Exit_Or15;
    end if;
<<Exit_Or15>>

--  END <Or (root of 'grammar_expr') at parser.lkt:59:21>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos15 > Mem_Pos then
         Mem_Pos := Or_Pos15;
         Mem_Res := Or_Res15;
         Set
           (PP.Grammar_Expr_Or_Parse0_Memo,
            Or_Pos15 /= No_Token_Index,
            Or_Res15,
            Pos,
            Or_Pos15);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res15 := Mem_Res;
         Or_Pos15 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (PP.Grammar_Expr_Or_Parse0_Memo,
      Or_Pos15 /= No_Token_Index,
      Or_Res15,
      Pos,
      Or_Pos15);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos15;

   return Or_Res15;
end Grammar_Expr_Or_Parse0;

   


function Grammar_Implicit_Pick_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Implicit_Pick
is
   use Bare_Grammar_Implicit_Pick_Memos;

      Row_Pos71 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos12 :
            Token_Index
               := No_Token_Index;
      Tmp_List12 :
            Free_Parse_List;
      Defer_Pos99 :
            Token_Index
               := No_Token_Index;
      Defer_Res99 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      List_Pos12 :
            Token_Index
               := No_Token_Index;
      List_Res12 :
            Bare_Grammar_Expr_List
               := No_Bare_Lkt_Node;
      Transform_Res65 :
            Bare_Grammar_Implicit_Pick
               := No_Bare_Lkt_Node;
      Transform_Diags65 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Grammar_Implicit_Pick_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res65 := M.Instance;
      return Transform_Res65;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res65;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareGrammarImplicitPick>) (root of 'grammar_implicit_pick') at parser.lkt:71:30>

Transform_Diags65 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_implicit_pick') at ???>

Row_Pos71 := Pos;



--  BEGIN <List (root of 'grammar_implicit_pick') at parser.lkt:71:50>

    List_Pos12 := No_Token_Index;



Lst_Cpos12 := Row_Pos71;
Tmp_List12 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:71:56>

Defer_Res99 :=
   Grammar_Expr_Or_Parse0 (Parser, Lst_Cpos12);
Defer_Pos99 := Parser.Current_Pos;

--  END <Defer (for 'grammar_expr') at parser.lkt:71:56>


   exit when Defer_Pos99 = No_Token_Index;

   List_Pos12 := Defer_Pos99;
   Lst_Cpos12 := List_Pos12;

   Tmp_List12.Nodes.Append (Defer_Res99);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List12.Nodes.Length;
begin
   List_Res12 := Allocate_Grammar_Expr_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos71;
      Token_End := (if Lst_Cpos12 = Row_Pos71
                    then Row_Pos71
                    else List_Pos12 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos71, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res12,
      Kind              => Lkt_Grammar_Expr_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res12,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List12.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res12.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List12);

--  END <List (root of 'grammar_implicit_pick') at parser.lkt:71:50>




if List_Pos12 /= No_Token_Index then

   Row_Pos71 := List_Pos12;

else
   Row_Pos71 := No_Token_Index;
   goto Exit_Row71_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row71_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_implicit_pick') at ???>



if Row_Pos71 /= No_Token_Index then

   Transform_Res65 := Allocate_Grammar_Implicit_Pick (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res65,
      Kind => Lkt_Grammar_Implicit_Pick,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos71 = Pos
                            then No_Token_Index
                            else Row_Pos71 - 1));

      
      Initialize_Fields_For_Grammar_Implicit_Pick
        (Self => Transform_Res65,
         Grammar_Pick_F_Exprs => List_Res12);

         if List_Res12 /= null and then Is_Incomplete (List_Res12) then
            Transform_Res65.Last_Attempted_Child := 0;
         elsif List_Res12 /= null and then not Is_Ghost (List_Res12) then
            Transform_Res65.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos71 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags65);
end if;

--  END <Transform(<CompiledType BareGrammarImplicitPick>) (root of 'grammar_implicit_pick') at parser.lkt:71:30>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Grammar_Implicit_Pick_Transform_Parse0_Memo,
      Row_Pos71 /= No_Token_Index,
      Transform_Res65,
      Pos,
      Row_Pos71);


   Parser.Current_Pos := Row_Pos71;

   return Transform_Res65;
end Grammar_Implicit_Pick_Transform_Parse0;

   


function Grammar_List_Expr_Transform_Parse3
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_List
is
   use Bare_Grammar_List_Memos;

      Row_Pos72 :
            Token_Index
               := No_Token_Index;
      Row_Pos73 :
            Token_Index
               := No_Token_Index;
      Token_Pos107 :
            Token_Index
               := No_Token_Index;
      Token_Res107 :
            Token_Index
               := No_Token_Index;
      Transform_Res66 :
            Bare_Default_List_Type_Ref
               := No_Bare_Lkt_Node;
      Transform_Diags66 :
            Ada.Containers.Count_Type;
      Defer_Pos100 :
            Token_Index
               := No_Token_Index;
      Defer_Res100 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Or_Pos16 :
            Token_Index
               := No_Token_Index;
      Or_Res16 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Row_Pos74 :
            Token_Index
               := No_Token_Index;
      Token_Pos108 :
            Token_Index
               := No_Token_Index;
      Token_Res108 :
            Token_Index
               := No_Token_Index;
      Transform_Res67 :
            Bare_List_Kind_One
               := No_Bare_Lkt_Node;
      Transform_Diags67 :
            Ada.Containers.Count_Type;
      Row_Pos75 :
            Token_Index
               := No_Token_Index;
      Token_Pos109 :
            Token_Index
               := No_Token_Index;
      Token_Res109 :
            Token_Index
               := No_Token_Index;
      Transform_Res68 :
            Bare_List_Kind_Zero
               := No_Bare_Lkt_Node;
      Transform_Diags68 :
            Ada.Containers.Count_Type;
      Or_Pos17 :
            Token_Index
               := No_Token_Index;
      Or_Res17 :
            Bare_List_Kind
               := No_Bare_Lkt_Node;
      Token_Pos110 :
            Token_Index
               := No_Token_Index;
      Token_Res110 :
            Token_Index
               := No_Token_Index;
      Defer_Pos101 :
            Token_Index
               := No_Token_Index;
      Defer_Res101 :
            Bare_Grammar_Implicit_Pick
               := No_Bare_Lkt_Node;
      Defer_Pos102 :
            Token_Index
               := No_Token_Index;
      Defer_Res102 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      Or_Pos18 :
            Token_Index
               := No_Token_Index;
      Or_Res18 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      Row_Pos76 :
            Token_Index
               := No_Token_Index;
      Token_Pos111 :
            Token_Index
               := No_Token_Index;
      Token_Res111 :
            Token_Index
               := No_Token_Index;
      Defer_Pos103 :
            Token_Index
               := No_Token_Index;
      Defer_Res103 :
            Bare_Grammar_List_Sep
               := No_Bare_Lkt_Node;
      Token_Pos112 :
            Token_Index
               := No_Token_Index;
      Token_Res112 :
            Token_Index
               := No_Token_Index;
      Transform_Res69 :
            Bare_Grammar_List
               := No_Bare_Lkt_Node;
      Transform_Diags69 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Grammar_List_Expr_Transform_Parse3_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res69 := M.Instance;
      return Transform_Res69;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res69;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareGrammarList>) (root of 'grammar_list_expr') at parser.lkt:99:26>

Transform_Diags69 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_list_expr') at ???>

Row_Pos72 := Pos;



--  BEGIN <Or (root of 'grammar_list_expr') at parser.lkt:102:9>

Or_Pos16 := No_Token_Index;
Or_Res16 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareDefaultListTypeRef>) (root of 'grammar_list_expr') at parser.lkt:102:12>

Transform_Diags66 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_list_expr') at ???>

Row_Pos73 := Row_Pos72;



--  BEGIN <Token(<WithSymbol Identifier>, list) (root of 'grammar_list_expr') at parser.lkt:102:31>

Token_Res107 := Row_Pos73;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res107));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_List)
   then
       Token_Pos107 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos73 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos73,
             Expected_Token_Id => Lkt_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos107 := Row_Pos73 + 1;
   end if;
end;

--  END <Token(<WithSymbol Identifier>, list) (root of 'grammar_list_expr') at parser.lkt:102:31>




if Token_Pos107 /= No_Token_Index then

   Row_Pos73 := Token_Pos107;

else
   Row_Pos73 := No_Token_Index;
   goto Exit_Row73_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row73_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_list_expr') at ???>



if Row_Pos73 /= No_Token_Index then

   Transform_Res66 := Allocate_Default_List_Type_Ref (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res66,
      Kind => Lkt_Default_List_Type_Ref,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos72,
      Token_End_Index   => (if Row_Pos73 = Row_Pos72
                            then No_Token_Index
                            else Row_Pos73 - 1));

      
      Initialize_Fields_For_Default_List_Type_Ref
        (Self => Transform_Res66);



elsif Row_Pos73 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags66);
end if;

--  END <Transform(<CompiledType BareDefaultListTypeRef>) (root of 'grammar_list_expr') at parser.lkt:102:12>

    if Row_Pos73 /= No_Token_Index then
        Or_Pos16 := Row_Pos73;
        Or_Res16 := Transform_Res66;
        goto Exit_Or16;
    end if;
    
--  BEGIN <Defer (for 'type_ref') at parser.lkt:102:54>

Defer_Res100 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos72);
Defer_Pos100 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:102:54>

    if Defer_Pos100 /= No_Token_Index then
        Or_Pos16 := Defer_Pos100;
        Or_Res16 := Defer_Res100;
        goto Exit_Or16;
    end if;
<<Exit_Or16>>

--  END <Or (root of 'grammar_list_expr') at parser.lkt:102:9>




if Or_Pos16 /= No_Token_Index then

   Row_Pos72 := Or_Pos16;

else
   Row_Pos72 := No_Token_Index;
   goto Exit_Row72_0;

end if;


--  BEGIN <Or (root of 'grammar_list_expr') at parser.lkt:104:9>

Or_Pos17 := No_Token_Index;
Or_Res17 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareListKindOne>) (root of 'grammar_list_expr') at parser.lkt:104:12>

Transform_Diags67 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_list_expr') at parser.lkt:104:12>

Row_Pos74 := Row_Pos72;



--  BEGIN <Token(<WithText Plus>, ) (root of 'grammar_list_expr') at parser.lkt:104:25>

Token_Res108 := Row_Pos74;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res108));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Plus)
   then
       Token_Pos108 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos74 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos74,
             Expected_Token_Id => Lkt_Plus,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos108 := Row_Pos74 + 1;
   end if;
end;

--  END <Token(<WithText Plus>, ) (root of 'grammar_list_expr') at parser.lkt:104:25>




if Token_Pos108 /= No_Token_Index then

   Row_Pos74 := Token_Pos108;

else
   Row_Pos74 := No_Token_Index;
   goto Exit_Row74_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row74_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_list_expr') at parser.lkt:104:12>



if Row_Pos74 /= No_Token_Index then

   Transform_Res67 := Allocate_List_Kind_One (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res67,
      Kind => Lkt_List_Kind_One,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos72,
      Token_End_Index   => (if Row_Pos74 = Row_Pos72
                            then No_Token_Index
                            else Row_Pos74 - 1));




elsif Row_Pos74 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags67);
end if;

--  END <Transform(<CompiledType BareListKindOne>) (root of 'grammar_list_expr') at parser.lkt:104:12>

    if Row_Pos74 /= No_Token_Index then
        Or_Pos17 := Row_Pos74;
        Or_Res17 := Transform_Res67;
        goto Exit_Or17;
    end if;
    
--  BEGIN <Transform(<CompiledType BareListKindZero>) (root of 'grammar_list_expr') at parser.lkt:104:32>

Transform_Diags68 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_list_expr') at parser.lkt:104:32>

Row_Pos75 := Row_Pos72;



--  BEGIN <Token(<WithText Times>, ) (root of 'grammar_list_expr') at parser.lkt:104:46>

Token_Res109 := Row_Pos75;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res109));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Times)
   then
       Token_Pos109 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos75 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos75,
             Expected_Token_Id => Lkt_Times,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos109 := Row_Pos75 + 1;
   end if;
end;

--  END <Token(<WithText Times>, ) (root of 'grammar_list_expr') at parser.lkt:104:46>




if Token_Pos109 /= No_Token_Index then

   Row_Pos75 := Token_Pos109;

else
   Row_Pos75 := No_Token_Index;
   goto Exit_Row75_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row75_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_list_expr') at parser.lkt:104:32>



if Row_Pos75 /= No_Token_Index then

   Transform_Res68 := Allocate_List_Kind_Zero (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res68,
      Kind => Lkt_List_Kind_Zero,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos72,
      Token_End_Index   => (if Row_Pos75 = Row_Pos72
                            then No_Token_Index
                            else Row_Pos75 - 1));




elsif Row_Pos75 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags68);
end if;

--  END <Transform(<CompiledType BareListKindZero>) (root of 'grammar_list_expr') at parser.lkt:104:32>

    if Row_Pos75 /= No_Token_Index then
        Or_Pos17 := Row_Pos75;
        Or_Res17 := Transform_Res68;
        goto Exit_Or17;
    end if;
<<Exit_Or17>>

--  END <Or (root of 'grammar_list_expr') at parser.lkt:104:9>




if Or_Pos17 /= No_Token_Index then

   Row_Pos72 := Or_Pos17;

else
   Row_Pos72 := No_Token_Index;
   goto Exit_Row72_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_list_expr') at parser.lkt:105:9>

Token_Res110 := Row_Pos72;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res110));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos110 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos72 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos72,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos110 := Row_Pos72 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'grammar_list_expr') at parser.lkt:105:9>




if Token_Pos110 /= No_Token_Index then

   Row_Pos72 := Token_Pos110;

else
   Row_Pos72 := No_Token_Index;
   goto Exit_Row72_0;

end if;


--  BEGIN <Or (root of 'grammar_list_expr') at parser.lkt:108:9>

Or_Pos18 := No_Token_Index;
Or_Res18 := No_Bare_Lkt_Node;
    
--  BEGIN <Defer (for 'grammar_implicit_pick') at parser.lkt:108:12>

Defer_Res101 :=
   Grammar_Implicit_Pick_Transform_Parse0 (Parser, Row_Pos72);
Defer_Pos101 := Parser.Current_Pos;

--  END <Defer (for 'grammar_implicit_pick') at parser.lkt:108:12>

    if Defer_Pos101 /= No_Token_Index then
        Or_Pos18 := Defer_Pos101;
        Or_Res18 := Defer_Res101;
        goto Exit_Or18;
    end if;
    
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:108:36>

Defer_Res102 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos72);
Defer_Pos102 := Parser.Current_Pos;

--  END <Defer (for 'grammar_expr') at parser.lkt:108:36>

    if Defer_Pos102 /= No_Token_Index then
        Or_Pos18 := Defer_Pos102;
        Or_Res18 := Defer_Res102;
        goto Exit_Or18;
    end if;
<<Exit_Or18>>

--  END <Or (root of 'grammar_list_expr') at parser.lkt:108:9>




if Or_Pos18 /= No_Token_Index then

   Row_Pos72 := Or_Pos18;

else
   Row_Pos72 := No_Token_Index;
   goto Exit_Row72_0;

end if;


--  BEGIN <Opt (root of 'grammar_list_expr') at parser.lkt:111:9>












--  BEGIN <_Extract (root of 'grammar_list_expr') at parser.lkt:111:10>

--  BEGIN <_Row (root of 'grammar_list_expr') at ???>

Row_Pos76 := Row_Pos72;



--  BEGIN <Token(<WithText Comma>, ) (root of 'grammar_list_expr') at parser.lkt:111:15>

Token_Res111 := Row_Pos76;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res111));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos111 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos76 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos76,
             Expected_Token_Id => Lkt_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos111 := Row_Pos76 + 1;
   end if;
end;

--  END <Token(<WithText Comma>, ) (root of 'grammar_list_expr') at parser.lkt:111:15>




if Token_Pos111 /= No_Token_Index then

   Row_Pos76 := Token_Pos111;

else
   Row_Pos76 := No_Token_Index;
   goto Exit_Row76_0;

end if;


--  BEGIN <Defer (for 'grammar_list_sep') at parser.lkt:111:19>

Defer_Res103 :=
   Grammar_List_Sep_Transform_Parse0 (Parser, Row_Pos76);
Defer_Pos103 := Parser.Current_Pos;

--  END <Defer (for 'grammar_list_sep') at parser.lkt:111:19>




if Defer_Pos103 /= No_Token_Index then

   Row_Pos76 := Defer_Pos103;

else
   Row_Pos76 := No_Token_Index;
   goto Exit_Row76_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row76_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_list_expr') at ???>

--  END <_Extract (root of 'grammar_list_expr') at parser.lkt:111:10>


if Row_Pos76 = No_Token_Index then

         
   Defer_Res103 := No_Bare_Lkt_Node;



       
   Row_Pos76 := Row_Pos72;



end if;

--  END <Opt (root of 'grammar_list_expr') at parser.lkt:111:9>




if Row_Pos76 /= No_Token_Index then

   Row_Pos72 := Row_Pos76;

else
   Row_Pos72 := No_Token_Index;
   goto Exit_Row72_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_list_expr') at parser.lkt:112:9>

Token_Res112 := Row_Pos72;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res112));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos112 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos72 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos72,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos112 := Row_Pos72 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'grammar_list_expr') at parser.lkt:112:9>




if Token_Pos112 /= No_Token_Index then

   Row_Pos72 := Token_Pos112;

else
   Row_Pos72 := No_Token_Index;
   goto Exit_Row72_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row72_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_list_expr') at ???>



if Row_Pos72 /= No_Token_Index then

   Transform_Res69 := Allocate_Grammar_List (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res69,
      Kind => Lkt_Grammar_List,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos72 = Pos
                            then No_Token_Index
                            else Row_Pos72 - 1));

      
      Initialize_Fields_For_Grammar_List
        (Self => Transform_Res69,
         Grammar_List_F_List_Type => Or_Res16,
         Grammar_List_F_Kind => Or_Res17,
         Grammar_List_F_Expr => Or_Res18,
         Grammar_List_F_Sep => Defer_Res103);

         if Or_Res16 /= null and then Is_Incomplete (Or_Res16) then
            Transform_Res69.Last_Attempted_Child := 0;
         elsif Or_Res16 /= null and then not Is_Ghost (Or_Res16) then
            Transform_Res69.Last_Attempted_Child := -1;
         end if;
         if Or_Res17 /= null and then Is_Incomplete (Or_Res17) then
            Transform_Res69.Last_Attempted_Child := 0;
         elsif Or_Res17 /= null and then not Is_Ghost (Or_Res17) then
            Transform_Res69.Last_Attempted_Child := -1;
         end if;
         if Or_Res18 /= null and then Is_Incomplete (Or_Res18) then
            Transform_Res69.Last_Attempted_Child := 0;
         elsif Or_Res18 /= null and then not Is_Ghost (Or_Res18) then
            Transform_Res69.Last_Attempted_Child := -1;
         end if;
         if Defer_Res103 /= null and then Is_Incomplete (Defer_Res103) then
            Transform_Res69.Last_Attempted_Child := 0;
         elsif Defer_Res103 /= null and then not Is_Ghost (Defer_Res103) then
            Transform_Res69.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos72 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags69);
end if;

--  END <Transform(<CompiledType BareGrammarList>) (root of 'grammar_list_expr') at parser.lkt:99:26>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Grammar_List_Expr_Transform_Parse3_Memo,
      Row_Pos72 /= No_Token_Index,
      Transform_Res69,
      Pos,
      Row_Pos72);


   Parser.Current_Pos := Row_Pos72;

   return Transform_Res69;
end Grammar_List_Expr_Transform_Parse3;

   


function Grammar_List_Sep_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_List_Sep
is
   use Bare_Grammar_List_Sep_Memos;

      Row_Pos77 :
            Token_Index
               := No_Token_Index;
      Defer_Pos104 :
            Token_Index
               := No_Token_Index;
      Defer_Res104 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      Row_Pos78 :
            Token_Index
               := No_Token_Index;
      Token_Pos113 :
            Token_Index
               := No_Token_Index;
      Token_Res113 :
            Token_Index
               := No_Token_Index;
      Defer_Pos105 :
            Token_Index
               := No_Token_Index;
      Defer_Res105 :
            Bare_Id
               := No_Bare_Lkt_Node;
      Transform_Res70 :
            Bare_Grammar_List_Sep
               := No_Bare_Lkt_Node;
      Transform_Diags70 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Grammar_List_Sep_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res70 := M.Instance;
      return Transform_Res70;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res70;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareGrammarListSep>) (root of 'grammar_list_sep') at parser.lkt:114:25>

Transform_Diags70 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_list_sep') at ???>

Row_Pos77 := Pos;



--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:114:40>

Defer_Res104 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos77);
Defer_Pos104 := Parser.Current_Pos;

--  END <Defer (for 'grammar_expr') at parser.lkt:114:40>




if Defer_Pos104 /= No_Token_Index then

   Row_Pos77 := Defer_Pos104;

else
   Row_Pos77 := No_Token_Index;
   goto Exit_Row77_0;

end if;


--  BEGIN <Opt (root of 'grammar_list_sep') at parser.lkt:114:53>












--  BEGIN <_Extract (root of 'grammar_list_sep') at parser.lkt:114:54>

--  BEGIN <_Row (root of 'grammar_list_sep') at ???>

Row_Pos78 := Row_Pos77;



--  BEGIN <Token(<WithText Comma>, ) (root of 'grammar_list_sep') at parser.lkt:114:59>

Token_Res113 := Row_Pos78;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res113));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos113 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos78 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos78,
             Expected_Token_Id => Lkt_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos113 := Row_Pos78 + 1;
   end if;
end;

--  END <Token(<WithText Comma>, ) (root of 'grammar_list_sep') at parser.lkt:114:59>




if Token_Pos113 /= No_Token_Index then

   Row_Pos78 := Token_Pos113;

else
   Row_Pos78 := No_Token_Index;
   goto Exit_Row78_0;

end if;


--  BEGIN <Defer (for 'id') at parser.lkt:114:63>

Defer_Res105 :=
   Id_Transform_Parse0 (Parser, Row_Pos78);
Defer_Pos105 := Parser.Current_Pos;

--  END <Defer (for 'id') at parser.lkt:114:63>




if Defer_Pos105 /= No_Token_Index then

   Row_Pos78 := Defer_Pos105;

else
   Row_Pos78 := No_Token_Index;
   goto Exit_Row78_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row78_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_list_sep') at ???>

--  END <_Extract (root of 'grammar_list_sep') at parser.lkt:114:54>


if Row_Pos78 = No_Token_Index then

         
   Defer_Res105 := No_Bare_Lkt_Node;



       
   Row_Pos78 := Row_Pos77;



end if;

--  END <Opt (root of 'grammar_list_sep') at parser.lkt:114:53>




if Row_Pos78 /= No_Token_Index then

   Row_Pos77 := Row_Pos78;

else
   Row_Pos77 := No_Token_Index;
   goto Exit_Row77_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row77_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_list_sep') at ???>



if Row_Pos77 /= No_Token_Index then

   Transform_Res70 := Allocate_Grammar_List_Sep (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res70,
      Kind => Lkt_Grammar_List_Sep,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos77 = Pos
                            then No_Token_Index
                            else Row_Pos77 - 1));

      
      Initialize_Fields_For_Grammar_List_Sep
        (Self => Transform_Res70,
         Grammar_List_Sep_F_Token => Defer_Res104,
         Grammar_List_Sep_F_Extra => Defer_Res105);

         if Defer_Res104 /= null and then Is_Incomplete (Defer_Res104) then
            Transform_Res70.Last_Attempted_Child := 0;
         elsif Defer_Res104 /= null and then not Is_Ghost (Defer_Res104) then
            Transform_Res70.Last_Attempted_Child := -1;
         end if;
         if Defer_Res105 /= null and then Is_Incomplete (Defer_Res105) then
            Transform_Res70.Last_Attempted_Child := 0;
         elsif Defer_Res105 /= null and then not Is_Ghost (Defer_Res105) then
            Transform_Res70.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos77 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags70);
end if;

--  END <Transform(<CompiledType BareGrammarListSep>) (root of 'grammar_list_sep') at parser.lkt:114:25>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Grammar_List_Sep_Transform_Parse0_Memo,
      Row_Pos77 /= No_Token_Index,
      Transform_Res70,
      Pos,
      Row_Pos77);


   Parser.Current_Pos := Row_Pos77;

   return Transform_Res70;
end Grammar_List_Sep_Transform_Parse0;

   


function Grammar_Null_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Null
is
   use Bare_Grammar_Null_Memos;

      Row_Pos79 :
            Token_Index
               := No_Token_Index;
      Token_Pos114 :
            Token_Index
               := No_Token_Index;
      Token_Res114 :
            Token_Index
               := No_Token_Index;
      Token_Pos115 :
            Token_Index
               := No_Token_Index;
      Token_Res115 :
            Token_Index
               := No_Token_Index;
      Defer_Pos106 :
            Token_Index
               := No_Token_Index;
      Defer_Res106 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Token_Pos116 :
            Token_Index
               := No_Token_Index;
      Token_Res116 :
            Token_Index
               := No_Token_Index;
      Transform_Res71 :
            Bare_Grammar_Null
               := No_Bare_Lkt_Node;
      Transform_Diags71 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Grammar_Null_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res71 := M.Instance;
      return Transform_Res71;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res71;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareGrammarNull>) (root of 'grammar_null') at parser.lkt:116:21>

Transform_Diags71 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_null') at ???>

Row_Pos79 := Pos;



--  BEGIN <Token(<WithText NullKw>, ) (root of 'grammar_null') at parser.lkt:116:33>

Token_Res114 := Row_Pos79;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res114));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Null_Kw)
   then
       Token_Pos114 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos79 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos79,
             Expected_Token_Id => Lkt_Null_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos114 := Row_Pos79 + 1;
   end if;
end;

--  END <Token(<WithText NullKw>, ) (root of 'grammar_null') at parser.lkt:116:33>




if Token_Pos114 /= No_Token_Index then

   Row_Pos79 := Token_Pos114;

else
   Row_Pos79 := No_Token_Index;
   goto Exit_Row79_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_null') at parser.lkt:116:40>

Token_Res115 := Row_Pos79;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res115));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos115 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos79 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos79,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos115 := Row_Pos79 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'grammar_null') at parser.lkt:116:40>




if Token_Pos115 /= No_Token_Index then

   Row_Pos79 := Token_Pos115;

else
   Row_Pos79 := No_Token_Index;
   goto Exit_Row79_0;

end if;


--  BEGIN <Defer (for 'type_ref') at parser.lkt:116:44>

Defer_Res106 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos79);
Defer_Pos106 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:116:44>




if Defer_Pos106 /= No_Token_Index then

   Row_Pos79 := Defer_Pos106;

else
   Row_Pos79 := No_Token_Index;
   goto Exit_Row79_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_null') at parser.lkt:116:53>

Token_Res116 := Row_Pos79;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res116));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos116 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos79 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos79,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos116 := Row_Pos79 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'grammar_null') at parser.lkt:116:53>




if Token_Pos116 /= No_Token_Index then

   Row_Pos79 := Token_Pos116;

else
   Row_Pos79 := No_Token_Index;
   goto Exit_Row79_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row79_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_null') at ???>



if Row_Pos79 /= No_Token_Index then

   Transform_Res71 := Allocate_Grammar_Null (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res71,
      Kind => Lkt_Grammar_Null,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos79 = Pos
                            then No_Token_Index
                            else Row_Pos79 - 1));

      
      Initialize_Fields_For_Grammar_Null
        (Self => Transform_Res71,
         Grammar_Null_F_Name => Defer_Res106);

         if Defer_Res106 /= null and then Is_Incomplete (Defer_Res106) then
            Transform_Res71.Last_Attempted_Child := 0;
         elsif Defer_Res106 /= null and then not Is_Ghost (Defer_Res106) then
            Transform_Res71.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos79 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags71);
end if;

--  END <Transform(<CompiledType BareGrammarNull>) (root of 'grammar_null') at parser.lkt:116:21>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Grammar_Null_Transform_Parse0_Memo,
      Row_Pos79 /= No_Token_Index,
      Transform_Res71,
      Pos,
      Row_Pos79);


   Parser.Current_Pos := Row_Pos79;

   return Transform_Res71;
end Grammar_Null_Transform_Parse0;

   


function Grammar_Opt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr
is
   use Bare_Grammar_Expr_Memos;

      Row_Pos80 :
            Token_Index
               := No_Token_Index;
      Token_Pos117 :
            Token_Index
               := No_Token_Index;
      Token_Res117 :
            Token_Index
               := No_Token_Index;
      Defer_Pos107 :
            Token_Index
               := No_Token_Index;
      Defer_Res107 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      Transform_Res72 :
            Bare_Grammar_Opt
               := No_Bare_Lkt_Node;
      Transform_Diags72 :
            Ada.Containers.Count_Type;
      Row_Pos81 :
            Token_Index
               := No_Token_Index;
      Token_Pos118 :
            Token_Index
               := No_Token_Index;
      Token_Res118 :
            Token_Index
               := No_Token_Index;
      Token_Pos119 :
            Token_Index
               := No_Token_Index;
      Token_Res119 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos13 :
            Token_Index
               := No_Token_Index;
      Tmp_List13 :
            Free_Parse_List;
      Defer_Pos108 :
            Token_Index
               := No_Token_Index;
      Defer_Res108 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      List_Pos13 :
            Token_Index
               := No_Token_Index;
      List_Res13 :
            Bare_Grammar_Expr_List
               := No_Bare_Lkt_Node;
      Token_Pos120 :
            Token_Index
               := No_Token_Index;
      Token_Res120 :
            Token_Index
               := No_Token_Index;
      Transform_Res73 :
            Bare_Grammar_Opt_Group
               := No_Bare_Lkt_Node;
      Transform_Diags73 :
            Ada.Containers.Count_Type;
      Or_Pos19 :
            Token_Index
               := No_Token_Index;
      Or_Res19 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Grammar_Opt_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res19 := M.Instance;
      return Or_Res19;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res19;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'grammar_opt') at parser.lkt:72:20>

Or_Pos19 := No_Token_Index;
Or_Res19 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareGrammarOpt>) (root of 'grammar_opt') at parser.lkt:73:11>

Transform_Diags72 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_opt') at ???>

Row_Pos80 := Pos;



--  BEGIN <Token(<WithText IntMark>, ) (root of 'grammar_opt') at parser.lkt:73:22>

Token_Res117 := Row_Pos80;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res117));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Int_Mark)
   then
       Token_Pos117 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos80 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos80,
             Expected_Token_Id => Lkt_Int_Mark,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos117 := Row_Pos80 + 1;
   end if;
end;

--  END <Token(<WithText IntMark>, ) (root of 'grammar_opt') at parser.lkt:73:22>




if Token_Pos117 /= No_Token_Index then

   Row_Pos80 := Token_Pos117;

else
   Row_Pos80 := No_Token_Index;
   goto Exit_Row80_0;

end if;


--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:73:26>

Defer_Res107 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos80);
Defer_Pos107 := Parser.Current_Pos;

--  END <Defer (for 'grammar_expr') at parser.lkt:73:26>




if Defer_Pos107 /= No_Token_Index then

   Row_Pos80 := Defer_Pos107;

else
   Row_Pos80 := No_Token_Index;
   goto Exit_Row80_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row80_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_opt') at ???>



if Row_Pos80 /= No_Token_Index then

   Transform_Res72 := Allocate_Grammar_Opt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res72,
      Kind => Lkt_Grammar_Opt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos80 = Pos
                            then No_Token_Index
                            else Row_Pos80 - 1));

      
      Initialize_Fields_For_Grammar_Opt
        (Self => Transform_Res72,
         Grammar_Opt_F_Expr => Defer_Res107);

         if Defer_Res107 /= null and then Is_Incomplete (Defer_Res107) then
            Transform_Res72.Last_Attempted_Child := 0;
         elsif Defer_Res107 /= null and then not Is_Ghost (Defer_Res107) then
            Transform_Res72.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos80 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags72);
end if;

--  END <Transform(<CompiledType BareGrammarOpt>) (root of 'grammar_opt') at parser.lkt:73:11>

    if Row_Pos80 /= No_Token_Index then
        Or_Pos19 := Row_Pos80;
        Or_Res19 := Transform_Res72;
        goto Exit_Or19;
    end if;
    
--  BEGIN <Transform(<CompiledType BareGrammarOptGroup>) (root of 'grammar_opt') at parser.lkt:74:11>

Transform_Diags73 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_opt') at ???>

Row_Pos81 := Pos;



--  BEGIN <Token(<WithText IntMark>, ) (root of 'grammar_opt') at parser.lkt:74:27>

Token_Res118 := Row_Pos81;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res118));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Int_Mark)
   then
       Token_Pos118 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos81 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos81,
             Expected_Token_Id => Lkt_Int_Mark,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos118 := Row_Pos81 + 1;
   end if;
end;

--  END <Token(<WithText IntMark>, ) (root of 'grammar_opt') at parser.lkt:74:27>




if Token_Pos118 /= No_Token_Index then

   Row_Pos81 := Token_Pos118;

else
   Row_Pos81 := No_Token_Index;
   goto Exit_Row81_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_opt') at parser.lkt:74:31>

Token_Res119 := Row_Pos81;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res119));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos119 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos81 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos81,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos119 := Row_Pos81 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'grammar_opt') at parser.lkt:74:31>




if Token_Pos119 /= No_Token_Index then

   Row_Pos81 := Token_Pos119;

else
   Row_Pos81 := No_Token_Index;
   goto Exit_Row81_0;

end if;


--  BEGIN <List (root of 'grammar_opt') at parser.lkt:74:35>

    List_Pos13 := Row_Pos81;



Lst_Cpos13 := Row_Pos81;
Tmp_List13 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:74:41>

Defer_Res108 :=
   Grammar_Expr_Or_Parse0 (Parser, Lst_Cpos13);
Defer_Pos108 := Parser.Current_Pos;

--  END <Defer (for 'grammar_expr') at parser.lkt:74:41>


   exit when Defer_Pos108 = No_Token_Index;

   List_Pos13 := Defer_Pos108;
   Lst_Cpos13 := List_Pos13;

   Tmp_List13.Nodes.Append (Defer_Res108);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List13.Nodes.Length;
begin
   List_Res13 := Allocate_Grammar_Expr_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos81;
      Token_End := (if Lst_Cpos13 = Row_Pos81
                    then Row_Pos81
                    else List_Pos13 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos81, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res13,
      Kind              => Lkt_Grammar_Expr_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res13,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List13.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res13.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List13);

--  END <List (root of 'grammar_opt') at parser.lkt:74:35>




if List_Pos13 /= No_Token_Index then

   Row_Pos81 := List_Pos13;

else
   Row_Pos81 := No_Token_Index;
   goto Exit_Row81_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_opt') at parser.lkt:74:55>

Token_Res120 := Row_Pos81;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res120));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos120 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos81 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos81,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos120 := Row_Pos81 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'grammar_opt') at parser.lkt:74:55>




if Token_Pos120 /= No_Token_Index then

   Row_Pos81 := Token_Pos120;

else
   Row_Pos81 := No_Token_Index;
   goto Exit_Row81_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row81_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_opt') at ???>



if Row_Pos81 /= No_Token_Index then

   Transform_Res73 := Allocate_Grammar_Opt_Group (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res73,
      Kind => Lkt_Grammar_Opt_Group,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos81 = Pos
                            then No_Token_Index
                            else Row_Pos81 - 1));

      
      Initialize_Fields_For_Grammar_Opt_Group
        (Self => Transform_Res73,
         Grammar_Opt_Group_F_Expr => List_Res13);

         if List_Res13 /= null and then Is_Incomplete (List_Res13) then
            Transform_Res73.Last_Attempted_Child := 0;
         elsif List_Res13 /= null and then not Is_Ghost (List_Res13) then
            Transform_Res73.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos81 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags73);
end if;

--  END <Transform(<CompiledType BareGrammarOptGroup>) (root of 'grammar_opt') at parser.lkt:74:11>

    if Row_Pos81 /= No_Token_Index then
        Or_Pos19 := Row_Pos81;
        Or_Res19 := Transform_Res73;
        goto Exit_Or19;
    end if;
<<Exit_Or19>>

--  END <Or (root of 'grammar_opt') at parser.lkt:72:20>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Grammar_Opt_Or_Parse0_Memo,
      Or_Pos19 /= No_Token_Index,
      Or_Res19,
      Pos,
      Or_Pos19);


   Parser.Current_Pos := Or_Pos19;

   return Or_Res19;
end Grammar_Opt_Or_Parse0;

   


function Grammar_Opt_Error_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr
is
   use Bare_Grammar_Expr_Memos;

      Row_Pos82 :
            Token_Index
               := No_Token_Index;
      Token_Pos121 :
            Token_Index
               := No_Token_Index;
      Token_Res121 :
            Token_Index
               := No_Token_Index;
      Defer_Pos109 :
            Token_Index
               := No_Token_Index;
      Defer_Res109 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      Transform_Res74 :
            Bare_Grammar_Opt_Error
               := No_Bare_Lkt_Node;
      Transform_Diags74 :
            Ada.Containers.Count_Type;
      Row_Pos83 :
            Token_Index
               := No_Token_Index;
      Token_Pos122 :
            Token_Index
               := No_Token_Index;
      Token_Res122 :
            Token_Index
               := No_Token_Index;
      Token_Pos123 :
            Token_Index
               := No_Token_Index;
      Token_Res123 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos14 :
            Token_Index
               := No_Token_Index;
      Tmp_List14 :
            Free_Parse_List;
      Defer_Pos110 :
            Token_Index
               := No_Token_Index;
      Defer_Res110 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      List_Pos14 :
            Token_Index
               := No_Token_Index;
      List_Res14 :
            Bare_Grammar_Expr_List
               := No_Bare_Lkt_Node;
      Token_Pos124 :
            Token_Index
               := No_Token_Index;
      Token_Res124 :
            Token_Index
               := No_Token_Index;
      Transform_Res75 :
            Bare_Grammar_Opt_Error_Group
               := No_Bare_Lkt_Node;
      Transform_Diags75 :
            Ada.Containers.Count_Type;
      Or_Pos20 :
            Token_Index
               := No_Token_Index;
      Or_Res20 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Grammar_Opt_Error_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res20 := M.Instance;
      return Or_Res20;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res20;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'grammar_opt_error') at parser.lkt:76:26>

Or_Pos20 := No_Token_Index;
Or_Res20 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareGrammarOptError>) (root of 'grammar_opt_error') at parser.lkt:77:11>

Transform_Diags74 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_opt_error') at ???>

Row_Pos82 := Pos;



--  BEGIN <Token(<WithText ExclMark>, ) (root of 'grammar_opt_error') at parser.lkt:77:27>

Token_Res121 := Row_Pos82;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res121));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Excl_Mark)
   then
       Token_Pos121 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos82 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos82,
             Expected_Token_Id => Lkt_Excl_Mark,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos121 := Row_Pos82 + 1;
   end if;
end;

--  END <Token(<WithText ExclMark>, ) (root of 'grammar_opt_error') at parser.lkt:77:27>




if Token_Pos121 /= No_Token_Index then

   Row_Pos82 := Token_Pos121;

else
   Row_Pos82 := No_Token_Index;
   goto Exit_Row82_0;

end if;


--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:77:31>

Defer_Res109 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos82);
Defer_Pos109 := Parser.Current_Pos;

--  END <Defer (for 'grammar_expr') at parser.lkt:77:31>




if Defer_Pos109 /= No_Token_Index then

   Row_Pos82 := Defer_Pos109;

else
   Row_Pos82 := No_Token_Index;
   goto Exit_Row82_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row82_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_opt_error') at ???>



if Row_Pos82 /= No_Token_Index then

   Transform_Res74 := Allocate_Grammar_Opt_Error (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res74,
      Kind => Lkt_Grammar_Opt_Error,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos82 = Pos
                            then No_Token_Index
                            else Row_Pos82 - 1));

      
      Initialize_Fields_For_Grammar_Opt_Error
        (Self => Transform_Res74,
         Grammar_Opt_Error_F_Expr => Defer_Res109);

         if Defer_Res109 /= null and then Is_Incomplete (Defer_Res109) then
            Transform_Res74.Last_Attempted_Child := 0;
         elsif Defer_Res109 /= null and then not Is_Ghost (Defer_Res109) then
            Transform_Res74.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos82 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags74);
end if;

--  END <Transform(<CompiledType BareGrammarOptError>) (root of 'grammar_opt_error') at parser.lkt:77:11>

    if Row_Pos82 /= No_Token_Index then
        Or_Pos20 := Row_Pos82;
        Or_Res20 := Transform_Res74;
        goto Exit_Or20;
    end if;
    
--  BEGIN <Transform(<CompiledType BareGrammarOptErrorGroup>) (root of 'grammar_opt_error') at parser.lkt:78:11>

Transform_Diags75 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_opt_error') at ???>

Row_Pos83 := Pos;



--  BEGIN <Token(<WithText ExclMark>, ) (root of 'grammar_opt_error') at parser.lkt:78:32>

Token_Res122 := Row_Pos83;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res122));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Excl_Mark)
   then
       Token_Pos122 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos83 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos83,
             Expected_Token_Id => Lkt_Excl_Mark,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos122 := Row_Pos83 + 1;
   end if;
end;

--  END <Token(<WithText ExclMark>, ) (root of 'grammar_opt_error') at parser.lkt:78:32>




if Token_Pos122 /= No_Token_Index then

   Row_Pos83 := Token_Pos122;

else
   Row_Pos83 := No_Token_Index;
   goto Exit_Row83_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_opt_error') at parser.lkt:78:36>

Token_Res123 := Row_Pos83;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res123));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos123 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos83 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos83,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos123 := Row_Pos83 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'grammar_opt_error') at parser.lkt:78:36>




if Token_Pos123 /= No_Token_Index then

   Row_Pos83 := Token_Pos123;

else
   Row_Pos83 := No_Token_Index;
   goto Exit_Row83_0;

end if;


--  BEGIN <List (root of 'grammar_opt_error') at parser.lkt:78:40>

    List_Pos14 := Row_Pos83;



Lst_Cpos14 := Row_Pos83;
Tmp_List14 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:78:46>

Defer_Res110 :=
   Grammar_Expr_Or_Parse0 (Parser, Lst_Cpos14);
Defer_Pos110 := Parser.Current_Pos;

--  END <Defer (for 'grammar_expr') at parser.lkt:78:46>


   exit when Defer_Pos110 = No_Token_Index;

   List_Pos14 := Defer_Pos110;
   Lst_Cpos14 := List_Pos14;

   Tmp_List14.Nodes.Append (Defer_Res110);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List14.Nodes.Length;
begin
   List_Res14 := Allocate_Grammar_Expr_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos83;
      Token_End := (if Lst_Cpos14 = Row_Pos83
                    then Row_Pos83
                    else List_Pos14 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos83, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res14,
      Kind              => Lkt_Grammar_Expr_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res14,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List14.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res14.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List14);

--  END <List (root of 'grammar_opt_error') at parser.lkt:78:40>




if List_Pos14 /= No_Token_Index then

   Row_Pos83 := List_Pos14;

else
   Row_Pos83 := No_Token_Index;
   goto Exit_Row83_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_opt_error') at parser.lkt:78:60>

Token_Res124 := Row_Pos83;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res124));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos124 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos83 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos83,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos124 := Row_Pos83 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'grammar_opt_error') at parser.lkt:78:60>




if Token_Pos124 /= No_Token_Index then

   Row_Pos83 := Token_Pos124;

else
   Row_Pos83 := No_Token_Index;
   goto Exit_Row83_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row83_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_opt_error') at ???>



if Row_Pos83 /= No_Token_Index then

   Transform_Res75 := Allocate_Grammar_Opt_Error_Group (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res75,
      Kind => Lkt_Grammar_Opt_Error_Group,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos83 = Pos
                            then No_Token_Index
                            else Row_Pos83 - 1));

      
      Initialize_Fields_For_Grammar_Opt_Error_Group
        (Self => Transform_Res75,
         Grammar_Opt_Error_Group_F_Expr => List_Res14);

         if List_Res14 /= null and then Is_Incomplete (List_Res14) then
            Transform_Res75.Last_Attempted_Child := 0;
         elsif List_Res14 /= null and then not Is_Ghost (List_Res14) then
            Transform_Res75.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos83 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags75);
end if;

--  END <Transform(<CompiledType BareGrammarOptErrorGroup>) (root of 'grammar_opt_error') at parser.lkt:78:11>

    if Row_Pos83 /= No_Token_Index then
        Or_Pos20 := Row_Pos83;
        Or_Res20 := Transform_Res75;
        goto Exit_Or20;
    end if;
<<Exit_Or20>>

--  END <Or (root of 'grammar_opt_error') at parser.lkt:76:26>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Grammar_Opt_Error_Or_Parse0_Memo,
      Or_Pos20 /= No_Token_Index,
      Or_Res20,
      Pos,
      Or_Pos20);


   Parser.Current_Pos := Or_Pos20;

   return Or_Res20;
end Grammar_Opt_Error_Or_Parse0;

   


function Grammar_Or_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Or_Expr
is
   use Bare_Grammar_Or_Expr_Memos;

      Row_Pos84 :
            Token_Index
               := No_Token_Index;
      Token_Pos125 :
            Token_Index
               := No_Token_Index;
      Token_Res125 :
            Token_Index
               := No_Token_Index;
      Token_Pos126 :
            Token_Index
               := No_Token_Index;
      Token_Res126 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos15 :
            Token_Index
               := No_Token_Index;
      Tmp_List15 :
            Free_Parse_List;
      Has_Leading0 :
            Boolean
               := False;
      Lst_Cpos16 :
            Token_Index
               := No_Token_Index;
      Tmp_List16 :
            Free_Parse_List;
      Defer_Pos111 :
            Token_Index
               := No_Token_Index;
      Defer_Res111 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      List_Pos15 :
            Token_Index
               := No_Token_Index;
      List_Res15 :
            Bare_Grammar_Expr_List
               := No_Bare_Lkt_Node;
      Token_Pos127 :
            Token_Index
               := No_Token_Index;
      Token_Res127 :
            Token_Index
               := No_Token_Index;
      List_Pos16 :
            Token_Index
               := No_Token_Index;
      List_Res16 :
            Bare_Grammar_Expr_List_List
               := No_Bare_Lkt_Node;
      Token_Pos128 :
            Token_Index
               := No_Token_Index;
      Token_Res128 :
            Token_Index
               := No_Token_Index;
      Transform_Res76 :
            Bare_Grammar_Or_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags76 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Grammar_Or_Expr_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res76 := M.Instance;
      return Transform_Res76;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res76;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareGrammarOrExpr>) (root of 'grammar_or_expr') at parser.lkt:84:24>

Transform_Diags76 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_or_expr') at ???>

Row_Pos84 := Pos;



--  BEGIN <Token(<WithText OrKw>, ) (root of 'grammar_or_expr') at parser.lkt:85:9>

Token_Res125 := Row_Pos84;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res125));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Or_Kw)
   then
       Token_Pos125 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos84 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos84,
             Expected_Token_Id => Lkt_Or_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos125 := Row_Pos84 + 1;
   end if;
end;

--  END <Token(<WithText OrKw>, ) (root of 'grammar_or_expr') at parser.lkt:85:9>




if Token_Pos125 /= No_Token_Index then

   Row_Pos84 := Token_Pos125;

else
   Row_Pos84 := No_Token_Index;
   goto Exit_Row84_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_or_expr') at parser.lkt:85:14>

Token_Res126 := Row_Pos84;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res126));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos126 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos84 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos84,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos126 := Row_Pos84 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'grammar_or_expr') at parser.lkt:85:14>




if Token_Pos126 /= No_Token_Index then

   Row_Pos84 := Token_Pos126;

else
   Row_Pos84 := No_Token_Index;
   goto Exit_Row84_0;

end if;


--  BEGIN <List (root of 'grammar_or_expr') at parser.lkt:85:18>

    List_Pos16 := No_Token_Index;



Lst_Cpos15 := Row_Pos84;
Tmp_List15 := Get_Parse_List (Parser);

   
--  BEGIN <Token(<WithText Pipe>, ) (root of 'grammar_or_expr') at parser.lkt:85:45>

Token_Res127 := Lst_Cpos15;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res127));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Pipe)
   then
       Token_Pos127 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos15 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos15,
             Expected_Token_Id => Lkt_Pipe,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos127 := Lst_Cpos15 + 1;
   end if;
end;

--  END <Token(<WithText Pipe>, ) (root of 'grammar_or_expr') at parser.lkt:85:45>

   if Token_Pos127 /= No_Token_Index then
       Lst_Cpos15 := Token_Pos127;
       Has_Leading0 := True;
   else
       Has_Leading0 := False;
   end if;

loop
   
--  BEGIN <List (root of 'grammar_or_expr') at parser.lkt:85:24>

    List_Pos15 := No_Token_Index;



Lst_Cpos16 := Lst_Cpos15;
Tmp_List16 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:85:30>

Defer_Res111 :=
   Grammar_Expr_Or_Parse0 (Parser, Lst_Cpos16);
Defer_Pos111 := Parser.Current_Pos;

--  END <Defer (for 'grammar_expr') at parser.lkt:85:30>


   exit when Defer_Pos111 = No_Token_Index;

   List_Pos15 := Defer_Pos111;
   Lst_Cpos16 := List_Pos15;

   Tmp_List16.Nodes.Append (Defer_Res111);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List16.Nodes.Length;
begin
   List_Res15 := Allocate_Grammar_Expr_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Lst_Cpos15;
      Token_End := (if Lst_Cpos16 = Lst_Cpos15
                    then Lst_Cpos15
                    else List_Pos15 - 1);

   else
      Token_Start := Token_Index'Max (Lst_Cpos15, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res15,
      Kind              => Lkt_Grammar_Expr_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res15,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List16.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res15.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List16);

--  END <List (root of 'grammar_or_expr') at parser.lkt:85:24>


   exit when List_Pos15 = No_Token_Index;

   List_Pos16 := List_Pos15;
   Lst_Cpos15 := List_Pos16;

   Tmp_List15.Nodes.Append (List_Res15);

      
--  BEGIN <Token(<WithText Pipe>, ) (root of 'grammar_or_expr') at parser.lkt:85:45>

Token_Res127 := Lst_Cpos15;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res127));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Pipe)
   then
       Token_Pos127 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos15 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos15,
             Expected_Token_Id => Lkt_Pipe,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos127 := Lst_Cpos15 + 1;
   end if;
end;

--  END <Token(<WithText Pipe>, ) (root of 'grammar_or_expr') at parser.lkt:85:45>


      exit when Token_Pos127 = No_Token_Index;

      Lst_Cpos15 := Token_Pos127;

end loop;

   if Has_Leading0 and then Tmp_List15.Nodes.Is_Empty then
      List_Pos16 := No_Token_Index;
   end if;

declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List15.Nodes.Length;
begin
   List_Res16 := Allocate_Grammar_Expr_List_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos84;
      Token_End := (if Lst_Cpos15 = Row_Pos84
                    then Row_Pos84
                    else List_Pos16 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos84, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res16,
      Kind              => Lkt_Grammar_Expr_List_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res16,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List15.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res16.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List15);

--  END <List (root of 'grammar_or_expr') at parser.lkt:85:18>




if List_Pos16 /= No_Token_Index then

   Row_Pos84 := List_Pos16;

else
   Row_Pos84 := No_Token_Index;
   goto Exit_Row84_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_or_expr') at parser.lkt:85:65>

Token_Res128 := Row_Pos84;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res128));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos128 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos84 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos84,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos128 := Row_Pos84 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'grammar_or_expr') at parser.lkt:85:65>




if Token_Pos128 /= No_Token_Index then

   Row_Pos84 := Token_Pos128;

else
   Row_Pos84 := No_Token_Index;
   goto Exit_Row84_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row84_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_or_expr') at ???>



if Row_Pos84 /= No_Token_Index then

   Transform_Res76 := Allocate_Grammar_Or_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res76,
      Kind => Lkt_Grammar_Or_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos84 = Pos
                            then No_Token_Index
                            else Row_Pos84 - 1));

      
      Initialize_Fields_For_Grammar_Or_Expr
        (Self => Transform_Res76,
         Grammar_Or_Expr_F_Sub_Exprs => List_Res16);

         if List_Res16 /= null and then Is_Incomplete (List_Res16) then
            Transform_Res76.Last_Attempted_Child := 0;
         elsif List_Res16 /= null and then not Is_Ghost (List_Res16) then
            Transform_Res76.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos84 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags76);
end if;

--  END <Transform(<CompiledType BareGrammarOrExpr>) (root of 'grammar_or_expr') at parser.lkt:84:24>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Grammar_Or_Expr_Transform_Parse0_Memo,
      Row_Pos84 /= No_Token_Index,
      Transform_Res76,
      Pos,
      Row_Pos84);


   Parser.Current_Pos := Row_Pos84;

   return Transform_Res76;
end Grammar_Or_Expr_Transform_Parse0;

   


function Grammar_Pick_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Pick
is
   use Bare_Grammar_Pick_Memos;

      Row_Pos85 :
            Token_Index
               := No_Token_Index;
      Token_Pos129 :
            Token_Index
               := No_Token_Index;
      Token_Res129 :
            Token_Index
               := No_Token_Index;
      Token_Pos130 :
            Token_Index
               := No_Token_Index;
      Token_Res130 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos17 :
            Token_Index
               := No_Token_Index;
      Tmp_List17 :
            Free_Parse_List;
      Defer_Pos112 :
            Token_Index
               := No_Token_Index;
      Defer_Res112 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      List_Pos17 :
            Token_Index
               := No_Token_Index;
      List_Res17 :
            Bare_Grammar_Expr_List
               := No_Bare_Lkt_Node;
      Token_Pos131 :
            Token_Index
               := No_Token_Index;
      Token_Res131 :
            Token_Index
               := No_Token_Index;
      Transform_Res77 :
            Bare_Grammar_Pick
               := No_Bare_Lkt_Node;
      Transform_Diags77 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Grammar_Pick_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res77 := M.Instance;
      return Transform_Res77;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res77;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareGrammarPick>) (root of 'grammar_pick') at parser.lkt:68:21>

Transform_Diags77 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_pick') at ???>

Row_Pos85 := Pos;



--  BEGIN <Token(<WithSymbol Identifier>, pick) (root of 'grammar_pick') at parser.lkt:69:9>

Token_Res129 := Row_Pos85;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res129));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Pick)
   then
       Token_Pos129 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos85 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos85,
             Expected_Token_Id => Lkt_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos129 := Row_Pos85 + 1;
   end if;
end;

--  END <Token(<WithSymbol Identifier>, pick) (root of 'grammar_pick') at parser.lkt:69:9>




if Token_Pos129 /= No_Token_Index then

   Row_Pos85 := Token_Pos129;

else
   Row_Pos85 := No_Token_Index;
   goto Exit_Row85_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_pick') at parser.lkt:69:29>

Token_Res130 := Row_Pos85;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res130));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos130 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos85 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos85,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos130 := Row_Pos85 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'grammar_pick') at parser.lkt:69:29>




if Token_Pos130 /= No_Token_Index then

   Row_Pos85 := Token_Pos130;

else
   Row_Pos85 := No_Token_Index;
   goto Exit_Row85_0;

end if;


--  BEGIN <List (root of 'grammar_pick') at parser.lkt:69:33>

    List_Pos17 := No_Token_Index;



Lst_Cpos17 := Row_Pos85;
Tmp_List17 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:69:39>

Defer_Res112 :=
   Grammar_Expr_Or_Parse0 (Parser, Lst_Cpos17);
Defer_Pos112 := Parser.Current_Pos;

--  END <Defer (for 'grammar_expr') at parser.lkt:69:39>


   exit when Defer_Pos112 = No_Token_Index;

   List_Pos17 := Defer_Pos112;
   Lst_Cpos17 := List_Pos17;

   Tmp_List17.Nodes.Append (Defer_Res112);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List17.Nodes.Length;
begin
   List_Res17 := Allocate_Grammar_Expr_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos85;
      Token_End := (if Lst_Cpos17 = Row_Pos85
                    then Row_Pos85
                    else List_Pos17 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos85, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res17,
      Kind              => Lkt_Grammar_Expr_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res17,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List17.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res17.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List17);

--  END <List (root of 'grammar_pick') at parser.lkt:69:33>




if List_Pos17 /= No_Token_Index then

   Row_Pos85 := List_Pos17;

else
   Row_Pos85 := No_Token_Index;
   goto Exit_Row85_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_pick') at parser.lkt:69:53>

Token_Res131 := Row_Pos85;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res131));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos131 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos85 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos85,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos131 := Row_Pos85 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'grammar_pick') at parser.lkt:69:53>




if Token_Pos131 /= No_Token_Index then

   Row_Pos85 := Token_Pos131;

else
   Row_Pos85 := No_Token_Index;
   goto Exit_Row85_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row85_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_pick') at ???>



if Row_Pos85 /= No_Token_Index then

   Transform_Res77 := Allocate_Grammar_Pick (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res77,
      Kind => Lkt_Grammar_Pick,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos85 = Pos
                            then No_Token_Index
                            else Row_Pos85 - 1));

      
      Initialize_Fields_For_Grammar_Pick
        (Self => Transform_Res77,
         Grammar_Pick_F_Exprs => List_Res17);

         if List_Res17 /= null and then Is_Incomplete (List_Res17) then
            Transform_Res77.Last_Attempted_Child := 0;
         elsif List_Res17 /= null and then not Is_Ghost (List_Res17) then
            Transform_Res77.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos85 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags77);
end if;

--  END <Transform(<CompiledType BareGrammarPick>) (root of 'grammar_pick') at parser.lkt:68:21>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Grammar_Pick_Transform_Parse0_Memo,
      Row_Pos85 /= No_Token_Index,
      Transform_Res77,
      Pos,
      Row_Pos85);


   Parser.Current_Pos := Row_Pos85;

   return Transform_Res77;
end Grammar_Pick_Transform_Parse0;

   


function Grammar_Primary_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr
is
   use Bare_Grammar_Expr_Memos;

      Defer_Pos113 :
            Token_Index
               := No_Token_Index;
      Defer_Res113 :
            Bare_Grammar_Pick
               := No_Bare_Lkt_Node;
      Defer_Pos114 :
            Token_Index
               := No_Token_Index;
      Defer_Res114 :
            Bare_Grammar_List
               := No_Bare_Lkt_Node;
      Defer_Pos115 :
            Token_Index
               := No_Token_Index;
      Defer_Res115 :
            Bare_Token_Lit
               := No_Bare_Lkt_Node;
      Defer_Pos116 :
            Token_Index
               := No_Token_Index;
      Defer_Res116 :
            Bare_Token_No_Case_Lit
               := No_Bare_Lkt_Node;
      Defer_Pos117 :
            Token_Index
               := No_Token_Index;
      Defer_Res117 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      Defer_Pos118 :
            Token_Index
               := No_Token_Index;
      Defer_Res118 :
            Bare_Grammar_Cut
               := No_Bare_Lkt_Node;
      Defer_Pos119 :
            Token_Index
               := No_Token_Index;
      Defer_Res119 :
            Bare_Grammar_Skip
               := No_Bare_Lkt_Node;
      Defer_Pos120 :
            Token_Index
               := No_Token_Index;
      Defer_Res120 :
            Bare_Grammar_Null
               := No_Bare_Lkt_Node;
      Defer_Pos121 :
            Token_Index
               := No_Token_Index;
      Defer_Res121 :
            Bare_Token_Ref
               := No_Bare_Lkt_Node;
      Defer_Pos122 :
            Token_Index
               := No_Token_Index;
      Defer_Res122 :
            Bare_Grammar_Stop_Cut
               := No_Bare_Lkt_Node;
      Defer_Pos123 :
            Token_Index
               := No_Token_Index;
      Defer_Res123 :
            Bare_Parse_Node_Expr
               := No_Bare_Lkt_Node;
      Defer_Pos124 :
            Token_Index
               := No_Token_Index;
      Defer_Res124 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      Defer_Pos125 :
            Token_Index
               := No_Token_Index;
      Defer_Res125 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      Defer_Pos126 :
            Token_Index
               := No_Token_Index;
      Defer_Res126 :
            Bare_Grammar_Or_Expr
               := No_Bare_Lkt_Node;
      Defer_Pos127 :
            Token_Index
               := No_Token_Index;
      Defer_Res127 :
            Bare_Grammar_Rule_Ref
               := No_Bare_Lkt_Node;
      Defer_Pos128 :
            Token_Index
               := No_Token_Index;
      Defer_Res128 :
            Bare_Grammar_Discard
               := No_Bare_Lkt_Node;
      Or_Pos21 :
            Token_Index
               := No_Token_Index;
      Or_Res21 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Grammar_Primary_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res21 := M.Instance;
      return Or_Res21;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res21;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'grammar_primary') at parser.lkt:41:24>

Or_Pos21 := No_Token_Index;
Or_Res21 := No_Bare_Lkt_Node;
    
--  BEGIN <Defer (for 'grammar_pick') at parser.lkt:42:11>

Defer_Res113 :=
   Grammar_Pick_Transform_Parse0 (Parser, Pos);
Defer_Pos113 := Parser.Current_Pos;

--  END <Defer (for 'grammar_pick') at parser.lkt:42:11>

    if Defer_Pos113 /= No_Token_Index then
        Or_Pos21 := Defer_Pos113;
        Or_Res21 := Defer_Res113;
        goto Exit_Or21;
    end if;
    
--  BEGIN <Defer (for 'grammar_list_expr') at parser.lkt:43:11>

Defer_Res114 :=
   Grammar_List_Expr_Transform_Parse3 (Parser, Pos);
Defer_Pos114 := Parser.Current_Pos;

--  END <Defer (for 'grammar_list_expr') at parser.lkt:43:11>

    if Defer_Pos114 /= No_Token_Index then
        Or_Pos21 := Defer_Pos114;
        Or_Res21 := Defer_Res114;
        goto Exit_Or21;
    end if;
    
--  BEGIN <Defer (for 'token_literal') at parser.lkt:44:11>

Defer_Res115 :=
   Token_Literal_Transform_Parse0 (Parser, Pos);
Defer_Pos115 := Parser.Current_Pos;

--  END <Defer (for 'token_literal') at parser.lkt:44:11>

    if Defer_Pos115 /= No_Token_Index then
        Or_Pos21 := Defer_Pos115;
        Or_Res21 := Defer_Res115;
        goto Exit_Or21;
    end if;
    
--  BEGIN <Defer (for 'token_no_case_literal') at parser.lkt:45:11>

Defer_Res116 :=
   Token_No_Case_Literal_Transform_Parse0 (Parser, Pos);
Defer_Pos116 := Parser.Current_Pos;

--  END <Defer (for 'token_no_case_literal') at parser.lkt:45:11>

    if Defer_Pos116 /= No_Token_Index then
        Or_Pos21 := Defer_Pos116;
        Or_Res21 := Defer_Res116;
        goto Exit_Or21;
    end if;
    
--  BEGIN <Defer (for 'token_pattern') at parser.lkt:46:11>

Defer_Res117 :=
   Token_Pattern_Or_Parse0 (Parser, Pos);
Defer_Pos117 := Parser.Current_Pos;

--  END <Defer (for 'token_pattern') at parser.lkt:46:11>

    if Defer_Pos117 /= No_Token_Index then
        Or_Pos21 := Defer_Pos117;
        Or_Res21 := Defer_Res117;
        goto Exit_Or21;
    end if;
    
--  BEGIN <Defer (for 'grammar_cut') at parser.lkt:47:11>

Defer_Res118 :=
   Grammar_Cut_Transform_Parse0 (Parser, Pos);
Defer_Pos118 := Parser.Current_Pos;

--  END <Defer (for 'grammar_cut') at parser.lkt:47:11>

    if Defer_Pos118 /= No_Token_Index then
        Or_Pos21 := Defer_Pos118;
        Or_Res21 := Defer_Res118;
        goto Exit_Or21;
    end if;
    
--  BEGIN <Defer (for 'grammar_skip') at parser.lkt:48:11>

Defer_Res119 :=
   Grammar_Skip_Transform_Parse0 (Parser, Pos);
Defer_Pos119 := Parser.Current_Pos;

--  END <Defer (for 'grammar_skip') at parser.lkt:48:11>

    if Defer_Pos119 /= No_Token_Index then
        Or_Pos21 := Defer_Pos119;
        Or_Res21 := Defer_Res119;
        goto Exit_Or21;
    end if;
    
--  BEGIN <Defer (for 'grammar_null') at parser.lkt:49:11>

Defer_Res120 :=
   Grammar_Null_Transform_Parse0 (Parser, Pos);
Defer_Pos120 := Parser.Current_Pos;

--  END <Defer (for 'grammar_null') at parser.lkt:49:11>

    if Defer_Pos120 /= No_Token_Index then
        Or_Pos21 := Defer_Pos120;
        Or_Res21 := Defer_Res120;
        goto Exit_Or21;
    end if;
    
--  BEGIN <Defer (for 'grammar_token') at parser.lkt:50:11>

Defer_Res121 :=
   Grammar_Token_Transform_Parse0 (Parser, Pos);
Defer_Pos121 := Parser.Current_Pos;

--  END <Defer (for 'grammar_token') at parser.lkt:50:11>

    if Defer_Pos121 /= No_Token_Index then
        Or_Pos21 := Defer_Pos121;
        Or_Res21 := Defer_Res121;
        goto Exit_Or21;
    end if;
    
--  BEGIN <Defer (for 'grammar_stopcut') at parser.lkt:51:11>

Defer_Res122 :=
   Grammar_Stopcut_Transform_Parse0 (Parser, Pos);
Defer_Pos122 := Parser.Current_Pos;

--  END <Defer (for 'grammar_stopcut') at parser.lkt:51:11>

    if Defer_Pos122 /= No_Token_Index then
        Or_Pos21 := Defer_Pos122;
        Or_Res21 := Defer_Res122;
        goto Exit_Or21;
    end if;
    
--  BEGIN <Defer (for 'parse_node_expr') at parser.lkt:52:11>

Defer_Res123 :=
   Parse_Node_Expr_Transform_Parse0 (Parser, Pos);
Defer_Pos123 := Parser.Current_Pos;

--  END <Defer (for 'parse_node_expr') at parser.lkt:52:11>

    if Defer_Pos123 /= No_Token_Index then
        Or_Pos21 := Defer_Pos123;
        Or_Res21 := Defer_Res123;
        goto Exit_Or21;
    end if;
    
--  BEGIN <Defer (for 'grammar_opt') at parser.lkt:53:11>

Defer_Res124 :=
   Grammar_Opt_Or_Parse0 (Parser, Pos);
Defer_Pos124 := Parser.Current_Pos;

--  END <Defer (for 'grammar_opt') at parser.lkt:53:11>

    if Defer_Pos124 /= No_Token_Index then
        Or_Pos21 := Defer_Pos124;
        Or_Res21 := Defer_Res124;
        goto Exit_Or21;
    end if;
    
--  BEGIN <Defer (for 'grammar_opt_error') at parser.lkt:54:11>

Defer_Res125 :=
   Grammar_Opt_Error_Or_Parse0 (Parser, Pos);
Defer_Pos125 := Parser.Current_Pos;

--  END <Defer (for 'grammar_opt_error') at parser.lkt:54:11>

    if Defer_Pos125 /= No_Token_Index then
        Or_Pos21 := Defer_Pos125;
        Or_Res21 := Defer_Res125;
        goto Exit_Or21;
    end if;
    
--  BEGIN <Defer (for 'grammar_or_expr') at parser.lkt:55:11>

Defer_Res126 :=
   Grammar_Or_Expr_Transform_Parse0 (Parser, Pos);
Defer_Pos126 := Parser.Current_Pos;

--  END <Defer (for 'grammar_or_expr') at parser.lkt:55:11>

    if Defer_Pos126 /= No_Token_Index then
        Or_Pos21 := Defer_Pos126;
        Or_Res21 := Defer_Res126;
        goto Exit_Or21;
    end if;
    
--  BEGIN <Defer (for 'grammar_rule_ref') at parser.lkt:56:11>

Defer_Res127 :=
   Grammar_Rule_Ref_Transform_Parse0 (Parser, Pos);
Defer_Pos127 := Parser.Current_Pos;

--  END <Defer (for 'grammar_rule_ref') at parser.lkt:56:11>

    if Defer_Pos127 /= No_Token_Index then
        Or_Pos21 := Defer_Pos127;
        Or_Res21 := Defer_Res127;
        goto Exit_Or21;
    end if;
    
--  BEGIN <Defer (for 'grammar_discard_expr') at parser.lkt:57:11>

Defer_Res128 :=
   Grammar_Discard_Expr_Transform_Parse0 (Parser, Pos);
Defer_Pos128 := Parser.Current_Pos;

--  END <Defer (for 'grammar_discard_expr') at parser.lkt:57:11>

    if Defer_Pos128 /= No_Token_Index then
        Or_Pos21 := Defer_Pos128;
        Or_Res21 := Defer_Res128;
        goto Exit_Or21;
    end if;
<<Exit_Or21>>

--  END <Or (root of 'grammar_primary') at parser.lkt:41:24>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Grammar_Primary_Or_Parse0_Memo,
      Or_Pos21 /= No_Token_Index,
      Or_Res21,
      Pos,
      Or_Pos21);


   Parser.Current_Pos := Or_Pos21;

   return Or_Res21;
end Grammar_Primary_Or_Parse0;

   


function Grammar_Rule_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Rule_Decl
is
   use Bare_Grammar_Rule_Decl_Memos;

      Row_Pos86 :
            Token_Index
               := No_Token_Index;
      Defer_Pos129 :
            Token_Index
               := No_Token_Index;
      Defer_Res129 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Row_Pos87 :
            Token_Index
               := No_Token_Index;
      Token_Pos132 :
            Token_Index
               := No_Token_Index;
      Token_Res132 :
            Token_Index
               := No_Token_Index;
      Defer_Pos130 :
            Token_Index
               := No_Token_Index;
      Defer_Res130 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      Transform_Res78 :
            Bare_Grammar_Rule_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags78 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Grammar_Rule_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res78 := M.Instance;
      return Transform_Res78;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res78;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareGrammarRuleDecl>) (root of 'grammar_rule') at parser.lkt:17:21>

Transform_Diags78 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_rule') at ???>

Row_Pos86 := Pos;



--  BEGIN <Defer (for 'def_id') at parser.lkt:17:37>

Defer_Res129 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos86);
Defer_Pos129 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:17:37>




if Defer_Pos129 /= No_Token_Index then

   Row_Pos86 := Defer_Pos129;

else
   Row_Pos86 := No_Token_Index;
   goto Exit_Row86_0;

end if;


--  BEGIN <Opt (root of 'grammar_rule') at parser.lkt:17:44>












--  BEGIN <_Extract (root of 'grammar_rule') at parser.lkt:17:45>

--  BEGIN <_Row (root of 'grammar_rule') at ???>

Row_Pos87 := Row_Pos86;



--  BEGIN <Token(<WithText LeftArrow>, ) (root of 'grammar_rule') at parser.lkt:17:50>

Token_Res132 := Row_Pos87;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res132));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Left_Arrow)
   then
       Token_Pos132 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos87 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos87,
             Expected_Token_Id => Lkt_Left_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos132 := Row_Pos87 + 1;
   end if;
end;

--  END <Token(<WithText LeftArrow>, ) (root of 'grammar_rule') at parser.lkt:17:50>




if Token_Pos132 /= No_Token_Index then

   Row_Pos87 := Token_Pos132;

else
   Row_Pos87 := No_Token_Index;
   goto Exit_Row87_0;

end if;


--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:17:55>

Defer_Res130 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos87);
Defer_Pos130 := Parser.Current_Pos;

--  END <Defer (for 'grammar_expr') at parser.lkt:17:55>




if Defer_Pos130 /= No_Token_Index then

   Row_Pos87 := Defer_Pos130;

else
   Row_Pos87 := No_Token_Index;
   goto Exit_Row87_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row87_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_rule') at ???>

--  END <_Extract (root of 'grammar_rule') at parser.lkt:17:45>


if Row_Pos87 = No_Token_Index then

         
   Defer_Res130 := No_Bare_Lkt_Node;



       
   Row_Pos87 := Row_Pos86;



end if;

--  END <Opt (root of 'grammar_rule') at parser.lkt:17:44>




if Row_Pos87 /= No_Token_Index then

   Row_Pos86 := Row_Pos87;

else
   Row_Pos86 := No_Token_Index;
   goto Exit_Row86_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row86_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_rule') at ???>



if Row_Pos86 /= No_Token_Index then

   Transform_Res78 := Allocate_Grammar_Rule_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res78,
      Kind => Lkt_Grammar_Rule_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos86 = Pos
                            then No_Token_Index
                            else Row_Pos86 - 1));

      
      Initialize_Fields_For_Grammar_Rule_Decl
        (Self => Transform_Res78,
         Grammar_Rule_Decl_F_Syn_Name => Defer_Res129,
         Grammar_Rule_Decl_F_Expr => Defer_Res130);

         if Defer_Res129 /= null and then Is_Incomplete (Defer_Res129) then
            Transform_Res78.Last_Attempted_Child := 0;
         elsif Defer_Res129 /= null and then not Is_Ghost (Defer_Res129) then
            Transform_Res78.Last_Attempted_Child := -1;
         end if;
         if Defer_Res130 /= null and then Is_Incomplete (Defer_Res130) then
            Transform_Res78.Last_Attempted_Child := 0;
         elsif Defer_Res130 /= null and then not Is_Ghost (Defer_Res130) then
            Transform_Res78.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos86 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags78);
end if;

--  END <Transform(<CompiledType BareGrammarRuleDecl>) (root of 'grammar_rule') at parser.lkt:17:21>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Grammar_Rule_Transform_Parse0_Memo,
      Row_Pos86 /= No_Token_Index,
      Transform_Res78,
      Pos,
      Row_Pos86);


   Parser.Current_Pos := Row_Pos86;

   return Transform_Res78;
end Grammar_Rule_Transform_Parse0;

   


function Grammar_Rule_Ref_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Rule_Ref
is
   use Bare_Grammar_Rule_Ref_Memos;

      Row_Pos88 :
            Token_Index
               := No_Token_Index;
      Defer_Pos131 :
            Token_Index
               := No_Token_Index;
      Defer_Res131 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Transform_Res79 :
            Bare_Grammar_Rule_Ref
               := No_Bare_Lkt_Node;
      Transform_Diags79 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Grammar_Rule_Ref_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res79 := M.Instance;
      return Transform_Res79;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res79;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareGrammarRuleRef>) (root of 'grammar_rule_ref') at parser.lkt:98:25>

Transform_Diags79 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_rule_ref') at ???>

Row_Pos88 := Pos;



--  BEGIN <Defer (for 'ref_id') at parser.lkt:98:40>

Defer_Res131 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos88);
Defer_Pos131 := Parser.Current_Pos;

--  END <Defer (for 'ref_id') at parser.lkt:98:40>




if Defer_Pos131 /= No_Token_Index then

   Row_Pos88 := Defer_Pos131;

else
   Row_Pos88 := No_Token_Index;
   goto Exit_Row88_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row88_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_rule_ref') at ???>



if Row_Pos88 /= No_Token_Index then

   Transform_Res79 := Allocate_Grammar_Rule_Ref (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res79,
      Kind => Lkt_Grammar_Rule_Ref,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos88 = Pos
                            then No_Token_Index
                            else Row_Pos88 - 1));

      
      Initialize_Fields_For_Grammar_Rule_Ref
        (Self => Transform_Res79,
         Grammar_Rule_Ref_F_Node_Name => Defer_Res131);

         if Defer_Res131 /= null and then Is_Incomplete (Defer_Res131) then
            Transform_Res79.Last_Attempted_Child := 0;
         elsif Defer_Res131 /= null and then not Is_Ghost (Defer_Res131) then
            Transform_Res79.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos88 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags79);
end if;

--  END <Transform(<CompiledType BareGrammarRuleRef>) (root of 'grammar_rule_ref') at parser.lkt:98:25>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Grammar_Rule_Ref_Transform_Parse0_Memo,
      Row_Pos88 /= No_Token_Index,
      Transform_Res79,
      Pos,
      Row_Pos88);


   Parser.Current_Pos := Row_Pos88;

   return Transform_Res79;
end Grammar_Rule_Ref_Transform_Parse0;

   


function Grammar_Skip_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Skip
is
   use Bare_Grammar_Skip_Memos;

      Row_Pos89 :
            Token_Index
               := No_Token_Index;
      Token_Pos133 :
            Token_Index
               := No_Token_Index;
      Token_Res133 :
            Token_Index
               := No_Token_Index;
      Token_Pos134 :
            Token_Index
               := No_Token_Index;
      Token_Res134 :
            Token_Index
               := No_Token_Index;
      Defer_Pos132 :
            Token_Index
               := No_Token_Index;
      Defer_Res132 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Token_Pos135 :
            Token_Index
               := No_Token_Index;
      Token_Res135 :
            Token_Index
               := No_Token_Index;
      Transform_Res80 :
            Bare_Grammar_Skip
               := No_Bare_Lkt_Node;
      Transform_Diags80 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Grammar_Skip_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res80 := M.Instance;
      return Transform_Res80;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res80;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareGrammarSkip>) (root of 'grammar_skip') at parser.lkt:115:21>

Transform_Diags80 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_skip') at ???>

Row_Pos89 := Pos;



--  BEGIN <Token(<WithSymbol Identifier>, skip) (root of 'grammar_skip') at parser.lkt:115:33>

Token_Res133 := Row_Pos89;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res133));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Skip)
   then
       Token_Pos133 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos89 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos89,
             Expected_Token_Id => Lkt_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos133 := Row_Pos89 + 1;
   end if;
end;

--  END <Token(<WithSymbol Identifier>, skip) (root of 'grammar_skip') at parser.lkt:115:33>




if Token_Pos133 /= No_Token_Index then

   Row_Pos89 := Token_Pos133;

else
   Row_Pos89 := No_Token_Index;
   goto Exit_Row89_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_skip') at parser.lkt:115:53>

Token_Res134 := Row_Pos89;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res134));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos134 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos89 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos89,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos134 := Row_Pos89 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'grammar_skip') at parser.lkt:115:53>




if Token_Pos134 /= No_Token_Index then

   Row_Pos89 := Token_Pos134;

else
   Row_Pos89 := No_Token_Index;
   goto Exit_Row89_0;

end if;


--  BEGIN <Defer (for 'type_ref') at parser.lkt:115:57>

Defer_Res132 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos89);
Defer_Pos132 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:115:57>




if Defer_Pos132 /= No_Token_Index then

   Row_Pos89 := Defer_Pos132;

else
   Row_Pos89 := No_Token_Index;
   goto Exit_Row89_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_skip') at parser.lkt:115:66>

Token_Res135 := Row_Pos89;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res135));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos135 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos89 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos89,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos135 := Row_Pos89 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'grammar_skip') at parser.lkt:115:66>




if Token_Pos135 /= No_Token_Index then

   Row_Pos89 := Token_Pos135;

else
   Row_Pos89 := No_Token_Index;
   goto Exit_Row89_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row89_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_skip') at ???>



if Row_Pos89 /= No_Token_Index then

   Transform_Res80 := Allocate_Grammar_Skip (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res80,
      Kind => Lkt_Grammar_Skip,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos89 = Pos
                            then No_Token_Index
                            else Row_Pos89 - 1));

      
      Initialize_Fields_For_Grammar_Skip
        (Self => Transform_Res80,
         Grammar_Skip_F_Name => Defer_Res132);

         if Defer_Res132 /= null and then Is_Incomplete (Defer_Res132) then
            Transform_Res80.Last_Attempted_Child := 0;
         elsif Defer_Res132 /= null and then not Is_Ghost (Defer_Res132) then
            Transform_Res80.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos89 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags80);
end if;

--  END <Transform(<CompiledType BareGrammarSkip>) (root of 'grammar_skip') at parser.lkt:115:21>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Grammar_Skip_Transform_Parse0_Memo,
      Row_Pos89 /= No_Token_Index,
      Transform_Res80,
      Pos,
      Row_Pos89);


   Parser.Current_Pos := Row_Pos89;

   return Transform_Res80;
end Grammar_Skip_Transform_Parse0;

   


function Grammar_Stopcut_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Stop_Cut
is
   use Bare_Grammar_Stop_Cut_Memos;

      Row_Pos90 :
            Token_Index
               := No_Token_Index;
      Token_Pos136 :
            Token_Index
               := No_Token_Index;
      Token_Res136 :
            Token_Index
               := No_Token_Index;
      Token_Pos137 :
            Token_Index
               := No_Token_Index;
      Token_Res137 :
            Token_Index
               := No_Token_Index;
      Defer_Pos133 :
            Token_Index
               := No_Token_Index;
      Defer_Res133 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      Token_Pos138 :
            Token_Index
               := No_Token_Index;
      Token_Res138 :
            Token_Index
               := No_Token_Index;
      Transform_Res81 :
            Bare_Grammar_Stop_Cut
               := No_Bare_Lkt_Node;
      Transform_Diags81 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Grammar_Stopcut_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res81 := M.Instance;
      return Transform_Res81;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res81;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareGrammarStopCut>) (root of 'grammar_stopcut') at parser.lkt:81:24>

Transform_Diags81 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_stopcut') at ???>

Row_Pos90 := Pos;



--  BEGIN <Token(<WithSymbol Identifier>, stop_cut) (root of 'grammar_stopcut') at parser.lkt:82:9>

Token_Res136 := Row_Pos90;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res136));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Stop_Cut)
   then
       Token_Pos136 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos90 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos90,
             Expected_Token_Id => Lkt_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos136 := Row_Pos90 + 1;
   end if;
end;

--  END <Token(<WithSymbol Identifier>, stop_cut) (root of 'grammar_stopcut') at parser.lkt:82:9>




if Token_Pos136 /= No_Token_Index then

   Row_Pos90 := Token_Pos136;

else
   Row_Pos90 := No_Token_Index;
   goto Exit_Row90_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_stopcut') at parser.lkt:82:33>

Token_Res137 := Row_Pos90;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res137));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos137 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos90 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos90,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos137 := Row_Pos90 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'grammar_stopcut') at parser.lkt:82:33>




if Token_Pos137 /= No_Token_Index then

   Row_Pos90 := Token_Pos137;

else
   Row_Pos90 := No_Token_Index;
   goto Exit_Row90_0;

end if;


--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:82:37>

Defer_Res133 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos90);
Defer_Pos133 := Parser.Current_Pos;

--  END <Defer (for 'grammar_expr') at parser.lkt:82:37>




if Defer_Pos133 /= No_Token_Index then

   Row_Pos90 := Defer_Pos133;

else
   Row_Pos90 := No_Token_Index;
   goto Exit_Row90_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_stopcut') at parser.lkt:82:50>

Token_Res138 := Row_Pos90;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res138));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos138 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos90 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos90,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos138 := Row_Pos90 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'grammar_stopcut') at parser.lkt:82:50>




if Token_Pos138 /= No_Token_Index then

   Row_Pos90 := Token_Pos138;

else
   Row_Pos90 := No_Token_Index;
   goto Exit_Row90_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row90_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_stopcut') at ???>



if Row_Pos90 /= No_Token_Index then

   Transform_Res81 := Allocate_Grammar_Stop_Cut (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res81,
      Kind => Lkt_Grammar_Stop_Cut,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos90 = Pos
                            then No_Token_Index
                            else Row_Pos90 - 1));

      
      Initialize_Fields_For_Grammar_Stop_Cut
        (Self => Transform_Res81,
         Grammar_Stop_Cut_F_Expr => Defer_Res133);

         if Defer_Res133 /= null and then Is_Incomplete (Defer_Res133) then
            Transform_Res81.Last_Attempted_Child := 0;
         elsif Defer_Res133 /= null and then not Is_Ghost (Defer_Res133) then
            Transform_Res81.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos90 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags81);
end if;

--  END <Transform(<CompiledType BareGrammarStopCut>) (root of 'grammar_stopcut') at parser.lkt:81:24>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Grammar_Stopcut_Transform_Parse0_Memo,
      Row_Pos90 /= No_Token_Index,
      Transform_Res81,
      Pos,
      Row_Pos90);


   Parser.Current_Pos := Row_Pos90;

   return Transform_Res81;
end Grammar_Stopcut_Transform_Parse0;

   


function Grammar_Token_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Token_Ref
is
   use Bare_Token_Ref_Memos;

      Row_Pos91 :
            Token_Index
               := No_Token_Index;
      Token_Pos139 :
            Token_Index
               := No_Token_Index;
      Token_Res139 :
            Token_Index
               := No_Token_Index;
      Defer_Pos134 :
            Token_Index
               := No_Token_Index;
      Defer_Res134 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Row_Pos92 :
            Token_Index
               := No_Token_Index;
      Token_Pos140 :
            Token_Index
               := No_Token_Index;
      Token_Res140 :
            Token_Index
               := No_Token_Index;
      Defer_Pos135 :
            Token_Index
               := No_Token_Index;
      Defer_Res135 :
            Bare_Token_Lit
               := No_Bare_Lkt_Node;
      Token_Pos141 :
            Token_Index
               := No_Token_Index;
      Token_Res141 :
            Token_Index
               := No_Token_Index;
      Transform_Res82 :
            Bare_Token_Ref
               := No_Bare_Lkt_Node;
      Transform_Diags82 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Grammar_Token_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res82 := M.Instance;
      return Transform_Res82;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res82;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareTokenRef>) (root of 'grammar_token') at parser.lkt:117:22>

Transform_Diags82 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'grammar_token') at ???>

Row_Pos91 := Pos;



--  BEGIN <Token(<WithText At>, ) (root of 'grammar_token') at parser.lkt:117:31>

Token_Res139 := Row_Pos91;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res139));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_At)
   then
       Token_Pos139 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos91 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos91,
             Expected_Token_Id => Lkt_At,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos139 := Row_Pos91 + 1;
   end if;
end;

--  END <Token(<WithText At>, ) (root of 'grammar_token') at parser.lkt:117:31>




if Token_Pos139 /= No_Token_Index then

   Row_Pos91 := Token_Pos139;

else
   Row_Pos91 := No_Token_Index;
   goto Exit_Row91_0;

end if;


--  BEGIN <Defer (for 'ref_id') at parser.lkt:117:35>

Defer_Res134 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos91);
Defer_Pos134 := Parser.Current_Pos;

--  END <Defer (for 'ref_id') at parser.lkt:117:35>




if Defer_Pos134 /= No_Token_Index then

   Row_Pos91 := Defer_Pos134;

else
   Row_Pos91 := No_Token_Index;
   goto Exit_Row91_0;

end if;


--  BEGIN <Opt (root of 'grammar_token') at parser.lkt:117:42>












--  BEGIN <_Extract (root of 'grammar_token') at parser.lkt:117:43>

--  BEGIN <_Row (root of 'grammar_token') at ???>

Row_Pos92 := Row_Pos91;



--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_token') at parser.lkt:117:48>

Token_Res140 := Row_Pos92;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res140));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos140 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos92 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos92,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos140 := Row_Pos92 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'grammar_token') at parser.lkt:117:48>




if Token_Pos140 /= No_Token_Index then

   Row_Pos92 := Token_Pos140;

else
   Row_Pos92 := No_Token_Index;
   goto Exit_Row92_0;

end if;


--  BEGIN <Defer (for 'token_literal') at parser.lkt:117:52>

Defer_Res135 :=
   Token_Literal_Transform_Parse0 (Parser, Row_Pos92);
Defer_Pos135 := Parser.Current_Pos;

--  END <Defer (for 'token_literal') at parser.lkt:117:52>




if Defer_Pos135 /= No_Token_Index then

   Row_Pos92 := Defer_Pos135;

else
   Row_Pos92 := No_Token_Index;
   goto Exit_Row92_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_token') at parser.lkt:117:66>

Token_Res141 := Row_Pos92;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res141));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos141 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos92 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos92,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos141 := Row_Pos92 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'grammar_token') at parser.lkt:117:66>




if Token_Pos141 /= No_Token_Index then

   Row_Pos92 := Token_Pos141;

else
   Row_Pos92 := No_Token_Index;
   goto Exit_Row92_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row92_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_token') at ???>

--  END <_Extract (root of 'grammar_token') at parser.lkt:117:43>


if Row_Pos92 = No_Token_Index then

         
   Defer_Res135 := No_Bare_Lkt_Node;



       
   Row_Pos92 := Row_Pos91;



end if;

--  END <Opt (root of 'grammar_token') at parser.lkt:117:42>




if Row_Pos92 /= No_Token_Index then

   Row_Pos91 := Row_Pos92;

else
   Row_Pos91 := No_Token_Index;
   goto Exit_Row91_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row91_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'grammar_token') at ???>



if Row_Pos91 /= No_Token_Index then

   Transform_Res82 := Allocate_Token_Ref (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res82,
      Kind => Lkt_Token_Ref,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos91 = Pos
                            then No_Token_Index
                            else Row_Pos91 - 1));

      
      Initialize_Fields_For_Token_Ref
        (Self => Transform_Res82,
         Token_Ref_F_Token_Name => Defer_Res134,
         Token_Ref_F_Expr => Defer_Res135);

         if Defer_Res134 /= null and then Is_Incomplete (Defer_Res134) then
            Transform_Res82.Last_Attempted_Child := 0;
         elsif Defer_Res134 /= null and then not Is_Ghost (Defer_Res134) then
            Transform_Res82.Last_Attempted_Child := -1;
         end if;
         if Defer_Res135 /= null and then Is_Incomplete (Defer_Res135) then
            Transform_Res82.Last_Attempted_Child := 0;
         elsif Defer_Res135 /= null and then not Is_Ghost (Defer_Res135) then
            Transform_Res82.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos91 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags82);
end if;

--  END <Transform(<CompiledType BareTokenRef>) (root of 'grammar_token') at parser.lkt:117:22>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Grammar_Token_Transform_Parse0_Memo,
      Row_Pos91 /= No_Token_Index,
      Transform_Res82,
      Pos,
      Row_Pos91);


   Parser.Current_Pos := Row_Pos91;

   return Transform_Res82;
end Grammar_Token_Transform_Parse0;

   


function Id_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Id
is
   use Bare_Id_Memos;

      Row_Pos93 :
            Token_Index
               := No_Token_Index;
      Token_Pos142 :
            Token_Index
               := No_Token_Index;
      Token_Res142 :
            Token_Index
               := No_Token_Index;
      Transform_Res83 :
            Bare_Id
               := No_Bare_Lkt_Node;
      Transform_Diags83 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Id_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res83 := M.Instance;
      return Transform_Res83;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res83;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareId>) (root of 'id') at parser.lkt:6:11>

Transform_Diags83 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'id') at ???>

Row_Pos93 := Pos;



--  BEGIN <Token(<WithSymbol Identifier>, ) (root of 'id') at parser.lkt:6:14>

Token_Res142 := Row_Pos93;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res142));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
   then
       Token_Pos142 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos93 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos93,
             Expected_Token_Id => Lkt_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos142 := Row_Pos93 + 1;
   end if;
end;

--  END <Token(<WithSymbol Identifier>, ) (root of 'id') at parser.lkt:6:14>




if Token_Pos142 /= No_Token_Index then

   Row_Pos93 := Token_Pos142;

else
   Row_Pos93 := No_Token_Index;
   goto Exit_Row93_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row93_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'id') at ???>



if Row_Pos93 /= No_Token_Index then

   Transform_Res83 := Allocate_Id (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res83,
      Kind => Lkt_Id,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos93 = Pos
                            then No_Token_Index
                            else Row_Pos93 - 1));

      
      Initialize_Fields_For_Id
        (Self => Transform_Res83);



elsif Row_Pos93 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags83);
end if;

--  END <Transform(<CompiledType BareId>) (root of 'id') at parser.lkt:6:11>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Id_Transform_Parse0_Memo,
      Row_Pos93 /= No_Token_Index,
      Transform_Res83,
      Pos,
      Row_Pos93);


   Parser.Current_Pos := Row_Pos93;

   return Transform_Res83;
end Id_Transform_Parse0;

   


function If_Expr_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_If_Expr
is
   use Bare_If_Expr_Memos;

      Row_Pos94 :
            Token_Index
               := No_Token_Index;
      Token_Pos143 :
            Token_Index
               := No_Token_Index;
      Token_Res143 :
            Token_Index
               := No_Token_Index;
      Defer_Pos136 :
            Token_Index
               := No_Token_Index;
      Defer_Res136 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos144 :
            Token_Index
               := No_Token_Index;
      Token_Res144 :
            Token_Index
               := No_Token_Index;
      Defer_Pos137 :
            Token_Index
               := No_Token_Index;
      Defer_Res137 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Lst_Cpos18 :
            Token_Index
               := No_Token_Index;
      Tmp_List18 :
            Free_Parse_List;
      Row_Pos95 :
            Token_Index
               := No_Token_Index;
      Token_Pos145 :
            Token_Index
               := No_Token_Index;
      Token_Res145 :
            Token_Index
               := No_Token_Index;
      Defer_Pos138 :
            Token_Index
               := No_Token_Index;
      Defer_Res138 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos146 :
            Token_Index
               := No_Token_Index;
      Token_Res146 :
            Token_Index
               := No_Token_Index;
      Defer_Pos139 :
            Token_Index
               := No_Token_Index;
      Defer_Res139 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res84 :
            Bare_Elsif_Branch
               := No_Bare_Lkt_Node;
      Transform_Diags84 :
            Ada.Containers.Count_Type;
      List_Pos18 :
            Token_Index
               := No_Token_Index;
      List_Res18 :
            Bare_Elsif_Branch_List
               := No_Bare_Lkt_Node;
      Token_Pos147 :
            Token_Index
               := No_Token_Index;
      Token_Res147 :
            Token_Index
               := No_Token_Index;
      Defer_Pos140 :
            Token_Index
               := No_Token_Index;
      Defer_Res140 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res85 :
            Bare_If_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags85 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.If_Expr_Transform_Parse1_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res85 := M.Instance;
      return Transform_Res85;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res85;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareIfExpr>) (root of 'if_expr') at parser.lkt:301:16>

Transform_Diags85 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'if_expr') at ???>

Row_Pos94 := Pos;



--  BEGIN <Token(<WithText IfKw>, ) (root of 'if_expr') at parser.lkt:302:9>

Token_Res143 := Row_Pos94;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res143));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_If_Kw)
   then
       Token_Pos143 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos94 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos94,
             Expected_Token_Id => Lkt_If_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos143 := Row_Pos94 + 1;
   end if;
end;

--  END <Token(<WithText IfKw>, ) (root of 'if_expr') at parser.lkt:302:9>




if Token_Pos143 /= No_Token_Index then

   Row_Pos94 := Token_Pos143;

else
   Row_Pos94 := No_Token_Index;
   goto Exit_Row94_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:303:9>

Defer_Res136 :=
   Expr_Or_Parse1 (Parser, Row_Pos94);
Defer_Pos136 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:303:9>




if Defer_Pos136 /= No_Token_Index then

   Row_Pos94 := Defer_Pos136;

else
   Row_Pos94 := No_Token_Index;
   goto Exit_Row94_0;

end if;


--  BEGIN <Token(<WithText ThenKw>, ) (root of 'if_expr') at parser.lkt:304:9>

Token_Res144 := Row_Pos94;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res144));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Then_Kw)
   then
       Token_Pos144 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos94 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos94,
             Expected_Token_Id => Lkt_Then_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos144 := Row_Pos94 + 1;
   end if;
end;

--  END <Token(<WithText ThenKw>, ) (root of 'if_expr') at parser.lkt:304:9>




if Token_Pos144 /= No_Token_Index then

   Row_Pos94 := Token_Pos144;

else
   Row_Pos94 := No_Token_Index;
   goto Exit_Row94_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:305:9>

Defer_Res137 :=
   Expr_Or_Parse1 (Parser, Row_Pos94);
Defer_Pos137 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:305:9>




if Defer_Pos137 /= No_Token_Index then

   Row_Pos94 := Defer_Pos137;

else
   Row_Pos94 := No_Token_Index;
   goto Exit_Row94_0;

end if;


--  BEGIN <List (root of 'if_expr') at parser.lkt:306:9>

    List_Pos18 := Row_Pos94;



Lst_Cpos18 := Row_Pos94;
Tmp_List18 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Transform(<CompiledType BareElsifBranch>) (root of 'if_expr') at parser.lkt:306:15>

Transform_Diags84 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'if_expr') at ???>

Row_Pos95 := Lst_Cpos18;



--  BEGIN <Token(<WithText ElifKw>, ) (root of 'if_expr') at parser.lkt:306:27>

Token_Res145 := Row_Pos95;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res145));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Elif_Kw)
   then
       Token_Pos145 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos95 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos95,
             Expected_Token_Id => Lkt_Elif_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos145 := Row_Pos95 + 1;
   end if;
end;

--  END <Token(<WithText ElifKw>, ) (root of 'if_expr') at parser.lkt:306:27>




if Token_Pos145 /= No_Token_Index then

   Row_Pos95 := Token_Pos145;

else
   Row_Pos95 := No_Token_Index;
   goto Exit_Row95_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:306:34>

Defer_Res138 :=
   Expr_Or_Parse1 (Parser, Row_Pos95);
Defer_Pos138 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:306:34>




if Defer_Pos138 /= No_Token_Index then

   Row_Pos95 := Defer_Pos138;

else
   Row_Pos95 := No_Token_Index;
   goto Exit_Row95_0;

end if;


--  BEGIN <Token(<WithText ThenKw>, ) (root of 'if_expr') at parser.lkt:306:39>

Token_Res146 := Row_Pos95;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res146));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Then_Kw)
   then
       Token_Pos146 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos95 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos95,
             Expected_Token_Id => Lkt_Then_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos146 := Row_Pos95 + 1;
   end if;
end;

--  END <Token(<WithText ThenKw>, ) (root of 'if_expr') at parser.lkt:306:39>




if Token_Pos146 /= No_Token_Index then

   Row_Pos95 := Token_Pos146;

else
   Row_Pos95 := No_Token_Index;
   goto Exit_Row95_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:306:46>

Defer_Res139 :=
   Expr_Or_Parse1 (Parser, Row_Pos95);
Defer_Pos139 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:306:46>




if Defer_Pos139 /= No_Token_Index then

   Row_Pos95 := Defer_Pos139;

else
   Row_Pos95 := No_Token_Index;
   goto Exit_Row95_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row95_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'if_expr') at ???>



if Row_Pos95 /= No_Token_Index then

   Transform_Res84 := Allocate_Elsif_Branch (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res84,
      Kind => Lkt_Elsif_Branch,
      Unit => Parser.Unit,

      Token_Start_Index => Lst_Cpos18,
      Token_End_Index   => (if Row_Pos95 = Lst_Cpos18
                            then No_Token_Index
                            else Row_Pos95 - 1));

      
      Initialize_Fields_For_Elsif_Branch
        (Self => Transform_Res84,
         Elsif_Branch_F_Cond_Expr => Defer_Res138,
         Elsif_Branch_F_Then_Expr => Defer_Res139);

         if Defer_Res138 /= null and then Is_Incomplete (Defer_Res138) then
            Transform_Res84.Last_Attempted_Child := 0;
         elsif Defer_Res138 /= null and then not Is_Ghost (Defer_Res138) then
            Transform_Res84.Last_Attempted_Child := -1;
         end if;
         if Defer_Res139 /= null and then Is_Incomplete (Defer_Res139) then
            Transform_Res84.Last_Attempted_Child := 0;
         elsif Defer_Res139 /= null and then not Is_Ghost (Defer_Res139) then
            Transform_Res84.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos95 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags84);
end if;

--  END <Transform(<CompiledType BareElsifBranch>) (root of 'if_expr') at parser.lkt:306:15>


   exit when Row_Pos95 = No_Token_Index;

   List_Pos18 := Row_Pos95;
   Lst_Cpos18 := List_Pos18;

   Tmp_List18.Nodes.Append (Transform_Res84);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List18.Nodes.Length;
begin
   List_Res18 := Allocate_Elsif_Branch_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos94;
      Token_End := (if Lst_Cpos18 = Row_Pos94
                    then Row_Pos94
                    else List_Pos18 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos94, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res18,
      Kind              => Lkt_Elsif_Branch_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res18,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List18.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res18.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List18);

--  END <List (root of 'if_expr') at parser.lkt:306:9>




if List_Pos18 /= No_Token_Index then

   Row_Pos94 := List_Pos18;

else
   Row_Pos94 := No_Token_Index;
   goto Exit_Row94_0;

end if;


--  BEGIN <Token(<WithText ElseKw>, ) (root of 'if_expr') at parser.lkt:307:9>

Token_Res147 := Row_Pos94;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res147));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Else_Kw)
   then
       Token_Pos147 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos94 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos94,
             Expected_Token_Id => Lkt_Else_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos147 := Row_Pos94 + 1;
   end if;
end;

--  END <Token(<WithText ElseKw>, ) (root of 'if_expr') at parser.lkt:307:9>




if Token_Pos147 /= No_Token_Index then

   Row_Pos94 := Token_Pos147;

else
   Row_Pos94 := No_Token_Index;
   goto Exit_Row94_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:308:9>

Defer_Res140 :=
   Expr_Or_Parse1 (Parser, Row_Pos94);
Defer_Pos140 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:308:9>




if Defer_Pos140 /= No_Token_Index then

   Row_Pos94 := Defer_Pos140;

else
   Row_Pos94 := No_Token_Index;
   goto Exit_Row94_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row94_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'if_expr') at ???>



if Row_Pos94 /= No_Token_Index then

   Transform_Res85 := Allocate_If_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res85,
      Kind => Lkt_If_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos94 = Pos
                            then No_Token_Index
                            else Row_Pos94 - 1));

      
      Initialize_Fields_For_If_Expr
        (Self => Transform_Res85,
         If_Expr_F_Cond_Expr => Defer_Res136,
         If_Expr_F_Then_Expr => Defer_Res137,
         If_Expr_F_Alternatives => List_Res18,
         If_Expr_F_Else_Expr => Defer_Res140);

         if Defer_Res136 /= null and then Is_Incomplete (Defer_Res136) then
            Transform_Res85.Last_Attempted_Child := 0;
         elsif Defer_Res136 /= null and then not Is_Ghost (Defer_Res136) then
            Transform_Res85.Last_Attempted_Child := -1;
         end if;
         if Defer_Res137 /= null and then Is_Incomplete (Defer_Res137) then
            Transform_Res85.Last_Attempted_Child := 0;
         elsif Defer_Res137 /= null and then not Is_Ghost (Defer_Res137) then
            Transform_Res85.Last_Attempted_Child := -1;
         end if;
         if List_Res18 /= null and then Is_Incomplete (List_Res18) then
            Transform_Res85.Last_Attempted_Child := 0;
         elsif List_Res18 /= null and then not Is_Ghost (List_Res18) then
            Transform_Res85.Last_Attempted_Child := -1;
         end if;
         if Defer_Res140 /= null and then Is_Incomplete (Defer_Res140) then
            Transform_Res85.Last_Attempted_Child := 0;
         elsif Defer_Res140 /= null and then not Is_Ghost (Defer_Res140) then
            Transform_Res85.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos94 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags85);
end if;

--  END <Transform(<CompiledType BareIfExpr>) (root of 'if_expr') at parser.lkt:301:16>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.If_Expr_Transform_Parse1_Memo,
      Row_Pos94 /= No_Token_Index,
      Transform_Res85,
      Pos,
      Row_Pos94);


   Parser.Current_Pos := Row_Pos94;

   return Transform_Res85;
end If_Expr_Transform_Parse1;

   


function Import_Stmt_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Import
is
   use Bare_Import_Memos;

      Row_Pos96 :
            Token_Index
               := No_Token_Index;
      Token_Pos148 :
            Token_Index
               := No_Token_Index;
      Token_Res148 :
            Token_Index
               := No_Token_Index;
      Row_Pos97 :
            Token_Index
               := No_Token_Index;
      Token_Pos149 :
            Token_Index
               := No_Token_Index;
      Token_Res149 :
            Token_Index
               := No_Token_Index;
      Transform_Res86 :
            Bare_Module_Ref_Id
               := No_Bare_Lkt_Node;
      Transform_Diags86 :
            Ada.Containers.Count_Type;
      Transform_Res87 :
            Bare_Import
               := No_Bare_Lkt_Node;
      Transform_Diags87 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Import_Stmt_Transform_Parse1_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res87 := M.Instance;
      return Transform_Res87;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res87;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareImport>) (root of 'import_stmt') at parser.lkt:11:20>

Transform_Diags87 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'import_stmt') at ???>

Row_Pos96 := Pos;



--  BEGIN <Token(<WithText ImportKw>, ) (root of 'import_stmt') at parser.lkt:11:27>

Token_Res148 := Row_Pos96;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res148));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Import_Kw)
   then
       Token_Pos148 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos96 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos96,
             Expected_Token_Id => Lkt_Import_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos148 := Row_Pos96 + 1;
   end if;
end;

--  END <Token(<WithText ImportKw>, ) (root of 'import_stmt') at parser.lkt:11:27>




if Token_Pos148 /= No_Token_Index then

   Row_Pos96 := Token_Pos148;

else
   Row_Pos96 := No_Token_Index;
   goto Exit_Row96_0;

end if;


--  BEGIN <Transform(<CompiledType BareModuleRefId>) (root of 'import_stmt') at parser.lkt:11:36>

Transform_Diags86 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'import_stmt') at ???>

Row_Pos97 := Row_Pos96;



--  BEGIN <Token(<WithSymbol Identifier>, ) (root of 'import_stmt') at parser.lkt:11:48>

Token_Res149 := Row_Pos97;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res149));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
   then
       Token_Pos149 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos97 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos97,
             Expected_Token_Id => Lkt_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos149 := Row_Pos97 + 1;
   end if;
end;

--  END <Token(<WithSymbol Identifier>, ) (root of 'import_stmt') at parser.lkt:11:48>




if Token_Pos149 /= No_Token_Index then

   Row_Pos97 := Token_Pos149;

else
   Row_Pos97 := No_Token_Index;
   goto Exit_Row97_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row97_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'import_stmt') at ???>



if Row_Pos97 /= No_Token_Index then

   Transform_Res86 := Allocate_Module_Ref_Id (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res86,
      Kind => Lkt_Module_Ref_Id,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos96,
      Token_End_Index   => (if Row_Pos97 = Row_Pos96
                            then No_Token_Index
                            else Row_Pos97 - 1));

      
      Initialize_Fields_For_Module_Ref_Id
        (Self => Transform_Res86);



elsif Row_Pos97 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags86);
end if;

--  END <Transform(<CompiledType BareModuleRefId>) (root of 'import_stmt') at parser.lkt:11:36>




if Row_Pos97 /= No_Token_Index then

   Row_Pos96 := Row_Pos97;

else
   Row_Pos96 := No_Token_Index;
   goto Exit_Row96_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row96_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'import_stmt') at ???>



if Row_Pos96 /= No_Token_Index then

   Transform_Res87 := Allocate_Import (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res87,
      Kind => Lkt_Import,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos96 = Pos
                            then No_Token_Index
                            else Row_Pos96 - 1));

      
      Initialize_Fields_For_Import
        (Self => Transform_Res87,
         Import_F_Name => Transform_Res86);

         if Transform_Res86 /= null and then Is_Incomplete (Transform_Res86) then
            Transform_Res87.Last_Attempted_Child := 0;
         elsif Transform_Res86 /= null and then not Is_Ghost (Transform_Res86) then
            Transform_Res87.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos96 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags87);
end if;

--  END <Transform(<CompiledType BareImport>) (root of 'import_stmt') at parser.lkt:11:20>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Import_Stmt_Transform_Parse1_Memo,
      Row_Pos96 /= No_Token_Index,
      Transform_Res87,
      Pos,
      Row_Pos96);


   Parser.Current_Pos := Row_Pos96;

   return Transform_Res87;
end Import_Stmt_Transform_Parse1;

   


function Imports_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Import_List
is
   use Bare_Import_List_Memos;

      Lst_Cpos19 :
            Token_Index
               := No_Token_Index;
      Tmp_List19 :
            Free_Parse_List;
      Defer_Pos141 :
            Token_Index
               := No_Token_Index;
      Defer_Res141 :
            Bare_Import
               := No_Bare_Lkt_Node;
      List_Pos19 :
            Token_Index
               := No_Token_Index;
      List_Res19 :
            Bare_Import_List
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Imports_List_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res19 := M.Instance;
      return List_Res19;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return List_Res19;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <List (root of 'imports') at parser.lkt:12:16>

    List_Pos19 := Pos;



Lst_Cpos19 := Pos;
Tmp_List19 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'import_stmt') at parser.lkt:12:22>

Defer_Res141 :=
   Import_Stmt_Transform_Parse1 (Parser, Lst_Cpos19);
Defer_Pos141 := Parser.Current_Pos;

--  END <Defer (for 'import_stmt') at parser.lkt:12:22>


   exit when Defer_Pos141 = No_Token_Index;

   List_Pos19 := Defer_Pos141;
   Lst_Cpos19 := List_Pos19;

   Tmp_List19.Nodes.Append (Defer_Res141);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List19.Nodes.Length;
begin
   List_Res19 := Allocate_Import_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos19 = Pos
                    then Pos
                    else List_Pos19 - 1);

   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res19,
      Kind              => Lkt_Import_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res19,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List19.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res19.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List19);

--  END <List (root of 'imports') at parser.lkt:12:16>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Imports_List_Parse0_Memo,
      List_Pos19 /= No_Token_Index,
      List_Res19,
      Pos,
      List_Pos19);


   Parser.Current_Pos := List_Pos19;

   return List_Res19;
end Imports_List_Parse0;

   


function Isa_Or_Primary_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

      Row_Pos98 :
            Token_Index
               := No_Token_Index;
      Defer_Pos142 :
            Token_Index
               := No_Token_Index;
      Defer_Res142 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos150 :
            Token_Index
               := No_Token_Index;
      Token_Res150 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos20 :
            Token_Index
               := No_Token_Index;
      Tmp_List20 :
            Free_Parse_List;
      Defer_Pos143 :
            Token_Index
               := No_Token_Index;
      Defer_Res143 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Token_Pos151 :
            Token_Index
               := No_Token_Index;
      Token_Res151 :
            Token_Index
               := No_Token_Index;
      List_Pos20 :
            Token_Index
               := No_Token_Index;
      List_Res20 :
            Bare_Isa_List
               := No_Bare_Lkt_Node;
      Transform_Res88 :
            Bare_Isa
               := No_Bare_Lkt_Node;
      Transform_Diags88 :
            Ada.Containers.Count_Type;
      Row_Pos99 :
            Token_Index
               := No_Token_Index;
      Defer_Pos144 :
            Token_Index
               := No_Token_Index;
      Defer_Res144 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos152 :
            Token_Index
               := No_Token_Index;
      Token_Res152 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos21 :
            Token_Index
               := No_Token_Index;
      Tmp_List21 :
            Free_Parse_List;
      Defer_Pos145 :
            Token_Index
               := No_Token_Index;
      Defer_Res145 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos153 :
            Token_Index
               := No_Token_Index;
      Token_Res153 :
            Token_Index
               := No_Token_Index;
      List_Pos21 :
            Token_Index
               := No_Token_Index;
      List_Res21 :
            Bare_Any_Of_List
               := No_Bare_Lkt_Node;
      Transform_Res89 :
            Bare_Any_Of
               := No_Bare_Lkt_Node;
      Transform_Diags89 :
            Ada.Containers.Count_Type;
      Row_Pos100 :
            Token_Index
               := No_Token_Index;
      Defer_Pos146 :
            Token_Index
               := No_Token_Index;
      Defer_Res146 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos154 :
            Token_Index
               := No_Token_Index;
      Token_Res154 :
            Token_Index
               := No_Token_Index;
      Defer_Pos147 :
            Token_Index
               := No_Token_Index;
      Defer_Res147 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res90 :
            Bare_Logic_Unify
               := No_Bare_Lkt_Node;
      Transform_Diags90 :
            Ada.Containers.Count_Type;
      Row_Pos101 :
            Token_Index
               := No_Token_Index;
      Defer_Pos148 :
            Token_Index
               := No_Token_Index;
      Defer_Res148 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos155 :
            Token_Index
               := No_Token_Index;
      Token_Res155 :
            Token_Index
               := No_Token_Index;
      Defer_Pos149 :
            Token_Index
               := No_Token_Index;
      Defer_Res149 :
            Bare_Logic_Propagate_Call
               := No_Bare_Lkt_Node;
      Transform_Res91 :
            Bare_Logic_Propagate
               := No_Bare_Lkt_Node;
      Transform_Diags91 :
            Ada.Containers.Count_Type;
      Row_Pos102 :
            Token_Index
               := No_Token_Index;
      Defer_Pos150 :
            Token_Index
               := No_Token_Index;
      Defer_Res150 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos156 :
            Token_Index
               := No_Token_Index;
      Token_Res156 :
            Token_Index
               := No_Token_Index;
      Defer_Pos151 :
            Token_Index
               := No_Token_Index;
      Defer_Res151 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res92 :
            Bare_Logic_Assign
               := No_Bare_Lkt_Node;
      Transform_Diags92 :
            Ada.Containers.Count_Type;
      Defer_Pos152 :
            Token_Index
               := No_Token_Index;
      Defer_Res152 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Or_Pos22 :
            Token_Index
               := No_Token_Index;
      Or_Res22 :
            Bare_Expr
               := No_Bare_Lkt_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Expr := No_Bare_Lkt_Node;

   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Isa_Or_Primary_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res22 := M.Instance;
      return Or_Res22;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res22;
   end if;

       Set (PP.Isa_Or_Primary_Or_Parse0_Memo, False, Or_Res22, Pos, Mem_Pos);

       <<Try_Again>>



   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'isa_or_primary') at parser.lkt:269:23>

Or_Pos22 := No_Token_Index;
Or_Res22 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareIsa>) (root of 'isa_or_primary') at parser.lkt:270:11>

Transform_Diags88 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'isa_or_primary') at ???>

Row_Pos98 := Pos;



--  BEGIN <Defer (for 'primary') at parser.lkt:270:15>

Defer_Res142 :=
   Primary_Or_Parse0 (Parser, Row_Pos98);
Defer_Pos142 := Parser.Current_Pos;

--  END <Defer (for 'primary') at parser.lkt:270:15>




if Defer_Pos142 /= No_Token_Index then

   Row_Pos98 := Defer_Pos142;

else
   Row_Pos98 := No_Token_Index;
   goto Exit_Row98_0;

end if;


--  BEGIN <Token(<WithText IsKw>, ) (root of 'isa_or_primary') at parser.lkt:270:23>

Token_Res150 := Row_Pos98;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res150));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Is_Kw)
   then
       Token_Pos150 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos98 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos98,
             Expected_Token_Id => Lkt_Is_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos150 := Row_Pos98 + 1;
   end if;
end;

--  END <Token(<WithText IsKw>, ) (root of 'isa_or_primary') at parser.lkt:270:23>




if Token_Pos150 /= No_Token_Index then

   Row_Pos98 := Token_Pos150;

else
   Row_Pos98 := No_Token_Index;
   goto Exit_Row98_0;

end if;


--  BEGIN <List (root of 'isa_or_primary') at parser.lkt:270:28>

    List_Pos20 := No_Token_Index;



Lst_Cpos20 := Row_Pos98;
Tmp_List20 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'type_ref') at parser.lkt:270:37>

Defer_Res143 :=
   Type_Ref_Or_Parse0 (Parser, Lst_Cpos20);
Defer_Pos143 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:270:37>


   exit when Defer_Pos143 = No_Token_Index;

   List_Pos20 := Defer_Pos143;
   Lst_Cpos20 := List_Pos20;

   Tmp_List20.Nodes.Append (Defer_Res143);

      
--  BEGIN <Token(<WithText Pipe>, ) (root of 'isa_or_primary') at parser.lkt:270:47>

Token_Res151 := Lst_Cpos20;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res151));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Pipe)
   then
       Token_Pos151 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos20 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos20,
             Expected_Token_Id => Lkt_Pipe,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos151 := Lst_Cpos20 + 1;
   end if;
end;

--  END <Token(<WithText Pipe>, ) (root of 'isa_or_primary') at parser.lkt:270:47>


      exit when Token_Pos151 = No_Token_Index;

      Lst_Cpos20 := Token_Pos151;

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List20.Nodes.Length;
begin
   List_Res20 := Allocate_Isa_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos98;
      Token_End := (if Lst_Cpos20 = Row_Pos98
                    then Row_Pos98
                    else List_Pos20 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos98, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res20,
      Kind              => Lkt_Isa_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res20,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List20.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res20.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List20);

--  END <List (root of 'isa_or_primary') at parser.lkt:270:28>




if List_Pos20 /= No_Token_Index then

   Row_Pos98 := List_Pos20;

else
   Row_Pos98 := No_Token_Index;
   goto Exit_Row98_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row98_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'isa_or_primary') at ???>



if Row_Pos98 /= No_Token_Index then

   Transform_Res88 := Allocate_Isa (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res88,
      Kind => Lkt_Isa,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos98 = Pos
                            then No_Token_Index
                            else Row_Pos98 - 1));

      
      Initialize_Fields_For_Isa
        (Self => Transform_Res88,
         Isa_F_Expr => Defer_Res142,
         Isa_F_Dest_Type => List_Res20);

         if Defer_Res142 /= null and then Is_Incomplete (Defer_Res142) then
            Transform_Res88.Last_Attempted_Child := 0;
         elsif Defer_Res142 /= null and then not Is_Ghost (Defer_Res142) then
            Transform_Res88.Last_Attempted_Child := -1;
         end if;
         if List_Res20 /= null and then Is_Incomplete (List_Res20) then
            Transform_Res88.Last_Attempted_Child := 0;
         elsif List_Res20 /= null and then not Is_Ghost (List_Res20) then
            Transform_Res88.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos98 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags88);
end if;

--  END <Transform(<CompiledType BareIsa>) (root of 'isa_or_primary') at parser.lkt:270:11>

    if Row_Pos98 /= No_Token_Index then
        Or_Pos22 := Row_Pos98;
        Or_Res22 := Transform_Res88;
        goto Exit_Or22;
    end if;
    
--  BEGIN <Transform(<CompiledType BareAnyOf>) (root of 'isa_or_primary') at parser.lkt:271:11>

Transform_Diags89 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'isa_or_primary') at ???>

Row_Pos99 := Pos;



--  BEGIN <Defer (for 'primary') at parser.lkt:271:17>

Defer_Res144 :=
   Primary_Or_Parse0 (Parser, Row_Pos99);
Defer_Pos144 := Parser.Current_Pos;

--  END <Defer (for 'primary') at parser.lkt:271:17>




if Defer_Pos144 /= No_Token_Index then

   Row_Pos99 := Defer_Pos144;

else
   Row_Pos99 := No_Token_Index;
   goto Exit_Row99_0;

end if;


--  BEGIN <Token(<WithText InKw>, ) (root of 'isa_or_primary') at parser.lkt:271:25>

Token_Res152 := Row_Pos99;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res152));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_In_Kw)
   then
       Token_Pos152 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos99 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos99,
             Expected_Token_Id => Lkt_In_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos152 := Row_Pos99 + 1;
   end if;
end;

--  END <Token(<WithText InKw>, ) (root of 'isa_or_primary') at parser.lkt:271:25>




if Token_Pos152 /= No_Token_Index then

   Row_Pos99 := Token_Pos152;

else
   Row_Pos99 := No_Token_Index;
   goto Exit_Row99_0;

end if;


--  BEGIN <List (root of 'isa_or_primary') at parser.lkt:271:30>

    List_Pos21 := No_Token_Index;



Lst_Cpos21 := Row_Pos99;
Tmp_List21 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'primary') at parser.lkt:271:41>

Defer_Res145 :=
   Primary_Or_Parse0 (Parser, Lst_Cpos21);
Defer_Pos145 := Parser.Current_Pos;

--  END <Defer (for 'primary') at parser.lkt:271:41>


   exit when Defer_Pos145 = No_Token_Index;

   List_Pos21 := Defer_Pos145;
   Lst_Cpos21 := List_Pos21;

   Tmp_List21.Nodes.Append (Defer_Res145);

      
--  BEGIN <Token(<WithText Pipe>, ) (root of 'isa_or_primary') at parser.lkt:271:50>

Token_Res153 := Lst_Cpos21;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res153));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Pipe)
   then
       Token_Pos153 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos21 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos21,
             Expected_Token_Id => Lkt_Pipe,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos153 := Lst_Cpos21 + 1;
   end if;
end;

--  END <Token(<WithText Pipe>, ) (root of 'isa_or_primary') at parser.lkt:271:50>


      exit when Token_Pos153 = No_Token_Index;

      Lst_Cpos21 := Token_Pos153;

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List21.Nodes.Length;
begin
   List_Res21 := Allocate_Any_Of_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos99;
      Token_End := (if Lst_Cpos21 = Row_Pos99
                    then Row_Pos99
                    else List_Pos21 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos99, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res21,
      Kind              => Lkt_Any_Of_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res21,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List21.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res21.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List21);

--  END <List (root of 'isa_or_primary') at parser.lkt:271:30>




if List_Pos21 /= No_Token_Index then

   Row_Pos99 := List_Pos21;

else
   Row_Pos99 := No_Token_Index;
   goto Exit_Row99_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row99_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'isa_or_primary') at ???>



if Row_Pos99 /= No_Token_Index then

   Transform_Res89 := Allocate_Any_Of (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res89,
      Kind => Lkt_Any_Of,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos99 = Pos
                            then No_Token_Index
                            else Row_Pos99 - 1));

      
      Initialize_Fields_For_Any_Of
        (Self => Transform_Res89,
         Any_Of_F_Expr => Defer_Res144,
         Any_Of_F_Values => List_Res21);

         if Defer_Res144 /= null and then Is_Incomplete (Defer_Res144) then
            Transform_Res89.Last_Attempted_Child := 0;
         elsif Defer_Res144 /= null and then not Is_Ghost (Defer_Res144) then
            Transform_Res89.Last_Attempted_Child := -1;
         end if;
         if List_Res21 /= null and then Is_Incomplete (List_Res21) then
            Transform_Res89.Last_Attempted_Child := 0;
         elsif List_Res21 /= null and then not Is_Ghost (List_Res21) then
            Transform_Res89.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos99 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags89);
end if;

--  END <Transform(<CompiledType BareAnyOf>) (root of 'isa_or_primary') at parser.lkt:271:11>

    if Row_Pos99 /= No_Token_Index then
        Or_Pos22 := Row_Pos99;
        Or_Res22 := Transform_Res89;
        goto Exit_Or22;
    end if;
    
--  BEGIN <Transform(<CompiledType BareLogicUnify>) (root of 'isa_or_primary') at parser.lkt:272:11>

Transform_Diags90 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'isa_or_primary') at ???>

Row_Pos100 := Pos;



--  BEGIN <Defer (for 'isa_or_primary') at parser.lkt:272:22>

Defer_Res146 :=
   Isa_Or_Primary_Or_Parse0 (Parser, Row_Pos100);
Defer_Pos146 := Parser.Current_Pos;

--  END <Defer (for 'isa_or_primary') at parser.lkt:272:22>




if Defer_Pos146 /= No_Token_Index then

   Row_Pos100 := Defer_Pos146;

else
   Row_Pos100 := No_Token_Index;
   goto Exit_Row100_0;

end if;


--  BEGIN <Token(<WithText TwoSidedArrow>, ) (root of 'isa_or_primary') at parser.lkt:272:37>

Token_Res154 := Row_Pos100;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res154));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Two_Sided_Arrow)
   then
       Token_Pos154 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos100 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos100,
             Expected_Token_Id => Lkt_Two_Sided_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos154 := Row_Pos100 + 1;
   end if;
end;

--  END <Token(<WithText TwoSidedArrow>, ) (root of 'isa_or_primary') at parser.lkt:272:37>




if Token_Pos154 /= No_Token_Index then

   Row_Pos100 := Token_Pos154;

else
   Row_Pos100 := No_Token_Index;
   goto Exit_Row100_0;

end if;


--  BEGIN <Defer (for 'primary') at parser.lkt:272:43>

Defer_Res147 :=
   Primary_Or_Parse0 (Parser, Row_Pos100);
Defer_Pos147 := Parser.Current_Pos;

--  END <Defer (for 'primary') at parser.lkt:272:43>




if Defer_Pos147 /= No_Token_Index then

   Row_Pos100 := Defer_Pos147;

else
   Row_Pos100 := No_Token_Index;
   goto Exit_Row100_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row100_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'isa_or_primary') at ???>



if Row_Pos100 /= No_Token_Index then

   Transform_Res90 := Allocate_Logic_Unify (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res90,
      Kind => Lkt_Logic_Unify,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos100 = Pos
                            then No_Token_Index
                            else Row_Pos100 - 1));

      
      Initialize_Fields_For_Logic_Unify
        (Self => Transform_Res90,
         Logic_Unify_F_Lhs => Defer_Res146,
         Logic_Unify_F_Rhs => Defer_Res147);

         if Defer_Res146 /= null and then Is_Incomplete (Defer_Res146) then
            Transform_Res90.Last_Attempted_Child := 0;
         elsif Defer_Res146 /= null and then not Is_Ghost (Defer_Res146) then
            Transform_Res90.Last_Attempted_Child := -1;
         end if;
         if Defer_Res147 /= null and then Is_Incomplete (Defer_Res147) then
            Transform_Res90.Last_Attempted_Child := 0;
         elsif Defer_Res147 /= null and then not Is_Ghost (Defer_Res147) then
            Transform_Res90.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos100 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags90);
end if;

--  END <Transform(<CompiledType BareLogicUnify>) (root of 'isa_or_primary') at parser.lkt:272:11>

    if Row_Pos100 /= No_Token_Index then
        Or_Pos22 := Row_Pos100;
        Or_Res22 := Transform_Res90;
        goto Exit_Or22;
    end if;
    
--  BEGIN <Transform(<CompiledType BareLogicPropagate>) (root of 'isa_or_primary') at parser.lkt:273:11>

Transform_Diags91 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'isa_or_primary') at ???>

Row_Pos101 := Pos;



--  BEGIN <Defer (for 'isa_or_primary') at parser.lkt:273:26>

Defer_Res148 :=
   Isa_Or_Primary_Or_Parse0 (Parser, Row_Pos101);
Defer_Pos148 := Parser.Current_Pos;

--  END <Defer (for 'isa_or_primary') at parser.lkt:273:26>




if Defer_Pos148 /= No_Token_Index then

   Row_Pos101 := Defer_Pos148;

else
   Row_Pos101 := No_Token_Index;
   goto Exit_Row101_0;

end if;


--  BEGIN <Token(<WithText LeftArrow>, ) (root of 'isa_or_primary') at parser.lkt:273:41>

Token_Res155 := Row_Pos101;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res155));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Left_Arrow)
   then
       Token_Pos155 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos101 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos101,
             Expected_Token_Id => Lkt_Left_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos155 := Row_Pos101 + 1;
   end if;
end;

--  END <Token(<WithText LeftArrow>, ) (root of 'isa_or_primary') at parser.lkt:273:41>




if Token_Pos155 /= No_Token_Index then

   Row_Pos101 := Token_Pos155;

else
   Row_Pos101 := No_Token_Index;
   goto Exit_Row101_0;

end if;


--  BEGIN <Defer (for 'logic_propagate_call') at parser.lkt:273:46>

Defer_Res149 :=
   Logic_Propagate_Call_Transform_Parse0 (Parser, Row_Pos101);
Defer_Pos149 := Parser.Current_Pos;

--  END <Defer (for 'logic_propagate_call') at parser.lkt:273:46>




if Defer_Pos149 /= No_Token_Index then

   Row_Pos101 := Defer_Pos149;

else
   Row_Pos101 := No_Token_Index;
   goto Exit_Row101_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row101_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'isa_or_primary') at ???>



if Row_Pos101 /= No_Token_Index then

   Transform_Res91 := Allocate_Logic_Propagate (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res91,
      Kind => Lkt_Logic_Propagate,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos101 = Pos
                            then No_Token_Index
                            else Row_Pos101 - 1));

      
      Initialize_Fields_For_Logic_Propagate
        (Self => Transform_Res91,
         Logic_Propagate_F_Dest_Var => Defer_Res148,
         Logic_Propagate_F_Call => Defer_Res149);

         if Defer_Res148 /= null and then Is_Incomplete (Defer_Res148) then
            Transform_Res91.Last_Attempted_Child := 0;
         elsif Defer_Res148 /= null and then not Is_Ghost (Defer_Res148) then
            Transform_Res91.Last_Attempted_Child := -1;
         end if;
         if Defer_Res149 /= null and then Is_Incomplete (Defer_Res149) then
            Transform_Res91.Last_Attempted_Child := 0;
         elsif Defer_Res149 /= null and then not Is_Ghost (Defer_Res149) then
            Transform_Res91.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos101 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags91);
end if;

--  END <Transform(<CompiledType BareLogicPropagate>) (root of 'isa_or_primary') at parser.lkt:273:11>

    if Row_Pos101 /= No_Token_Index then
        Or_Pos22 := Row_Pos101;
        Or_Res22 := Transform_Res91;
        goto Exit_Or22;
    end if;
    
--  BEGIN <Transform(<CompiledType BareLogicAssign>) (root of 'isa_or_primary') at parser.lkt:274:11>

Transform_Diags92 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'isa_or_primary') at ???>

Row_Pos102 := Pos;



--  BEGIN <Defer (for 'isa_or_primary') at parser.lkt:274:23>

Defer_Res150 :=
   Isa_Or_Primary_Or_Parse0 (Parser, Row_Pos102);
Defer_Pos150 := Parser.Current_Pos;

--  END <Defer (for 'isa_or_primary') at parser.lkt:274:23>




if Defer_Pos150 /= No_Token_Index then

   Row_Pos102 := Defer_Pos150;

else
   Row_Pos102 := No_Token_Index;
   goto Exit_Row102_0;

end if;


--  BEGIN <Token(<WithText LeftArrow>, ) (root of 'isa_or_primary') at parser.lkt:274:38>

Token_Res156 := Row_Pos102;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res156));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Left_Arrow)
   then
       Token_Pos156 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos102 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos102,
             Expected_Token_Id => Lkt_Left_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos156 := Row_Pos102 + 1;
   end if;
end;

--  END <Token(<WithText LeftArrow>, ) (root of 'isa_or_primary') at parser.lkt:274:38>




if Token_Pos156 /= No_Token_Index then

   Row_Pos102 := Token_Pos156;

else
   Row_Pos102 := No_Token_Index;
   goto Exit_Row102_0;

end if;


--  BEGIN <Defer (for 'primary') at parser.lkt:274:43>

Defer_Res151 :=
   Primary_Or_Parse0 (Parser, Row_Pos102);
Defer_Pos151 := Parser.Current_Pos;

--  END <Defer (for 'primary') at parser.lkt:274:43>




if Defer_Pos151 /= No_Token_Index then

   Row_Pos102 := Defer_Pos151;

else
   Row_Pos102 := No_Token_Index;
   goto Exit_Row102_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row102_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'isa_or_primary') at ???>



if Row_Pos102 /= No_Token_Index then

   Transform_Res92 := Allocate_Logic_Assign (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res92,
      Kind => Lkt_Logic_Assign,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos102 = Pos
                            then No_Token_Index
                            else Row_Pos102 - 1));

      
      Initialize_Fields_For_Logic_Assign
        (Self => Transform_Res92,
         Logic_Assign_F_Dest_Var => Defer_Res150,
         Logic_Assign_F_Value => Defer_Res151);

         if Defer_Res150 /= null and then Is_Incomplete (Defer_Res150) then
            Transform_Res92.Last_Attempted_Child := 0;
         elsif Defer_Res150 /= null and then not Is_Ghost (Defer_Res150) then
            Transform_Res92.Last_Attempted_Child := -1;
         end if;
         if Defer_Res151 /= null and then Is_Incomplete (Defer_Res151) then
            Transform_Res92.Last_Attempted_Child := 0;
         elsif Defer_Res151 /= null and then not Is_Ghost (Defer_Res151) then
            Transform_Res92.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos102 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags92);
end if;

--  END <Transform(<CompiledType BareLogicAssign>) (root of 'isa_or_primary') at parser.lkt:274:11>

    if Row_Pos102 /= No_Token_Index then
        Or_Pos22 := Row_Pos102;
        Or_Res22 := Transform_Res92;
        goto Exit_Or22;
    end if;
    
--  BEGIN <Defer (for 'primary') at parser.lkt:275:11>

Defer_Res152 :=
   Primary_Or_Parse0 (Parser, Pos);
Defer_Pos152 := Parser.Current_Pos;

--  END <Defer (for 'primary') at parser.lkt:275:11>

    if Defer_Pos152 /= No_Token_Index then
        Or_Pos22 := Defer_Pos152;
        Or_Res22 := Defer_Res152;
        goto Exit_Or22;
    end if;
<<Exit_Or22>>

--  END <Or (root of 'isa_or_primary') at parser.lkt:269:23>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos22 > Mem_Pos then
         Mem_Pos := Or_Pos22;
         Mem_Res := Or_Res22;
         Set
           (PP.Isa_Or_Primary_Or_Parse0_Memo,
            Or_Pos22 /= No_Token_Index,
            Or_Res22,
            Pos,
            Or_Pos22);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res22 := Mem_Res;
         Or_Pos22 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (PP.Isa_Or_Primary_Or_Parse0_Memo,
      Or_Pos22 /= No_Token_Index,
      Or_Res22,
      Pos,
      Or_Pos22);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos22;

   return Or_Res22;
end Isa_Or_Primary_Or_Parse0;

   


function Lambda_Arg_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lambda_Arg_Decl
is
   use Bare_Lambda_Arg_Decl_Memos;

      Row_Pos103 :
            Token_Index
               := No_Token_Index;
      Defer_Pos153 :
            Token_Index
               := No_Token_Index;
      Defer_Res153 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Row_Pos104 :
            Token_Index
               := No_Token_Index;
      Token_Pos157 :
            Token_Index
               := No_Token_Index;
      Token_Res157 :
            Token_Index
               := No_Token_Index;
      Defer_Pos154 :
            Token_Index
               := No_Token_Index;
      Defer_Res154 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Row_Pos105 :
            Token_Index
               := No_Token_Index;
      Token_Pos158 :
            Token_Index
               := No_Token_Index;
      Token_Res158 :
            Token_Index
               := No_Token_Index;
      Defer_Pos155 :
            Token_Index
               := No_Token_Index;
      Defer_Res155 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res93 :
            Bare_Lambda_Arg_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags93 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Lambda_Arg_Decl_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res93 := M.Instance;
      return Transform_Res93;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res93;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareLambdaArgDecl>) (root of 'lambda_arg_decl') at parser.lkt:178:24>

Transform_Diags93 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'lambda_arg_decl') at ???>

Row_Pos103 := Pos;



--  BEGIN <Defer (for 'def_id') at parser.lkt:179:9>

Defer_Res153 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos103);
Defer_Pos153 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:179:9>




if Defer_Pos153 /= No_Token_Index then

   Row_Pos103 := Defer_Pos153;

else
   Row_Pos103 := No_Token_Index;
   goto Exit_Row103_0;

end if;


--  BEGIN <Opt (root of 'lambda_arg_decl') at parser.lkt:179:16>












--  BEGIN <_Extract (root of 'lambda_arg_decl') at parser.lkt:179:17>

--  BEGIN <_Row (root of 'lambda_arg_decl') at ???>

Row_Pos104 := Row_Pos103;



--  BEGIN <Token(<WithText Colon>, ) (root of 'lambda_arg_decl') at parser.lkt:179:22>

Token_Res157 := Row_Pos104;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res157));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos157 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos104 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos104,
             Expected_Token_Id => Lkt_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos157 := Row_Pos104 + 1;
   end if;
end;

--  END <Token(<WithText Colon>, ) (root of 'lambda_arg_decl') at parser.lkt:179:22>




if Token_Pos157 /= No_Token_Index then

   Row_Pos104 := Token_Pos157;

else
   Row_Pos104 := No_Token_Index;
   goto Exit_Row104_0;

end if;


--  BEGIN <Defer (for 'type_ref') at parser.lkt:179:26>

Defer_Res154 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos104);
Defer_Pos154 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:179:26>




if Defer_Pos154 /= No_Token_Index then

   Row_Pos104 := Defer_Pos154;

else
   Row_Pos104 := No_Token_Index;
   goto Exit_Row104_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row104_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'lambda_arg_decl') at ???>

--  END <_Extract (root of 'lambda_arg_decl') at parser.lkt:179:17>


if Row_Pos104 = No_Token_Index then

         
   Defer_Res154 := No_Bare_Lkt_Node;



       
   Row_Pos104 := Row_Pos103;



end if;

--  END <Opt (root of 'lambda_arg_decl') at parser.lkt:179:16>




if Row_Pos104 /= No_Token_Index then

   Row_Pos103 := Row_Pos104;

else
   Row_Pos103 := No_Token_Index;
   goto Exit_Row103_0;

end if;


--  BEGIN <Opt (root of 'lambda_arg_decl') at parser.lkt:179:36>












--  BEGIN <_Extract (root of 'lambda_arg_decl') at parser.lkt:179:37>

--  BEGIN <_Row (root of 'lambda_arg_decl') at ???>

Row_Pos105 := Row_Pos103;



--  BEGIN <Token(<WithText Equal>, ) (root of 'lambda_arg_decl') at parser.lkt:179:42>

Token_Res158 := Row_Pos105;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res158));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Equal)
   then
       Token_Pos158 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos105 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos105,
             Expected_Token_Id => Lkt_Equal,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos158 := Row_Pos105 + 1;
   end if;
end;

--  END <Token(<WithText Equal>, ) (root of 'lambda_arg_decl') at parser.lkt:179:42>




if Token_Pos158 /= No_Token_Index then

   Row_Pos105 := Token_Pos158;

else
   Row_Pos105 := No_Token_Index;
   goto Exit_Row105_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:179:46>

Defer_Res155 :=
   Expr_Or_Parse1 (Parser, Row_Pos105);
Defer_Pos155 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:179:46>




if Defer_Pos155 /= No_Token_Index then

   Row_Pos105 := Defer_Pos155;

else
   Row_Pos105 := No_Token_Index;
   goto Exit_Row105_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row105_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'lambda_arg_decl') at ???>

--  END <_Extract (root of 'lambda_arg_decl') at parser.lkt:179:37>


if Row_Pos105 = No_Token_Index then

         
   Defer_Res155 := No_Bare_Lkt_Node;



       
   Row_Pos105 := Row_Pos103;



end if;

--  END <Opt (root of 'lambda_arg_decl') at parser.lkt:179:36>




if Row_Pos105 /= No_Token_Index then

   Row_Pos103 := Row_Pos105;

else
   Row_Pos103 := No_Token_Index;
   goto Exit_Row103_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row103_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'lambda_arg_decl') at ???>



if Row_Pos103 /= No_Token_Index then

   Transform_Res93 := Allocate_Lambda_Arg_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res93,
      Kind => Lkt_Lambda_Arg_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos103 = Pos
                            then No_Token_Index
                            else Row_Pos103 - 1));

      
      Initialize_Fields_For_Lambda_Arg_Decl
        (Self => Transform_Res93,
         Lambda_Arg_Decl_F_Syn_Name => Defer_Res153,
         Lambda_Arg_Decl_F_Decl_Type => Defer_Res154,
         Lambda_Arg_Decl_F_Default_Val => Defer_Res155);

         if Defer_Res153 /= null and then Is_Incomplete (Defer_Res153) then
            Transform_Res93.Last_Attempted_Child := 0;
         elsif Defer_Res153 /= null and then not Is_Ghost (Defer_Res153) then
            Transform_Res93.Last_Attempted_Child := -1;
         end if;
         if Defer_Res154 /= null and then Is_Incomplete (Defer_Res154) then
            Transform_Res93.Last_Attempted_Child := 0;
         elsif Defer_Res154 /= null and then not Is_Ghost (Defer_Res154) then
            Transform_Res93.Last_Attempted_Child := -1;
         end if;
         if Defer_Res155 /= null and then Is_Incomplete (Defer_Res155) then
            Transform_Res93.Last_Attempted_Child := 0;
         elsif Defer_Res155 /= null and then not Is_Ghost (Defer_Res155) then
            Transform_Res93.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos103 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags93);
end if;

--  END <Transform(<CompiledType BareLambdaArgDecl>) (root of 'lambda_arg_decl') at parser.lkt:178:24>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Lambda_Arg_Decl_Transform_Parse0_Memo,
      Row_Pos103 /= No_Token_Index,
      Transform_Res93,
      Pos,
      Row_Pos103);


   Parser.Current_Pos := Row_Pos103;

   return Transform_Res93;
end Lambda_Arg_Decl_Transform_Parse0;

   


function Lambda_Arg_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lambda_Arg_Decl_List
is
   use Bare_Lambda_Arg_Decl_List_Memos;

      Lst_Cpos22 :
            Token_Index
               := No_Token_Index;
      Tmp_List22 :
            Free_Parse_List;
      Defer_Pos156 :
            Token_Index
               := No_Token_Index;
      Defer_Res156 :
            Bare_Lambda_Arg_Decl
               := No_Bare_Lkt_Node;
      Token_Pos159 :
            Token_Index
               := No_Token_Index;
      Token_Res159 :
            Token_Index
               := No_Token_Index;
      List_Pos22 :
            Token_Index
               := No_Token_Index;
      List_Res22 :
            Bare_Lambda_Arg_Decl_List
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Lambda_Arg_List_List_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res22 := M.Instance;
      return List_Res22;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return List_Res22;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <List (root of 'lambda_arg_list') at parser.lkt:185:24>

    List_Pos22 := Pos;



Lst_Cpos22 := Pos;
Tmp_List22 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'lambda_arg_decl') at parser.lkt:185:30>

Defer_Res156 :=
   Lambda_Arg_Decl_Transform_Parse0 (Parser, Lst_Cpos22);
Defer_Pos156 := Parser.Current_Pos;

--  END <Defer (for 'lambda_arg_decl') at parser.lkt:185:30>


   exit when Defer_Pos156 = No_Token_Index;

   List_Pos22 := Defer_Pos156;
   Lst_Cpos22 := List_Pos22;

   Tmp_List22.Nodes.Append (Defer_Res156);

      
--  BEGIN <Token(<WithText Comma>, ) (root of 'lambda_arg_list') at parser.lkt:185:47>

Token_Res159 := Lst_Cpos22;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res159));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos159 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos22 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos22,
             Expected_Token_Id => Lkt_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos159 := Lst_Cpos22 + 1;
   end if;
end;

--  END <Token(<WithText Comma>, ) (root of 'lambda_arg_list') at parser.lkt:185:47>


      exit when Token_Pos159 = No_Token_Index;

      Lst_Cpos22 := Token_Pos159;

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List22.Nodes.Length;
begin
   List_Res22 := Allocate_Lambda_Arg_Decl_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos22 = Pos
                    then Pos
                    else List_Pos22 - 1);

   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res22,
      Kind              => Lkt_Lambda_Arg_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res22,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List22.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res22.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List22);

--  END <List (root of 'lambda_arg_list') at parser.lkt:185:24>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Lambda_Arg_List_List_Parse0_Memo,
      List_Pos22 /= No_Token_Index,
      List_Res22,
      Pos,
      List_Pos22);


   Parser.Current_Pos := List_Pos22;

   return List_Res22;
end Lambda_Arg_List_List_Parse0;

   


function Lambda_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lambda_Expr
is
   use Bare_Lambda_Expr_Memos;

      Nobt2 :
            Boolean
               := False;
      Row_Pos106 :
            Token_Index
               := No_Token_Index;
      Token_Pos160 :
            Token_Index
               := No_Token_Index;
      Token_Res160 :
            Token_Index
               := No_Token_Index;
      Defer_Pos157 :
            Token_Index
               := No_Token_Index;
      Defer_Res157 :
            Bare_Lambda_Arg_Decl_List
               := No_Bare_Lkt_Node;
      Token_Pos161 :
            Token_Index
               := No_Token_Index;
      Token_Res161 :
            Token_Index
               := No_Token_Index;
      Row_Pos107 :
            Token_Index
               := No_Token_Index;
      Token_Pos162 :
            Token_Index
               := No_Token_Index;
      Token_Res162 :
            Token_Index
               := No_Token_Index;
      Defer_Pos158 :
            Token_Index
               := No_Token_Index;
      Defer_Res158 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Token_Pos163 :
            Token_Index
               := No_Token_Index;
      Token_Res163 :
            Token_Index
               := No_Token_Index;
      Defer_Pos159 :
            Token_Index
               := No_Token_Index;
      Defer_Res159 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Row_Progress2 :
            Integer
               := 0;
      Transform_Res94 :
            Bare_Lambda_Expr
               := No_Bare_Lkt_Node;
      Transform_Has_Failed2 :
            Boolean
               := False;
      Transform_Diags94 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Lambda_Expr_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res94 := M.Instance;
      return Transform_Res94;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res94;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareLambdaExpr>) (root of 'lambda_expr') at parser.lkt:344:20>

Transform_Diags94 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'lambda_expr') at ???>

Row_Pos106 := Pos;



--  BEGIN <Token(<WithText LPar>, ) (root of 'lambda_expr') at parser.lkt:345:9>

Token_Res160 := Row_Pos106;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res160));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos160 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos106 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos106,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos160 := Row_Pos106 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'lambda_expr') at parser.lkt:345:9>



Row_Progress2 := 1;

if Token_Pos160 /= No_Token_Index then

   Row_Pos106 := Token_Pos160;

else
   Row_Pos106 := No_Token_Index;
   goto Exit_Row106_0;

end if;


--  BEGIN <Defer (for 'lambda_arg_list') at parser.lkt:345:13>

Defer_Res157 :=
   Lambda_Arg_List_List_Parse0 (Parser, Row_Pos106);
Defer_Pos157 := Parser.Current_Pos;

--  END <Defer (for 'lambda_arg_list') at parser.lkt:345:13>



Row_Progress2 := 2;

if Defer_Pos157 /= No_Token_Index then

   Row_Pos106 := Defer_Pos157;

else
   Row_Pos106 := No_Token_Index;
   goto Exit_Row106_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'lambda_expr') at parser.lkt:345:29>

Token_Res161 := Row_Pos106;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res161));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos161 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos106 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos106,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos161 := Row_Pos106 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'lambda_expr') at parser.lkt:345:29>



Row_Progress2 := 3;

if Token_Pos161 /= No_Token_Index then

   Row_Pos106 := Token_Pos161;

else
   Row_Pos106 := No_Token_Index;
   goto Exit_Row106_0;

end if;


--  BEGIN <Opt (root of 'lambda_expr') at parser.lkt:345:33>












--  BEGIN <_Extract (root of 'lambda_expr') at parser.lkt:345:34>

--  BEGIN <_Row (root of 'lambda_expr') at ???>

Row_Pos107 := Row_Pos106;



--  BEGIN <Token(<WithText Colon>, ) (root of 'lambda_expr') at parser.lkt:345:39>

Token_Res162 := Row_Pos107;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res162));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos162 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos107 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos107,
             Expected_Token_Id => Lkt_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos162 := Row_Pos107 + 1;
   end if;
end;

--  END <Token(<WithText Colon>, ) (root of 'lambda_expr') at parser.lkt:345:39>




if Token_Pos162 /= No_Token_Index then

   Row_Pos107 := Token_Pos162;

else
   Row_Pos107 := No_Token_Index;
   goto Exit_Row107_0;

end if;


--  BEGIN <Defer (for 'type_ref') at parser.lkt:345:43>

Defer_Res158 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos107);
Defer_Pos158 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:345:43>




if Defer_Pos158 /= No_Token_Index then

   Row_Pos107 := Defer_Pos158;

else
   Row_Pos107 := No_Token_Index;
   goto Exit_Row107_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row107_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'lambda_expr') at ???>

--  END <_Extract (root of 'lambda_expr') at parser.lkt:345:34>


if Row_Pos107 = No_Token_Index then

         
   Defer_Res158 := No_Bare_Lkt_Node;



       
   Row_Pos107 := Row_Pos106;



end if;

--  END <Opt (root of 'lambda_expr') at parser.lkt:345:33>



Row_Progress2 := 4;

if Row_Pos107 /= No_Token_Index then

   Row_Pos106 := Row_Pos107;

else
   Row_Pos106 := No_Token_Index;
   goto Exit_Row106_0;

end if;


--  BEGIN <Token(<WithText FatRightArrow>, ) (root of 'lambda_expr') at parser.lkt:345:53>

Token_Res163 := Row_Pos106;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res163));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Fat_Right_Arrow)
   then
       Token_Pos163 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos106 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos106,
             Expected_Token_Id => Lkt_Fat_Right_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos163 := Row_Pos106 + 1;
   end if;
end;

--  END <Token(<WithText FatRightArrow>, ) (root of 'lambda_expr') at parser.lkt:345:53>



Row_Progress2 := 5;

if Token_Pos163 /= No_Token_Index then

   Row_Pos106 := Token_Pos163;

else
   Row_Pos106 := No_Token_Index;
   goto Exit_Row106_0;

end if;


--  BEGIN <Cut (root of 'lambda_expr') at ???>
Nobt2 := True;
--  END <Cut (root of 'lambda_expr') at ???>


   Nobt2 := Nobt2;

Row_Progress2 := 6;

if Row_Pos106 /= No_Token_Index then

   Row_Pos106 := Row_Pos106;

else
   Row_Pos106 := No_Token_Index;
   goto Exit_Row106_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:345:60>

Defer_Res159 :=
   Expr_Or_Parse1 (Parser, Row_Pos106);
Defer_Pos159 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:345:60>



Row_Progress2 := 7;

if Defer_Pos159 /= No_Token_Index then

   Row_Pos106 := Defer_Pos159;

else
   Row_Pos106 := No_Token_Index;
   goto Exit_Row106_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row106_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'lambda_expr') at ???>


if Row_Pos106 = No_Token_Index and then Nobt2 then

   Row_Pos106 := Parser.Last_Fail.Pos;

   Transform_Has_Failed2 := True;
end if;

if Row_Pos106 /= No_Token_Index then

   Transform_Res94 := Allocate_Lambda_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res94,
      Kind => Lkt_Lambda_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos106 = Pos
                            then No_Token_Index
                            else Row_Pos106 - 1));

      
      Initialize_Fields_For_Lambda_Expr
        (Self => Transform_Res94,
         Lambda_Expr_F_Params => Defer_Res157,
         Lambda_Expr_F_Return_Type => Defer_Res158,
         Lambda_Expr_F_Body => Defer_Res159);

         if Defer_Res157 /= null and then Is_Incomplete (Defer_Res157) then
            Transform_Res94.Last_Attempted_Child := 0;
         elsif Defer_Res157 /= null and then not Is_Ghost (Defer_Res157) then
            Transform_Res94.Last_Attempted_Child := -1;
         end if;
         if Defer_Res158 /= null and then Is_Incomplete (Defer_Res158) then
            Transform_Res94.Last_Attempted_Child := 0;
         elsif Defer_Res158 /= null and then not Is_Ghost (Defer_Res158) then
            Transform_Res94.Last_Attempted_Child := -1;
         end if;
         if Defer_Res159 /= null and then Is_Incomplete (Defer_Res159) then
            Transform_Res94.Last_Attempted_Child := 0;
         elsif Defer_Res159 /= null and then not Is_Ghost (Defer_Res159) then
            Transform_Res94.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed2 then
      Transform_Res94.Last_Attempted_Child :=
         Row_Progress2;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <lambda_expr>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos106 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags94);
end if;

--  END <Transform(<CompiledType BareLambdaExpr>) (root of 'lambda_expr') at parser.lkt:344:20>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Lambda_Expr_Transform_Parse0_Memo,
      Row_Pos106 /= No_Token_Index,
      Transform_Res94,
      Pos,
      Row_Pos106);


   Parser.Current_Pos := Row_Pos106;

   return Transform_Res94;
end Lambda_Expr_Transform_Parse0;

   


function Lexer_Case_Alt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Lexer_Case_Rule_Alt
is
   use Bare_Base_Lexer_Case_Rule_Alt_Memos;

      Row_Pos108 :
            Token_Index
               := No_Token_Index;
      Token_Pos164 :
            Token_Index
               := No_Token_Index;
      Token_Res164 :
            Token_Index
               := No_Token_Index;
      Token_Pos165 :
            Token_Index
               := No_Token_Index;
      Token_Res165 :
            Token_Index
               := No_Token_Index;
      Token_Pos166 :
            Token_Index
               := No_Token_Index;
      Token_Res166 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos23 :
            Token_Index
               := No_Token_Index;
      Tmp_List23 :
            Free_Parse_List;
      Defer_Pos160 :
            Token_Index
               := No_Token_Index;
      Defer_Res160 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Token_Pos167 :
            Token_Index
               := No_Token_Index;
      Token_Res167 :
            Token_Index
               := No_Token_Index;
      List_Pos23 :
            Token_Index
               := No_Token_Index;
      List_Res23 :
            Bare_Ref_Id_List
               := No_Bare_Lkt_Node;
      Token_Pos168 :
            Token_Index
               := No_Token_Index;
      Token_Res168 :
            Token_Index
               := No_Token_Index;
      Defer_Pos161 :
            Token_Index
               := No_Token_Index;
      Defer_Res161 :
            Bare_Lexer_Case_Rule_Send
               := No_Bare_Lkt_Node;
      Transform_Res95 :
            Bare_Lexer_Case_Rule_Cond_Alt
               := No_Bare_Lkt_Node;
      Transform_Diags95 :
            Ada.Containers.Count_Type;
      Row_Pos109 :
            Token_Index
               := No_Token_Index;
      Token_Pos169 :
            Token_Index
               := No_Token_Index;
      Token_Res169 :
            Token_Index
               := No_Token_Index;
      Defer_Pos162 :
            Token_Index
               := No_Token_Index;
      Defer_Res162 :
            Bare_Lexer_Case_Rule_Send
               := No_Bare_Lkt_Node;
      Transform_Res96 :
            Bare_Lexer_Case_Rule_Default_Alt
               := No_Bare_Lkt_Node;
      Transform_Diags96 :
            Ada.Containers.Count_Type;
      Or_Pos23 :
            Token_Index
               := No_Token_Index;
      Or_Res23 :
            Bare_Base_Lexer_Case_Rule_Alt
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Lexer_Case_Alt_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res23 := M.Instance;
      return Or_Res23;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res23;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'lexer_case_alt') at parser.lkt:27:23>

Or_Pos23 := No_Token_Index;
Or_Res23 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareLexerCaseRuleCondAlt>) (root of 'lexer_case_alt') at parser.lkt:28:11>

Transform_Diags95 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'lexer_case_alt') at ???>

Row_Pos108 := Pos;



--  BEGIN <Token(<WithText IfKw>, ) (root of 'lexer_case_alt') at parser.lkt:29:13>

Token_Res164 := Row_Pos108;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res164));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_If_Kw)
   then
       Token_Pos164 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos108 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos108,
             Expected_Token_Id => Lkt_If_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos164 := Row_Pos108 + 1;
   end if;
end;

--  END <Token(<WithText IfKw>, ) (root of 'lexer_case_alt') at parser.lkt:29:13>




if Token_Pos164 /= No_Token_Index then

   Row_Pos108 := Token_Pos164;

else
   Row_Pos108 := No_Token_Index;
   goto Exit_Row108_0;

end if;


--  BEGIN <Token(<WithSymbol Identifier>, previous_token) (root of 'lexer_case_alt') at parser.lkt:30:13>

Token_Res165 := Row_Pos108;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res165));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Previous_Token)
   then
       Token_Pos165 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos108 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos108,
             Expected_Token_Id => Lkt_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos165 := Row_Pos108 + 1;
   end if;
end;

--  END <Token(<WithSymbol Identifier>, previous_token) (root of 'lexer_case_alt') at parser.lkt:30:13>




if Token_Pos165 /= No_Token_Index then

   Row_Pos108 := Token_Pos165;

else
   Row_Pos108 := No_Token_Index;
   goto Exit_Row108_0;

end if;


--  BEGIN <Token(<WithText IsKw>, ) (root of 'lexer_case_alt') at parser.lkt:31:13>

Token_Res166 := Row_Pos108;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res166));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Is_Kw)
   then
       Token_Pos166 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos108 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos108,
             Expected_Token_Id => Lkt_Is_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos166 := Row_Pos108 + 1;
   end if;
end;

--  END <Token(<WithText IsKw>, ) (root of 'lexer_case_alt') at parser.lkt:31:13>




if Token_Pos166 /= No_Token_Index then

   Row_Pos108 := Token_Pos166;

else
   Row_Pos108 := No_Token_Index;
   goto Exit_Row108_0;

end if;


--  BEGIN <List (root of 'lexer_case_alt') at parser.lkt:32:13>

    List_Pos23 := No_Token_Index;



Lst_Cpos23 := Row_Pos108;
Tmp_List23 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'ref_id') at parser.lkt:32:19>

Defer_Res160 :=
   Ref_Id_Transform_Parse0 (Parser, Lst_Cpos23);
Defer_Pos160 := Parser.Current_Pos;

--  END <Defer (for 'ref_id') at parser.lkt:32:19>


   exit when Defer_Pos160 = No_Token_Index;

   List_Pos23 := Defer_Pos160;
   Lst_Cpos23 := List_Pos23;

   Tmp_List23.Nodes.Append (Defer_Res160);

      
--  BEGIN <Token(<WithText Pipe>, ) (root of 'lexer_case_alt') at parser.lkt:32:27>

Token_Res167 := Lst_Cpos23;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res167));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Pipe)
   then
       Token_Pos167 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos23 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos23,
             Expected_Token_Id => Lkt_Pipe,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos167 := Lst_Cpos23 + 1;
   end if;
end;

--  END <Token(<WithText Pipe>, ) (root of 'lexer_case_alt') at parser.lkt:32:27>


      exit when Token_Pos167 = No_Token_Index;

      Lst_Cpos23 := Token_Pos167;

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List23.Nodes.Length;
begin
   List_Res23 := Allocate_Ref_Id_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos108;
      Token_End := (if Lst_Cpos23 = Row_Pos108
                    then Row_Pos108
                    else List_Pos23 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos108, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res23,
      Kind              => Lkt_Ref_Id_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res23,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List23.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res23.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List23);

--  END <List (root of 'lexer_case_alt') at parser.lkt:32:13>




if List_Pos23 /= No_Token_Index then

   Row_Pos108 := List_Pos23;

else
   Row_Pos108 := No_Token_Index;
   goto Exit_Row108_0;

end if;


--  BEGIN <Token(<WithText ThenKw>, ) (root of 'lexer_case_alt') at parser.lkt:33:13>

Token_Res168 := Row_Pos108;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res168));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Then_Kw)
   then
       Token_Pos168 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos108 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos108,
             Expected_Token_Id => Lkt_Then_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos168 := Row_Pos108 + 1;
   end if;
end;

--  END <Token(<WithText ThenKw>, ) (root of 'lexer_case_alt') at parser.lkt:33:13>




if Token_Pos168 /= No_Token_Index then

   Row_Pos108 := Token_Pos168;

else
   Row_Pos108 := No_Token_Index;
   goto Exit_Row108_0;

end if;


--  BEGIN <Defer (for 'lexer_case_send') at parser.lkt:34:13>

Defer_Res161 :=
   Lexer_Case_Send_Transform_Parse0 (Parser, Row_Pos108);
Defer_Pos161 := Parser.Current_Pos;

--  END <Defer (for 'lexer_case_send') at parser.lkt:34:13>




if Defer_Pos161 /= No_Token_Index then

   Row_Pos108 := Defer_Pos161;

else
   Row_Pos108 := No_Token_Index;
   goto Exit_Row108_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row108_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'lexer_case_alt') at ???>



if Row_Pos108 /= No_Token_Index then

   Transform_Res95 := Allocate_Lexer_Case_Rule_Cond_Alt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res95,
      Kind => Lkt_Lexer_Case_Rule_Cond_Alt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos108 = Pos
                            then No_Token_Index
                            else Row_Pos108 - 1));

      
      Initialize_Fields_For_Lexer_Case_Rule_Cond_Alt
        (Self => Transform_Res95,
         Lexer_Case_Rule_Cond_Alt_F_Cond_Exprs => List_Res23,
         Lexer_Case_Rule_Cond_Alt_F_Send => Defer_Res161);

         if List_Res23 /= null and then Is_Incomplete (List_Res23) then
            Transform_Res95.Last_Attempted_Child := 0;
         elsif List_Res23 /= null and then not Is_Ghost (List_Res23) then
            Transform_Res95.Last_Attempted_Child := -1;
         end if;
         if Defer_Res161 /= null and then Is_Incomplete (Defer_Res161) then
            Transform_Res95.Last_Attempted_Child := 0;
         elsif Defer_Res161 /= null and then not Is_Ghost (Defer_Res161) then
            Transform_Res95.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos108 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags95);
end if;

--  END <Transform(<CompiledType BareLexerCaseRuleCondAlt>) (root of 'lexer_case_alt') at parser.lkt:28:11>

    if Row_Pos108 /= No_Token_Index then
        Or_Pos23 := Row_Pos108;
        Or_Res23 := Transform_Res95;
        goto Exit_Or23;
    end if;
    
--  BEGIN <Transform(<CompiledType BareLexerCaseRuleDefaultAlt>) (root of 'lexer_case_alt') at parser.lkt:36:11>

Transform_Diags96 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'lexer_case_alt') at ???>

Row_Pos109 := Pos;



--  BEGIN <Token(<WithText ElseKw>, ) (root of 'lexer_case_alt') at parser.lkt:36:35>

Token_Res169 := Row_Pos109;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res169));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Else_Kw)
   then
       Token_Pos169 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos109 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos109,
             Expected_Token_Id => Lkt_Else_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos169 := Row_Pos109 + 1;
   end if;
end;

--  END <Token(<WithText ElseKw>, ) (root of 'lexer_case_alt') at parser.lkt:36:35>




if Token_Pos169 /= No_Token_Index then

   Row_Pos109 := Token_Pos169;

else
   Row_Pos109 := No_Token_Index;
   goto Exit_Row109_0;

end if;


--  BEGIN <Defer (for 'lexer_case_send') at parser.lkt:36:42>

Defer_Res162 :=
   Lexer_Case_Send_Transform_Parse0 (Parser, Row_Pos109);
Defer_Pos162 := Parser.Current_Pos;

--  END <Defer (for 'lexer_case_send') at parser.lkt:36:42>




if Defer_Pos162 /= No_Token_Index then

   Row_Pos109 := Defer_Pos162;

else
   Row_Pos109 := No_Token_Index;
   goto Exit_Row109_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row109_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'lexer_case_alt') at ???>



if Row_Pos109 /= No_Token_Index then

   Transform_Res96 := Allocate_Lexer_Case_Rule_Default_Alt (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res96,
      Kind => Lkt_Lexer_Case_Rule_Default_Alt,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos109 = Pos
                            then No_Token_Index
                            else Row_Pos109 - 1));

      
      Initialize_Fields_For_Lexer_Case_Rule_Default_Alt
        (Self => Transform_Res96,
         Lexer_Case_Rule_Default_Alt_F_Send => Defer_Res162);

         if Defer_Res162 /= null and then Is_Incomplete (Defer_Res162) then
            Transform_Res96.Last_Attempted_Child := 0;
         elsif Defer_Res162 /= null and then not Is_Ghost (Defer_Res162) then
            Transform_Res96.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos109 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags96);
end if;

--  END <Transform(<CompiledType BareLexerCaseRuleDefaultAlt>) (root of 'lexer_case_alt') at parser.lkt:36:11>

    if Row_Pos109 /= No_Token_Index then
        Or_Pos23 := Row_Pos109;
        Or_Res23 := Transform_Res96;
        goto Exit_Or23;
    end if;
<<Exit_Or23>>

--  END <Or (root of 'lexer_case_alt') at parser.lkt:27:23>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Lexer_Case_Alt_Or_Parse0_Memo,
      Or_Pos23 /= No_Token_Index,
      Or_Res23,
      Pos,
      Or_Pos23);


   Parser.Current_Pos := Or_Pos23;

   return Or_Res23;
end Lexer_Case_Alt_Or_Parse0;

   


function Lexer_Case_Rule_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lexer_Case_Rule
is
   use Bare_Lexer_Case_Rule_Memos;

      Row_Pos110 :
            Token_Index
               := No_Token_Index;
      Token_Pos170 :
            Token_Index
               := No_Token_Index;
      Token_Res170 :
            Token_Index
               := No_Token_Index;
      Defer_Pos163 :
            Token_Index
               := No_Token_Index;
      Defer_Res163 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      Token_Pos171 :
            Token_Index
               := No_Token_Index;
      Token_Res171 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos24 :
            Token_Index
               := No_Token_Index;
      Tmp_List24 :
            Free_Parse_List;
      Defer_Pos164 :
            Token_Index
               := No_Token_Index;
      Defer_Res164 :
            Bare_Base_Lexer_Case_Rule_Alt
               := No_Bare_Lkt_Node;
      List_Pos24 :
            Token_Index
               := No_Token_Index;
      List_Res24 :
            Bare_Base_Lexer_Case_Rule_Alt_List
               := No_Bare_Lkt_Node;
      Token_Pos172 :
            Token_Index
               := No_Token_Index;
      Token_Res172 :
            Token_Index
               := No_Token_Index;
      Transform_Res97 :
            Bare_Lexer_Case_Rule
               := No_Bare_Lkt_Node;
      Transform_Diags97 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Lexer_Case_Rule_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res97 := M.Instance;
      return Transform_Res97;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res97;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareLexerCaseRule>) (root of 'lexer_case_rule') at parser.lkt:24:24>

Transform_Diags97 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'lexer_case_rule') at ???>

Row_Pos110 := Pos;



--  BEGIN <Token(<WithText MatchKw>, ) (root of 'lexer_case_rule') at parser.lkt:25:9>

Token_Res170 := Row_Pos110;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res170));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Match_Kw)
   then
       Token_Pos170 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos110 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos110,
             Expected_Token_Id => Lkt_Match_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos170 := Row_Pos110 + 1;
   end if;
end;

--  END <Token(<WithText MatchKw>, ) (root of 'lexer_case_rule') at parser.lkt:25:9>




if Token_Pos170 /= No_Token_Index then

   Row_Pos110 := Token_Pos170;

else
   Row_Pos110 := No_Token_Index;
   goto Exit_Row110_0;

end if;


--  BEGIN <Defer (for 'grammar_primary') at parser.lkt:25:17>

Defer_Res163 :=
   Grammar_Primary_Or_Parse0 (Parser, Row_Pos110);
Defer_Pos163 := Parser.Current_Pos;

--  END <Defer (for 'grammar_primary') at parser.lkt:25:17>




if Defer_Pos163 /= No_Token_Index then

   Row_Pos110 := Defer_Pos163;

else
   Row_Pos110 := No_Token_Index;
   goto Exit_Row110_0;

end if;


--  BEGIN <Token(<WithText LBrace>, ) (root of 'lexer_case_rule') at parser.lkt:25:33>

Token_Res171 := Row_Pos110;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res171));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos171 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos110 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos110,
             Expected_Token_Id => Lkt_L_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos171 := Row_Pos110 + 1;
   end if;
end;

--  END <Token(<WithText LBrace>, ) (root of 'lexer_case_rule') at parser.lkt:25:33>




if Token_Pos171 /= No_Token_Index then

   Row_Pos110 := Token_Pos171;

else
   Row_Pos110 := No_Token_Index;
   goto Exit_Row110_0;

end if;


--  BEGIN <List (root of 'lexer_case_rule') at parser.lkt:25:37>

    List_Pos24 := No_Token_Index;



Lst_Cpos24 := Row_Pos110;
Tmp_List24 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'lexer_case_alt') at parser.lkt:25:43>

Defer_Res164 :=
   Lexer_Case_Alt_Or_Parse0 (Parser, Lst_Cpos24);
Defer_Pos164 := Parser.Current_Pos;

--  END <Defer (for 'lexer_case_alt') at parser.lkt:25:43>


   exit when Defer_Pos164 = No_Token_Index;

   List_Pos24 := Defer_Pos164;
   Lst_Cpos24 := List_Pos24;

   Tmp_List24.Nodes.Append (Defer_Res164);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List24.Nodes.Length;
begin
   List_Res24 := Allocate_Base_Lexer_Case_Rule_Alt_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos110;
      Token_End := (if Lst_Cpos24 = Row_Pos110
                    then Row_Pos110
                    else List_Pos24 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos110, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res24,
      Kind              => Lkt_Base_Lexer_Case_Rule_Alt_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res24,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List24.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res24.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List24);

--  END <List (root of 'lexer_case_rule') at parser.lkt:25:37>




if List_Pos24 /= No_Token_Index then

   Row_Pos110 := List_Pos24;

else
   Row_Pos110 := No_Token_Index;
   goto Exit_Row110_0;

end if;


--  BEGIN <Token(<WithText RBrace>, ) (root of 'lexer_case_rule') at parser.lkt:25:59>

Token_Res172 := Row_Pos110;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res172));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos172 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos110 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos110,
             Expected_Token_Id => Lkt_R_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos172 := Row_Pos110 + 1;
   end if;
end;

--  END <Token(<WithText RBrace>, ) (root of 'lexer_case_rule') at parser.lkt:25:59>




if Token_Pos172 /= No_Token_Index then

   Row_Pos110 := Token_Pos172;

else
   Row_Pos110 := No_Token_Index;
   goto Exit_Row110_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row110_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'lexer_case_rule') at ???>



if Row_Pos110 /= No_Token_Index then

   Transform_Res97 := Allocate_Lexer_Case_Rule (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res97,
      Kind => Lkt_Lexer_Case_Rule,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos110 = Pos
                            then No_Token_Index
                            else Row_Pos110 - 1));

      
      Initialize_Fields_For_Lexer_Case_Rule
        (Self => Transform_Res97,
         Lexer_Case_Rule_F_Expr => Defer_Res163,
         Lexer_Case_Rule_F_Alts => List_Res24);

         if Defer_Res163 /= null and then Is_Incomplete (Defer_Res163) then
            Transform_Res97.Last_Attempted_Child := 0;
         elsif Defer_Res163 /= null and then not Is_Ghost (Defer_Res163) then
            Transform_Res97.Last_Attempted_Child := -1;
         end if;
         if List_Res24 /= null and then Is_Incomplete (List_Res24) then
            Transform_Res97.Last_Attempted_Child := 0;
         elsif List_Res24 /= null and then not Is_Ghost (List_Res24) then
            Transform_Res97.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos110 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags97);
end if;

--  END <Transform(<CompiledType BareLexerCaseRule>) (root of 'lexer_case_rule') at parser.lkt:24:24>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Lexer_Case_Rule_Transform_Parse0_Memo,
      Row_Pos110 /= No_Token_Index,
      Transform_Res97,
      Pos,
      Row_Pos110);


   Parser.Current_Pos := Row_Pos110;

   return Transform_Res97;
end Lexer_Case_Rule_Transform_Parse0;

   


function Lexer_Case_Send_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lexer_Case_Rule_Send
is
   use Bare_Lexer_Case_Rule_Send_Memos;

      Row_Pos111 :
            Token_Index
               := No_Token_Index;
      Token_Pos173 :
            Token_Index
               := No_Token_Index;
      Token_Res173 :
            Token_Index
               := No_Token_Index;
      Token_Pos174 :
            Token_Index
               := No_Token_Index;
      Token_Res174 :
            Token_Index
               := No_Token_Index;
      Defer_Pos165 :
            Token_Index
               := No_Token_Index;
      Defer_Res165 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Token_Pos175 :
            Token_Index
               := No_Token_Index;
      Token_Res175 :
            Token_Index
               := No_Token_Index;
      Defer_Pos166 :
            Token_Index
               := No_Token_Index;
      Defer_Res166 :
            Bare_Num_Lit
               := No_Bare_Lkt_Node;
      Token_Pos176 :
            Token_Index
               := No_Token_Index;
      Token_Res176 :
            Token_Index
               := No_Token_Index;
      Transform_Res98 :
            Bare_Lexer_Case_Rule_Send
               := No_Bare_Lkt_Node;
      Transform_Diags98 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Lexer_Case_Send_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res98 := M.Instance;
      return Transform_Res98;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res98;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareLexerCaseRuleSend>) (root of 'lexer_case_send') at parser.lkt:38:24>

Transform_Diags98 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'lexer_case_send') at ???>

Row_Pos111 := Pos;



--  BEGIN <Token(<WithSymbol Identifier>, send) (root of 'lexer_case_send') at parser.lkt:39:9>

Token_Res173 := Row_Pos111;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res173));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Send)
   then
       Token_Pos173 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos111 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos111,
             Expected_Token_Id => Lkt_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos173 := Row_Pos111 + 1;
   end if;
end;

--  END <Token(<WithSymbol Identifier>, send) (root of 'lexer_case_send') at parser.lkt:39:9>




if Token_Pos173 /= No_Token_Index then

   Row_Pos111 := Token_Pos173;

else
   Row_Pos111 := No_Token_Index;
   goto Exit_Row111_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'lexer_case_send') at parser.lkt:39:29>

Token_Res174 := Row_Pos111;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res174));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos174 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos111 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos111,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos174 := Row_Pos111 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'lexer_case_send') at parser.lkt:39:29>




if Token_Pos174 /= No_Token_Index then

   Row_Pos111 := Token_Pos174;

else
   Row_Pos111 := No_Token_Index;
   goto Exit_Row111_0;

end if;


--  BEGIN <Defer (for 'ref_id') at parser.lkt:39:33>

Defer_Res165 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos111);
Defer_Pos165 := Parser.Current_Pos;

--  END <Defer (for 'ref_id') at parser.lkt:39:33>




if Defer_Pos165 /= No_Token_Index then

   Row_Pos111 := Defer_Pos165;

else
   Row_Pos111 := No_Token_Index;
   goto Exit_Row111_0;

end if;


--  BEGIN <Token(<WithText Comma>, ) (root of 'lexer_case_send') at parser.lkt:39:40>

Token_Res175 := Row_Pos111;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res175));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos175 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos111 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos111,
             Expected_Token_Id => Lkt_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos175 := Row_Pos111 + 1;
   end if;
end;

--  END <Token(<WithText Comma>, ) (root of 'lexer_case_send') at parser.lkt:39:40>




if Token_Pos175 /= No_Token_Index then

   Row_Pos111 := Token_Pos175;

else
   Row_Pos111 := No_Token_Index;
   goto Exit_Row111_0;

end if;


--  BEGIN <Defer (for 'num_lit') at parser.lkt:39:44>

Defer_Res166 :=
   Num_Lit_Transform_Parse0 (Parser, Row_Pos111);
Defer_Pos166 := Parser.Current_Pos;

--  END <Defer (for 'num_lit') at parser.lkt:39:44>




if Defer_Pos166 /= No_Token_Index then

   Row_Pos111 := Defer_Pos166;

else
   Row_Pos111 := No_Token_Index;
   goto Exit_Row111_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'lexer_case_send') at parser.lkt:39:52>

Token_Res176 := Row_Pos111;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res176));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos176 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos111 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos111,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos176 := Row_Pos111 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'lexer_case_send') at parser.lkt:39:52>




if Token_Pos176 /= No_Token_Index then

   Row_Pos111 := Token_Pos176;

else
   Row_Pos111 := No_Token_Index;
   goto Exit_Row111_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row111_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'lexer_case_send') at ???>



if Row_Pos111 /= No_Token_Index then

   Transform_Res98 := Allocate_Lexer_Case_Rule_Send (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res98,
      Kind => Lkt_Lexer_Case_Rule_Send,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos111 = Pos
                            then No_Token_Index
                            else Row_Pos111 - 1));

      
      Initialize_Fields_For_Lexer_Case_Rule_Send
        (Self => Transform_Res98,
         Lexer_Case_Rule_Send_F_Sent => Defer_Res165,
         Lexer_Case_Rule_Send_F_Match_Size => Defer_Res166);

         if Defer_Res165 /= null and then Is_Incomplete (Defer_Res165) then
            Transform_Res98.Last_Attempted_Child := 0;
         elsif Defer_Res165 /= null and then not Is_Ghost (Defer_Res165) then
            Transform_Res98.Last_Attempted_Child := -1;
         end if;
         if Defer_Res166 /= null and then Is_Incomplete (Defer_Res166) then
            Transform_Res98.Last_Attempted_Child := 0;
         elsif Defer_Res166 /= null and then not Is_Ghost (Defer_Res166) then
            Transform_Res98.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos111 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags98);
end if;

--  END <Transform(<CompiledType BareLexerCaseRuleSend>) (root of 'lexer_case_send') at parser.lkt:38:24>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Lexer_Case_Send_Transform_Parse0_Memo,
      Row_Pos111 /= No_Token_Index,
      Transform_Res98,
      Pos,
      Row_Pos111);


   Parser.Current_Pos := Row_Pos111;

   return Transform_Res98;
end Lexer_Case_Send_Transform_Parse0;

   


function Lexer_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lexer_Decl
is
   use Bare_Lexer_Decl_Memos;

      Row_Pos112 :
            Token_Index
               := No_Token_Index;
      Token_Pos177 :
            Token_Index
               := No_Token_Index;
      Token_Res177 :
            Token_Index
               := No_Token_Index;
      Defer_Pos167 :
            Token_Index
               := No_Token_Index;
      Defer_Res167 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Token_Pos178 :
            Token_Index
               := No_Token_Index;
      Token_Res178 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos25 :
            Token_Index
               := No_Token_Index;
      Tmp_List25 :
            Free_Parse_List;
      Defer_Pos168 :
            Token_Index
               := No_Token_Index;
      Defer_Res168 :
            Bare_Full_Decl
               := No_Bare_Lkt_Node;
      Defer_Pos169 :
            Token_Index
               := No_Token_Index;
      Defer_Res169 :
            Bare_Lkt_Node
               := No_Bare_Lkt_Node;
      Or_Pos24 :
            Token_Index
               := No_Token_Index;
      Or_Res24 :
            Bare_Lkt_Node
               := No_Bare_Lkt_Node;
      List_Pos25 :
            Token_Index
               := No_Token_Index;
      List_Res25 :
            Bare_Lkt_Node_List
               := No_Bare_Lkt_Node;
      Token_Pos179 :
            Token_Index
               := No_Token_Index;
      Token_Res179 :
            Token_Index
               := No_Token_Index;
      Transform_Res99 :
            Bare_Lexer_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags99 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Lexer_Decl_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res99 := M.Instance;
      return Transform_Res99;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res99;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareLexerDecl>) (root of 'lexer_decl') at parser.lkt:13:19>

Transform_Diags99 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'lexer_decl') at ???>

Row_Pos112 := Pos;



--  BEGIN <Token(<WithText LexerKw>, ) (root of 'lexer_decl') at parser.lkt:14:9>

Token_Res177 := Row_Pos112;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res177));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Lexer_Kw)
   then
       Token_Pos177 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos112 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos112,
             Expected_Token_Id => Lkt_Lexer_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos177 := Row_Pos112 + 1;
   end if;
end;

--  END <Token(<WithText LexerKw>, ) (root of 'lexer_decl') at parser.lkt:14:9>




if Token_Pos177 /= No_Token_Index then

   Row_Pos112 := Token_Pos177;

else
   Row_Pos112 := No_Token_Index;
   goto Exit_Row112_0;

end if;


--  BEGIN <Defer (for 'def_id') at parser.lkt:14:17>

Defer_Res167 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos112);
Defer_Pos167 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:14:17>




if Defer_Pos167 /= No_Token_Index then

   Row_Pos112 := Defer_Pos167;

else
   Row_Pos112 := No_Token_Index;
   goto Exit_Row112_0;

end if;


--  BEGIN <Token(<WithText LBrace>, ) (root of 'lexer_decl') at parser.lkt:14:24>

Token_Res178 := Row_Pos112;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res178));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos178 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos112 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos112,
             Expected_Token_Id => Lkt_L_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos178 := Row_Pos112 + 1;
   end if;
end;

--  END <Token(<WithText LBrace>, ) (root of 'lexer_decl') at parser.lkt:14:24>




if Token_Pos178 /= No_Token_Index then

   Row_Pos112 := Token_Pos178;

else
   Row_Pos112 := No_Token_Index;
   goto Exit_Row112_0;

end if;


--  BEGIN <List (root of 'lexer_decl') at parser.lkt:14:28>

    List_Pos25 := Row_Pos112;



Lst_Cpos25 := Row_Pos112;
Tmp_List25 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Or (root of 'lexer_decl') at parser.lkt:14:34>

Or_Pos24 := No_Token_Index;
Or_Res24 := No_Bare_Lkt_Node;
    
--  BEGIN <Defer (for 'lexer_family_decl') at parser.lkt:14:37>

Defer_Res168 :=
   Lexer_Family_Decl_Transform_Parse1 (Parser, Lst_Cpos25);
Defer_Pos168 := Parser.Current_Pos;

--  END <Defer (for 'lexer_family_decl') at parser.lkt:14:37>

    if Defer_Pos168 /= No_Token_Index then
        Or_Pos24 := Defer_Pos168;
        Or_Res24 := Defer_Res168;
        goto Exit_Or24;
    end if;
    
--  BEGIN <Defer (for 'lexer_rule') at parser.lkt:14:57>

Defer_Res169 :=
   Lexer_Rule_Or_Parse0 (Parser, Lst_Cpos25);
Defer_Pos169 := Parser.Current_Pos;

--  END <Defer (for 'lexer_rule') at parser.lkt:14:57>

    if Defer_Pos169 /= No_Token_Index then
        Or_Pos24 := Defer_Pos169;
        Or_Res24 := Defer_Res169;
        goto Exit_Or24;
    end if;
<<Exit_Or24>>

--  END <Or (root of 'lexer_decl') at parser.lkt:14:34>


   exit when Or_Pos24 = No_Token_Index;

   List_Pos25 := Or_Pos24;
   Lst_Cpos25 := List_Pos25;

   Tmp_List25.Nodes.Append (Or_Res24);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List25.Nodes.Length;
begin
   List_Res25 := Allocate_Lkt_Node_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos112;
      Token_End := (if Lst_Cpos25 = Row_Pos112
                    then Row_Pos112
                    else List_Pos25 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos112, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res25,
      Kind              => Lkt_Lkt_Node_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res25,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List25.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res25.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List25);

--  END <List (root of 'lexer_decl') at parser.lkt:14:28>




if List_Pos25 /= No_Token_Index then

   Row_Pos112 := List_Pos25;

else
   Row_Pos112 := No_Token_Index;
   goto Exit_Row112_0;

end if;


--  BEGIN <Token(<WithText RBrace>, ) (root of 'lexer_decl') at parser.lkt:14:70>

Token_Res179 := Row_Pos112;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res179));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos179 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos112 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos112,
             Expected_Token_Id => Lkt_R_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos179 := Row_Pos112 + 1;
   end if;
end;

--  END <Token(<WithText RBrace>, ) (root of 'lexer_decl') at parser.lkt:14:70>




if Token_Pos179 /= No_Token_Index then

   Row_Pos112 := Token_Pos179;

else
   Row_Pos112 := No_Token_Index;
   goto Exit_Row112_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row112_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'lexer_decl') at ???>



if Row_Pos112 /= No_Token_Index then

   Transform_Res99 := Allocate_Lexer_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res99,
      Kind => Lkt_Lexer_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos112 = Pos
                            then No_Token_Index
                            else Row_Pos112 - 1));

      
      Initialize_Fields_For_Lexer_Decl
        (Self => Transform_Res99,
         Lexer_Decl_F_Syn_Name => Defer_Res167,
         Lexer_Decl_F_Rules => List_Res25);

         if Defer_Res167 /= null and then Is_Incomplete (Defer_Res167) then
            Transform_Res99.Last_Attempted_Child := 0;
         elsif Defer_Res167 /= null and then not Is_Ghost (Defer_Res167) then
            Transform_Res99.Last_Attempted_Child := -1;
         end if;
         if List_Res25 /= null and then Is_Incomplete (List_Res25) then
            Transform_Res99.Last_Attempted_Child := 0;
         elsif List_Res25 /= null and then not Is_Ghost (List_Res25) then
            Transform_Res99.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos112 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags99);
end if;

--  END <Transform(<CompiledType BareLexerDecl>) (root of 'lexer_decl') at parser.lkt:13:19>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Lexer_Decl_Transform_Parse0_Memo,
      Row_Pos112 /= No_Token_Index,
      Transform_Res99,
      Pos,
      Row_Pos112);


   Parser.Current_Pos := Row_Pos112;

   return Transform_Res99;
end Lexer_Decl_Transform_Parse0;

   


function Lexer_Family_Decl_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Full_Decl
is
   use Bare_Full_Decl_Memos;

      Row_Pos113 :
            Token_Index
               := No_Token_Index;
      Defer_Pos170 :
            Token_Index
               := No_Token_Index;
      Defer_Res170 :
            Bare_String_Lit
               := No_Bare_Lkt_Node;
      Lst_Cpos26 :
            Token_Index
               := No_Token_Index;
      Tmp_List26 :
            Free_Parse_List;
      Defer_Pos171 :
            Token_Index
               := No_Token_Index;
      Defer_Res171 :
            Bare_Decl_Annotation
               := No_Bare_Lkt_Node;
      List_Pos26 :
            Token_Index
               := No_Token_Index;
      List_Res26 :
            Bare_Decl_Annotation_List
               := No_Bare_Lkt_Node;
      Row_Pos114 :
            Token_Index
               := No_Token_Index;
      Token_Pos180 :
            Token_Index
               := No_Token_Index;
      Token_Res180 :
            Token_Index
               := No_Token_Index;
      Defer_Pos172 :
            Token_Index
               := No_Token_Index;
      Defer_Res172 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Token_Pos181 :
            Token_Index
               := No_Token_Index;
      Token_Res181 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos27 :
            Token_Index
               := No_Token_Index;
      Tmp_List27 :
            Free_Parse_List;
      Defer_Pos173 :
            Token_Index
               := No_Token_Index;
      Defer_Res173 :
            Bare_Full_Decl
               := No_Bare_Lkt_Node;
      List_Pos27 :
            Token_Index
               := No_Token_Index;
      List_Res27 :
            Bare_Full_Decl_List
               := No_Bare_Lkt_Node;
      Token_Pos182 :
            Token_Index
               := No_Token_Index;
      Token_Res182 :
            Token_Index
               := No_Token_Index;
      Transform_Res100 :
            Bare_Lexer_Family_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags100 :
            Ada.Containers.Count_Type;
      Transform_Res101 :
            Bare_Full_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags101 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Lexer_Family_Decl_Transform_Parse1_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res101 := M.Instance;
      return Transform_Res101;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res101;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareFullDecl>) (root of 'lexer_family_decl') at parser.lkt:19:26>

Transform_Diags101 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'lexer_family_decl') at ???>

Row_Pos113 := Pos;



--  BEGIN <Defer (for 'doc') at parser.lkt:20:9>

Defer_Res170 :=
   Doc_Opt_Parse0 (Parser, Row_Pos113);
Defer_Pos170 := Parser.Current_Pos;

--  END <Defer (for 'doc') at parser.lkt:20:9>




if Defer_Pos170 /= No_Token_Index then

   Row_Pos113 := Defer_Pos170;

else
   Row_Pos113 := No_Token_Index;
   goto Exit_Row113_0;

end if;


--  BEGIN <List (root of 'lexer_family_decl') at parser.lkt:21:9>

    List_Pos26 := Row_Pos113;



Lst_Cpos26 := Row_Pos113;
Tmp_List26 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'decl_annotation') at parser.lkt:21:15>

Defer_Res171 :=
   Decl_Annotation_Transform_Parse0 (Parser, Lst_Cpos26);
Defer_Pos171 := Parser.Current_Pos;

--  END <Defer (for 'decl_annotation') at parser.lkt:21:15>


   exit when Defer_Pos171 = No_Token_Index;

   List_Pos26 := Defer_Pos171;
   Lst_Cpos26 := List_Pos26;

   Tmp_List26.Nodes.Append (Defer_Res171);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List26.Nodes.Length;
begin
   List_Res26 := Allocate_Decl_Annotation_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos113;
      Token_End := (if Lst_Cpos26 = Row_Pos113
                    then Row_Pos113
                    else List_Pos26 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos113, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res26,
      Kind              => Lkt_Decl_Annotation_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res26,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List26.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res26.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List26);

--  END <List (root of 'lexer_family_decl') at parser.lkt:21:9>




if List_Pos26 /= No_Token_Index then

   Row_Pos113 := List_Pos26;

else
   Row_Pos113 := No_Token_Index;
   goto Exit_Row113_0;

end if;


--  BEGIN <Transform(<CompiledType BareLexerFamilyDecl>) (root of 'lexer_family_decl') at parser.lkt:22:9>

Transform_Diags100 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'lexer_family_decl') at ???>

Row_Pos114 := Row_Pos113;



--  BEGIN <Token(<WithSymbol Identifier>, family) (root of 'lexer_family_decl') at parser.lkt:22:25>

Token_Res180 := Row_Pos114;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res180));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Family)
   then
       Token_Pos180 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos114 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos114,
             Expected_Token_Id => Lkt_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos180 := Row_Pos114 + 1;
   end if;
end;

--  END <Token(<WithSymbol Identifier>, family) (root of 'lexer_family_decl') at parser.lkt:22:25>




if Token_Pos180 /= No_Token_Index then

   Row_Pos114 := Token_Pos180;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;


--  BEGIN <Defer (for 'def_id') at parser.lkt:22:47>

Defer_Res172 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos114);
Defer_Pos172 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:22:47>




if Defer_Pos172 /= No_Token_Index then

   Row_Pos114 := Defer_Pos172;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;


--  BEGIN <Token(<WithText LBrace>, ) (root of 'lexer_family_decl') at parser.lkt:22:54>

Token_Res181 := Row_Pos114;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res181));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos181 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos114 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos114,
             Expected_Token_Id => Lkt_L_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos181 := Row_Pos114 + 1;
   end if;
end;

--  END <Token(<WithText LBrace>, ) (root of 'lexer_family_decl') at parser.lkt:22:54>




if Token_Pos181 /= No_Token_Index then

   Row_Pos114 := Token_Pos181;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;


--  BEGIN <List (root of 'lexer_family_decl') at parser.lkt:22:58>

    List_Pos27 := No_Token_Index;



Lst_Cpos27 := Row_Pos114;
Tmp_List27 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'decl') at parser.lkt:22:64>

Defer_Res173 :=
   Decl_Transform_Parse0 (Parser, Lst_Cpos27);
Defer_Pos173 := Parser.Current_Pos;

--  END <Defer (for 'decl') at parser.lkt:22:64>


   exit when Defer_Pos173 = No_Token_Index;

   List_Pos27 := Defer_Pos173;
   Lst_Cpos27 := List_Pos27;

   Tmp_List27.Nodes.Append (Defer_Res173);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List27.Nodes.Length;
begin
   List_Res27 := Allocate_Full_Decl_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos114;
      Token_End := (if Lst_Cpos27 = Row_Pos114
                    then Row_Pos114
                    else List_Pos27 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos114, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res27,
      Kind              => Lkt_Full_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res27,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List27.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res27.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List27);

--  END <List (root of 'lexer_family_decl') at parser.lkt:22:58>




if List_Pos27 /= No_Token_Index then

   Row_Pos114 := List_Pos27;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;


--  BEGIN <Token(<WithText RBrace>, ) (root of 'lexer_family_decl') at parser.lkt:22:70>

Token_Res182 := Row_Pos114;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res182));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos182 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos114 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos114,
             Expected_Token_Id => Lkt_R_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos182 := Row_Pos114 + 1;
   end if;
end;

--  END <Token(<WithText RBrace>, ) (root of 'lexer_family_decl') at parser.lkt:22:70>




if Token_Pos182 /= No_Token_Index then

   Row_Pos114 := Token_Pos182;

else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row114_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'lexer_family_decl') at ???>



if Row_Pos114 /= No_Token_Index then

   Transform_Res100 := Allocate_Lexer_Family_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res100,
      Kind => Lkt_Lexer_Family_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos113,
      Token_End_Index   => (if Row_Pos114 = Row_Pos113
                            then No_Token_Index
                            else Row_Pos114 - 1));

      
      Initialize_Fields_For_Lexer_Family_Decl
        (Self => Transform_Res100,
         Lexer_Family_Decl_F_Syn_Name => Defer_Res172,
         Lexer_Family_Decl_F_Rules => List_Res27);

         if Defer_Res172 /= null and then Is_Incomplete (Defer_Res172) then
            Transform_Res100.Last_Attempted_Child := 0;
         elsif Defer_Res172 /= null and then not Is_Ghost (Defer_Res172) then
            Transform_Res100.Last_Attempted_Child := -1;
         end if;
         if List_Res27 /= null and then Is_Incomplete (List_Res27) then
            Transform_Res100.Last_Attempted_Child := 0;
         elsif List_Res27 /= null and then not Is_Ghost (List_Res27) then
            Transform_Res100.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos114 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags100);
end if;

--  END <Transform(<CompiledType BareLexerFamilyDecl>) (root of 'lexer_family_decl') at parser.lkt:22:9>




if Row_Pos114 /= No_Token_Index then

   Row_Pos113 := Row_Pos114;

else
   Row_Pos113 := No_Token_Index;
   goto Exit_Row113_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row113_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'lexer_family_decl') at ???>



if Row_Pos113 /= No_Token_Index then

   Transform_Res101 := Allocate_Full_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res101,
      Kind => Lkt_Full_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos113 = Pos
                            then No_Token_Index
                            else Row_Pos113 - 1));

      
      Initialize_Fields_For_Full_Decl
        (Self => Transform_Res101,
         Full_Decl_F_Doc => Defer_Res170,
         Full_Decl_F_Decl_Annotations => List_Res26,
         Full_Decl_F_Decl => Transform_Res100);

         if Defer_Res170 /= null and then Is_Incomplete (Defer_Res170) then
            Transform_Res101.Last_Attempted_Child := 0;
         elsif Defer_Res170 /= null and then not Is_Ghost (Defer_Res170) then
            Transform_Res101.Last_Attempted_Child := -1;
         end if;
         if List_Res26 /= null and then Is_Incomplete (List_Res26) then
            Transform_Res101.Last_Attempted_Child := 0;
         elsif List_Res26 /= null and then not Is_Ghost (List_Res26) then
            Transform_Res101.Last_Attempted_Child := -1;
         end if;
         if Transform_Res100 /= null and then Is_Incomplete (Transform_Res100) then
            Transform_Res101.Last_Attempted_Child := 0;
         elsif Transform_Res100 /= null and then not Is_Ghost (Transform_Res100) then
            Transform_Res101.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos113 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags101);
end if;

--  END <Transform(<CompiledType BareFullDecl>) (root of 'lexer_family_decl') at parser.lkt:19:26>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Lexer_Family_Decl_Transform_Parse1_Memo,
      Row_Pos113 /= No_Token_Index,
      Transform_Res101,
      Pos,
      Row_Pos113);


   Parser.Current_Pos := Row_Pos113;

   return Transform_Res101;
end Lexer_Family_Decl_Transform_Parse1;

   


function Lexer_Rule_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
   use Bare_Lkt_Node_Memos;

      Defer_Pos174 :
            Token_Index
               := No_Token_Index;
      Defer_Res174 :
            Bare_Full_Decl
               := No_Bare_Lkt_Node;
      Defer_Pos175 :
            Token_Index
               := No_Token_Index;
      Defer_Res175 :
            Bare_Full_Decl
               := No_Bare_Lkt_Node;
      Defer_Pos176 :
            Token_Index
               := No_Token_Index;
      Defer_Res176 :
            Bare_Lexer_Case_Rule
               := No_Bare_Lkt_Node;
      Or_Pos25 :
            Token_Index
               := No_Token_Index;
      Or_Res25 :
            Bare_Lkt_Node
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Lexer_Rule_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res25 := M.Instance;
      return Or_Res25;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res25;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'lexer_rule') at parser.lkt:18:19>

Or_Pos25 := No_Token_Index;
Or_Res25 := No_Bare_Lkt_Node;
    
--  BEGIN <Defer (for 'lexer_family_decl') at parser.lkt:18:22>

Defer_Res174 :=
   Lexer_Family_Decl_Transform_Parse1 (Parser, Pos);
Defer_Pos174 := Parser.Current_Pos;

--  END <Defer (for 'lexer_family_decl') at parser.lkt:18:22>

    if Defer_Pos174 /= No_Token_Index then
        Or_Pos25 := Defer_Pos174;
        Or_Res25 := Defer_Res174;
        goto Exit_Or25;
    end if;
    
--  BEGIN <Defer (for 'decl') at parser.lkt:18:42>

Defer_Res175 :=
   Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos175 := Parser.Current_Pos;

--  END <Defer (for 'decl') at parser.lkt:18:42>

    if Defer_Pos175 /= No_Token_Index then
        Or_Pos25 := Defer_Pos175;
        Or_Res25 := Defer_Res175;
        goto Exit_Or25;
    end if;
    
--  BEGIN <Defer (for 'lexer_case_rule') at parser.lkt:18:49>

Defer_Res176 :=
   Lexer_Case_Rule_Transform_Parse0 (Parser, Pos);
Defer_Pos176 := Parser.Current_Pos;

--  END <Defer (for 'lexer_case_rule') at parser.lkt:18:49>

    if Defer_Pos176 /= No_Token_Index then
        Or_Pos25 := Defer_Pos176;
        Or_Res25 := Defer_Res176;
        goto Exit_Or25;
    end if;
<<Exit_Or25>>

--  END <Or (root of 'lexer_rule') at parser.lkt:18:19>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Lexer_Rule_Or_Parse0_Memo,
      Or_Pos25 /= No_Token_Index,
      Or_Res25,
      Pos,
      Or_Pos25);


   Parser.Current_Pos := Or_Pos25;

   return Or_Res25;
end Lexer_Rule_Or_Parse0;

   


function Logic_Propagate_Call_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Logic_Propagate_Call
is
   use Bare_Logic_Propagate_Call_Memos;

      Row_Pos115 :
            Token_Index
               := No_Token_Index;
      Defer_Pos177 :
            Token_Index
               := No_Token_Index;
      Defer_Res177 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos183 :
            Token_Index
               := No_Token_Index;
      Token_Res183 :
            Token_Index
               := No_Token_Index;
      Token_Pos184 :
            Token_Index
               := No_Token_Index;
      Token_Res184 :
            Token_Index
               := No_Token_Index;
      Defer_Pos178 :
            Token_Index
               := No_Token_Index;
      Defer_Res178 :
            Bare_Param_List
               := No_Bare_Lkt_Node;
      Token_Pos185 :
            Token_Index
               := No_Token_Index;
      Token_Res185 :
            Token_Index
               := No_Token_Index;
      Transform_Res102 :
            Bare_Logic_Propagate_Call
               := No_Bare_Lkt_Node;
      Transform_Diags102 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Logic_Propagate_Call_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res102 := M.Instance;
      return Transform_Res102;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res102;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareLogicPropagateCall>) (root of 'logic_propagate_call') at parser.lkt:277:29>

Transform_Diags102 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'logic_propagate_call') at ???>

Row_Pos115 := Pos;



--  BEGIN <Defer (for 'callable_ref') at parser.lkt:277:48>

Defer_Res177 :=
   Callable_Ref_Or_Parse0 (Parser, Row_Pos115);
Defer_Pos177 := Parser.Current_Pos;

--  END <Defer (for 'callable_ref') at parser.lkt:277:48>




if Defer_Pos177 /= No_Token_Index then

   Row_Pos115 := Defer_Pos177;

else
   Row_Pos115 := No_Token_Index;
   goto Exit_Row115_0;

end if;


--  BEGIN <Token(<WithText Percent>, ) (root of 'logic_propagate_call') at parser.lkt:277:61>

Token_Res183 := Row_Pos115;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res183));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Percent)
   then
       Token_Pos183 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos115 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos115,
             Expected_Token_Id => Lkt_Percent,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos183 := Row_Pos115 + 1;
   end if;
end;

--  END <Token(<WithText Percent>, ) (root of 'logic_propagate_call') at parser.lkt:277:61>




if Token_Pos183 /= No_Token_Index then

   Row_Pos115 := Token_Pos183;

else
   Row_Pos115 := No_Token_Index;
   goto Exit_Row115_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'logic_propagate_call') at parser.lkt:277:65>

Token_Res184 := Row_Pos115;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res184));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos184 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos115 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos115,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos184 := Row_Pos115 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'logic_propagate_call') at parser.lkt:277:65>




if Token_Pos184 /= No_Token_Index then

   Row_Pos115 := Token_Pos184;

else
   Row_Pos115 := No_Token_Index;
   goto Exit_Row115_0;

end if;


--  BEGIN <Defer (for 'params') at parser.lkt:277:69>

Defer_Res178 :=
   Params_List_Parse0 (Parser, Row_Pos115);
Defer_Pos178 := Parser.Current_Pos;

--  END <Defer (for 'params') at parser.lkt:277:69>




if Defer_Pos178 /= No_Token_Index then

   Row_Pos115 := Defer_Pos178;

else
   Row_Pos115 := No_Token_Index;
   goto Exit_Row115_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'logic_propagate_call') at parser.lkt:277:76>

Token_Res185 := Row_Pos115;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res185));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos185 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos115 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos115,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos185 := Row_Pos115 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'logic_propagate_call') at parser.lkt:277:76>




if Token_Pos185 /= No_Token_Index then

   Row_Pos115 := Token_Pos185;

else
   Row_Pos115 := No_Token_Index;
   goto Exit_Row115_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row115_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'logic_propagate_call') at ???>



if Row_Pos115 /= No_Token_Index then

   Transform_Res102 := Allocate_Logic_Propagate_Call (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res102,
      Kind => Lkt_Logic_Propagate_Call,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos115 = Pos
                            then No_Token_Index
                            else Row_Pos115 - 1));

      
      Initialize_Fields_For_Logic_Propagate_Call
        (Self => Transform_Res102,
         Base_Call_Expr_F_Name => Defer_Res177,
         Base_Call_Expr_F_Args => Defer_Res178);

         if Defer_Res177 /= null and then Is_Incomplete (Defer_Res177) then
            Transform_Res102.Last_Attempted_Child := 0;
         elsif Defer_Res177 /= null and then not Is_Ghost (Defer_Res177) then
            Transform_Res102.Last_Attempted_Child := -1;
         end if;
         if Defer_Res178 /= null and then Is_Incomplete (Defer_Res178) then
            Transform_Res102.Last_Attempted_Child := 0;
         elsif Defer_Res178 /= null and then not Is_Ghost (Defer_Res178) then
            Transform_Res102.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos115 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags102);
end if;

--  END <Transform(<CompiledType BareLogicPropagateCall>) (root of 'logic_propagate_call') at parser.lkt:277:29>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Logic_Propagate_Call_Transform_Parse0_Memo,
      Row_Pos115 /= No_Token_Index,
      Transform_Res102,
      Pos,
      Row_Pos115);


   Parser.Current_Pos := Row_Pos115;

   return Transform_Res102;
end Logic_Propagate_Call_Transform_Parse0;

   


function Main_Rule_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Langkit_Root
is
   use Bare_Langkit_Root_Memos;

      Row_Pos116 :
            Token_Index
               := No_Token_Index;
      Defer_Pos179 :
            Token_Index
               := No_Token_Index;
      Defer_Res179 :
            Bare_Import_List
               := No_Bare_Lkt_Node;
      Defer_Pos180 :
            Token_Index
               := No_Token_Index;
      Defer_Res180 :
            Bare_Full_Decl_List
               := No_Bare_Lkt_Node;
      Token_Pos186 :
            Token_Index
               := No_Token_Index;
      Token_Res186 :
            Token_Index
               := No_Token_Index;
      Transform_Res103 :
            Bare_Langkit_Root
               := No_Bare_Lkt_Node;
      Transform_Diags103 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Main_Rule_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res103 := M.Instance;
      return Transform_Res103;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res103;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareLangkitRoot>) (root of 'main_rule') at parser.lkt:5:18>

Transform_Diags103 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'main_rule') at ???>

Row_Pos116 := Pos;



--  BEGIN <Defer (for 'imports') at parser.lkt:5:30>

Defer_Res179 :=
   Imports_List_Parse0 (Parser, Row_Pos116);
Defer_Pos179 := Parser.Current_Pos;

--  END <Defer (for 'imports') at parser.lkt:5:30>




if Defer_Pos179 /= No_Token_Index then

   Row_Pos116 := Defer_Pos179;

else
   Row_Pos116 := No_Token_Index;
   goto Exit_Row116_0;

end if;


--  BEGIN <Defer (for 'decls') at parser.lkt:5:38>

Defer_Res180 :=
   Decls_List_Parse0 (Parser, Row_Pos116);
Defer_Pos180 := Parser.Current_Pos;

--  END <Defer (for 'decls') at parser.lkt:5:38>




if Defer_Pos180 /= No_Token_Index then

   Row_Pos116 := Defer_Pos180;

else
   Row_Pos116 := No_Token_Index;
   goto Exit_Row116_0;

end if;


--  BEGIN <Token(<WithText Termination>, ) (root of 'main_rule') at parser.lkt:5:44>

Token_Res186 := Row_Pos116;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res186));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Termination)
   then
       Token_Pos186 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos116 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos116,
             Expected_Token_Id => Lkt_Termination,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos186 := Row_Pos116;
   end if;
end;

--  END <Token(<WithText Termination>, ) (root of 'main_rule') at parser.lkt:5:44>




if Token_Pos186 /= No_Token_Index then

   Row_Pos116 := Token_Pos186;

else
   Row_Pos116 := No_Token_Index;
   goto Exit_Row116_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row116_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'main_rule') at ???>



if Row_Pos116 /= No_Token_Index then

   Transform_Res103 := Allocate_Langkit_Root (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res103,
      Kind => Lkt_Langkit_Root,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos116 = Pos
                            then No_Token_Index
                            else Row_Pos116 - 1));

      
      Initialize_Fields_For_Langkit_Root
        (Self => Transform_Res103,
         Langkit_Root_F_Imports => Defer_Res179,
         Langkit_Root_F_Decls => Defer_Res180);

         if Defer_Res179 /= null and then Is_Incomplete (Defer_Res179) then
            Transform_Res103.Last_Attempted_Child := 0;
         elsif Defer_Res179 /= null and then not Is_Ghost (Defer_Res179) then
            Transform_Res103.Last_Attempted_Child := -1;
         end if;
         if Defer_Res180 /= null and then Is_Incomplete (Defer_Res180) then
            Transform_Res103.Last_Attempted_Child := 0;
         elsif Defer_Res180 /= null and then not Is_Ghost (Defer_Res180) then
            Transform_Res103.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos116 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags103);
end if;

--  END <Transform(<CompiledType BareLangkitRoot>) (root of 'main_rule') at parser.lkt:5:18>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Main_Rule_Transform_Parse0_Memo,
      Row_Pos116 /= No_Token_Index,
      Transform_Res103,
      Pos,
      Row_Pos116);


   Parser.Current_Pos := Row_Pos116;

   return Transform_Res103;
end Main_Rule_Transform_Parse0;

   


function Match_Expr_Transform_Parse2
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Match_Expr
is
   use Bare_Match_Expr_Memos;

      Row_Pos117 :
            Token_Index
               := No_Token_Index;
      Token_Pos187 :
            Token_Index
               := No_Token_Index;
      Token_Res187 :
            Token_Index
               := No_Token_Index;
      Defer_Pos181 :
            Token_Index
               := No_Token_Index;
      Defer_Res181 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos188 :
            Token_Index
               := No_Token_Index;
      Token_Res188 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos28 :
            Token_Index
               := No_Token_Index;
      Tmp_List28 :
            Free_Parse_List;
      Row_Pos118 :
            Token_Index
               := No_Token_Index;
      Token_Pos189 :
            Token_Index
               := No_Token_Index;
      Token_Res189 :
            Token_Index
               := No_Token_Index;
      Row_Pos119 :
            Token_Index
               := No_Token_Index;
      Defer_Pos182 :
            Token_Index
               := No_Token_Index;
      Defer_Res182 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Row_Pos120 :
            Token_Index
               := No_Token_Index;
      Token_Pos190 :
            Token_Index
               := No_Token_Index;
      Token_Res190 :
            Token_Index
               := No_Token_Index;
      Defer_Pos183 :
            Token_Index
               := No_Token_Index;
      Defer_Res183 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Transform_Res104 :
            Bare_Match_Val_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags104 :
            Ada.Containers.Count_Type;
      Token_Pos191 :
            Token_Index
               := No_Token_Index;
      Token_Res191 :
            Token_Index
               := No_Token_Index;
      Defer_Pos184 :
            Token_Index
               := No_Token_Index;
      Defer_Res184 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res105 :
            Bare_Match_Branch
               := No_Bare_Lkt_Node;
      Transform_Diags105 :
            Ada.Containers.Count_Type;
      List_Pos28 :
            Token_Index
               := No_Token_Index;
      List_Res28 :
            Bare_Match_Branch_List
               := No_Bare_Lkt_Node;
      Token_Pos192 :
            Token_Index
               := No_Token_Index;
      Token_Res192 :
            Token_Index
               := No_Token_Index;
      Transform_Res106 :
            Bare_Match_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags106 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Match_Expr_Transform_Parse2_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res106 := M.Instance;
      return Transform_Res106;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res106;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareMatchExpr>) (root of 'match_expr') at parser.lkt:279:19>

Transform_Diags106 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'match_expr') at ???>

Row_Pos117 := Pos;



--  BEGIN <Token(<WithText MatchKw>, ) (root of 'match_expr') at parser.lkt:280:9>

Token_Res187 := Row_Pos117;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res187));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Match_Kw)
   then
       Token_Pos187 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos117 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos117,
             Expected_Token_Id => Lkt_Match_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos187 := Row_Pos117 + 1;
   end if;
end;

--  END <Token(<WithText MatchKw>, ) (root of 'match_expr') at parser.lkt:280:9>




if Token_Pos187 /= No_Token_Index then

   Row_Pos117 := Token_Pos187;

else
   Row_Pos117 := No_Token_Index;
   goto Exit_Row117_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:281:9>

Defer_Res181 :=
   Expr_Or_Parse1 (Parser, Row_Pos117);
Defer_Pos181 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:281:9>




if Defer_Pos181 /= No_Token_Index then

   Row_Pos117 := Defer_Pos181;

else
   Row_Pos117 := No_Token_Index;
   goto Exit_Row117_0;

end if;


--  BEGIN <Token(<WithText LBrace>, ) (root of 'match_expr') at parser.lkt:282:9>

Token_Res188 := Row_Pos117;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res188));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos188 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos117 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos117,
             Expected_Token_Id => Lkt_L_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos188 := Row_Pos117 + 1;
   end if;
end;

--  END <Token(<WithText LBrace>, ) (root of 'match_expr') at parser.lkt:282:9>




if Token_Pos188 /= No_Token_Index then

   Row_Pos117 := Token_Pos188;

else
   Row_Pos117 := No_Token_Index;
   goto Exit_Row117_0;

end if;


--  BEGIN <List (root of 'match_expr') at parser.lkt:283:9>

    List_Pos28 := No_Token_Index;



Lst_Cpos28 := Row_Pos117;
Tmp_List28 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Transform(<CompiledType BareMatchBranch>) (root of 'match_expr') at parser.lkt:284:13>

Transform_Diags105 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'match_expr') at ???>

Row_Pos118 := Lst_Cpos28;



--  BEGIN <Token(<WithText CaseKw>, ) (root of 'match_expr') at parser.lkt:285:17>

Token_Res189 := Row_Pos118;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res189));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Case_Kw)
   then
       Token_Pos189 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos118 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos118,
             Expected_Token_Id => Lkt_Case_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos189 := Row_Pos118 + 1;
   end if;
end;

--  END <Token(<WithText CaseKw>, ) (root of 'match_expr') at parser.lkt:285:17>




if Token_Pos189 /= No_Token_Index then

   Row_Pos118 := Token_Pos189;

else
   Row_Pos118 := No_Token_Index;
   goto Exit_Row118_0;

end if;


--  BEGIN <Transform(<CompiledType BareMatchValDecl>) (root of 'match_expr') at parser.lkt:285:24>

Transform_Diags104 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'match_expr') at ???>

Row_Pos119 := Row_Pos118;



--  BEGIN <Defer (for 'def_id') at parser.lkt:285:37>

Defer_Res182 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos119);
Defer_Pos182 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:285:37>




if Defer_Pos182 /= No_Token_Index then

   Row_Pos119 := Defer_Pos182;

else
   Row_Pos119 := No_Token_Index;
   goto Exit_Row119_0;

end if;


--  BEGIN <Opt (root of 'match_expr') at parser.lkt:285:44>












--  BEGIN <_Extract (root of 'match_expr') at parser.lkt:285:45>

--  BEGIN <_Row (root of 'match_expr') at ???>

Row_Pos120 := Row_Pos119;



--  BEGIN <Token(<WithText Colon>, ) (root of 'match_expr') at parser.lkt:285:50>

Token_Res190 := Row_Pos120;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res190));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos190 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos120 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos120,
             Expected_Token_Id => Lkt_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos190 := Row_Pos120 + 1;
   end if;
end;

--  END <Token(<WithText Colon>, ) (root of 'match_expr') at parser.lkt:285:50>




if Token_Pos190 /= No_Token_Index then

   Row_Pos120 := Token_Pos190;

else
   Row_Pos120 := No_Token_Index;
   goto Exit_Row120_0;

end if;


--  BEGIN <Defer (for 'type_ref') at parser.lkt:285:54>

Defer_Res183 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos120);
Defer_Pos183 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:285:54>




if Defer_Pos183 /= No_Token_Index then

   Row_Pos120 := Defer_Pos183;

else
   Row_Pos120 := No_Token_Index;
   goto Exit_Row120_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row120_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'match_expr') at ???>

--  END <_Extract (root of 'match_expr') at parser.lkt:285:45>


if Row_Pos120 = No_Token_Index then

         
   Defer_Res183 := No_Bare_Lkt_Node;



       
   Row_Pos120 := Row_Pos119;



end if;

--  END <Opt (root of 'match_expr') at parser.lkt:285:44>




if Row_Pos120 /= No_Token_Index then

   Row_Pos119 := Row_Pos120;

else
   Row_Pos119 := No_Token_Index;
   goto Exit_Row119_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row119_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'match_expr') at ???>



if Row_Pos119 /= No_Token_Index then

   Transform_Res104 := Allocate_Match_Val_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res104,
      Kind => Lkt_Match_Val_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Row_Pos118,
      Token_End_Index   => (if Row_Pos119 = Row_Pos118
                            then No_Token_Index
                            else Row_Pos119 - 1));

      
      Initialize_Fields_For_Match_Val_Decl
        (Self => Transform_Res104,
         Match_Val_Decl_F_Syn_Name => Defer_Res182,
         Match_Val_Decl_F_Decl_Type => Defer_Res183);

         if Defer_Res182 /= null and then Is_Incomplete (Defer_Res182) then
            Transform_Res104.Last_Attempted_Child := 0;
         elsif Defer_Res182 /= null and then not Is_Ghost (Defer_Res182) then
            Transform_Res104.Last_Attempted_Child := -1;
         end if;
         if Defer_Res183 /= null and then Is_Incomplete (Defer_Res183) then
            Transform_Res104.Last_Attempted_Child := 0;
         elsif Defer_Res183 /= null and then not Is_Ghost (Defer_Res183) then
            Transform_Res104.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos119 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags104);
end if;

--  END <Transform(<CompiledType BareMatchValDecl>) (root of 'match_expr') at parser.lkt:285:24>




if Row_Pos119 /= No_Token_Index then

   Row_Pos118 := Row_Pos119;

else
   Row_Pos118 := No_Token_Index;
   goto Exit_Row118_0;

end if;


--  BEGIN <Token(<WithText FatRightArrow>, ) (root of 'match_expr') at parser.lkt:285:65>

Token_Res191 := Row_Pos118;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res191));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Fat_Right_Arrow)
   then
       Token_Pos191 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos118 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos118,
             Expected_Token_Id => Lkt_Fat_Right_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos191 := Row_Pos118 + 1;
   end if;
end;

--  END <Token(<WithText FatRightArrow>, ) (root of 'match_expr') at parser.lkt:285:65>




if Token_Pos191 /= No_Token_Index then

   Row_Pos118 := Token_Pos191;

else
   Row_Pos118 := No_Token_Index;
   goto Exit_Row118_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:285:70>

Defer_Res184 :=
   Expr_Or_Parse1 (Parser, Row_Pos118);
Defer_Pos184 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:285:70>




if Defer_Pos184 /= No_Token_Index then

   Row_Pos118 := Defer_Pos184;

else
   Row_Pos118 := No_Token_Index;
   goto Exit_Row118_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row118_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'match_expr') at ???>



if Row_Pos118 /= No_Token_Index then

   Transform_Res105 := Allocate_Match_Branch (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res105,
      Kind => Lkt_Match_Branch,
      Unit => Parser.Unit,

      Token_Start_Index => Lst_Cpos28,
      Token_End_Index   => (if Row_Pos118 = Lst_Cpos28
                            then No_Token_Index
                            else Row_Pos118 - 1));

      
      Initialize_Fields_For_Match_Branch
        (Self => Transform_Res105,
         Match_Branch_F_Decl => Transform_Res104,
         Match_Branch_F_Expr => Defer_Res184);

         if Transform_Res104 /= null and then Is_Incomplete (Transform_Res104) then
            Transform_Res105.Last_Attempted_Child := 0;
         elsif Transform_Res104 /= null and then not Is_Ghost (Transform_Res104) then
            Transform_Res105.Last_Attempted_Child := -1;
         end if;
         if Defer_Res184 /= null and then Is_Incomplete (Defer_Res184) then
            Transform_Res105.Last_Attempted_Child := 0;
         elsif Defer_Res184 /= null and then not Is_Ghost (Defer_Res184) then
            Transform_Res105.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos118 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags105);
end if;

--  END <Transform(<CompiledType BareMatchBranch>) (root of 'match_expr') at parser.lkt:284:13>


   exit when Row_Pos118 = No_Token_Index;

   List_Pos28 := Row_Pos118;
   Lst_Cpos28 := List_Pos28;

   Tmp_List28.Nodes.Append (Transform_Res105);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List28.Nodes.Length;
begin
   List_Res28 := Allocate_Match_Branch_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos117;
      Token_End := (if Lst_Cpos28 = Row_Pos117
                    then Row_Pos117
                    else List_Pos28 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos117, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res28,
      Kind              => Lkt_Match_Branch_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res28,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List28.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res28.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List28);

--  END <List (root of 'match_expr') at parser.lkt:283:9>




if List_Pos28 /= No_Token_Index then

   Row_Pos117 := List_Pos28;

else
   Row_Pos117 := No_Token_Index;
   goto Exit_Row117_0;

end if;


--  BEGIN <Token(<WithText RBrace>, ) (root of 'match_expr') at parser.lkt:288:9>

Token_Res192 := Row_Pos117;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res192));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos192 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos117 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos117,
             Expected_Token_Id => Lkt_R_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos192 := Row_Pos117 + 1;
   end if;
end;

--  END <Token(<WithText RBrace>, ) (root of 'match_expr') at parser.lkt:288:9>




if Token_Pos192 /= No_Token_Index then

   Row_Pos117 := Token_Pos192;

else
   Row_Pos117 := No_Token_Index;
   goto Exit_Row117_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row117_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'match_expr') at ???>



if Row_Pos117 /= No_Token_Index then

   Transform_Res106 := Allocate_Match_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res106,
      Kind => Lkt_Match_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos117 = Pos
                            then No_Token_Index
                            else Row_Pos117 - 1));

      
      Initialize_Fields_For_Match_Expr
        (Self => Transform_Res106,
         Match_Expr_F_Match_Expr => Defer_Res181,
         Match_Expr_F_Branches => List_Res28);

         if Defer_Res181 /= null and then Is_Incomplete (Defer_Res181) then
            Transform_Res106.Last_Attempted_Child := 0;
         elsif Defer_Res181 /= null and then not Is_Ghost (Defer_Res181) then
            Transform_Res106.Last_Attempted_Child := -1;
         end if;
         if List_Res28 /= null and then Is_Incomplete (List_Res28) then
            Transform_Res106.Last_Attempted_Child := 0;
         elsif List_Res28 /= null and then not Is_Ghost (List_Res28) then
            Transform_Res106.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos117 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags106);
end if;

--  END <Transform(<CompiledType BareMatchExpr>) (root of 'match_expr') at parser.lkt:279:19>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Match_Expr_Transform_Parse2_Memo,
      Row_Pos117 /= No_Token_Index,
      Transform_Res106,
      Pos,
      Row_Pos117);


   Parser.Current_Pos := Row_Pos117;

   return Transform_Res106;
end Match_Expr_Transform_Parse2;

   


function Null_Lit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Null_Lit
is
   use Bare_Null_Lit_Memos;

      Row_Pos121 :
            Token_Index
               := No_Token_Index;
      Token_Pos193 :
            Token_Index
               := No_Token_Index;
      Token_Res193 :
            Token_Index
               := No_Token_Index;
      Row_Pos122 :
            Token_Index
               := No_Token_Index;
      Token_Pos194 :
            Token_Index
               := No_Token_Index;
      Token_Res194 :
            Token_Index
               := No_Token_Index;
      Defer_Pos185 :
            Token_Index
               := No_Token_Index;
      Defer_Res185 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Token_Pos195 :
            Token_Index
               := No_Token_Index;
      Token_Res195 :
            Token_Index
               := No_Token_Index;
      Transform_Res107 :
            Bare_Null_Lit
               := No_Bare_Lkt_Node;
      Transform_Diags107 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Null_Lit_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res107 := M.Instance;
      return Transform_Res107;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res107;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareNullLit>) (root of 'null_lit') at parser.lkt:347:17>

Transform_Diags107 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'null_lit') at ???>

Row_Pos121 := Pos;



--  BEGIN <Token(<WithText NullKw>, ) (root of 'null_lit') at parser.lkt:347:25>

Token_Res193 := Row_Pos121;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res193));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Null_Kw)
   then
       Token_Pos193 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos121 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos121,
             Expected_Token_Id => Lkt_Null_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos193 := Row_Pos121 + 1;
   end if;
end;

--  END <Token(<WithText NullKw>, ) (root of 'null_lit') at parser.lkt:347:25>




if Token_Pos193 /= No_Token_Index then

   Row_Pos121 := Token_Pos193;

else
   Row_Pos121 := No_Token_Index;
   goto Exit_Row121_0;

end if;


--  BEGIN <Opt (root of 'null_lit') at parser.lkt:347:32>












--  BEGIN <_Extract (root of 'null_lit') at parser.lkt:347:33>

--  BEGIN <_Row (root of 'null_lit') at ???>

Row_Pos122 := Row_Pos121;



--  BEGIN <Token(<WithText LBrack>, ) (root of 'null_lit') at parser.lkt:347:38>

Token_Res194 := Row_Pos122;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res194));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos194 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos122 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos122,
             Expected_Token_Id => Lkt_L_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos194 := Row_Pos122 + 1;
   end if;
end;

--  END <Token(<WithText LBrack>, ) (root of 'null_lit') at parser.lkt:347:38>




if Token_Pos194 /= No_Token_Index then

   Row_Pos122 := Token_Pos194;

else
   Row_Pos122 := No_Token_Index;
   goto Exit_Row122_0;

end if;


--  BEGIN <Defer (for 'type_ref') at parser.lkt:347:42>

Defer_Res185 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos122);
Defer_Pos185 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:347:42>




if Defer_Pos185 /= No_Token_Index then

   Row_Pos122 := Defer_Pos185;

else
   Row_Pos122 := No_Token_Index;
   goto Exit_Row122_0;

end if;


--  BEGIN <Token(<WithText RBrack>, ) (root of 'null_lit') at parser.lkt:347:51>

Token_Res195 := Row_Pos122;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res195));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos195 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos122 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos122,
             Expected_Token_Id => Lkt_R_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos195 := Row_Pos122 + 1;
   end if;
end;

--  END <Token(<WithText RBrack>, ) (root of 'null_lit') at parser.lkt:347:51>




if Token_Pos195 /= No_Token_Index then

   Row_Pos122 := Token_Pos195;

else
   Row_Pos122 := No_Token_Index;
   goto Exit_Row122_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row122_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'null_lit') at ???>

--  END <_Extract (root of 'null_lit') at parser.lkt:347:33>


if Row_Pos122 = No_Token_Index then

         
   Defer_Res185 := No_Bare_Lkt_Node;



       
   Row_Pos122 := Row_Pos121;



end if;

--  END <Opt (root of 'null_lit') at parser.lkt:347:32>




if Row_Pos122 /= No_Token_Index then

   Row_Pos121 := Row_Pos122;

else
   Row_Pos121 := No_Token_Index;
   goto Exit_Row121_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row121_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'null_lit') at ???>



if Row_Pos121 /= No_Token_Index then

   Transform_Res107 := Allocate_Null_Lit (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res107,
      Kind => Lkt_Null_Lit,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos121 = Pos
                            then No_Token_Index
                            else Row_Pos121 - 1));

      
      Initialize_Fields_For_Null_Lit
        (Self => Transform_Res107,
         Null_Lit_F_Dest_Type => Defer_Res185);

         if Defer_Res185 /= null and then Is_Incomplete (Defer_Res185) then
            Transform_Res107.Last_Attempted_Child := 0;
         elsif Defer_Res185 /= null and then not Is_Ghost (Defer_Res185) then
            Transform_Res107.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos121 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags107);
end if;

--  END <Transform(<CompiledType BareNullLit>) (root of 'null_lit') at parser.lkt:347:17>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Null_Lit_Transform_Parse0_Memo,
      Row_Pos121 /= No_Token_Index,
      Transform_Res107,
      Pos,
      Row_Pos121);


   Parser.Current_Pos := Row_Pos121;

   return Transform_Res107;
end Null_Lit_Transform_Parse0;

   


function Num_Lit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Num_Lit
is
   use Bare_Num_Lit_Memos;

      Row_Pos123 :
            Token_Index
               := No_Token_Index;
      Token_Pos196 :
            Token_Index
               := No_Token_Index;
      Token_Res196 :
            Token_Index
               := No_Token_Index;
      Transform_Res108 :
            Bare_Num_Lit
               := No_Bare_Lkt_Node;
      Transform_Diags108 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Num_Lit_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res108 := M.Instance;
      return Transform_Res108;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res108;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareNumLit>) (root of 'num_lit') at parser.lkt:290:16>

Transform_Diags108 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'num_lit') at ???>

Row_Pos123 := Pos;



--  BEGIN <Token(<WithText Number>, ) (root of 'num_lit') at parser.lkt:290:23>

Token_Res196 := Row_Pos123;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res196));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Number)
   then
       Token_Pos196 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos123 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos123,
             Expected_Token_Id => Lkt_Number,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos196 := Row_Pos123 + 1;
   end if;
end;

--  END <Token(<WithText Number>, ) (root of 'num_lit') at parser.lkt:290:23>




if Token_Pos196 /= No_Token_Index then

   Row_Pos123 := Token_Pos196;

else
   Row_Pos123 := No_Token_Index;
   goto Exit_Row123_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row123_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'num_lit') at ???>



if Row_Pos123 /= No_Token_Index then

   Transform_Res108 := Allocate_Num_Lit (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res108,
      Kind => Lkt_Num_Lit,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos123 = Pos
                            then No_Token_Index
                            else Row_Pos123 - 1));

      
      Initialize_Fields_For_Num_Lit
        (Self => Transform_Res108);



elsif Row_Pos123 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags108);
end if;

--  END <Transform(<CompiledType BareNumLit>) (root of 'num_lit') at parser.lkt:290:16>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Num_Lit_Transform_Parse0_Memo,
      Row_Pos123 /= No_Token_Index,
      Transform_Res108,
      Pos,
      Row_Pos123);


   Parser.Current_Pos := Row_Pos123;

   return Transform_Res108;
end Num_Lit_Transform_Parse0;

   


function Param_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Param
is
   use Bare_Param_Memos;

      Row_Pos124 :
            Token_Index
               := No_Token_Index;
      Row_Pos125 :
            Token_Index
               := No_Token_Index;
      Defer_Pos186 :
            Token_Index
               := No_Token_Index;
      Defer_Res186 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Token_Pos197 :
            Token_Index
               := No_Token_Index;
      Token_Res197 :
            Token_Index
               := No_Token_Index;
      Defer_Pos187 :
            Token_Index
               := No_Token_Index;
      Defer_Res187 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res109 :
            Bare_Param
               := No_Bare_Lkt_Node;
      Transform_Diags109 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Param_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res109 := M.Instance;
      return Transform_Res109;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res109;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareParam>) (root of 'param') at parser.lkt:348:14>

Transform_Diags109 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'param') at ???>

Row_Pos124 := Pos;



--  BEGIN <Opt (root of 'param') at parser.lkt:348:20>












--  BEGIN <_Extract (root of 'param') at parser.lkt:348:21>

--  BEGIN <_Row (root of 'param') at ???>

Row_Pos125 := Row_Pos124;



--  BEGIN <Defer (for 'ref_id') at parser.lkt:348:26>

Defer_Res186 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos125);
Defer_Pos186 := Parser.Current_Pos;

--  END <Defer (for 'ref_id') at parser.lkt:348:26>




if Defer_Pos186 /= No_Token_Index then

   Row_Pos125 := Defer_Pos186;

else
   Row_Pos125 := No_Token_Index;
   goto Exit_Row125_0;

end if;


--  BEGIN <Token(<WithText Equal>, ) (root of 'param') at parser.lkt:348:33>

Token_Res197 := Row_Pos125;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res197));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Equal)
   then
       Token_Pos197 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos125 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos125,
             Expected_Token_Id => Lkt_Equal,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos197 := Row_Pos125 + 1;
   end if;
end;

--  END <Token(<WithText Equal>, ) (root of 'param') at parser.lkt:348:33>




if Token_Pos197 /= No_Token_Index then

   Row_Pos125 := Token_Pos197;

else
   Row_Pos125 := No_Token_Index;
   goto Exit_Row125_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row125_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'param') at ???>

--  END <_Extract (root of 'param') at parser.lkt:348:21>


if Row_Pos125 = No_Token_Index then

         
   Defer_Res186 := No_Bare_Lkt_Node;



       
   Row_Pos125 := Row_Pos124;



end if;

--  END <Opt (root of 'param') at parser.lkt:348:20>




if Row_Pos125 /= No_Token_Index then

   Row_Pos124 := Row_Pos125;

else
   Row_Pos124 := No_Token_Index;
   goto Exit_Row124_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:348:38>

Defer_Res187 :=
   Expr_Or_Parse1 (Parser, Row_Pos124);
Defer_Pos187 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:348:38>




if Defer_Pos187 /= No_Token_Index then

   Row_Pos124 := Defer_Pos187;

else
   Row_Pos124 := No_Token_Index;
   goto Exit_Row124_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row124_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'param') at ???>



if Row_Pos124 /= No_Token_Index then

   Transform_Res109 := Allocate_Param (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res109,
      Kind => Lkt_Param,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos124 = Pos
                            then No_Token_Index
                            else Row_Pos124 - 1));

      
      Initialize_Fields_For_Param
        (Self => Transform_Res109,
         Param_F_Name => Defer_Res186,
         Param_F_Value => Defer_Res187);

         if Defer_Res186 /= null and then Is_Incomplete (Defer_Res186) then
            Transform_Res109.Last_Attempted_Child := 0;
         elsif Defer_Res186 /= null and then not Is_Ghost (Defer_Res186) then
            Transform_Res109.Last_Attempted_Child := -1;
         end if;
         if Defer_Res187 /= null and then Is_Incomplete (Defer_Res187) then
            Transform_Res109.Last_Attempted_Child := 0;
         elsif Defer_Res187 /= null and then not Is_Ghost (Defer_Res187) then
            Transform_Res109.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos124 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags109);
end if;

--  END <Transform(<CompiledType BareParam>) (root of 'param') at parser.lkt:348:14>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Param_Transform_Parse0_Memo,
      Row_Pos124 /= No_Token_Index,
      Transform_Res109,
      Pos,
      Row_Pos124);


   Parser.Current_Pos := Row_Pos124;

   return Transform_Res109;
end Param_Transform_Parse0;

   


function Params_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Param_List
is
   use Bare_Param_List_Memos;

      Lst_Cpos29 :
            Token_Index
               := No_Token_Index;
      Tmp_List29 :
            Free_Parse_List;
      Defer_Pos188 :
            Token_Index
               := No_Token_Index;
      Defer_Res188 :
            Bare_Param
               := No_Bare_Lkt_Node;
      Token_Pos198 :
            Token_Index
               := No_Token_Index;
      Token_Res198 :
            Token_Index
               := No_Token_Index;
      List_Pos29 :
            Token_Index
               := No_Token_Index;
      List_Res29 :
            Bare_Param_List
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Params_List_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res29 := M.Instance;
      return List_Res29;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return List_Res29;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <List (root of 'params') at parser.lkt:349:15>

    List_Pos29 := Pos;



Lst_Cpos29 := Pos;
Tmp_List29 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'param') at parser.lkt:349:21>

Defer_Res188 :=
   Param_Transform_Parse0 (Parser, Lst_Cpos29);
Defer_Pos188 := Parser.Current_Pos;

--  END <Defer (for 'param') at parser.lkt:349:21>


   exit when Defer_Pos188 = No_Token_Index;

   List_Pos29 := Defer_Pos188;
   Lst_Cpos29 := List_Pos29;

   Tmp_List29.Nodes.Append (Defer_Res188);

      
--  BEGIN <Token(<WithText Comma>, ) (root of 'params') at parser.lkt:349:28>

Token_Res198 := Lst_Cpos29;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res198));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos198 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos29 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos29,
             Expected_Token_Id => Lkt_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos198 := Lst_Cpos29 + 1;
   end if;
end;

--  END <Token(<WithText Comma>, ) (root of 'params') at parser.lkt:349:28>


      exit when Token_Pos198 = No_Token_Index;

      Lst_Cpos29 := Token_Pos198;

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List29.Nodes.Length;
begin
   List_Res29 := Allocate_Param_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos29 = Pos
                    then Pos
                    else List_Pos29 - 1);

   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res29,
      Kind              => Lkt_Param_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res29,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List29.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res29.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List29);

--  END <List (root of 'params') at parser.lkt:349:15>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Params_List_Parse0_Memo,
      List_Pos29 /= No_Token_Index,
      List_Res29,
      Pos,
      List_Pos29);


   Parser.Current_Pos := List_Pos29;

   return List_Res29;
end Params_List_Parse0;

   


function Parse_Node_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Parse_Node_Expr
is
   use Bare_Parse_Node_Expr_Memos;

      Row_Pos126 :
            Token_Index
               := No_Token_Index;
      Defer_Pos189 :
            Token_Index
               := No_Token_Index;
      Defer_Res189 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Token_Pos199 :
            Token_Index
               := No_Token_Index;
      Token_Res199 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos30 :
            Token_Index
               := No_Token_Index;
      Tmp_List30 :
            Free_Parse_List;
      Defer_Pos190 :
            Token_Index
               := No_Token_Index;
      Defer_Res190 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      List_Pos30 :
            Token_Index
               := No_Token_Index;
      List_Res30 :
            Bare_Grammar_Expr_List
               := No_Bare_Lkt_Node;
      Token_Pos200 :
            Token_Index
               := No_Token_Index;
      Token_Res200 :
            Token_Index
               := No_Token_Index;
      Transform_Res110 :
            Bare_Parse_Node_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags110 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Parse_Node_Expr_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res110 := M.Instance;
      return Transform_Res110;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res110;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareParseNodeExpr>) (root of 'parse_node_expr') at parser.lkt:97:24>

Transform_Diags110 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'parse_node_expr') at ???>

Row_Pos126 := Pos;



--  BEGIN <Defer (for 'type_ref') at parser.lkt:97:38>

Defer_Res189 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos126);
Defer_Pos189 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:97:38>




if Defer_Pos189 /= No_Token_Index then

   Row_Pos126 := Defer_Pos189;

else
   Row_Pos126 := No_Token_Index;
   goto Exit_Row126_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'parse_node_expr') at parser.lkt:97:47>

Token_Res199 := Row_Pos126;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res199));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos199 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos126 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos126,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos199 := Row_Pos126 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'parse_node_expr') at parser.lkt:97:47>




if Token_Pos199 /= No_Token_Index then

   Row_Pos126 := Token_Pos199;

else
   Row_Pos126 := No_Token_Index;
   goto Exit_Row126_0;

end if;


--  BEGIN <List (root of 'parse_node_expr') at parser.lkt:97:51>

    List_Pos30 := Row_Pos126;



Lst_Cpos30 := Row_Pos126;
Tmp_List30 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:97:57>

Defer_Res190 :=
   Grammar_Expr_Or_Parse0 (Parser, Lst_Cpos30);
Defer_Pos190 := Parser.Current_Pos;

--  END <Defer (for 'grammar_expr') at parser.lkt:97:57>


   exit when Defer_Pos190 = No_Token_Index;

   List_Pos30 := Defer_Pos190;
   Lst_Cpos30 := List_Pos30;

   Tmp_List30.Nodes.Append (Defer_Res190);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List30.Nodes.Length;
begin
   List_Res30 := Allocate_Grammar_Expr_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos126;
      Token_End := (if Lst_Cpos30 = Row_Pos126
                    then Row_Pos126
                    else List_Pos30 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos126, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res30,
      Kind              => Lkt_Grammar_Expr_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res30,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List30.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res30.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List30);

--  END <List (root of 'parse_node_expr') at parser.lkt:97:51>




if List_Pos30 /= No_Token_Index then

   Row_Pos126 := List_Pos30;

else
   Row_Pos126 := No_Token_Index;
   goto Exit_Row126_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'parse_node_expr') at parser.lkt:97:71>

Token_Res200 := Row_Pos126;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res200));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos200 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos126 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos126,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos200 := Row_Pos126 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'parse_node_expr') at parser.lkt:97:71>




if Token_Pos200 /= No_Token_Index then

   Row_Pos126 := Token_Pos200;

else
   Row_Pos126 := No_Token_Index;
   goto Exit_Row126_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row126_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'parse_node_expr') at ???>



if Row_Pos126 /= No_Token_Index then

   Transform_Res110 := Allocate_Parse_Node_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res110,
      Kind => Lkt_Parse_Node_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos126 = Pos
                            then No_Token_Index
                            else Row_Pos126 - 1));

      
      Initialize_Fields_For_Parse_Node_Expr
        (Self => Transform_Res110,
         Parse_Node_Expr_F_Node_Name => Defer_Res189,
         Parse_Node_Expr_F_Sub_Exprs => List_Res30);

         if Defer_Res189 /= null and then Is_Incomplete (Defer_Res189) then
            Transform_Res110.Last_Attempted_Child := 0;
         elsif Defer_Res189 /= null and then not Is_Ghost (Defer_Res189) then
            Transform_Res110.Last_Attempted_Child := -1;
         end if;
         if List_Res30 /= null and then Is_Incomplete (List_Res30) then
            Transform_Res110.Last_Attempted_Child := 0;
         elsif List_Res30 /= null and then not Is_Ghost (List_Res30) then
            Transform_Res110.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos126 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags110);
end if;

--  END <Transform(<CompiledType BareParseNodeExpr>) (root of 'parse_node_expr') at parser.lkt:97:24>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Parse_Node_Expr_Transform_Parse0_Memo,
      Row_Pos126 /= No_Token_Index,
      Transform_Res110,
      Pos,
      Row_Pos126);


   Parser.Current_Pos := Row_Pos126;

   return Transform_Res110;
end Parse_Node_Expr_Transform_Parse0;

   


function Primary_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

      Defer_Pos191 :
            Token_Index
               := No_Token_Index;
      Defer_Res191 :
            Bare_Lambda_Expr
               := No_Bare_Lkt_Node;
      Defer_Pos192 :
            Token_Index
               := No_Token_Index;
      Defer_Res192 :
            Bare_If_Expr
               := No_Bare_Lkt_Node;
      Defer_Pos193 :
            Token_Index
               := No_Token_Index;
      Defer_Res193 :
            Bare_Raise_Expr
               := No_Bare_Lkt_Node;
      Defer_Pos194 :
            Token_Index
               := No_Token_Index;
      Defer_Res194 :
            Bare_Try_Expr
               := No_Bare_Lkt_Node;
      Defer_Pos195 :
            Token_Index
               := No_Token_Index;
      Defer_Res195 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Or_Pos26 :
            Token_Index
               := No_Token_Index;
      Or_Res26 :
            Bare_Expr
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Primary_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res26 := M.Instance;
      return Or_Res26;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res26;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'primary') at parser.lkt:278:16>

Or_Pos26 := No_Token_Index;
Or_Res26 := No_Bare_Lkt_Node;
    
--  BEGIN <Defer (for 'lambda_expr') at parser.lkt:278:21>

Defer_Res191 :=
   Lambda_Expr_Transform_Parse0 (Parser, Pos);
Defer_Pos191 := Parser.Current_Pos;

--  END <Defer (for 'lambda_expr') at parser.lkt:278:21>

    if Defer_Pos191 /= No_Token_Index then
        Or_Pos26 := Defer_Pos191;
        Or_Res26 := Defer_Res191;
        goto Exit_Or26;
    end if;
    
--  BEGIN <Defer (for 'if_expr') at parser.lkt:278:35>

Defer_Res192 :=
   If_Expr_Transform_Parse1 (Parser, Pos);
Defer_Pos192 := Parser.Current_Pos;

--  END <Defer (for 'if_expr') at parser.lkt:278:35>

    if Defer_Pos192 /= No_Token_Index then
        Or_Pos26 := Defer_Pos192;
        Or_Res26 := Defer_Res192;
        goto Exit_Or26;
    end if;
    
--  BEGIN <Defer (for 'raise_expr') at parser.lkt:278:45>

Defer_Res193 :=
   Raise_Expr_Transform_Parse0 (Parser, Pos);
Defer_Pos193 := Parser.Current_Pos;

--  END <Defer (for 'raise_expr') at parser.lkt:278:45>

    if Defer_Pos193 /= No_Token_Index then
        Or_Pos26 := Defer_Pos193;
        Or_Res26 := Defer_Res193;
        goto Exit_Or26;
    end if;
    
--  BEGIN <Defer (for 'try_expr') at parser.lkt:278:58>

Defer_Res194 :=
   Try_Expr_Transform_Parse0 (Parser, Pos);
Defer_Pos194 := Parser.Current_Pos;

--  END <Defer (for 'try_expr') at parser.lkt:278:58>

    if Defer_Pos194 /= No_Token_Index then
        Or_Pos26 := Defer_Pos194;
        Or_Res26 := Defer_Res194;
        goto Exit_Or26;
    end if;
    
--  BEGIN <Defer (for 'basic_expr') at parser.lkt:278:69>

Defer_Res195 :=
   Basic_Expr_Or_Parse0 (Parser, Pos);
Defer_Pos195 := Parser.Current_Pos;

--  END <Defer (for 'basic_expr') at parser.lkt:278:69>

    if Defer_Pos195 /= No_Token_Index then
        Or_Pos26 := Defer_Pos195;
        Or_Res26 := Defer_Res195;
        goto Exit_Or26;
    end if;
<<Exit_Or26>>

--  END <Or (root of 'primary') at parser.lkt:278:16>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Primary_Or_Parse0_Memo,
      Or_Pos26 /= No_Token_Index,
      Or_Res26,
      Pos,
      Or_Pos26);


   Parser.Current_Pos := Or_Pos26;

   return Or_Res26;
end Primary_Or_Parse0;

   


function Raise_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Raise_Expr
is
   use Bare_Raise_Expr_Memos;

      Row_Pos127 :
            Token_Index
               := No_Token_Index;
      Token_Pos201 :
            Token_Index
               := No_Token_Index;
      Token_Res201 :
            Token_Index
               := No_Token_Index;
      Row_Pos128 :
            Token_Index
               := No_Token_Index;
      Token_Pos202 :
            Token_Index
               := No_Token_Index;
      Token_Res202 :
            Token_Index
               := No_Token_Index;
      Defer_Pos196 :
            Token_Index
               := No_Token_Index;
      Defer_Res196 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Token_Pos203 :
            Token_Index
               := No_Token_Index;
      Token_Res203 :
            Token_Index
               := No_Token_Index;
      Defer_Pos197 :
            Token_Index
               := No_Token_Index;
      Defer_Res197 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res111 :
            Bare_Raise_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags111 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Raise_Expr_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res111 := M.Instance;
      return Transform_Res111;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res111;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareRaiseExpr>) (root of 'raise_expr') at parser.lkt:310:19>

Transform_Diags111 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'raise_expr') at ???>

Row_Pos127 := Pos;



--  BEGIN <Token(<WithText RaiseKw>, ) (root of 'raise_expr') at parser.lkt:310:29>

Token_Res201 := Row_Pos127;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res201));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Raise_Kw)
   then
       Token_Pos201 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos127 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos127,
             Expected_Token_Id => Lkt_Raise_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos201 := Row_Pos127 + 1;
   end if;
end;

--  END <Token(<WithText RaiseKw>, ) (root of 'raise_expr') at parser.lkt:310:29>




if Token_Pos201 /= No_Token_Index then

   Row_Pos127 := Token_Pos201;

else
   Row_Pos127 := No_Token_Index;
   goto Exit_Row127_0;

end if;


--  BEGIN <Opt (root of 'raise_expr') at parser.lkt:310:37>












--  BEGIN <_Extract (root of 'raise_expr') at parser.lkt:310:38>

--  BEGIN <_Row (root of 'raise_expr') at ???>

Row_Pos128 := Row_Pos127;



--  BEGIN <Token(<WithText LBrack>, ) (root of 'raise_expr') at parser.lkt:310:43>

Token_Res202 := Row_Pos128;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res202));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos202 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos128 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos128,
             Expected_Token_Id => Lkt_L_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos202 := Row_Pos128 + 1;
   end if;
end;

--  END <Token(<WithText LBrack>, ) (root of 'raise_expr') at parser.lkt:310:43>




if Token_Pos202 /= No_Token_Index then

   Row_Pos128 := Token_Pos202;

else
   Row_Pos128 := No_Token_Index;
   goto Exit_Row128_0;

end if;


--  BEGIN <Defer (for 'type_ref') at parser.lkt:310:47>

Defer_Res196 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos128);
Defer_Pos196 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:310:47>




if Defer_Pos196 /= No_Token_Index then

   Row_Pos128 := Defer_Pos196;

else
   Row_Pos128 := No_Token_Index;
   goto Exit_Row128_0;

end if;


--  BEGIN <Token(<WithText RBrack>, ) (root of 'raise_expr') at parser.lkt:310:56>

Token_Res203 := Row_Pos128;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res203));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos203 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos128 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos128,
             Expected_Token_Id => Lkt_R_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos203 := Row_Pos128 + 1;
   end if;
end;

--  END <Token(<WithText RBrack>, ) (root of 'raise_expr') at parser.lkt:310:56>




if Token_Pos203 /= No_Token_Index then

   Row_Pos128 := Token_Pos203;

else
   Row_Pos128 := No_Token_Index;
   goto Exit_Row128_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row128_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'raise_expr') at ???>

--  END <_Extract (root of 'raise_expr') at parser.lkt:310:38>


if Row_Pos128 = No_Token_Index then

         
   Defer_Res196 := No_Bare_Lkt_Node;



       
   Row_Pos128 := Row_Pos127;



end if;

--  END <Opt (root of 'raise_expr') at parser.lkt:310:37>




if Row_Pos128 /= No_Token_Index then

   Row_Pos127 := Row_Pos128;

else
   Row_Pos127 := No_Token_Index;
   goto Exit_Row127_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:310:61>

Defer_Res197 :=
   Expr_Or_Parse1 (Parser, Row_Pos127);
Defer_Pos197 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:310:61>




if Defer_Pos197 /= No_Token_Index then

   Row_Pos127 := Defer_Pos197;

else
   Row_Pos127 := No_Token_Index;
   goto Exit_Row127_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row127_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'raise_expr') at ???>



if Row_Pos127 /= No_Token_Index then

   Transform_Res111 := Allocate_Raise_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res111,
      Kind => Lkt_Raise_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos127 = Pos
                            then No_Token_Index
                            else Row_Pos127 - 1));

      
      Initialize_Fields_For_Raise_Expr
        (Self => Transform_Res111,
         Raise_Expr_F_Dest_Type => Defer_Res196,
         Raise_Expr_F_Except_Expr => Defer_Res197);

         if Defer_Res196 /= null and then Is_Incomplete (Defer_Res196) then
            Transform_Res111.Last_Attempted_Child := 0;
         elsif Defer_Res196 /= null and then not Is_Ghost (Defer_Res196) then
            Transform_Res111.Last_Attempted_Child := -1;
         end if;
         if Defer_Res197 /= null and then Is_Incomplete (Defer_Res197) then
            Transform_Res111.Last_Attempted_Child := 0;
         elsif Defer_Res197 /= null and then not Is_Ghost (Defer_Res197) then
            Transform_Res111.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos127 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags111);
end if;

--  END <Transform(<CompiledType BareRaiseExpr>) (root of 'raise_expr') at parser.lkt:310:19>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Raise_Expr_Transform_Parse0_Memo,
      Row_Pos127 /= No_Token_Index,
      Transform_Res111,
      Pos,
      Row_Pos127);


   Parser.Current_Pos := Row_Pos127;

   return Transform_Res111;
end Raise_Expr_Transform_Parse0;

   


function Ref_Id_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ref_Id
is
   use Bare_Ref_Id_Memos;

      Row_Pos129 :
            Token_Index
               := No_Token_Index;
      Token_Pos204 :
            Token_Index
               := No_Token_Index;
      Token_Res204 :
            Token_Index
               := No_Token_Index;
      Transform_Res112 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Transform_Diags112 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Ref_Id_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res112 := M.Instance;
      return Transform_Res112;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res112;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareRefId>) (root of 'ref_id') at parser.lkt:7:15>

Transform_Diags112 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'ref_id') at ???>

Row_Pos129 := Pos;



--  BEGIN <Token(<WithSymbol Identifier>, ) (root of 'ref_id') at parser.lkt:7:21>

Token_Res204 := Row_Pos129;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res204));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
   then
       Token_Pos204 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos129 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos129,
             Expected_Token_Id => Lkt_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos204 := Row_Pos129 + 1;
   end if;
end;

--  END <Token(<WithSymbol Identifier>, ) (root of 'ref_id') at parser.lkt:7:21>




if Token_Pos204 /= No_Token_Index then

   Row_Pos129 := Token_Pos204;

else
   Row_Pos129 := No_Token_Index;
   goto Exit_Row129_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row129_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'ref_id') at ???>



if Row_Pos129 /= No_Token_Index then

   Transform_Res112 := Allocate_Ref_Id (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res112,
      Kind => Lkt_Ref_Id,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos129 = Pos
                            then No_Token_Index
                            else Row_Pos129 - 1));

      
      Initialize_Fields_For_Ref_Id
        (Self => Transform_Res112);



elsif Row_Pos129 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags112);
end if;

--  END <Transform(<CompiledType BareRefId>) (root of 'ref_id') at parser.lkt:7:15>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Ref_Id_Transform_Parse0_Memo,
      Row_Pos129 /= No_Token_Index,
      Transform_Res112,
      Pos,
      Row_Pos129);


   Parser.Current_Pos := Row_Pos129;

   return Transform_Res112;
end Ref_Id_Transform_Parse0;

   


function Rel_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

      Row_Pos130 :
            Token_Index
               := No_Token_Index;
      Token_Pos205 :
            Token_Index
               := No_Token_Index;
      Token_Res205 :
            Token_Index
               := No_Token_Index;
      Defer_Pos198 :
            Token_Index
               := No_Token_Index;
      Defer_Res198 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res113 :
            Bare_Not_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags113 :
            Ada.Containers.Count_Type;
      Defer_Pos199 :
            Token_Index
               := No_Token_Index;
      Defer_Res199 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Or_Pos27 :
            Token_Index
               := No_Token_Index;
      Or_Res27 :
            Bare_Expr
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Rel_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res27 := M.Instance;
      return Or_Res27;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res27;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'rel') at parser.lkt:241:12>

Or_Pos27 := No_Token_Index;
Or_Res27 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareNotExpr>) (root of 'rel') at parser.lkt:241:15>

Transform_Diags113 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'rel') at ???>

Row_Pos130 := Pos;



--  BEGIN <Token(<WithText NotKw>, ) (root of 'rel') at parser.lkt:241:23>

Token_Res205 := Row_Pos130;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res205));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Not_Kw)
   then
       Token_Pos205 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos130 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos130,
             Expected_Token_Id => Lkt_Not_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos205 := Row_Pos130 + 1;
   end if;
end;

--  END <Token(<WithText NotKw>, ) (root of 'rel') at parser.lkt:241:23>




if Token_Pos205 /= No_Token_Index then

   Row_Pos130 := Token_Pos205;

else
   Row_Pos130 := No_Token_Index;
   goto Exit_Row130_0;

end if;


--  BEGIN <Defer (for 'eq') at parser.lkt:241:29>

Defer_Res198 :=
   Eq_Or_Parse1 (Parser, Row_Pos130);
Defer_Pos198 := Parser.Current_Pos;

--  END <Defer (for 'eq') at parser.lkt:241:29>




if Defer_Pos198 /= No_Token_Index then

   Row_Pos130 := Defer_Pos198;

else
   Row_Pos130 := No_Token_Index;
   goto Exit_Row130_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row130_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'rel') at ???>



if Row_Pos130 /= No_Token_Index then

   Transform_Res113 := Allocate_Not_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res113,
      Kind => Lkt_Not_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos130 = Pos
                            then No_Token_Index
                            else Row_Pos130 - 1));

      
      Initialize_Fields_For_Not_Expr
        (Self => Transform_Res113,
         Not_Expr_F_Expr => Defer_Res198);

         if Defer_Res198 /= null and then Is_Incomplete (Defer_Res198) then
            Transform_Res113.Last_Attempted_Child := 0;
         elsif Defer_Res198 /= null and then not Is_Ghost (Defer_Res198) then
            Transform_Res113.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos130 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags113);
end if;

--  END <Transform(<CompiledType BareNotExpr>) (root of 'rel') at parser.lkt:241:15>

    if Row_Pos130 /= No_Token_Index then
        Or_Pos27 := Row_Pos130;
        Or_Res27 := Transform_Res113;
        goto Exit_Or27;
    end if;
    
--  BEGIN <Defer (for 'eq') at parser.lkt:241:35>

Defer_Res199 :=
   Eq_Or_Parse1 (Parser, Pos);
Defer_Pos199 := Parser.Current_Pos;

--  END <Defer (for 'eq') at parser.lkt:241:35>

    if Defer_Pos199 /= No_Token_Index then
        Or_Pos27 := Defer_Pos199;
        Or_Res27 := Defer_Res199;
        goto Exit_Or27;
    end if;
<<Exit_Or27>>

--  END <Or (root of 'rel') at parser.lkt:241:12>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Rel_Or_Parse0_Memo,
      Or_Pos27 /= No_Token_Index,
      Or_Res27,
      Pos,
      Or_Pos27);


   Parser.Current_Pos := Or_Pos27;

   return Or_Res27;
end Rel_Or_Parse0;

   


function String_Lit_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_String_Lit
is
   use Bare_String_Lit_Memos;

      Row_Pos131 :
            Token_Index
               := No_Token_Index;
      Token_Pos206 :
            Token_Index
               := No_Token_Index;
      Token_Res206 :
            Token_Index
               := No_Token_Index;
      Transform_Res114 :
            Bare_Single_Line_String_Lit
               := No_Bare_Lkt_Node;
      Transform_Diags114 :
            Ada.Containers.Count_Type;
      Row_Pos132 :
            Token_Index
               := No_Token_Index;
      Token_Pos207 :
            Token_Index
               := No_Token_Index;
      Token_Res207 :
            Token_Index
               := No_Token_Index;
      Transform_Res115 :
            Bare_Pattern_Single_Line_String_Lit
               := No_Bare_Lkt_Node;
      Transform_Diags115 :
            Ada.Containers.Count_Type;
      Defer_Pos200 :
            Token_Index
               := No_Token_Index;
      Defer_Res200 :
            Bare_Block_String_Lit
               := No_Bare_Lkt_Node;
      Or_Pos28 :
            Token_Index
               := No_Token_Index;
      Or_Res28 :
            Bare_String_Lit
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.String_Lit_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res28 := M.Instance;
      return Or_Res28;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res28;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'string_lit') at parser.lkt:292:19>

Or_Pos28 := No_Token_Index;
Or_Res28 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareSingleLineStringLit>) (root of 'string_lit') at parser.lkt:293:11>

Transform_Diags114 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'string_lit') at ???>

Row_Pos131 := Pos;



--  BEGIN <Token(<WithText String>, ) (root of 'string_lit') at parser.lkt:293:31>

Token_Res206 := Row_Pos131;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res206));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_String)
   then
       Token_Pos206 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos131 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos131,
             Expected_Token_Id => Lkt_String,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos206 := Row_Pos131 + 1;
   end if;
end;

--  END <Token(<WithText String>, ) (root of 'string_lit') at parser.lkt:293:31>




if Token_Pos206 /= No_Token_Index then

   Row_Pos131 := Token_Pos206;

else
   Row_Pos131 := No_Token_Index;
   goto Exit_Row131_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row131_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'string_lit') at ???>



if Row_Pos131 /= No_Token_Index then

   Transform_Res114 := Allocate_Single_Line_String_Lit (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res114,
      Kind => Lkt_Single_Line_String_Lit,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos131 = Pos
                            then No_Token_Index
                            else Row_Pos131 - 1));

      
      Initialize_Fields_For_Single_Line_String_Lit
        (Self => Transform_Res114);



elsif Row_Pos131 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags114);
end if;

--  END <Transform(<CompiledType BareSingleLineStringLit>) (root of 'string_lit') at parser.lkt:293:11>

    if Row_Pos131 /= No_Token_Index then
        Or_Pos28 := Row_Pos131;
        Or_Res28 := Transform_Res114;
        goto Exit_Or28;
    end if;
    
--  BEGIN <Transform(<CompiledType BarePatternSingleLineStringLit>) (root of 'string_lit') at parser.lkt:294:11>

Transform_Diags115 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'string_lit') at ???>

Row_Pos132 := Pos;



--  BEGIN <Token(<WithText PString>, ) (root of 'string_lit') at parser.lkt:294:38>

Token_Res207 := Row_Pos132;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res207));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_P_String)
   then
       Token_Pos207 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos132 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos132,
             Expected_Token_Id => Lkt_P_String,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos207 := Row_Pos132 + 1;
   end if;
end;

--  END <Token(<WithText PString>, ) (root of 'string_lit') at parser.lkt:294:38>




if Token_Pos207 /= No_Token_Index then

   Row_Pos132 := Token_Pos207;

else
   Row_Pos132 := No_Token_Index;
   goto Exit_Row132_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row132_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'string_lit') at ???>



if Row_Pos132 /= No_Token_Index then

   Transform_Res115 := Allocate_Pattern_Single_Line_String_Lit (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res115,
      Kind => Lkt_Pattern_Single_Line_String_Lit,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos132 = Pos
                            then No_Token_Index
                            else Row_Pos132 - 1));

      
      Initialize_Fields_For_Pattern_Single_Line_String_Lit
        (Self => Transform_Res115);



elsif Row_Pos132 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags115);
end if;

--  END <Transform(<CompiledType BarePatternSingleLineStringLit>) (root of 'string_lit') at parser.lkt:294:11>

    if Row_Pos132 /= No_Token_Index then
        Or_Pos28 := Row_Pos132;
        Or_Res28 := Transform_Res115;
        goto Exit_Or28;
    end if;
    
--  BEGIN <Defer (for 'block_string_lit') at parser.lkt:295:11>

Defer_Res200 :=
   Block_String_Lit_Transform_Parse1 (Parser, Pos);
Defer_Pos200 := Parser.Current_Pos;

--  END <Defer (for 'block_string_lit') at parser.lkt:295:11>

    if Defer_Pos200 /= No_Token_Index then
        Or_Pos28 := Defer_Pos200;
        Or_Res28 := Defer_Res200;
        goto Exit_Or28;
    end if;
<<Exit_Or28>>

--  END <Or (root of 'string_lit') at parser.lkt:292:19>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.String_Lit_Or_Parse0_Memo,
      Or_Pos28 /= No_Token_Index,
      Or_Res28,
      Pos,
      Or_Pos28);


   Parser.Current_Pos := Or_Pos28;

   return Or_Res28;
end String_Lit_Or_Parse0;

   


function Term_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

      Row_Pos133 :
            Token_Index
               := No_Token_Index;
      Token_Pos208 :
            Token_Index
               := No_Token_Index;
      Token_Res208 :
            Token_Index
               := No_Token_Index;
      Defer_Pos201 :
            Token_Index
               := No_Token_Index;
      Defer_Res201 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos209 :
            Token_Index
               := No_Token_Index;
      Token_Res209 :
            Token_Index
               := No_Token_Index;
      Transform_Res116 :
            Bare_Paren_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags116 :
            Ada.Containers.Count_Type;
      Defer_Pos202 :
            Token_Index
               := No_Token_Index;
      Defer_Res202 :
            Bare_Match_Expr
               := No_Bare_Lkt_Node;
      Defer_Pos203 :
            Token_Index
               := No_Token_Index;
      Defer_Res203 :
            Bare_Null_Lit
               := No_Bare_Lkt_Node;
      Defer_Pos204 :
            Token_Index
               := No_Token_Index;
      Defer_Res204 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Defer_Pos205 :
            Token_Index
               := No_Token_Index;
      Defer_Res205 :
            Bare_Block_Expr
               := No_Bare_Lkt_Node;
      Defer_Pos206 :
            Token_Index
               := No_Token_Index;
      Defer_Res206 :
            Bare_Num_Lit
               := No_Bare_Lkt_Node;
      Defer_Pos207 :
            Token_Index
               := No_Token_Index;
      Defer_Res207 :
            Bare_Big_Num_Lit
               := No_Bare_Lkt_Node;
      Defer_Pos208 :
            Token_Index
               := No_Token_Index;
      Defer_Res208 :
            Bare_String_Lit
               := No_Bare_Lkt_Node;
      Defer_Pos209 :
            Token_Index
               := No_Token_Index;
      Defer_Res209 :
            Bare_Char_Lit
               := No_Bare_Lkt_Node;
      Defer_Pos210 :
            Token_Index
               := No_Token_Index;
      Defer_Res210 :
            Bare_Array_Literal
               := No_Bare_Lkt_Node;
      Or_Pos29 :
            Token_Index
               := No_Token_Index;
      Or_Res29 :
            Bare_Expr
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Term_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res29 := M.Instance;
      return Or_Res29;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res29;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'term') at parser.lkt:331:13>

Or_Pos29 := No_Token_Index;
Or_Res29 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareParenExpr>) (root of 'term') at parser.lkt:332:11>

Transform_Diags116 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'term') at ???>

Row_Pos133 := Pos;



--  BEGIN <Token(<WithText LPar>, ) (root of 'term') at parser.lkt:332:21>

Token_Res208 := Row_Pos133;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res208));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos208 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos133 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos133,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos208 := Row_Pos133 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'term') at parser.lkt:332:21>




if Token_Pos208 /= No_Token_Index then

   Row_Pos133 := Token_Pos208;

else
   Row_Pos133 := No_Token_Index;
   goto Exit_Row133_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:332:25>

Defer_Res201 :=
   Expr_Or_Parse1 (Parser, Row_Pos133);
Defer_Pos201 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:332:25>




if Defer_Pos201 /= No_Token_Index then

   Row_Pos133 := Defer_Pos201;

else
   Row_Pos133 := No_Token_Index;
   goto Exit_Row133_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'term') at parser.lkt:332:30>

Token_Res209 := Row_Pos133;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res209));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos209 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos133 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos133,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos209 := Row_Pos133 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'term') at parser.lkt:332:30>




if Token_Pos209 /= No_Token_Index then

   Row_Pos133 := Token_Pos209;

else
   Row_Pos133 := No_Token_Index;
   goto Exit_Row133_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row133_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'term') at ???>



if Row_Pos133 /= No_Token_Index then

   Transform_Res116 := Allocate_Paren_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res116,
      Kind => Lkt_Paren_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos133 = Pos
                            then No_Token_Index
                            else Row_Pos133 - 1));

      
      Initialize_Fields_For_Paren_Expr
        (Self => Transform_Res116,
         Paren_Expr_F_Expr => Defer_Res201);

         if Defer_Res201 /= null and then Is_Incomplete (Defer_Res201) then
            Transform_Res116.Last_Attempted_Child := 0;
         elsif Defer_Res201 /= null and then not Is_Ghost (Defer_Res201) then
            Transform_Res116.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos133 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags116);
end if;

--  END <Transform(<CompiledType BareParenExpr>) (root of 'term') at parser.lkt:332:11>

    if Row_Pos133 /= No_Token_Index then
        Or_Pos29 := Row_Pos133;
        Or_Res29 := Transform_Res116;
        goto Exit_Or29;
    end if;
    
--  BEGIN <Defer (for 'match_expr') at parser.lkt:333:11>

Defer_Res202 :=
   Match_Expr_Transform_Parse2 (Parser, Pos);
Defer_Pos202 := Parser.Current_Pos;

--  END <Defer (for 'match_expr') at parser.lkt:333:11>

    if Defer_Pos202 /= No_Token_Index then
        Or_Pos29 := Defer_Pos202;
        Or_Res29 := Defer_Res202;
        goto Exit_Or29;
    end if;
    
--  BEGIN <Defer (for 'null_lit') at parser.lkt:334:11>

Defer_Res203 :=
   Null_Lit_Transform_Parse0 (Parser, Pos);
Defer_Pos203 := Parser.Current_Pos;

--  END <Defer (for 'null_lit') at parser.lkt:334:11>

    if Defer_Pos203 /= No_Token_Index then
        Or_Pos29 := Defer_Pos203;
        Or_Res29 := Defer_Res203;
        goto Exit_Or29;
    end if;
    
--  BEGIN <Defer (for 'ref_id') at parser.lkt:335:11>

Defer_Res204 :=
   Ref_Id_Transform_Parse0 (Parser, Pos);
Defer_Pos204 := Parser.Current_Pos;

--  END <Defer (for 'ref_id') at parser.lkt:335:11>

    if Defer_Pos204 /= No_Token_Index then
        Or_Pos29 := Defer_Pos204;
        Or_Res29 := Defer_Res204;
        goto Exit_Or29;
    end if;
    
--  BEGIN <Defer (for 'block') at parser.lkt:336:11>

Defer_Res205 :=
   Block_Transform_Parse0 (Parser, Pos);
Defer_Pos205 := Parser.Current_Pos;

--  END <Defer (for 'block') at parser.lkt:336:11>

    if Defer_Pos205 /= No_Token_Index then
        Or_Pos29 := Defer_Pos205;
        Or_Res29 := Defer_Res205;
        goto Exit_Or29;
    end if;
    
--  BEGIN <Defer (for 'num_lit') at parser.lkt:337:11>

Defer_Res206 :=
   Num_Lit_Transform_Parse0 (Parser, Pos);
Defer_Pos206 := Parser.Current_Pos;

--  END <Defer (for 'num_lit') at parser.lkt:337:11>

    if Defer_Pos206 /= No_Token_Index then
        Or_Pos29 := Defer_Pos206;
        Or_Res29 := Defer_Res206;
        goto Exit_Or29;
    end if;
    
--  BEGIN <Defer (for 'big_num_lit') at parser.lkt:338:11>

Defer_Res207 :=
   Big_Num_Lit_Transform_Parse0 (Parser, Pos);
Defer_Pos207 := Parser.Current_Pos;

--  END <Defer (for 'big_num_lit') at parser.lkt:338:11>

    if Defer_Pos207 /= No_Token_Index then
        Or_Pos29 := Defer_Pos207;
        Or_Res29 := Defer_Res207;
        goto Exit_Or29;
    end if;
    
--  BEGIN <Defer (for 'string_lit') at parser.lkt:339:11>

Defer_Res208 :=
   String_Lit_Or_Parse0 (Parser, Pos);
Defer_Pos208 := Parser.Current_Pos;

--  END <Defer (for 'string_lit') at parser.lkt:339:11>

    if Defer_Pos208 /= No_Token_Index then
        Or_Pos29 := Defer_Pos208;
        Or_Res29 := Defer_Res208;
        goto Exit_Or29;
    end if;
    
--  BEGIN <Defer (for 'char_lit') at parser.lkt:340:11>

Defer_Res209 :=
   Char_Lit_Transform_Parse0 (Parser, Pos);
Defer_Pos209 := Parser.Current_Pos;

--  END <Defer (for 'char_lit') at parser.lkt:340:11>

    if Defer_Pos209 /= No_Token_Index then
        Or_Pos29 := Defer_Pos209;
        Or_Res29 := Defer_Res209;
        goto Exit_Or29;
    end if;
    
--  BEGIN <Defer (for 'array_literal') at parser.lkt:341:11>

Defer_Res210 :=
   Array_Literal_Transform_Parse0 (Parser, Pos);
Defer_Pos210 := Parser.Current_Pos;

--  END <Defer (for 'array_literal') at parser.lkt:341:11>

    if Defer_Pos210 /= No_Token_Index then
        Or_Pos29 := Defer_Pos210;
        Or_Res29 := Defer_Res210;
        goto Exit_Or29;
    end if;
<<Exit_Or29>>

--  END <Or (root of 'term') at parser.lkt:331:13>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Term_Or_Parse0_Memo,
      Or_Pos29 /= No_Token_Index,
      Or_Res29,
      Pos,
      Or_Pos29);


   Parser.Current_Pos := Or_Pos29;

   return Or_Res29;
end Term_Or_Parse0;

   


function Token_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Token_Lit
is
   use Bare_Token_Lit_Memos;

      Row_Pos134 :
            Token_Index
               := No_Token_Index;
      Token_Pos210 :
            Token_Index
               := No_Token_Index;
      Token_Res210 :
            Token_Index
               := No_Token_Index;
      Transform_Res117 :
            Bare_Token_Lit
               := No_Bare_Lkt_Node;
      Transform_Diags117 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Token_Literal_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res117 := M.Instance;
      return Transform_Res117;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res117;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareTokenLit>) (root of 'token_literal') at parser.lkt:88:22>

Transform_Diags117 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'token_literal') at ???>

Row_Pos134 := Pos;



--  BEGIN <Token(<WithText String>, ) (root of 'token_literal') at parser.lkt:88:31>

Token_Res210 := Row_Pos134;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res210));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_String)
   then
       Token_Pos210 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos134 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos134,
             Expected_Token_Id => Lkt_String,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos210 := Row_Pos134 + 1;
   end if;
end;

--  END <Token(<WithText String>, ) (root of 'token_literal') at parser.lkt:88:31>




if Token_Pos210 /= No_Token_Index then

   Row_Pos134 := Token_Pos210;

else
   Row_Pos134 := No_Token_Index;
   goto Exit_Row134_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row134_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'token_literal') at ???>



if Row_Pos134 /= No_Token_Index then

   Transform_Res117 := Allocate_Token_Lit (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res117,
      Kind => Lkt_Token_Lit,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos134 = Pos
                            then No_Token_Index
                            else Row_Pos134 - 1));

      
      Initialize_Fields_For_Token_Lit
        (Self => Transform_Res117);



elsif Row_Pos134 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags117);
end if;

--  END <Transform(<CompiledType BareTokenLit>) (root of 'token_literal') at parser.lkt:88:22>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Token_Literal_Transform_Parse0_Memo,
      Row_Pos134 /= No_Token_Index,
      Transform_Res117,
      Pos,
      Row_Pos134);


   Parser.Current_Pos := Row_Pos134;

   return Transform_Res117;
end Token_Literal_Transform_Parse0;

   


function Token_No_Case_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Token_No_Case_Lit
is
   use Bare_Token_No_Case_Lit_Memos;

      Row_Pos135 :
            Token_Index
               := No_Token_Index;
      Token_Pos211 :
            Token_Index
               := No_Token_Index;
      Token_Res211 :
            Token_Index
               := No_Token_Index;
      Token_Pos212 :
            Token_Index
               := No_Token_Index;
      Token_Res212 :
            Token_Index
               := No_Token_Index;
      Defer_Pos211 :
            Token_Index
               := No_Token_Index;
      Defer_Res211 :
            Bare_Token_Lit
               := No_Bare_Lkt_Node;
      Token_Pos213 :
            Token_Index
               := No_Token_Index;
      Token_Res213 :
            Token_Index
               := No_Token_Index;
      Transform_Res118 :
            Bare_Token_No_Case_Lit
               := No_Bare_Lkt_Node;
      Transform_Diags118 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Token_No_Case_Literal_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res118 := M.Instance;
      return Transform_Res118;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res118;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareTokenNoCaseLit>) (root of 'token_no_case_literal') at parser.lkt:89:30>

Transform_Diags118 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'token_no_case_literal') at ???>

Row_Pos135 := Pos;



--  BEGIN <Token(<WithSymbol Identifier>, no_case) (root of 'token_no_case_literal') at parser.lkt:90:9>

Token_Res211 := Row_Pos135;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res211));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_No_Case)
   then
       Token_Pos211 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos135 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos135,
             Expected_Token_Id => Lkt_Identifier,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos211 := Row_Pos135 + 1;
   end if;
end;

--  END <Token(<WithSymbol Identifier>, no_case) (root of 'token_no_case_literal') at parser.lkt:90:9>




if Token_Pos211 /= No_Token_Index then

   Row_Pos135 := Token_Pos211;

else
   Row_Pos135 := No_Token_Index;
   goto Exit_Row135_0;

end if;


--  BEGIN <Token(<WithText LPar>, ) (root of 'token_no_case_literal') at parser.lkt:90:32>

Token_Res212 := Row_Pos135;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res212));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos212 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos135 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos135,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos212 := Row_Pos135 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'token_no_case_literal') at parser.lkt:90:32>




if Token_Pos212 /= No_Token_Index then

   Row_Pos135 := Token_Pos212;

else
   Row_Pos135 := No_Token_Index;
   goto Exit_Row135_0;

end if;


--  BEGIN <Defer (for 'token_literal') at parser.lkt:90:36>

Defer_Res211 :=
   Token_Literal_Transform_Parse0 (Parser, Row_Pos135);
Defer_Pos211 := Parser.Current_Pos;

--  END <Defer (for 'token_literal') at parser.lkt:90:36>




if Defer_Pos211 /= No_Token_Index then

   Row_Pos135 := Defer_Pos211;

else
   Row_Pos135 := No_Token_Index;
   goto Exit_Row135_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'token_no_case_literal') at parser.lkt:90:50>

Token_Res213 := Row_Pos135;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res213));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos213 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos135 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos135,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos213 := Row_Pos135 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'token_no_case_literal') at parser.lkt:90:50>




if Token_Pos213 /= No_Token_Index then

   Row_Pos135 := Token_Pos213;

else
   Row_Pos135 := No_Token_Index;
   goto Exit_Row135_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row135_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'token_no_case_literal') at ???>



if Row_Pos135 /= No_Token_Index then

   Transform_Res118 := Allocate_Token_No_Case_Lit (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res118,
      Kind => Lkt_Token_No_Case_Lit,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos135 = Pos
                            then No_Token_Index
                            else Row_Pos135 - 1));

      
      Initialize_Fields_For_Token_No_Case_Lit
        (Self => Transform_Res118,
         Token_No_Case_Lit_F_Lit => Defer_Res211);

         if Defer_Res211 /= null and then Is_Incomplete (Defer_Res211) then
            Transform_Res118.Last_Attempted_Child := 0;
         elsif Defer_Res211 /= null and then not Is_Ghost (Defer_Res211) then
            Transform_Res118.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos135 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags118);
end if;

--  END <Transform(<CompiledType BareTokenNoCaseLit>) (root of 'token_no_case_literal') at parser.lkt:89:30>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Token_No_Case_Literal_Transform_Parse0_Memo,
      Row_Pos135 /= No_Token_Index,
      Transform_Res118,
      Pos,
      Row_Pos135);


   Parser.Current_Pos := Row_Pos135;

   return Transform_Res118;
end Token_No_Case_Literal_Transform_Parse0;

   


function Token_Pattern_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr
is
   use Bare_Grammar_Expr_Memos;

      Row_Pos136 :
            Token_Index
               := No_Token_Index;
      Defer_Pos212 :
            Token_Index
               := No_Token_Index;
      Defer_Res212 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;
      Token_Pos214 :
            Token_Index
               := No_Token_Index;
      Token_Res214 :
            Token_Index
               := No_Token_Index;
      Defer_Pos213 :
            Token_Index
               := No_Token_Index;
      Defer_Res213 :
            Bare_Token_Pattern_Lit
               := No_Bare_Lkt_Node;
      Transform_Res119 :
            Bare_Token_Pattern_Concat
               := No_Bare_Lkt_Node;
      Transform_Diags119 :
            Ada.Containers.Count_Type;
      Defer_Pos214 :
            Token_Index
               := No_Token_Index;
      Defer_Res214 :
            Bare_Token_Pattern_Lit
               := No_Bare_Lkt_Node;
      Or_Pos30 :
            Token_Index
               := No_Token_Index;
      Or_Res30 :
            Bare_Grammar_Expr
               := No_Bare_Lkt_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Grammar_Expr := No_Bare_Lkt_Node;

   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Token_Pattern_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res30 := M.Instance;
      return Or_Res30;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res30;
   end if;

       Set (PP.Token_Pattern_Or_Parse0_Memo, False, Or_Res30, Pos, Mem_Pos);

       <<Try_Again>>



   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'token_pattern') at parser.lkt:92:22>

Or_Pos30 := No_Token_Index;
Or_Res30 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareTokenPatternConcat>) (root of 'token_pattern') at parser.lkt:93:11>

Transform_Diags119 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'token_pattern') at ???>

Row_Pos136 := Pos;



--  BEGIN <Defer (for 'token_pattern') at parser.lkt:93:30>

Defer_Res212 :=
   Token_Pattern_Or_Parse0 (Parser, Row_Pos136);
Defer_Pos212 := Parser.Current_Pos;

--  END <Defer (for 'token_pattern') at parser.lkt:93:30>




if Defer_Pos212 /= No_Token_Index then

   Row_Pos136 := Defer_Pos212;

else
   Row_Pos136 := No_Token_Index;
   goto Exit_Row136_0;

end if;


--  BEGIN <Token(<WithText Amp>, ) (root of 'token_pattern') at parser.lkt:93:44>

Token_Res214 := Row_Pos136;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res214));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Amp)
   then
       Token_Pos214 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos136 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos136,
             Expected_Token_Id => Lkt_Amp,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos214 := Row_Pos136 + 1;
   end if;
end;

--  END <Token(<WithText Amp>, ) (root of 'token_pattern') at parser.lkt:93:44>




if Token_Pos214 /= No_Token_Index then

   Row_Pos136 := Token_Pos214;

else
   Row_Pos136 := No_Token_Index;
   goto Exit_Row136_0;

end if;


--  BEGIN <Defer (for 'token_pattern_literal') at parser.lkt:93:48>

Defer_Res213 :=
   Token_Pattern_Literal_Transform_Parse0 (Parser, Row_Pos136);
Defer_Pos213 := Parser.Current_Pos;

--  END <Defer (for 'token_pattern_literal') at parser.lkt:93:48>




if Defer_Pos213 /= No_Token_Index then

   Row_Pos136 := Defer_Pos213;

else
   Row_Pos136 := No_Token_Index;
   goto Exit_Row136_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row136_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'token_pattern') at ???>



if Row_Pos136 /= No_Token_Index then

   Transform_Res119 := Allocate_Token_Pattern_Concat (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res119,
      Kind => Lkt_Token_Pattern_Concat,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos136 = Pos
                            then No_Token_Index
                            else Row_Pos136 - 1));

      
      Initialize_Fields_For_Token_Pattern_Concat
        (Self => Transform_Res119,
         Token_Pattern_Concat_F_Left => Defer_Res212,
         Token_Pattern_Concat_F_Right => Defer_Res213);

         if Defer_Res212 /= null and then Is_Incomplete (Defer_Res212) then
            Transform_Res119.Last_Attempted_Child := 0;
         elsif Defer_Res212 /= null and then not Is_Ghost (Defer_Res212) then
            Transform_Res119.Last_Attempted_Child := -1;
         end if;
         if Defer_Res213 /= null and then Is_Incomplete (Defer_Res213) then
            Transform_Res119.Last_Attempted_Child := 0;
         elsif Defer_Res213 /= null and then not Is_Ghost (Defer_Res213) then
            Transform_Res119.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos136 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags119);
end if;

--  END <Transform(<CompiledType BareTokenPatternConcat>) (root of 'token_pattern') at parser.lkt:93:11>

    if Row_Pos136 /= No_Token_Index then
        Or_Pos30 := Row_Pos136;
        Or_Res30 := Transform_Res119;
        goto Exit_Or30;
    end if;
    
--  BEGIN <Defer (for 'token_pattern_literal') at parser.lkt:94:11>

Defer_Res214 :=
   Token_Pattern_Literal_Transform_Parse0 (Parser, Pos);
Defer_Pos214 := Parser.Current_Pos;

--  END <Defer (for 'token_pattern_literal') at parser.lkt:94:11>

    if Defer_Pos214 /= No_Token_Index then
        Or_Pos30 := Defer_Pos214;
        Or_Res30 := Defer_Res214;
        goto Exit_Or30;
    end if;
<<Exit_Or30>>

--  END <Or (root of 'token_pattern') at parser.lkt:92:22>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos30 > Mem_Pos then
         Mem_Pos := Or_Pos30;
         Mem_Res := Or_Res30;
         Set
           (PP.Token_Pattern_Or_Parse0_Memo,
            Or_Pos30 /= No_Token_Index,
            Or_Res30,
            Pos,
            Or_Pos30);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res30 := Mem_Res;
         Or_Pos30 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (PP.Token_Pattern_Or_Parse0_Memo,
      Or_Pos30 /= No_Token_Index,
      Or_Res30,
      Pos,
      Or_Pos30);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos30;

   return Or_Res30;
end Token_Pattern_Or_Parse0;

   


function Token_Pattern_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Token_Pattern_Lit
is
   use Bare_Token_Pattern_Lit_Memos;

      Row_Pos137 :
            Token_Index
               := No_Token_Index;
      Token_Pos215 :
            Token_Index
               := No_Token_Index;
      Token_Res215 :
            Token_Index
               := No_Token_Index;
      Transform_Res120 :
            Bare_Token_Pattern_Lit
               := No_Bare_Lkt_Node;
      Transform_Diags120 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Token_Pattern_Literal_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res120 := M.Instance;
      return Transform_Res120;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res120;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareTokenPatternLit>) (root of 'token_pattern_literal') at parser.lkt:96:30>

Transform_Diags120 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'token_pattern_literal') at ???>

Row_Pos137 := Pos;



--  BEGIN <Token(<WithText PString>, ) (root of 'token_pattern_literal') at parser.lkt:96:46>

Token_Res215 := Row_Pos137;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res215));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_P_String)
   then
       Token_Pos215 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos137 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos137,
             Expected_Token_Id => Lkt_P_String,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos215 := Row_Pos137 + 1;
   end if;
end;

--  END <Token(<WithText PString>, ) (root of 'token_pattern_literal') at parser.lkt:96:46>




if Token_Pos215 /= No_Token_Index then

   Row_Pos137 := Token_Pos215;

else
   Row_Pos137 := No_Token_Index;
   goto Exit_Row137_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row137_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'token_pattern_literal') at ???>



if Row_Pos137 /= No_Token_Index then

   Transform_Res120 := Allocate_Token_Pattern_Lit (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res120,
      Kind => Lkt_Token_Pattern_Lit,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos137 = Pos
                            then No_Token_Index
                            else Row_Pos137 - 1));

      
      Initialize_Fields_For_Token_Pattern_Lit
        (Self => Transform_Res120);



elsif Row_Pos137 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags120);
end if;

--  END <Transform(<CompiledType BareTokenPatternLit>) (root of 'token_pattern_literal') at parser.lkt:96:30>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Token_Pattern_Literal_Transform_Parse0_Memo,
      Row_Pos137 /= No_Token_Index,
      Transform_Res120,
      Pos,
      Row_Pos137);


   Parser.Current_Pos := Row_Pos137;

   return Transform_Res120;
end Token_Pattern_Literal_Transform_Parse0;

   


function Try_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Try_Expr
is
   use Bare_Try_Expr_Memos;

      Row_Pos138 :
            Token_Index
               := No_Token_Index;
      Token_Pos216 :
            Token_Index
               := No_Token_Index;
      Token_Res216 :
            Token_Index
               := No_Token_Index;
      Defer_Pos215 :
            Token_Index
               := No_Token_Index;
      Defer_Res215 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Row_Pos139 :
            Token_Index
               := No_Token_Index;
      Token_Pos217 :
            Token_Index
               := No_Token_Index;
      Token_Res217 :
            Token_Index
               := No_Token_Index;
      Defer_Pos216 :
            Token_Index
               := No_Token_Index;
      Defer_Res216 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res121 :
            Bare_Try_Expr
               := No_Bare_Lkt_Node;
      Transform_Diags121 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Try_Expr_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res121 := M.Instance;
      return Transform_Res121;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res121;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareTryExpr>) (root of 'try_expr') at parser.lkt:311:17>

Transform_Diags121 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'try_expr') at ???>

Row_Pos138 := Pos;



--  BEGIN <Token(<WithText TryKw>, ) (root of 'try_expr') at parser.lkt:311:25>

Token_Res216 := Row_Pos138;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res216));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Try_Kw)
   then
       Token_Pos216 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos138 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos138,
             Expected_Token_Id => Lkt_Try_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos216 := Row_Pos138 + 1;
   end if;
end;

--  END <Token(<WithText TryKw>, ) (root of 'try_expr') at parser.lkt:311:25>




if Token_Pos216 /= No_Token_Index then

   Row_Pos138 := Token_Pos216;

else
   Row_Pos138 := No_Token_Index;
   goto Exit_Row138_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:311:31>

Defer_Res215 :=
   Expr_Or_Parse1 (Parser, Row_Pos138);
Defer_Pos215 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:311:31>




if Defer_Pos215 /= No_Token_Index then

   Row_Pos138 := Defer_Pos215;

else
   Row_Pos138 := No_Token_Index;
   goto Exit_Row138_0;

end if;


--  BEGIN <Opt (root of 'try_expr') at parser.lkt:311:36>












--  BEGIN <_Extract (root of 'try_expr') at parser.lkt:311:37>

--  BEGIN <_Row (root of 'try_expr') at ???>

Row_Pos139 := Row_Pos138;



--  BEGIN <Token(<WithText ElseKw>, ) (root of 'try_expr') at parser.lkt:311:42>

Token_Res217 := Row_Pos139;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res217));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Else_Kw)
   then
       Token_Pos217 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos139 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos139,
             Expected_Token_Id => Lkt_Else_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos217 := Row_Pos139 + 1;
   end if;
end;

--  END <Token(<WithText ElseKw>, ) (root of 'try_expr') at parser.lkt:311:42>




if Token_Pos217 /= No_Token_Index then

   Row_Pos139 := Token_Pos217;

else
   Row_Pos139 := No_Token_Index;
   goto Exit_Row139_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:311:49>

Defer_Res216 :=
   Expr_Or_Parse1 (Parser, Row_Pos139);
Defer_Pos216 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:311:49>




if Defer_Pos216 /= No_Token_Index then

   Row_Pos139 := Defer_Pos216;

else
   Row_Pos139 := No_Token_Index;
   goto Exit_Row139_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row139_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'try_expr') at ???>

--  END <_Extract (root of 'try_expr') at parser.lkt:311:37>


if Row_Pos139 = No_Token_Index then

         
   Defer_Res216 := No_Bare_Lkt_Node;



       
   Row_Pos139 := Row_Pos138;



end if;

--  END <Opt (root of 'try_expr') at parser.lkt:311:36>




if Row_Pos139 /= No_Token_Index then

   Row_Pos138 := Row_Pos139;

else
   Row_Pos138 := No_Token_Index;
   goto Exit_Row138_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row138_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'try_expr') at ???>



if Row_Pos138 /= No_Token_Index then

   Transform_Res121 := Allocate_Try_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res121,
      Kind => Lkt_Try_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos138 = Pos
                            then No_Token_Index
                            else Row_Pos138 - 1));

      
      Initialize_Fields_For_Try_Expr
        (Self => Transform_Res121,
         Try_Expr_F_Try_Expr => Defer_Res215,
         Try_Expr_F_Or_Expr => Defer_Res216);

         if Defer_Res215 /= null and then Is_Incomplete (Defer_Res215) then
            Transform_Res121.Last_Attempted_Child := 0;
         elsif Defer_Res215 /= null and then not Is_Ghost (Defer_Res215) then
            Transform_Res121.Last_Attempted_Child := -1;
         end if;
         if Defer_Res216 /= null and then Is_Incomplete (Defer_Res216) then
            Transform_Res121.Last_Attempted_Child := 0;
         elsif Defer_Res216 /= null and then not Is_Ghost (Defer_Res216) then
            Transform_Res121.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos138 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags121);
end if;

--  END <Transform(<CompiledType BareTryExpr>) (root of 'try_expr') at parser.lkt:311:17>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Try_Expr_Transform_Parse0_Memo,
      Row_Pos138 /= No_Token_Index,
      Transform_Res121,
      Pos,
      Row_Pos138);


   Parser.Current_Pos := Row_Pos138;

   return Transform_Res121;
end Try_Expr_Transform_Parse0;

   


function Type_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Named_Type_Decl
is
   use Bare_Named_Type_Decl_Memos;

      Row_Pos140 :
            Token_Index
               := No_Token_Index;
      Token_Pos218 :
            Token_Index
               := No_Token_Index;
      Token_Res218 :
            Token_Index
               := No_Token_Index;
      Defer_Pos217 :
            Token_Index
               := No_Token_Index;
      Defer_Res217 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Row_Pos141 :
            Token_Index
               := No_Token_Index;
      Token_Pos219 :
            Token_Index
               := No_Token_Index;
      Token_Res219 :
            Token_Index
               := No_Token_Index;
      Defer_Pos218 :
            Token_Index
               := No_Token_Index;
      Defer_Res218 :
            Bare_Type_Ref_List
               := No_Bare_Lkt_Node;
      Token_Pos220 :
            Token_Index
               := No_Token_Index;
      Token_Res220 :
            Token_Index
               := No_Token_Index;
      Defer_Pos219 :
            Token_Index
               := No_Token_Index;
      Defer_Res219 :
            Bare_Decl_Block
               := No_Bare_Lkt_Node;
      Token_Pos221 :
            Token_Index
               := No_Token_Index;
      Token_Res221 :
            Token_Index
               := No_Token_Index;
      Transform_Res122 :
            Bare_Struct_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags122 :
            Ada.Containers.Count_Type;
      Row_Pos142 :
            Token_Index
               := No_Token_Index;
      Token_Pos222 :
            Token_Index
               := No_Token_Index;
      Token_Res222 :
            Token_Index
               := No_Token_Index;
      Token_Pos223 :
            Token_Index
               := No_Token_Index;
      Token_Res223 :
            Token_Index
               := No_Token_Index;
      Defer_Pos220 :
            Token_Index
               := No_Token_Index;
      Defer_Res220 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Row_Pos143 :
            Token_Index
               := No_Token_Index;
      Token_Pos224 :
            Token_Index
               := No_Token_Index;
      Token_Res224 :
            Token_Index
               := No_Token_Index;
      Defer_Pos221 :
            Token_Index
               := No_Token_Index;
      Defer_Res221 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Row_Pos144 :
            Token_Index
               := No_Token_Index;
      Token_Pos225 :
            Token_Index
               := No_Token_Index;
      Token_Res225 :
            Token_Index
               := No_Token_Index;
      Defer_Pos222 :
            Token_Index
               := No_Token_Index;
      Defer_Res222 :
            Bare_Type_Ref_List
               := No_Bare_Lkt_Node;
      Token_Pos226 :
            Token_Index
               := No_Token_Index;
      Token_Res226 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos31 :
            Token_Index
               := No_Token_Index;
      Tmp_List31 :
            Free_Parse_List;
      Row_Pos145 :
            Token_Index
               := No_Token_Index;
      Token_Pos227 :
            Token_Index
               := No_Token_Index;
      Token_Res227 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos32 :
            Token_Index
               := No_Token_Index;
      Tmp_List32 :
            Free_Parse_List;
      Row_Pos146 :
            Token_Index
               := No_Token_Index;
      Defer_Pos223 :
            Token_Index
               := No_Token_Index;
      Defer_Res223 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Transform_Res123 :
            Bare_Enum_Class_Alt_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags123 :
            Ada.Containers.Count_Type;
      Token_Pos228 :
            Token_Index
               := No_Token_Index;
      Token_Res228 :
            Token_Index
               := No_Token_Index;
      List_Pos31 :
            Token_Index
               := No_Token_Index;
      List_Res31 :
            Bare_Enum_Class_Alt_Decl_List
               := No_Bare_Lkt_Node;
      Transform_Res124 :
            Bare_Enum_Class_Case
               := No_Bare_Lkt_Node;
      Transform_Diags124 :
            Ada.Containers.Count_Type;
      List_Pos32 :
            Token_Index
               := No_Token_Index;
      List_Res32 :
            Bare_Enum_Class_Case_List
               := No_Bare_Lkt_Node;
      Defer_Pos224 :
            Token_Index
               := No_Token_Index;
      Defer_Res224 :
            Bare_Decl_Block
               := No_Bare_Lkt_Node;
      Token_Pos229 :
            Token_Index
               := No_Token_Index;
      Token_Res229 :
            Token_Index
               := No_Token_Index;
      Transform_Res125 :
            Bare_Enum_Class_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags125 :
            Ada.Containers.Count_Type;
      Row_Pos147 :
            Token_Index
               := No_Token_Index;
      Token_Pos230 :
            Token_Index
               := No_Token_Index;
      Token_Res230 :
            Token_Index
               := No_Token_Index;
      Defer_Pos225 :
            Token_Index
               := No_Token_Index;
      Defer_Res225 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Row_Pos148 :
            Token_Index
               := No_Token_Index;
      Token_Pos231 :
            Token_Index
               := No_Token_Index;
      Token_Res231 :
            Token_Index
               := No_Token_Index;
      Defer_Pos226 :
            Token_Index
               := No_Token_Index;
      Defer_Res226 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Row_Pos149 :
            Token_Index
               := No_Token_Index;
      Token_Pos232 :
            Token_Index
               := No_Token_Index;
      Token_Res232 :
            Token_Index
               := No_Token_Index;
      Defer_Pos227 :
            Token_Index
               := No_Token_Index;
      Defer_Res227 :
            Bare_Type_Ref_List
               := No_Bare_Lkt_Node;
      Token_Pos233 :
            Token_Index
               := No_Token_Index;
      Token_Res233 :
            Token_Index
               := No_Token_Index;
      Defer_Pos228 :
            Token_Index
               := No_Token_Index;
      Defer_Res228 :
            Bare_Decl_Block
               := No_Bare_Lkt_Node;
      Token_Pos234 :
            Token_Index
               := No_Token_Index;
      Token_Res234 :
            Token_Index
               := No_Token_Index;
      Transform_Res126 :
            Bare_Class_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags126 :
            Ada.Containers.Count_Type;
      Row_Pos150 :
            Token_Index
               := No_Token_Index;
      Token_Pos235 :
            Token_Index
               := No_Token_Index;
      Token_Res235 :
            Token_Index
               := No_Token_Index;
      Defer_Pos229 :
            Token_Index
               := No_Token_Index;
      Defer_Res229 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Row_Pos151 :
            Token_Index
               := No_Token_Index;
      Token_Pos236 :
            Token_Index
               := No_Token_Index;
      Token_Res236 :
            Token_Index
               := No_Token_Index;
      Defer_Pos230 :
            Token_Index
               := No_Token_Index;
      Defer_Res230 :
            Bare_Type_Ref_List
               := No_Bare_Lkt_Node;
      Token_Pos237 :
            Token_Index
               := No_Token_Index;
      Token_Res237 :
            Token_Index
               := No_Token_Index;
      Token_Pos238 :
            Token_Index
               := No_Token_Index;
      Token_Res238 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos33 :
            Token_Index
               := No_Token_Index;
      Tmp_List33 :
            Free_Parse_List;
      Defer_Pos231 :
            Token_Index
               := No_Token_Index;
      Defer_Res231 :
            Bare_Enum_Lit_Decl
               := No_Bare_Lkt_Node;
      Token_Pos239 :
            Token_Index
               := No_Token_Index;
      Token_Res239 :
            Token_Index
               := No_Token_Index;
      List_Pos33 :
            Token_Index
               := No_Token_Index;
      List_Res33 :
            Bare_Enum_Lit_Decl_List
               := No_Bare_Lkt_Node;
      Defer_Pos232 :
            Token_Index
               := No_Token_Index;
      Defer_Res232 :
            Bare_Decl_Block
               := No_Bare_Lkt_Node;
      Token_Pos240 :
            Token_Index
               := No_Token_Index;
      Token_Res240 :
            Token_Index
               := No_Token_Index;
      Transform_Res127 :
            Bare_Enum_Type_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags127 :
            Ada.Containers.Count_Type;
      Row_Pos152 :
            Token_Index
               := No_Token_Index;
      Token_Pos241 :
            Token_Index
               := No_Token_Index;
      Token_Res241 :
            Token_Index
               := No_Token_Index;
      Defer_Pos233 :
            Token_Index
               := No_Token_Index;
      Defer_Res233 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Token_Pos242 :
            Token_Index
               := No_Token_Index;
      Token_Res242 :
            Token_Index
               := No_Token_Index;
      Defer_Pos234 :
            Token_Index
               := No_Token_Index;
      Defer_Res234 :
            Bare_Decl_Block
               := No_Bare_Lkt_Node;
      Token_Pos243 :
            Token_Index
               := No_Token_Index;
      Token_Res243 :
            Token_Index
               := No_Token_Index;
      Transform_Res128 :
            Bare_Trait_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags128 :
            Ada.Containers.Count_Type;
      Or_Pos31 :
            Token_Index
               := No_Token_Index;
      Or_Res31 :
            Bare_Named_Type_Decl
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Type_Decl_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res31 := M.Instance;
      return Or_Res31;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res31;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'type_decl') at parser.lkt:118:18>

Or_Pos31 := No_Token_Index;
Or_Res31 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareStructDecl>) (root of 'type_decl') at parser.lkt:119:11>

Transform_Diags122 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'type_decl') at ???>

Row_Pos140 := Pos;



--  BEGIN <Token(<WithText StructKw>, ) (root of 'type_decl') at parser.lkt:120:13>

Token_Res218 := Row_Pos140;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res218));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Struct_Kw)
   then
       Token_Pos218 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos140 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos140,
             Expected_Token_Id => Lkt_Struct_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos218 := Row_Pos140 + 1;
   end if;
end;

--  END <Token(<WithText StructKw>, ) (root of 'type_decl') at parser.lkt:120:13>




if Token_Pos218 /= No_Token_Index then

   Row_Pos140 := Token_Pos218;

else
   Row_Pos140 := No_Token_Index;
   goto Exit_Row140_0;

end if;


--  BEGIN <Defer (for 'def_id') at parser.lkt:120:22>

Defer_Res217 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos140);
Defer_Pos217 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:120:22>




if Defer_Pos217 /= No_Token_Index then

   Row_Pos140 := Defer_Pos217;

else
   Row_Pos140 := No_Token_Index;
   goto Exit_Row140_0;

end if;


--  BEGIN <Opt (root of 'type_decl') at parser.lkt:120:29>












--  BEGIN <_Extract (root of 'type_decl') at parser.lkt:120:30>

--  BEGIN <_Row (root of 'type_decl') at ???>

Row_Pos141 := Row_Pos140;



--  BEGIN <Token(<WithText ImplementsKw>, ) (root of 'type_decl') at parser.lkt:120:35>

Token_Res219 := Row_Pos141;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res219));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Implements_Kw)
   then
       Token_Pos219 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos141 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos141,
             Expected_Token_Id => Lkt_Implements_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos219 := Row_Pos141 + 1;
   end if;
end;

--  END <Token(<WithText ImplementsKw>, ) (root of 'type_decl') at parser.lkt:120:35>




if Token_Pos219 /= No_Token_Index then

   Row_Pos141 := Token_Pos219;

else
   Row_Pos141 := No_Token_Index;
   goto Exit_Row141_0;

end if;


--  BEGIN <Defer (for 'type_list') at parser.lkt:120:48>

Defer_Res218 :=
   Type_List_List_Parse0 (Parser, Row_Pos141);
Defer_Pos218 := Parser.Current_Pos;

--  END <Defer (for 'type_list') at parser.lkt:120:48>




if Defer_Pos218 /= No_Token_Index then

   Row_Pos141 := Defer_Pos218;

else
   Row_Pos141 := No_Token_Index;
   goto Exit_Row141_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row141_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'type_decl') at ???>

--  END <_Extract (root of 'type_decl') at parser.lkt:120:30>


if Row_Pos141 = No_Token_Index then

         
   Defer_Res218 :=
     Allocate_Type_Ref_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res218,
      Kind              => Lkt_Type_Ref_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos140,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res218,
      Parser => Parser,
      Count  => 0);



       
   Row_Pos141 := Row_Pos140;



end if;

--  END <Opt (root of 'type_decl') at parser.lkt:120:29>




if Row_Pos141 /= No_Token_Index then

   Row_Pos140 := Row_Pos141;

else
   Row_Pos140 := No_Token_Index;
   goto Exit_Row140_0;

end if;


--  BEGIN <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:120:59>

Token_Res220 := Row_Pos140;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res220));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos220 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos140 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos140,
             Expected_Token_Id => Lkt_L_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos220 := Row_Pos140 + 1;
   end if;
end;

--  END <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:120:59>




if Token_Pos220 /= No_Token_Index then

   Row_Pos140 := Token_Pos220;

else
   Row_Pos140 := No_Token_Index;
   goto Exit_Row140_0;

end if;


--  BEGIN <Defer (for 'decl_block') at parser.lkt:120:63>

Defer_Res219 :=
   Decl_Block_List_Parse0 (Parser, Row_Pos140);
Defer_Pos219 := Parser.Current_Pos;

--  END <Defer (for 'decl_block') at parser.lkt:120:63>




if Defer_Pos219 /= No_Token_Index then

   Row_Pos140 := Defer_Pos219;

else
   Row_Pos140 := No_Token_Index;
   goto Exit_Row140_0;

end if;


--  BEGIN <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:120:74>

Token_Res221 := Row_Pos140;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res221));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos221 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos140 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos140,
             Expected_Token_Id => Lkt_R_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos221 := Row_Pos140 + 1;
   end if;
end;

--  END <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:120:74>




if Token_Pos221 /= No_Token_Index then

   Row_Pos140 := Token_Pos221;

else
   Row_Pos140 := No_Token_Index;
   goto Exit_Row140_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row140_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'type_decl') at ???>



if Row_Pos140 /= No_Token_Index then

   Transform_Res122 := Allocate_Struct_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res122,
      Kind => Lkt_Struct_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos140 = Pos
                            then No_Token_Index
                            else Row_Pos140 - 1));

      
      Initialize_Fields_For_Struct_Decl
        (Self => Transform_Res122,
         Struct_Decl_F_Syn_Name => Defer_Res217,
         Struct_Decl_F_Traits => Defer_Res218,
         Struct_Decl_F_Decls => Defer_Res219);

         if Defer_Res217 /= null and then Is_Incomplete (Defer_Res217) then
            Transform_Res122.Last_Attempted_Child := 0;
         elsif Defer_Res217 /= null and then not Is_Ghost (Defer_Res217) then
            Transform_Res122.Last_Attempted_Child := -1;
         end if;
         if Defer_Res218 /= null and then Is_Incomplete (Defer_Res218) then
            Transform_Res122.Last_Attempted_Child := 0;
         elsif Defer_Res218 /= null and then not Is_Ghost (Defer_Res218) then
            Transform_Res122.Last_Attempted_Child := -1;
         end if;
         if Defer_Res219 /= null and then Is_Incomplete (Defer_Res219) then
            Transform_Res122.Last_Attempted_Child := 0;
         elsif Defer_Res219 /= null and then not Is_Ghost (Defer_Res219) then
            Transform_Res122.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos140 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags122);
end if;

--  END <Transform(<CompiledType BareStructDecl>) (root of 'type_decl') at parser.lkt:119:11>

    if Row_Pos140 /= No_Token_Index then
        Or_Pos31 := Row_Pos140;
        Or_Res31 := Transform_Res122;
        goto Exit_Or31;
    end if;
    
--  BEGIN <Transform(<CompiledType BareEnumClassDecl>) (root of 'type_decl') at parser.lkt:122:11>

Transform_Diags125 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'type_decl') at ???>

Row_Pos142 := Pos;



--  BEGIN <Token(<WithText EnumKw>, ) (root of 'type_decl') at parser.lkt:123:13>

Token_Res222 := Row_Pos142;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res222));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Enum_Kw)
   then
       Token_Pos222 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos142 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos142,
             Expected_Token_Id => Lkt_Enum_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos222 := Row_Pos142 + 1;
   end if;
end;

--  END <Token(<WithText EnumKw>, ) (root of 'type_decl') at parser.lkt:123:13>




if Token_Pos222 /= No_Token_Index then

   Row_Pos142 := Token_Pos222;

else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;

end if;


--  BEGIN <Token(<WithText ClassKw>, ) (root of 'type_decl') at parser.lkt:124:13>

Token_Res223 := Row_Pos142;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res223));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Class_Kw)
   then
       Token_Pos223 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos142 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos142,
             Expected_Token_Id => Lkt_Class_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos223 := Row_Pos142 + 1;
   end if;
end;

--  END <Token(<WithText ClassKw>, ) (root of 'type_decl') at parser.lkt:124:13>




if Token_Pos223 /= No_Token_Index then

   Row_Pos142 := Token_Pos223;

else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;

end if;


--  BEGIN <Defer (for 'def_id') at parser.lkt:125:13>

Defer_Res220 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos142);
Defer_Pos220 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:125:13>




if Defer_Pos220 /= No_Token_Index then

   Row_Pos142 := Defer_Pos220;

else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;

end if;


--  BEGIN <Opt (root of 'type_decl') at parser.lkt:126:13>












--  BEGIN <_Extract (root of 'type_decl') at parser.lkt:126:14>

--  BEGIN <_Row (root of 'type_decl') at ???>

Row_Pos143 := Row_Pos142;



--  BEGIN <Token(<WithText Colon>, ) (root of 'type_decl') at parser.lkt:126:19>

Token_Res224 := Row_Pos143;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res224));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos224 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos143 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos143,
             Expected_Token_Id => Lkt_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos224 := Row_Pos143 + 1;
   end if;
end;

--  END <Token(<WithText Colon>, ) (root of 'type_decl') at parser.lkt:126:19>




if Token_Pos224 /= No_Token_Index then

   Row_Pos143 := Token_Pos224;

else
   Row_Pos143 := No_Token_Index;
   goto Exit_Row143_0;

end if;


--  BEGIN <Defer (for 'type_ref') at parser.lkt:126:23>

Defer_Res221 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos143);
Defer_Pos221 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:126:23>




if Defer_Pos221 /= No_Token_Index then

   Row_Pos143 := Defer_Pos221;

else
   Row_Pos143 := No_Token_Index;
   goto Exit_Row143_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row143_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'type_decl') at ???>

--  END <_Extract (root of 'type_decl') at parser.lkt:126:14>


if Row_Pos143 = No_Token_Index then

         
   Defer_Res221 := No_Bare_Lkt_Node;



       
   Row_Pos143 := Row_Pos142;



end if;

--  END <Opt (root of 'type_decl') at parser.lkt:126:13>




if Row_Pos143 /= No_Token_Index then

   Row_Pos142 := Row_Pos143;

else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;

end if;


--  BEGIN <Opt (root of 'type_decl') at parser.lkt:127:13>












--  BEGIN <_Extract (root of 'type_decl') at parser.lkt:127:14>

--  BEGIN <_Row (root of 'type_decl') at ???>

Row_Pos144 := Row_Pos142;



--  BEGIN <Token(<WithText ImplementsKw>, ) (root of 'type_decl') at parser.lkt:127:19>

Token_Res225 := Row_Pos144;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res225));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Implements_Kw)
   then
       Token_Pos225 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos144 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos144,
             Expected_Token_Id => Lkt_Implements_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos225 := Row_Pos144 + 1;
   end if;
end;

--  END <Token(<WithText ImplementsKw>, ) (root of 'type_decl') at parser.lkt:127:19>




if Token_Pos225 /= No_Token_Index then

   Row_Pos144 := Token_Pos225;

else
   Row_Pos144 := No_Token_Index;
   goto Exit_Row144_0;

end if;


--  BEGIN <Defer (for 'type_list') at parser.lkt:127:32>

Defer_Res222 :=
   Type_List_List_Parse0 (Parser, Row_Pos144);
Defer_Pos222 := Parser.Current_Pos;

--  END <Defer (for 'type_list') at parser.lkt:127:32>




if Defer_Pos222 /= No_Token_Index then

   Row_Pos144 := Defer_Pos222;

else
   Row_Pos144 := No_Token_Index;
   goto Exit_Row144_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row144_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'type_decl') at ???>

--  END <_Extract (root of 'type_decl') at parser.lkt:127:14>


if Row_Pos144 = No_Token_Index then

         
   Defer_Res222 :=
     Allocate_Type_Ref_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res222,
      Kind              => Lkt_Type_Ref_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos142,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res222,
      Parser => Parser,
      Count  => 0);



       
   Row_Pos144 := Row_Pos142;



end if;

--  END <Opt (root of 'type_decl') at parser.lkt:127:13>




if Row_Pos144 /= No_Token_Index then

   Row_Pos142 := Row_Pos144;

else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;

end if;


--  BEGIN <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:128:13>

Token_Res226 := Row_Pos142;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res226));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos226 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos142 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos142,
             Expected_Token_Id => Lkt_L_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos226 := Row_Pos142 + 1;
   end if;
end;

--  END <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:128:13>




if Token_Pos226 /= No_Token_Index then

   Row_Pos142 := Token_Pos226;

else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;

end if;


--  BEGIN <List (root of 'type_decl') at parser.lkt:129:13>

    List_Pos32 := Row_Pos142;



Lst_Cpos31 := Row_Pos142;
Tmp_List31 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Transform(<CompiledType BareEnumClassCase>) (root of 'type_decl') at parser.lkt:129:19>

Transform_Diags124 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'type_decl') at ???>

Row_Pos145 := Lst_Cpos31;



--  BEGIN <Token(<WithText CaseKw>, ) (root of 'type_decl') at parser.lkt:129:33>

Token_Res227 := Row_Pos145;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res227));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Case_Kw)
   then
       Token_Pos227 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos145 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos145,
             Expected_Token_Id => Lkt_Case_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos227 := Row_Pos145 + 1;
   end if;
end;

--  END <Token(<WithText CaseKw>, ) (root of 'type_decl') at parser.lkt:129:33>




if Token_Pos227 /= No_Token_Index then

   Row_Pos145 := Token_Pos227;

else
   Row_Pos145 := No_Token_Index;
   goto Exit_Row145_0;

end if;


--  BEGIN <List (root of 'type_decl') at parser.lkt:129:40>

    List_Pos31 := No_Token_Index;



Lst_Cpos32 := Row_Pos145;
Tmp_List32 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Transform(<CompiledType BareEnumClassAltDecl>) (root of 'type_decl') at parser.lkt:129:46>

Transform_Diags123 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'type_decl') at ???>

Row_Pos146 := Lst_Cpos32;



--  BEGIN <Defer (for 'def_id') at parser.lkt:129:63>

Defer_Res223 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos146);
Defer_Pos223 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:129:63>




if Defer_Pos223 /= No_Token_Index then

   Row_Pos146 := Defer_Pos223;

else
   Row_Pos146 := No_Token_Index;
   goto Exit_Row146_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row146_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'type_decl') at ???>



if Row_Pos146 /= No_Token_Index then

   Transform_Res123 := Allocate_Enum_Class_Alt_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res123,
      Kind => Lkt_Enum_Class_Alt_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Lst_Cpos32,
      Token_End_Index   => (if Row_Pos146 = Lst_Cpos32
                            then No_Token_Index
                            else Row_Pos146 - 1));

      
      Initialize_Fields_For_Enum_Class_Alt_Decl
        (Self => Transform_Res123,
         Enum_Class_Alt_Decl_F_Syn_Name => Defer_Res223);

         if Defer_Res223 /= null and then Is_Incomplete (Defer_Res223) then
            Transform_Res123.Last_Attempted_Child := 0;
         elsif Defer_Res223 /= null and then not Is_Ghost (Defer_Res223) then
            Transform_Res123.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos146 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags123);
end if;

--  END <Transform(<CompiledType BareEnumClassAltDecl>) (root of 'type_decl') at parser.lkt:129:46>


   exit when Row_Pos146 = No_Token_Index;

   List_Pos31 := Row_Pos146;
   Lst_Cpos32 := List_Pos31;

   Tmp_List32.Nodes.Append (Transform_Res123);

      
--  BEGIN <Token(<WithText Comma>, ) (root of 'type_decl') at parser.lkt:129:72>

Token_Res228 := Lst_Cpos32;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res228));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos228 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos32 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos32,
             Expected_Token_Id => Lkt_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos228 := Lst_Cpos32 + 1;
   end if;
end;

--  END <Token(<WithText Comma>, ) (root of 'type_decl') at parser.lkt:129:72>


      exit when Token_Pos228 = No_Token_Index;

      Lst_Cpos32 := Token_Pos228;

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List32.Nodes.Length;
begin
   List_Res31 := Allocate_Enum_Class_Alt_Decl_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos145;
      Token_End := (if Lst_Cpos32 = Row_Pos145
                    then Row_Pos145
                    else List_Pos31 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos145, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res31,
      Kind              => Lkt_Enum_Class_Alt_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res31,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List32.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res31.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List32);

--  END <List (root of 'type_decl') at parser.lkt:129:40>




if List_Pos31 /= No_Token_Index then

   Row_Pos145 := List_Pos31;

else
   Row_Pos145 := No_Token_Index;
   goto Exit_Row145_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row145_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'type_decl') at ???>



if Row_Pos145 /= No_Token_Index then

   Transform_Res124 := Allocate_Enum_Class_Case (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res124,
      Kind => Lkt_Enum_Class_Case,
      Unit => Parser.Unit,

      Token_Start_Index => Lst_Cpos31,
      Token_End_Index   => (if Row_Pos145 = Lst_Cpos31
                            then No_Token_Index
                            else Row_Pos145 - 1));

      
      Initialize_Fields_For_Enum_Class_Case
        (Self => Transform_Res124,
         Enum_Class_Case_F_Decls => List_Res31);

         if List_Res31 /= null and then Is_Incomplete (List_Res31) then
            Transform_Res124.Last_Attempted_Child := 0;
         elsif List_Res31 /= null and then not Is_Ghost (List_Res31) then
            Transform_Res124.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos145 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags124);
end if;

--  END <Transform(<CompiledType BareEnumClassCase>) (root of 'type_decl') at parser.lkt:129:19>


   exit when Row_Pos145 = No_Token_Index;

   List_Pos32 := Row_Pos145;
   Lst_Cpos31 := List_Pos32;

   Tmp_List31.Nodes.Append (Transform_Res124);

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List31.Nodes.Length;
begin
   List_Res32 := Allocate_Enum_Class_Case_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos142;
      Token_End := (if Lst_Cpos31 = Row_Pos142
                    then Row_Pos142
                    else List_Pos32 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos142, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res32,
      Kind              => Lkt_Enum_Class_Case_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res32,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List31.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res32.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List31);

--  END <List (root of 'type_decl') at parser.lkt:129:13>




if List_Pos32 /= No_Token_Index then

   Row_Pos142 := List_Pos32;

else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;

end if;


--  BEGIN <Defer (for 'decl_block') at parser.lkt:130:13>

Defer_Res224 :=
   Decl_Block_List_Parse0 (Parser, Row_Pos142);
Defer_Pos224 := Parser.Current_Pos;

--  END <Defer (for 'decl_block') at parser.lkt:130:13>




if Defer_Pos224 /= No_Token_Index then

   Row_Pos142 := Defer_Pos224;

else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;

end if;


--  BEGIN <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:131:13>

Token_Res229 := Row_Pos142;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res229));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos229 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos142 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos142,
             Expected_Token_Id => Lkt_R_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos229 := Row_Pos142 + 1;
   end if;
end;

--  END <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:131:13>




if Token_Pos229 /= No_Token_Index then

   Row_Pos142 := Token_Pos229;

else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row142_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'type_decl') at ???>



if Row_Pos142 /= No_Token_Index then

   Transform_Res125 := Allocate_Enum_Class_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res125,
      Kind => Lkt_Enum_Class_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos142 = Pos
                            then No_Token_Index
                            else Row_Pos142 - 1));

      
      Initialize_Fields_For_Enum_Class_Decl
        (Self => Transform_Res125,
         Basic_Class_Decl_F_Syn_Name => Defer_Res220,
         Basic_Class_Decl_F_Syn_Base_Type => Defer_Res221,
         Basic_Class_Decl_F_Traits => Defer_Res222,
         Enum_Class_Decl_F_Branches => List_Res32,
         Enum_Class_Decl_F_Decls => Defer_Res224);

         if Defer_Res220 /= null and then Is_Incomplete (Defer_Res220) then
            Transform_Res125.Last_Attempted_Child := 0;
         elsif Defer_Res220 /= null and then not Is_Ghost (Defer_Res220) then
            Transform_Res125.Last_Attempted_Child := -1;
         end if;
         if Defer_Res221 /= null and then Is_Incomplete (Defer_Res221) then
            Transform_Res125.Last_Attempted_Child := 0;
         elsif Defer_Res221 /= null and then not Is_Ghost (Defer_Res221) then
            Transform_Res125.Last_Attempted_Child := -1;
         end if;
         if Defer_Res222 /= null and then Is_Incomplete (Defer_Res222) then
            Transform_Res125.Last_Attempted_Child := 0;
         elsif Defer_Res222 /= null and then not Is_Ghost (Defer_Res222) then
            Transform_Res125.Last_Attempted_Child := -1;
         end if;
         if List_Res32 /= null and then Is_Incomplete (List_Res32) then
            Transform_Res125.Last_Attempted_Child := 0;
         elsif List_Res32 /= null and then not Is_Ghost (List_Res32) then
            Transform_Res125.Last_Attempted_Child := -1;
         end if;
         if Defer_Res224 /= null and then Is_Incomplete (Defer_Res224) then
            Transform_Res125.Last_Attempted_Child := 0;
         elsif Defer_Res224 /= null and then not Is_Ghost (Defer_Res224) then
            Transform_Res125.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos142 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags125);
end if;

--  END <Transform(<CompiledType BareEnumClassDecl>) (root of 'type_decl') at parser.lkt:122:11>

    if Row_Pos142 /= No_Token_Index then
        Or_Pos31 := Row_Pos142;
        Or_Res31 := Transform_Res125;
        goto Exit_Or31;
    end if;
    
--  BEGIN <Transform(<CompiledType BareClassDecl>) (root of 'type_decl') at parser.lkt:133:11>

Transform_Diags126 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'type_decl') at ???>

Row_Pos147 := Pos;



--  BEGIN <Token(<WithText ClassKw>, ) (root of 'type_decl') at parser.lkt:134:13>

Token_Res230 := Row_Pos147;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res230));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Class_Kw)
   then
       Token_Pos230 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos147 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos147,
             Expected_Token_Id => Lkt_Class_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos230 := Row_Pos147 + 1;
   end if;
end;

--  END <Token(<WithText ClassKw>, ) (root of 'type_decl') at parser.lkt:134:13>




if Token_Pos230 /= No_Token_Index then

   Row_Pos147 := Token_Pos230;

else
   Row_Pos147 := No_Token_Index;
   goto Exit_Row147_0;

end if;


--  BEGIN <Defer (for 'def_id') at parser.lkt:135:13>

Defer_Res225 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos147);
Defer_Pos225 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:135:13>




if Defer_Pos225 /= No_Token_Index then

   Row_Pos147 := Defer_Pos225;

else
   Row_Pos147 := No_Token_Index;
   goto Exit_Row147_0;

end if;


--  BEGIN <Opt (root of 'type_decl') at parser.lkt:136:13>












--  BEGIN <_Extract (root of 'type_decl') at parser.lkt:136:14>

--  BEGIN <_Row (root of 'type_decl') at ???>

Row_Pos148 := Row_Pos147;



--  BEGIN <Token(<WithText Colon>, ) (root of 'type_decl') at parser.lkt:136:19>

Token_Res231 := Row_Pos148;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res231));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos231 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos148 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos148,
             Expected_Token_Id => Lkt_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos231 := Row_Pos148 + 1;
   end if;
end;

--  END <Token(<WithText Colon>, ) (root of 'type_decl') at parser.lkt:136:19>




if Token_Pos231 /= No_Token_Index then

   Row_Pos148 := Token_Pos231;

else
   Row_Pos148 := No_Token_Index;
   goto Exit_Row148_0;

end if;


--  BEGIN <Defer (for 'type_ref') at parser.lkt:136:23>

Defer_Res226 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos148);
Defer_Pos226 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:136:23>




if Defer_Pos226 /= No_Token_Index then

   Row_Pos148 := Defer_Pos226;

else
   Row_Pos148 := No_Token_Index;
   goto Exit_Row148_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row148_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'type_decl') at ???>

--  END <_Extract (root of 'type_decl') at parser.lkt:136:14>


if Row_Pos148 = No_Token_Index then

         
   Defer_Res226 := No_Bare_Lkt_Node;



       
   Row_Pos148 := Row_Pos147;



end if;

--  END <Opt (root of 'type_decl') at parser.lkt:136:13>




if Row_Pos148 /= No_Token_Index then

   Row_Pos147 := Row_Pos148;

else
   Row_Pos147 := No_Token_Index;
   goto Exit_Row147_0;

end if;


--  BEGIN <Opt (root of 'type_decl') at parser.lkt:137:13>












--  BEGIN <_Extract (root of 'type_decl') at parser.lkt:137:14>

--  BEGIN <_Row (root of 'type_decl') at ???>

Row_Pos149 := Row_Pos147;



--  BEGIN <Token(<WithText ImplementsKw>, ) (root of 'type_decl') at parser.lkt:137:19>

Token_Res232 := Row_Pos149;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res232));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Implements_Kw)
   then
       Token_Pos232 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos149 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos149,
             Expected_Token_Id => Lkt_Implements_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos232 := Row_Pos149 + 1;
   end if;
end;

--  END <Token(<WithText ImplementsKw>, ) (root of 'type_decl') at parser.lkt:137:19>




if Token_Pos232 /= No_Token_Index then

   Row_Pos149 := Token_Pos232;

else
   Row_Pos149 := No_Token_Index;
   goto Exit_Row149_0;

end if;


--  BEGIN <Defer (for 'type_list') at parser.lkt:137:32>

Defer_Res227 :=
   Type_List_List_Parse0 (Parser, Row_Pos149);
Defer_Pos227 := Parser.Current_Pos;

--  END <Defer (for 'type_list') at parser.lkt:137:32>




if Defer_Pos227 /= No_Token_Index then

   Row_Pos149 := Defer_Pos227;

else
   Row_Pos149 := No_Token_Index;
   goto Exit_Row149_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row149_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'type_decl') at ???>

--  END <_Extract (root of 'type_decl') at parser.lkt:137:14>


if Row_Pos149 = No_Token_Index then

         
   Defer_Res227 :=
     Allocate_Type_Ref_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res227,
      Kind              => Lkt_Type_Ref_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos147,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res227,
      Parser => Parser,
      Count  => 0);



       
   Row_Pos149 := Row_Pos147;



end if;

--  END <Opt (root of 'type_decl') at parser.lkt:137:13>




if Row_Pos149 /= No_Token_Index then

   Row_Pos147 := Row_Pos149;

else
   Row_Pos147 := No_Token_Index;
   goto Exit_Row147_0;

end if;


--  BEGIN <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:138:13>

Token_Res233 := Row_Pos147;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res233));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos233 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos147 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos147,
             Expected_Token_Id => Lkt_L_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos233 := Row_Pos147 + 1;
   end if;
end;

--  END <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:138:13>




if Token_Pos233 /= No_Token_Index then

   Row_Pos147 := Token_Pos233;

else
   Row_Pos147 := No_Token_Index;
   goto Exit_Row147_0;

end if;


--  BEGIN <Defer (for 'decl_block') at parser.lkt:139:13>

Defer_Res228 :=
   Decl_Block_List_Parse0 (Parser, Row_Pos147);
Defer_Pos228 := Parser.Current_Pos;

--  END <Defer (for 'decl_block') at parser.lkt:139:13>




if Defer_Pos228 /= No_Token_Index then

   Row_Pos147 := Defer_Pos228;

else
   Row_Pos147 := No_Token_Index;
   goto Exit_Row147_0;

end if;


--  BEGIN <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:140:13>

Token_Res234 := Row_Pos147;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res234));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos234 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos147 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos147,
             Expected_Token_Id => Lkt_R_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos234 := Row_Pos147 + 1;
   end if;
end;

--  END <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:140:13>




if Token_Pos234 /= No_Token_Index then

   Row_Pos147 := Token_Pos234;

else
   Row_Pos147 := No_Token_Index;
   goto Exit_Row147_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row147_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'type_decl') at ???>



if Row_Pos147 /= No_Token_Index then

   Transform_Res126 := Allocate_Class_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res126,
      Kind => Lkt_Class_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos147 = Pos
                            then No_Token_Index
                            else Row_Pos147 - 1));

      
      Initialize_Fields_For_Class_Decl
        (Self => Transform_Res126,
         Basic_Class_Decl_F_Syn_Name => Defer_Res225,
         Basic_Class_Decl_F_Syn_Base_Type => Defer_Res226,
         Basic_Class_Decl_F_Traits => Defer_Res227,
         Class_Decl_F_Decls => Defer_Res228);

         if Defer_Res225 /= null and then Is_Incomplete (Defer_Res225) then
            Transform_Res126.Last_Attempted_Child := 0;
         elsif Defer_Res225 /= null and then not Is_Ghost (Defer_Res225) then
            Transform_Res126.Last_Attempted_Child := -1;
         end if;
         if Defer_Res226 /= null and then Is_Incomplete (Defer_Res226) then
            Transform_Res126.Last_Attempted_Child := 0;
         elsif Defer_Res226 /= null and then not Is_Ghost (Defer_Res226) then
            Transform_Res126.Last_Attempted_Child := -1;
         end if;
         if Defer_Res227 /= null and then Is_Incomplete (Defer_Res227) then
            Transform_Res126.Last_Attempted_Child := 0;
         elsif Defer_Res227 /= null and then not Is_Ghost (Defer_Res227) then
            Transform_Res126.Last_Attempted_Child := -1;
         end if;
         if Defer_Res228 /= null and then Is_Incomplete (Defer_Res228) then
            Transform_Res126.Last_Attempted_Child := 0;
         elsif Defer_Res228 /= null and then not Is_Ghost (Defer_Res228) then
            Transform_Res126.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos147 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags126);
end if;

--  END <Transform(<CompiledType BareClassDecl>) (root of 'type_decl') at parser.lkt:133:11>

    if Row_Pos147 /= No_Token_Index then
        Or_Pos31 := Row_Pos147;
        Or_Res31 := Transform_Res126;
        goto Exit_Or31;
    end if;
    
--  BEGIN <Transform(<CompiledType BareEnumTypeDecl>) (root of 'type_decl') at parser.lkt:142:11>

Transform_Diags127 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'type_decl') at ???>

Row_Pos150 := Pos;



--  BEGIN <Token(<WithText EnumKw>, ) (root of 'type_decl') at parser.lkt:143:13>

Token_Res235 := Row_Pos150;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res235));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Enum_Kw)
   then
       Token_Pos235 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos150 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos150,
             Expected_Token_Id => Lkt_Enum_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos235 := Row_Pos150 + 1;
   end if;
end;

--  END <Token(<WithText EnumKw>, ) (root of 'type_decl') at parser.lkt:143:13>




if Token_Pos235 /= No_Token_Index then

   Row_Pos150 := Token_Pos235;

else
   Row_Pos150 := No_Token_Index;
   goto Exit_Row150_0;

end if;


--  BEGIN <Defer (for 'def_id') at parser.lkt:144:13>

Defer_Res229 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos150);
Defer_Pos229 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:144:13>




if Defer_Pos229 /= No_Token_Index then

   Row_Pos150 := Defer_Pos229;

else
   Row_Pos150 := No_Token_Index;
   goto Exit_Row150_0;

end if;


--  BEGIN <Opt (root of 'type_decl') at parser.lkt:145:13>












--  BEGIN <_Extract (root of 'type_decl') at parser.lkt:145:14>

--  BEGIN <_Row (root of 'type_decl') at ???>

Row_Pos151 := Row_Pos150;



--  BEGIN <Token(<WithText ImplementsKw>, ) (root of 'type_decl') at parser.lkt:145:19>

Token_Res236 := Row_Pos151;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res236));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Implements_Kw)
   then
       Token_Pos236 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos151 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos151,
             Expected_Token_Id => Lkt_Implements_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos236 := Row_Pos151 + 1;
   end if;
end;

--  END <Token(<WithText ImplementsKw>, ) (root of 'type_decl') at parser.lkt:145:19>




if Token_Pos236 /= No_Token_Index then

   Row_Pos151 := Token_Pos236;

else
   Row_Pos151 := No_Token_Index;
   goto Exit_Row151_0;

end if;


--  BEGIN <Defer (for 'type_list') at parser.lkt:145:32>

Defer_Res230 :=
   Type_List_List_Parse0 (Parser, Row_Pos151);
Defer_Pos230 := Parser.Current_Pos;

--  END <Defer (for 'type_list') at parser.lkt:145:32>




if Defer_Pos230 /= No_Token_Index then

   Row_Pos151 := Defer_Pos230;

else
   Row_Pos151 := No_Token_Index;
   goto Exit_Row151_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row151_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'type_decl') at ???>

--  END <_Extract (root of 'type_decl') at parser.lkt:145:14>


if Row_Pos151 = No_Token_Index then

         
   Defer_Res230 :=
     Allocate_Type_Ref_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res230,
      Kind              => Lkt_Type_Ref_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos150,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res230,
      Parser => Parser,
      Count  => 0);



       
   Row_Pos151 := Row_Pos150;



end if;

--  END <Opt (root of 'type_decl') at parser.lkt:145:13>




if Row_Pos151 /= No_Token_Index then

   Row_Pos150 := Row_Pos151;

else
   Row_Pos150 := No_Token_Index;
   goto Exit_Row150_0;

end if;


--  BEGIN <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:146:13>

Token_Res237 := Row_Pos150;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res237));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos237 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos150 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos150,
             Expected_Token_Id => Lkt_L_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos237 := Row_Pos150 + 1;
   end if;
end;

--  END <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:146:13>




if Token_Pos237 /= No_Token_Index then

   Row_Pos150 := Token_Pos237;

else
   Row_Pos150 := No_Token_Index;
   goto Exit_Row150_0;

end if;


--  BEGIN <Token(<WithText CaseKw>, ) (root of 'type_decl') at parser.lkt:147:13>

Token_Res238 := Row_Pos150;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res238));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Case_Kw)
   then
       Token_Pos238 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos150 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos150,
             Expected_Token_Id => Lkt_Case_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos238 := Row_Pos150 + 1;
   end if;
end;

--  END <Token(<WithText CaseKw>, ) (root of 'type_decl') at parser.lkt:147:13>




if Token_Pos238 /= No_Token_Index then

   Row_Pos150 := Token_Pos238;

else
   Row_Pos150 := No_Token_Index;
   goto Exit_Row150_0;

end if;


--  BEGIN <List (root of 'type_decl') at parser.lkt:148:13>

    List_Pos33 := No_Token_Index;



Lst_Cpos33 := Row_Pos150;
Tmp_List33 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'enum_lit_decl') at parser.lkt:148:19>

Defer_Res231 :=
   Enum_Lit_Decl_Transform_Parse0 (Parser, Lst_Cpos33);
Defer_Pos231 := Parser.Current_Pos;

--  END <Defer (for 'enum_lit_decl') at parser.lkt:148:19>


   exit when Defer_Pos231 = No_Token_Index;

   List_Pos33 := Defer_Pos231;
   Lst_Cpos33 := List_Pos33;

   Tmp_List33.Nodes.Append (Defer_Res231);

      
--  BEGIN <Token(<WithText Comma>, ) (root of 'type_decl') at parser.lkt:148:34>

Token_Res239 := Lst_Cpos33;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res239));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos239 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos33 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos33,
             Expected_Token_Id => Lkt_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos239 := Lst_Cpos33 + 1;
   end if;
end;

--  END <Token(<WithText Comma>, ) (root of 'type_decl') at parser.lkt:148:34>


      exit when Token_Pos239 = No_Token_Index;

      Lst_Cpos33 := Token_Pos239;

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List33.Nodes.Length;
begin
   List_Res33 := Allocate_Enum_Lit_Decl_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos150;
      Token_End := (if Lst_Cpos33 = Row_Pos150
                    then Row_Pos150
                    else List_Pos33 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos150, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res33,
      Kind              => Lkt_Enum_Lit_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res33,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List33.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res33.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List33);

--  END <List (root of 'type_decl') at parser.lkt:148:13>




if List_Pos33 /= No_Token_Index then

   Row_Pos150 := List_Pos33;

else
   Row_Pos150 := No_Token_Index;
   goto Exit_Row150_0;

end if;


--  BEGIN <Defer (for 'decl_block') at parser.lkt:149:13>

Defer_Res232 :=
   Decl_Block_List_Parse0 (Parser, Row_Pos150);
Defer_Pos232 := Parser.Current_Pos;

--  END <Defer (for 'decl_block') at parser.lkt:149:13>




if Defer_Pos232 /= No_Token_Index then

   Row_Pos150 := Defer_Pos232;

else
   Row_Pos150 := No_Token_Index;
   goto Exit_Row150_0;

end if;


--  BEGIN <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:150:13>

Token_Res240 := Row_Pos150;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res240));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos240 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos150 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos150,
             Expected_Token_Id => Lkt_R_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos240 := Row_Pos150 + 1;
   end if;
end;

--  END <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:150:13>




if Token_Pos240 /= No_Token_Index then

   Row_Pos150 := Token_Pos240;

else
   Row_Pos150 := No_Token_Index;
   goto Exit_Row150_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row150_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'type_decl') at ???>



if Row_Pos150 /= No_Token_Index then

   Transform_Res127 := Allocate_Enum_Type_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res127,
      Kind => Lkt_Enum_Type_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos150 = Pos
                            then No_Token_Index
                            else Row_Pos150 - 1));

      
      Initialize_Fields_For_Enum_Type_Decl
        (Self => Transform_Res127,
         Enum_Type_Decl_F_Syn_Name => Defer_Res229,
         Enum_Type_Decl_F_Traits => Defer_Res230,
         Enum_Type_Decl_F_Literals => List_Res33,
         Enum_Type_Decl_F_Decls => Defer_Res232);

         if Defer_Res229 /= null and then Is_Incomplete (Defer_Res229) then
            Transform_Res127.Last_Attempted_Child := 0;
         elsif Defer_Res229 /= null and then not Is_Ghost (Defer_Res229) then
            Transform_Res127.Last_Attempted_Child := -1;
         end if;
         if Defer_Res230 /= null and then Is_Incomplete (Defer_Res230) then
            Transform_Res127.Last_Attempted_Child := 0;
         elsif Defer_Res230 /= null and then not Is_Ghost (Defer_Res230) then
            Transform_Res127.Last_Attempted_Child := -1;
         end if;
         if List_Res33 /= null and then Is_Incomplete (List_Res33) then
            Transform_Res127.Last_Attempted_Child := 0;
         elsif List_Res33 /= null and then not Is_Ghost (List_Res33) then
            Transform_Res127.Last_Attempted_Child := -1;
         end if;
         if Defer_Res232 /= null and then Is_Incomplete (Defer_Res232) then
            Transform_Res127.Last_Attempted_Child := 0;
         elsif Defer_Res232 /= null and then not Is_Ghost (Defer_Res232) then
            Transform_Res127.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos150 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags127);
end if;

--  END <Transform(<CompiledType BareEnumTypeDecl>) (root of 'type_decl') at parser.lkt:142:11>

    if Row_Pos150 /= No_Token_Index then
        Or_Pos31 := Row_Pos150;
        Or_Res31 := Transform_Res127;
        goto Exit_Or31;
    end if;
    
--  BEGIN <Transform(<CompiledType BareTraitDecl>) (root of 'type_decl') at parser.lkt:152:11>

Transform_Diags128 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'type_decl') at ???>

Row_Pos152 := Pos;



--  BEGIN <Token(<WithText TraitKw>, ) (root of 'type_decl') at parser.lkt:152:21>

Token_Res241 := Row_Pos152;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res241));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Trait_Kw)
   then
       Token_Pos241 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos152 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos152,
             Expected_Token_Id => Lkt_Trait_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos241 := Row_Pos152 + 1;
   end if;
end;

--  END <Token(<WithText TraitKw>, ) (root of 'type_decl') at parser.lkt:152:21>




if Token_Pos241 /= No_Token_Index then

   Row_Pos152 := Token_Pos241;

else
   Row_Pos152 := No_Token_Index;
   goto Exit_Row152_0;

end if;


--  BEGIN <Defer (for 'def_id') at parser.lkt:152:29>

Defer_Res233 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos152);
Defer_Pos233 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:152:29>




if Defer_Pos233 /= No_Token_Index then

   Row_Pos152 := Defer_Pos233;

else
   Row_Pos152 := No_Token_Index;
   goto Exit_Row152_0;

end if;


--  BEGIN <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:152:36>

Token_Res242 := Row_Pos152;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res242));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos242 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos152 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos152,
             Expected_Token_Id => Lkt_L_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos242 := Row_Pos152 + 1;
   end if;
end;

--  END <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:152:36>




if Token_Pos242 /= No_Token_Index then

   Row_Pos152 := Token_Pos242;

else
   Row_Pos152 := No_Token_Index;
   goto Exit_Row152_0;

end if;


--  BEGIN <Defer (for 'decl_block') at parser.lkt:152:40>

Defer_Res234 :=
   Decl_Block_List_Parse0 (Parser, Row_Pos152);
Defer_Pos234 := Parser.Current_Pos;

--  END <Defer (for 'decl_block') at parser.lkt:152:40>




if Defer_Pos234 /= No_Token_Index then

   Row_Pos152 := Defer_Pos234;

else
   Row_Pos152 := No_Token_Index;
   goto Exit_Row152_0;

end if;


--  BEGIN <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:152:51>

Token_Res243 := Row_Pos152;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res243));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos243 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos152 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos152,
             Expected_Token_Id => Lkt_R_Brace,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos243 := Row_Pos152 + 1;
   end if;
end;

--  END <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:152:51>




if Token_Pos243 /= No_Token_Index then

   Row_Pos152 := Token_Pos243;

else
   Row_Pos152 := No_Token_Index;
   goto Exit_Row152_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row152_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'type_decl') at ???>



if Row_Pos152 /= No_Token_Index then

   Transform_Res128 := Allocate_Trait_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res128,
      Kind => Lkt_Trait_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos152 = Pos
                            then No_Token_Index
                            else Row_Pos152 - 1));

      
      Initialize_Fields_For_Trait_Decl
        (Self => Transform_Res128,
         Trait_Decl_F_Syn_Name => Defer_Res233,
         Trait_Decl_F_Decls => Defer_Res234);

         if Defer_Res233 /= null and then Is_Incomplete (Defer_Res233) then
            Transform_Res128.Last_Attempted_Child := 0;
         elsif Defer_Res233 /= null and then not Is_Ghost (Defer_Res233) then
            Transform_Res128.Last_Attempted_Child := -1;
         end if;
         if Defer_Res234 /= null and then Is_Incomplete (Defer_Res234) then
            Transform_Res128.Last_Attempted_Child := 0;
         elsif Defer_Res234 /= null and then not Is_Ghost (Defer_Res234) then
            Transform_Res128.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos152 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags128);
end if;

--  END <Transform(<CompiledType BareTraitDecl>) (root of 'type_decl') at parser.lkt:152:11>

    if Row_Pos152 /= No_Token_Index then
        Or_Pos31 := Row_Pos152;
        Or_Res31 := Transform_Res128;
        goto Exit_Or31;
    end if;
<<Exit_Or31>>

--  END <Or (root of 'type_decl') at parser.lkt:118:18>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Type_Decl_Or_Parse0_Memo,
      Or_Pos31 /= No_Token_Index,
      Or_Res31,
      Pos,
      Or_Pos31);


   Parser.Current_Pos := Or_Pos31;

   return Or_Res31;
end Type_Decl_Or_Parse0;

   


function Type_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
   use Bare_Expr_Memos;

      Nobt3 :
            Boolean
               := False;
      Row_Pos153 :
            Token_Index
               := No_Token_Index;
      Defer_Pos235 :
            Token_Index
               := No_Token_Index;
      Defer_Res235 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos244 :
            Token_Index
               := No_Token_Index;
      Token_Res244 :
            Token_Index
               := No_Token_Index;
      Defer_Pos236 :
            Token_Index
               := No_Token_Index;
      Defer_Res236 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Row_Progress3 :
            Integer
               := 0;
      Transform_Res129 :
            Bare_Dot_Expr
               := No_Bare_Lkt_Node;
      Transform_Has_Failed3 :
            Boolean
               := False;
      Transform_Diags129 :
            Ada.Containers.Count_Type;
      Defer_Pos237 :
            Token_Index
               := No_Token_Index;
      Defer_Res237 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Or_Pos32 :
            Token_Index
               := No_Token_Index;
      Or_Res32 :
            Bare_Expr
               := No_Bare_Lkt_Node;

      Mem_Pos : Token_Index := Pos;
      Mem_Res : Bare_Expr := No_Bare_Lkt_Node;

   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Type_Expr_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res32 := M.Instance;
      return Or_Res32;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res32;
   end if;

       Set (PP.Type_Expr_Or_Parse0_Memo, False, Or_Res32, Pos, Mem_Pos);

       <<Try_Again>>

      Nobt3 := False;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'type_expr') at parser.lkt:207:18>

Or_Pos32 := No_Token_Index;
Or_Res32 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareDotExpr>) (root of 'type_expr') at parser.lkt:207:23>

Transform_Diags129 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'type_expr') at ???>

Row_Pos153 := Pos;



--  BEGIN <Defer (for 'type_expr') at parser.lkt:207:31>

Defer_Res235 :=
   Type_Expr_Or_Parse0 (Parser, Row_Pos153);
Defer_Pos235 := Parser.Current_Pos;

--  END <Defer (for 'type_expr') at parser.lkt:207:31>



Row_Progress3 := 1;

if Defer_Pos235 /= No_Token_Index then

   Row_Pos153 := Defer_Pos235;

else
   Row_Pos153 := No_Token_Index;
   goto Exit_Row153_0;

end if;


--  BEGIN <Token(<WithText Dot>, ) (root of 'type_expr') at parser.lkt:207:41>

Token_Res244 := Row_Pos153;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res244));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dot)
   then
       Token_Pos244 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos153 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos153,
             Expected_Token_Id => Lkt_Dot,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos244 := Row_Pos153 + 1;
   end if;
end;

--  END <Token(<WithText Dot>, ) (root of 'type_expr') at parser.lkt:207:41>



Row_Progress3 := 2;

if Token_Pos244 /= No_Token_Index then

   Row_Pos153 := Token_Pos244;

else
   Row_Pos153 := No_Token_Index;
   goto Exit_Row153_0;

end if;


--  BEGIN <Cut (root of 'type_expr') at ???>
Nobt3 := True;
--  END <Cut (root of 'type_expr') at ???>


   Nobt3 := Nobt3;

Row_Progress3 := 3;

if Row_Pos153 /= No_Token_Index then

   Row_Pos153 := Row_Pos153;

else
   Row_Pos153 := No_Token_Index;
   goto Exit_Row153_0;

end if;


--  BEGIN <Defer (for 'type_ref_id') at parser.lkt:207:47>

Defer_Res236 :=
   Type_Ref_Id_Predicate_Parse0 (Parser, Row_Pos153);
Defer_Pos236 := Parser.Current_Pos;

--  END <Defer (for 'type_ref_id') at parser.lkt:207:47>



Row_Progress3 := 4;

if Defer_Pos236 /= No_Token_Index then

   Row_Pos153 := Defer_Pos236;

else
   Row_Pos153 := No_Token_Index;
   goto Exit_Row153_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row153_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'type_expr') at ???>


if Row_Pos153 = No_Token_Index and then Nobt3 then

   Row_Pos153 := Parser.Last_Fail.Pos;

   Transform_Has_Failed3 := True;
end if;

if Row_Pos153 /= No_Token_Index then

   Transform_Res129 := Allocate_Dot_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res129,
      Kind => Lkt_Dot_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos153 = Pos
                            then No_Token_Index
                            else Row_Pos153 - 1));

      
      Initialize_Fields_For_Dot_Expr
        (Self => Transform_Res129,
         Base_Dot_Expr_F_Prefix => Defer_Res235,
         Base_Dot_Expr_F_Suffix => Defer_Res236);

         if Defer_Res235 /= null and then Is_Incomplete (Defer_Res235) then
            Transform_Res129.Last_Attempted_Child := 0;
         elsif Defer_Res235 /= null and then not Is_Ghost (Defer_Res235) then
            Transform_Res129.Last_Attempted_Child := -1;
         end if;
         if Defer_Res236 /= null and then Is_Incomplete (Defer_Res236) then
            Transform_Res129.Last_Attempted_Child := 0;
         elsif Defer_Res236 /= null and then not Is_Ghost (Defer_Res236) then
            Transform_Res129.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed3 then
      Transform_Res129.Last_Attempted_Child :=
         Row_Progress3;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <type_expr>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos153 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags129);
end if;

--  END <Transform(<CompiledType BareDotExpr>) (root of 'type_expr') at parser.lkt:207:23>

    if Row_Pos153 /= No_Token_Index then
        Or_Pos32 := Row_Pos153;
        Or_Res32 := Transform_Res129;
        goto Exit_Or32;
    end if;
    
--  BEGIN <Defer (for 'type_ref_id') at parser.lkt:207:62>

Defer_Res237 :=
   Type_Ref_Id_Predicate_Parse0 (Parser, Pos);
Defer_Pos237 := Parser.Current_Pos;

--  END <Defer (for 'type_ref_id') at parser.lkt:207:62>

    if Defer_Pos237 /= No_Token_Index then
        Or_Pos32 := Defer_Pos237;
        Or_Res32 := Defer_Res237;
        goto Exit_Or32;
    end if;
<<Exit_Or32>>

--  END <Or (root of 'type_expr') at parser.lkt:207:18>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------

      if Or_Pos32 > Mem_Pos then
         Mem_Pos := Or_Pos32;
         Mem_Res := Or_Res32;
         Set
           (PP.Type_Expr_Or_Parse0_Memo,
            Or_Pos32 /= No_Token_Index,
            Or_Res32,
            Pos,
            Or_Pos32);
         goto Try_Again;

      elsif Mem_Pos > Pos then
         Or_Res32 := Mem_Res;
         Or_Pos32 := Mem_Pos;
         goto No_Memo;
      end if;

   Set
     (PP.Type_Expr_Or_Parse0_Memo,
      Or_Pos32 /= No_Token_Index,
      Or_Res32,
      Pos,
      Or_Pos32);

       <<No_Memo>>

   Parser.Current_Pos := Or_Pos32;

   return Or_Res32;
end Type_Expr_Or_Parse0;

   


function Type_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Type_Ref_List
is
   use Bare_Type_Ref_List_Memos;

      Lst_Cpos34 :
            Token_Index
               := No_Token_Index;
      Tmp_List34 :
            Free_Parse_List;
      Defer_Pos238 :
            Token_Index
               := No_Token_Index;
      Defer_Res238 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Token_Pos245 :
            Token_Index
               := No_Token_Index;
      Token_Res245 :
            Token_Index
               := No_Token_Index;
      List_Pos34 :
            Token_Index
               := No_Token_Index;
      List_Res34 :
            Bare_Type_Ref_List
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Type_List_List_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      List_Res34 := M.Instance;
      return List_Res34;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return List_Res34;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <List (root of 'type_list') at parser.lkt:213:18>

    List_Pos34 := No_Token_Index;



Lst_Cpos34 := Pos;
Tmp_List34 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'type_ref') at parser.lkt:213:24>

Defer_Res238 :=
   Type_Ref_Or_Parse0 (Parser, Lst_Cpos34);
Defer_Pos238 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:213:24>


   exit when Defer_Pos238 = No_Token_Index;

   List_Pos34 := Defer_Pos238;
   Lst_Cpos34 := List_Pos34;

   Tmp_List34.Nodes.Append (Defer_Res238);

      
--  BEGIN <Token(<WithText Comma>, ) (root of 'type_list') at parser.lkt:213:34>

Token_Res245 := Lst_Cpos34;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res245));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos245 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos34 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos34,
             Expected_Token_Id => Lkt_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos245 := Lst_Cpos34 + 1;
   end if;
end;

--  END <Token(<WithText Comma>, ) (root of 'type_list') at parser.lkt:213:34>


      exit when Token_Pos245 = No_Token_Index;

      Lst_Cpos34 := Token_Pos245;

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List34.Nodes.Length;
begin
   List_Res34 := Allocate_Type_Ref_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos34 = Pos
                    then Pos
                    else List_Pos34 - 1);

   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res34,
      Kind              => Lkt_Type_Ref_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res34,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List34.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res34.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List34);

--  END <List (root of 'type_list') at parser.lkt:213:18>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Type_List_List_Parse0_Memo,
      List_Pos34 /= No_Token_Index,
      List_Res34,
      Pos,
      List_Pos34);


   Parser.Current_Pos := List_Pos34;

   return List_Res34;
end Type_List_List_Parse0;

   


function Type_Member_Ref_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Dot_Expr
is
   use Bare_Dot_Expr_Memos;

      Nobt4 :
            Boolean
               := False;
      Row_Pos154 :
            Token_Index
               := No_Token_Index;
      Defer_Pos239 :
            Token_Index
               := No_Token_Index;
      Defer_Res239 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Token_Pos246 :
            Token_Index
               := No_Token_Index;
      Token_Res246 :
            Token_Index
               := No_Token_Index;
      Defer_Pos240 :
            Token_Index
               := No_Token_Index;
      Defer_Res240 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Row_Progress4 :
            Integer
               := 0;
      Transform_Res130 :
            Bare_Dot_Expr
               := No_Bare_Lkt_Node;
      Transform_Has_Failed4 :
            Boolean
               := False;
      Transform_Diags130 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Type_Member_Ref_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res130 := M.Instance;
      return Transform_Res130;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res130;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareDotExpr>) (root of 'type_member_ref') at parser.lkt:206:24>

Transform_Diags130 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'type_member_ref') at ???>

Row_Pos154 := Pos;



--  BEGIN <Defer (for 'type_ref_id') at parser.lkt:206:32>

Defer_Res239 :=
   Type_Ref_Id_Predicate_Parse0 (Parser, Row_Pos154);
Defer_Pos239 := Parser.Current_Pos;

--  END <Defer (for 'type_ref_id') at parser.lkt:206:32>



Row_Progress4 := 1;

if Defer_Pos239 /= No_Token_Index then

   Row_Pos154 := Defer_Pos239;

else
   Row_Pos154 := No_Token_Index;
   goto Exit_Row154_0;

end if;


--  BEGIN <Token(<WithText Dot>, ) (root of 'type_member_ref') at parser.lkt:206:44>

Token_Res246 := Row_Pos154;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res246));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dot)
   then
       Token_Pos246 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos154 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos154,
             Expected_Token_Id => Lkt_Dot,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos246 := Row_Pos154 + 1;
   end if;
end;

--  END <Token(<WithText Dot>, ) (root of 'type_member_ref') at parser.lkt:206:44>



Row_Progress4 := 2;

if Token_Pos246 /= No_Token_Index then

   Row_Pos154 := Token_Pos246;

else
   Row_Pos154 := No_Token_Index;
   goto Exit_Row154_0;

end if;


--  BEGIN <Cut (root of 'type_member_ref') at ???>
Nobt4 := True;
--  END <Cut (root of 'type_member_ref') at ???>


   Nobt4 := Nobt4;

Row_Progress4 := 3;

if Row_Pos154 /= No_Token_Index then

   Row_Pos154 := Row_Pos154;

else
   Row_Pos154 := No_Token_Index;
   goto Exit_Row154_0;

end if;


--  BEGIN <Defer (for 'ref_id') at parser.lkt:206:50>

Defer_Res240 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos154);
Defer_Pos240 := Parser.Current_Pos;

--  END <Defer (for 'ref_id') at parser.lkt:206:50>



Row_Progress4 := 4;

if Defer_Pos240 /= No_Token_Index then

   Row_Pos154 := Defer_Pos240;

else
   Row_Pos154 := No_Token_Index;
   goto Exit_Row154_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row154_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'type_member_ref') at ???>


if Row_Pos154 = No_Token_Index and then Nobt4 then

   Row_Pos154 := Parser.Last_Fail.Pos;

   Transform_Has_Failed4 := True;
end if;

if Row_Pos154 /= No_Token_Index then

   Transform_Res130 := Allocate_Dot_Expr (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res130,
      Kind => Lkt_Dot_Expr,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos154 = Pos
                            then No_Token_Index
                            else Row_Pos154 - 1));

      
      Initialize_Fields_For_Dot_Expr
        (Self => Transform_Res130,
         Base_Dot_Expr_F_Prefix => Defer_Res239,
         Base_Dot_Expr_F_Suffix => Defer_Res240);

         if Defer_Res239 /= null and then Is_Incomplete (Defer_Res239) then
            Transform_Res130.Last_Attempted_Child := 0;
         elsif Defer_Res239 /= null and then not Is_Ghost (Defer_Res239) then
            Transform_Res130.Last_Attempted_Child := -1;
         end if;
         if Defer_Res240 /= null and then Is_Incomplete (Defer_Res240) then
            Transform_Res130.Last_Attempted_Child := 0;
         elsif Defer_Res240 /= null and then not Is_Ghost (Defer_Res240) then
            Transform_Res130.Last_Attempted_Child := -1;
         end if;

   if Transform_Has_Failed4 then
      Transform_Res130.Last_Attempted_Child :=
         Row_Progress4;

      Append (Parser.Diagnostics,
              Sloc_Range (Parser.TDH.all,
                          Get_Token (Parser.TDH.all, Pos)),
              To_Text ("Cannot parse <type_member_ref>"));

      Add_Last_Fail_Diagnostic (Parser);
   end if;

elsif Row_Pos154 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags130);
end if;

--  END <Transform(<CompiledType BareDotExpr>) (root of 'type_member_ref') at parser.lkt:206:24>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Type_Member_Ref_Transform_Parse0_Memo,
      Row_Pos154 /= No_Token_Index,
      Transform_Res130,
      Pos,
      Row_Pos154);


   Parser.Current_Pos := Row_Pos154;

   return Transform_Res130;
end Type_Member_Ref_Transform_Parse0;

   


function Type_Ref_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Type_Ref
is
   use Bare_Type_Ref_Memos;

      Row_Pos155 :
            Token_Index
               := No_Token_Index;
      Defer_Pos241 :
            Token_Index
               := No_Token_Index;
      Defer_Res241 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Token_Pos247 :
            Token_Index
               := No_Token_Index;
      Token_Res247 :
            Token_Index
               := No_Token_Index;
      Defer_Pos242 :
            Token_Index
               := No_Token_Index;
      Defer_Res242 :
            Bare_Type_Ref_List
               := No_Bare_Lkt_Node;
      Token_Pos248 :
            Token_Index
               := No_Token_Index;
      Token_Res248 :
            Token_Index
               := No_Token_Index;
      Transform_Res131 :
            Bare_Generic_Type_Ref
               := No_Bare_Lkt_Node;
      Transform_Diags131 :
            Ada.Containers.Count_Type;
      Row_Pos156 :
            Token_Index
               := No_Token_Index;
      Defer_Pos243 :
            Token_Index
               := No_Token_Index;
      Defer_Res243 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res132 :
            Bare_Simple_Type_Ref
               := No_Bare_Lkt_Node;
      Transform_Diags132 :
            Ada.Containers.Count_Type;
      Row_Pos157 :
            Token_Index
               := No_Token_Index;
      Token_Pos249 :
            Token_Index
               := No_Token_Index;
      Token_Res249 :
            Token_Index
               := No_Token_Index;
      Lst_Cpos35 :
            Token_Index
               := No_Token_Index;
      Tmp_List35 :
            Free_Parse_List;
      Defer_Pos244 :
            Token_Index
               := No_Token_Index;
      Defer_Res244 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Token_Pos250 :
            Token_Index
               := No_Token_Index;
      Token_Res250 :
            Token_Index
               := No_Token_Index;
      List_Pos35 :
            Token_Index
               := No_Token_Index;
      List_Res35 :
            Bare_Type_Ref_List
               := No_Bare_Lkt_Node;
      Token_Pos251 :
            Token_Index
               := No_Token_Index;
      Token_Res251 :
            Token_Index
               := No_Token_Index;
      Token_Pos252 :
            Token_Index
               := No_Token_Index;
      Token_Res252 :
            Token_Index
               := No_Token_Index;
      Defer_Pos245 :
            Token_Index
               := No_Token_Index;
      Defer_Res245 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Transform_Res133 :
            Bare_Function_Type_Ref
               := No_Bare_Lkt_Node;
      Transform_Diags133 :
            Ada.Containers.Count_Type;
      Or_Pos33 :
            Token_Index
               := No_Token_Index;
      Or_Res33 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Type_Ref_Or_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Or_Res33 := M.Instance;
      return Or_Res33;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Or_Res33;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Or (root of 'type_ref') at parser.lkt:208:17>

Or_Pos33 := No_Token_Index;
Or_Res33 := No_Bare_Lkt_Node;
    
--  BEGIN <Transform(<CompiledType BareGenericTypeRef>) (root of 'type_ref') at parser.lkt:209:11>

Transform_Diags131 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'type_ref') at ???>

Row_Pos155 := Pos;



--  BEGIN <Defer (for 'type_expr') at parser.lkt:209:26>

Defer_Res241 :=
   Type_Expr_Or_Parse0 (Parser, Row_Pos155);
Defer_Pos241 := Parser.Current_Pos;

--  END <Defer (for 'type_expr') at parser.lkt:209:26>




if Defer_Pos241 /= No_Token_Index then

   Row_Pos155 := Defer_Pos241;

else
   Row_Pos155 := No_Token_Index;
   goto Exit_Row155_0;

end if;


--  BEGIN <Token(<WithText LBrack>, ) (root of 'type_ref') at parser.lkt:209:36>

Token_Res247 := Row_Pos155;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res247));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos247 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos155 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos155,
             Expected_Token_Id => Lkt_L_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos247 := Row_Pos155 + 1;
   end if;
end;

--  END <Token(<WithText LBrack>, ) (root of 'type_ref') at parser.lkt:209:36>




if Token_Pos247 /= No_Token_Index then

   Row_Pos155 := Token_Pos247;

else
   Row_Pos155 := No_Token_Index;
   goto Exit_Row155_0;

end if;


--  BEGIN <Defer (for 'type_list') at parser.lkt:209:40>

Defer_Res242 :=
   Type_List_List_Parse0 (Parser, Row_Pos155);
Defer_Pos242 := Parser.Current_Pos;

--  END <Defer (for 'type_list') at parser.lkt:209:40>




if Defer_Pos242 /= No_Token_Index then

   Row_Pos155 := Defer_Pos242;

else
   Row_Pos155 := No_Token_Index;
   goto Exit_Row155_0;

end if;


--  BEGIN <Token(<WithText RBrack>, ) (root of 'type_ref') at parser.lkt:209:50>

Token_Res248 := Row_Pos155;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res248));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos248 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos155 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos155,
             Expected_Token_Id => Lkt_R_Brack,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos248 := Row_Pos155 + 1;
   end if;
end;

--  END <Token(<WithText RBrack>, ) (root of 'type_ref') at parser.lkt:209:50>




if Token_Pos248 /= No_Token_Index then

   Row_Pos155 := Token_Pos248;

else
   Row_Pos155 := No_Token_Index;
   goto Exit_Row155_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row155_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'type_ref') at ???>



if Row_Pos155 /= No_Token_Index then

   Transform_Res131 := Allocate_Generic_Type_Ref (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res131,
      Kind => Lkt_Generic_Type_Ref,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos155 = Pos
                            then No_Token_Index
                            else Row_Pos155 - 1));

      
      Initialize_Fields_For_Generic_Type_Ref
        (Self => Transform_Res131,
         Generic_Type_Ref_F_Type_Name => Defer_Res241,
         Generic_Type_Ref_F_Params => Defer_Res242);

         if Defer_Res241 /= null and then Is_Incomplete (Defer_Res241) then
            Transform_Res131.Last_Attempted_Child := 0;
         elsif Defer_Res241 /= null and then not Is_Ghost (Defer_Res241) then
            Transform_Res131.Last_Attempted_Child := -1;
         end if;
         if Defer_Res242 /= null and then Is_Incomplete (Defer_Res242) then
            Transform_Res131.Last_Attempted_Child := 0;
         elsif Defer_Res242 /= null and then not Is_Ghost (Defer_Res242) then
            Transform_Res131.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos155 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags131);
end if;

--  END <Transform(<CompiledType BareGenericTypeRef>) (root of 'type_ref') at parser.lkt:209:11>

    if Row_Pos155 /= No_Token_Index then
        Or_Pos33 := Row_Pos155;
        Or_Res33 := Transform_Res131;
        goto Exit_Or33;
    end if;
    
--  BEGIN <Transform(<CompiledType BareSimpleTypeRef>) (root of 'type_ref') at parser.lkt:210:11>

Transform_Diags132 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'type_ref') at ???>

Row_Pos156 := Pos;



--  BEGIN <Defer (for 'type_expr') at parser.lkt:210:25>

Defer_Res243 :=
   Type_Expr_Or_Parse0 (Parser, Row_Pos156);
Defer_Pos243 := Parser.Current_Pos;

--  END <Defer (for 'type_expr') at parser.lkt:210:25>




if Defer_Pos243 /= No_Token_Index then

   Row_Pos156 := Defer_Pos243;

else
   Row_Pos156 := No_Token_Index;
   goto Exit_Row156_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row156_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'type_ref') at ???>



if Row_Pos156 /= No_Token_Index then

   Transform_Res132 := Allocate_Simple_Type_Ref (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res132,
      Kind => Lkt_Simple_Type_Ref,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos156 = Pos
                            then No_Token_Index
                            else Row_Pos156 - 1));

      
      Initialize_Fields_For_Simple_Type_Ref
        (Self => Transform_Res132,
         Simple_Type_Ref_F_Type_Name => Defer_Res243);

         if Defer_Res243 /= null and then Is_Incomplete (Defer_Res243) then
            Transform_Res132.Last_Attempted_Child := 0;
         elsif Defer_Res243 /= null and then not Is_Ghost (Defer_Res243) then
            Transform_Res132.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos156 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags132);
end if;

--  END <Transform(<CompiledType BareSimpleTypeRef>) (root of 'type_ref') at parser.lkt:210:11>

    if Row_Pos156 /= No_Token_Index then
        Or_Pos33 := Row_Pos156;
        Or_Res33 := Transform_Res132;
        goto Exit_Or33;
    end if;
    
--  BEGIN <Transform(<CompiledType BareFunctionTypeRef>) (root of 'type_ref') at parser.lkt:211:11>

Transform_Diags133 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'type_ref') at ???>

Row_Pos157 := Pos;



--  BEGIN <Token(<WithText LPar>, ) (root of 'type_ref') at parser.lkt:211:27>

Token_Res249 := Row_Pos157;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res249));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos249 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos157 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos157,
             Expected_Token_Id => Lkt_L_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos249 := Row_Pos157 + 1;
   end if;
end;

--  END <Token(<WithText LPar>, ) (root of 'type_ref') at parser.lkt:211:27>




if Token_Pos249 /= No_Token_Index then

   Row_Pos157 := Token_Pos249;

else
   Row_Pos157 := No_Token_Index;
   goto Exit_Row157_0;

end if;


--  BEGIN <List (root of 'type_ref') at parser.lkt:211:31>

    List_Pos35 := Row_Pos157;



Lst_Cpos35 := Row_Pos157;
Tmp_List35 := Get_Parse_List (Parser);


loop
   
--  BEGIN <Defer (for 'type_ref') at parser.lkt:211:37>

Defer_Res244 :=
   Type_Ref_Or_Parse0 (Parser, Lst_Cpos35);
Defer_Pos244 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:211:37>


   exit when Defer_Pos244 = No_Token_Index;

   List_Pos35 := Defer_Pos244;
   Lst_Cpos35 := List_Pos35;

   Tmp_List35.Nodes.Append (Defer_Res244);

      
--  BEGIN <Token(<WithText Comma>, ) (root of 'type_ref') at parser.lkt:211:47>

Token_Res250 := Lst_Cpos35;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res250));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos250 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Lst_Cpos35 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Lst_Cpos35,
             Expected_Token_Id => Lkt_Comma,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos250 := Lst_Cpos35 + 1;
   end if;
end;

--  END <Token(<WithText Comma>, ) (root of 'type_ref') at parser.lkt:211:47>


      exit when Token_Pos250 = No_Token_Index;

      Lst_Cpos35 := Token_Pos250;

end loop;


declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List35.Nodes.Length;
begin
   List_Res35 := Allocate_Type_Ref_List (Parser.Mem_Pool);

   if Count > 0 then
      Token_Start := Row_Pos157;
      Token_End := (if Lst_Cpos35 = Row_Pos157
                    then Row_Pos157
                    else List_Pos35 - 1);

   else
      Token_Start := Token_Index'Max (Row_Pos157, 1);
      Token_End := No_Token_Index;
   end if;

   Initialize
     (Self              => List_Res35,
      Kind              => Lkt_Type_Ref_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res35,
      Parser => Parser,
      Count  => Count);

   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List35.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res35.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;

Release_Parse_List (Parser, Tmp_List35);

--  END <List (root of 'type_ref') at parser.lkt:211:31>




if List_Pos35 /= No_Token_Index then

   Row_Pos157 := List_Pos35;

else
   Row_Pos157 := No_Token_Index;
   goto Exit_Row157_0;

end if;


--  BEGIN <Token(<WithText RPar>, ) (root of 'type_ref') at parser.lkt:211:52>

Token_Res251 := Row_Pos157;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res251));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos251 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos157 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos157,
             Expected_Token_Id => Lkt_R_Par,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos251 := Row_Pos157 + 1;
   end if;
end;

--  END <Token(<WithText RPar>, ) (root of 'type_ref') at parser.lkt:211:52>




if Token_Pos251 /= No_Token_Index then

   Row_Pos157 := Token_Pos251;

else
   Row_Pos157 := No_Token_Index;
   goto Exit_Row157_0;

end if;


--  BEGIN <Token(<WithText RightArrow>, ) (root of 'type_ref') at parser.lkt:211:56>

Token_Res252 := Row_Pos157;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res252));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Right_Arrow)
   then
       Token_Pos252 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos157 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos157,
             Expected_Token_Id => Lkt_Right_Arrow,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos252 := Row_Pos157 + 1;
   end if;
end;

--  END <Token(<WithText RightArrow>, ) (root of 'type_ref') at parser.lkt:211:56>




if Token_Pos252 /= No_Token_Index then

   Row_Pos157 := Token_Pos252;

else
   Row_Pos157 := No_Token_Index;
   goto Exit_Row157_0;

end if;


--  BEGIN <Defer (for 'type_ref') at parser.lkt:211:61>

Defer_Res245 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos157);
Defer_Pos245 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:211:61>




if Defer_Pos245 /= No_Token_Index then

   Row_Pos157 := Defer_Pos245;

else
   Row_Pos157 := No_Token_Index;
   goto Exit_Row157_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row157_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'type_ref') at ???>



if Row_Pos157 /= No_Token_Index then

   Transform_Res133 := Allocate_Function_Type_Ref (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res133,
      Kind => Lkt_Function_Type_Ref,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos157 = Pos
                            then No_Token_Index
                            else Row_Pos157 - 1));

      
      Initialize_Fields_For_Function_Type_Ref
        (Self => Transform_Res133,
         Function_Type_Ref_F_Args_Types => List_Res35,
         Function_Type_Ref_F_Return_Type => Defer_Res245);

         if List_Res35 /= null and then Is_Incomplete (List_Res35) then
            Transform_Res133.Last_Attempted_Child := 0;
         elsif List_Res35 /= null and then not Is_Ghost (List_Res35) then
            Transform_Res133.Last_Attempted_Child := -1;
         end if;
         if Defer_Res245 /= null and then Is_Incomplete (Defer_Res245) then
            Transform_Res133.Last_Attempted_Child := 0;
         elsif Defer_Res245 /= null and then not Is_Ghost (Defer_Res245) then
            Transform_Res133.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos157 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags133);
end if;

--  END <Transform(<CompiledType BareFunctionTypeRef>) (root of 'type_ref') at parser.lkt:211:11>

    if Row_Pos157 /= No_Token_Index then
        Or_Pos33 := Row_Pos157;
        Or_Res33 := Transform_Res133;
        goto Exit_Or33;
    end if;
<<Exit_Or33>>

--  END <Or (root of 'type_ref') at parser.lkt:208:17>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Type_Ref_Or_Parse0_Memo,
      Or_Pos33 /= No_Token_Index,
      Or_Res33,
      Pos,
      Or_Pos33);


   Parser.Current_Pos := Or_Pos33;

   return Or_Res33;
end Type_Ref_Or_Parse0;

   


function Type_Ref_Id_Predicate_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ref_Id
is
   use Bare_Ref_Id_Memos;

      Defer_Pos246 :
            Token_Index
               := No_Token_Index;
      Defer_Res246 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Predicate_Pos0 :
            Token_Index
               := No_Token_Index;
      Predicate_Res0 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Type_Ref_Id_Predicate_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Predicate_Res0 := M.Instance;
      return Predicate_Res0;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Predicate_Res0;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Predicate (root of 'type_ref_id') at parser.lkt:8:20>


--  BEGIN <Defer (for 'ref_id') at parser.lkt:8:20>

Defer_Res246 :=
   Ref_Id_Transform_Parse0 (Parser, Pos);
Defer_Pos246 := Parser.Current_Pos;

--  END <Defer (for 'ref_id') at parser.lkt:8:20>


if Defer_Res246 /= null
   and then Liblktlang.Implementation.Extensions.Id_P_Is_Type_Name (Defer_Res246)
then
    Predicate_Res0 := Defer_Res246;
    Predicate_Pos0 := Defer_Pos246;
else
    Predicate_Pos0 := No_Token_Index;
    Predicate_Res0 := null;

    if Parser.Last_Fail.Pos <= Pos then
       Parser.Last_Fail :=
         (Kind           => Custom_Fail,
          Pos            => Pos,
          Custom_Message => Generic_Parsing_Error_Message_Access);
    end if;
end if;

--  END <Predicate (root of 'type_ref_id') at parser.lkt:8:20>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Type_Ref_Id_Predicate_Parse0_Memo,
      Predicate_Pos0 /= No_Token_Index,
      Predicate_Res0,
      Pos,
      Predicate_Pos0);


   Parser.Current_Pos := Predicate_Pos0;

   return Predicate_Res0;
end Type_Ref_Id_Predicate_Parse0;

   


function Val_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Val_Decl
is
   use Bare_Val_Decl_Memos;

      Row_Pos158 :
            Token_Index
               := No_Token_Index;
      Token_Pos253 :
            Token_Index
               := No_Token_Index;
      Token_Res253 :
            Token_Index
               := No_Token_Index;
      Defer_Pos247 :
            Token_Index
               := No_Token_Index;
      Defer_Res247 :
            Bare_Def_Id
               := No_Bare_Lkt_Node;
      Row_Pos159 :
            Token_Index
               := No_Token_Index;
      Token_Pos254 :
            Token_Index
               := No_Token_Index;
      Token_Res254 :
            Token_Index
               := No_Token_Index;
      Defer_Pos248 :
            Token_Index
               := No_Token_Index;
      Defer_Res248 :
            Bare_Type_Ref
               := No_Bare_Lkt_Node;
      Token_Pos255 :
            Token_Index
               := No_Token_Index;
      Token_Res255 :
            Token_Index
               := No_Token_Index;
      Defer_Pos249 :
            Token_Index
               := No_Token_Index;
      Defer_Res249 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res134 :
            Bare_Val_Decl
               := No_Bare_Lkt_Node;
      Transform_Diags134 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Val_Decl_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res134 := M.Instance;
      return Transform_Res134;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res134;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareValDecl>) (root of 'val_decl') at parser.lkt:216:17>

Transform_Diags134 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'val_decl') at ???>

Row_Pos158 := Pos;



--  BEGIN <Token(<WithText ValKw>, ) (root of 'val_decl') at parser.lkt:216:25>

Token_Res253 := Row_Pos158;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res253));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Val_Kw)
   then
       Token_Pos253 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos158 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos158,
             Expected_Token_Id => Lkt_Val_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos253 := Row_Pos158 + 1;
   end if;
end;

--  END <Token(<WithText ValKw>, ) (root of 'val_decl') at parser.lkt:216:25>




if Token_Pos253 /= No_Token_Index then

   Row_Pos158 := Token_Pos253;

else
   Row_Pos158 := No_Token_Index;
   goto Exit_Row158_0;

end if;


--  BEGIN <Defer (for 'def_id') at parser.lkt:216:31>

Defer_Res247 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos158);
Defer_Pos247 := Parser.Current_Pos;

--  END <Defer (for 'def_id') at parser.lkt:216:31>




if Defer_Pos247 /= No_Token_Index then

   Row_Pos158 := Defer_Pos247;

else
   Row_Pos158 := No_Token_Index;
   goto Exit_Row158_0;

end if;


--  BEGIN <Opt (root of 'val_decl') at parser.lkt:216:38>












--  BEGIN <_Extract (root of 'val_decl') at parser.lkt:216:39>

--  BEGIN <_Row (root of 'val_decl') at ???>

Row_Pos159 := Row_Pos158;



--  BEGIN <Token(<WithText Colon>, ) (root of 'val_decl') at parser.lkt:216:44>

Token_Res254 := Row_Pos159;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res254));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos254 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos159 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos159,
             Expected_Token_Id => Lkt_Colon,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos254 := Row_Pos159 + 1;
   end if;
end;

--  END <Token(<WithText Colon>, ) (root of 'val_decl') at parser.lkt:216:44>




if Token_Pos254 /= No_Token_Index then

   Row_Pos159 := Token_Pos254;

else
   Row_Pos159 := No_Token_Index;
   goto Exit_Row159_0;

end if;


--  BEGIN <Defer (for 'type_ref') at parser.lkt:216:48>

Defer_Res248 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos159);
Defer_Pos248 := Parser.Current_Pos;

--  END <Defer (for 'type_ref') at parser.lkt:216:48>




if Defer_Pos248 /= No_Token_Index then

   Row_Pos159 := Defer_Pos248;

else
   Row_Pos159 := No_Token_Index;
   goto Exit_Row159_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row159_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'val_decl') at ???>

--  END <_Extract (root of 'val_decl') at parser.lkt:216:39>


if Row_Pos159 = No_Token_Index then

         
   Defer_Res248 := No_Bare_Lkt_Node;



       
   Row_Pos159 := Row_Pos158;



end if;

--  END <Opt (root of 'val_decl') at parser.lkt:216:38>




if Row_Pos159 /= No_Token_Index then

   Row_Pos158 := Row_Pos159;

else
   Row_Pos158 := No_Token_Index;
   goto Exit_Row158_0;

end if;


--  BEGIN <Token(<WithText Equal>, ) (root of 'val_decl') at parser.lkt:216:58>

Token_Res255 := Row_Pos158;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res255));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Equal)
   then
       Token_Pos255 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos158 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos158,
             Expected_Token_Id => Lkt_Equal,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos255 := Row_Pos158 + 1;
   end if;
end;

--  END <Token(<WithText Equal>, ) (root of 'val_decl') at parser.lkt:216:58>




if Token_Pos255 /= No_Token_Index then

   Row_Pos158 := Token_Pos255;

else
   Row_Pos158 := No_Token_Index;
   goto Exit_Row158_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:216:62>

Defer_Res249 :=
   Expr_Or_Parse1 (Parser, Row_Pos158);
Defer_Pos249 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:216:62>




if Defer_Pos249 /= No_Token_Index then

   Row_Pos158 := Defer_Pos249;

else
   Row_Pos158 := No_Token_Index;
   goto Exit_Row158_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row158_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'val_decl') at ???>



if Row_Pos158 /= No_Token_Index then

   Transform_Res134 := Allocate_Val_Decl (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res134,
      Kind => Lkt_Val_Decl,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos158 = Pos
                            then No_Token_Index
                            else Row_Pos158 - 1));

      
      Initialize_Fields_For_Val_Decl
        (Self => Transform_Res134,
         Val_Decl_F_Syn_Name => Defer_Res247,
         Val_Decl_F_Decl_Type => Defer_Res248,
         Val_Decl_F_Expr => Defer_Res249);

         if Defer_Res247 /= null and then Is_Incomplete (Defer_Res247) then
            Transform_Res134.Last_Attempted_Child := 0;
         elsif Defer_Res247 /= null and then not Is_Ghost (Defer_Res247) then
            Transform_Res134.Last_Attempted_Child := -1;
         end if;
         if Defer_Res248 /= null and then Is_Incomplete (Defer_Res248) then
            Transform_Res134.Last_Attempted_Child := 0;
         elsif Defer_Res248 /= null and then not Is_Ghost (Defer_Res248) then
            Transform_Res134.Last_Attempted_Child := -1;
         end if;
         if Defer_Res249 /= null and then Is_Incomplete (Defer_Res249) then
            Transform_Res134.Last_Attempted_Child := 0;
         elsif Defer_Res249 /= null and then not Is_Ghost (Defer_Res249) then
            Transform_Res134.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos158 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags134);
end if;

--  END <Transform(<CompiledType BareValDecl>) (root of 'val_decl') at parser.lkt:216:17>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Val_Decl_Transform_Parse0_Memo,
      Row_Pos158 /= No_Token_Index,
      Transform_Res134,
      Pos,
      Row_Pos158);


   Parser.Current_Pos := Row_Pos158;

   return Transform_Res134;
end Val_Decl_Transform_Parse0;

   


function Var_Bind_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Var_Bind
is
   use Bare_Var_Bind_Memos;

      Row_Pos160 :
            Token_Index
               := No_Token_Index;
      Token_Pos256 :
            Token_Index
               := No_Token_Index;
      Token_Res256 :
            Token_Index
               := No_Token_Index;
      Defer_Pos250 :
            Token_Index
               := No_Token_Index;
      Defer_Res250 :
            Bare_Ref_Id
               := No_Bare_Lkt_Node;
      Token_Pos257 :
            Token_Index
               := No_Token_Index;
      Token_Res257 :
            Token_Index
               := No_Token_Index;
      Defer_Pos251 :
            Token_Index
               := No_Token_Index;
      Defer_Res251 :
            Bare_Expr
               := No_Bare_Lkt_Node;
      Transform_Res135 :
            Bare_Var_Bind
               := No_Bare_Lkt_Node;
      Transform_Diags135 :
            Ada.Containers.Count_Type;


   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memo_Entry := Get (PP.Var_Bind_Transform_Parse0_Memo, Pos);

begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Transform_Res135 := M.Instance;
      return Transform_Res135;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      return Transform_Res135;
   end if;


   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------

   
--  BEGIN <Transform(<CompiledType BareVarBind>) (root of 'var_bind') at parser.lkt:218:17>

Transform_Diags135 := Parser.Diagnostics.Length;


--  BEGIN <_Row (root of 'var_bind') at ???>

Row_Pos160 := Pos;



--  BEGIN <Token(<WithText BindKw>, ) (root of 'var_bind') at parser.lkt:218:25>

Token_Res256 := Row_Pos160;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res256));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Bind_Kw)
   then
       Token_Pos256 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos160 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos160,
             Expected_Token_Id => Lkt_Bind_Kw,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos256 := Row_Pos160 + 1;
   end if;
end;

--  END <Token(<WithText BindKw>, ) (root of 'var_bind') at parser.lkt:218:25>




if Token_Pos256 /= No_Token_Index then

   Row_Pos160 := Token_Pos256;

else
   Row_Pos160 := No_Token_Index;
   goto Exit_Row160_0;

end if;


--  BEGIN <Defer (for 'ref_id') at parser.lkt:218:32>

Defer_Res250 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos160);
Defer_Pos250 := Parser.Current_Pos;

--  END <Defer (for 'ref_id') at parser.lkt:218:32>




if Defer_Pos250 /= No_Token_Index then

   Row_Pos160 := Defer_Pos250;

else
   Row_Pos160 := No_Token_Index;
   goto Exit_Row160_0;

end if;


--  BEGIN <Token(<WithText Equal>, ) (root of 'var_bind') at parser.lkt:218:39>

Token_Res257 := Row_Pos160;

declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res257));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Equal)
   then
       Token_Pos257 := No_Token_Index;

       if Parser.Last_Fail.Pos <= Row_Pos160 then
          Parser.Last_Fail :=
            (Kind              => Token_Fail,
             Pos               => Row_Pos160,
             Expected_Token_Id => Lkt_Equal,
             Found_Token_Id    => To_Token_Kind (T.Kind));
       end if;
   else
          Token_Pos257 := Row_Pos160 + 1;
   end if;
end;

--  END <Token(<WithText Equal>, ) (root of 'var_bind') at parser.lkt:218:39>




if Token_Pos257 /= No_Token_Index then

   Row_Pos160 := Token_Pos257;

else
   Row_Pos160 := No_Token_Index;
   goto Exit_Row160_0;

end if;


--  BEGIN <Defer (for 'expr') at parser.lkt:218:43>

Defer_Res251 :=
   Expr_Or_Parse1 (Parser, Row_Pos160);
Defer_Pos251 := Parser.Current_Pos;

--  END <Defer (for 'expr') at parser.lkt:218:43>




if Defer_Pos251 /= No_Token_Index then

   Row_Pos160 := Defer_Pos251;

else
   Row_Pos160 := No_Token_Index;
   goto Exit_Row160_0;

end if;

pragma Warnings (Off, "referenced");
<<Exit_Row160_0>>
pragma Warnings (On, "referenced");

--  END <_Row (root of 'var_bind') at ???>



if Row_Pos160 /= No_Token_Index then

   Transform_Res135 := Allocate_Var_Bind (Parser.Mem_Pool);

   Initialize
     (Self => Transform_Res135,
      Kind => Lkt_Var_Bind,
      Unit => Parser.Unit,

      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos160 = Pos
                            then No_Token_Index
                            else Row_Pos160 - 1));

      
      Initialize_Fields_For_Var_Bind
        (Self => Transform_Res135,
         Var_Bind_F_Name => Defer_Res250,
         Var_Bind_F_Expr => Defer_Res251);

         if Defer_Res250 /= null and then Is_Incomplete (Defer_Res250) then
            Transform_Res135.Last_Attempted_Child := 0;
         elsif Defer_Res250 /= null and then not Is_Ghost (Defer_Res250) then
            Transform_Res135.Last_Attempted_Child := -1;
         end if;
         if Defer_Res251 /= null and then Is_Incomplete (Defer_Res251) then
            Transform_Res135.Last_Attempted_Child := 0;
         elsif Defer_Res251 /= null and then not Is_Ghost (Defer_Res251) then
            Transform_Res135.Last_Attempted_Child := -1;
         end if;


elsif Row_Pos160 = No_Token_Index then
   Parser.Diagnostics.Set_Length (Transform_Diags135);
end if;

--  END <Transform(<CompiledType BareVarBind>) (root of 'var_bind') at parser.lkt:218:17>


   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------


   Set
     (PP.Var_Bind_Transform_Parse0_Memo,
      Row_Pos160 /= No_Token_Index,
      Transform_Res135,
      Pos,
      Row_Pos160);


   Parser.Current_Pos := Row_Pos160;

   return Transform_Res135;
end Var_Bind_Transform_Parse0;


   -----------
   -- Reset --
   -----------

   procedure Reset (Parser : in out Parser_Type) is
      New_Parser : Parser_Type;
      --  We create this new parser instance to leverage creation of default
      --  values, so as to not repeat them.

      PP : Parser_Private_Part;
   begin
      --  We just keep the private part, to not have to reallocate it
      New_Parser.Private_Part := Parser.Private_Part;

      --  And then reset everything else
      Parser := New_Parser;

      --  Reset the memo tables in the private part
      PP := +Parser.Private_Part;
         Bare_Expr_Memos.Clear (PP.Arith_1_Or_Parse1_Memo);
         Bare_Expr_Memos.Clear (PP.Arith_2_Or_Parse1_Memo);
         Bare_Expr_Memos.Clear (PP.Arith_3_Or_Parse1_Memo);
         Bare_Array_Literal_Memos.Clear (PP.Array_Literal_Transform_Parse0_Memo);
         Bare_Decl_Memos.Clear (PP.Bare_Decl_Or_Parse0_Memo);
         Bare_Expr_Memos.Clear (PP.Basic_Expr_Or_Parse0_Memo);
         Bare_Expr_Memos.Clear (PP.Basic_Name_Or_Parse0_Memo);
         Bare_Big_Num_Lit_Memos.Clear (PP.Big_Num_Lit_Transform_Parse0_Memo);
         Bare_Block_String_Lit_Memos.Clear (PP.Block_String_Lit_Transform_Parse1_Memo);
         Bare_Block_Expr_Memos.Clear (PP.Block_Transform_Parse0_Memo);
         Bare_Expr_Memos.Clear (PP.Callable_Ref_Or_Parse0_Memo);
         Bare_Char_Lit_Memos.Clear (PP.Char_Lit_Transform_Parse0_Memo);
         Bare_Decl_Annotation_Params_Memos.Clear (PP.Decl_Annotation_Params_Opt_Parse0_Memo);
         Bare_Decl_Annotation_Memos.Clear (PP.Decl_Annotation_Transform_Parse0_Memo);
         Bare_Decl_Block_Memos.Clear (PP.Decl_Block_List_Parse0_Memo);
         Bare_Full_Decl_Memos.Clear (PP.Decl_Transform_Parse0_Memo);
         Bare_Full_Decl_List_Memos.Clear (PP.Decls_List_Parse0_Memo);
         Bare_Def_Id_Memos.Clear (PP.Def_Id_Transform_Parse0_Memo);
         Bare_String_Lit_Memos.Clear (PP.Doc_Opt_Parse0_Memo);
         Bare_Dyn_Var_Decl_Memos.Clear (PP.Dynvar_Decl_Transform_Parse0_Memo);
         Bare_Enum_Lit_Decl_Memos.Clear (PP.Enum_Lit_Decl_Transform_Parse0_Memo);
         Bare_Call_Expr_Memos.Clear (PP.Env_Spec_Action_Transform_Parse1_Memo);
         Bare_Env_Spec_Decl_Memos.Clear (PP.Env_Spec_Decl_Transform_Parse1_Memo);
         Bare_Expr_Memos.Clear (PP.Eq_Or_Parse1_Memo);
         Bare_Expr_Memos.Clear (PP.Expr_Or_Parse1_Memo);
         Bare_Field_Decl_Memos.Clear (PP.Field_Decl_Transform_Parse0_Memo);
         Bare_Fun_Arg_Decl_Memos.Clear (PP.Fun_Arg_Decl_Transform_Parse0_Memo);
         Bare_Fun_Arg_Decl_List_Memos.Clear (PP.Fun_Arg_List_List_Parse0_Memo);
         Bare_Fun_Decl_Memos.Clear (PP.Fun_Decl_Transform_Parse0_Memo);
         Bare_Generic_Decl_Memos.Clear (PP.Generic_Decl_Transform_Parse0_Memo);
         Bare_Full_Decl_Memos.Clear (PP.Generic_Formal_Type_Transform_Parse1_Memo);
         Bare_Grammar_Cut_Memos.Clear (PP.Grammar_Cut_Transform_Parse0_Memo);
         Bare_Grammar_Decl_Memos.Clear (PP.Grammar_Decl_Transform_Parse0_Memo);
         Bare_Grammar_Discard_Memos.Clear (PP.Grammar_Discard_Expr_Transform_Parse0_Memo);
         Bare_Grammar_Expr_Memos.Clear (PP.Grammar_Expr_Or_Parse0_Memo);
         Bare_Grammar_Implicit_Pick_Memos.Clear (PP.Grammar_Implicit_Pick_Transform_Parse0_Memo);
         Bare_Grammar_List_Memos.Clear (PP.Grammar_List_Expr_Transform_Parse3_Memo);
         Bare_Grammar_List_Sep_Memos.Clear (PP.Grammar_List_Sep_Transform_Parse0_Memo);
         Bare_Grammar_Null_Memos.Clear (PP.Grammar_Null_Transform_Parse0_Memo);
         Bare_Grammar_Expr_Memos.Clear (PP.Grammar_Opt_Error_Or_Parse0_Memo);
         Bare_Grammar_Expr_Memos.Clear (PP.Grammar_Opt_Or_Parse0_Memo);
         Bare_Grammar_Or_Expr_Memos.Clear (PP.Grammar_Or_Expr_Transform_Parse0_Memo);
         Bare_Grammar_Pick_Memos.Clear (PP.Grammar_Pick_Transform_Parse0_Memo);
         Bare_Grammar_Expr_Memos.Clear (PP.Grammar_Primary_Or_Parse0_Memo);
         Bare_Grammar_Rule_Ref_Memos.Clear (PP.Grammar_Rule_Ref_Transform_Parse0_Memo);
         Bare_Grammar_Rule_Decl_Memos.Clear (PP.Grammar_Rule_Transform_Parse0_Memo);
         Bare_Grammar_Skip_Memos.Clear (PP.Grammar_Skip_Transform_Parse0_Memo);
         Bare_Grammar_Stop_Cut_Memos.Clear (PP.Grammar_Stopcut_Transform_Parse0_Memo);
         Bare_Token_Ref_Memos.Clear (PP.Grammar_Token_Transform_Parse0_Memo);
         Bare_Id_Memos.Clear (PP.Id_Transform_Parse0_Memo);
         Bare_If_Expr_Memos.Clear (PP.If_Expr_Transform_Parse1_Memo);
         Bare_Import_Memos.Clear (PP.Import_Stmt_Transform_Parse1_Memo);
         Bare_Import_List_Memos.Clear (PP.Imports_List_Parse0_Memo);
         Bare_Expr_Memos.Clear (PP.Isa_Or_Primary_Or_Parse0_Memo);
         Bare_Lambda_Arg_Decl_Memos.Clear (PP.Lambda_Arg_Decl_Transform_Parse0_Memo);
         Bare_Lambda_Arg_Decl_List_Memos.Clear (PP.Lambda_Arg_List_List_Parse0_Memo);
         Bare_Lambda_Expr_Memos.Clear (PP.Lambda_Expr_Transform_Parse0_Memo);
         Bare_Base_Lexer_Case_Rule_Alt_Memos.Clear (PP.Lexer_Case_Alt_Or_Parse0_Memo);
         Bare_Lexer_Case_Rule_Memos.Clear (PP.Lexer_Case_Rule_Transform_Parse0_Memo);
         Bare_Lexer_Case_Rule_Send_Memos.Clear (PP.Lexer_Case_Send_Transform_Parse0_Memo);
         Bare_Lexer_Decl_Memos.Clear (PP.Lexer_Decl_Transform_Parse0_Memo);
         Bare_Full_Decl_Memos.Clear (PP.Lexer_Family_Decl_Transform_Parse1_Memo);
         Bare_Lkt_Node_Memos.Clear (PP.Lexer_Rule_Or_Parse0_Memo);
         Bare_Logic_Propagate_Call_Memos.Clear (PP.Logic_Propagate_Call_Transform_Parse0_Memo);
         Bare_Langkit_Root_Memos.Clear (PP.Main_Rule_Transform_Parse0_Memo);
         Bare_Match_Expr_Memos.Clear (PP.Match_Expr_Transform_Parse2_Memo);
         Bare_Null_Lit_Memos.Clear (PP.Null_Lit_Transform_Parse0_Memo);
         Bare_Num_Lit_Memos.Clear (PP.Num_Lit_Transform_Parse0_Memo);
         Bare_Param_Memos.Clear (PP.Param_Transform_Parse0_Memo);
         Bare_Param_List_Memos.Clear (PP.Params_List_Parse0_Memo);
         Bare_Parse_Node_Expr_Memos.Clear (PP.Parse_Node_Expr_Transform_Parse0_Memo);
         Bare_Expr_Memos.Clear (PP.Primary_Or_Parse0_Memo);
         Bare_Raise_Expr_Memos.Clear (PP.Raise_Expr_Transform_Parse0_Memo);
         Bare_Ref_Id_Memos.Clear (PP.Ref_Id_Transform_Parse0_Memo);
         Bare_Expr_Memos.Clear (PP.Rel_Or_Parse0_Memo);
         Bare_String_Lit_Memos.Clear (PP.String_Lit_Or_Parse0_Memo);
         Bare_Expr_Memos.Clear (PP.Term_Or_Parse0_Memo);
         Bare_Token_Lit_Memos.Clear (PP.Token_Literal_Transform_Parse0_Memo);
         Bare_Token_No_Case_Lit_Memos.Clear (PP.Token_No_Case_Literal_Transform_Parse0_Memo);
         Bare_Token_Pattern_Lit_Memos.Clear (PP.Token_Pattern_Literal_Transform_Parse0_Memo);
         Bare_Grammar_Expr_Memos.Clear (PP.Token_Pattern_Or_Parse0_Memo);
         Bare_Try_Expr_Memos.Clear (PP.Try_Expr_Transform_Parse0_Memo);
         Bare_Named_Type_Decl_Memos.Clear (PP.Type_Decl_Or_Parse0_Memo);
         Bare_Expr_Memos.Clear (PP.Type_Expr_Or_Parse0_Memo);
         Bare_Type_Ref_List_Memos.Clear (PP.Type_List_List_Parse0_Memo);
         Bare_Dot_Expr_Memos.Clear (PP.Type_Member_Ref_Transform_Parse0_Memo);
         Bare_Ref_Id_Memos.Clear (PP.Type_Ref_Id_Predicate_Parse0_Memo);
         Bare_Type_Ref_Memos.Clear (PP.Type_Ref_Or_Parse0_Memo);
         Bare_Val_Decl_Memos.Clear (PP.Val_Decl_Transform_Parse0_Memo);
         Bare_Var_Bind_Memos.Clear (PP.Var_Bind_Transform_Parse0_Memo);
   end Reset;

   -------------
   -- Destroy --
   -------------

   procedure Destroy (Parser : in out Parser_Type) is
      procedure Free is new Ada.Unchecked_Deallocation
        (Parser_Private_Part_Type, Parser_Private_Part);
      procedure Free is new Ada.Unchecked_Deallocation
        (Free_Parse_List_Record, Free_Parse_List);

      PP  : Parser_Private_Part := +Parser.Private_Part;
      Cur : Free_Parse_List renames PP.Parse_Lists;
   begin
      while Cur /= null loop
         declare
            Next : constant Free_Parse_List := Cur.Next;
         begin
            Cur.Nodes.Destroy;
            Free (Cur);
            Cur := Next;
         end;
      end loop;
      Free (PP);
   end Destroy;

   ----------------
   -- Initialize --
   ----------------

   procedure Initialize (Parser : in out Parser_Type) is
      PP : constant Parser_Private_Part :=
        new Parser_Private_Part_Type'(others => <>);
   begin
      Parser.Private_Part := +PP;
   end Initialize;

   --------------------
   -- Get_Parse_List --
   --------------------

   function Get_Parse_List (Parser : Parser_Type) return Free_Parse_List is
      PP     : constant Parser_Private_Part := +Parser.Private_Part;
      Lists  : Free_Parse_List renames PP.Parse_Lists;
      Result : Free_Parse_List;
   begin
      if Lists = null then
         Result := new Free_Parse_List_Record;

      else
         Result := Lists;
         Lists := Lists.Next;
      end if;

      return Result;
   end Get_Parse_List;

   ------------------------
   -- Release_Parse_List --
   ------------------------

   procedure Release_Parse_List
     (Parser : Parser_Type; List : in out Free_Parse_List)
   is
      PP    : constant Parser_Private_Part := +Parser.Private_Part;
      Lists : Free_Parse_List renames PP.Parse_Lists;
   begin
      List.Nodes.Clear;
      List.Next := Lists;
      Lists := List;
      List := null;
   end Release_Parse_List;

end Liblktlang.Parsers_Impl;
