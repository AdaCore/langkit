










with Ada.Containers;                  use Ada.Containers;
with Ada.Containers.Hashed_Maps;
with Ada.Containers.Vectors;
with Ada.Directories;
with Ada.Exceptions;
with Ada.Finalization;
with Ada.Strings.Unbounded;           use Ada.Strings.Unbounded;
with Ada.Strings.Wide_Wide_Unbounded; use Ada.Strings.Wide_Wide_Unbounded;

pragma Warnings (Off, "internal");
with Ada.Strings.Wide_Wide_Unbounded.Aux;
use Ada.Strings.Wide_Wide_Unbounded.Aux;
pragma Warnings (On, "internal");

with Ada.Text_IO;                     use Ada.Text_IO;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
with System;
with System.Memory;

with GNAT.Task_Lock;
with GNAT.Traceback.Symbolic;

with GNATCOLL.Traces;

with Liblktlang_Support.Adalog.Debug;
with Liblktlang_Support.Generic_API.Analysis;
with Liblktlang_Support.Generic_API.Introspection;
with Liblktlang_Support.Hashes; use Liblktlang_Support.Hashes;
with Liblktlang_Support.Images; use Liblktlang_Support.Images;
with Liblktlang_Support.Names;  use Liblktlang_Support.Names;
with Liblktlang_Support.Relative_Get;

with Liblktlang.Private_Converters;
use Liblktlang.Private_Converters;

pragma Warnings (Off, "referenced");

          with Liblktlang.Default_Provider;
          with Liblktlang.Implementation.Extensions;
            use Liblktlang.Implementation.Extensions;

pragma Warnings (On, "referenced");



package body Liblktlang.Implementation is

   use Precomputed_Symbols;

   pragma Warnings (Off, "has no effect");
   use Solver;
   pragma Warnings (On, "has no effect");

   package Context_Vectors is new Ada.Containers.Vectors
     (Index_Type   => Positive,
      Element_Type => Internal_Context);

   type Contexts_Destructor is limited
      new Ada.Finalization.Limited_Controlled with null record;
   overriding procedure Finalize (CD : in out Contexts_Destructor);
   --  Helper to destroy all contexts when terminating the process

   package Context_Pool is

      procedure Acquire (Context : out Internal_Context)
         with Post => Context /= null;
      --  If a context is free for reuse, increment its serial number and
      --  return it. Otherwise, allocate a new one. In any case, this does not
      --  initialize it, except for the Serial_Number field.

      procedure Release (Context : in out Internal_Context)
         with Pre  => Context /= null,
              Post => Context = null;
      --  Tag Context as free for reuse and set it to null

      procedure Free;
      --  Free all contexts in this pool. Intended to be called only when the
      --  process is terminating, to avoid reported memory leaks.

   private

      Available : Context_Vectors.Vector;
      --  List of allocated contexts that can be re-used right now

      CD : Contexts_Destructor with Unreferenced;
      --  Singleton whose only purpose is to free all contexts in Available
      --  when finalized.

   end Context_Pool;

   procedure Register_Destroyable_Helper
     (Unit    : Internal_Unit;
      Object  : System.Address;
      Destroy : Destroy_Procedure);
   --  Common underlying implementation for Register_Destroyable_Gen

   pragma Warnings (Off, "referenced");
   function Construct_Entity_Array
     (V : AST_Envs.Entity_Vectors.Vector) return Internal_Entity_Array_Access;
   pragma Warnings (On, "referenced");

   procedure Reset_Envs_Caches (Unit : Internal_Unit);
   --  Reset the env caches of all lexical environments created for ``Unit``

   procedure Destroy (Env : in out Lexical_Env_Access);

   function Snaps_At_Start (Self : Bare_Lkt_Node) return Boolean;
   function Snaps_At_End (Self : Bare_Lkt_Node) return Boolean;

   --  Those maps are used to give unique ids to lexical envs while pretty
   --  printing them.

   package Address_To_Id_Maps is new Ada.Containers.Hashed_Maps
     (Lexical_Env, Integer, Hash, "=");

   type Dump_Lexical_Env_State is record
      Env_Ids : Address_To_Id_Maps.Map;
      --  Mapping: Lexical_Env -> Integer, used to remember which unique Ids we
      --  assigned to the lexical environments we found.

      Next_Id : Positive := 1;
      --  Id to assign to the next unknown lexical environment

      Root_Env : Lexical_Env;
      --  Lexical environment we consider a root (this is the Root_Scope from
      --  the current analysis context), or null if unknown.
   end record;
   --  Holder for the state of lexical environment dumpers

   function Get_Env_Id
     (E : Lexical_Env; State : in out Dump_Lexical_Env_State) return String;
   --  If E is known, return its unique Id from State. Otherwise, assign it a
   --  new unique Id and return it.

   procedure Print
     (Node        : Liblktlang_Support.Generic_API.Analysis.Lk_Node;
      Show_Slocs  : Boolean;
      Line_Prefix : String := "");
   --  Helper for the public overload, but working on the generic API node type

   ------------------------
   -- Precomputed_Symbol --
   ------------------------

   pragma Warnings (Off, "referenced");
   function Precomputed_Symbol
     (Index : Precomputed_Symbol_Index) return Text_Type is
   pragma Warnings (On, "referenced");
   begin
         declare
            Raw_Text : constant Text_Type := (case Index is
            
               when Precomputed_Sym_Abstract => "abstract",
               when Precomputed_Sym_All => "all",
               when Precomputed_Sym_Analysisunit => "AnalysisUnit",
               when Precomputed_Sym_Any => "any",
               when Precomputed_Sym_Array => "Array",
               when Precomputed_Sym_As => "as",
               when Precomputed_Sym_As_Bool => "as_bool",
               when Precomputed_Sym_Astlist => "ASTList",
               when Precomputed_Sym_Basictrait => "BasicTrait",
               when Precomputed_Sym_Bigint => "BigInt",
               when Precomputed_Sym_Bool => "Bool",
               when Precomputed_Sym_Builder => "builder",
               when Precomputed_Sym_Call => "__call__",
               when Precomputed_Sym_Char => "Char",
               when Precomputed_Sym_Dedent => "dedent",
               when Precomputed_Sym_Domain => "domain",
               when Precomputed_Sym_Dont_Skip => "dont_skip",
               when Precomputed_Sym_Entity => "Entity",
               when Precomputed_Sym_Env_Spec => "env_spec",
               when Precomputed_Sym_Envaction => "EnvAction",
               when Precomputed_Sym_Equation => "Equation",
               when Precomputed_Sym_Errornode => "ErrorNode",
               when Precomputed_Sym_False => "false",
               when Precomputed_Sym_Family => "family",
               when Precomputed_Sym_Ignore_Constructor_Arg => "ignore_constructor_arg",
               when Precomputed_Sym_Indent => "indent",
               when Precomputed_Sym_Indexable => "Indexable",
               when Precomputed_Sym_Int => "Int",
               when Precomputed_Sym_Internal => "__internal",
               when Precomputed_Sym_Invalid => "invalid",
               when Precomputed_Sym_Iterator => "Iterator",
               when Precomputed_Sym_Keep => "keep",
               when Precomputed_Sym_Lazy => "lazy",
               when Precomputed_Sym_List => "list",
               when Precomputed_Sym_List_Elements => "list_elements",
               when Precomputed_Sym_Logicvar => "LogicVar",
               when Precomputed_Sym_Metadata => "Metadata",
               when Precomputed_Sym_Metadata_46 => "metadata",
               when Precomputed_Sym_Newline => "newline",
               when Precomputed_Sym_No_Case => "no_case",
               when Precomputed_Sym_Node => "Node",
               when Precomputed_Sym_Node_49 => "node",
               when Precomputed_Sym_Nodebuilder => "NodeBuilder",
               when Precomputed_Sym_Null_Field => "null_field",
               when Precomputed_Sym_Nullable => "nullable",
               when Precomputed_Sym_Open => "open",
               when Precomputed_Sym_Parse_Field => "parse_field",
               when Precomputed_Sym_Pick => "pick",
               when Precomputed_Sym_Previous_Token => "previous_token",
               when Precomputed_Sym_Property => "property",
               when Precomputed_Sym_Propertyerror => "PropertyError",
               when Precomputed_Sym_Qualifier => "qualifier",
               when Precomputed_Sym_Regexp => "Regexp",
               when Precomputed_Sym_Root_Node => "root_node",
               when Precomputed_Sym_Rootnode => "RootNode__",
               when Precomputed_Sym_Self => "self",
               when Precomputed_Sym_Send => "send",
               when Precomputed_Sym_Skip => "skip",
               when Precomputed_Sym_Stop_Cut => "stop_cut",
               when Precomputed_Sym_String => "String",
               when Precomputed_Sym_Super => "super",
               when Precomputed_Sym_Symbol => "Symbol",
               when Precomputed_Sym_Synthetic => "synthetic",
               when Precomputed_Sym_T => "T",
               when Precomputed_Sym_Tokennode => "TokenNode",
               when Precomputed_Sym_True => "true",
               when Precomputed_Sym_Update => "update",
               when Precomputed_Sym_Var => "var",
               when Precomputed_Sym_With_Dynvars => "with_dynvars"
            );

            Symbol : constant Symbolization_Result :=
                  Create_Symbol (Raw_Text)
            ;
         begin
            if Symbol.Success then
               return Symbol.Symbol;
            else
               raise Program_Error with
                 "Cannot canonicalize symbol literal: " & Image (Raw_Text);
            end if;
         end;
   end Precomputed_Symbol;

   ----------------------------
   -- Construct_Entity_Array --
   ----------------------------

   function Construct_Entity_Array
     (V : AST_Envs.Entity_Vectors.Vector) return Internal_Entity_Array_Access
   is
      Ret : Internal_Entity_Array_Access :=
        Create_Internal_Entity_Array (V.Length);
   begin
      for J in V.First_Index .. V.Last_Index loop
         Ret.Items (J) := V.Get (J);
      end loop;

      declare
         Tmp : AST_Envs.Entity_Vectors.Vector := V;
      begin
         Tmp.Destroy;
      end;

      return Ret;
   end Construct_Entity_Array;

   -----------
   -- Image --
   -----------

   function Image (Self : Symbol_Type) return String_Type is
   begin
      return Create_String (Image (Self));
   end Image;

   ------------------
   -- Context_Pool --
   ------------------

   package body Context_Pool is

      -------------
      -- Acquire --
      -------------

      procedure Acquire (Context : out Internal_Context) is
      begin
         GNAT.Task_Lock.Lock;

         if Available.Is_Empty then
            Context := new Analysis_Context_Type;
            Context.Serial_Number := 1;
         else
            Context := Available.Last_Element;
            Available.Delete_Last;
         end if;

         GNAT.Task_Lock.Unlock;

         Context.Initialized := False;
         Context.Ref_Count := 1;

      exception
         when others =>
            GNAT.Task_Lock.Unlock;
            raise;
      end Acquire;

      -------------
      -- Release --
      -------------

      procedure Release (Context : in out Internal_Context) is
      begin
         GNAT.Task_Lock.Lock;

         Available.Append (Context);
         Context.Serial_Number := Context.Serial_Number + 1;
         Context := null;

         GNAT.Task_Lock.Unlock;

      exception
         when others =>
            GNAT.Task_Lock.Unlock;
            raise;
      end Release;

      ----------
      -- Free --
      ----------

      procedure Free is
      begin
         GNAT.Task_Lock.Lock;

         for C of Available loop
            Free (C);
         end loop;

         GNAT.Task_Lock.Unlock;

      exception
         when others =>
            GNAT.Task_Lock.Unlock;
            raise;
      end Free;

   end Context_Pool;

   --------------
   -- Finalize --
   --------------

   overriding procedure Finalize (CD : in out Contexts_Destructor) is
      pragma Unreferenced (CD);
   begin
      Context_Pool.Free;
   end Finalize;

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (File_Reader : in out Internal_File_Reader_Access) is
      procedure Destroy is new Ada.Unchecked_Deallocation
        (Internal_File_Reader'Class, Internal_File_Reader_Access);
   begin
      if File_Reader /= null and then File_Reader.all.Dec_Ref then
         Destroy (File_Reader);
      end if;
   end Dec_Ref;

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (Self : in out Internal_Event_Handler_Access) is
      procedure Destroy is new Ada.Unchecked_Deallocation
        (Internal_Event_Handler'Class, Internal_Event_Handler_Access);
   begin
      if Self /= null and then Self.all.Dec_Ref then
         Destroy (Self);
      end if;
   end Dec_Ref;

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (Provider : in out Internal_Unit_Provider_Access) is
      procedure Destroy is new Ada.Unchecked_Deallocation
        (Internal_Unit_Provider'Class, Internal_Unit_Provider_Access);
   begin
      if Provider /= null and then Provider.all.Dec_Ref then
         Destroy (Provider);
      end if;
   end Dec_Ref;

   ----------------
   -- Get_Env_Id --
   ----------------

   function Get_Env_Id
     (E : Lexical_Env; State : in out Dump_Lexical_Env_State) return String
   is
      C        : Address_To_Id_Maps.Cursor;
      Inserted : Boolean;
   begin
      if E = Null_Lexical_Env then
         return "$null";

      elsif E = State.Root_Env then
         --  Insert root env with a special Id so that we only print it once
         State.Env_Ids.Insert (E, -1, C, Inserted);
         return "$root";
      end if;

      State.Env_Ids.Insert (E, State.Next_Id, C, Inserted);
      if Inserted then
         State.Next_Id := State.Next_Id + 1;
      end if;

      return '@' & Stripped_Image (Address_To_Id_Maps.Element (C));
   end Get_Env_Id;

   pragma Warnings (Off, "referenced");
   function To_Lookup_Kind_Type (K : Lookup_Kind) return Lookup_Kind_Type
   is
     (Lookup_Kind_Type'Val (Lookup_Kind'Pos (K)));
   pragma Warnings (On, "referenced");

   ----------------------
   -- Allocate_Context --
   ----------------------

   function Allocate_Context return Internal_Context is
   begin
      return Context : Internal_Context do
         Context_Pool.Acquire (Context);
      end return;
   end Allocate_Context;

   ------------------------
   -- Initialize_Context --
   ------------------------

   procedure Initialize_Context
     (Context        : Internal_Context;
      Charset        : String;
      File_Reader    : Internal_File_Reader_Access;
      Unit_Provider  : Internal_Unit_Provider_Access;
      Event_Handler  : Internal_Event_Handler_Access;
      With_Trivia    : Boolean;
      Tab_Stop       : Positive)
   is
      Actual_Charset : constant String :=
        (if Charset = "" then Default_Charset else Charset);
      Symbols        : constant Precomputed_Symbol_Table
        := Create_Symbol_Table;
   begin
      Context.Rewriting_Handle := System.Null_Address;
      Context.Rewriting_Version := 1;
      Context.Initialized := True;
      Context.Symbols := Symbol_Table (Symbols);
      Context.Charset := To_Unbounded_String (Actual_Charset);
      Context.Tab_Stop := Tab_Stop;
      Context.With_Trivia := With_Trivia;
      Context.Root_Scope := Create_Static_Lexical_Env
        (Parent    => Null_Lexical_Env,
         Node      => null,
         Sym_Table => Context.Symbols);

      --  Create a new ownership share for Event_Handler so that it lives at
      --  least as long as this analysis context.
      Context.Event_Handler := Event_Handler;
      if Context.Event_Handler /= null then
         Context.Event_Handler.Inc_Ref;
      end if;

      --  Create a new ownership share for File_Reader so that it lives at
      --  least as long as this analysis context.
      Context.File_Reader := File_Reader;
      if Context.File_Reader /= null then
         Context.File_Reader.Inc_Ref;
      end if;

      --  Create a new ownership share for Unit_Provider so that it lives at
      --  least as long as this analysis context.
      Context.Unit_Provider := Unit_Provider;
      if Context.Unit_Provider /= null then
         Context.Unit_Provider.Inc_Ref;
      end if;

         if Context.Unit_Provider = null then
            Context.Unit_Provider := Liblktlang.Default_Provider.Create;
         end if;

      Initialize (Context.Parser);

      Context.Discard_Errors_In_Populate_Lexical_Env := True;
      Context.Logic_Resolution_Timeout :=
        Liblktlang_Support.Adalog.Default_Timeout_Ticks_Number;
      Context.In_Populate_Lexical_Env := False;
      Context.Cache_Version := 0;
      Context.Reparse_Cache_Version := 0;

      Context.Templates_Unit := No_Analysis_Unit;

      Context.Available_Rebindings := Env_Rebindings_Vectors.Empty_Vector;

      

   end Initialize_Context;

   -----------------
   -- Create_Unit --
   -----------------

   function Create_Unit
     (Context             : Internal_Context;
      Normalized_Filename : Virtual_File;
      Charset             : String;
      Rule                : Grammar_Rule) return Internal_Unit
   is
      use Units_Maps;

      Unit : Internal_Unit;
   begin
      Unit := Create_Special_Unit
        (Context, Normalized_Filename, Charset, Rule);
      Context.Units.Insert (Normalized_Filename, Unit);
      return Unit;
   end Create_Unit;

   --------------
   -- Get_Unit --
   --------------

   function Get_Unit
     (Context           : Internal_Context;
      Filename, Charset : String;
      Reparse           : Boolean;
      Input             : Liblktlang_Support.Internal.Analysis.Lexer_Input;
      Rule              : Grammar_Rule;
      Is_Internal       : Boolean := False) return Internal_Unit
   is
      use Units_Maps;

      Normalized_Filename : constant GNATCOLL.VFS.Virtual_File :=
         Normalized_Unit_Filename (Context, Filename);

      Cur     : constant Cursor :=
         Context.Units.Find (Normalized_Filename);
      Created : constant Boolean := Cur = No_Element;
      Unit    : Internal_Unit;

      Actual_Charset : Unbounded_String;
      Refined_Input  : Liblktlang_Support.Internal.Analysis.Lexer_Input := Input;

      Parsing_Happened : Boolean := False;

   begin
      --  Determine which encoding to use. Use the Charset parameter (if
      --  provided), otherwise use the context-wide default.

      Actual_Charset := (if Charset'Length /= 0
                         then To_Unbounded_String (Charset)
                         else Context.Charset);

      if Refined_Input.Kind = File then
         Refined_Input.Filename := Normalized_Filename;
      end if;

      if Refined_Input.Kind in File | Bytes_Buffer then
         Refined_Input.Charset := Actual_Charset;

         --  Unless the caller requested a specific charset for this unit,
         --  allow the lexer to automatically discover the source file encoding
         --  before defaulting to the context-specific one. We do this trying
         --  to match a byte order mark.

         Refined_Input.Read_BOM := Charset'Length = 0;
      end if;

      --  Create the Internal_Unit if needed

      Unit :=
        (if Created
         then Create_Unit (Context, Normalized_Filename,
                           To_String (Actual_Charset), Rule)
         else Element (Cur));

      --  If an internal unit is requested, set the corresponding flag.
      --  Otherwise, make sure that the unit we return isn't internal.

      if Is_Internal then
         Unit.Is_Internal := True;
      end if;

      --  (Re)parse it if needed

      if Created or else Reparse then

         --  It is illegal to reparse an internal unit for public API users.
         --  Since public APIs do not allow to pass True to Is_Internal, we can
         --  check here that only the implementation can ask to reparse an
         --  internal unit.

         if Unit.Is_Internal and then not Is_Internal then
            raise Precondition_Failure with "cannot reparse an internal unit";
         end if;

         declare
            Reparsed : Reparsed_Unit;
         begin
            Do_Parsing (Unit, Refined_Input, Reparsed);
            Parsing_Happened := Reparsed.Present;
            Update_After_Reparse (Unit, Reparsed);
         end;

         --  Now that we have removed reparsed the unit, update its current
         --  charset.

         Unit.Charset := Actual_Charset;
      end if;

      if Context.Event_Handler /= null then
         Context.Event_Handler.Unit_Parsed_Callback
           (Context  => Context,
            Unit     => Unit,
            Reparsed => Parsing_Happened and then not Created);
      end if;

      return Unit;
   end Get_Unit;

   --------------
   -- Has_Unit --
   --------------

   function Has_Unit
     (Context : Internal_Context; Unit_Filename : String) return Boolean is
   begin
      return Context.Units.Contains
        (Normalized_Unit_Filename (Context, Unit_Filename));
   end Has_Unit;

   -------------------
   -- Get_From_File --
   -------------------

   function Get_From_File
     (Context  : Internal_Context;
      Filename : String;
      Charset  : String;
      Reparse  : Boolean;
      Rule     : Grammar_Rule) return Internal_Unit
   is
      Input : constant Liblktlang_Support.Internal.Analysis.Lexer_Input :=
        (Kind     => File,
         Charset  => <>,
         Read_BOM => False,
         Filename => <>);
   begin
      if Reparse and then Has_Rewriting_Handle (Context) then
         raise Precondition_Failure with
            "cannot reparse during tree rewriting";
      end if;

      return Get_Unit (Context, Filename, Charset, Reparse, Input, Rule);
   end Get_From_File;

   ---------------------
   -- Get_From_Buffer --
   ---------------------

   function Get_From_Buffer
     (Context  : Internal_Context;
      Filename : String;
      Charset  : String;
      Buffer   : String;
      Rule     : Grammar_Rule) return Internal_Unit
   is
      Input : constant Liblktlang_Support.Internal.Analysis.Lexer_Input :=
        (Kind        => Bytes_Buffer,
         Charset     => <>,
         Read_BOM    => False,
         Bytes       => Buffer'Address,
         Bytes_Count => Buffer'Length);
   begin
      if Has_Rewriting_Handle (Context) then
         raise Precondition_Failure with
            "cannot parse from buffer during tree rewriting";

      elsif Context.File_Reader /= null then
         raise Precondition_Failure with
            "cannot parse from buffer with a file reader";
      end if;

      return Get_Unit (Context, Filename, Charset, True, Input, Rule);
   end Get_From_Buffer;

   --------------------
   -- Get_With_Error --
   --------------------

   function Get_With_Error
     (Context  : Internal_Context;
      Filename : String;
      Error    : Text_Type;
      Charset  : String;
      Rule     : Grammar_Rule) return Internal_Unit
   is
      use Units_Maps;

      Normalized_Filename : constant Virtual_File :=
         Normalized_Unit_Filename (Context, Filename);
      Cur                 : constant Cursor :=
         Context.Units.Find (Normalized_Filename);
   begin
      if Cur = No_Element then
         declare
            Unit : constant Internal_Unit := Create_Unit
              (Context, Normalized_Filename, Charset, Rule);
         begin
            Append (Unit.Diagnostics, No_Source_Location_Range, Error);
            return Unit;
         end;
      else
         return Element (Cur);
      end if;
   end Get_With_Error;


   -----------------------
   -- Get_From_Provider --
   -----------------------

   function Get_From_Provider
     (Context : Internal_Context;
      Name    : Text_Type;
      Kind    : Analysis_Unit_Kind;
      Charset : String;
      Reparse : Boolean) return Internal_Unit is
   begin
      if Reparse and then Has_Rewriting_Handle (Context) then
         raise Precondition_Failure with
            "cannot reparse during tree rewriting";
      end if;

      declare
         Result      : Internal_Unit;
         Dummy_Index : Positive;
      begin
         Context.Unit_Provider.Get_Unit_And_PLE_Root
           (Context, Name, Kind, Charset, Reparse, Result, Dummy_Index);
         return Result;
      exception
         when Property_Error =>
            raise Invalid_Unit_Name_Error with
               "Invalid unit name: " & Image (Name, With_Quotes => True)
               & " (" & Analysis_Unit_Kind'Image (Kind) & ")";
      end;
   end Get_From_Provider;


   -------------------
   -- Unit_Provider --
   -------------------

   function Unit_Provider
     (Context : Internal_Context) return Internal_Unit_Provider_Access
   is (Context.Unit_Provider);

   ------------------
   -- Resolve_Unit --
   ------------------

   procedure Resolve_Unit
     (Context : Internal_Context;
      Name    : Text_Type;
      Kind    : Analysis_Unit_Kind;
      Unit    : out Resolved_Unit)
   is
      --  Look for the cache entry corresponding to Unit; create one if needed

      Dummy    : Resolved_Unit_Array;
      Key      : constant Symbol_Type := Find (Context.Symbols, Name);
      Pos      : Unit_Provider_Cache_Maps.Cursor;
      Inserted : Boolean;
   begin
      Context.Unit_Provider_Cache.Insert (Key, Dummy, Pos, Inserted);
      declare
         Units : Resolved_Unit_Array renames
           Context.Unit_Provider_Cache.Reference (Pos);
         U     : Resolved_Unit renames Units (Kind);
      begin
         --  If the cache entry is not populated for the requested kind, run
         --  the query and save the result for later requests.

         if U.Filename = null then
            declare
               Provider : Internal_Unit_Provider'Class renames
                 Context.Unit_Provider.all;
               Filename : Unbounded_String;
            begin
               Provider.Get_Unit_Location
                 (Name           => Name,
                  Kind           => Kind,
                  Filename       => Filename,
                  PLE_Root_Index => U.PLE_Root_Index);
               Provider.Get_Unit_And_PLE_Root
                 (Context        => Context,
                  Name           => Name,
                  Kind           => Kind,
                  Unit           => U.Unit,
                  PLE_Root_Index => U.PLE_Root_Index);
               U.Filename := new String'(To_String (Filename));
            end;
         end if;

         Unit := U;
      end;
   end Resolve_Unit;

   -----------------------
   -- Get_Unit_Location --
   -----------------------

   procedure Get_Unit_Location
     (Context        : Internal_Context;
      Name           : Text_Type;
      Kind           : Analysis_Unit_Kind;
      Filename       : out String_Access;
      PLE_Root_Index : out Positive)
   is
      U : Resolved_Unit;
   begin
      Resolve_Unit (Context, Name, Kind, U);
      Filename := U.Filename;
      PLE_Root_Index := U.PLE_Root_Index;
   end Get_Unit_Location;

   ---------------------------
   -- Get_Unit_And_PLE_Root --
   ---------------------------

   procedure Get_Unit_And_PLE_Root
     (Context        : Internal_Context;
      Name           : Text_Type;
      Kind           : Analysis_Unit_Kind;
      Unit           : out Internal_Unit;
      PLE_Root_Index : out Positive)
   is
      U : Resolved_Unit;
   begin
      Resolve_Unit (Context, Name, Kind, U);
      Unit := U.Unit;
      PLE_Root_Index := U.PLE_Root_Index;
   end Get_Unit_And_PLE_Root;

   ----------
   -- Hash --
   ----------

   function Hash (Context : Internal_Context) return Hash_Type is
      function H is new Hash_Access (Analysis_Context_Type, Internal_Context);
   begin
      return H (Context);
   end Hash;

   ---------------------
   -- Has_With_Trivia --
   ---------------------

   function Has_With_Trivia (Context : Internal_Context) return Boolean is
   begin
      return Context.With_Trivia;
   end Has_With_Trivia;

   --------------------------------------------
   -- Discard_Errors_In_Populate_Lexical_Env --
   --------------------------------------------

   procedure Discard_Errors_In_Populate_Lexical_Env
     (Context : Internal_Context; Discard : Boolean) is
   begin
      Context.Discard_Errors_In_Populate_Lexical_Env := Discard;
   end Discard_Errors_In_Populate_Lexical_Env;

   ----------------------------------
   -- Set_Logic_Resolution_Timeout --
   ----------------------------------

   procedure Set_Logic_Resolution_Timeout
     (Context : Internal_Context; Timeout : Natural) is
   begin
      Context.Logic_Resolution_Timeout := Timeout;
   end Set_Logic_Resolution_Timeout;

   --------------------------
   -- Has_Rewriting_Handle --
   --------------------------

   function Has_Rewriting_Handle (Context : Internal_Context) return Boolean is
   begin
      return Context.Rewriting_Handle /= System.Null_Address;
   end Has_Rewriting_Handle;

   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (Context : Internal_Context) is
   begin
      if Context /= null then
         Context.Ref_Count := Context.Ref_Count + 1;
      end if;
   end Inc_Ref;

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (Context : in out Internal_Context) is
   begin
      if Context /= null then
         Context.Ref_Count := Context.Ref_Count - 1;
         if Context.Ref_Count = 0 then

            --  If this context was not completely initialized, just release
            --  the allocated object. Do the full destruction otherwise.
            if Context.Initialized then
               Destroy (Context);
            end if;
            Context_Pool.Release (Context);
         end if;
      end if;
   end Dec_Ref;

   -------------
   -- Destroy --
   -------------

   procedure Destroy (Context : Internal_Context) is
   begin
      


      --  Destroy all named environment data structures
      for Desc of Context.Named_Envs loop
         for V of Desc.Foreign_Nodes loop
            V.Destroy;
         end loop;
         Destroy (Desc);
      end loop;
      Context.Named_Envs.Clear;

      --  If we are asked to free this context, it means that no one else have
      --  references to its analysis units, so it's safe to destroy these.
      for Unit of Context.Units loop
         Destroy (Unit);
      end loop;
      Context.Units := Units_Maps.Empty_Map;
      Context.Filenames :=
        Liblktlang_Support.Internal.Analysis.Empty_Virtual_File_Cache;

      declare
         procedure Destroy is new Ada.Unchecked_Deallocation
           (Env_Rebindings_Type, Env_Rebindings);

         AR : Env_Rebindings_Vectors.Vector renames
            Context.Available_Rebindings;
         R  : Env_Rebindings;
      begin
         for I in AR.First_Index .. AR.Last_Index loop
            R := AR.Get (I);
            Destroy (R);
         end loop;
         AR.Destroy;
      end;

      for Pos in Context.Unit_Provider_Cache.Iterate loop
         declare
            Units : Resolved_Unit_Array renames
              Context.Unit_Provider_Cache.Reference (Pos);
         begin
            for U of Units loop
               Free (U.Filename);
            end loop;
         end;
      end loop;
      Context.Unit_Provider_Cache.Clear;

      Destroy (Context.Templates_Unit);
      AST_Envs.Destroy (Context.Root_Scope);
      Destroy (Context.Symbols);
      Destroy (Context.Parser);
      Dec_Ref (Context.File_Reader);
      Dec_Ref (Context.Unit_Provider);
      Dec_Ref (Context.Event_Handler);
   end Destroy;

   -------------
   -- Context --
   -------------

   function Context (Unit : Internal_Unit) return Internal_Context is
   begin
      return Unit.Context;
   end Context;

   ----------
   -- Hash --
   ----------

   function Hash (Unit : Internal_Unit) return Hash_Type is
      function H is new Hash_Access (Analysis_Unit_Type, Internal_Unit);
   begin
      return H (Unit);
   end Hash;

   -------------
   -- Reparse --
   -------------

   procedure Reparse (Unit : Internal_Unit; Charset : String) is
      Dummy : constant Internal_Unit := Get_From_File
        (Unit.Context, +Unit.Filename.Full_Name, Charset,
         Reparse => True,
         Rule    => Unit.Rule);
   begin
      null;
   end Reparse;

   -------------
   -- Reparse --
   -------------

   procedure Reparse (Unit : Internal_Unit; Charset : String; Buffer : String)
   is
      Dummy : constant Internal_Unit := Get_From_Buffer
        (Unit.Context, +Unit.Filename.Full_Name, Charset, Buffer, Unit.Rule);
   begin
      null;
   end Reparse;

   -----------------------
   -- Reset_Envs_Caches --
   -----------------------

   procedure Reset_Envs_Caches (Unit : Internal_Unit) is
      procedure Internal (Node : Bare_Lkt_Node);
      --  Reset env caches in ``Node`` and then in its children recursively

      Generic_Unit : constant Generic_Unit_Ptr := Convert_Unit (Unit);

      --------------
      -- Internal --
      --------------

      procedure Internal (Node : Bare_Lkt_Node) is
      begin
         if Node = null then
            return;
         end if;
         --  Make sure to only reset caches of envs belonging to this unit
         if Node.Self_Env.Owner = Generic_Unit then
            Reset_Caches (Node.Self_Env);
         end if;
         for I in 1 .. Children_Count (Node) loop
            Internal (Child (Node, I));
         end loop;
      end Internal;
   begin
      Internal (Unit.Ast_Root);
   end Reset_Envs_Caches;

   --------------------------
   -- Populate_Lexical_Env --
   --------------------------

   procedure Populate_Lexical_Env
     (Unit           : Internal_Unit;
      PLE_Root_Index : Positive
         := 1
   ) is
      Context : constant Internal_Context := Unit.Context;

      Saved_In_Populate_Lexical_Env : constant Boolean :=
        Context.In_Populate_Lexical_Env;

      Has_Errors : Boolean := False;
      --  Whether at least one Property_Error occurred during this PLE pass

   begin
      --  TODO??? Handle env invalidation when reparsing a unit and when a
      --  previous call raised a Property_Error.

      --  If we have already run PLE on this root, there is nothing to do.
      --  Otherwise, keep track of the fact that PLE was requested for it,
      --  possibly extending the vector if needed.

      if Unit.Env_Populated_Roots.Last_Index >= PLE_Root_Index
         and then Unit.Env_Populated_Roots.Get (PLE_Root_Index)
      then
         return;
      end if;
      for Dummy in Unit.Env_Populated_Roots.Last_Index + 1 .. PLE_Root_Index
      loop
         Unit.Env_Populated_Roots.Append (False);
      end loop;
      Unit.Env_Populated_Roots.Set (PLE_Root_Index, True);

      --  Create context for the PLE run: all exit points must call the Cleanup
      --  procedure above first to clean this context.

      Context.In_Populate_Lexical_Env := True;
      if Main_Trace.Active then
         Main_Trace.Trace
           ("Populating lexical envs for"
            & " unit: " & Basename (Unit));
         Main_Trace.Increase_Indent;
      end if;

      --  Fetch the node on which to run PLE: it's the unit root node, or one
      --  of its children if PLE roots are enabled and the unit has a list of
      --  PLE roots. Then run PLE itself.

      declare
         PLE_Root : Bare_Lkt_Node := Unit.Ast_Root;
      begin

         if PLE_Root /= null then
            Has_Errors := Populate_Lexical_Env (PLE_Root);
         end if;
      end;

      --  Restore the context for PLE run (undo what was done above)

      Context.In_Populate_Lexical_Env := Saved_In_Populate_Lexical_Env;
      if Main_Trace.Active then
         Main_Trace.Decrease_Indent;
         Main_Trace.Trace
           ("Finished populating lexical envs for"
            & " unit: " & Basename (Unit));
      end if;

      Reset_Envs_Caches (Unit);

      if Has_Errors and then not Context.Discard_Errors_In_Populate_Lexical_Env
      then
         raise Property_Error with
            "errors occurred in Populate_Lexical_Env";
      end if;
   end Populate_Lexical_Env;

   -----------------------------------
   -- Populate_Lexical_Env_For_Unit --
   -----------------------------------

   procedure Populate_Lexical_Env_For_Unit (Node : Bare_Lkt_Node) is
      Root  : Bare_Lkt_Node;
      Index : Natural;
   begin
      Lookup_PLE_Root (Node, Root, Index);
      if Index = 0 then
         Index := 1;
      end if;
      Populate_Lexical_Env (Node.Unit, Index);
   end Populate_Lexical_Env_For_Unit;

   ------------------
   -- Get_Filename --
   ------------------

   function Get_Filename (Unit : Internal_Unit) return String is
     (+Unit.Filename.Full_Name);

   -----------------
   -- Get_Charset --
   -----------------

   function Get_Charset (Unit : Internal_Unit) return String is
   begin
      return To_String (Unit.Charset);
   end Get_Charset;

   ---------------------
   -- Has_Diagnostics --
   ---------------------

   function Has_Diagnostics (Unit : Internal_Unit) return Boolean is
   begin
      return not Unit.Diagnostics.Is_Empty;
   end Has_Diagnostics;

   -----------------
   -- Diagnostics --
   -----------------

   function Diagnostics (Unit : Internal_Unit) return Diagnostics_Array is
      Result : Diagnostics_Array (1 .. Natural (Unit.Diagnostics.Length));
      I      : Natural := 1;
   begin
      for D of Unit.Diagnostics loop
         Result (I) := D;
         I := I + 1;
      end loop;
      return Result;
   end Diagnostics;

   ---------------------------
   -- Format_GNU_Diagnostic --
   ---------------------------

   function Format_GNU_Diagnostic
     (Unit : Internal_Unit; D : Diagnostic) return String
   is
      Filename : constant String := Basename (Unit);
      Sloc     : constant Source_Location := Start_Sloc (D.Sloc_Range);
      Msg      : constant String :=
         Image
           (Ada.Strings.Wide_Wide_Unbounded.To_Wide_Wide_String (D.Message));
   begin
      return (Filename
              & (if Sloc = No_Source_Location then "" else ":" & Image (Sloc))
              & ": " & Msg);
   end Format_GNU_Diagnostic;

   ----------
   -- Root --
   ----------

   function Root (Unit : Internal_Unit) return Bare_Lkt_Node is
     (Unit.Ast_Root);

   -----------------
   -- First_Token --
   -----------------

   function First_Token (Unit : Internal_Unit) return Token_Reference is
     (Wrap_Token_Reference (Unit.Context,
                            Unit.TDH'Access,
                            First_Token_Or_Trivia (Unit.TDH)));

   ----------------
   -- Last_Token --
   ----------------

   function Last_Token (Unit : Internal_Unit) return Token_Reference is
     (Wrap_Token_Reference (Unit.Context,
                            Unit.TDH'Access,
                            Last_Token_Or_Trivia (Unit.TDH)));

   -----------------
   -- Token_Count --
   -----------------

   function Token_Count (Unit : Internal_Unit) return Natural is
     (Unit.TDH.Tokens.Length);

   ------------------
   -- Trivia_Count --
   ------------------

   function Trivia_Count (Unit : Internal_Unit) return Natural is
     (Unit.TDH.Trivias.Length);

   ----------
   -- Text --
   ----------

   function Text (Unit : Internal_Unit) return Text_Type is
   begin
      return Text (First_Token (Unit), Last_Token (Unit));
   end Text;

   ------------------
   -- Lookup_Token --
   ------------------

   function Lookup_Token
     (Unit : Internal_Unit; Sloc : Source_Location) return Token_Reference
   is
      Result : constant Token_Or_Trivia_Index := Lookup_Token (Unit.TDH, Sloc);
   begin
      return Wrap_Token_Reference (Unit.Context, Unit.TDH'Access, Result);
   end Lookup_Token;

   ---------------------
   -- Lookup_PLE_Root --
   ---------------------

   procedure Lookup_PLE_Root
     (Node  : Bare_Lkt_Node;
      Root  : out Bare_Lkt_Node;
      Index : out Natural)
   is
      Unit : constant Internal_Unit := Node.Unit;
   begin
      --  If this unit does not contain a list of PLE roots, just return the
      --  unit root node.

      if Unit.PLE_Roots_Starting_Token.Is_Empty then
         Root := Unit.Ast_Root;
         Index := 0;
         return;
      end if;

      --  Otherwise, look for the last PLE root whose first token (in
      --  Unit.PLE_Roots_Starting_Token) appears before Node's (T). This vector
      --  is sorted by construction, so we can perform a binary search.

      declare
         T      : constant Token_Index := Node.Token_Start_Index;
         Tokens : Token_Index_Vectors.Vector renames
           Unit.PLE_Roots_Starting_Token;

         First : Positive := Tokens.First_Index;
         Last  : Positive := Tokens.Last_Index;
         I     : Positive;
      begin
         while First < Last loop

            --  Because we look for the "floor" (last element that is <= T), we
            --  need to look at the value in Last when there are only two
            --  elements left to look at. If we did not do that, then we would
            --  go into an infinite loop when Tokens[First] < T.

            I := (if First + 1 = Last
                  then Last
                  else (First + Last) / 2);
            declare
               I_T : constant Token_Index := Tokens.Get (I);
            begin
               if I_T <= T then
                  First := I;
               else
                  Last := I - 1;
               end if;
            end;
         end loop;

         Root := Child (Unit.Ast_Root, First);
         Index := First;
      end;
   end Lookup_PLE_Root;

   --------------
   -- Ple_Root --
   --------------

   function Ple_Root
     (Node : Bare_Lkt_Node) return Bare_Lkt_Node
   is
      Root        : Bare_Lkt_Node;
      Dummy_Index : Natural;
   begin
      if Node = null then
         raise Property_Error with "null node dereference";
      end if;
      Lookup_PLE_Root (Node, Root, Dummy_Index);
      return Root;
   end Ple_Root;

   ----------------------
   -- Dump_Lexical_Env --
   ----------------------

   procedure Dump_Lexical_Env (Unit : Internal_Unit) is
      Node     : constant Bare_Lkt_Node := Unit.Ast_Root;
      Root_Env : constant Lexical_Env := Unit.Context.Root_Scope;
      State    : Dump_Lexical_Env_State := (Root_Env => Root_Env, others => <>);

      procedure Dump_One_Lexical_Env (Env, Parent : Lexical_Env);
      --  Wrapper around the library-level Dump_One_Lexical_Env procedure, to
      --  automatically compute ids for Env and Parent.

      function Get_Parent (Env : Lexical_Env) return Lexical_Env
      is (Unwrap (Env).Parent);

      --------------------------
      -- Dump_One_Lexical_Env --
      --------------------------

      procedure Dump_One_Lexical_Env (Env, Parent : Lexical_Env) is
         Env_Id    : constant String := Get_Env_Id (Env, State);
         Parent_Id : constant String := Get_Env_Id (Parent, State);
      begin
         Dump_One_Lexical_Env (Env, Env_Id, Parent_Id);
      end Dump_One_Lexical_Env;

      --------------------------
      -- Explore_Parent_Chain --
      --------------------------

      procedure Explore_Parent_Chain (Env : Lexical_Env) is
         P : Lexical_Env;
      begin
         if Env /= Null_Lexical_Env then
            P := Get_Parent (Env);
            Dump_One_Lexical_Env (Env, P);
            Explore_Parent_Chain (P);
         end if;
      end Explore_Parent_Chain;

      --------------
      -- Internal --
      --------------

      procedure Internal (Current : Bare_Lkt_Node) is
         Explore_Parent : Boolean := False;
         Env, Parent    : Lexical_Env;
      begin
         if Current = null then
            return;
         end if;

         --  We only dump environments that we haven't dumped before. This way
         --  we'll only dump environments at the site of their creation, and
         --  not in any subsequent link. We use the Env_Ids map to check which
         --  envs we have already seen or not.
         if not State.Env_Ids.Contains (Current.Self_Env) then
            Env := Current.Self_Env;
            Parent := Get_Parent (Env);
            Explore_Parent := not State.Env_Ids.Contains (Parent);
            Dump_One_Lexical_Env (Env, Parent);

            if Explore_Parent then
               Explore_Parent_Chain (Parent);
            end if;
         end if;

         for Child of Internal_Bare_Lkt_Node_Array'(Children (Current))
         loop
            Internal (Child);
         end loop;
      end Internal;
      --  This procedure implements the main recursive logic of dumping the
      --  environments.
   begin
      Internal (Bare_Lkt_Node (Node));
   end Dump_Lexical_Env;

   --------------
   -- Get_Line --
   --------------

   function Get_Line
     (Unit : Internal_Unit; Line_Number : Positive) return Text_Type
   is
   begin
      return Get_Line (Unit.TDH, Line_Number);
   end Get_Line;

   -----------
   -- Print --
   -----------

   procedure Print (Unit : Internal_Unit; Show_Slocs : Boolean) is
   begin
      if Unit.Ast_Root = null then
         Put_Line ("<empty analysis unit>");
      else
         Print (Unit.Ast_Root, Show_Slocs);
      end if;
   end Print;

   ---------------
   -- PP_Trivia --
   ---------------

   procedure PP_Trivia (Unit : Internal_Unit) is

      procedure Process (Trivia : Token_Index) is
         Data : constant Stored_Token_Data :=
            Unit.TDH.Trivias.Get (Natural (Trivia)).T;
      begin
         Put_Line (Image (Text (Unit.TDH, Data)));
      end Process;

      Last_Token : constant Token_Index :=
         Token_Index (Token_Vectors.Last_Index (Unit.TDH.Tokens) - 1);
      --  Index for the last token in Unit excluding the Termination token
      --  (hence the -1).
   begin
      for Tok of Get_Leading_Trivias (Unit.TDH) loop
         Process (Tok);
      end loop;

      PP_Trivia (Unit.Ast_Root);

      for Tok of Get_Trivias (Unit.TDH, Last_Token) loop
         Process (Tok);
      end loop;
   end PP_Trivia;

   -------------
   -- Destroy --
   -------------

   procedure Destroy (Unit : in out Internal_Unit) is
   begin
      if Unit = No_Analysis_Unit then
         return;
      end if;

      --  Clear the env caches while the unit is still fully alive to make sure
      --  that what is accessed in ``Lexical_Env_Cache_Updated`` is still
      --  valid, as it will be called back by lexical envs that are being
      --  destroyed.
      Reset_Envs_Caches (Unit);

      Unit.PLE_Roots_Starting_Token.Destroy;
      Unit.Env_Populated_Roots.Destroy;

      Unit.Exiled_Entries.Destroy;
      Unit.Foreign_Nodes.Destroy;
      Unit.Exiled_Entries_In_NED.Destroy;
      Unit.Exiled_Envs.Destroy;
      Unit.Named_Envs.Destroy;

         Destroy (Unit.Memoization_Map);

      Destroy_Rebindings (Unit.Rebindings'Access);
      Unit.Rebindings.Destroy;

      if Unit.Ast_Root /= null then
         Destroy (Unit.Ast_Root);
      end if;

      Free (Unit.TDH);
      Free (Unit.Ast_Mem_Pool);
      Destroy_Unit_Destroyables (Unit);
      Destroyable_Vectors.Destroy (Unit.Destroyables);
      

      Free (Unit);
   end Destroy;

   -------------------
   -- Is_Token_Node --
   -------------------

   function Is_Token_Node (Node : Bare_Lkt_Node) return Boolean is
   begin
      return Is_Token_Node (Node.Kind);
   end Is_Token_Node;

   ------------------
   -- Is_Synthetic --
   ------------------

   function Is_Synthetic (Node : Bare_Lkt_Node) return Boolean is
   begin
      return Node.Kind in Synthetic_Nodes;
   end Is_Synthetic;

   ------------------------------
   -- Raise_Property_Exception --
   ------------------------------

   procedure Raise_Property_Exception
     (Node    : Bare_Lkt_Node;
      Exc     : Ada.Exceptions.Exception_Id;
      Message : String)
   is
      Sloc_Prefix : constant String :=
        (if Node = null
         then ""
         else Ada.Directories.Simple_Name (Get_Filename (Unit (Node)))
              & ":" & Image (Sloc_Range (Node)) & ": ");
   begin
      Ada.Exceptions.Raise_Exception (Exc, Sloc_Prefix & Message);
   end Raise_Property_Exception;

   ------------------------------
   -- Register_Destroyable_Gen --
   ------------------------------

   procedure Register_Destroyable_Gen
     (Unit : Internal_Unit; Object : T_Access)
   is
      function Convert is new Ada.Unchecked_Conversion
        (System.Address, Destroy_Procedure);
      procedure Destroy_Procedure (Object : in out T_Access) renames Destroy;
   begin
      Register_Destroyable_Helper
        (Unit,
         Object.all'Address,
         Convert (Destroy_Procedure'Address));
   end Register_Destroyable_Gen;

      

   


   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Bare_Lkt_Node_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Bare_Lkt_Node
   is
      function Absolute_Get
        (T : Bare_Lkt_Node_Array_Access; Index : Integer)
         return Bare_Lkt_Node
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Bare_Lkt_Node,
         Sequence_Type => Bare_Lkt_Node_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Bare_Lkt_Node;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Bare_Lkt_Node;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Bare_Lkt_Node_Array_Access) return Bare_Lkt_Node_Array_Access is
      Ret : Bare_Lkt_Node_Array_Access := Create_Bare_Lkt_Node_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Bare_Lkt_Node_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Bare_Lkt_Node_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Bare_Lkt_Node_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Bare_Lkt_Node_Array (Items_Count : Natural) return Bare_Lkt_Node_Array_Access
   is (if Items_Count = 0
       then No_Bare_Lkt_Node_Array_Type
       else new Bare_Lkt_Node_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Bare_Lkt_Node_Array
     (Items : Internal_Bare_Lkt_Node_Array) return Bare_Lkt_Node_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Bare_Lkt_Node_Array_Type;
      end if;

      return new Bare_Lkt_Node_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Bare_Lkt_Node_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Bare_Lkt_Node_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   


   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Bare_Type_Ref_Node_Builder_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Bare_Type_Ref_Node_Builder
   is
      function Absolute_Get
        (T : Bare_Type_Ref_Node_Builder_Array_Access; Index : Integer)
         return Bare_Type_Ref_Node_Builder
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Bare_Type_Ref_Node_Builder,
         Sequence_Type => Bare_Type_Ref_Node_Builder_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Bare_Type_Ref_Node_Builder;
   begin
      if Relative_Get (T, Index, Result) then
            Inc_Ref (Result);
         return Result;
      elsif Or_Null then
         return null;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Bare_Type_Ref_Node_Builder_Array_Access) return Bare_Type_Ref_Node_Builder_Array_Access is
      Ret : Bare_Type_Ref_Node_Builder_Array_Access := Create_Bare_Type_Ref_Node_Builder_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
         for Item of Ret.Items loop
            Inc_Ref (Item);
         end loop;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Bare_Type_Ref_Node_Builder_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Bare_Type_Ref_Node_Builder_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Bare_Type_Ref_Node_Builder_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
            for Item of T.Items loop
               Dec_Ref (Item);
            end loop;
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Bare_Type_Ref_Node_Builder_Array (Items_Count : Natural) return Bare_Type_Ref_Node_Builder_Array_Access
   is (if Items_Count = 0
       then No_Bare_Type_Ref_Node_Builder_Array_Type
       else new Bare_Type_Ref_Node_Builder_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Bare_Type_Ref_Node_Builder_Array
     (Items : Internal_Bare_Type_Ref_Node_Builder_Array) return Bare_Type_Ref_Node_Builder_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Bare_Type_Ref_Node_Builder_Array_Type;
      end if;

         for El of Items loop
            Inc_Ref (El);
         end loop;
      return new Bare_Type_Ref_Node_Builder_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Bare_Type_Ref_Node_Builder_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Bare_Type_Ref_Node_Builder_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Integer_Vectors is new Liblktlang_Support.Vectors (Integer);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Integer_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Integer
   is
      function Absolute_Get
        (T : Integer_Array_Access; Index : Integer)
         return Integer
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Integer,
         Sequence_Type => Integer_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Integer;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return 0;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Integer_Array_Access) return Integer_Array_Access is
      Ret : Integer_Array_Access := Create_Integer_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Integer_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Integer_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Integer_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Integer_Array (Items_Count : Natural) return Integer_Array_Access
   is (if Items_Count = 0
       then No_Integer_Array_Type
       else new Integer_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Integer_Array
     (Items : Internal_Integer_Array) return Integer_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Integer_Array_Type;
      end if;

      return new Integer_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Integer_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Integer_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Internal_Complete_Item_Vectors is new Liblktlang_Support.Vectors (Internal_Complete_Item);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Complete_Item_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Complete_Item
   is
      function Absolute_Get
        (T : Internal_Complete_Item_Array_Access; Index : Integer)
         return Internal_Complete_Item
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Complete_Item,
         Sequence_Type => Internal_Complete_Item_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Complete_Item;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Complete_Item;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Complete_Item_Array_Access) return Internal_Complete_Item_Array_Access is
      Ret : Internal_Complete_Item_Array_Access := Create_Internal_Complete_Item_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Complete_Item_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Complete_Item_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Complete_Item_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Complete_Item_Array (Items_Count : Natural) return Internal_Complete_Item_Array_Access
   is (if Items_Count = 0
       then No_Internal_Complete_Item_Array_Type
       else new Internal_Complete_Item_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Complete_Item_Array
     (Items : Internal_Internal_Complete_Item_Array) return Internal_Complete_Item_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Complete_Item_Array_Type;
      end if;

      return new Internal_Complete_Item_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Complete_Item_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Complete_Item_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Internal_Entity_Argument_Vectors is new Liblktlang_Support.Vectors (Internal_Entity_Argument);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Entity_Argument_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Entity_Argument
   is
      function Absolute_Get
        (T : Internal_Entity_Argument_Array_Access; Index : Integer)
         return Internal_Entity_Argument
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Entity_Argument,
         Sequence_Type => Internal_Entity_Argument_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Entity_Argument;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Entity_Argument;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Entity_Argument_Array_Access) return Internal_Entity_Argument_Array_Access is
      Ret : Internal_Entity_Argument_Array_Access := Create_Internal_Entity_Argument_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Entity_Argument_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Entity_Argument_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Entity_Argument_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Entity_Argument_Array (Items_Count : Natural) return Internal_Entity_Argument_Array_Access
   is (if Items_Count = 0
       then No_Internal_Entity_Argument_Array_Type
       else new Internal_Entity_Argument_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Entity_Argument_Array
     (Items : Internal_Internal_Entity_Argument_Array) return Internal_Entity_Argument_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Entity_Argument_Array_Type;
      end if;

      return new Internal_Entity_Argument_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Entity_Argument_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Entity_Argument_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Internal_Entity_Vectors is new Liblktlang_Support.Vectors (Internal_Entity);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Entity_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Entity
   is
      function Absolute_Get
        (T : Internal_Entity_Array_Access; Index : Integer)
         return Internal_Entity
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Entity,
         Sequence_Type => Internal_Entity_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Entity;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Entity;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Entity_Array_Access) return Internal_Entity_Array_Access is
      Ret : Internal_Entity_Array_Access := Create_Internal_Entity_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Entity_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Entity_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Entity_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Entity_Array (Items_Count : Natural) return Internal_Entity_Array_Access
   is (if Items_Count = 0
       then No_Internal_Entity_Array_Type
       else new Internal_Entity_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));

   function Create_Internal_Entity_Array
     (Items : AST_Envs.Entity_Array) return Internal_Entity_Array_Access
   is (if Items'Length = 0
       then No_Internal_Entity_Array_Type
       else new Internal_Entity_Array_Record'
         (N         => Items'Length,
          Items     => Implementation.Internal_Internal_Entity_Array (Items),
          Ref_Count => 1));

   function Create_Internal_Entity_Array
     (Items : Internal_Internal_Entity_Array) return Internal_Entity_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Entity_Array_Type;
      end if;

      return new Internal_Entity_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Entity_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Entity_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Internal_Entity_Def_Id_Vectors is new Liblktlang_Support.Vectors (Internal_Entity_Def_Id);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Entity_Def_Id_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Entity_Def_Id
   is
      function Absolute_Get
        (T : Internal_Entity_Def_Id_Array_Access; Index : Integer)
         return Internal_Entity_Def_Id
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Entity_Def_Id,
         Sequence_Type => Internal_Entity_Def_Id_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Entity_Def_Id;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Entity_Def_Id;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Entity_Def_Id_Array_Access) return Internal_Entity_Def_Id_Array_Access is
      Ret : Internal_Entity_Def_Id_Array_Access := Create_Internal_Entity_Def_Id_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Entity_Def_Id_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Entity_Def_Id_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Entity_Def_Id_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Entity_Def_Id_Array (Items_Count : Natural) return Internal_Entity_Def_Id_Array_Access
   is (if Items_Count = 0
       then No_Internal_Entity_Def_Id_Array_Type
       else new Internal_Entity_Def_Id_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Entity_Def_Id_Array
     (Items : Internal_Internal_Entity_Def_Id_Array) return Internal_Entity_Def_Id_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Entity_Def_Id_Array_Type;
      end if;

      return new Internal_Entity_Def_Id_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Entity_Def_Id_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Entity_Def_Id_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Internal_Entity_Enum_Class_Alt_Decl_Vectors is new Liblktlang_Support.Vectors (Internal_Entity_Enum_Class_Alt_Decl);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Entity_Enum_Class_Alt_Decl_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Entity_Enum_Class_Alt_Decl
   is
      function Absolute_Get
        (T : Internal_Entity_Enum_Class_Alt_Decl_Array_Access; Index : Integer)
         return Internal_Entity_Enum_Class_Alt_Decl
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Entity_Enum_Class_Alt_Decl,
         Sequence_Type => Internal_Entity_Enum_Class_Alt_Decl_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Entity_Enum_Class_Alt_Decl;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Entity_Enum_Class_Alt_Decl;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Entity_Enum_Class_Alt_Decl_Array_Access) return Internal_Entity_Enum_Class_Alt_Decl_Array_Access is
      Ret : Internal_Entity_Enum_Class_Alt_Decl_Array_Access := Create_Internal_Entity_Enum_Class_Alt_Decl_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Entity_Enum_Class_Alt_Decl_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Entity_Enum_Class_Alt_Decl_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Entity_Enum_Class_Alt_Decl_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Entity_Enum_Class_Alt_Decl_Array (Items_Count : Natural) return Internal_Entity_Enum_Class_Alt_Decl_Array_Access
   is (if Items_Count = 0
       then No_Internal_Entity_Enum_Class_Alt_Decl_Array_Type
       else new Internal_Entity_Enum_Class_Alt_Decl_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Entity_Enum_Class_Alt_Decl_Array
     (Items : Internal_Internal_Entity_Enum_Class_Alt_Decl_Array) return Internal_Entity_Enum_Class_Alt_Decl_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Entity_Enum_Class_Alt_Decl_Array_Type;
      end if;

      return new Internal_Entity_Enum_Class_Alt_Decl_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Entity_Enum_Class_Alt_Decl_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Entity_Enum_Class_Alt_Decl_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Internal_Entity_Expr_Vectors is new Liblktlang_Support.Vectors (Internal_Entity_Expr);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Entity_Expr_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Entity_Expr
   is
      function Absolute_Get
        (T : Internal_Entity_Expr_Array_Access; Index : Integer)
         return Internal_Entity_Expr
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Entity_Expr,
         Sequence_Type => Internal_Entity_Expr_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Entity_Expr;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Entity_Expr;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Entity_Expr_Array_Access) return Internal_Entity_Expr_Array_Access is
      Ret : Internal_Entity_Expr_Array_Access := Create_Internal_Entity_Expr_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Entity_Expr_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Entity_Expr_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Entity_Expr_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Entity_Expr_Array (Items_Count : Natural) return Internal_Entity_Expr_Array_Access
   is (if Items_Count = 0
       then No_Internal_Entity_Expr_Array_Type
       else new Internal_Entity_Expr_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Entity_Expr_Array
     (Items : Internal_Internal_Entity_Expr_Array) return Internal_Entity_Expr_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Entity_Expr_Array_Type;
      end if;

      return new Internal_Entity_Expr_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Entity_Expr_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Entity_Expr_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Internal_Entity_Field_Decl_Vectors is new Liblktlang_Support.Vectors (Internal_Entity_Field_Decl);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Entity_Field_Decl_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Entity_Field_Decl
   is
      function Absolute_Get
        (T : Internal_Entity_Field_Decl_Array_Access; Index : Integer)
         return Internal_Entity_Field_Decl
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Entity_Field_Decl,
         Sequence_Type => Internal_Entity_Field_Decl_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Entity_Field_Decl;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Entity_Field_Decl;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Entity_Field_Decl_Array_Access) return Internal_Entity_Field_Decl_Array_Access is
      Ret : Internal_Entity_Field_Decl_Array_Access := Create_Internal_Entity_Field_Decl_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Entity_Field_Decl_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Entity_Field_Decl_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Entity_Field_Decl_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Entity_Field_Decl_Array (Items_Count : Natural) return Internal_Entity_Field_Decl_Array_Access
   is (if Items_Count = 0
       then No_Internal_Entity_Field_Decl_Array_Type
       else new Internal_Entity_Field_Decl_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Entity_Field_Decl_Array
     (Items : Internal_Internal_Entity_Field_Decl_Array) return Internal_Entity_Field_Decl_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Entity_Field_Decl_Array_Type;
      end if;

      return new Internal_Entity_Field_Decl_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Entity_Field_Decl_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Entity_Field_Decl_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Internal_Entity_Full_Decl_Vectors is new Liblktlang_Support.Vectors (Internal_Entity_Full_Decl);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Entity_Full_Decl_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Entity_Full_Decl
   is
      function Absolute_Get
        (T : Internal_Entity_Full_Decl_Array_Access; Index : Integer)
         return Internal_Entity_Full_Decl
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Entity_Full_Decl,
         Sequence_Type => Internal_Entity_Full_Decl_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Entity_Full_Decl;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Entity_Full_Decl;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Entity_Full_Decl_Array_Access) return Internal_Entity_Full_Decl_Array_Access is
      Ret : Internal_Entity_Full_Decl_Array_Access := Create_Internal_Entity_Full_Decl_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Entity_Full_Decl_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Entity_Full_Decl_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Entity_Full_Decl_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Entity_Full_Decl_Array (Items_Count : Natural) return Internal_Entity_Full_Decl_Array_Access
   is (if Items_Count = 0
       then No_Internal_Entity_Full_Decl_Array_Type
       else new Internal_Entity_Full_Decl_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Entity_Full_Decl_Array
     (Items : Internal_Internal_Entity_Full_Decl_Array) return Internal_Entity_Full_Decl_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Entity_Full_Decl_Array_Type;
      end if;

      return new Internal_Entity_Full_Decl_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Entity_Full_Decl_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Entity_Full_Decl_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Internal_Entity_Fun_Decl_Vectors is new Liblktlang_Support.Vectors (Internal_Entity_Fun_Decl);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Entity_Fun_Decl_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Entity_Fun_Decl
   is
      function Absolute_Get
        (T : Internal_Entity_Fun_Decl_Array_Access; Index : Integer)
         return Internal_Entity_Fun_Decl
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Entity_Fun_Decl,
         Sequence_Type => Internal_Entity_Fun_Decl_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Entity_Fun_Decl;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Entity_Fun_Decl;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Entity_Fun_Decl_Array_Access) return Internal_Entity_Fun_Decl_Array_Access is
      Ret : Internal_Entity_Fun_Decl_Array_Access := Create_Internal_Entity_Fun_Decl_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Entity_Fun_Decl_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Entity_Fun_Decl_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Entity_Fun_Decl_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Entity_Fun_Decl_Array (Items_Count : Natural) return Internal_Entity_Fun_Decl_Array_Access
   is (if Items_Count = 0
       then No_Internal_Entity_Fun_Decl_Array_Type
       else new Internal_Entity_Fun_Decl_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Entity_Fun_Decl_Array
     (Items : Internal_Internal_Entity_Fun_Decl_Array) return Internal_Entity_Fun_Decl_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Entity_Fun_Decl_Array_Type;
      end if;

      return new Internal_Entity_Fun_Decl_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Entity_Fun_Decl_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Entity_Fun_Decl_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Internal_Entity_Fun_Param_Decl_Vectors is new Liblktlang_Support.Vectors (Internal_Entity_Fun_Param_Decl);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Entity_Fun_Param_Decl_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Entity_Fun_Param_Decl
   is
      function Absolute_Get
        (T : Internal_Entity_Fun_Param_Decl_Array_Access; Index : Integer)
         return Internal_Entity_Fun_Param_Decl
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Entity_Fun_Param_Decl,
         Sequence_Type => Internal_Entity_Fun_Param_Decl_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Entity_Fun_Param_Decl;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Entity_Fun_Param_Decl;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Entity_Fun_Param_Decl_Array_Access) return Internal_Entity_Fun_Param_Decl_Array_Access is
      Ret : Internal_Entity_Fun_Param_Decl_Array_Access := Create_Internal_Entity_Fun_Param_Decl_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Entity_Fun_Param_Decl_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Entity_Fun_Param_Decl_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Entity_Fun_Param_Decl_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Entity_Fun_Param_Decl_Array (Items_Count : Natural) return Internal_Entity_Fun_Param_Decl_Array_Access
   is (if Items_Count = 0
       then No_Internal_Entity_Fun_Param_Decl_Array_Type
       else new Internal_Entity_Fun_Param_Decl_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Entity_Fun_Param_Decl_Array
     (Items : Internal_Internal_Entity_Fun_Param_Decl_Array) return Internal_Entity_Fun_Param_Decl_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Entity_Fun_Param_Decl_Array_Type;
      end if;

      return new Internal_Entity_Fun_Param_Decl_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Entity_Fun_Param_Decl_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Entity_Fun_Param_Decl_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Internal_Entity_Generic_Param_Type_Decl_Vectors is new Liblktlang_Support.Vectors (Internal_Entity_Generic_Param_Type_Decl);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Entity_Generic_Param_Type_Decl_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Entity_Generic_Param_Type_Decl
   is
      function Absolute_Get
        (T : Internal_Entity_Generic_Param_Type_Decl_Array_Access; Index : Integer)
         return Internal_Entity_Generic_Param_Type_Decl
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Entity_Generic_Param_Type_Decl,
         Sequence_Type => Internal_Entity_Generic_Param_Type_Decl_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Entity_Generic_Param_Type_Decl;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Entity_Generic_Param_Type_Decl;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Entity_Generic_Param_Type_Decl_Array_Access) return Internal_Entity_Generic_Param_Type_Decl_Array_Access is
      Ret : Internal_Entity_Generic_Param_Type_Decl_Array_Access := Create_Internal_Entity_Generic_Param_Type_Decl_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Entity_Generic_Param_Type_Decl_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Entity_Generic_Param_Type_Decl_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Entity_Generic_Param_Type_Decl_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Entity_Generic_Param_Type_Decl_Array (Items_Count : Natural) return Internal_Entity_Generic_Param_Type_Decl_Array_Access
   is (if Items_Count = 0
       then No_Internal_Entity_Generic_Param_Type_Decl_Array_Type
       else new Internal_Entity_Generic_Param_Type_Decl_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Entity_Generic_Param_Type_Decl_Array
     (Items : Internal_Internal_Entity_Generic_Param_Type_Decl_Array) return Internal_Entity_Generic_Param_Type_Decl_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Entity_Generic_Param_Type_Decl_Array_Type;
      end if;

      return new Internal_Entity_Generic_Param_Type_Decl_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Entity_Generic_Param_Type_Decl_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Entity_Generic_Param_Type_Decl_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Internal_Entity_Ref_Id_Vectors is new Liblktlang_Support.Vectors (Internal_Entity_Ref_Id);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Entity_Ref_Id_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Entity_Ref_Id
   is
      function Absolute_Get
        (T : Internal_Entity_Ref_Id_Array_Access; Index : Integer)
         return Internal_Entity_Ref_Id
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Entity_Ref_Id,
         Sequence_Type => Internal_Entity_Ref_Id_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Entity_Ref_Id;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Entity_Ref_Id;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Entity_Ref_Id_Array_Access) return Internal_Entity_Ref_Id_Array_Access is
      Ret : Internal_Entity_Ref_Id_Array_Access := Create_Internal_Entity_Ref_Id_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Entity_Ref_Id_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Entity_Ref_Id_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Entity_Ref_Id_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Entity_Ref_Id_Array (Items_Count : Natural) return Internal_Entity_Ref_Id_Array_Access
   is (if Items_Count = 0
       then No_Internal_Entity_Ref_Id_Array_Type
       else new Internal_Entity_Ref_Id_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Entity_Ref_Id_Array
     (Items : Internal_Internal_Entity_Ref_Id_Array) return Internal_Entity_Ref_Id_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Entity_Ref_Id_Array_Type;
      end if;

      return new Internal_Entity_Ref_Id_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Entity_Ref_Id_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Entity_Ref_Id_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Internal_Entity_Type_Decl_Vectors is new Liblktlang_Support.Vectors (Internal_Entity_Type_Decl);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Entity_Type_Decl_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Entity_Type_Decl
   is
      function Absolute_Get
        (T : Internal_Entity_Type_Decl_Array_Access; Index : Integer)
         return Internal_Entity_Type_Decl
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Entity_Type_Decl,
         Sequence_Type => Internal_Entity_Type_Decl_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Entity_Type_Decl;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Entity_Type_Decl;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Entity_Type_Decl_Array_Access) return Internal_Entity_Type_Decl_Array_Access is
      Ret : Internal_Entity_Type_Decl_Array_Access := Create_Internal_Entity_Type_Decl_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Entity_Type_Decl_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Entity_Type_Decl_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Entity_Type_Decl_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Entity_Type_Decl_Array (Items_Count : Natural) return Internal_Entity_Type_Decl_Array_Access
   is (if Items_Count = 0
       then No_Internal_Entity_Type_Decl_Array_Type
       else new Internal_Entity_Type_Decl_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Entity_Type_Decl_Array
     (Items : Internal_Internal_Entity_Type_Decl_Array) return Internal_Entity_Type_Decl_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Entity_Type_Decl_Array_Type;
      end if;

      return new Internal_Entity_Type_Decl_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Entity_Type_Decl_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Entity_Type_Decl_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;


      ----------
      -- Hash --
      ----------

      function Hash (R : Internal_Entity_Type_Decl_Array_Access) return Hash_Type is
         Result : Hash_Type := Initial_Hash;
      begin
         for I in R.Items'Range loop
            Result := Combine (Result, Hash (R.Items (I)));
         end loop;
         return Result;
      end Hash;


      

   

      package Internal_Env_Assoc_Vectors is new Liblktlang_Support.Vectors (Internal_Env_Assoc);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Env_Assoc_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Env_Assoc
   is
      function Absolute_Get
        (T : Internal_Env_Assoc_Array_Access; Index : Integer)
         return Internal_Env_Assoc
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Env_Assoc,
         Sequence_Type => Internal_Env_Assoc_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Env_Assoc;
   begin
      if Relative_Get (T, Index, Result) then
            Inc_Ref (Result);
         return Result;
      elsif Or_Null then
         return No_Env_Assoc;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Env_Assoc_Array_Access) return Internal_Env_Assoc_Array_Access is
      Ret : Internal_Env_Assoc_Array_Access := Create_Internal_Env_Assoc_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
         for Item of Ret.Items loop
            Inc_Ref (Item);
         end loop;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Env_Assoc_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Env_Assoc_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Env_Assoc_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
            for Item of T.Items loop
               Dec_Ref (Item);
            end loop;
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Env_Assoc_Array (Items_Count : Natural) return Internal_Env_Assoc_Array_Access
   is (if Items_Count = 0
       then No_Internal_Env_Assoc_Array_Type
       else new Internal_Env_Assoc_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Env_Assoc_Array
     (Items : Internal_Internal_Env_Assoc_Array) return Internal_Env_Assoc_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Env_Assoc_Array_Type;
      end if;

         for El of Items loop
            Inc_Ref (El);
         end loop;
      return new Internal_Env_Assoc_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Env_Assoc_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               not Equivalent (L.Items (I), R.Items (I))
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Env_Assoc_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Internal_Inner_Env_Assoc_Vectors is new Liblktlang_Support.Vectors (Internal_Inner_Env_Assoc);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Inner_Env_Assoc_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Inner_Env_Assoc
   is
      function Absolute_Get
        (T : Internal_Inner_Env_Assoc_Array_Access; Index : Integer)
         return Internal_Inner_Env_Assoc
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Inner_Env_Assoc,
         Sequence_Type => Internal_Inner_Env_Assoc_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Inner_Env_Assoc;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Inner_Env_Assoc;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Inner_Env_Assoc_Array_Access) return Internal_Inner_Env_Assoc_Array_Access is
      Ret : Internal_Inner_Env_Assoc_Array_Access := Create_Internal_Inner_Env_Assoc_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Inner_Env_Assoc_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Inner_Env_Assoc_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Inner_Env_Assoc_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Inner_Env_Assoc_Array (Items_Count : Natural) return Internal_Inner_Env_Assoc_Array_Access
   is (if Items_Count = 0
       then No_Internal_Inner_Env_Assoc_Array_Type
       else new Internal_Inner_Env_Assoc_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Inner_Env_Assoc_Array
     (Items : Internal_Internal_Inner_Env_Assoc_Array) return Internal_Inner_Env_Assoc_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Inner_Env_Assoc_Array_Type;
      end if;

      return new Internal_Inner_Env_Assoc_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Inner_Env_Assoc_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Inner_Env_Assoc_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   


   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Logic_Context_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Logic_Context
   is
      function Absolute_Get
        (T : Internal_Logic_Context_Array_Access; Index : Integer)
         return Internal_Logic_Context
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Logic_Context,
         Sequence_Type => Internal_Logic_Context_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Logic_Context;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Logic_Context;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Logic_Context_Array_Access) return Internal_Logic_Context_Array_Access is
      Ret : Internal_Logic_Context_Array_Access := Create_Internal_Logic_Context_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Logic_Context_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Logic_Context_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Logic_Context_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Logic_Context_Array (Items_Count : Natural) return Internal_Logic_Context_Array_Access
   is (if Items_Count = 0
       then No_Internal_Logic_Context_Array_Type
       else new Internal_Logic_Context_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Logic_Context_Array
     (Items : Internal_Internal_Logic_Context_Array) return Internal_Logic_Context_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Logic_Context_Array_Type;
      end if;

      return new Internal_Logic_Context_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Logic_Context_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Logic_Context_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Internal_Param_Match_Vectors is new Liblktlang_Support.Vectors (Internal_Param_Match);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Param_Match_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Param_Match
   is
      function Absolute_Get
        (T : Internal_Param_Match_Array_Access; Index : Integer)
         return Internal_Param_Match
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Param_Match,
         Sequence_Type => Internal_Param_Match_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Param_Match;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Param_Match;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Param_Match_Array_Access) return Internal_Param_Match_Array_Access is
      Ret : Internal_Param_Match_Array_Access := Create_Internal_Param_Match_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Param_Match_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Param_Match_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Param_Match_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Param_Match_Array (Items_Count : Natural) return Internal_Param_Match_Array_Access
   is (if Items_Count = 0
       then No_Internal_Param_Match_Array_Type
       else new Internal_Param_Match_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Param_Match_Array
     (Items : Internal_Internal_Param_Match_Array) return Internal_Param_Match_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Param_Match_Array_Type;
      end if;

      return new Internal_Param_Match_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Param_Match_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Param_Match_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Internal_Ref_Result_Vectors is new Liblktlang_Support.Vectors (Internal_Ref_Result);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Ref_Result_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Ref_Result
   is
      function Absolute_Get
        (T : Internal_Ref_Result_Array_Access; Index : Integer)
         return Internal_Ref_Result
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Ref_Result,
         Sequence_Type => Internal_Ref_Result_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Ref_Result;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Ref_Result;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Ref_Result_Array_Access) return Internal_Ref_Result_Array_Access is
      Ret : Internal_Ref_Result_Array_Access := Create_Internal_Ref_Result_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Ref_Result_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Ref_Result_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Ref_Result_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Ref_Result_Array (Items_Count : Natural) return Internal_Ref_Result_Array_Access
   is (if Items_Count = 0
       then No_Internal_Ref_Result_Array_Type
       else new Internal_Ref_Result_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Ref_Result_Array
     (Items : Internal_Internal_Ref_Result_Array) return Internal_Ref_Result_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Ref_Result_Array_Type;
      end if;

      return new Internal_Ref_Result_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Ref_Result_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Ref_Result_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Internal_Resolved_Param_Vectors is new Liblktlang_Support.Vectors (Internal_Resolved_Param);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Resolved_Param_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Resolved_Param
   is
      function Absolute_Get
        (T : Internal_Resolved_Param_Array_Access; Index : Integer)
         return Internal_Resolved_Param
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Resolved_Param,
         Sequence_Type => Internal_Resolved_Param_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Resolved_Param;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Resolved_Param;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Resolved_Param_Array_Access) return Internal_Resolved_Param_Array_Access is
      Ret : Internal_Resolved_Param_Array_Access := Create_Internal_Resolved_Param_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Resolved_Param_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Resolved_Param_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Resolved_Param_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Resolved_Param_Array (Items_Count : Natural) return Internal_Resolved_Param_Array_Access
   is (if Items_Count = 0
       then No_Internal_Resolved_Param_Array_Type
       else new Internal_Resolved_Param_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Resolved_Param_Array
     (Items : Internal_Internal_Resolved_Param_Array) return Internal_Resolved_Param_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Resolved_Param_Array_Type;
      end if;

      return new Internal_Resolved_Param_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Resolved_Param_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Resolved_Param_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;


      ----------
      -- Hash --
      ----------

      function Hash (R : Internal_Resolved_Param_Array_Access) return Hash_Type is
         Result : Hash_Type := Initial_Hash;
      begin
         for I in R.Items'Range loop
            Result := Combine (Result, Hash (R.Items (I)));
         end loop;
         return Result;
      end Hash;


      

   


   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Solver_Diagnostic_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Solver_Diagnostic
   is
      function Absolute_Get
        (T : Internal_Solver_Diagnostic_Array_Access; Index : Integer)
         return Internal_Solver_Diagnostic
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Solver_Diagnostic,
         Sequence_Type => Internal_Solver_Diagnostic_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Solver_Diagnostic;
   begin
      if Relative_Get (T, Index, Result) then
            Inc_Ref (Result);
         return Result;
      elsif Or_Null then
         return No_Solver_Diagnostic;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Solver_Diagnostic_Array_Access) return Internal_Solver_Diagnostic_Array_Access is
      Ret : Internal_Solver_Diagnostic_Array_Access := Create_Internal_Solver_Diagnostic_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
         for Item of Ret.Items loop
            Inc_Ref (Item);
         end loop;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Solver_Diagnostic_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Solver_Diagnostic_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Solver_Diagnostic_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
            for Item of T.Items loop
               Dec_Ref (Item);
            end loop;
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Solver_Diagnostic_Array (Items_Count : Natural) return Internal_Solver_Diagnostic_Array_Access
   is (if Items_Count = 0
       then No_Internal_Solver_Diagnostic_Array_Type
       else new Internal_Solver_Diagnostic_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Solver_Diagnostic_Array
     (Items : Internal_Internal_Solver_Diagnostic_Array) return Internal_Solver_Diagnostic_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Solver_Diagnostic_Array_Type;
      end if;

         for El of Items loop
            Inc_Ref (El);
         end loop;
      return new Internal_Solver_Diagnostic_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Solver_Diagnostic_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               not Equivalent (L.Items (I), R.Items (I))
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Solver_Diagnostic_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   


   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Internal_Unit_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Internal_Unit
   is
      function Absolute_Get
        (T : Internal_Unit_Array_Access; Index : Integer)
         return Internal_Unit
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Internal_Unit,
         Sequence_Type => Internal_Unit_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Internal_Unit;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return null;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Internal_Unit_Array_Access) return Internal_Unit_Array_Access is
      Ret : Internal_Unit_Array_Access := Create_Internal_Unit_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Unit_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Internal_Unit_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Unit_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Internal_Unit_Array (Items_Count : Natural) return Internal_Unit_Array_Access
   is (if Items_Count = 0
       then No_Internal_Unit_Array_Type
       else new Internal_Unit_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Internal_Unit_Array
     (Items : Internal_Internal_Unit_Array) return Internal_Unit_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Internal_Unit_Array_Type;
      end if;

      return new Internal_Unit_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Internal_Unit_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Unit_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Lexical_Env_Vectors is new Liblktlang_Support.Vectors (Lexical_Env);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Lexical_Env_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Lexical_Env
   is
      function Absolute_Get
        (T : Lexical_Env_Array_Access; Index : Integer)
         return Lexical_Env
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Lexical_Env,
         Sequence_Type => Lexical_Env_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Lexical_Env;
   begin
      if Relative_Get (T, Index, Result) then
            Inc_Ref (Result);
         return Result;
      elsif Or_Null then
         return Empty_Env;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Lexical_Env_Array_Access) return Lexical_Env_Array_Access is
      Ret : Lexical_Env_Array_Access := Create_Lexical_Env_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
         for Item of Ret.Items loop
            Inc_Ref (Item);
         end loop;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Lexical_Env_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Lexical_Env_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Lexical_Env_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
            for Item of T.Items loop
               Dec_Ref (Item);
            end loop;
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Lexical_Env_Array (Items_Count : Natural) return Lexical_Env_Array_Access
   is (if Items_Count = 0
       then No_Lexical_Env_Array_Type
       else new Lexical_Env_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Lexical_Env_Array
     (Items : Internal_Lexical_Env_Array) return Lexical_Env_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Lexical_Env_Array_Type;
      end if;

         for El of Items loop
            Inc_Ref (El);
         end loop;
      return new Lexical_Env_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Lexical_Env_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               not Equivalent (L.Items (I), R.Items (I))
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Lexical_Env_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Logic_Equation_Vectors is new Liblktlang_Support.Vectors (Logic_Equation);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Logic_Equation_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Logic_Equation
   is
      function Absolute_Get
        (T : Logic_Equation_Array_Access; Index : Integer)
         return Logic_Equation
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Logic_Equation,
         Sequence_Type => Logic_Equation_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Logic_Equation;
   begin
      if Relative_Get (T, Index, Result) then
            Inc_Ref (Result);
         return Result;
      elsif Or_Null then
         return Null_Logic_Equation;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Logic_Equation_Array_Access) return Logic_Equation_Array_Access is
      Ret : Logic_Equation_Array_Access := Create_Logic_Equation_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
         for Item of Ret.Items loop
            Inc_Ref (Item);
         end loop;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Logic_Equation_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Logic_Equation_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Logic_Equation_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
            for Item of T.Items loop
               Dec_Ref (Item);
            end loop;
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Logic_Equation_Array (Items_Count : Natural) return Logic_Equation_Array_Access
   is (if Items_Count = 0
       then No_Logic_Equation_Array_Type
       else new Logic_Equation_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Logic_Equation_Array
     (Items : Internal_Logic_Equation_Array) return Logic_Equation_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Logic_Equation_Array_Type;
      end if;

         for El of Items loop
            Inc_Ref (El);
         end loop;
      return new Logic_Equation_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Logic_Equation_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Logic_Equation_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Logic_Var_Vectors is new Liblktlang_Support.Vectors (Logic_Var);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Logic_Var_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Logic_Var
   is
      function Absolute_Get
        (T : Logic_Var_Array_Access; Index : Integer)
         return Logic_Var
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Logic_Var,
         Sequence_Type => Logic_Var_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Logic_Var;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return null;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Logic_Var_Array_Access) return Logic_Var_Array_Access is
      Ret : Logic_Var_Array_Access := Create_Logic_Var_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Logic_Var_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Logic_Var_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Logic_Var_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Logic_Var_Array (Items_Count : Natural) return Logic_Var_Array_Access
   is (if Items_Count = 0
       then No_Logic_Var_Array_Type
       else new Logic_Var_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Logic_Var_Array
     (Items : Internal_Logic_Var_Array) return Logic_Var_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Logic_Var_Array_Type;
      end if;

      return new Logic_Var_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Logic_Var_Array_Access) return Boolean is
      use type Logic_Var;
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Logic_Var_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package String_Type_Vectors is new Liblktlang_Support.Vectors (String_Type);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : String_Type_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return String_Type
   is
      function Absolute_Get
        (T : String_Type_Array_Access; Index : Integer)
         return String_Type
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => String_Type,
         Sequence_Type => String_Type_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : String_Type;
   begin
      if Relative_Get (T, Index, Result) then
            Inc_Ref (Result);
         return Result;
      elsif Or_Null then
         return Empty_String;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : String_Type_Array_Access) return String_Type_Array_Access is
      Ret : String_Type_Array_Access := Create_String_Type_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
         for Item of Ret.Items loop
            Inc_Ref (Item);
         end loop;
      return Ret;
   end Concat;

      ------------------
      -- Join_Strings --
      ------------------

      function Join_Strings
        (Separator : String_Type;
         Strings   : String_Type_Array_Access) return String_Type
      is
         Separator_Length : constant Natural := Separator.Length;
         Length           : Natural := 0;
         First            : Boolean;
      begin
         --  First, compute the length of the result: the sum of all string
         --  lengths in Strings.
         First := True;
         for S of Strings.Items loop
            if First then
               First := False;
            else
               Length := Length + Separator_Length;
            end if;
            Length := Length + S.Length;
         end loop;

         --  Create the result string with the correct length. Do not use our
         --  constructor and initialize the content in-place, to avoid extra
         --  copies.
         return Result : constant String_Type :=
            new String_Record (Length)
         do
            Result.Ref_Count := 1;

            --  Now copy the content of all strings into the result
            declare
               Last : Natural := 0;
            begin
               First := True;
               for S of Strings.Items loop
                  if First then
                     First := False;
                  else
                     Result.Content (Last + 1 .. Last + Separator_Length) :=
                        Separator.Content;
                     Last := Last + Separator_Length;
                  end if;
                  Result.Content (Last + 1 .. Last + S.Length) := S.Content;
                  Last := Last + S.Length;
               end loop;
            end;
         end return;
      end Join_Strings;

   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : String_Type_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : String_Type_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out String_Type_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
            for Item of T.Items loop
               Dec_Ref (Item);
            end loop;
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_String_Type_Array (Items_Count : Natural) return String_Type_Array_Access
   is (if Items_Count = 0
       then No_String_Type_Array_Type
       else new String_Type_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_String_Type_Array
     (Items : Internal_String_Type_Array) return String_Type_Array_Access is
   begin
      if Items'Length = 0 then
         return No_String_Type_Array_Type;
      end if;

         for El of Items loop
            Inc_Ref (El);
         end loop;
      return new String_Type_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : String_Type_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               not Equivalent (L.Items (I), R.Items (I))
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : String_Type_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;




      

   

      package Symbol_Type_Vectors is new Liblktlang_Support.Vectors (Symbol_Type);

   ---------
   -- Get --
   ---------

   function Get
     (Node    : Bare_Lkt_Node;
      T       : Symbol_Type_Array_Access;
      Index   : Integer;
      Or_Null : Boolean := False) return Symbol_Type
   is
      function Absolute_Get
        (T : Symbol_Type_Array_Access; Index : Integer)
         return Symbol_Type
      is
        (T.Items (Index + 1)); --  T.Items is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Symbol_Type,
         Sequence_Type => Symbol_Type_Array_Access,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Symbol_Type;
   begin
      if Relative_Get (T, Index, Result) then
         return Result;
      elsif Or_Null then
         return No_Symbol;
      else
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "out-of-bounds array access");
      end if;
   end Get;

   ------------
   -- Concat --
   ------------

   function Concat (L, R : Symbol_Type_Array_Access) return Symbol_Type_Array_Access is
      Ret : Symbol_Type_Array_Access := Create_Symbol_Type_Array (Length (L) + Length (R));
   begin
      Ret.Items := L.Items & R.Items;
      return Ret;
   end Concat;


   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Symbol_Type_Array_Access) is
   begin
      if T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   ------------
   -- Length --
   ------------

   function Length (T : Symbol_Type_Array_Access) return Natural is (T.N);

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Symbol_Type_Array_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

   function Create_Symbol_Type_Array (Items_Count : Natural) return Symbol_Type_Array_Access
   is (if Items_Count = 0
       then No_Symbol_Type_Array_Type
       else new Symbol_Type_Array_Record'(N => Items_Count, Ref_Count => 1, Items => <>));


   function Create_Symbol_Type_Array
     (Items : Internal_Symbol_Type_Array) return Symbol_Type_Array_Access is
   begin
      if Items'Length = 0 then
         return No_Symbol_Type_Array_Type;
      end if;

      return new Symbol_Type_Array_Record'
        (N => Items'Length, Ref_Count => 1, Items => Items);
   end;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (L, R : Symbol_Type_Array_Access) return Boolean is
   begin
      if L.N /= R.N then
         return False;
      end if;

      for I in L.Items'Range loop
         if
               L.Items (I) /= R.Items (I)
         then
            return False;
         end if;
      end loop;

      return True;
   end Equivalent;


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Symbol_Type_Array_Access) return String is
         Result : Unbounded_String;
      begin
         Append (Result, "[");
         for I in A.Items'Range loop
            if I > A.Items'First then
               Append (Result, ", ");
            end if;
            Append (Result, Trace_Image (A.Items (I)));
         end loop;
         Append (Result, "]");
         return To_String (Result);
      end Trace_Image;





         

   

   ----------
   -- Next --
   ----------

   function Next
     (T       : Bare_Lkt_Node_Iterator_Access;
      Element : out Bare_Lkt_Node) return Boolean is
   begin
      if T = null then
         raise Property_Error with "null access dereference";
      end if;
      Check_Safety_Net (T.Safety_Net);

      if T.Index > T.Elements.Items'Last then
         return False;
      else
         Element := T.Elements.Items (T.Index);
         T.Index := T.Index + 1;
         return True;
      end if;
   end Next;

   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Bare_Lkt_Node_Iterator_Access) is
   begin
      if T /= null and then T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Bare_Lkt_Node_Iterator_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Dec_Ref (T.Elements);
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Bare_Lkt_Node_Iterator_Access) return String is
      begin
         return "<Iterator of LktNode, index="
                & A.Index'Image & ">";
      end Trace_Image;


         

   

   ----------
   -- Next --
   ----------

   function Next
     (T       : Internal_Entity_Iterator_Access;
      Element : out Internal_Entity) return Boolean is
   begin
      if T = null then
         raise Property_Error with "null access dereference";
      end if;
      Check_Safety_Net (T.Safety_Net);

      if T.Index > T.Elements.Items'Last then
         return False;
      else
         Element := T.Elements.Items (T.Index);
         T.Index := T.Index + 1;
         return True;
      end if;
   end Next;

   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Entity_Iterator_Access) is
   begin
      if T /= null and then T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Entity_Iterator_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Dec_Ref (T.Elements);
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Entity_Iterator_Access) return String is
      begin
         return "<Iterator of Entity[LktNode], index="
                & A.Index'Image & ">";
      end Trace_Image;


         

   

   ----------
   -- Next --
   ----------

   function Next
     (T       : Internal_Inner_Env_Assoc_Iterator_Access;
      Element : out Internal_Inner_Env_Assoc) return Boolean is
   begin
      if T = null then
         raise Property_Error with "null access dereference";
      end if;
      Check_Safety_Net (T.Safety_Net);

      if T.Index > T.Elements.Items'Last then
         return False;
      else
         Element := T.Elements.Items (T.Index);
         T.Index := T.Index + 1;
         return True;
      end if;
   end Next;

   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (T : Internal_Inner_Env_Assoc_Iterator_Access) is
   begin
      if T /= null and then T.Ref_Count >= 0 then
         T.Ref_Count := T.Ref_Count + 1;
      end if;
   end Inc_Ref;

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (T : in out Internal_Inner_Env_Assoc_Iterator_Access) is
   begin
      if T = null or else T.Ref_Count < 0 then
         return;
      end if;

      if T.Ref_Count = 1 then
         Dec_Ref (T.Elements);
         Free (T);
      else
         T.Ref_Count := T.Ref_Count - 1;
         T := null;
      end if;
   end Dec_Ref;

      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (A : Internal_Inner_Env_Assoc_Iterator_Access) return String is
      begin
         return "<Iterator of InnerEnvAssoc, index="
                & A.Index'Image & ">";
      end Trace_Image;




   ---------
   -- "<" --
   ---------

   function "<" (Left, Right : Internal_Unit) return Boolean is
   begin
      return Left.Filename < Right.Filename;
   end "<";

      



function Hash (Key : Mmz_Key_Item) return Hash_Type;
function Equivalent (L, R : Mmz_Key_Item) return Boolean;
procedure Destroy (Key : in out Mmz_Key_Array_Access);

----------------
-- Equivalent --
----------------

function Equivalent (L, R : Mmz_Key_Item) return Boolean is
begin
   if L.Kind /= R.Kind then
      return False;
   end if;

   case L.Kind is
         when Mmz_Bare_Argument_List =>
            
               return L.As_Bare_Argument_List = R.As_Bare_Argument_List;
         when Mmz_Bare_Basic_Class_Decl =>
            
               return L.As_Bare_Basic_Class_Decl = R.As_Bare_Basic_Class_Decl;
         when Mmz_Bare_Decl =>
            
               return L.As_Bare_Decl = R.As_Bare_Decl;
         when Mmz_Bare_Dot_Expr =>
            
               return L.As_Bare_Dot_Expr = R.As_Bare_Dot_Expr;
         when Mmz_Bare_Expr =>
            
               return L.As_Bare_Expr = R.As_Bare_Expr;
         when Mmz_Bare_Lexer_Decl =>
            
               return L.As_Bare_Lexer_Decl = R.As_Bare_Lexer_Decl;
         when Mmz_Bare_Lkt_Node =>
            
               return L.As_Bare_Lkt_Node = R.As_Bare_Lkt_Node;
         when Mmz_Bare_Ref_Id =>
            
               return L.As_Bare_Ref_Id = R.As_Bare_Ref_Id;
         when Mmz_Bare_Struct_Decl =>
            
               return L.As_Bare_Struct_Decl = R.As_Bare_Struct_Decl;
         when Mmz_Bare_Type_Decl =>
            
               return L.As_Bare_Type_Decl = R.As_Bare_Type_Decl;
         when Mmz_Bare_Type_Ref =>
            
               return L.As_Bare_Type_Ref = R.As_Bare_Type_Ref;
         when Mmz_Boolean =>
            
               return L.As_Boolean = R.As_Boolean;
         when Mmz_Env_Rebindings =>
            
               return L.As_Env_Rebindings = R.As_Env_Rebindings;
         when Mmz_Internal_Entity =>
            
               return L.As_Internal_Entity = R.As_Internal_Entity;
         when Mmz_Internal_Entity_Argument_List =>
            
               return L.As_Internal_Entity_Argument_List = R.As_Internal_Entity_Argument_List;
         when Mmz_Internal_Entity_Decl =>
            
               return L.As_Internal_Entity_Decl = R.As_Internal_Entity_Decl;
         when Mmz_Internal_Entity_Info =>
            
               return L.As_Internal_Entity_Info = R.As_Internal_Entity_Info;
         when Mmz_Internal_Entity_Type_Decl =>
            
               return L.As_Internal_Entity_Type_Decl = R.As_Internal_Entity_Type_Decl;
         when Mmz_Internal_Entity_Type_Decl_Array_Access =>
            
               return Equivalent (L.As_Internal_Entity_Type_Decl_Array_Access, R.As_Internal_Entity_Type_Decl_Array_Access);
         when Mmz_Internal_Metadata =>
            
               return L.As_Internal_Metadata = R.As_Internal_Metadata;
         when Mmz_Internal_Resolved_Param_Array_Access =>
            
               return Equivalent (L.As_Internal_Resolved_Param_Array_Access, R.As_Internal_Resolved_Param_Array_Access);
         when Mmz_Symbol_Type =>
            
               return L.As_Symbol_Type = R.As_Symbol_Type;
   end case;
end Equivalent;

----------
-- Hash --
----------

function Hash (Key : Mmz_Key_Item) return Hash_Type is
begin
   case Key.Kind is
         when Mmz_Bare_Argument_List =>
            return Hash (Key.As_Bare_Argument_List);
         when Mmz_Bare_Basic_Class_Decl =>
            return Hash (Key.As_Bare_Basic_Class_Decl);
         when Mmz_Bare_Decl =>
            return Hash (Key.As_Bare_Decl);
         when Mmz_Bare_Dot_Expr =>
            return Hash (Key.As_Bare_Dot_Expr);
         when Mmz_Bare_Expr =>
            return Hash (Key.As_Bare_Expr);
         when Mmz_Bare_Lexer_Decl =>
            return Hash (Key.As_Bare_Lexer_Decl);
         when Mmz_Bare_Lkt_Node =>
            return Hash (Key.As_Bare_Lkt_Node);
         when Mmz_Bare_Ref_Id =>
            return Hash (Key.As_Bare_Ref_Id);
         when Mmz_Bare_Struct_Decl =>
            return Hash (Key.As_Bare_Struct_Decl);
         when Mmz_Bare_Type_Decl =>
            return Hash (Key.As_Bare_Type_Decl);
         when Mmz_Bare_Type_Ref =>
            return Hash (Key.As_Bare_Type_Ref);
         when Mmz_Boolean =>
            return Hash (Key.As_Boolean);
         when Mmz_Env_Rebindings =>
            return Hash (Key.As_Env_Rebindings);
         when Mmz_Internal_Entity =>
            return Hash (Key.As_Internal_Entity);
         when Mmz_Internal_Entity_Argument_List =>
            return Hash (Key.As_Internal_Entity_Argument_List);
         when Mmz_Internal_Entity_Decl =>
            return Hash (Key.As_Internal_Entity_Decl);
         when Mmz_Internal_Entity_Info =>
            return Hash (Key.As_Internal_Entity_Info);
         when Mmz_Internal_Entity_Type_Decl =>
            return Hash (Key.As_Internal_Entity_Type_Decl);
         when Mmz_Internal_Entity_Type_Decl_Array_Access =>
            return Hash (Key.As_Internal_Entity_Type_Decl_Array_Access);
         when Mmz_Internal_Metadata =>
            return Hash (Key.As_Internal_Metadata);
         when Mmz_Internal_Resolved_Param_Array_Access =>
            return Hash (Key.As_Internal_Resolved_Param_Array_Access);
         when Mmz_Symbol_Type =>
            return Hash (Key.As_Symbol_Type);
   end case;
end Hash;

----------
-- Hash --
----------

function Hash (Key : Mmz_Key) return Hash_Type is
   Result : Hash_Type := Mmz_Property'Pos (Key.Property);
begin
   for K of Key.Items.all loop
      Result := Combine (Result, Hash (K));
   end loop;
   return Result;
end Hash;

----------------
-- Equivalent --
----------------

function Equivalent (L, R : Mmz_Key) return Boolean is
   L_Items : Mmz_Key_Array renames L.Items.all;
   R_Items : Mmz_Key_Array renames R.Items.all;
begin
   if L.Property /= R.Property or else L_Items'Length /= R_Items'Length then
      return False;
   end if;

   for I in L_Items'Range loop
      if not Equivalent (L_Items (I), R_Items (I)) then
         return False;
      end if;
   end loop;

   return True;
end Equivalent;

-------------
-- Destroy --
-------------

procedure Destroy (Map : in out Memoization_Maps.Map) is
   use Memoization_Maps;

   --  We need keys and values to be valid when clearing the memoization map,
   --  but on the other hand we need to free keys and values as well. To
   --  achieve both goals, we first copy key and values into arrays, then we
   --  clear the map, and then we free keys/values in the arrays. Allocate both
   --  arrays on the heap to avoid stack overflow, as they can be quite big.

   Length : constant Natural := Natural (Map.Length);

   type Key_Array is array (1 .. Length) of Mmz_Key_Array_Access;
   type Key_Array_Access is access Key_Array;
   procedure Free is new Ada.Unchecked_Deallocation
     (Key_Array, Key_Array_Access);

   type Value_Array is array (1 .. Length) of Mmz_Value;
   type Value_Array_Access is access Value_Array;
   procedure Free is new Ada.Unchecked_Deallocation
     (Value_Array, Value_Array_Access);

   Keys   : Key_Array_Access := new Key_Array;
   Values : Value_Array_Access := new Value_Array;
   I      : Positive := 1;
begin
   for Cur in Map.Iterate loop
      Keys (I) := Key (Cur).Items;
      Values (I) := Element (Cur);
      I := I + 1;
   end loop;

   Map.Clear;

   for K_Array of Keys.all loop
      Destroy (K_Array);
   end loop;

   
   for V of Values.all loop
      case V.Kind is
         when Mmz_Error =>
            Free_Memoized_Error (V.Exc_Id, V.Exc_Msg);

            when Mmz_Internal_Env_Assoc_Array_Access =>
               Dec_Ref (V.As_Internal_Env_Assoc_Array_Access);
            when Mmz_Internal_Param_Match_Array_Access =>
               Dec_Ref (V.As_Internal_Param_Match_Array_Access);
            when Mmz_Internal_Resolved_Param_Array_Access =>
               Dec_Ref (V.As_Internal_Resolved_Param_Array_Access);
            when Mmz_Internal_Solver_Result =>
               Dec_Ref (V.As_Internal_Solver_Result);
            when Mmz_Lexical_Env =>
               Dec_Ref (V.As_Lexical_Env);

         when others => null;
      end case;
   end loop;

   Free (Keys);
   Free (Values);
end Destroy;

-------------
-- Destroy --
-------------

procedure Destroy (Key : in out Mmz_Key_Array_Access) is
   procedure Free is new Ada.Unchecked_Deallocation
     (Mmz_Key_Array, Mmz_Key_Array_Access);
begin
   

      for K of Key.all loop
         case K.Kind is
               when Mmz_Internal_Entity_Type_Decl_Array_Access =>
                  Dec_Ref (K.As_Internal_Entity_Type_Decl_Array_Access);
               when Mmz_Internal_Resolved_Param_Array_Access =>
                  Dec_Ref (K.As_Internal_Resolved_Param_Array_Access);

            when others => null;
         end case;
      end loop;
   Free (Key);
end Destroy;

-------------------------
-- Find_Memoized_Value --
-------------------------

function Find_Memoized_Value
  (Unit       : Internal_Unit;
   Handle     : out Memoization_Handle;
   Value      : out Mmz_Value;
   Create_Key : access function return Mmz_Key) return Boolean
is
   Inserted : Boolean;
begin
   --  Make sure that we don't lookup stale caches
   Reset_Caches (Unit);

   --  Initialize handle: create the key and create a cursor pointing to an
   --  existing entry.
   Handle.Key := Create_Key.all;
   Handle.Cache_Version := Unit.Cache_Version;
   Value := (Kind => Mmz_Evaluating);
   Unit.Memoization_Map.Insert (Handle.Key, Value, Handle.Cur, Inserted);

   --  No existing entry yet? The above just created one. Otherwise, destroy
   --  our key and reuse the existing entry's.
   if not Inserted then
      Destroy (Handle.Key.Items);
      Handle.Key := Memoization_Maps.Key (Handle.Cur);
      Value := Memoization_Maps.Element (Handle.Cur);
   end if;

   return not Inserted;
end Find_Memoized_Value;

------------------------
-- Add_Memoized_Value --
------------------------

procedure Add_Memoized_Value
  (Unit   : Internal_Unit;
   Handle : in out Memoization_Handle;
   Value  : Mmz_Value;
   Stored : out Boolean) is
begin
   --  If Handle was created using a memoization map that has been since then
   --  reset, do nothing: the result can be partly stale due to the event that
   --  triggered the memoization tables reset.

   Stored := Unit.Cache_Version <= Handle.Cache_Version;
   if Stored then
      Unit.Memoization_Map.Replace_Element (Handle.Cur, Value);
   end if;
end Add_Memoized_Value;

------------------------
-- Add_Memoized_Error --
------------------------

procedure Add_Memoized_Error
  (Unit   : Internal_Unit;
   Handle : in out Memoization_Handle;
   Exc    : Ada.Exceptions.Exception_Occurrence;
   Stored : out Boolean)
is
   Value : Mmz_Value (Kind => Mmz_Error);
begin
   Store_Memoized_Error (Exc, Value.Exc_Id, Value.Exc_Msg);
   Add_Memoized_Value (Unit, Handle, Value, Stored);
   if not Stored then
      Free_Memoized_Error (Value.Exc_Id, Value.Exc_Msg);
   end if;
end Add_Memoized_Error;

----------------------------
-- Reraise_Memoized_Error --
----------------------------

procedure Reraise_Memoized_Error (Value : Mmz_Value) is
begin
   Reraise_Memoized_Error (Value.Exc_Id, Value.Exc_Msg);
end Reraise_Memoized_Error;

--------------------------
-- Store_Memoized_Error --
--------------------------

procedure Store_Memoized_Error
  (Exc     : Ada.Exceptions.Exception_Occurrence;
   Exc_Id  : out Ada.Exceptions.Exception_Id;
   Exc_Msg : out String_Access) is
begin
   Exc_Id := Ada.Exceptions.Exception_Identity (Exc);
   Exc_Msg := new String'(Ada.Exceptions.Exception_Message (Exc));
end Store_Memoized_Error;

-------------------------
-- Free_Memoized_Error --
-------------------------

procedure Free_Memoized_Error
  (Exc_Id  : in out Ada.Exceptions.Exception_Id;
   Exc_Msg : in out String_Access)
is
   pragma Unreferenced (Exc_Id);
begin
   Free (Exc_Msg);
end Free_Memoized_Error;

----------------------------
-- Reraise_Memoized_Error --
----------------------------

procedure Reraise_Memoized_Error
  (Exc_Id  : Ada.Exceptions.Exception_Id;
   Exc_Msg : String_Access) is
begin
   Ada.Exceptions.Raise_Exception (Exc_Id, Exc_Msg.all & " (memoized)");
end Reraise_Memoized_Error;



   package Solver_Diagnostic_Vectors is new Liblktlang_Support.Vectors
     (Internal_Solver_Diagnostic);

   ----------------------------
   -- Allocate_Logic_Context --
   ----------------------------

   function Allocate_Logic_Context
     (Ctx : Internal_Logic_Context) return Internal_Logic_Context_Access
   is ((if Ctx.Ref_Node = No_Entity
           and then Ctx.Decl_Node = No_Entity
        then null
        else new Internal_Logic_Context'(Ctx)));

   -------------------------
   -- Trace_Logic_Context --
   -------------------------

   function Trace_Logic_Context
     (Ctx : Internal_Logic_Context_Access) return String
   is (Trace_Image (Ctx.all));

   -----------------
   -- Deep_Equals --
   -----------------

   function Deep_Equals
     (X, Y : Internal_Logic_Context_Access) return Boolean
   is (X.all = Y.all);

   ------------------------
   -- Free_Logic_Context --
   ------------------------

   procedure Free_Logic_Context
     (Ctx : in out Internal_Logic_Context_Access)
   is
      procedure Free is new Ada.Unchecked_Deallocation
        (Internal_Logic_Context, Internal_Logic_Context_Access);
   begin
      Free (Ctx);
   end Free_Logic_Context;

   -------------------
   -- Solve_Wrapper --
   -------------------

   function Solve_Wrapper
     (R            : Solver.Relation;
      Context_Node : Bare_Lkt_Node) return Boolean is
   begin
      if Context_Node /= null and then Liblktlang_Support.Adalog.Debug.Debug then
         Assign_Names_To_Logic_Vars (Context_Node);
      end if;

      begin
         return Solver.Solve_First
           (R, Timeout => Context_Node.Unit.Context.Logic_Resolution_Timeout);
      exception
         when Liblktlang_Support.Adalog.Early_Binding_Error =>
            Raise_Property_Exception
              (Context_Node,
               Property_Error'Identity,
               "invalid equation for logic resolution");
         when Liblktlang_Support.Adalog.Timeout_Error =>
            Raise_Property_Exception
              (Context_Node,
               Property_Error'Identity,
               "logic resolution timed out");
      end;
   end Solve_Wrapper;

   ----------------------------
   -- Solve_With_Diagnostics --
   ----------------------------

   function Solve_With_Diagnostics
     (R            : Solver.Relation;
      Context_Node : Bare_Lkt_Node) return Internal_Solver_Result
   is
      Ret : Internal_Solver_Result :=
        (True, No_Internal_Solver_Diagnostic_Array_Type);

      Acc : Solver_Diagnostic_Vectors.Vector;
      --  Vectors that will accumulate diagnostic emitted during resolution

      procedure Emit_Diagnostic (Diag : Internal_Solver_Diagnostic) is
      begin
         Acc.Append (Diag);
      end Emit_Diagnostic;
   begin
      Ret.Success := Solve_Wrapper (R, Context_Node);

      if not Ret.Success then
         Ret.Success := Solver.Solve_First
           (R,
            Solve_Options => (Report_Errors => True),
            Diag_Emitter  => Emit_Diagnostic'Unrestricted_Access,
            Timeout       =>
              Context_Node.Unit.Context.Logic_Resolution_Timeout);
         Ret.Diagnostics := Create_Internal_Solver_Diagnostic_Array
           (Acc.Length);
         for I in 1 .. Acc.Length loop
            Ret.Diagnostics.Items (I) := Acc.Get (I);
         end loop;
         Acc.Destroy;
      end if;
      return Ret;
   end Solve_With_Diagnostics;

   -------------
   -- Destroy --
   -------------

   procedure Destroy (Env : in out Lexical_Env_Access) is
      Mutable_Env : Lexical_Env :=
        (Wrap (Env), 0, Env.Kind, No_Generic_Unit, 0);
   begin
      Destroy (Mutable_Env);
      Env := null;
   end Destroy;

   ----------------
   -- Initialize --
   ----------------

   procedure Initialize
     (Self              : Bare_Lkt_Node;
      Kind              : Lkt_Node_Kind_Type;
      Unit              : Internal_Unit;
      Token_Start_Index : Token_Index;
      Token_End_Index   : Token_Index;
      Parent            : Bare_Lkt_Node := null;
      Self_Env          : Lexical_Env := AST_Envs.Empty_Env) is
   begin
      pragma Unreferenced (Kind);
      Self.Parent := Parent;
      Self.Unit := Unit;

      Self.Token_Start_Index := Token_Start_Index;
      Self.Token_End_Index := Token_End_Index;

      Self.Self_Env := Self_Env;
      Self.Last_Attempted_Child := -1;

      

   end Initialize;

   --------------------------------------
   -- Allocate_Synthetic_List_Children --
   --------------------------------------

   function Allocate_Synthetic_List_Children
     (Self  : Bare_Lkt_Node_Base_List;
      Count : Natural) return Alloc_AST_List_Array.Element_Array_Access
   is
      use Alloc_AST_List_Array;
      use System.Memory;

      Size : constant size_t :=
        Bare_Lkt_Node'Max_Size_In_Storage_Elements * size_t (Count);
   begin
      return Result : constant Element_Array_Access :=
        (if Count = 0
         then Empty_Array_Access
         else To_Pointer (System.Memory.Alloc (Size)))
      do
         Self.Count := Count;
         Self.Nodes := Result;
      end return;
   end Allocate_Synthetic_List_Children;

   ----------------------------------
   -- Free_Synthetic_List_Children --
   ----------------------------------

   procedure Free_Synthetic_List_Children
     (Self : Bare_Lkt_Node_Base_List)
   is
      use Alloc_AST_List_Array;
      use System.Memory;
   begin
      if Self.Nodes /= Empty_Array_Access then
         Free (To_Address (Self.Nodes));
      end if;
   end Free_Synthetic_List_Children;

   --------------------
   -- Use_Direct_Env --
   --------------------

   procedure Use_Direct_Env (State : in out PLE_Node_State; Env : Lexical_Env)
   is
   begin
      State.Current_Env := Env;
      State.Current_NED := null;
   end Use_Direct_Env;

   -------------------
   -- Use_Named_Env --
   -------------------

   procedure Use_Named_Env
     (State   : in out PLE_Node_State;
      Context : Internal_Context;
      Name    : Symbol_Type) is
   begin
      State.Current_NED := Get_Named_Env_Descriptor (Context, Name);
      State.Current_Env := State.Current_NED.Env_With_Precedence;
   end Use_Named_Env;

   ---------------------
   -- Set_Initial_Env --
   ---------------------

   procedure Set_Initial_Env
     (Self         : Bare_Lkt_Node;
      State        : in out PLE_Node_State;
      Env          : Internal_Designated_Env;
      DSL_Location : String) is
   begin
      case Env.Kind is
         when None =>
            Use_Direct_Env (State, Empty_Env);

         when Current_Env =>
            null;

         when Named_Env =>
            Use_Named_Env (State, Self.Unit.Context, Env.Env_Name);

         when Direct_Env =>

            --  Sanitize this environment value: make sure it's a non-foreign
            --  and primary environment.

            if Env.Direct_Env.Kind /= Static_Primary then
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Cannot set an env that is not static-primary as the"
                  & " initial env");

            elsif Is_Foreign_Strict (Env.Direct_Env, Self) then
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "unsound foreign environment in SetInitialEnv ("
                  & DSL_Location & ")");
            end if;
            Use_Direct_Env (State, Env.Direct_Env);
      end case;
   end Set_Initial_Env;

   ----------------
   -- Add_To_Env --
   ----------------

   procedure Add_To_Env
     (Self         : Bare_Lkt_Node;
      State        : PLE_Node_State;
      Key          : Symbol_Type;
      Value        : Bare_Lkt_Node;
      Md           : Internal_Metadata;
      Resolver     : Entity_Resolver;
      Dest_Env     : Internal_Designated_Env;
      DSL_Location : String)
   is
      Context    : constant Internal_Context := Self.Unit.Context;
      Root_Scope : Lexical_Env renames Context.Root_Scope;
      --  Shortcuts

      Actual_Dest_Env : Lexical_Env;
      Dest_NED        : Named_Env_Descriptor_Access;
      --  Description for the destination environment
   begin
      --  Skip the env addition if explicitly requested

      if Key = No_Symbol
         or else Value = null
         or else (case Dest_Env.Kind is
                  when None        => True,
                  when Current_Env => False,
                  when Named_Env   => Dest_Env.Env_Name = No_Symbol,
                  when Direct_Env  => Dest_Env.Direct_Env = Empty_Env)
      then
         return;
      end if;

      if Value.Unit /= Self.Unit then
         Raise_Property_Exception
           (Self,
            Property_Error'Identity,
            "Cannot add_to_env an AST node that comes from another analysis"
            & " unit");
      end if;

      

      --  Then determine the destination environment

      case Dest_Env.Kind is
         when None =>
            raise Program_Error with "unreachable code";

         when Current_Env =>
            --  Just use the current environment
            Dest_NED := State.Current_NED;
            Actual_Dest_Env := State.Current_Env;

         when Named_Env =>
            --  There is an environment name: just lookup the corresponding
            --  NED/env.
            Dest_NED := Get_Named_Env_Descriptor (Context, Dest_Env.Env_Name);
            Actual_Dest_Env := Dest_NED.Env_With_Precedence;

         when Direct_Env =>
            --  There is an explicit destination environment
            Dest_NED := null;
            Actual_Dest_Env := Dest_Env.Direct_Env;
      end case;

      --  Sanitize it

      if Actual_Dest_Env.Kind /= Static_Primary then
         Raise_Property_Exception
           (Self,
            Property_Error'Identity,
            "Cannot add elements to a lexical env that is not static-primary");

      elsif
         --  Since lexical envs need to sort the foreign nodes they contain,
         --  and that the total order on nodes is not defined for synthetic
         --  nodes, it is not possible to add a synthetic node to a foreign
         --  lexical environment.
         --
         --  This reasoning applies to environments that belong to foreign
         --  units, but also to the root environment.
         Is_Foreign (Actual_Dest_Env, Self) and then Is_Synthetic (Value)
      then
         Raise_Property_Exception
           (Self,
            Property_Error'Identity,
            "Cannot add a synthetic node to a lexical env from another"
            & " analysis unit");

      elsif
         --  Reject direct references to foreign destination environments.
         --
         --  This is an attempt at identifying uses of the unsound relocation
         --  mechanism (as opposed to named environments), so this applies to
         --  all foreign environments (root scope included).
         DSL_Location'Length > 0
         and then Dest_Env.Kind = Direct_Env
         and then Is_Foreign_Strict (Actual_Dest_Env, Self)
      then
         Raise_Property_Exception
           (Self,
            Property_Error'Identity,
            "unsound foreign environment in AddToEnv (" & DSL_Location & ")");
      end if;

      --  Now that everything is sanitized, we can proceed with the actual
      --  key/value pair addition. Note that this does nothing if
      --  Actual_Dest_Env ended up empty.
      Add (Actual_Dest_Env, Thin (Key), Value, Md, Resolver);

      --  If we're adding the element to an environment by env name, we must
      --  register this association in two places: in the target named env
      --  entry, and in Value's unit.
      if Dest_NED /= null then
         declare
            use NED_Assoc_Maps;

            FN    : Map renames Dest_NED.Foreign_Nodes;
            Dummy : Boolean;
            Cur   : Cursor;
         begin
            FN.Insert (Key      => Key,
                       New_Item => Internal_Map_Node_Vectors.Empty_Vector,
                       Position => Cur,
                       Inserted => Dummy);
            declare
               V : Internal_Map_Node_Vectors.Vector renames
                  FN.Reference (Cur);
            begin
               V.Append ((Value, null, Md, Resolver));
               --  Note that the rebindings field is unused by the relocation
               --  mechanism (since we don't even allow adding env entries
               --  with custom rebindings), hence we simply leave it to null.
            end;
         end;
         Value.Unit.Exiled_Entries_In_NED.Append ((Dest_NED, Key, Value));

      --  Otherwise, if we're adding the element to an environment that belongs
      --  to a different unit, or to the root scope, then...
      elsif Is_Foreign_Not_Empty (Actual_Dest_Env, Self) then
         --  Add the Key/Value association to the list of entries contained in
         --  other units, so we can remove them when reparsing Value's unit.
         Value.Unit.Exiled_Entries.Append ((Actual_Dest_Env, Key, Value));

         if Actual_Dest_Env /= Root_Scope then
            --  Add Val to the list of foreign nodes that Actual_Dest_Env's
            --  unit contains, so that when that unit is reparsed, we can call
            --  Add_To_Env again on those nodes.
            Convert_Unit (Actual_Dest_Env.Owner).Foreign_Nodes.Append
              ((Value, Self.Unit));
         end if;
      end if;
   end Add_To_Env;

   -------------
   -- Ref_Env --
   -------------

   procedure Ref_Env
     (Self                : Bare_Lkt_Node;
      Dest_Env            : Lexical_Env;
      Ref_Env_Nodes       : in out Bare_Lkt_Node_Array_Access;
      Resolver            : Lexical_Env_Resolver;
      Kind                : Ref_Kind;
      Cats                : Ref_Categories;
      Shed_Rebindings     : Boolean) is
   begin
      for N of Ref_Env_Nodes.Items loop
         if N /= null then
            if N.Unit /= Self.Unit then
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "attempt to add a referenced environment to a foreign unit");
            end if;
            Reference (Dest_Env, N, Resolver, Kind, Cats, Shed_Rebindings);
         end if;
      end loop;
      Dec_Ref (Ref_Env_Nodes);
   end Ref_Env;

   -------------
   -- Add_Env --
   -------------

   procedure Add_Env
     (Self              : Bare_Lkt_Node;
      State             : in out PLE_Node_State;
      No_Parent         : Boolean;
      Transitive_Parent : Boolean;
      Names             : in out Symbol_Type_Array_Access)
   is
      Parent_From_Name : constant Boolean := State.Current_NED /= null;
      --  Does the parent environment comes from a named environment lookup?

      --  Determine the parent of this new environment:
      --
      --  (1) no parent if requested;
      --  (2) the current environment as the static parent if it comes from a
      --      named env lookup or if it is not foreign (or is the empty/root
      --      environment).
      Parent : constant Lexical_Env :=
        (if No_Parent
         then Null_Lexical_Env
         else State.Current_Env);
   begin
      --  Create the environment itself
      Self.Self_Env := Create_Static_Lexical_Env
        (Parent            => Parent,
         Node              => Self,
         Transitive_Parent => Transitive_Parent,
         Sym_Table         => Self.Unit.Context.Symbols);

      --  If the parent of this new environment comes from a named environment
      --  lookup, register this new environment so that its parent is updated
      --  when the precence for this named environment changes.
      if Parent_From_Name then
         declare
            NED : constant Named_Env_Descriptor_Access := State.Current_NED;
         begin
            Self.Unit.Exiled_Envs.Append ((NED, Self.Self_Env));
            NED.Foreign_Envs.Insert (Self, Self.Self_Env);
         end;
      end if;

      --  From now on, the current environment is Self.Self_Env, with a direct
      --  access to it. It does not go through the env naming scheme, since
      --  only this node and its children (i.e. non-foreign nodes) will access
      --  it as a "current" environment during PLE.
      Use_Direct_Env (State, Self.Self_Env);

      --  Register the environment we just created on all the requested names
      if Names /= null then
         declare
            Context   : constant Internal_Context := Self.Unit.Context;
            Env       : constant Lexical_Env := Self.Self_Env;
            NENU      : NED_Maps.Map renames
               State.Unit_State.Named_Envs_Needing_Update;
         begin
            for N of Names.Items loop
               Register_Named_Env (Context, N, Env, NENU);
            end loop;
            Dec_Ref (Names);
         end;
      end if;
   end Add_Env;

   ---------------------
   -- Pre_Env_Actions --
   ---------------------

   procedure Pre_Env_Actions
     (Self            : Bare_Lkt_Node;
      State           : in out PLE_Node_State;
      Add_To_Env_Only : Boolean := False) is
   begin

      
   

   case Self.Kind is
            when Lkt_Decl_Block =>
            
            Decl_Block_Pre_Env_Actions (Self, State, Add_To_Env_Only);
      
            when Lkt_Langkit_Root =>
            
            Langkit_Root_Pre_Env_Actions (Self, State, Add_To_Env_Only);
      
            when Lkt_Import =>
            
            Import_Pre_Env_Actions (Self, State, Add_To_Env_Only);
      
            when Lkt_Lambda_Expr =>
            
            Lambda_Expr_Pre_Env_Actions (Self, State, Add_To_Env_Only);
      
            when Lkt_Block_Expr =>
            
            Block_Expr_Pre_Env_Actions (Self, State, Add_To_Env_Only);
      
            when Lkt_Enum_Type_Decl =>
            
            Enum_Type_Decl_Pre_Env_Actions (Self, State, Add_To_Env_Only);
      
            when Lkt_Enum_Class_Decl =>
            
            Enum_Class_Decl_Pre_Env_Actions (Self, State, Add_To_Env_Only);
      
            when Lkt_Enum_Class_Alt_Decl =>
            
            null;
      
            when Lkt_Lexer_Decl =>
            
            Lexer_Decl_Pre_Env_Actions (Self, State, Add_To_Env_Only);
      
            when Lkt_Grammar_Decl =>
            
            Grammar_Decl_Pre_Env_Actions (Self, State, Add_To_Env_Only);
      
            when Lkt_Generic_Decl =>
            
            Generic_Decl_Pre_Env_Actions (Self, State, Add_To_Env_Only);
      
            when Lkt_Env_Spec_Decl =>
            
            Env_Spec_Decl_Pre_Env_Actions (Self, State, Add_To_Env_Only);
      
            when Lkt_Fun_Decl =>
            
            Fun_Decl_Pre_Env_Actions (Self, State, Add_To_Env_Only);
      
            when Lkt_Field_Decl =>
            
            Field_Decl_Pre_Env_Actions (Self, State, Add_To_Env_Only);
      
            when Lkt_Enum_Lit_Decl =>
            
            null;
      
            when Lkt_Grammar_Rule_Decl .. Lkt_Binding_Val_Decl | Lkt_Fun_Param_Decl .. Lkt_Val_Decl | Lkt_Error_Decl | Lkt_Lexer_Family_Decl .. Lkt_Any_Type_Decl | Lkt_Function_Type .. Lkt_Class_Decl | Lkt_Struct_Decl .. Lkt_Trait_Decl =>
            
            Decl_Pre_Env_Actions (Self, State, Add_To_Env_Only);
      
            when Lkt_Match_Branch .. Lkt_Pattern_Match_Branch =>
            
            Base_Match_Branch_Pre_Env_Actions (Self, State, Add_To_Env_Only);
      
      when others =>  null; 
   end case;


   end Pre_Env_Actions;

   ----------------------
   -- Post_Env_Actions --
   ----------------------

   procedure Post_Env_Actions
     (Self : Bare_Lkt_Node; State : in out PLE_Node_State) is
   begin
      
   

   case Self.Kind is
            when Lkt_Decl_Block =>
            
            null;
      
            when Lkt_Langkit_Root =>
            
            Langkit_Root_Post_Env_Actions (Self, State);
      
            when Lkt_Import =>
            
            null;
      
            when Lkt_Lambda_Expr =>
            
            null;
      
            when Lkt_Block_Expr =>
            
            null;
      
            when Lkt_Enum_Type_Decl =>
            
            Enum_Type_Decl_Post_Env_Actions (Self, State);
      
            when Lkt_Enum_Class_Decl =>
            
            Enum_Class_Decl_Post_Env_Actions (Self, State);
      
            when Lkt_Enum_Class_Alt_Decl =>
            
            null;
      
            when Lkt_Lexer_Decl =>
            
            null;
      
            when Lkt_Grammar_Decl =>
            
            null;
      
            when Lkt_Generic_Decl =>
            
            null;
      
            when Lkt_Env_Spec_Decl =>
            
            null;
      
            when Lkt_Fun_Decl =>
            
            null;
      
            when Lkt_Field_Decl =>
            
            null;
      
            when Lkt_Enum_Lit_Decl =>
            
            null;
      
            when Lkt_Grammar_Rule_Decl .. Lkt_Binding_Val_Decl | Lkt_Fun_Param_Decl .. Lkt_Val_Decl | Lkt_Error_Decl | Lkt_Lexer_Family_Decl .. Lkt_Any_Type_Decl | Lkt_Function_Type .. Lkt_Class_Decl | Lkt_Struct_Decl .. Lkt_Trait_Decl =>
            
            null;
      
            when Lkt_Match_Branch .. Lkt_Pattern_Match_Branch =>
            
            null;
      
      when others =>  null; 
   end case;


   end Post_Env_Actions;

   ----------------
   -- Get_Symbol --
   ----------------

   function Get_Symbol
     (Node : Bare_Lkt_Node) return Symbol_Type is
   begin
      if Node = null then
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "cannot get the symbol of a null node");
      end if;
      return Get_Symbol (Token (Node, Node.Token_Start_Index));
   end Get_Symbol;

   ----------
   -- Text --
   ----------

   function Text
     (Node : Bare_Lkt_Node) return Text_Type
   is
   begin
      if Node = null then
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "cannot get the text of a null node");
      end if;

      declare
         Start_T : constant Token_Reference :=
            Token (Node, Node.Token_Start_Index);
         End_T   : constant Token_Reference :=
            Token (Node, Node.Token_End_Index);
      begin
         --  No text is associated to synthetic and ghost nodes

         if Is_Synthetic (Node) then
            return "";
         end if;

         if Is_Ghost (Node) then
            return "";
         end if;

         return Text (Start_T, End_T);
      end;
   end Text;

   ----------
   -- Unit --
   ----------

   function Unit (Node : Bare_Lkt_Node) return Internal_Unit is
   begin
      return Node.Unit;
   end Unit;

   function Lookup_Internal
     (Node : Bare_Lkt_Node;
      Sloc : Source_Location) return Bare_Lkt_Node;
   procedure Lookup_Relative
     (Node       : Bare_Lkt_Node;
      Sloc       : Source_Location;
      Position   : out Relative_Position;
      Node_Found : out Bare_Lkt_Node);
   --  Implementation helpers for the looking up process

   -----------------
   -- Set_Parents --
   -----------------

   procedure Set_Parents
     (Node, Parent : Bare_Lkt_Node)
   is
   begin
      if Node = null then
         return;
      end if;

      Node.Parent := Bare_Lkt_Node (Parent);

      for I in 1 .. Children_Count (Node) loop
         Set_Parents (Child (Node, I), Node);
      end loop;
   end Set_Parents;

   -------------
   -- Destroy --
   -------------

   procedure Destroy (Node : Bare_Lkt_Node) is
   begin
      if Node = null then
         return;
      end if;

      Free_User_Fields (Node);
      for I in 1 .. Children_Count (Node) loop
         Destroy (Child (Node, I));
      end loop;
   end Destroy;

   -----------
   -- Child --
   -----------

   function Child (Node  : Bare_Lkt_Node;
                   Index : Positive) return Bare_Lkt_Node
   is
      Result          : Bare_Lkt_Node;
      Index_In_Bounds : Boolean;
   begin
      Get_Child (Node, Index, Index_In_Bounds, Result);
      return Result;
   end Child;

   --------------
   -- Traverse --
   --------------

   function Traverse
     (Node  : Bare_Lkt_Node;
      Visit : access function (Node : Bare_Lkt_Node)
              return Visit_Status)
     return Visit_Status
   is
      Status : Visit_Status := Into;

   begin
      if Node /= null then
         Status := Visit (Node);

         --  Skip processing the child nodes if the returned status is Over
         --  or Stop. In the former case the previous call to Visit has taken
         --  care of processing the needed childs, and in the latter case we
         --  must immediately stop processing the tree.

         if Status = Into then
            for I in 1 .. Children_Count (Node) loop
               declare
                  Cur_Child : constant Bare_Lkt_Node :=
                     Child (Node, I);

               begin
                  if Cur_Child /= null then
                     Status := Traverse (Cur_Child, Visit);
                     exit when Status /= Into;
                  end if;
               end;
            end loop;
         end if;
      end if;

      if Status = Stop then
         return Stop;

      --  At this stage the Over status has no sense and we just continue
      --  processing the tree.

      else
         return Into;
      end if;
   end Traverse;

   --------------
   -- Traverse --
   --------------

   procedure Traverse
     (Node  : Bare_Lkt_Node;
      Visit : access function (Node : Bare_Lkt_Node)
                               return Visit_Status)
   is
      Result_Status : Visit_Status;
      pragma Unreferenced (Result_Status);
   begin
      Result_Status := Traverse (Node, Visit);
   end Traverse;

   ------------------------
   -- Traverse_With_Data --
   ------------------------

   function Traverse_With_Data
     (Node  : Bare_Lkt_Node;
      Visit : access function (Node : Bare_Lkt_Node;
                               Data : in out Data_Type)
                               return Visit_Status;
      Data  : in out Data_Type)
      return Visit_Status
   is
      function Helper (Node : Bare_Lkt_Node) return Visit_Status;

      ------------
      -- Helper --
      ------------

      function Helper (Node : Bare_Lkt_Node) return Visit_Status is
      begin
         return Visit (Node, Data);
      end Helper;

      Saved_Data : Data_Type;
      Result     : Visit_Status;

   begin
      if Reset_After_Traversal then
         Saved_Data := Data;
      end if;
      Result := Traverse (Node, Helper'Access);
      if Reset_After_Traversal then
         Data := Saved_Data;
      end if;
      return Result;
   end Traverse_With_Data;

   ----------------
   -- Sloc_Range --
   ----------------

   function Sloc_Range
     (Node : Bare_Lkt_Node) return Source_Location_Range
   is
      type Token_Anchor is (T_Start, T_End);
      type Token_Pos is record
         Pos    : Token_Index;
         Anchor : Token_Anchor;
      end record;

      TDH                    : Token_Data_Handler renames Node.Unit.TDH;
      Token_Start, Token_End : Token_Pos;

      function Get (Index : Token_Index) return Stored_Token_Data is
        (Get_Token (TDH, Index));

      function Sloc (T : Token_Pos) return Source_Location is
        (if T.Anchor = T_Start
         then Sloc_Start (TDH, Get (T.Pos))
         else Sloc_End (TDH, Get (T.Pos)));

   begin
      if Is_Synthetic (Node) then
         return (if Node.Parent = null
                 then No_Source_Location_Range
                 else Sloc_Range (Node.Parent));
      end if;

      if Is_Ghost (Node) then
         Token_Start := (if Node.Token_Start_Index = 1
                         then (1, T_Start)
                         else (Node.Token_Start_Index - 1, T_End));
         Token_End := Token_Start;
      else
         Token_Start := (Node.Token_Start_Index, T_Start);
         Token_End := (Node.Token_End_Index, T_End);
      end if;

      if Snaps_At_Start (Node)
         and then not Is_Ghost (Node)
         and then Token_Start.Pos /= 1
      then
         Token_Start := (Token_Start.Pos - 1, T_End);
      end if;

      if Snaps_At_End (Node) and then Token_End.Pos /= Last_Token (TDH) then
         Token_End := (Token_End.Pos + 1, T_Start);
      end if;

      return Make_Range (Sloc (Token_Start), Sloc (Token_End));
   end Sloc_Range;

   ------------
   -- Lookup --
   ------------

   function Lookup
     (Node : Bare_Lkt_Node;
      Sloc : Source_Location) return Bare_Lkt_Node
   is
      Position : Relative_Position;
      Result   : Bare_Lkt_Node;
   begin
      if Sloc = No_Source_Location then
         return null;
      end if;

      Lookup_Relative
        (Bare_Lkt_Node (Node), Sloc, Position, Result);
      return Result;
   end Lookup;

   ---------------------
   -- Lookup_Internal --
   ---------------------

   function Lookup_Internal
     (Node : Bare_Lkt_Node;
      Sloc : Source_Location) return Bare_Lkt_Node
   is
      --  For this implementation helper (i.e. internal primitive), we can
      --  assume that all lookups fall into this node's sloc range.
      pragma Assert (Compare (Sloc_Range (Node), Sloc) = Inside);

      Children : constant Internal_Bare_Lkt_Node_Array :=
         Implementation.Children (Node);
      Pos      : Relative_Position;
      Result   : Bare_Lkt_Node;
   begin
      --  Look for a child node that contains Sloc (i.e. return the most
      --  precise result).

      for Child of Children loop
         --  Note that we assume here that child nodes are ordered so that the
         --  first one has a sloc range that is before the sloc range of the
         --  second child node, etc.

         if Child /= null then
            Lookup_Relative (Child, Sloc, Pos, Result);
            case Pos is
               when Before =>
                   --  If this is the first node, Sloc is before it, so we can
                   --  stop here.  Otherwise, Sloc is between the previous
                   --  child node and the next one...  so we can stop here,
                   --  too.
                   return Node;

               when Inside =>
                   return Result;

               when After =>
                   --  Sloc is after the current child node, so see with the
                   --  next one.
                   null;
            end case;
         end if;
      end loop;

      --  If we reach this point, we found no children that covers Sloc, but
      --  Node still covers it (see the assertion).
      return Node;
   end Lookup_Internal;

   -------------
   -- Compare --
   -------------

   function Compare
     (Node : Bare_Lkt_Node;
      Sloc : Source_Location) return Relative_Position is
   begin
      return Compare (Sloc_Range (Node), Sloc);
   end Compare;

   ---------------------
   -- Lookup_Relative --
   ---------------------

   procedure Lookup_Relative
     (Node       : Bare_Lkt_Node;
      Sloc       : Source_Location;
      Position   : out Relative_Position;
      Node_Found : out Bare_Lkt_Node)
   is
      Result : constant Relative_Position :=
        Compare (Node, Sloc);
   begin
      Position := Result;
      Node_Found := (if Result = Inside
                     then Lookup_Internal (Node, Sloc)
                     else null);
   end Lookup_Relative;

   -------------
   -- Compare --
   -------------

   function Compare
     (Self, Left, Right : Bare_Lkt_Node;
      Relation          : Comparison_Relation) return Boolean
   is
      LS, RS : Source_Location;
   begin
      if Left = null or else Right = null or else Left.Unit /= Right.Unit then
         Raise_Property_Exception
           (Self,
            Property_Error'Identity,
            "invalid node comparison");
      end if;

      LS := Start_Sloc (Sloc_Range (Left));
      RS := Start_Sloc (Sloc_Range (Right));
      return (case Relation is
              when Liblktlang_Support.Types.Less_Than        => LS < RS,
              when Liblktlang_Support.Types.Less_Or_Equal    => LS <= RS,
              when Liblktlang_Support.Types.Greater_Than     => LS > RS,
              when Liblktlang_Support.Types.Greater_Or_Equal => LS >= RS);
   end Compare;

   --------------
   -- Children --
   --------------

   function Children
     (Node : Bare_Lkt_Node) return Internal_Bare_Lkt_Node_Array
   is
      First : constant Integer := Bare_Lkt_Node_Vectors.Index_Type'First;
      Last  : constant Integer := First + Children_Count (Node) - 1;
   begin
      return A : Internal_Bare_Lkt_Node_Array (First .. Last)
      do
         for I in First .. Last loop
            A (I) := Child (Node, I);
         end loop;
      end return;
   end Children;

   function Children
     (Node : Bare_Lkt_Node) return Bare_Lkt_Node_Array_Access
   is
      C : Internal_Bare_Lkt_Node_Array := Children (Node);
   begin
      return Ret : Bare_Lkt_Node_Array_Access :=
         Create_Bare_Lkt_Node_Array (C'Length)
      do
         Ret.Items := C;
      end return;
   end Children;

   ---------
   -- Get --
   ---------

   function Get
     (Self    : Bare_Lkt_Node;
      Node    : Bare_Lkt_Node_Base_List;
      Index   : Integer;
      Or_Null : Boolean := False) return Bare_Lkt_Node
   is
      function Length (Node : Bare_Lkt_Node_Base_List) return Natural
      is (Node.Count);
      --  Wrapper around the Length primitive to get the compiler happy for the
      --  the package instantiation below.

      function Absolute_Get
        (L     : Bare_Lkt_Node_Base_List;
         Index : Integer) return Bare_Lkt_Node
      is (L.Nodes.all (Index + 1));
      --  L.Nodes is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Bare_Lkt_Node,
         Sequence_Type => Bare_Lkt_Node_Base_List,
         Length        => Length,
         Get           => Absolute_Get);

      Result : Bare_Lkt_Node;
   begin
      if Node = null and then Or_Null then
         return null;
      elsif Relative_Get (Node, Index, Result) then
         return Result;
      elsif Or_Null then
         return null;
      else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "out-of-bounds AST list access");
      end if;
   end Get;

   ---------------
   -- PP_Trivia --
   ---------------

   procedure PP_Trivia
     (Node        : Bare_Lkt_Node;
      Line_Prefix : String := "")
   is
      Children_Prefix : constant String := Line_Prefix & "|  ";
   begin
      if Node = null then
         Put_Line (Line_Prefix & "None");
         return;
      end if;
      Put_Line (Line_Prefix & Kind_Name (Node));
      for C of Children_And_Trivia (Node) loop
         case C.Kind is
            when Trivia =>
               Put_Line (Children_Prefix & Image (Text (C.Trivia)));
            when Child =>
               PP_Trivia (C.Node, Children_Prefix);
         end case;
      end loop;
   end PP_Trivia;

   --------------------------
   -- Populate_Lexical_Env --
   --------------------------

   function Populate_Lexical_Env (Node : Bare_Lkt_Node) return Boolean is

      Context    : constant Internal_Context := Node.Unit.Context;
      Unit_State : aliased PLE_Unit_State := (Named_Envs_Needing_Update => <>);
      Root_State : constant PLE_Node_State :=
        (Unit_State  => Unit_State'Unchecked_Access,
         Current_Env => Context.Root_Scope,
         Current_NED => null);

      function Populate_Internal
        (Node         : Bare_Lkt_Node;
         Parent_State : PLE_Node_State) return Boolean;
      --  Do the lexical env population on Node and recurse on its children

      procedure Register_Foreign_Env
        (Node : Bare_Lkt_Node; State : PLE_Node_State);
      --  Given a node and its PLE state, register Node.Self_Env as being
      --  initialized through the named environment mechanism, if that's indeed
      --  the case. Do nothing otherwise.

      -----------------------
      -- Populate_Internal --
      -----------------------

      function Populate_Internal
        (Node         : Bare_Lkt_Node;
         Parent_State : PLE_Node_State) return Boolean
      is
         Result : Boolean := False;
         State  : PLE_Node_State := Parent_State;
      begin
         if Node = null then
            return Result;
         end if;

         --  By default (i.e. unless env actions add a new env), the
         --  environment we store in Node is the current one.
         Node.Self_Env := State.Current_Env;

         --  Run pre/post actions, and run PLE on children in between. Make
         --  sure we register the potential foreign Node.Self_Env environment
         --  at the end, even when an exception interrupts PLE to keep the
         --  state consistent.
         begin
            Pre_Env_Actions (Node, State);
            if State.Current_Env /= Null_Lexical_Env then
               Node.Self_Env := State.Current_Env;
               Register_Foreign_Env (Node, State);
            end if;

            --  Call recursively on children
            for I in First_Child_Index (Node) .. Last_Child_Index (Node) loop
               Result := Populate_Internal
                 (Child (Node, I), State) or else Result;
            end loop;

            Post_Env_Actions (Node, State);
         exception
            when Exc : Property_Error =>
               if PLE_Errors_Trace.Is_Active then
                   GNATCOLL.Traces.Trace
                     (PLE_Errors_Trace,
                      "Exception raised during PLE "
                      & Ada.Exceptions.Exception_Name (Exc) & " : "
                      & Ada.Exceptions.Exception_Message (Exc));
                   GNATCOLL.Traces.Trace
                     (PLE_Errors_Trace,
                      GNAT.Traceback.Symbolic.Symbolic_Traceback (Exc));
               end if;
               Register_Foreign_Env (Node, State);
               return True;
         end;

         return Result;
      end Populate_Internal;

      --------------------------
      -- Register_Foreign_Env --
      --------------------------

      procedure Register_Foreign_Env
        (Node : Bare_Lkt_Node; State : PLE_Node_State) is
      begin
         if State.Current_NED /= null then
            State.Current_NED.Nodes_With_Foreign_Env.Insert (Node);
            Node.Unit.Nodes_With_Foreign_Env.Insert (Node, State.Current_NED);
         end if;
      end Register_Foreign_Env;

   begin
      --  This is intended to be called on the root node only (when there is no
      --  PLE root) or on a PLE root (child of the root node with a specific
      --  kind).
      if
         Node.Parent /= null
      then
         raise Program_Error;
      end if;

      return Result : constant Boolean :=
         Populate_Internal (Node, Root_State)
      do
         Update_Named_Envs (Context, Unit_State.Named_Envs_Needing_Update);
      end return;
   end Populate_Lexical_Env;

   ------------------------------
   -- AST_Envs_Node_Text_Image --
   ------------------------------

   function AST_Envs_Node_Text_Image
     (Node  : Bare_Lkt_Node;
      Short : Boolean := True) return Text_Type is
   begin
      if Short then
         if Node = null then
            return "null";
         end if;
         return To_Text (Basename (Node.Unit))
           & ":" & To_Text (Image (Start_Sloc (Sloc_Range (Node))));
      else
         return Short_Text_Image (Node);
      end if;
   end AST_Envs_Node_Text_Image;

   -------------------
   -- Is_Rebindable --
   -------------------

   function Is_Rebindable (Node : Bare_Lkt_Node) return Boolean is
   begin
      
         return Node.Kind in Lkt_Generic_Decl;
   end Is_Rebindable;

   -----------------------
   -- Acquire_Rebinding --
   -----------------------

   function Acquire_Rebinding
     (Node             : Bare_Lkt_Node;
      Parent           : Env_Rebindings;
      Old_Env, New_Env : Lexical_Env) return Env_Rebindings
   is
      Result    : Env_Rebindings;
      Available : Env_Rebindings_Vectors.Vector renames
         Node.Unit.Context.Available_Rebindings;
   begin
      --  Use an existing and available Env_Rebindings_Type record for Node's
      --  Context, otherwise allocate a new rebinding.
      Result := (if Available.Is_Empty
                 then new Env_Rebindings_Type'(Version => 0, others => <>)
                 else Available.Pop);

      Result.Parent := Parent;
      Result.Old_Env := Old_Env;
      Result.New_Env := New_Env;
      Result.Children := Env_Rebindings_Vectors.Empty_Vector;
      return Result;
   end Acquire_Rebinding;

   -----------------------
   -- Release_Rebinding --
   -----------------------

   procedure Release_Rebinding (Self : in out Env_Rebindings) is
      Available : Env_Rebindings_Vectors.Vector renames
         Unwrap (Self.Old_Env).Node.Unit.Context.Available_Rebindings;
   begin
      --  Bumping the version number, to invalidate existing references to
      --  Self.
      Self.Version := Self.Version + 1;

      Self.Children.Destroy;
      Available.Append (Self);
      Self := null;
   end Release_Rebinding;

   ------------------------
   -- Register_Rebinding --
   ------------------------

   procedure Register_Rebinding
     (Node : Bare_Lkt_Node; Rebinding : Env_Rebindings) is
   begin
      Node.Unit.Rebindings.Append (Rebinding);
   end Register_Rebinding;


   --------------------
   -- Element_Parent --
   --------------------

   function Element_Parent
     (Node : Bare_Lkt_Node) return Bare_Lkt_Node
   is (Node.Parent);

   ---------------
   -- Node_Unit --
   ---------------

   function Node_Unit (Node : Bare_Lkt_Node) return Generic_Unit_Ptr is
   begin
      return Convert_Unit (Node.Unit);
   end Node_Unit;

   ----------
   -- Hash --
   ----------

   function Hash (Node : Bare_Lkt_Node) return Hash_Type
   is
      function H is new Hash_Access
        (Root_Node_Record, Bare_Lkt_Node);
   begin
      return H (Node);
   end Hash;

      function Hash (B : Boolean) return Hash_Type is (Boolean'Pos (B));





   ------------------------
   -- Named environments --
   ------------------------

   ---------
   -- Add --
   ---------

   procedure Add
     (Self : in out NED_Assoc_Maps.Map;
      Key  : Symbol_Type;
      Node : AST_Envs.Internal_Map_Node)
   is
      use NED_Assoc_Maps;

      Pos   : Cursor;
      Dummy : Boolean;
   begin
      --  Make sure there is a vector entry for Key
      Self.Insert (Key, Internal_Map_Node_Vectors.Empty_Vector, Pos, Dummy);

      --  Append Node to that vector
      declare
         V : Internal_Map_Node_Vectors.Vector renames Self.Reference (Pos);
      begin
         V.Append (Node);
      end;
   end Add;

   ------------
   -- Remove --
   ------------

   procedure Remove
     (Self : in out NED_Assoc_Maps.Map;
      Key  : Symbol_Type;
      Node : Bare_Lkt_Node)
   is
      use NED_Assoc_Maps;

      V : Internal_Map_Node_Vectors.Vector renames Self.Reference (Key);
   begin
      --  Remove the (assumed unique) entry in V whose node is Node. The order
      --  of items in V is not significant, so we can use Pop for efficient
      --  removal. Do the traversal in reverse order for correctness.
      for I in reverse 1 .. V.Length loop
         if V.Get_Access (I).Node = Node then
            V.Pop (I);
            exit;
         end if;
      end loop;
   end Remove;

   ------------------------------
   -- Get_Named_Env_Descriptor --
   ------------------------------

   function Get_Named_Env_Descriptor
     (Context : Internal_Context;
      Name    : Symbol_Type) return Named_Env_Descriptor_Access
   is
      use NED_Maps;

      --  Look for an existing entry for Name
      Pos : constant Cursor := Context.Named_Envs.Find (Name);
   begin
      if Has_Element (Pos) then
         return Element (Pos);
      end if;

      --  There is no such entry: create one
      return Result : constant Named_Env_Descriptor_Access :=
         new Named_Env_Descriptor'
           (Name                   => Name,
            Envs                   => <>,
            Env_With_Precedence    => Empty_Env,
            Foreign_Nodes          => <>,
            Foreign_Envs           => <>,
            Nodes_With_Foreign_Env => <>)
      do
         Context.Named_Envs.Insert (Name, Result);
      end return;
   end Get_Named_Env_Descriptor;

   ------------------------
   -- Register_Named_Env --
   ------------------------

   procedure Register_Named_Env
     (Context                   : Internal_Context;
      Name                      : Symbol_Type;
      Env                       : Lexical_Env;
      Named_Envs_Needing_Update : in out NED_Maps.Map)
   is
      NED_Access : constant Named_Env_Descriptor_Access :=
         Get_Named_Env_Descriptor (Context, Name);
      NED        : Named_Env_Descriptor renames NED_Access.all;
      Node       : constant Bare_Lkt_Node := Env_Node (Env);
   begin
      NED.Envs.Insert (Node, Env);
      Node.Unit.Named_Envs.Append ((Name, Env));

      --  If that insertion must change the env that has precedence, signal
      --  that NED requires an update.

      if NED.Envs.First_Element /= NED.Env_With_Precedence then
         Named_Envs_Needing_Update.Include (Name, NED_Access);
      end if;
   end Register_Named_Env;

   ----------------------
   -- Update_Named_Env --
   ----------------------

   procedure Update_Named_Envs
     (Context : Internal_Context; Named_Envs : NED_Maps.Map)
   is
      Require_Cache_Reset : Boolean := False;
   begin
      for Cur in Named_Envs.Iterate loop
         declare
            NE      : Named_Env_Descriptor renames NED_Maps.Element (Cur).all;
            New_Env : constant Lexical_Env :=
              (if NE.Envs.Is_Empty
               then Empty_Env
               else NE.Envs.First_Element);
         begin
            --  If there was an environment with precedence, remove its foreign
            --  nodes.
            if NE.Env_With_Precedence /= Empty_Env then
               for Cur in NE.Foreign_Nodes.Iterate loop
                  declare
                     Key   : constant Symbol_Type :=
                        NED_Assoc_Maps.Key (Cur);
                     Nodes : Internal_Map_Node_Vectors.Vector renames
                        NE.Foreign_Nodes.Reference (Cur);
                  begin
                     for N of Nodes loop
                        Remove (NE.Env_With_Precedence, Thin (Key), N.Node);
                     end loop;
                  end;
               end loop;
            end if;

            --  Now, set the new environment that has precedence
            NE.Env_With_Precedence := New_Env;

            --  Add the foreign nodes to the new environment with precedence,
            --  if any.
            for Cur in NE.Foreign_Nodes.Iterate loop
               declare
                  Key   : constant Symbol_Type :=
                     NED_Assoc_Maps.Key (Cur);
                  Nodes : Internal_Map_Node_Vectors.Vector renames
                     NE.Foreign_Nodes.Reference (Cur);
               begin
                  for N of Nodes loop
                     Add (New_Env, Thin (Key), N.Node, N.Md, N.Resolver);
                  end loop;
               end;
            end loop;

            --  Set the parent environment of all foreign environments
            for Cur in NE.Foreign_Envs.Iterate loop
               declare
                  Env : Lexical_Env_Record renames
                     Unwrap (Sorted_Env_Maps.Element (Cur)).all;
               begin
                  Env.Parent := New_Env;

                  --  We have updated the lexical env hierarchy (e.g. an env
                  --  which had no parent may have one now), so the cached
                  --  entries for queries that traveresed the old env hierarchy
                  --  need to be invalidated.
                  Require_Cache_Reset := True;
               end;
            end loop;

            --  Update nodes whose environment was the old env with precedence
            for N of NE.Nodes_With_Foreign_Env loop
               N.Self_Env := New_Env;
            end loop;
         end;
      end loop;
      if Require_Cache_Reset then
         Invalidate_Caches (Context, Invalidate_Envs => True);
      end if;
   end Update_Named_Envs;

   --------------------------
   -- Big integers wrapper --
   --------------------------

   ------------------------
   -- Create_Big_Integer --
   ------------------------

   function Create_Big_Integer
     (Image : String; Base : Integer := 10) return Big_Integer_Type
   is
      use GNATCOLL.GMP;
      use GNATCOLL.GMP.Integers;
   begin
      return new Big_Integer_Record'(Value     => Make (Image, Int (Base)),
                                     Ref_Count => 1);
   end Create_Big_Integer;

   ------------------------
   -- Create_Big_Integer --
   ------------------------

   function Create_Big_Integer
     (Big_Int : GNATCOLL.GMP.Integers.Big_Integer) return Big_Integer_Type
   is
      Result : constant Big_Integer_Type :=
         new Big_Integer_Record'(Value     => <>,
                                 Ref_Count => 1);
   begin
      Result.Value.Set (Big_Int);
      return Result;
   end Create_Big_Integer;

   ------------------------
   -- Create_Big_Integer --
   ------------------------

   function Create_Big_Integer (Int : Integer) return Big_Integer_Type is
      Result : constant Big_Integer_Type :=
         new Big_Integer_Record'(Value     => <>,
                                 Ref_Count => 1);
   begin
      Result.Value.Set (GNATCOLL.GMP.Long (Int));
      return Result;
   end Create_Big_Integer;

   -------------------------------
   -- Create_Public_Big_Integer --
   -------------------------------

   function Create_Public_Big_Integer
     (Big_Int : Big_Integer_Type) return GNATCOLL.GMP.Integers.Big_Integer is
   begin
      return Result : GNATCOLL.GMP.Integers.Big_Integer do
         Result.Set (Big_Int.Value);
      end return;
   end Create_Public_Big_Integer;

   -----------------
   -- Trace_Image --
   -----------------

   function Trace_Image (I : Big_Integer_Type) return String is
   begin
      return GNATCOLL.GMP.Integers.Image (I.Value);
   end Trace_Image;

   ----------------
   -- To_Integer --
   ----------------

   function To_Integer
     (Self    : Bare_Lkt_Node;
      Big_Int : Big_Integer_Type) return Integer
   is
      Image : constant String := Big_Int.Value.Image;
   begin
      return Integer'Value (Image);
   exception
      when Constraint_Error =>
         Raise_Property_Exception
           (Self, Property_Error'Identity, "out of range big integer");
   end To_Integer;

   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (Big_Int : Big_Integer_Type) is
   begin
      if Big_Int.Ref_Count /= -1 then
         Big_Int.Ref_Count := Big_Int.Ref_Count + 1;
      end if;
   end Inc_Ref;

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (Big_Int : in out Big_Integer_Type) is
      procedure Destroy is new Ada.Unchecked_Deallocation
        (Big_Integer_Record, Big_Integer_Type);
   begin
      if Big_Int = null or else Big_Int.Ref_Count = -1 then
         return;
      end if;

      Big_Int.Ref_Count := Big_Int.Ref_Count - 1;
      if Big_Int.Ref_Count = 0 then
         Destroy (Big_Int);
      else
         Big_Int := null;
      end if;
   end Dec_Ref;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (Left, Right : Big_Integer_Type) return Boolean is
      use type GNATCOLL.GMP.Integers.Big_Integer;
   begin
      return Left.Value = Right.Value;
   end Equivalent;

   ---------
   -- "<" --
   ---------

   function "<" (Left, Right : Big_Integer_Type) return Boolean is
      use type GNATCOLL.GMP.Integers.Big_Integer;
   begin
      return Left.Value < Right.Value;
   end "<";

   ----------
   -- "<=" --
   ----------

   function "<=" (Left, Right : Big_Integer_Type) return Boolean is
      use type GNATCOLL.GMP.Integers.Big_Integer;
   begin
      return Left.Value <= Right.Value;
   end "<=";

   ---------
   -- ">" --
   ---------

   function ">" (Left, Right : Big_Integer_Type) return Boolean is
      use type GNATCOLL.GMP.Integers.Big_Integer;
   begin
      return Left.Value > Right.Value;
   end ">";

   ----------
   -- ">=" --
   ----------

   function ">=" (Left, Right : Big_Integer_Type) return Boolean is
      use type GNATCOLL.GMP.Integers.Big_Integer;
   begin
      return Left.Value >= Right.Value;
   end ">=";

   ---------
   -- "+" --
   ---------

   function "+" (Left, Right : Big_Integer_Type) return Big_Integer_Type is
      use type GNATCOLL.GMP.Integers.Big_Integer;
   begin
      return Create_Big_Integer (Left.Value + Right.Value);
   end "+";

   ---------
   -- "-" --
   ---------

   function "-" (Left, Right : Big_Integer_Type) return Big_Integer_Type is
      use type GNATCOLL.GMP.Integers.Big_Integer;
   begin
      return Create_Big_Integer (Left.Value - Right.Value);
   end "-";

   ---------
   -- "-" --
   ---------

   function "-" (Value : Big_Integer_Type) return Big_Integer_Type is
      use type GNATCOLL.GMP.Integers.Big_Integer;
   begin
      return Create_Big_Integer (-Value.Value);
   end "-";

   ------------------
   -- Unit_Version --
   ------------------

   function Unit_Version (Unit : Generic_Unit_Ptr) return Version_Number is
   begin
      return Convert_Unit (Unit).Unit_Version;
   end Unit_Version;

   -------------------------
   -- Get_Context_Version --
   -------------------------

   function Get_Context_Version
     (Node : Bare_Lkt_Node) return Version_Number is
   begin
      return Node.Unit.Context.Cache_Version;
   end Get_Context_Version;

   ---------------
   --  Self_Env --
   ---------------

   function Self_Env (Node : Bare_Lkt_Node) return Lexical_Env is
   begin
      return Node.Self_Env;
   end Self_Env;

   --------------------------
   -- Properties_May_Raise --
   --------------------------

   function Properties_May_Raise
     (Exc : Ada.Exceptions.Exception_Occurrence) return Boolean is
   begin
      return Ada.Exceptions.Exception_Identity (Exc) in
            Property_Error'Identity
      ;
   end Properties_May_Raise;

   ----------------------
   -- Short_Text_Image --
   ----------------------

   function Short_Text_Image (Self : Bare_Lkt_Node) return Text_Type
   is
   begin
      if Self = null then
         return "None";
      end if;

      
   

   case Self.Kind is
            when Lkt_Id .. Lkt_Ref_Id =>
            
         return Id_Short_Image (Self);
      
            when Lkt_Grammar_Rule_Decl .. Lkt_Trait_Decl =>
            
         return Decl_Short_Image (Self);
      
      when others => 
         return "<" & To_Text (Kind_Name (Self))
                & " " & Node_Sloc_Image (Self) & ">";
      
   end case;

   end Short_Text_Image;

   ----------------------
   --- Node_Sloc_Image --
   ----------------------

   function Node_Sloc_Image (Self : Bare_Lkt_Node) return Text_Type
   is
      
   begin
         return To_Text
                  (Ada.Directories.Simple_Name (Get_Filename (Unit (Self))))
                & ":" & To_Text (Image (Sloc_Range (Self)));
   end Node_Sloc_Image;

   --------------------
   -- Snaps_At_Start --
   --------------------

   function Snaps_At_Start (Self : Bare_Lkt_Node) return Boolean is
   begin
      
   

   case Self.Kind is
      when others => 
         return False;
      
   end case;

   end Snaps_At_Start;

   ------------------
   -- Snaps_At_End --
   ------------------

   function Snaps_At_End (Self : Bare_Lkt_Node) return Boolean is
   begin
      
   

   case Self.Kind is
      when others => 
         return Is_Incomplete (Self);
      
   end case;

   end Snaps_At_End;

   -------------
   -- Parents --
   -------------

   function Parents
     (Node      : Bare_Lkt_Node;
      With_Self : Boolean := True)
      return Bare_Lkt_Node_Array_Access
   is
      Count : Natural := 0;
      Start : Bare_Lkt_Node :=
        (if With_Self then Node else Node.Parent);
      Cur   : Bare_Lkt_Node := Start;
   begin
      while Cur /= null loop
         Count := Count + 1;
         Cur := Cur.Parent;
      end loop;

      declare
         Result : constant Bare_Lkt_Node_Array_Access :=
            Create_Bare_Lkt_Node_Array (Count);
      begin
         Cur := Start;
         for I in Result.Items'Range loop
            Result.Items (I) := Cur;
            Cur := Cur.Parent;
         end loop;
         return Result;
      end;
   end Parents;

   -----------------------
   -- First_Child_Index --
   -----------------------

   function First_Child_Index (Node : Bare_Lkt_Node) return Natural
   is (1);

   ----------------------
   -- Last_Child_Index --
   ----------------------

   function Last_Child_Index (Node : Bare_Lkt_Node) return Natural
   is (Children_Count (Node));

   ---------------
   -- Get_Child --
   ---------------

   procedure Get_Child
     (Node            : Bare_Lkt_Node;
      Index           : Positive;
      Index_In_Bounds : out Boolean;
      Result          : out Bare_Lkt_Node)
   is
      K : constant Lkt_Node_Kind_Type := Node.Kind;
   begin
      

      Index_In_Bounds := True;
      Result := null;
      case Lkt_Lkt_Node (K) is
when Lkt_Argument_Range =>
declare
N_Bare_Argument : constant Bare_Argument := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Argument.Argument_F_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Argument.Argument_F_Value;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Lexer_Case_Rule_Cond_Alt_Range =>
declare
N_Bare_Lexer_Case_Rule_Cond_Alt : constant Bare_Lexer_Case_Rule_Cond_Alt := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Lexer_Case_Rule_Cond_Alt.Lexer_Case_Rule_Cond_Alt_F_Cond_Exprs;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Lexer_Case_Rule_Cond_Alt.Lexer_Case_Rule_Cond_Alt_F_Send;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Lexer_Case_Rule_Default_Alt_Range =>
declare
N_Bare_Lexer_Case_Rule_Default_Alt : constant Bare_Lexer_Case_Rule_Default_Alt := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Lexer_Case_Rule_Default_Alt.Lexer_Case_Rule_Default_Alt_F_Send;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Match_Branch_Range =>
declare
N_Bare_Match_Branch : constant Bare_Match_Branch := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Match_Branch.Match_Branch_F_Decl;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Match_Branch.Match_Branch_F_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Pattern_Match_Branch_Range =>
declare
N_Bare_Pattern_Match_Branch : constant Bare_Pattern_Match_Branch := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Pattern_Match_Branch.Pattern_Match_Branch_F_Pattern;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Pattern_Match_Branch.Pattern_Match_Branch_F_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Block_Expr_Clause_Range =>
declare
N_Bare_Block_Expr_Clause : constant Bare_Block_Expr_Clause := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Block_Expr_Clause.Block_Expr_Clause_F_Clause;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Grammar_Rule_Decl_Range =>
declare
N_Bare_Grammar_Rule_Decl : constant Bare_Grammar_Rule_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Grammar_Rule_Decl.Grammar_Rule_Decl_F_Syn_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Grammar_Rule_Decl.Grammar_Rule_Decl_F_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Binding_Val_Decl_Range =>
declare
N_Bare_Binding_Val_Decl : constant Bare_Binding_Val_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Binding_Val_Decl.Binding_Val_Decl_F_Syn_Name;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Enum_Lit_Decl_Range =>
declare
N_Bare_Enum_Lit_Decl : constant Bare_Enum_Lit_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Enum_Lit_Decl.Enum_Lit_Decl_F_Syn_Name;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Field_Decl_Range =>
declare
N_Bare_Field_Decl : constant Bare_Field_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Field_Decl.Field_Decl_F_Syn_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Field_Decl.Field_Decl_F_Decl_Type;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Field_Decl.Field_Decl_F_Trait_Ref;
                            return;
                    

                        when 4 =>
                            Result := N_Bare_Field_Decl.Field_Decl_F_Default_Val;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Fun_Param_Decl_Range =>
declare
N_Bare_Fun_Param_Decl : constant Bare_Fun_Param_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Fun_Param_Decl.Fun_Param_Decl_F_Decl_Annotations;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Fun_Param_Decl.Fun_Param_Decl_F_Syn_Name;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Fun_Param_Decl.Fun_Param_Decl_F_Decl_Type;
                            return;
                    

                        when 4 =>
                            Result := N_Bare_Fun_Param_Decl.Fun_Param_Decl_F_Default_Val;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Lambda_Param_Decl_Range =>
declare
N_Bare_Lambda_Param_Decl : constant Bare_Lambda_Param_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Lambda_Param_Decl.Lambda_Param_Decl_F_Syn_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Lambda_Param_Decl.Lambda_Param_Decl_F_Decl_Type;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Lambda_Param_Decl.Lambda_Param_Decl_F_Default_Val;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Dyn_Var_Decl_Range =>
declare
N_Bare_Dyn_Var_Decl : constant Bare_Dyn_Var_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Dyn_Var_Decl.Dyn_Var_Decl_F_Syn_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Dyn_Var_Decl.Dyn_Var_Decl_F_Decl_Type;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Match_Val_Decl_Range =>
declare
N_Bare_Match_Val_Decl : constant Bare_Match_Val_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Match_Val_Decl.Match_Val_Decl_F_Syn_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Match_Val_Decl.Match_Val_Decl_F_Decl_Type;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Val_Decl_Range =>
declare
N_Bare_Val_Decl : constant Bare_Val_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Val_Decl.Val_Decl_F_Syn_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Val_Decl.Val_Decl_F_Decl_Type;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Val_Decl.Val_Decl_F_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Fun_Decl_Range =>
declare
N_Bare_Fun_Decl : constant Bare_Fun_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Fun_Decl.Fun_Decl_F_Syn_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Fun_Decl.Fun_Decl_F_Params;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Fun_Decl.Fun_Decl_F_Return_Type;
                            return;
                    

                        when 4 =>
                            Result := N_Bare_Fun_Decl.Fun_Decl_F_Trait_Ref;
                            return;
                    

                        when 5 =>
                            Result := N_Bare_Fun_Decl.Fun_Decl_F_Body;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Env_Spec_Decl_Range =>
declare
N_Bare_Env_Spec_Decl : constant Bare_Env_Spec_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Env_Spec_Decl.Env_Spec_Decl_F_Syn_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Env_Spec_Decl.Env_Spec_Decl_F_Actions;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Generic_Decl_Range =>
declare
N_Bare_Generic_Decl : constant Bare_Generic_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Generic_Decl.Generic_Decl_F_Generic_Param_Decls;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Generic_Decl.Generic_Decl_F_Decl;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Grammar_Decl_Range =>
declare
N_Bare_Grammar_Decl : constant Bare_Grammar_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Grammar_Decl.Grammar_Decl_F_Syn_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Grammar_Decl.Grammar_Decl_F_Rules;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Lexer_Decl_Range =>
declare
N_Bare_Lexer_Decl : constant Bare_Lexer_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Lexer_Decl.Lexer_Decl_F_Syn_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Lexer_Decl.Lexer_Decl_F_Rules;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Lexer_Family_Decl_Range =>
declare
N_Bare_Lexer_Family_Decl : constant Bare_Lexer_Family_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Lexer_Family_Decl.Lexer_Family_Decl_F_Syn_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Lexer_Family_Decl.Lexer_Family_Decl_F_Rules;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Any_Type_Decl_Range =>
declare
N_Bare_Any_Type_Decl : constant Bare_Any_Type_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Any_Type_Decl.Any_Type_Decl_F_Traits;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Enum_Class_Alt_Decl_Range =>
declare
N_Bare_Enum_Class_Alt_Decl : constant Bare_Enum_Class_Alt_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Enum_Class_Alt_Decl.Enum_Class_Alt_Decl_F_Syn_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Enum_Class_Alt_Decl.Enum_Class_Alt_Decl_F_Traits;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Function_Type_Range =>
declare
N_Bare_Function_Type : constant Bare_Function_Type := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Function_Type.Function_Type_F_Traits;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Generic_Param_Type_Decl_Range =>
declare
N_Bare_Generic_Param_Type_Decl : constant Bare_Generic_Param_Type_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Generic_Param_Type_Decl.Generic_Param_Type_Decl_F_Has_Class;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Generic_Param_Type_Decl.Generic_Param_Type_Decl_F_Syn_Name;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Generic_Param_Type_Decl.Generic_Param_Type_Decl_F_Traits;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Basic_Class_Decl =>
declare
N_Bare_Basic_Class_Decl : constant Bare_Basic_Class_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Basic_Class_Decl.Basic_Class_Decl_F_Syn_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Basic_Class_Decl.Basic_Class_Decl_F_Syn_Base_Type;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Basic_Class_Decl.Basic_Class_Decl_F_Traits;
                            return;
                    

                        when others => null;
                    end case;
                
case Lkt_Basic_Class_Decl (K) is
when Lkt_Class_Decl_Range =>
declare
N_Bare_Class_Decl : constant Bare_Class_Decl := N_Bare_Basic_Class_Decl;
begin
case Index is

                        when 4 =>
                            Result := N_Bare_Class_Decl.Class_Decl_F_Decls;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Enum_Class_Decl_Range =>
declare
N_Bare_Enum_Class_Decl : constant Bare_Enum_Class_Decl := N_Bare_Basic_Class_Decl;
begin
case Index is

                        when 4 =>
                            Result := N_Bare_Enum_Class_Decl.Enum_Class_Decl_F_Branches;
                            return;
                    

                        when 5 =>
                            Result := N_Bare_Enum_Class_Decl.Enum_Class_Decl_F_Decls;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when others => null;
end case;
end;
when Lkt_Enum_Type_Decl_Range =>
declare
N_Bare_Enum_Type_Decl : constant Bare_Enum_Type_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Enum_Type_Decl.Enum_Type_Decl_F_Syn_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Enum_Type_Decl.Enum_Type_Decl_F_Traits;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Enum_Type_Decl.Enum_Type_Decl_F_Literals;
                            return;
                    

                        when 4 =>
                            Result := N_Bare_Enum_Type_Decl.Enum_Type_Decl_F_Decls;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Struct_Decl_Range =>
declare
N_Bare_Struct_Decl : constant Bare_Struct_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Struct_Decl.Struct_Decl_F_Syn_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Struct_Decl.Struct_Decl_F_Traits;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Struct_Decl.Struct_Decl_F_Decls;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Trait_Decl_Range =>
declare
N_Bare_Trait_Decl : constant Bare_Trait_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Trait_Decl.Trait_Decl_F_Syn_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Trait_Decl.Trait_Decl_F_Traits;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Trait_Decl.Trait_Decl_F_Decls;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Decl_Annotation_Range =>
declare
N_Bare_Decl_Annotation : constant Bare_Decl_Annotation := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Decl_Annotation.Decl_Annotation_F_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Decl_Annotation.Decl_Annotation_F_Args;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Decl_Annotation_Args_Range =>
declare
N_Bare_Decl_Annotation_Args : constant Bare_Decl_Annotation_Args := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Decl_Annotation_Args.Decl_Annotation_Args_F_Args;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Elsif_Branch_Range =>
declare
N_Bare_Elsif_Branch : constant Bare_Elsif_Branch := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Elsif_Branch.Elsif_Branch_F_Cond_Expr;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Elsif_Branch.Elsif_Branch_F_Then_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Enum_Class_Case_Range =>
declare
N_Bare_Enum_Class_Case : constant Bare_Enum_Class_Case := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Enum_Class_Case.Enum_Class_Case_F_Decls;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Any_Of_Range =>
declare
N_Bare_Any_Of : constant Bare_Any_Of := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Any_Of.Any_Of_F_Expr;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Any_Of.Any_Of_F_Values;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Array_Literal_Range =>
declare
N_Bare_Array_Literal : constant Bare_Array_Literal := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Array_Literal.Array_Literal_F_Exprs;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Array_Literal.Array_Literal_F_Element_Type;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Base_Call_Expr =>
declare
N_Bare_Base_Call_Expr : constant Bare_Base_Call_Expr := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Base_Call_Expr.Base_Call_Expr_F_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Base_Call_Expr.Base_Call_Expr_F_Args;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Bin_Op_Range =>
declare
N_Bare_Bin_Op : constant Bare_Bin_Op := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Bin_Op.Bin_Op_F_Left;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Bin_Op.Bin_Op_F_Op;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Bin_Op.Bin_Op_F_Right;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Block_Expr_Range =>
declare
N_Bare_Block_Expr : constant Bare_Block_Expr := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Block_Expr.Block_Expr_F_Clauses;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Cast_Expr_Range =>
declare
N_Bare_Cast_Expr : constant Bare_Cast_Expr := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Cast_Expr.Cast_Expr_F_Expr;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Cast_Expr.Cast_Expr_F_Null_Cond;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Cast_Expr.Cast_Expr_F_Excludes_Null;
                            return;
                    

                        when 4 =>
                            Result := N_Bare_Cast_Expr.Cast_Expr_F_Dest_Type;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Dot_Expr_Range =>
declare
N_Bare_Dot_Expr : constant Bare_Dot_Expr := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Dot_Expr.Dot_Expr_F_Prefix;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Dot_Expr.Dot_Expr_F_Null_Cond;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Dot_Expr.Dot_Expr_F_Suffix;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Error_On_Null_Range =>
declare
N_Bare_Error_On_Null : constant Bare_Error_On_Null := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Error_On_Null.Error_On_Null_F_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Generic_Instantiation_Range =>
declare
N_Bare_Generic_Instantiation : constant Bare_Generic_Instantiation := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Generic_Instantiation.Generic_Instantiation_F_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Generic_Instantiation.Generic_Instantiation_F_Args;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Grammar_Discard_Range =>
declare
N_Bare_Grammar_Discard : constant Bare_Grammar_Discard := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Grammar_Discard.Grammar_Discard_F_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Grammar_Dont_Skip_Range =>
declare
N_Bare_Grammar_Dont_Skip : constant Bare_Grammar_Dont_Skip := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Grammar_Dont_Skip.Grammar_Dont_Skip_F_Expr;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Grammar_Dont_Skip.Grammar_Dont_Skip_F_Dont_Skip;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Grammar_List_Range =>
declare
N_Bare_Grammar_List : constant Bare_Grammar_List := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Grammar_List.Grammar_List_F_List_Type;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Grammar_List.Grammar_List_F_Kind;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Grammar_List.Grammar_List_F_Expr;
                            return;
                    

                        when 4 =>
                            Result := N_Bare_Grammar_List.Grammar_List_F_Sep;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Grammar_Null_Range =>
declare
N_Bare_Grammar_Null : constant Bare_Grammar_Null := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Grammar_Null.Grammar_Null_F_Name;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Grammar_Opt_Range =>
declare
N_Bare_Grammar_Opt : constant Bare_Grammar_Opt := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Grammar_Opt.Grammar_Opt_F_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Grammar_Opt_Error_Range =>
declare
N_Bare_Grammar_Opt_Error : constant Bare_Grammar_Opt_Error := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Grammar_Opt_Error.Grammar_Opt_Error_F_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Grammar_Opt_Error_Group_Range =>
declare
N_Bare_Grammar_Opt_Error_Group : constant Bare_Grammar_Opt_Error_Group := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Grammar_Opt_Error_Group.Grammar_Opt_Error_Group_F_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Grammar_Opt_Group_Range =>
declare
N_Bare_Grammar_Opt_Group : constant Bare_Grammar_Opt_Group := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Grammar_Opt_Group.Grammar_Opt_Group_F_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Grammar_Or_Expr_Range =>
declare
N_Bare_Grammar_Or_Expr : constant Bare_Grammar_Or_Expr := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Grammar_Or_Expr.Grammar_Or_Expr_F_Sub_Exprs;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Grammar_Pick_Range =>
declare
N_Bare_Grammar_Pick : constant Bare_Grammar_Pick := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Grammar_Pick.Grammar_Pick_F_Exprs;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Grammar_Predicate_Range =>
declare
N_Bare_Grammar_Predicate : constant Bare_Grammar_Predicate := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Grammar_Predicate.Grammar_Predicate_F_Expr;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Grammar_Predicate.Grammar_Predicate_F_Prop_Ref;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Grammar_Rule_Ref_Range =>
declare
N_Bare_Grammar_Rule_Ref : constant Bare_Grammar_Rule_Ref := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Grammar_Rule_Ref.Grammar_Rule_Ref_F_Node_Name;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Grammar_Skip_Range =>
declare
N_Bare_Grammar_Skip : constant Bare_Grammar_Skip := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Grammar_Skip.Grammar_Skip_F_Name;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Grammar_Stop_Cut_Range =>
declare
N_Bare_Grammar_Stop_Cut : constant Bare_Grammar_Stop_Cut := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Grammar_Stop_Cut.Grammar_Stop_Cut_F_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Parse_Node_Expr_Range =>
declare
N_Bare_Parse_Node_Expr : constant Bare_Parse_Node_Expr := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Parse_Node_Expr.Parse_Node_Expr_F_Node_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Parse_Node_Expr.Parse_Node_Expr_F_Sub_Exprs;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Token_No_Case_Lit_Range =>
declare
N_Bare_Token_No_Case_Lit : constant Bare_Token_No_Case_Lit := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Token_No_Case_Lit.Token_No_Case_Lit_F_Lit;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Token_Pattern_Concat_Range =>
declare
N_Bare_Token_Pattern_Concat : constant Bare_Token_Pattern_Concat := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Token_Pattern_Concat.Token_Pattern_Concat_F_Left;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Token_Pattern_Concat.Token_Pattern_Concat_F_Right;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Token_Ref_Range =>
declare
N_Bare_Token_Ref : constant Bare_Token_Ref := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Token_Ref.Token_Ref_F_Token_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Token_Ref.Token_Ref_F_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_If_Expr_Range =>
declare
N_Bare_If_Expr : constant Bare_If_Expr := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_If_Expr.If_Expr_F_Cond_Expr;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_If_Expr.If_Expr_F_Then_Expr;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_If_Expr.If_Expr_F_Alternatives;
                            return;
                    

                        when 4 =>
                            Result := N_Bare_If_Expr.If_Expr_F_Else_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Isa_Range =>
declare
N_Bare_Isa : constant Bare_Isa := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Isa.Isa_F_Expr;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Isa.Isa_F_Pattern;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Keep_Expr_Range =>
declare
N_Bare_Keep_Expr : constant Bare_Keep_Expr := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Keep_Expr.Keep_Expr_F_Expr;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Keep_Expr.Keep_Expr_F_Null_Cond;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Keep_Expr.Keep_Expr_F_Keep_Type;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Lambda_Expr_Range =>
declare
N_Bare_Lambda_Expr : constant Bare_Lambda_Expr := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Lambda_Expr.Lambda_Expr_F_Params;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Lambda_Expr.Lambda_Expr_F_Return_Type;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Lambda_Expr.Lambda_Expr_F_Body;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Null_Lit_Range =>
declare
N_Bare_Null_Lit : constant Bare_Null_Lit := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Null_Lit.Null_Lit_F_Dest_Type;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Block_String_Lit_Range =>
declare
N_Bare_Block_String_Lit : constant Bare_Block_String_Lit := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Block_String_Lit.Block_String_Lit_F_Lines;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Module_Doc_String_Lit_Range =>
declare
N_Bare_Module_Doc_String_Lit : constant Bare_Module_Doc_String_Lit := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Module_Doc_String_Lit.Module_Doc_String_Lit_F_Lines;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Logic_Assign_Range =>
declare
N_Bare_Logic_Assign : constant Bare_Logic_Assign := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Logic_Assign.Logic_Assign_F_Dest_Var;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Logic_Assign.Logic_Assign_F_Value;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Logic_Expr_Range =>
declare
N_Bare_Logic_Expr : constant Bare_Logic_Expr := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Logic_Expr.Logic_Expr_F_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Logic_Propagate_Range =>
declare
N_Bare_Logic_Propagate : constant Bare_Logic_Propagate := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Logic_Propagate.Logic_Propagate_F_Dest_Var;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Logic_Propagate.Logic_Propagate_F_Call;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Logic_Unify_Range =>
declare
N_Bare_Logic_Unify : constant Bare_Logic_Unify := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Logic_Unify.Logic_Unify_F_Lhs;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Logic_Unify.Logic_Unify_F_Rhs;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Match_Expr_Range =>
declare
N_Bare_Match_Expr : constant Bare_Match_Expr := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Match_Expr.Match_Expr_F_Match_Expr;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Match_Expr.Match_Expr_F_Branches;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Not_Expr_Range =>
declare
N_Bare_Not_Expr : constant Bare_Not_Expr := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Not_Expr.Not_Expr_F_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Paren_Expr_Range =>
declare
N_Bare_Paren_Expr : constant Bare_Paren_Expr := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Paren_Expr.Paren_Expr_F_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Query_Range =>
declare
N_Bare_Query : constant Bare_Query := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Query.Query_F_Source;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Query.Query_F_Pattern;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Query.Query_F_Mapping;
                            return;
                    

                        when 4 =>
                            Result := N_Bare_Query.Query_F_Guard;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Raise_Expr_Range =>
declare
N_Bare_Raise_Expr : constant Bare_Raise_Expr := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Raise_Expr.Raise_Expr_F_Dest_Type;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Raise_Expr.Raise_Expr_F_Except_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Subscript_Expr_Range =>
declare
N_Bare_Subscript_Expr : constant Bare_Subscript_Expr := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Subscript_Expr.Subscript_Expr_F_Prefix;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Subscript_Expr.Subscript_Expr_F_Null_Cond;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Subscript_Expr.Subscript_Expr_F_Index;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Try_Expr_Range =>
declare
N_Bare_Try_Expr : constant Bare_Try_Expr := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Try_Expr.Try_Expr_F_Try_Expr;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Try_Expr.Try_Expr_F_Or_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Un_Op_Range =>
declare
N_Bare_Un_Op : constant Bare_Un_Op := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Un_Op.Un_Op_F_Op;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Un_Op.Un_Op_F_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Full_Decl_Range =>
declare
N_Bare_Full_Decl : constant Bare_Full_Decl := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Full_Decl.Full_Decl_F_Doc;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Full_Decl.Full_Decl_F_Decl_Annotations;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Full_Decl.Full_Decl_F_Decl;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Grammar_List_Sep_Range =>
declare
N_Bare_Grammar_List_Sep : constant Bare_Grammar_List_Sep := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Grammar_List_Sep.Grammar_List_Sep_F_Token;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Grammar_List_Sep.Grammar_List_Sep_F_Extra;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Import_Range =>
declare
N_Bare_Import : constant Bare_Import := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Import.Import_F_Name;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Langkit_Root_Range =>
declare
N_Bare_Langkit_Root : constant Bare_Langkit_Root := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Langkit_Root.Langkit_Root_F_Doc;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Langkit_Root.Langkit_Root_F_Imports;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Langkit_Root.Langkit_Root_F_Decls;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Lexer_Case_Rule_Range =>
declare
N_Bare_Lexer_Case_Rule : constant Bare_Lexer_Case_Rule := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Lexer_Case_Rule.Lexer_Case_Rule_F_Expr;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Lexer_Case_Rule.Lexer_Case_Rule_F_Alts;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Lexer_Case_Rule_Send_Range =>
declare
N_Bare_Lexer_Case_Rule_Send : constant Bare_Lexer_Case_Rule_Send := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Lexer_Case_Rule_Send.Lexer_Case_Rule_Send_F_Sent;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Lexer_Case_Rule_Send.Lexer_Case_Rule_Send_F_Match_Size;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Lkt_Node_Base_List =>
declare
N_Bare_Lkt_Node_Base_List : constant Bare_Lkt_Node_Base_List := Node;
begin

                    if Index > N_Bare_Lkt_Node_Base_List.Count then
                        Index_In_Bounds := False;
                    else
                        Result := N_Bare_Lkt_Node_Base_List.Nodes (Index);
                    end if;
                    return;
                
end;
when Lkt_Binding_Pattern_Range =>
declare
N_Bare_Binding_Pattern : constant Bare_Binding_Pattern := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Binding_Pattern.Binding_Pattern_F_Decl;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Binding_Pattern.Binding_Pattern_F_Sub_Pattern;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Ellipsis_Pattern_Range =>
declare
N_Bare_Ellipsis_Pattern : constant Bare_Ellipsis_Pattern := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Ellipsis_Pattern.Ellipsis_Pattern_F_Binding;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Extended_Pattern_Range =>
declare
N_Bare_Extended_Pattern : constant Bare_Extended_Pattern := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Extended_Pattern.Extended_Pattern_F_Sub_Pattern;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Extended_Pattern.Extended_Pattern_F_Details;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Filtered_Pattern_Range =>
declare
N_Bare_Filtered_Pattern : constant Bare_Filtered_Pattern := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Filtered_Pattern.Filtered_Pattern_F_Sub_Pattern;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Filtered_Pattern.Filtered_Pattern_F_Predicate;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_List_Pattern_Range =>
declare
N_Bare_List_Pattern : constant Bare_List_Pattern := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_List_Pattern.List_Pattern_F_Sub_Patterns;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Not_Pattern_Range =>
declare
N_Bare_Not_Pattern : constant Bare_Not_Pattern := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Not_Pattern.Not_Pattern_F_Sub_Pattern;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Or_Pattern_Range =>
declare
N_Bare_Or_Pattern : constant Bare_Or_Pattern := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Or_Pattern.Or_Pattern_F_Left_Sub_Pattern;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Or_Pattern.Or_Pattern_F_Right_Sub_Pattern;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Paren_Pattern_Range =>
declare
N_Bare_Paren_Pattern : constant Bare_Paren_Pattern := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Paren_Pattern.Paren_Pattern_F_Sub_Pattern;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Tuple_Pattern_Range =>
declare
N_Bare_Tuple_Pattern : constant Bare_Tuple_Pattern := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Tuple_Pattern.Tuple_Pattern_F_Sub_Patterns;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Type_Pattern_Range =>
declare
N_Bare_Type_Pattern : constant Bare_Type_Pattern := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Type_Pattern.Type_Pattern_F_Type_Name;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Field_Pattern_Detail_Range =>
declare
N_Bare_Field_Pattern_Detail : constant Bare_Field_Pattern_Detail := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Field_Pattern_Detail.Field_Pattern_Detail_F_Id;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Field_Pattern_Detail.Field_Pattern_Detail_F_Expected_Value;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Property_Pattern_Detail_Range =>
declare
N_Bare_Property_Pattern_Detail : constant Bare_Property_Pattern_Detail := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Property_Pattern_Detail.Property_Pattern_Detail_F_Call;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Property_Pattern_Detail.Property_Pattern_Detail_F_Expected_Value;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Selector_Pattern_Detail_Range =>
declare
N_Bare_Selector_Pattern_Detail : constant Bare_Selector_Pattern_Detail := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Selector_Pattern_Detail.Selector_Pattern_Detail_F_Call;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Selector_Pattern_Detail.Selector_Pattern_Detail_F_Sub_Pattern;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Selector_Call_Range =>
declare
N_Bare_Selector_Call : constant Bare_Selector_Call := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Selector_Call.Selector_Call_F_Quantifier;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Selector_Call.Selector_Call_F_Binding;
                            return;
                    

                        when 3 =>
                            Result := N_Bare_Selector_Call.Selector_Call_F_Selector_Call;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Function_Type_Ref_Range =>
declare
N_Bare_Function_Type_Ref : constant Bare_Function_Type_Ref := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Function_Type_Ref.Function_Type_Ref_F_Param_Types;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Function_Type_Ref.Function_Type_Ref_F_Return_Type;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Generic_Type_Ref_Range =>
declare
N_Bare_Generic_Type_Ref : constant Bare_Generic_Type_Ref := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Generic_Type_Ref.Generic_Type_Ref_F_Type_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Generic_Type_Ref.Generic_Type_Ref_F_Args;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Simple_Type_Ref_Range =>
declare
N_Bare_Simple_Type_Ref : constant Bare_Simple_Type_Ref := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Simple_Type_Ref.Simple_Type_Ref_F_Type_Name;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when Lkt_Var_Bind_Range =>
declare
N_Bare_Var_Bind : constant Bare_Var_Bind := Node;
begin
case Index is

                        when 1 =>
                            Result := N_Bare_Var_Bind.Var_Bind_F_Name;
                            return;
                    

                        when 2 =>
                            Result := N_Bare_Var_Bind.Var_Bind_F_Expr;
                            return;
                    

                        when others => null;
                    end case;
                
end;
when others => null;
end case;

      --  Execution should reach this point iff nothing matched this index, so
      --  we must be out of bounds.
      Index_In_Bounds := False;
   end Get_Child;

   -----------
   -- Print --
   -----------

   procedure Print
     (Node        : Liblktlang_Support.Generic_API.Analysis.Lk_Node;
      Show_Slocs  : Boolean;
      Line_Prefix : String := "")
   is
      use Liblktlang_Support.Generic_API.Analysis;
      use Liblktlang_Support.Generic_API.Introspection;

      T : Type_Ref;
   begin
      if Node.Is_Null then
         Put_Line ("None");
         return;
      end if;

      T := Type_Of (Node);
      Put (Line_Prefix & Image (Node_Type_Repr_Name (T)));
      if Show_Slocs then
         Put ("[" & Image (Node.Sloc_Range) & "]");
      end if;

      if Node.Is_Incomplete then
         Put (" <<INCOMPLETE>>");
      end if;

      if Node.Is_Token_Node then
         Put_Line (": " & Image (Node.Text));

      elsif Is_List_Node (Node) then

         --  List nodes are displayed in a special way (they have no field)

         declare
            Count : constant Natural := Node.Children_Count;
            Child : Lk_Node;
         begin
            if Count = 0 then
               Put_Line (": <empty list>");
               return;
            end if;
            New_Line;

            for I in 1 .. Count loop
               Child := Node.Child (I);
               if not Child.Is_Null then
                  Print (Child, Show_Slocs, Line_Prefix & "|  ");
               end if;
            end loop;
         end;

      else
         --  This is for regular nodes: display each syntax field (i.e.
         --  non-property member).

         declare
            Attr_Prefix     : constant String := Line_Prefix & "|";
            Children_Prefix : constant String := Line_Prefix & "|  ";
            M_List          : constant Struct_Member_Ref_Array := Members (T);
            Child           : Lk_Node;
         begin
            New_Line;
            for M of M_List loop
               if not Is_Property (M) and then not Is_Null_For (M, T) then
                  Child := As_Node (Eval_Node_Member (Node, M));
                  Put (Attr_Prefix
                       & Image (Format_Name (Member_Name (M), Lower)) & ":");
                  if Child.Is_Null then
                     Put_Line (" <null>");
                  else
                     New_Line;
                     Print (Child, Show_Slocs, Children_Prefix);
                  end if;
               end if;
            end loop;
         end;
      end if;
   end Print;

   -----------
   -- Print --
   -----------

   procedure Print
     (Node        : Bare_Lkt_Node;
      Show_Slocs  : Boolean;
      Line_Prefix : String := "")
   is
      Entity : constant Internal_Entity := (Node, No_Entity_Info);
   begin
      Print (To_Generic_Node (Entity), Show_Slocs, Line_Prefix);
   end Print;

   ------------
   -- Parent --
   ------------

   function Parent (Node : Bare_Lkt_Node) return Bare_Lkt_Node is
   begin
      return Node.Parent;
   end Parent;

   ------------------
   -- Stored_Token --
   ------------------

   function Stored_Token
     (Node  : Bare_Lkt_Node;
      Token : Token_Reference) return Token_Index
   is
      Index : constant Token_Or_Trivia_Index := Get_Token_Index (Token);
   begin
      if Node.Unit.TDH'Access /= Get_Token_TDH (Token) then
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "Cannot associate a token and a node from different analysis"
            & " units");
      elsif Index.Trivia /= No_Token_Index then
         Raise_Property_Exception
           (Node,
            Property_Error'Identity,
            "A node cannot hold trivia");
      end if;

      return Index.Token;
   end Stored_Token;

   -------------------------
   -- Children_And_Trivia --
   -------------------------

   function Children_And_Trivia
     (Node : Bare_Lkt_Node) return Bare_Children_Vector
   is
      Ret_Vec : Bare_Children_Vector;
      Ctx     : Internal_Context renames Node.Unit.Context;
      TDH     : Token_Data_Handler renames Node.Unit.TDH;

      procedure Append_Trivias (First, Last : Token_Index);
      --  Append all the trivias of tokens between indices First and Last to
      --  the returned vector.

      function Filter_Children
        (Parent : Bare_Lkt_Node)
         return Internal_Bare_Lkt_Node_Array;
      --  Return an array for all children in Parent that are not null

      --------------------
      -- Append_Trivias --
      --------------------

      procedure Append_Trivias (First, Last : Token_Index) is
      begin
         for I in First .. Last loop
            for D of Get_Trivias (TDH, I) loop
               Ret_Vec.Append
                 (Bare_Child_Record'
                    (Kind   => Trivia,
                     Trivia => Wrap_Token_Reference
                                 (Ctx, TDH'Access, (I, D))));
            end loop;
         end loop;
      end Append_Trivias;

      ---------------------
      -- Filter_Children --
      ---------------------

      function Filter_Children
        (Parent : Bare_Lkt_Node)
         return Internal_Bare_Lkt_Node_Array
      is
         Children : constant Internal_Bare_Lkt_Node_Array :=
            Implementation.Children (Parent);
         Result   : Internal_Bare_Lkt_Node_Array (Children'Range);
         Next     : Integer := Result'First;
      begin
         for I in Children'Range loop
            if Children (I) /= null then
               Result (Next) := Children (I);
               Next := Next + 1;
            end if;
         end loop;
         return Result (Result'First .. Next - 1);
      end Filter_Children;

      First_Child : constant Positive := 1;
      N_Children  : constant Internal_Bare_Lkt_Node_Array :=
         Filter_Children (Node);
   begin
      if N_Children'Length > 0
        and then (Node.Token_Start_Index
                    /= N_Children (First_Child).Token_Start_Index)
      then
         Append_Trivias (Node.Token_Start_Index,
                         N_Children (First_Child).Token_Start_Index - 1);
      end if;

      --  Append each node to Ret_Vec, and append trivia that follow after each
      --  non-ghost nodes.
      for I in N_Children'Range loop
         Ret_Vec.Append (Bare_Child_Record'(Child, N_Children (I)));
         if not Is_Ghost (N_Children (I)) then
            Append_Trivias (N_Children (I).Token_End_Index,
                            (if I = N_Children'Last
                             then Node.Token_End_Index - 1
                             else N_Children (I + 1).Token_Start_Index - 1));
         end if;
      end loop;

      return Ret_Vec;
   end Children_And_Trivia;

   --------------
   -- Is_Ghost --
   --------------

   function Is_Ghost (Node : Bare_Lkt_Node) return Boolean
   is (Node.Token_End_Index = No_Token_Index);

   -------------------
   -- Is_Incomplete --
   -------------------

   function Is_Incomplete (Node : Bare_Lkt_Node) return Boolean
   is
      LGC : Bare_Lkt_Node;
   begin
     if Is_List_Node (Node.Kind) then
        LGC := (if Last_Child_Index (Node) /= 0
                then Child (Node, Last_Child_Index (Node))
                else null);
        return LGC /= null and then Is_Incomplete (LGC);
      else
         return Node.Last_Attempted_Child > -1;
      end if;
   end;

   -----------------
   -- Token_Start --
   -----------------

   function Token_Start (Node : Bare_Lkt_Node) return Token_Reference
   is (Token (Node, Node.Token_Start_Index));

   ---------------
   -- Token_End --
   ---------------

   function Token_End (Node : Bare_Lkt_Node) return Token_Reference
   is
     (if Node.Token_End_Index = No_Token_Index
      then Token_Start (Node)
      else Token (Node, Node.Token_End_Index));

   -----------
   -- Token --
   -----------

   function Token
     (Node  : Bare_Lkt_Node;
      Index : Token_Index) return Token_Reference
   is
      Unit    : constant Internal_Unit := Node.Unit;
      Context : constant Internal_Context := Unit.Context;
   begin
      return Wrap_Token_Reference
        (Context, Token_Data (Unit), (Index, No_Token_Index));
   end Token;

   ---------
   -- "<" --
   ---------

   function "<" (Left, Right : Bare_Lkt_Node) return Boolean is
   begin
      --  Reject invalid inputs
      if Left /= null and Is_Synthetic (Left) then
         raise Property_Error with "left node is synthetic";
      elsif Right /= null and Is_Synthetic (Right) then
         raise Property_Error with "right node is synthetic";
      end if;

      --  Null nodes come first
      if Left = null then
         return Right /= null;
      elsif Right = null then
         return False;
      end if;

      --  So we have two non-null nodes. Sort by unit filename
      if Left.Unit < Right.Unit then
         return True;
      elsif Left.Unit /= Right.Unit then
         return False;
      end if;

      --  Both nodes come from the same unit: compare their token indexes
      if Left.Token_Start_Index < Right.Token_Start_Index then
         return True;
      elsif Left.Token_Start_Index > Right.Token_Start_Index then
         return False;
      else
         return Left.Token_End_Index < Right.Token_End_Index;
      end if;
   end "<";

   -------------
   -- Is_Null --
   -------------

   function Is_Null (Node : Bare_Lkt_Node) return Boolean
   is (Node = null);

   ----------
   -- Kind --
   ----------

   function Kind (Node : Bare_Lkt_Node) return Lkt_Node_Kind_Type
   is (Node.Kind);

   -----------------
   -- Child_Index --
   -----------------

   function Child_Index (Node : Bare_Lkt_Node) return Integer
   is
      N : Bare_Lkt_Node := null;
   begin
      if Node.Parent = null then
         raise Property_Error with
            "Trying to get the child index of a root node";
      end if;

      for I in First_Child_Index (Node.Parent)
            .. Last_Child_Index (Node.Parent)
      loop
         N := Child (Node.Parent, I);
         if N = Node then
            return I - 1;
         end if;
      end loop;

      --  If we reach this point, then Node isn't a Child of Node.Parent. This
      --  is not supposed to happen.
      raise Program_Error;
   end Child_Index;

   -------------------
   -- Fetch_Sibling --
   -------------------

   function Fetch_Sibling
     (Node   : Bare_Lkt_Node;
      Offset : Integer) return Bare_Lkt_Node is
   begin
      --  Root nodes have no sibling: handle them now to avoid invalid requests
      --  in the code below.
      if Node.Parent = null then
         return null;
      end if;

      declare
         Node_Index : constant Positive := Child_Index (Node) + 1;
         --  Child_Index is 0-based, but the Child primitive expects a 1-based
         --  index.

         Sibling_Index : constant Integer := Node_Index + Offset;
      begin
         --  Child returns null for out-of-bound indexes

         return (if Sibling_Index >= 1
                 then Child (Node.Parent, Sibling_Index)
                 else null);
      end;
   end Fetch_Sibling;

   -------------------
   -- Fetch_Sibling --
   -------------------

   function Fetch_Sibling
     (Node   : Bare_Lkt_Node;
      E_Info : Internal_Entity_Info;
      Offset : Integer) return Internal_Entity
   is
      Sibling : constant Bare_Lkt_Node := Fetch_Sibling (Node, Offset);
   begin
      --  Don't forget to clear entity info if the result is nul

      return (if Sibling = null
              then No_Entity
              else (Sibling, E_Info));
   end Fetch_Sibling;

   ----------------------
   -- Previous_Sibling --
   ----------------------

   function Previous_Sibling
     (Node   : Bare_Lkt_Node;
      E_Info : Internal_Entity_Info := No_Entity_Info)
      return Internal_Entity is
   begin
      return Fetch_Sibling (Node, E_Info, -1);
   end Previous_Sibling;

   ------------------
   -- Next_Sibling --
   ------------------

   function Next_Sibling
     (Node   : Bare_Lkt_Node;
      E_Info : Internal_Entity_Info := No_Entity_Info)
      return Internal_Entity is
   begin
      return Fetch_Sibling (Node, E_Info, 1);
   end Next_Sibling;

   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (Self : Node_Builder_Type) is
   begin
      if Self.Ref_Count > 0 then
         Self.Ref_Count := Self.Ref_Count + 1;
      end if;
   end Inc_Ref;

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (Self : in out Node_Builder_Type) is
   begin
      if Self = null or else Self.Ref_Count < 0 then
         return;
      elsif Self.Ref_Count = 1 then
         Self.Release;
         Free (Self);
      else
         Self.Ref_Count := Self.Ref_Count - 1;
      end if;
   end Dec_Ref;

   ------------------------------
   -- Create_Copy_Node_Builder --
   ------------------------------

   function Create_Copy_Node_Builder
     (Value : Bare_Lkt_Node) return Node_Builder_Type is
   begin
      --  No need to allocate a new builder if in practice it cannot be
      --  distinguished from the "null" builder.

      if Value = null then
         return Null_Node_Builder;
      else
         return new Copy_Node_Builder_Record'(Ref_Count => 1, Value => Value);
      end if;
   end Create_Copy_Node_Builder;

         

         type Bare_Synthetic_Type_Ref_List_Node_Builder_Record is new Node_Builder_Record with
            record
               List_Elements : Bare_Type_Ref_Node_Builder_Array_Access;
            end record;
         type Bare_Synthetic_Type_Ref_List_Node_Builder_Access is access all Bare_Synthetic_Type_Ref_List_Node_Builder_Record;

         overriding function Build
           (Self              : Bare_Synthetic_Type_Ref_List_Node_Builder_Record;
            Parent, Self_Node : Bare_Lkt_Node)
            return Bare_Lkt_Node;

         overriding function Trace_Image
           (Self : Bare_Synthetic_Type_Ref_List_Node_Builder_Record) return String
         is ("<NodeBuilder to synthetize SyntheticTypeRefList>");

            overriding procedure Release (Self : in out Bare_Synthetic_Type_Ref_List_Node_Builder_Record);

         -----------
         -- Build --
         -----------

         overriding function Build
           (Self              : Bare_Synthetic_Type_Ref_List_Node_Builder_Record;
            Parent, Self_Node : Bare_Lkt_Node)
            return Bare_Lkt_Node
         is
            Result : Bare_Lkt_Node;
            Unit   : constant Internal_Unit := Self_Node.Unit;
            Env    : constant Lexical_Env :=
              (if Parent = null
               then Empty_Env
               else Parent.Self_Env);
         begin
            if Parent /= null and then Parent.Unit /= Unit then
               Raise_Property_Exception
                 (Self_Node,
                  Property_Error'Identity,
                  "synthetic node parents must belong to the same unit as the"
                  & " nodes that trigger node synthetization");
            end if;

            if Is_Foreign_Strict (Env, Parent) then
               Raise_Property_Exception
                 (Self_Node,
                  Property_Error'Identity,
                  "synthetic nodes cannot have foreign lexical envs");
            end if;

            Result := new Root_Node_Record
              (Lkt_Synthetic_Type_Ref_List);
            Initialize
              (Self => Result,
               Kind => Lkt_Synthetic_Type_Ref_List,
               Unit => Unit,

               Token_Start_Index => No_Token_Index,
               Token_End_Index   => No_Token_Index,

               Parent   => Parent,
               Self_Env => Env);
            Register_Destroyable (Unit, Result);

               declare
                  Elements_Builders : Internal_Bare_Type_Ref_Node_Builder_Array renames Self.List_Elements.Items;
                  Children          : constant
                    Alloc_AST_List_Array.Element_Array_Access :=
                      Allocate_Synthetic_List_Children
                        (Result, Elements_Builders'Length);
               begin
                  for I in Elements_Builders'Range loop
                     Children (I) :=
                       Elements_Builders (I).Build (Result, Self_Node);
                  end loop;
               end;


            return Result;
         end Build;


            -------------
            -- Release --
            -------------

            overriding procedure Release (Self : in out Bare_Synthetic_Type_Ref_List_Node_Builder_Record) is
            begin
                     Dec_Ref (Self.List_Elements);
            end Release;

         function Create_Bare_Synthetic_Type_Ref_List_Node_Builder
             (List_Elements : Bare_Type_Ref_Node_Builder_Array_Access)
           return Bare_Synthetic_Type_Ref_List_Node_Builder
         is
            Builder : constant Bare_Synthetic_Type_Ref_List_Node_Builder_Access := new Bare_Synthetic_Type_Ref_List_Node_Builder_Record;
         begin
            Builder.Ref_Count := 1;
               Builder.List_Elements := List_Elements;
                  Inc_Ref (Builder.List_Elements);
            return Node_Builder_Type (Builder);
         end Create_Bare_Synthetic_Type_Ref_List_Node_Builder;


   ----------------------
   -- Compare_Metadata --
   ----------------------

   --  Deactivate "not referenced" warnings because if the metadata struct has
   --  no fields, formals and temporaries won't be referenced in the two
   --  following functions.
   pragma Warnings (Off, "referenced");
   function Compare_Metadata (L, R : Internal_Metadata) return Boolean is
   begin
      return True;
   end Compare_Metadata;

   ----------
   -- Hash --
   ----------

   function Hash (Self : Internal_Metadata) return Hash_Type is
      Ret : Hash_Type := Liblktlang_Support.Hashes.Initial_Hash;
   begin
      return Ret;
   end Hash;
   pragma Warnings (On, "referenced");

   -------------
   -- Combine --
   -------------

   function Combine
     (L, R : Internal_Metadata) return Internal_Metadata
   is
      pragma Unreferenced (L, R);
      Ret : Internal_Metadata := No_Metadata;
   begin
      return Ret;
   end Combine;

   -------------------------------
   -- Create_Static_Lexical_Env --
   -------------------------------

   function Create_Static_Lexical_Env
     (Parent            : Lexical_Env;
      Node              : Bare_Lkt_Node;
      Sym_Table         : Symbol_Table;
      Transitive_Parent : Boolean := False) return Lexical_Env
   is
      Unit : constant Internal_Unit :=
        (if Node = null then null else Node.Unit);
   begin
      return Result : Lexical_Env := Create_Lexical_Env
        (Parent, Node, Transitive_Parent, Sym_Table, Convert_Unit (Unit))
      do
         if Unit /= null then
            Register_Destroyable (Unit, Unwrap (Result.Env));
         end if;
      end return;
   end Create_Static_Lexical_Env;

   ---------
   -- Get --
   ---------

   function Get
     (Self  : Bare_Lkt_Node;
      A     : AST_Envs.Entity_Array;
      Index : Integer) return Internal_Entity
   is
      function Length (A : AST_Envs.Entity_Array) return Natural
      is (A'Length);

      function Get
        (A     : AST_Envs.Entity_Array;
         Index : Integer) return Internal_Entity
      is (A (Index + 1)); --  A is 1-based but Index is 0-based

      function Relative_Get is new Liblktlang_Support.Relative_Get
        (Item_Type     => Entity,
         Sequence_Type => AST_Envs.Entity_Array,
         Length        => Length,
         Get           => Get);
      Result : Internal_Entity;
   begin
      if Relative_Get (A, Index, Result) then
         return Result;
      else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "out-of-bounds array access");
      end if;
   end Get;

   -----------
   -- Group --
   -----------

   function Group
     (Envs   : Lexical_Env_Array_Access;
      Env_Md : Internal_Metadata := No_Metadata) return Lexical_Env
   is (Group (Lexical_Env_Array (Envs.Items), Env_Md));

       

   

      --
      --  Untyped wrappers for Bare_Lkt_Node
      --

         
function Lkt_Node_P_Shed_Rebindings
  (E : Entity
  ) return Internal_Entity;



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   

      --
      --  Untyped wrappers for Bare_Dyn_Env_Wrapper
      --

         
function Dyn_Env_Wrapper_P_Instantiation_Bindings
  (E : Entity
  ) return Internal_Inner_Env_Assoc_Array_Access;



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   

      --
      --  Untyped wrappers for Bare_Langkit_Root
      --

         
function Langkit_Root_P_Internal_Env
  (E : Entity
  ) return Lexical_Env;



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   



       

   




   ------------------
   -- Children_Env --
   ------------------

   function Children_Env
     (Node   : Bare_Lkt_Node;
      E_Info : Internal_Entity_Info := No_Entity_Info)
      return Lexical_Env
   is (Rebind_Env (Node.Self_Env, E_Info));

   --------------
   -- Node_Env --
   --------------

   function Node_Env
     (Node   : Bare_Lkt_Node;
      E_Info : Internal_Entity_Info := No_Entity_Info)
      return Lexical_Env
   is
      function Get_Base_Env return Lexical_Env;
      --  Return the environment that we need to rebind before returning

      ------------------
      -- Get_Base_Env --
      ------------------

      function Get_Base_Env return Lexical_Env is
         pragma Warnings (Off, "referenced");
         function Get_Parent_Env return Lexical_Env;
         pragma Warnings (On, "referenced");

         --------------------
         -- Get_Parent_Env --
         --------------------

         function Get_Parent_Env return Lexical_Env is
            Parent : constant Lexical_Env := AST_Envs.Parent (Node.Self_Env);
         begin
            --  If Node is the root scope or the empty environment, Parent can
            --  be a wrapper around the null node. Turn this into the
            --  Empty_Env, as null envs are erroneous values in properties.
            return (if Unwrap (Parent) = null
                    then Empty_Env
                    else Parent);
         end Get_Parent_Env;

      begin
         
         return
           (if Node.Kind in Lkt_Match_Branch | Lkt_Pattern_Match_Branch | Lkt_Field_Decl | Lkt_Fun_Decl | Lkt_Env_Spec_Decl | Lkt_Generic_Decl | Lkt_Grammar_Decl | Lkt_Lexer_Decl | Lkt_Block_Expr | Lkt_Lambda_Expr | Lkt_Decl_Block
            then Get_Parent_Env
            else Node.Self_Env);
      end Get_Base_Env;

      Base_Env : Lexical_Env := Get_Base_Env;
      Result   : constant Lexical_Env := Rebind_Env (Base_Env, E_Info);
   begin
      Dec_Ref (Base_Env);
      return Result;
   end Node_Env;

   ------------
   -- Parent --
   ------------

   function Parent
     (Node   : Bare_Lkt_Node;
      E_Info : Internal_Entity_Info := No_Entity_Info)
      return Internal_Entity is
   begin
      --  TODO: shed entity information as appropriate
      return (Node.Parent, E_Info);
   end Parent;

   -------------
   -- Parents --
   -------------

   function Parents
     (Node      : Bare_Lkt_Node;
      With_Self : Boolean := True;
      E_Info    : Internal_Entity_Info := No_Entity_Info)
      return Internal_Entity_Array_Access
   is
      Bare_Parents : Bare_Lkt_Node_Array_Access := Parents (Node, With_Self);
      Result       : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (Bare_Parents.N);
   begin
      --  TODO: shed entity information as appropriate
      for I in Bare_Parents.Items'Range loop
         Result.Items (I) := (Bare_Parents.Items (I), E_Info);
      end loop;
      Dec_Ref (Bare_Parents);
      return Result;
   end Parents;

   --------------
   -- Children --
   --------------

   function Children
     (Node   : Bare_Lkt_Node;
      E_Info : Internal_Entity_Info := No_Entity_Info)
      return Internal_Entity_Array_Access
   is
      Bare_Children : Bare_Lkt_Node_Array_Access := Children (Node);
      Result        : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (Bare_Children.N);
   begin
      --  TODO: shed entity information as appropriate
      for I in Bare_Children.Items'Range loop
         Result.Items (I) := (Bare_Children.Items (I), E_Info);
      end loop;
      Dec_Ref (Bare_Children);
      return Result;
   end Children;

   ---------------------
   -- New_Unit_String --
   ---------------------

   function New_Unit_String
     (Unit : Internal_Unit; Str : String) return String_Access
   is
      procedure Register_Destroyable_String is new Register_Destroyable_Gen
        (String, String_Access, Free);
   begin
      return Ret : String_Access := new String'(Str) do
         Register_Destroyable_String (Unit, Ret);
      end return;
   end New_Unit_String;

   --------------------------------
   -- Assign_Names_To_Logic_Vars --
   --------------------------------

   procedure Assign_Names_To_Logic_Vars (Node : Bare_Lkt_Node) is

      pragma Warnings (Off, "referenced");

      procedure Assign
        (Node  : Bare_Lkt_Node;
         LV    : in out Logic_Var_Record;
         Field : String);
      --  Assign a name to the LV logic variable. Node must be the node that
      --  owns LV, and Field must be the name of the field in Node that holds
      --  LV.

      ------------
      -- Assign --
      ------------

      procedure Assign
        (Node  : Bare_Lkt_Node;
         LV    : in out Logic_Var_Record;
         Field : String) is
      begin
         LV.Dbg_Name :=
           new String'(Image (Short_Text_Image (Node)) & "." & Field);
      end Assign;

      K : constant Lkt_Node_Kind_Type := Node.Kind;

      pragma Warnings (On, "referenced");

   begin
      
      case Lkt_Lkt_Node (K) is
when Lkt_Lambda_Param_Decl_Range =>
declare
N_Bare_Lambda_Param_Decl : constant Bare_Lambda_Param_Decl := Node;
begin
Assign (N_Bare_Lambda_Param_Decl,        N_Bare_Lambda_Param_Decl.Lambda_Param_Decl_F_Type_Var,        "type_var");
end;
when Lkt_Expr =>
declare
N_Bare_Expr : constant Bare_Expr := Node;
begin
Assign (N_Bare_Expr,        N_Bare_Expr.Expr_F_Expected_Type_Var,        "expected_type_var");
Assign (N_Bare_Expr,        N_Bare_Expr.Expr_F_Actual_Type_Var,        "actual_type_var");
Assign (N_Bare_Expr,        N_Bare_Expr.Expr_F_Generic_Func_Type_Var,        "generic_func_type_var");
case Lkt_Expr (K) is
when Lkt_Array_Literal_Range =>
declare
N_Bare_Array_Literal : constant Bare_Array_Literal := N_Bare_Expr;
begin
Assign (N_Bare_Array_Literal,        N_Bare_Array_Literal.Array_Literal_F_Expected_Exprs_Type_Var,        "expected_exprs_type_var");
Assign (N_Bare_Array_Literal,        N_Bare_Array_Literal.Array_Literal_F_Actual_Element_Type,        "actual_element_type");
end;
when Lkt_Generic_Instantiation_Range =>
declare
N_Bare_Generic_Instantiation : constant Bare_Generic_Instantiation := N_Bare_Expr;
begin
Assign (N_Bare_Generic_Instantiation,        N_Bare_Generic_Instantiation.Generic_Instantiation_F_Rebinded_Var,        "rebinded_var");
end;
when Lkt_Ref_Id_Range =>
declare
N_Bare_Ref_Id : constant Bare_Ref_Id := N_Bare_Expr;
begin
Assign (N_Bare_Ref_Id,        N_Bare_Ref_Id.Ref_Id_F_Ref_Var,        "ref_var");
end;
when Lkt_If_Expr_Range =>
declare
N_Bare_If_Expr : constant Bare_If_Expr := N_Bare_Expr;
begin
Assign (N_Bare_If_Expr,        N_Bare_If_Expr.If_Expr_F_Expected_Branch_Type_Var,        "expected_branch_type_var");
end;
when Lkt_Keep_Expr_Range =>
declare
N_Bare_Keep_Expr : constant Bare_Keep_Expr := N_Bare_Expr;
begin
Assign (N_Bare_Keep_Expr,        N_Bare_Keep_Expr.Keep_Expr_F_Array_Element_Type,        "array_element_type");
end;
when Lkt_Match_Expr_Range =>
declare
N_Bare_Match_Expr : constant Bare_Match_Expr := N_Bare_Expr;
begin
Assign (N_Bare_Match_Expr,        N_Bare_Match_Expr.Match_Expr_F_Expected_Branch_Type_Var,        "expected_branch_type_var");
end;
when Lkt_Try_Expr_Range =>
declare
N_Bare_Try_Expr : constant Bare_Try_Expr := N_Bare_Expr;
begin
Assign (N_Bare_Try_Expr,        N_Bare_Try_Expr.Try_Expr_F_Expected_Expr_Type_Var,        "expected_expr_type_var");
end;
when others => null;
end case;
end;
when Lkt_Type_Ref =>
declare
N_Bare_Type_Ref : constant Bare_Type_Ref := Node;
begin
Assign (N_Bare_Type_Ref,        N_Bare_Type_Ref.Type_Ref_F_Type_Var,        "type_var");
end;
when others => null;
end case;
      for Child of Internal_Bare_Lkt_Node_Array'(Children (Node)) loop
         if Child /= null then
            Assign_Names_To_Logic_Vars (Child);
         end if;
      end loop;
   end Assign_Names_To_Logic_Vars;

   --------------------------
   -- Initialization_Error --
   --------------------------

   function Initialization_Error
     (Exc : Ada.Exceptions.Exception_Occurrence)
      return Error_Initialization_State
   is
      use Ada.Exceptions;
   begin
      if
         
            Exception_Identity (Exc) = Property_Error'Identity
         then
            return Raised_Property_Error;
      else
         raise Program_Error;
      end if;
   end Initialization_Error;

   ----------------------------------
   -- Reraise_Initialization_Error --
   ----------------------------------

   procedure Reraise_Initialization_Error
     (Node    : Bare_Lkt_Node;
      State   : Error_Initialization_State;
      Message : String)
   is
      Exc : Ada.Exceptions.Exception_Id;
   begin
      case State is
            when Raised_Property_Error =>
               Exc := Property_Error'Identity;
      end case;
      Raise_Property_Exception (Node, Exc, Message);
   end Reraise_Initialization_Error;

   ----------------
   -- Text_Image --
   ----------------

   function Text_Image (Ent : Internal_Entity) return Text_Type is
   begin
      if Ent.Node /= null then
         declare
            Node_Image : constant Text_Type := Short_Text_Image (Ent.Node);
         begin
            return
            (if Ent.Info.Rebindings /= null
             then "<| "
             & Node_Image (Node_Image'First + 1 .. Node_Image'Last - 1) & " "
             & AST_Envs.Text_Image (Ent.Info.Rebindings) & " |>"
             else Node_Image);
         end;
      else
         return "None";
      end if;
   end Text_Image;

   ---------------------
   -- Full_Sloc_Image --
   ---------------------

   function Full_Sloc_Image (Node : Bare_Lkt_Node) return String_Type
   is
      Res      : constant Text_Type :=
        To_Text
          (Ada.Directories.Simple_Name
             (Get_Filename (Unit (Node))))
           & ":" & To_Text (Image (Start_Sloc (Sloc_Range (Node)))) & ": ";
   begin
      return Create_String (Res);
   end Full_Sloc_Image;

   ---------------------------------
   -- Completion_Item_Kind_To_Int --
   ---------------------------------

   function Completion_Item_Kind_To_Int
     (Node : Bare_Lkt_Node;
      Kind : Completion_Item_Kind)
      return Integer
   is
      pragma Unreferenced (Node);
   begin
      return Completion_Item_Kind'Enum_Rep (Kind) + 1;
   end Completion_Item_Kind_To_Int;

   -----------
   -- Image --
   -----------

   function Image (Ent : Internal_Entity) return String is
      Result : constant Text_Type := Text_Image (Ent);
   begin
      return Image (Result);
   end Image;

   ---------------
   -- Can_Reach --
   ---------------

   function Can_Reach (El, From : Bare_Lkt_Node) return Boolean is
   begin
      return Lkt_Node_P_Can_Reach (El, From);
   end Can_Reach;

   -----------------
   -- Hash_Entity --
   -----------------

   function Hash_Entity (Self : Internal_Entity) return Hash_Type is
   begin
      return Combine
        ((Hash (Self.Node), Hash (Self.Info.Rebindings), Hash (Self.Info.Md)));
   end Hash_Entity;

   --------------------
   -- Compare_Entity --
   --------------------

   function Compare_Entity (Left, Right : Internal_Entity) return Boolean
   is
   begin
      return Left.Node = Right.Node
             and then Left.Info.Rebindings = Right.Info.Rebindings
             and then Compare_Metadata (Left.Info.Md, Right.Info.Md);
   end Compare_Entity;

   --------------------------------
   -- Create_Dynamic_Lexical_Env --
   --------------------------------

   function Create_Dynamic_Lexical_Env
     (Self              : Bare_Lkt_Node;
      Assocs_Getter     : Inner_Env_Assocs_Resolver;
      Assoc_Resolver    : Entity_Resolver;
      Transitive_Parent : Boolean;
      Sym_Table         : Symbol_Table) return Lexical_Env
   is
      Unit : constant Internal_Unit := Self.Unit;
   begin
      --  This restriction is necessary to avoid relocation issues when
      --  Self.Self_Env is terminated.
      if Is_Foreign_Strict (Self.Self_Env, Self) then
         Raise_Property_Exception
           (Self,
            Property_Error'Identity,
            "cannot create a dynamic lexical env when Self.Self_Env is"
            & " foreign");
      end if;

      return Result : constant Lexical_Env := Create_Dynamic_Lexical_Env
        (Parent            => Null_Lexical_Env,
         Node              => Self,
         Transitive_Parent => Transitive_Parent,
         Owner             => Convert_Unit (Unit),
         Assocs_Getter     => Assocs_Getter,
         Assoc_Resolver    => Assoc_Resolver,
         Sym_Table         => Sym_Table)
      do
         --  Since dynamic lexical environments can only be created in lazy
         --  field initializers, it is fine to tie Result's lifetime to the
         --  its owning unit's lifetime.
         Register_Destroyable (Unit, Unwrap (Result));
      end return;
   end Create_Dynamic_Lexical_Env;

   procedure Destroy_Synthetic_Node (Node : in out Bare_Lkt_Node);
   --  Helper for the Register_Destroyable above

   ------------
   -- Length --
   ------------

   function Length (Node : Bare_Lkt_Node_Base_List) return Natural
   is (if Node = null then 0 else Children_Count (Node));


      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (B : Boolean) return String is
      begin
         return (if B then "True" else "False");
      end Trace_Image;

      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (I : Integer) return String is
      begin
         return Integer'Image (I);
      end Trace_Image;

      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (S : Symbol_Type) return String is
      begin
         return (if S = No_Symbol
                 then "None"
                 else Image (S, With_Quotes => True));
      end Trace_Image;

      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (C : Character_Type) return String is
         C_Str : constant Text_Type := (1 => C);
      begin
         return "'" & Image (C_Str) & "'";
      end Trace_Image;

      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (S : String_Type) return String is
      begin
         return Image (S.Content, With_Quotes => True);
      end Trace_Image;

      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (Env : Lexical_Env) return String is
      begin
         case Env.Kind is
         when Static_Primary =>
            return "<LexicalEnv static-primary for "
                   & Trace_Image (Env_Node (Env)) & ">";
         when others =>
            return "<LexicalEnv synthetic>";
         end case;
      end Trace_Image;

      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (R : Env_Rebindings) return String is
      begin
         return Image (Text_Image (R));
      end Trace_Image;

      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (Unit : Internal_Unit) return String is
      begin
         return "Internal_Unit (""" & Basename (Unit) & """)";
      end Trace_Image;

      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (Eq : Logic_Equation) return String is
         pragma Unreferenced (Eq);
      begin
         return "<LogicEquation>";
      end Trace_Image;

      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (Var : Logic_Var) return String is
         pragma Unreferenced (Var);
      begin
         return "<LogicVariable>";
      end Trace_Image;

      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (K : Analysis_Unit_Kind) return String is
      begin
         return Analysis_Unit_Kind'Image (K);
      end Trace_Image;

      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image (Self : Ref_Categories) return String is
         Result : Unbounded_String;
         First  : Boolean := True;
      begin
         Append (Result, "RefCategories(");
         for C in Ref_Category loop
            if Self (C) then
               if First then
                  First := False;
               else
                  Append (Result, ", ");
               end if;
               Append (Result, C'Image);
            end if;
         end loop;
         Append (Result, ")");
         return To_String (Result);
      end Trace_Image;


   

   




   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Metadata) return String is
         pragma Warnings (On, "referenced");
      begin
            return
              ("("
                  & "null record"
               & ")");
      end Trace_Image;


   

   




   

      ----------
      -- Hash --
      ----------

      pragma Warnings (Off, "referenced");
      function Hash (R : Internal_Entity_Info) return Hash_Type is
         pragma Warnings (On, "referenced");
      begin
         
            return Combine ((Hash (R.Md), Hash (R.Rebindings), Hash (R.From_Rebound)));
      end Hash;


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Info) return String is
         pragma Warnings (On, "referenced");
      begin
            return
              ("("
                     & "Md => "
                     & Trace_Image (R.Md)
                        & ", "
                     & "Rebindings => "
                     & Trace_Image (R.Rebindings)
                        & ", "
                     & "From_Rebound => "
                     & Trace_Image (R.From_Rebound)
               & ")");
      end Trace_Image;


   

   



      function Create_Internal_Entity
        (Node : Bare_Lkt_Node; Info : Internal_Entity_Info)
         return Internal_Entity is
      begin
         if Node = null then
            return No_Entity;
         end if;
         return (Node => Node, Info => Info);
      end;



   

      ----------
      -- Hash --
      ----------

      pragma Warnings (Off, "referenced");
      function Hash (R : Internal_Entity) return Hash_Type is
         pragma Warnings (On, "referenced");
      begin
         
            return Combine
              (Hash (R.Node), Hash (R.Info));
      end Hash;


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Decl
        (Node : Bare_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Decl is
      begin
         if Node = null then
            return No_Entity_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   

      ----------
      -- Hash --
      ----------

      pragma Warnings (Off, "referenced");
      function Hash (R : Internal_Entity_Decl) return Hash_Type is
         pragma Warnings (On, "referenced");
      begin
         
            return Combine
              (Hash (R.Node), Hash (R.Info));
      end Hash;


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   




   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Complete_Item) return String is
         pragma Warnings (On, "referenced");
      begin
            return
              ("("
                     & "Declaration => "
                     & Trace_Image (R.Declaration)
               & ")");
      end Trace_Image;


   

   


      -------------
      -- Inc_Ref --
      -------------

      procedure Inc_Ref (R : Internal_Decoded_Char_Value) is
      begin
               Inc_Ref (R.Error_Message);
      end Inc_Ref;

      -------------
      -- Dec_Ref --
      -------------

      procedure Dec_Ref (R : in out Internal_Decoded_Char_Value) is
      begin
               Dec_Ref (R.Error_Message);
      end Dec_Ref;




      ----------------
      -- Equivalent --
      ----------------

      function Equivalent (L, R : Internal_Decoded_Char_Value) return Boolean is
      begin
         return L.Value = R.Value and then L.Has_Error = R.Has_Error and then L.Error_Sloc = R.Error_Sloc and then Equivalent (L.Error_Message, R.Error_Message);
      end Equivalent;


   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Decoded_Char_Value) return String is
         pragma Warnings (On, "referenced");
      begin
            return
              ("("
                     & "Value => "
                     & Trace_Image (R.Value)
                        & ", "
                     & "Has_Error => "
                     & Trace_Image (R.Has_Error)
                        & ", "
                     & "Error_Sloc => "
                     & Trace_Image (R.Error_Sloc)
                        & ", "
                     & "Error_Message => "
                     & Trace_Image (R.Error_Message)
               & ")");
      end Trace_Image;


   

   


      -------------
      -- Inc_Ref --
      -------------

      procedure Inc_Ref (R : Internal_Decoded_String_Value) is
      begin
               Inc_Ref (R.Value);
               Inc_Ref (R.Error_Message);
      end Inc_Ref;

      -------------
      -- Dec_Ref --
      -------------

      procedure Dec_Ref (R : in out Internal_Decoded_String_Value) is
      begin
               Dec_Ref (R.Value);
               Dec_Ref (R.Error_Message);
      end Dec_Ref;




      ----------------
      -- Equivalent --
      ----------------

      function Equivalent (L, R : Internal_Decoded_String_Value) return Boolean is
      begin
         return Equivalent (L.Value, R.Value) and then L.Has_Error = R.Has_Error and then L.Error_Sloc = R.Error_Sloc and then Equivalent (L.Error_Message, R.Error_Message);
      end Equivalent;


   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Decoded_String_Value) return String is
         pragma Warnings (On, "referenced");
      begin
            return
              ("("
                     & "Value => "
                     & Trace_Image (R.Value)
                        & ", "
                     & "Has_Error => "
                     & Trace_Image (R.Has_Error)
                        & ", "
                     & "Error_Sloc => "
                     & Trace_Image (R.Error_Sloc)
                        & ", "
                     & "Error_Message => "
                     & Trace_Image (R.Error_Message)
               & ")");
      end Trace_Image;


   

   


      -------------
      -- Inc_Ref --
      -------------

      procedure Inc_Ref (R : Internal_Designated_Env) is
      begin
               Inc_Ref (R.Direct_Env);
      end Inc_Ref;

      -------------
      -- Dec_Ref --
      -------------

      procedure Dec_Ref (R : in out Internal_Designated_Env) is
      begin
               Dec_Ref (R.Direct_Env);
      end Dec_Ref;




      ----------------
      -- Equivalent --
      ----------------

      function Equivalent (L, R : Internal_Designated_Env) return Boolean is
      begin
         return L.Kind = R.Kind and then L.Env_Name = R.Env_Name and then Equivalent (L.Direct_Env, R.Direct_Env);
      end Equivalent;


   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Designated_Env) return String is
         pragma Warnings (On, "referenced");
      begin
            return
              ("("
                     & "Kind => "
                     & Trace_Image (R.Kind)
                        & ", "
                     & "Env_Name => "
                     & Trace_Image (R.Env_Name)
                        & ", "
                     & "Direct_Env => "
                     & Trace_Image (R.Direct_Env)
               & ")");
      end Trace_Image;


   

   



      function Create_Internal_Entity_Expr
        (Node : Bare_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Expr is
      begin
         if Node = null then
            return No_Entity_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Any_Of
        (Node : Bare_Any_Of; Info : Internal_Entity_Info)
         return Internal_Entity_Any_Of is
      begin
         if Node = null then
            return No_Entity_Any_Of;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Any_Of) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Lkt_Node_Base_List
        (Node : Bare_Lkt_Node_Base_List; Info : Internal_Entity_Info)
         return Internal_Entity_Lkt_Node_Base_List is
      begin
         if Node = null then
            return No_Entity_Lkt_Node_Base_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Lkt_Node_Base_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Expr_List
        (Node : Bare_Expr_List; Info : Internal_Entity_Info)
         return Internal_Entity_Expr_List is
      begin
         if Node = null then
            return No_Entity_Expr_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Expr_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Any_Of_List
        (Node : Bare_Any_Of_List; Info : Internal_Entity_Info)
         return Internal_Entity_Any_Of_List is
      begin
         if Node = null then
            return No_Entity_Any_Of_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Any_Of_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Type_Decl
        (Node : Bare_Type_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Type_Decl is
      begin
         if Node = null then
            return No_Entity_Type_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   

      ----------
      -- Hash --
      ----------

      pragma Warnings (Off, "referenced");
      function Hash (R : Internal_Entity_Type_Decl) return Hash_Type is
         pragma Warnings (On, "referenced");
      begin
         
            return Combine
              (Hash (R.Node), Hash (R.Info));
      end Hash;


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Type_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Any_Type_Decl
        (Node : Bare_Any_Type_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Any_Type_Decl is
      begin
         if Node = null then
            return No_Entity_Any_Type_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Any_Type_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Pattern
        (Node : Bare_Pattern; Info : Internal_Entity_Info)
         return Internal_Entity_Pattern is
      begin
         if Node = null then
            return No_Entity_Pattern;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Pattern) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Any_Type_Pattern
        (Node : Bare_Any_Type_Pattern; Info : Internal_Entity_Info)
         return Internal_Entity_Any_Type_Pattern is
      begin
         if Node = null then
            return No_Entity_Any_Type_Pattern;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Any_Type_Pattern) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Argument
        (Node : Bare_Argument; Info : Internal_Entity_Info)
         return Internal_Entity_Argument is
      begin
         if Node = null then
            return No_Entity_Argument;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Argument) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Argument_List
        (Node : Bare_Argument_List; Info : Internal_Entity_Info)
         return Internal_Entity_Argument_List is
      begin
         if Node = null then
            return No_Entity_Argument_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   

      ----------
      -- Hash --
      ----------

      pragma Warnings (Off, "referenced");
      function Hash (R : Internal_Entity_Argument_List) return Hash_Type is
         pragma Warnings (On, "referenced");
      begin
         
            return Combine
              (Hash (R.Node), Hash (R.Info));
      end Hash;


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Argument_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Array_Literal
        (Node : Bare_Array_Literal; Info : Internal_Entity_Info)
         return Internal_Entity_Array_Literal is
      begin
         if Node = null then
            return No_Entity_Array_Literal;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Array_Literal) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Base_Call_Expr
        (Node : Bare_Base_Call_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Base_Call_Expr is
      begin
         if Node = null then
            return No_Entity_Base_Call_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Base_Call_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Base_Grammar_Rule_Decl
        (Node : Bare_Base_Grammar_Rule_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Base_Grammar_Rule_Decl is
      begin
         if Node = null then
            return No_Entity_Base_Grammar_Rule_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Base_Grammar_Rule_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Base_Lexer_Case_Rule_Alt
        (Node : Bare_Base_Lexer_Case_Rule_Alt; Info : Internal_Entity_Info)
         return Internal_Entity_Base_Lexer_Case_Rule_Alt is
      begin
         if Node = null then
            return No_Entity_Base_Lexer_Case_Rule_Alt;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Base_Lexer_Case_Rule_Alt) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Base_Lexer_Case_Rule_Alt_List
        (Node : Bare_Base_Lexer_Case_Rule_Alt_List; Info : Internal_Entity_Info)
         return Internal_Entity_Base_Lexer_Case_Rule_Alt_List is
      begin
         if Node = null then
            return No_Entity_Base_Lexer_Case_Rule_Alt_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Base_Lexer_Case_Rule_Alt_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Base_Match_Branch
        (Node : Bare_Base_Match_Branch; Info : Internal_Entity_Info)
         return Internal_Entity_Base_Match_Branch is
      begin
         if Node = null then
            return No_Entity_Base_Match_Branch;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Base_Match_Branch) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Base_Match_Branch_List
        (Node : Bare_Base_Match_Branch_List; Info : Internal_Entity_Info)
         return Internal_Entity_Base_Match_Branch_List is
      begin
         if Node = null then
            return No_Entity_Base_Match_Branch_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Base_Match_Branch_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Base_Val_Decl
        (Node : Bare_Base_Val_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Base_Val_Decl is
      begin
         if Node = null then
            return No_Entity_Base_Val_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Base_Val_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Named_Type_Decl
        (Node : Bare_Named_Type_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Named_Type_Decl is
      begin
         if Node = null then
            return No_Entity_Named_Type_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Named_Type_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Basic_Class_Decl
        (Node : Bare_Basic_Class_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Basic_Class_Decl is
      begin
         if Node = null then
            return No_Entity_Basic_Class_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Basic_Class_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Lit
        (Node : Bare_Lit; Info : Internal_Entity_Info)
         return Internal_Entity_Lit is
      begin
         if Node = null then
            return No_Entity_Lit;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Lit) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Big_Num_Lit
        (Node : Bare_Big_Num_Lit; Info : Internal_Entity_Info)
         return Internal_Entity_Big_Num_Lit is
      begin
         if Node = null then
            return No_Entity_Big_Num_Lit;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Big_Num_Lit) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Bin_Op
        (Node : Bare_Bin_Op; Info : Internal_Entity_Info)
         return Internal_Entity_Bin_Op is
      begin
         if Node = null then
            return No_Entity_Bin_Op;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Bin_Op) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Binding_Pattern
        (Node : Bare_Binding_Pattern; Info : Internal_Entity_Info)
         return Internal_Entity_Binding_Pattern is
      begin
         if Node = null then
            return No_Entity_Binding_Pattern;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Binding_Pattern) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_User_Val_Decl
        (Node : Bare_User_Val_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_User_Val_Decl is
      begin
         if Node = null then
            return No_Entity_User_Val_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_User_Val_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Binding_Val_Decl
        (Node : Bare_Binding_Val_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Binding_Val_Decl is
      begin
         if Node = null then
            return No_Entity_Binding_Val_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Binding_Val_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Block_Expr
        (Node : Bare_Block_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Block_Expr is
      begin
         if Node = null then
            return No_Entity_Block_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Block_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Block_Expr_Clause
        (Node : Bare_Block_Expr_Clause; Info : Internal_Entity_Info)
         return Internal_Entity_Block_Expr_Clause is
      begin
         if Node = null then
            return No_Entity_Block_Expr_Clause;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Block_Expr_Clause) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Block_String_Line
        (Node : Bare_Block_String_Line; Info : Internal_Entity_Info)
         return Internal_Entity_Block_String_Line is
      begin
         if Node = null then
            return No_Entity_Block_String_Line;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Block_String_Line) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Block_String_Line_List
        (Node : Bare_Block_String_Line_List; Info : Internal_Entity_Info)
         return Internal_Entity_Block_String_Line_List is
      begin
         if Node = null then
            return No_Entity_Block_String_Line_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Block_String_Line_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_String_Lit
        (Node : Bare_String_Lit; Info : Internal_Entity_Info)
         return Internal_Entity_String_Lit is
      begin
         if Node = null then
            return No_Entity_String_Lit;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_String_Lit) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Block_String_Lit
        (Node : Bare_Block_String_Lit; Info : Internal_Entity_Info)
         return Internal_Entity_Block_String_Lit is
      begin
         if Node = null then
            return No_Entity_Block_String_Lit;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Block_String_Lit) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Bool_Pattern
        (Node : Bare_Bool_Pattern; Info : Internal_Entity_Info)
         return Internal_Entity_Bool_Pattern is
      begin
         if Node = null then
            return No_Entity_Bool_Pattern;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Bool_Pattern) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Bool_Pattern_False
        (Node : Bare_Bool_Pattern_False; Info : Internal_Entity_Info)
         return Internal_Entity_Bool_Pattern_False is
      begin
         if Node = null then
            return No_Entity_Bool_Pattern_False;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Bool_Pattern_False) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Bool_Pattern_True
        (Node : Bare_Bool_Pattern_True; Info : Internal_Entity_Info)
         return Internal_Entity_Bool_Pattern_True is
      begin
         if Node = null then
            return No_Entity_Bool_Pattern_True;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Bool_Pattern_True) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Call_Expr
        (Node : Bare_Call_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Call_Expr is
      begin
         if Node = null then
            return No_Entity_Call_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Call_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Call_Expr_List
        (Node : Bare_Call_Expr_List; Info : Internal_Entity_Info)
         return Internal_Entity_Call_Expr_List is
      begin
         if Node = null then
            return No_Entity_Call_Expr_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Call_Expr_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Cast_Expr
        (Node : Bare_Cast_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Cast_Expr is
      begin
         if Node = null then
            return No_Entity_Cast_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Cast_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Char_Lit
        (Node : Bare_Char_Lit; Info : Internal_Entity_Info)
         return Internal_Entity_Char_Lit is
      begin
         if Node = null then
            return No_Entity_Char_Lit;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Char_Lit) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Class_Decl
        (Node : Bare_Class_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Class_Decl is
      begin
         if Node = null then
            return No_Entity_Class_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Class_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Class_Qualifier
        (Node : Bare_Class_Qualifier; Info : Internal_Entity_Info)
         return Internal_Entity_Class_Qualifier is
      begin
         if Node = null then
            return No_Entity_Class_Qualifier;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Class_Qualifier) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Class_Qualifier_Absent
        (Node : Bare_Class_Qualifier_Absent; Info : Internal_Entity_Info)
         return Internal_Entity_Class_Qualifier_Absent is
      begin
         if Node = null then
            return No_Entity_Class_Qualifier_Absent;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Class_Qualifier_Absent) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Class_Qualifier_Present
        (Node : Bare_Class_Qualifier_Present; Info : Internal_Entity_Info)
         return Internal_Entity_Class_Qualifier_Present is
      begin
         if Node = null then
            return No_Entity_Class_Qualifier_Present;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Class_Qualifier_Present) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Explicitly_Typed_Decl
        (Node : Bare_Explicitly_Typed_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Explicitly_Typed_Decl is
      begin
         if Node = null then
            return No_Entity_Explicitly_Typed_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Explicitly_Typed_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Component_Decl
        (Node : Bare_Component_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Component_Decl is
      begin
         if Node = null then
            return No_Entity_Component_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Component_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Decl_Annotation
        (Node : Bare_Decl_Annotation; Info : Internal_Entity_Info)
         return Internal_Entity_Decl_Annotation is
      begin
         if Node = null then
            return No_Entity_Decl_Annotation;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Decl_Annotation) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Decl_Annotation_Args
        (Node : Bare_Decl_Annotation_Args; Info : Internal_Entity_Info)
         return Internal_Entity_Decl_Annotation_Args is
      begin
         if Node = null then
            return No_Entity_Decl_Annotation_Args;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Decl_Annotation_Args) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Decl_Annotation_List
        (Node : Bare_Decl_Annotation_List; Info : Internal_Entity_Info)
         return Internal_Entity_Decl_Annotation_List is
      begin
         if Node = null then
            return No_Entity_Decl_Annotation_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Decl_Annotation_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Full_Decl_List
        (Node : Bare_Full_Decl_List; Info : Internal_Entity_Info)
         return Internal_Entity_Full_Decl_List is
      begin
         if Node = null then
            return No_Entity_Full_Decl_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Full_Decl_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Decl_Block
        (Node : Bare_Decl_Block; Info : Internal_Entity_Info)
         return Internal_Entity_Decl_Block is
      begin
         if Node = null then
            return No_Entity_Decl_Block;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Decl_Block) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Id
        (Node : Bare_Id; Info : Internal_Entity_Info)
         return Internal_Entity_Id is
      begin
         if Node = null then
            return No_Entity_Id;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Id) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Def_Id
        (Node : Bare_Def_Id; Info : Internal_Entity_Info)
         return Internal_Entity_Def_Id is
      begin
         if Node = null then
            return No_Entity_Def_Id;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Def_Id) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Type_Ref
        (Node : Bare_Type_Ref; Info : Internal_Entity_Info)
         return Internal_Entity_Type_Ref is
      begin
         if Node = null then
            return No_Entity_Type_Ref;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Type_Ref) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Default_List_Type_Ref
        (Node : Bare_Default_List_Type_Ref; Info : Internal_Entity_Info)
         return Internal_Entity_Default_List_Type_Ref is
      begin
         if Node = null then
            return No_Entity_Default_List_Type_Ref;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Default_List_Type_Ref) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Dot_Expr
        (Node : Bare_Dot_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Dot_Expr is
      begin
         if Node = null then
            return No_Entity_Dot_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Dot_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Dyn_Env_Wrapper
        (Node : Bare_Dyn_Env_Wrapper; Info : Internal_Entity_Info)
         return Internal_Entity_Dyn_Env_Wrapper is
      begin
         if Node = null then
            return No_Entity_Dyn_Env_Wrapper;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Dyn_Env_Wrapper) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Dyn_Var_Decl
        (Node : Bare_Dyn_Var_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Dyn_Var_Decl is
      begin
         if Node = null then
            return No_Entity_Dyn_Var_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Dyn_Var_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Ellipsis_Pattern
        (Node : Bare_Ellipsis_Pattern; Info : Internal_Entity_Info)
         return Internal_Entity_Ellipsis_Pattern is
      begin
         if Node = null then
            return No_Entity_Ellipsis_Pattern;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Ellipsis_Pattern) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Elsif_Branch
        (Node : Bare_Elsif_Branch; Info : Internal_Entity_Info)
         return Internal_Entity_Elsif_Branch is
      begin
         if Node = null then
            return No_Entity_Elsif_Branch;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Elsif_Branch) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Elsif_Branch_List
        (Node : Bare_Elsif_Branch_List; Info : Internal_Entity_Info)
         return Internal_Entity_Elsif_Branch_List is
      begin
         if Node = null then
            return No_Entity_Elsif_Branch_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Elsif_Branch_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Enum_Class_Alt_Decl
        (Node : Bare_Enum_Class_Alt_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Enum_Class_Alt_Decl is
      begin
         if Node = null then
            return No_Entity_Enum_Class_Alt_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Enum_Class_Alt_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Enum_Class_Alt_Decl_List
        (Node : Bare_Enum_Class_Alt_Decl_List; Info : Internal_Entity_Info)
         return Internal_Entity_Enum_Class_Alt_Decl_List is
      begin
         if Node = null then
            return No_Entity_Enum_Class_Alt_Decl_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Enum_Class_Alt_Decl_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Enum_Class_Case
        (Node : Bare_Enum_Class_Case; Info : Internal_Entity_Info)
         return Internal_Entity_Enum_Class_Case is
      begin
         if Node = null then
            return No_Entity_Enum_Class_Case;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Enum_Class_Case) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Enum_Class_Case_List
        (Node : Bare_Enum_Class_Case_List; Info : Internal_Entity_Info)
         return Internal_Entity_Enum_Class_Case_List is
      begin
         if Node = null then
            return No_Entity_Enum_Class_Case_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Enum_Class_Case_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Enum_Class_Decl
        (Node : Bare_Enum_Class_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Enum_Class_Decl is
      begin
         if Node = null then
            return No_Entity_Enum_Class_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Enum_Class_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Enum_Lit_Decl
        (Node : Bare_Enum_Lit_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Enum_Lit_Decl is
      begin
         if Node = null then
            return No_Entity_Enum_Lit_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Enum_Lit_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Enum_Lit_Decl_List
        (Node : Bare_Enum_Lit_Decl_List; Info : Internal_Entity_Info)
         return Internal_Entity_Enum_Lit_Decl_List is
      begin
         if Node = null then
            return No_Entity_Enum_Lit_Decl_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Enum_Lit_Decl_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Enum_Type_Decl
        (Node : Bare_Enum_Type_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Enum_Type_Decl is
      begin
         if Node = null then
            return No_Entity_Enum_Type_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Enum_Type_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Env_Spec_Decl
        (Node : Bare_Env_Spec_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Env_Spec_Decl is
      begin
         if Node = null then
            return No_Entity_Env_Spec_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Env_Spec_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Error_Decl
        (Node : Bare_Error_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Error_Decl is
      begin
         if Node = null then
            return No_Entity_Error_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Error_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Expr
        (Node : Bare_Grammar_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Expr is
      begin
         if Node = null then
            return No_Entity_Grammar_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Error_Grammar_Expr
        (Node : Bare_Error_Grammar_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Error_Grammar_Expr is
      begin
         if Node = null then
            return No_Entity_Error_Grammar_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Error_Grammar_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Error_Lexer_Case_Rule_Alt
        (Node : Bare_Error_Lexer_Case_Rule_Alt; Info : Internal_Entity_Info)
         return Internal_Entity_Error_Lexer_Case_Rule_Alt is
      begin
         if Node = null then
            return No_Entity_Error_Lexer_Case_Rule_Alt;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Error_Lexer_Case_Rule_Alt) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Error_On_Null
        (Node : Bare_Error_On_Null; Info : Internal_Entity_Info)
         return Internal_Entity_Error_On_Null is
      begin
         if Node = null then
            return No_Entity_Error_On_Null;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Error_On_Null) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Excludes_Null
        (Node : Bare_Excludes_Null; Info : Internal_Entity_Info)
         return Internal_Entity_Excludes_Null is
      begin
         if Node = null then
            return No_Entity_Excludes_Null;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Excludes_Null) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Excludes_Null_Absent
        (Node : Bare_Excludes_Null_Absent; Info : Internal_Entity_Info)
         return Internal_Entity_Excludes_Null_Absent is
      begin
         if Node = null then
            return No_Entity_Excludes_Null_Absent;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Excludes_Null_Absent) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Excludes_Null_Present
        (Node : Bare_Excludes_Null_Present; Info : Internal_Entity_Info)
         return Internal_Entity_Excludes_Null_Present is
      begin
         if Node = null then
            return No_Entity_Excludes_Null_Present;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Excludes_Null_Present) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Extended_Pattern
        (Node : Bare_Extended_Pattern; Info : Internal_Entity_Info)
         return Internal_Entity_Extended_Pattern is
      begin
         if Node = null then
            return No_Entity_Extended_Pattern;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Extended_Pattern) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Field_Decl
        (Node : Bare_Field_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Field_Decl is
      begin
         if Node = null then
            return No_Entity_Field_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Field_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Pattern_Detail
        (Node : Bare_Pattern_Detail; Info : Internal_Entity_Info)
         return Internal_Entity_Pattern_Detail is
      begin
         if Node = null then
            return No_Entity_Pattern_Detail;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Pattern_Detail) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Field_Pattern_Detail
        (Node : Bare_Field_Pattern_Detail; Info : Internal_Entity_Info)
         return Internal_Entity_Field_Pattern_Detail is
      begin
         if Node = null then
            return No_Entity_Field_Pattern_Detail;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Field_Pattern_Detail) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Filtered_Pattern
        (Node : Bare_Filtered_Pattern; Info : Internal_Entity_Info)
         return Internal_Entity_Filtered_Pattern is
      begin
         if Node = null then
            return No_Entity_Filtered_Pattern;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Filtered_Pattern) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Full_Decl
        (Node : Bare_Full_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Full_Decl is
      begin
         if Node = null then
            return No_Entity_Full_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Full_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Fun_Decl
        (Node : Bare_Fun_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Fun_Decl is
      begin
         if Node = null then
            return No_Entity_Fun_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Fun_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Fun_Param_Decl
        (Node : Bare_Fun_Param_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Fun_Param_Decl is
      begin
         if Node = null then
            return No_Entity_Fun_Param_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Fun_Param_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Fun_Param_Decl_List
        (Node : Bare_Fun_Param_Decl_List; Info : Internal_Entity_Info)
         return Internal_Entity_Fun_Param_Decl_List is
      begin
         if Node = null then
            return No_Entity_Fun_Param_Decl_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Fun_Param_Decl_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Function_Type
        (Node : Bare_Function_Type; Info : Internal_Entity_Info)
         return Internal_Entity_Function_Type is
      begin
         if Node = null then
            return No_Entity_Function_Type;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Function_Type) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Function_Type_Ref
        (Node : Bare_Function_Type_Ref; Info : Internal_Entity_Info)
         return Internal_Entity_Function_Type_Ref is
      begin
         if Node = null then
            return No_Entity_Function_Type_Ref;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Function_Type_Ref) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Generic_Decl
        (Node : Bare_Generic_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Generic_Decl is
      begin
         if Node = null then
            return No_Entity_Generic_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Generic_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Generic_Instantiation
        (Node : Bare_Generic_Instantiation; Info : Internal_Entity_Info)
         return Internal_Entity_Generic_Instantiation is
      begin
         if Node = null then
            return No_Entity_Generic_Instantiation;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Generic_Instantiation) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Generic_Param_Decl_List
        (Node : Bare_Generic_Param_Decl_List; Info : Internal_Entity_Info)
         return Internal_Entity_Generic_Param_Decl_List is
      begin
         if Node = null then
            return No_Entity_Generic_Param_Decl_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Generic_Param_Decl_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Generic_Param_Type_Decl
        (Node : Bare_Generic_Param_Type_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Generic_Param_Type_Decl is
      begin
         if Node = null then
            return No_Entity_Generic_Param_Type_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Generic_Param_Type_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Generic_Type_Ref
        (Node : Bare_Generic_Type_Ref; Info : Internal_Entity_Info)
         return Internal_Entity_Generic_Type_Ref is
      begin
         if Node = null then
            return No_Entity_Generic_Type_Ref;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Generic_Type_Ref) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Cut
        (Node : Bare_Grammar_Cut; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Cut is
      begin
         if Node = null then
            return No_Entity_Grammar_Cut;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Cut) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Decl
        (Node : Bare_Grammar_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Decl is
      begin
         if Node = null then
            return No_Entity_Grammar_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Discard
        (Node : Bare_Grammar_Discard; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Discard is
      begin
         if Node = null then
            return No_Entity_Grammar_Discard;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Discard) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Dont_Skip
        (Node : Bare_Grammar_Dont_Skip; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Dont_Skip is
      begin
         if Node = null then
            return No_Entity_Grammar_Dont_Skip;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Dont_Skip) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Expr_List
        (Node : Bare_Grammar_Expr_List; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Expr_List is
      begin
         if Node = null then
            return No_Entity_Grammar_Expr_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Expr_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Expr_List_List
        (Node : Bare_Grammar_Expr_List_List; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Expr_List_List is
      begin
         if Node = null then
            return No_Entity_Grammar_Expr_List_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Expr_List_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Pick
        (Node : Bare_Grammar_Pick; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Pick is
      begin
         if Node = null then
            return No_Entity_Grammar_Pick;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Pick) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Implicit_Pick
        (Node : Bare_Grammar_Implicit_Pick; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Implicit_Pick is
      begin
         if Node = null then
            return No_Entity_Grammar_Implicit_Pick;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Implicit_Pick) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_List
        (Node : Bare_Grammar_List; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_List is
      begin
         if Node = null then
            return No_Entity_Grammar_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_List_Sep
        (Node : Bare_Grammar_List_Sep; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_List_Sep is
      begin
         if Node = null then
            return No_Entity_Grammar_List_Sep;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_List_Sep) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Null
        (Node : Bare_Grammar_Null; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Null is
      begin
         if Node = null then
            return No_Entity_Grammar_Null;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Null) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Opt
        (Node : Bare_Grammar_Opt; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Opt is
      begin
         if Node = null then
            return No_Entity_Grammar_Opt;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Opt) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Opt_Error
        (Node : Bare_Grammar_Opt_Error; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Opt_Error is
      begin
         if Node = null then
            return No_Entity_Grammar_Opt_Error;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Opt_Error) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Opt_Error_Group
        (Node : Bare_Grammar_Opt_Error_Group; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Opt_Error_Group is
      begin
         if Node = null then
            return No_Entity_Grammar_Opt_Error_Group;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Opt_Error_Group) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Opt_Group
        (Node : Bare_Grammar_Opt_Group; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Opt_Group is
      begin
         if Node = null then
            return No_Entity_Grammar_Opt_Group;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Opt_Group) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Or_Expr
        (Node : Bare_Grammar_Or_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Or_Expr is
      begin
         if Node = null then
            return No_Entity_Grammar_Or_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Or_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Predicate
        (Node : Bare_Grammar_Predicate; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Predicate is
      begin
         if Node = null then
            return No_Entity_Grammar_Predicate;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Predicate) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Rule_Decl
        (Node : Bare_Grammar_Rule_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Rule_Decl is
      begin
         if Node = null then
            return No_Entity_Grammar_Rule_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Rule_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Rule_Ref
        (Node : Bare_Grammar_Rule_Ref; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Rule_Ref is
      begin
         if Node = null then
            return No_Entity_Grammar_Rule_Ref;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Rule_Ref) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Skip
        (Node : Bare_Grammar_Skip; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Skip is
      begin
         if Node = null then
            return No_Entity_Grammar_Skip;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Skip) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Grammar_Stop_Cut
        (Node : Bare_Grammar_Stop_Cut; Info : Internal_Entity_Info)
         return Internal_Entity_Grammar_Stop_Cut is
      begin
         if Node = null then
            return No_Entity_Grammar_Stop_Cut;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Grammar_Stop_Cut) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_If_Expr
        (Node : Bare_If_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_If_Expr is
      begin
         if Node = null then
            return No_Entity_If_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_If_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Import
        (Node : Bare_Import; Info : Internal_Entity_Info)
         return Internal_Entity_Import is
      begin
         if Node = null then
            return No_Entity_Import;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Import) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Import_List
        (Node : Bare_Import_List; Info : Internal_Entity_Info)
         return Internal_Entity_Import_List is
      begin
         if Node = null then
            return No_Entity_Import_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Import_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Integer_Pattern
        (Node : Bare_Integer_Pattern; Info : Internal_Entity_Info)
         return Internal_Entity_Integer_Pattern is
      begin
         if Node = null then
            return No_Entity_Integer_Pattern;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Integer_Pattern) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Isa
        (Node : Bare_Isa; Info : Internal_Entity_Info)
         return Internal_Entity_Isa is
      begin
         if Node = null then
            return No_Entity_Isa;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Isa) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Keep_Expr
        (Node : Bare_Keep_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Keep_Expr is
      begin
         if Node = null then
            return No_Entity_Keep_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Keep_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Lambda_Expr
        (Node : Bare_Lambda_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Lambda_Expr is
      begin
         if Node = null then
            return No_Entity_Lambda_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Lambda_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Lambda_Param_Decl
        (Node : Bare_Lambda_Param_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Lambda_Param_Decl is
      begin
         if Node = null then
            return No_Entity_Lambda_Param_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Lambda_Param_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Lambda_Param_Decl_List
        (Node : Bare_Lambda_Param_Decl_List; Info : Internal_Entity_Info)
         return Internal_Entity_Lambda_Param_Decl_List is
      begin
         if Node = null then
            return No_Entity_Lambda_Param_Decl_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Lambda_Param_Decl_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Langkit_Root
        (Node : Bare_Langkit_Root; Info : Internal_Entity_Info)
         return Internal_Entity_Langkit_Root is
      begin
         if Node = null then
            return No_Entity_Langkit_Root;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Langkit_Root) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Lexer_Case_Rule
        (Node : Bare_Lexer_Case_Rule; Info : Internal_Entity_Info)
         return Internal_Entity_Lexer_Case_Rule is
      begin
         if Node = null then
            return No_Entity_Lexer_Case_Rule;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Lexer_Case_Rule) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Lexer_Case_Rule_Cond_Alt
        (Node : Bare_Lexer_Case_Rule_Cond_Alt; Info : Internal_Entity_Info)
         return Internal_Entity_Lexer_Case_Rule_Cond_Alt is
      begin
         if Node = null then
            return No_Entity_Lexer_Case_Rule_Cond_Alt;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Lexer_Case_Rule_Cond_Alt) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Lexer_Case_Rule_Default_Alt
        (Node : Bare_Lexer_Case_Rule_Default_Alt; Info : Internal_Entity_Info)
         return Internal_Entity_Lexer_Case_Rule_Default_Alt is
      begin
         if Node = null then
            return No_Entity_Lexer_Case_Rule_Default_Alt;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Lexer_Case_Rule_Default_Alt) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Lexer_Case_Rule_Send
        (Node : Bare_Lexer_Case_Rule_Send; Info : Internal_Entity_Info)
         return Internal_Entity_Lexer_Case_Rule_Send is
      begin
         if Node = null then
            return No_Entity_Lexer_Case_Rule_Send;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Lexer_Case_Rule_Send) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Lexer_Decl
        (Node : Bare_Lexer_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Lexer_Decl is
      begin
         if Node = null then
            return No_Entity_Lexer_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Lexer_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Lexer_Family_Decl
        (Node : Bare_Lexer_Family_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Lexer_Family_Decl is
      begin
         if Node = null then
            return No_Entity_Lexer_Family_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Lexer_Family_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_List_Kind
        (Node : Bare_List_Kind; Info : Internal_Entity_Info)
         return Internal_Entity_List_Kind is
      begin
         if Node = null then
            return No_Entity_List_Kind;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_List_Kind) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_List_Kind_One
        (Node : Bare_List_Kind_One; Info : Internal_Entity_Info)
         return Internal_Entity_List_Kind_One is
      begin
         if Node = null then
            return No_Entity_List_Kind_One;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_List_Kind_One) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_List_Kind_Zero
        (Node : Bare_List_Kind_Zero; Info : Internal_Entity_Info)
         return Internal_Entity_List_Kind_Zero is
      begin
         if Node = null then
            return No_Entity_List_Kind_Zero;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_List_Kind_Zero) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_List_Pattern
        (Node : Bare_List_Pattern; Info : Internal_Entity_Info)
         return Internal_Entity_List_Pattern is
      begin
         if Node = null then
            return No_Entity_List_Pattern;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_List_Pattern) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Lkt_Node_List
        (Node : Bare_Lkt_Node_List; Info : Internal_Entity_Info)
         return Internal_Entity_Lkt_Node_List is
      begin
         if Node = null then
            return No_Entity_Lkt_Node_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Lkt_Node_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Logic_Assign
        (Node : Bare_Logic_Assign; Info : Internal_Entity_Info)
         return Internal_Entity_Logic_Assign is
      begin
         if Node = null then
            return No_Entity_Logic_Assign;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Logic_Assign) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Logic_Call_Expr
        (Node : Bare_Logic_Call_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Logic_Call_Expr is
      begin
         if Node = null then
            return No_Entity_Logic_Call_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Logic_Call_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Logic_Expr
        (Node : Bare_Logic_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Logic_Expr is
      begin
         if Node = null then
            return No_Entity_Logic_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Logic_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Logic_Predicate
        (Node : Bare_Logic_Predicate; Info : Internal_Entity_Info)
         return Internal_Entity_Logic_Predicate is
      begin
         if Node = null then
            return No_Entity_Logic_Predicate;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Logic_Predicate) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Logic_Propagate
        (Node : Bare_Logic_Propagate; Info : Internal_Entity_Info)
         return Internal_Entity_Logic_Propagate is
      begin
         if Node = null then
            return No_Entity_Logic_Propagate;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Logic_Propagate) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Logic_Propagate_Call
        (Node : Bare_Logic_Propagate_Call; Info : Internal_Entity_Info)
         return Internal_Entity_Logic_Propagate_Call is
      begin
         if Node = null then
            return No_Entity_Logic_Propagate_Call;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Logic_Propagate_Call) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Logic_Unify
        (Node : Bare_Logic_Unify; Info : Internal_Entity_Info)
         return Internal_Entity_Logic_Unify is
      begin
         if Node = null then
            return No_Entity_Logic_Unify;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Logic_Unify) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Match_Branch
        (Node : Bare_Match_Branch; Info : Internal_Entity_Info)
         return Internal_Entity_Match_Branch is
      begin
         if Node = null then
            return No_Entity_Match_Branch;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Match_Branch) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Match_Expr
        (Node : Bare_Match_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Match_Expr is
      begin
         if Node = null then
            return No_Entity_Match_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Match_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Match_Val_Decl
        (Node : Bare_Match_Val_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Match_Val_Decl is
      begin
         if Node = null then
            return No_Entity_Match_Val_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Match_Val_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Module_Doc_String_Line
        (Node : Bare_Module_Doc_String_Line; Info : Internal_Entity_Info)
         return Internal_Entity_Module_Doc_String_Line is
      begin
         if Node = null then
            return No_Entity_Module_Doc_String_Line;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Module_Doc_String_Line) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Module_Doc_String_Line_List
        (Node : Bare_Module_Doc_String_Line_List; Info : Internal_Entity_Info)
         return Internal_Entity_Module_Doc_String_Line_List is
      begin
         if Node = null then
            return No_Entity_Module_Doc_String_Line_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Module_Doc_String_Line_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Module_Doc_String_Lit
        (Node : Bare_Module_Doc_String_Lit; Info : Internal_Entity_Info)
         return Internal_Entity_Module_Doc_String_Lit is
      begin
         if Node = null then
            return No_Entity_Module_Doc_String_Lit;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Module_Doc_String_Lit) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Module_Ref_Id
        (Node : Bare_Module_Ref_Id; Info : Internal_Entity_Info)
         return Internal_Entity_Module_Ref_Id is
      begin
         if Node = null then
            return No_Entity_Module_Ref_Id;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Module_Ref_Id) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Node_Decl
        (Node : Bare_Node_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Node_Decl is
      begin
         if Node = null then
            return No_Entity_Node_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Node_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Not_Expr
        (Node : Bare_Not_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Not_Expr is
      begin
         if Node = null then
            return No_Entity_Not_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Not_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Not_Pattern
        (Node : Bare_Not_Pattern; Info : Internal_Entity_Info)
         return Internal_Entity_Not_Pattern is
      begin
         if Node = null then
            return No_Entity_Not_Pattern;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Not_Pattern) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Null_Cond_Qualifier
        (Node : Bare_Null_Cond_Qualifier; Info : Internal_Entity_Info)
         return Internal_Entity_Null_Cond_Qualifier is
      begin
         if Node = null then
            return No_Entity_Null_Cond_Qualifier;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Null_Cond_Qualifier) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Null_Cond_Qualifier_Absent
        (Node : Bare_Null_Cond_Qualifier_Absent; Info : Internal_Entity_Info)
         return Internal_Entity_Null_Cond_Qualifier_Absent is
      begin
         if Node = null then
            return No_Entity_Null_Cond_Qualifier_Absent;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Null_Cond_Qualifier_Absent) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Null_Cond_Qualifier_Present
        (Node : Bare_Null_Cond_Qualifier_Present; Info : Internal_Entity_Info)
         return Internal_Entity_Null_Cond_Qualifier_Present is
      begin
         if Node = null then
            return No_Entity_Null_Cond_Qualifier_Present;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Null_Cond_Qualifier_Present) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Null_Lit
        (Node : Bare_Null_Lit; Info : Internal_Entity_Info)
         return Internal_Entity_Null_Lit is
      begin
         if Node = null then
            return No_Entity_Null_Lit;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Null_Lit) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Null_Pattern
        (Node : Bare_Null_Pattern; Info : Internal_Entity_Info)
         return Internal_Entity_Null_Pattern is
      begin
         if Node = null then
            return No_Entity_Null_Pattern;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Null_Pattern) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Num_Lit
        (Node : Bare_Num_Lit; Info : Internal_Entity_Info)
         return Internal_Entity_Num_Lit is
      begin
         if Node = null then
            return No_Entity_Num_Lit;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Num_Lit) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op
        (Node : Bare_Op; Info : Internal_Entity_Info)
         return Internal_Entity_Op is
      begin
         if Node = null then
            return No_Entity_Op;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op_Amp
        (Node : Bare_Op_Amp; Info : Internal_Entity_Info)
         return Internal_Entity_Op_Amp is
      begin
         if Node = null then
            return No_Entity_Op_Amp;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op_Amp) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op_And
        (Node : Bare_Op_And; Info : Internal_Entity_Info)
         return Internal_Entity_Op_And is
      begin
         if Node = null then
            return No_Entity_Op_And;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op_And) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op_Div
        (Node : Bare_Op_Div; Info : Internal_Entity_Info)
         return Internal_Entity_Op_Div is
      begin
         if Node = null then
            return No_Entity_Op_Div;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op_Div) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op_Eq
        (Node : Bare_Op_Eq; Info : Internal_Entity_Info)
         return Internal_Entity_Op_Eq is
      begin
         if Node = null then
            return No_Entity_Op_Eq;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op_Eq) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op_Gt
        (Node : Bare_Op_Gt; Info : Internal_Entity_Info)
         return Internal_Entity_Op_Gt is
      begin
         if Node = null then
            return No_Entity_Op_Gt;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op_Gt) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op_Gte
        (Node : Bare_Op_Gte; Info : Internal_Entity_Info)
         return Internal_Entity_Op_Gte is
      begin
         if Node = null then
            return No_Entity_Op_Gte;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op_Gte) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op_Logic_And
        (Node : Bare_Op_Logic_And; Info : Internal_Entity_Info)
         return Internal_Entity_Op_Logic_And is
      begin
         if Node = null then
            return No_Entity_Op_Logic_And;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op_Logic_And) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op_Logic_Or
        (Node : Bare_Op_Logic_Or; Info : Internal_Entity_Info)
         return Internal_Entity_Op_Logic_Or is
      begin
         if Node = null then
            return No_Entity_Op_Logic_Or;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op_Logic_Or) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op_Lt
        (Node : Bare_Op_Lt; Info : Internal_Entity_Info)
         return Internal_Entity_Op_Lt is
      begin
         if Node = null then
            return No_Entity_Op_Lt;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op_Lt) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op_Lte
        (Node : Bare_Op_Lte; Info : Internal_Entity_Info)
         return Internal_Entity_Op_Lte is
      begin
         if Node = null then
            return No_Entity_Op_Lte;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op_Lte) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op_Minus
        (Node : Bare_Op_Minus; Info : Internal_Entity_Info)
         return Internal_Entity_Op_Minus is
      begin
         if Node = null then
            return No_Entity_Op_Minus;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op_Minus) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op_Mult
        (Node : Bare_Op_Mult; Info : Internal_Entity_Info)
         return Internal_Entity_Op_Mult is
      begin
         if Node = null then
            return No_Entity_Op_Mult;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op_Mult) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op_Ne
        (Node : Bare_Op_Ne; Info : Internal_Entity_Info)
         return Internal_Entity_Op_Ne is
      begin
         if Node = null then
            return No_Entity_Op_Ne;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op_Ne) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op_Or
        (Node : Bare_Op_Or; Info : Internal_Entity_Info)
         return Internal_Entity_Op_Or is
      begin
         if Node = null then
            return No_Entity_Op_Or;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op_Or) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op_Or_Int
        (Node : Bare_Op_Or_Int; Info : Internal_Entity_Info)
         return Internal_Entity_Op_Or_Int is
      begin
         if Node = null then
            return No_Entity_Op_Or_Int;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op_Or_Int) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op_Plus
        (Node : Bare_Op_Plus; Info : Internal_Entity_Info)
         return Internal_Entity_Op_Plus is
      begin
         if Node = null then
            return No_Entity_Op_Plus;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op_Plus) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op_Stream_Concat
        (Node : Bare_Op_Stream_Concat; Info : Internal_Entity_Info)
         return Internal_Entity_Op_Stream_Concat is
      begin
         if Node = null then
            return No_Entity_Op_Stream_Concat;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op_Stream_Concat) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Op_Stream_Cons
        (Node : Bare_Op_Stream_Cons; Info : Internal_Entity_Info)
         return Internal_Entity_Op_Stream_Cons is
      begin
         if Node = null then
            return No_Entity_Op_Stream_Cons;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Op_Stream_Cons) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Or_Pattern
        (Node : Bare_Or_Pattern; Info : Internal_Entity_Info)
         return Internal_Entity_Or_Pattern is
      begin
         if Node = null then
            return No_Entity_Or_Pattern;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Or_Pattern) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Paren_Expr
        (Node : Bare_Paren_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Paren_Expr is
      begin
         if Node = null then
            return No_Entity_Paren_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Paren_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Paren_Pattern
        (Node : Bare_Paren_Pattern; Info : Internal_Entity_Info)
         return Internal_Entity_Paren_Pattern is
      begin
         if Node = null then
            return No_Entity_Paren_Pattern;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Paren_Pattern) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Parse_Node_Expr
        (Node : Bare_Parse_Node_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Parse_Node_Expr is
      begin
         if Node = null then
            return No_Entity_Parse_Node_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Parse_Node_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Pattern_Detail_List
        (Node : Bare_Pattern_Detail_List; Info : Internal_Entity_Info)
         return Internal_Entity_Pattern_Detail_List is
      begin
         if Node = null then
            return No_Entity_Pattern_Detail_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Pattern_Detail_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Pattern_List
        (Node : Bare_Pattern_List; Info : Internal_Entity_Info)
         return Internal_Entity_Pattern_List is
      begin
         if Node = null then
            return No_Entity_Pattern_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Pattern_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Pattern_Match_Branch
        (Node : Bare_Pattern_Match_Branch; Info : Internal_Entity_Info)
         return Internal_Entity_Pattern_Match_Branch is
      begin
         if Node = null then
            return No_Entity_Pattern_Match_Branch;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Pattern_Match_Branch) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Single_Line_String_Lit
        (Node : Bare_Single_Line_String_Lit; Info : Internal_Entity_Info)
         return Internal_Entity_Single_Line_String_Lit is
      begin
         if Node = null then
            return No_Entity_Single_Line_String_Lit;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Single_Line_String_Lit) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Pattern_Single_Line_String_Lit
        (Node : Bare_Pattern_Single_Line_String_Lit; Info : Internal_Entity_Info)
         return Internal_Entity_Pattern_Single_Line_String_Lit is
      begin
         if Node = null then
            return No_Entity_Pattern_Single_Line_String_Lit;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Pattern_Single_Line_String_Lit) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Property_Pattern_Detail
        (Node : Bare_Property_Pattern_Detail; Info : Internal_Entity_Info)
         return Internal_Entity_Property_Pattern_Detail is
      begin
         if Node = null then
            return No_Entity_Property_Pattern_Detail;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Property_Pattern_Detail) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Query
        (Node : Bare_Query; Info : Internal_Entity_Info)
         return Internal_Entity_Query is
      begin
         if Node = null then
            return No_Entity_Query;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Query) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Raise_Expr
        (Node : Bare_Raise_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Raise_Expr is
      begin
         if Node = null then
            return No_Entity_Raise_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Raise_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Ref_Id
        (Node : Bare_Ref_Id; Info : Internal_Entity_Info)
         return Internal_Entity_Ref_Id is
      begin
         if Node = null then
            return No_Entity_Ref_Id;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Ref_Id) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Ref_Id_List
        (Node : Bare_Ref_Id_List; Info : Internal_Entity_Info)
         return Internal_Entity_Ref_Id_List is
      begin
         if Node = null then
            return No_Entity_Ref_Id_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Ref_Id_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Regex_Pattern
        (Node : Bare_Regex_Pattern; Info : Internal_Entity_Info)
         return Internal_Entity_Regex_Pattern is
      begin
         if Node = null then
            return No_Entity_Regex_Pattern;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Regex_Pattern) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Selector_Call
        (Node : Bare_Selector_Call; Info : Internal_Entity_Info)
         return Internal_Entity_Selector_Call is
      begin
         if Node = null then
            return No_Entity_Selector_Call;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Selector_Call) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Selector_Pattern_Detail
        (Node : Bare_Selector_Pattern_Detail; Info : Internal_Entity_Info)
         return Internal_Entity_Selector_Pattern_Detail is
      begin
         if Node = null then
            return No_Entity_Selector_Pattern_Detail;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Selector_Pattern_Detail) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Self_Decl
        (Node : Bare_Self_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Self_Decl is
      begin
         if Node = null then
            return No_Entity_Self_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Self_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Simple_Type_Ref
        (Node : Bare_Simple_Type_Ref; Info : Internal_Entity_Info)
         return Internal_Entity_Simple_Type_Ref is
      begin
         if Node = null then
            return No_Entity_Simple_Type_Ref;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Simple_Type_Ref) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Struct_Decl
        (Node : Bare_Struct_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Struct_Decl is
      begin
         if Node = null then
            return No_Entity_Struct_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Struct_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Subscript_Expr
        (Node : Bare_Subscript_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Subscript_Expr is
      begin
         if Node = null then
            return No_Entity_Subscript_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Subscript_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Synth_Fun_Decl
        (Node : Bare_Synth_Fun_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Synth_Fun_Decl is
      begin
         if Node = null then
            return No_Entity_Synth_Fun_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Synth_Fun_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Synth_Param_Decl
        (Node : Bare_Synth_Param_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Synth_Param_Decl is
      begin
         if Node = null then
            return No_Entity_Synth_Param_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Synth_Param_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Synthetic_Lexer_Decl
        (Node : Bare_Synthetic_Lexer_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Synthetic_Lexer_Decl is
      begin
         if Node = null then
            return No_Entity_Synthetic_Lexer_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Synthetic_Lexer_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Type_Ref_List
        (Node : Bare_Type_Ref_List; Info : Internal_Entity_Info)
         return Internal_Entity_Type_Ref_List is
      begin
         if Node = null then
            return No_Entity_Type_Ref_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Type_Ref_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Synthetic_Type_Ref_List
        (Node : Bare_Synthetic_Type_Ref_List; Info : Internal_Entity_Info)
         return Internal_Entity_Synthetic_Type_Ref_List is
      begin
         if Node = null then
            return No_Entity_Synthetic_Type_Ref_List;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Synthetic_Type_Ref_List) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Token_Lit
        (Node : Bare_Token_Lit; Info : Internal_Entity_Info)
         return Internal_Entity_Token_Lit is
      begin
         if Node = null then
            return No_Entity_Token_Lit;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Token_Lit) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Token_No_Case_Lit
        (Node : Bare_Token_No_Case_Lit; Info : Internal_Entity_Info)
         return Internal_Entity_Token_No_Case_Lit is
      begin
         if Node = null then
            return No_Entity_Token_No_Case_Lit;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Token_No_Case_Lit) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Token_Pattern_Concat
        (Node : Bare_Token_Pattern_Concat; Info : Internal_Entity_Info)
         return Internal_Entity_Token_Pattern_Concat is
      begin
         if Node = null then
            return No_Entity_Token_Pattern_Concat;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Token_Pattern_Concat) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Token_Pattern_Lit
        (Node : Bare_Token_Pattern_Lit; Info : Internal_Entity_Info)
         return Internal_Entity_Token_Pattern_Lit is
      begin
         if Node = null then
            return No_Entity_Token_Pattern_Lit;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Token_Pattern_Lit) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Token_Ref
        (Node : Bare_Token_Ref; Info : Internal_Entity_Info)
         return Internal_Entity_Token_Ref is
      begin
         if Node = null then
            return No_Entity_Token_Ref;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Token_Ref) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Trait_Decl
        (Node : Bare_Trait_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Trait_Decl is
      begin
         if Node = null then
            return No_Entity_Trait_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Trait_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Try_Expr
        (Node : Bare_Try_Expr; Info : Internal_Entity_Info)
         return Internal_Entity_Try_Expr is
      begin
         if Node = null then
            return No_Entity_Try_Expr;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Try_Expr) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Tuple_Pattern
        (Node : Bare_Tuple_Pattern; Info : Internal_Entity_Info)
         return Internal_Entity_Tuple_Pattern is
      begin
         if Node = null then
            return No_Entity_Tuple_Pattern;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Tuple_Pattern) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Type_Pattern
        (Node : Bare_Type_Pattern; Info : Internal_Entity_Info)
         return Internal_Entity_Type_Pattern is
      begin
         if Node = null then
            return No_Entity_Type_Pattern;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Type_Pattern) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Un_Op
        (Node : Bare_Un_Op; Info : Internal_Entity_Info)
         return Internal_Entity_Un_Op is
      begin
         if Node = null then
            return No_Entity_Un_Op;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Un_Op) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Val_Decl
        (Node : Bare_Val_Decl; Info : Internal_Entity_Info)
         return Internal_Entity_Val_Decl is
      begin
         if Node = null then
            return No_Entity_Val_Decl;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Val_Decl) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   



      function Create_Internal_Entity_Var_Bind
        (Node : Bare_Var_Bind; Info : Internal_Entity_Info)
         return Internal_Entity_Var_Bind is
      begin
         if Node = null then
            return No_Entity_Var_Bind;
         end if;
         return (Node => Node, Info => Info);
      end;



   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Entity_Var_Bind) return String is
         pragma Warnings (On, "referenced");
      begin
            return Image (Entity'(Node => R.Node, Info => R.Info));
      end Trace_Image;


   

   


      -------------
      -- Inc_Ref --
      -------------

      procedure Inc_Ref (R : Internal_Env_Assoc) is
      begin
               Inc_Ref (R.Dest_Env);
      end Inc_Ref;

      -------------
      -- Dec_Ref --
      -------------

      procedure Dec_Ref (R : in out Internal_Env_Assoc) is
      begin
               Dec_Ref (R.Dest_Env);
      end Dec_Ref;




      ----------------
      -- Equivalent --
      ----------------

      function Equivalent (L, R : Internal_Env_Assoc) return Boolean is
      begin
         return L.Key = R.Key and then L.Value = R.Value and then Equivalent (L.Dest_Env, R.Dest_Env) and then L.Metadata = R.Metadata;
      end Equivalent;


   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Env_Assoc) return String is
         pragma Warnings (On, "referenced");
      begin
            return
              ("("
                     & "Key => "
                     & Trace_Image (R.Key)
                        & ", "
                     & "Value => "
                     & Trace_Image (R.Value)
                        & ", "
                     & "Dest_Env => "
                     & Trace_Image (R.Dest_Env)
                        & ", "
                     & "Metadata => "
                     & Trace_Image (R.Metadata)
               & ")");
      end Trace_Image;


   

   




   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Inner_Env_Assoc) return String is
         pragma Warnings (On, "referenced");
      begin
            return
              ("("
                     & "Key => "
                     & Trace_Image (R.Key)
                        & ", "
                     & "Value => "
                     & Trace_Image (R.Value)
                        & ", "
                     & "Rebindings => "
                     & Trace_Image (R.Rebindings)
                        & ", "
                     & "Metadata => "
                     & Trace_Image (R.Metadata)
               & ")");
      end Trace_Image;


   

   




   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Logic_Context) return String is
         pragma Warnings (On, "referenced");
      begin
            return
              ("("
                     & "Ref_Node => "
                     & Trace_Image (R.Ref_Node)
                        & ", "
                     & "Decl_Node => "
                     & Trace_Image (R.Decl_Node)
               & ")");
      end Trace_Image;


   

   




   

      ----------
      -- Hash --
      ----------

      pragma Warnings (Off, "referenced");
      function Hash (R : Internal_Resolved_Param) return Hash_Type is
         pragma Warnings (On, "referenced");
      begin
         
            return Combine ((Hash (R.Name), Hash (R.Param_Type), Hash (R.Has_Default_Value), Hash (R.Accept_Logical_Var), Hash (R.Decl)));
      end Hash;


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Resolved_Param) return String is
         pragma Warnings (On, "referenced");
      begin
            return
              ("("
                     & "Name => "
                     & Trace_Image (R.Name)
                        & ", "
                     & "Param_Type => "
                     & Trace_Image (R.Param_Type)
                        & ", "
                     & "Has_Default_Value => "
                     & Trace_Image (R.Has_Default_Value)
                        & ", "
                     & "Accept_Logical_Var => "
                     & Trace_Image (R.Accept_Logical_Var)
                        & ", "
                     & "Decl => "
                     & Trace_Image (R.Decl)
               & ")");
      end Trace_Image;


   

   




   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Param_Match) return String is
         pragma Warnings (On, "referenced");
      begin
            return
              ("("
                     & "Has_Matched => "
                     & Trace_Image (R.Has_Matched)
                        & ", "
                     & "Arg => "
                     & Trace_Image (R.Arg)
                        & ", "
                     & "Param => "
                     & Trace_Image (R.Param)
               & ")");
      end Trace_Image;


   

   




   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Ref_Result) return String is
         pragma Warnings (On, "referenced");
      begin
            return
              ("("
                     & "Ref => "
                     & Trace_Image (R.Ref)
               & ")");
      end Trace_Image;


   

   


      -------------
      -- Inc_Ref --
      -------------

      procedure Inc_Ref (R : Internal_Solver_Diagnostic) is
      begin
               Inc_Ref (R.Message_Template);
               Inc_Ref (R.Args);
               Inc_Ref (R.Contexts);
      end Inc_Ref;

      -------------
      -- Dec_Ref --
      -------------

      procedure Dec_Ref (R : in out Internal_Solver_Diagnostic) is
      begin
               Dec_Ref (R.Message_Template);
               Dec_Ref (R.Args);
               Dec_Ref (R.Contexts);
      end Dec_Ref;




      ----------------
      -- Equivalent --
      ----------------

      function Equivalent (L, R : Internal_Solver_Diagnostic) return Boolean is
      begin
         return Equivalent (L.Message_Template, R.Message_Template) and then Equivalent (L.Args, R.Args) and then L.Location = R.Location and then Equivalent (L.Contexts, R.Contexts) and then L.Round = R.Round;
      end Equivalent;


   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Solver_Diagnostic) return String is
         pragma Warnings (On, "referenced");
      begin
            return
              ("("
                     & "Message_Template => "
                     & Trace_Image (R.Message_Template)
                        & ", "
                     & "Args => "
                     & Trace_Image (R.Args)
                        & ", "
                     & "Location => "
                     & Trace_Image (R.Location)
                        & ", "
                     & "Contexts => "
                     & Trace_Image (R.Contexts)
                        & ", "
                     & "Round => "
                     & Trace_Image (R.Round)
               & ")");
      end Trace_Image;


   

   


      -------------
      -- Inc_Ref --
      -------------

      procedure Inc_Ref (R : Internal_Solver_Result) is
      begin
               Inc_Ref (R.Diagnostics);
      end Inc_Ref;

      -------------
      -- Dec_Ref --
      -------------

      procedure Dec_Ref (R : in out Internal_Solver_Result) is
      begin
               Dec_Ref (R.Diagnostics);
      end Dec_Ref;




      ----------------
      -- Equivalent --
      ----------------

      function Equivalent (L, R : Internal_Solver_Result) return Boolean is
      begin
         return L.Success = R.Success and then Equivalent (L.Diagnostics, R.Diagnostics);
      end Equivalent;


   


      -----------------
      -- Trace_Image --
      -----------------

      pragma Warnings (Off, "referenced");
      function Trace_Image (R : Internal_Solver_Result) return String is
         pragma Warnings (On, "referenced");
      begin
            return
              ("("
                     & "Success => "
                     & Trace_Image (R.Success)
                        & ", "
                     & "Diagnostics => "
                     & Trace_Image (R.Diagnostics)
               & ")");
      end Trace_Image;



   
         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

   

   

   

   type Decl_P_Is_Type_Decl_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Decl_P_Is_Type_Decl_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Decl_P_Is_Type_Decl_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Decl_P_Is_Type_Decl_0_Predicate) return String;

   

   function Create_Decl_P_Is_Type_Decl_0_Predicate
   (
         Error_Location : Bare_Lkt_Node
   )
      return Decl_P_Is_Type_Decl_0_Predicate is
   begin
      
      return Decl_P_Is_Type_Decl_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Decl_P_Is_Type_Decl_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is
         pragma Unreferenced (Self);



      
      Node : Bare_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Decl_P_Is_Type_Decl (Node);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Decl_P_Is_Type_Decl_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (1);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("{} is not a type"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entity;
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Decl_P_Is_Type_Decl_0_Predicate) return String is
   begin
      return "Decl.is_type_decl";
   end Image;



         

         

   

   

   

   type Decl_P_Is_Defined_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Decl_P_Is_Defined_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Decl_P_Is_Defined_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Decl_P_Is_Defined_0_Predicate) return String;

   

   function Create_Decl_P_Is_Defined_0_Predicate
   (
         Error_Location : Bare_Lkt_Node
   )
      return Decl_P_Is_Defined_0_Predicate is
   begin
      
      return Decl_P_Is_Defined_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Decl_P_Is_Defined_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is
         pragma Unreferenced (Self);



      
      Node : Bare_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Decl_P_Is_Defined (Node);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Decl_P_Is_Defined_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (0);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("undefined entity"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Decl_P_Is_Defined_0_Predicate) return String is
   begin
      return "Decl.is_defined";
   end Image;



         

         

         

         

         

   

   type Decl_P_Function_Type_0_Functor is new Solver_Ifc.Converter_Type with
      null record;

   overriding function Convert (Self : Decl_P_Function_Type_0_Functor; From : Internal_Entity) return Internal_Entity with Inline;
   overriding function Image (Self : Decl_P_Function_Type_0_Functor) return String;


   

   function Create_Decl_P_Function_Type_0_Functor
      return Decl_P_Function_Type_0_Functor is
   begin
      
      return Decl_P_Function_Type_0_Functor'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1);
   end;

   overriding function Convert (Self : Decl_P_Function_Type_0_Functor; From : Internal_Entity) return Internal_Entity is
         pragma Unreferenced (Self);



      

      Ret : Internal_Entity_Function_Type;
   begin
            if From.Node /= null
               and then From.Node.Kind not in
                 Lkt_Decl
            then
               Raise_Property_Exception
                 (From.Node,
                  Property_Error'Identity,
                  "mismatching node type for conv_prop");
            end if;


      
      Ret := Decl_P_Function_Type (Node => From.Node, E_Info => From.Info);


      return (Node => Ret.Node, Info => Ret.Info);
   end Convert;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Decl_P_Function_Type_0_Functor) return String is
   begin
      return ("Decl.function_type");
   end Image;



         

         

         

         

         

         

         

         

   

   type Decl_P_Get_Keep_Type_0_Functor is new Solver_Ifc.Combiner_Type with
      null record;

   overriding function Combine (Self : Decl_P_Get_Keep_Type_0_Functor; Vals : Entity_Vars.Value_Array) return Internal_Entity with Inline;
   overriding function Image (Self : Decl_P_Get_Keep_Type_0_Functor) return String;


   

   function Create_Decl_P_Get_Keep_Type_0_Functor
   (
         N : Positive
   )
      return Decl_P_Get_Keep_Type_0_Functor is
   begin
      
      return Decl_P_Get_Keep_Type_0_Functor'(N => N, Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1);
   end;

   overriding function Combine (Self : Decl_P_Get_Keep_Type_0_Functor; Vals : Entity_Vars.Value_Array) return Internal_Entity is
         pragma Unreferenced (Self);

         From : constant Internal_Entity := Vals (1);


      

      Ret : Internal_Entity_Type_Decl;
   begin
            if From.Node /= null
               and then From.Node.Kind not in
                 Lkt_Decl
            then
               Raise_Property_Exception
                 (From.Node,
                  Property_Error'Identity,
                  "mismatching node type for comb_prop");
            end if;
            if Vals (2).Node /= null
               and then Vals (2).Node.Kind not in
                 Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (From.Node,
                  Property_Error'Identity,
                  "mismatching node type for comb_prop");
            end if;


      
      Ret := Decl_P_Get_Keep_Type (Node => From.Node, Keep_Type => (Node => Vals (2).Node,  Info => Vals (2).Info), E_Info => From.Info);


      return (Node => Ret.Node, Info => Ret.Info);
   end Combine;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Decl_P_Get_Keep_Type_0_Functor) return String is
   begin
      return ("Decl.get_keep_type");
   end Image;



         

         

         

         

         

         

         

         

         

         

         

   

   

   

   type Decl_P_Is_Generic_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Decl_P_Is_Generic_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Decl_P_Is_Generic_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Decl_P_Is_Generic_0_Predicate) return String;

   

   function Create_Decl_P_Is_Generic_0_Predicate
   (
         Error_Location : Bare_Lkt_Node
   )
      return Decl_P_Is_Generic_0_Predicate is
   begin
      
      return Decl_P_Is_Generic_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Decl_P_Is_Generic_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is
         pragma Unreferenced (Self);



      
      Node : Bare_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Decl_P_Is_Generic (Node, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Decl_P_Is_Generic_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (1);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("{} is not a generic declaration"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entity;
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Decl_P_Is_Generic_0_Predicate) return String is
   begin
      return "Decl.is_generic";
   end Image;



         

         

   

   

   

   type Decl_P_Return_Type_Is_Instantiated_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         null;
   end record;

   
      overriding function Call
        (Self : Decl_P_Return_Type_Is_Instantiated_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;


   overriding function Image (Self : Decl_P_Return_Type_Is_Instantiated_0_Predicate) return String;

   

   function Create_Decl_P_Return_Type_Is_Instantiated_0_Predicate
      return Decl_P_Return_Type_Is_Instantiated_0_Predicate is
   begin
      
      return Decl_P_Return_Type_Is_Instantiated_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Decl_P_Return_Type_Is_Instantiated_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is
         pragma Unreferenced (Self);



      
      Node : Bare_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Decl_P_Return_Type_Is_Instantiated (Node, E_Info => Entity.Info);


      return Ret;
   end Call;


   -----------
   -- Image --
   -----------

   overriding function Image (Self : Decl_P_Return_Type_Is_Instantiated_0_Predicate) return String is
   begin
      return "Decl.return_type_is_instantiated";
   end Image;



         

         

         

         

   

   

   

   type Decl_P_Has_Correct_Type_Arg_Number_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Field_0 : Integer;
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Decl_P_Has_Correct_Type_Arg_Number_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Decl_P_Has_Correct_Type_Arg_Number_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Decl_P_Has_Correct_Type_Arg_Number_0_Predicate) return String;

   

   function Create_Decl_P_Has_Correct_Type_Arg_Number_0_Predicate
   (
         Nb_Types : Integer;
         Error_Location : Bare_Lkt_Node
   )
      return Decl_P_Has_Correct_Type_Arg_Number_0_Predicate is
   begin
      
         
      return Decl_P_Has_Correct_Type_Arg_Number_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location, Field_0 => Nb_Types);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Decl_P_Has_Correct_Type_Arg_Number_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is



      
      Node : Bare_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Decl_P_Has_Correct_Type_Arg_Number (Node, Nb_Types => Self.Field_0, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Decl_P_Has_Correct_Type_Arg_Number_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (0);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("Incorrect number of parameter types"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Decl_P_Has_Correct_Type_Arg_Number_0_Predicate) return String is
   begin
      return "Decl.has_correct_type_arg_number";
   end Image;



         

         

   

   

   

   type Decl_P_Could_Infer_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Field_0 : Internal_Entity_Function_Type;
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Decl_P_Could_Infer_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Decl_P_Could_Infer_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Decl_P_Could_Infer_0_Predicate) return String;

   

   function Create_Decl_P_Could_Infer_0_Predicate
   (
         Generic_Type : Internal_Entity_Function_Type;
         Error_Location : Bare_Lkt_Node
   )
      return Decl_P_Could_Infer_0_Predicate is
   begin
      
         
      return Decl_P_Could_Infer_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location, Field_0 => Generic_Type);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Decl_P_Could_Infer_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is



      
      Node : Bare_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Decl_P_Could_Infer (Node, Generic_Type => Self.Field_0, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Decl_P_Could_Infer_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (0);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("could not determine callee type"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Decl_P_Could_Infer_0_Predicate) return String is
   begin
      return "Decl.could_infer";
   end Image;



         

         

         

   

   type Decl_P_Instantiate_Generic_Decl_0_Functor is new Solver_Ifc.Combiner_Type with
      null record;

   overriding function Combine (Self : Decl_P_Instantiate_Generic_Decl_0_Functor; Vals : Entity_Vars.Value_Array) return Internal_Entity with Inline;
   overriding function Image (Self : Decl_P_Instantiate_Generic_Decl_0_Functor) return String;


   

   function Create_Decl_P_Instantiate_Generic_Decl_0_Functor
   (
         N : Positive
   )
      return Decl_P_Instantiate_Generic_Decl_0_Functor is
   begin
      
      return Decl_P_Instantiate_Generic_Decl_0_Functor'(N => N, Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1);
   end;

   overriding function Combine (Self : Decl_P_Instantiate_Generic_Decl_0_Functor; Vals : Entity_Vars.Value_Array) return Internal_Entity is
         pragma Unreferenced (Self);

         From : constant Internal_Entity := Vals (1);

         
         Args : Internal_Entity_Type_Decl_Array_Access :=
           Create_Internal_Entity_Type_Decl_Array (Vals'Length - 1);

      

      Ret : Internal_Entity_Decl;
   begin
            if From.Node /= null
               and then From.Node.Kind not in
                 Lkt_Decl
            then
               Raise_Property_Exception
                 (From.Node,
                  Property_Error'Identity,
                  "mismatching node type for comb_prop");
            end if;

      
      for I in 2 .. Vals'Last loop
            if Vals (I).Node /= null
               and then Vals (I).Node.Kind not in
                  Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Vals (I).Node,
                  Property_Error'Identity,
                  "mismatching node type for comb_prop");
            end if;
         Args.Items (I - 1) := (Vals (I).Node, Vals (I).Info);
      end loop;

      
      Ret := Decl_P_Instantiate_Generic_Decl (Node => From.Node, Param_Types => Args, E_Info => From.Info);

      Dec_Ref (Args);

      return (Node => Ret.Node, Info => Ret.Info);
   exception
      when Exc : Property_Error =>
         pragma Unreferenced (Exc);
         Dec_Ref (Args);
         raise;
   end Combine;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Decl_P_Instantiate_Generic_Decl_0_Functor) return String is
   begin
      return ("Decl.instantiate_generic_decl");
   end Image;



         

         

         

   

   

   

   type Decl_P_Is_Dynvar_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Decl_P_Is_Dynvar_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Decl_P_Is_Dynvar_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Decl_P_Is_Dynvar_0_Predicate) return String;

   

   function Create_Decl_P_Is_Dynvar_0_Predicate
   (
         Error_Location : Bare_Lkt_Node
   )
      return Decl_P_Is_Dynvar_0_Predicate is
   begin
      
      return Decl_P_Is_Dynvar_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Decl_P_Is_Dynvar_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is
         pragma Unreferenced (Self);



      
      Node : Bare_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Decl_P_Is_Dynvar (Node, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Decl_P_Is_Dynvar_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (1);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("{} is not a dynamic variable"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entity;
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Decl_P_Is_Dynvar_0_Predicate) return String is
   begin
      return "Decl.is_dynvar";
   end Image;



         

         

         

         

         

         

         

         

         

         

         

         

   

   

   

   type Decl_P_Is_Directly_Referenceable_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Decl_P_Is_Directly_Referenceable_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Decl_P_Is_Directly_Referenceable_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Decl_P_Is_Directly_Referenceable_0_Predicate) return String;

   

   function Create_Decl_P_Is_Directly_Referenceable_0_Predicate
   (
         Error_Location : Bare_Lkt_Node
   )
      return Decl_P_Is_Directly_Referenceable_0_Predicate is
   begin
      
      return Decl_P_Is_Directly_Referenceable_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Decl_P_Is_Directly_Referenceable_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is
         pragma Unreferenced (Self);



      
      Node : Bare_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Decl_P_Is_Directly_Referenceable (Node, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Decl_P_Is_Directly_Referenceable_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (1);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("{} cannot be directly referenced"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entity;
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Decl_P_Is_Directly_Referenceable_0_Predicate) return String is
   begin
      return "Decl.is_directly_referenceable";
   end Image;



         

         

   

   

   

   type Decl_P_Extraneous_Parameter_0_Predicate is
   new Solver_Ifc.N_Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Decl_P_Extraneous_Parameter_0_Predicate;
            Entities : Entity_Vars.Value_Array
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Decl_P_Extraneous_Parameter_0_Predicate;
            Entities : Entity_Vars.Value_Array;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Decl_P_Extraneous_Parameter_0_Predicate) return String;

   

   function Create_Decl_P_Extraneous_Parameter_0_Predicate
   (
         N : Positive;
         Error_Location : Bare_Lkt_Node
   )
      return Decl_P_Extraneous_Parameter_0_Predicate is
   begin
      
      return Decl_P_Extraneous_Parameter_0_Predicate'(N => N, Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Decl_P_Extraneous_Parameter_0_Predicate;
            Entities : Entity_Vars.Value_Array
        ) return Boolean
   
   is
         pragma Unreferenced (Self);

         Entity : Internal_Entity := Entities (1);


      
      Node : Bare_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;
            if Entities (2).Node /= null
               and then Entities (2).Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;
            if Entities (3).Node /= null
               and then Entities (3).Node.Kind
                        not in Lkt_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Decl_P_Extraneous_Parameter (Node, (Node => Entities (2).Node, Info => Entities (2).Info), (Node => Entities (3).Node, Info => Entities (3).Info), E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Decl_P_Extraneous_Parameter_0_Predicate;
            Entities : Entity_Vars.Value_Array;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (1);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("extraneous parameter for {}"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entities (3);
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Decl_P_Extraneous_Parameter_0_Predicate) return String is
   begin
      return "Decl.extraneous_parameter";
   end Image;



         

         

   

   

   

   type Decl_P_Unmatched_Argument_0_Predicate is
   new Solver_Ifc.N_Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Decl_P_Unmatched_Argument_0_Predicate;
            Entities : Entity_Vars.Value_Array
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Decl_P_Unmatched_Argument_0_Predicate;
            Entities : Entity_Vars.Value_Array;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Decl_P_Unmatched_Argument_0_Predicate) return String;

   

   function Create_Decl_P_Unmatched_Argument_0_Predicate
   (
         N : Positive;
         Error_Location : Bare_Lkt_Node
   )
      return Decl_P_Unmatched_Argument_0_Predicate is
   begin
      
      return Decl_P_Unmatched_Argument_0_Predicate'(N => N, Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Decl_P_Unmatched_Argument_0_Predicate;
            Entities : Entity_Vars.Value_Array
        ) return Boolean
   
   is
         pragma Unreferenced (Self);

         Entity : Internal_Entity := Entities (1);


      
      Node : Bare_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;
            if Entities (2).Node /= null
               and then Entities (2).Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Decl_P_Unmatched_Argument (Node, (Node => Entities (2).Node, Info => Entities (2).Info), E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Decl_P_Unmatched_Argument_0_Predicate;
            Entities : Entity_Vars.Value_Array;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (0);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("unmatched argument"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Decl_P_Unmatched_Argument_0_Predicate) return String is
   begin
      return "Decl.unmatched_argument";
   end Image;



         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

   

   

   

   type Type_Decl_P_Is_Equation_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Type_Decl_P_Is_Equation_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Type_Decl_P_Is_Equation_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Type_Decl_P_Is_Equation_0_Predicate) return String;

   

   function Create_Type_Decl_P_Is_Equation_0_Predicate
   (
         Error_Location : Bare_Lkt_Node
   )
      return Type_Decl_P_Is_Equation_0_Predicate is
   begin
      
      return Type_Decl_P_Is_Equation_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Type_Decl_P_Is_Equation_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is
         pragma Unreferenced (Self);



      
      Node : Bare_Type_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Type_Decl_P_Is_Equation (Node, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Type_Decl_P_Is_Equation_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (1);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("operands of %and and %or must be equations, got {}"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entity;
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Is_Equation_0_Predicate) return String is
   begin
      return "TypeDecl.is_equation";
   end Image;



         

         

   

   

   

   type Type_Decl_P_Is_Bool_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Type_Decl_P_Is_Bool_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Type_Decl_P_Is_Bool_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Type_Decl_P_Is_Bool_0_Predicate) return String;

   

   function Create_Type_Decl_P_Is_Bool_0_Predicate
   (
         Error_Location : Bare_Lkt_Node
   )
      return Type_Decl_P_Is_Bool_0_Predicate is
   begin
      
      return Type_Decl_P_Is_Bool_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Type_Decl_P_Is_Bool_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is
         pragma Unreferenced (Self);



      
      Node : Bare_Type_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Type_Decl_P_Is_Bool (Node, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Type_Decl_P_Is_Bool_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (1);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("operands of binary logic operators must be of boolean type, got {}"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entity;
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Is_Bool_0_Predicate) return String is
   begin
      return "TypeDecl.is_bool";
   end Image;



         

         

   

   

   

   type Type_Decl_P_Is_String_Or_Array_Type_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Type_Decl_P_Is_String_Or_Array_Type_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Type_Decl_P_Is_String_Or_Array_Type_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Type_Decl_P_Is_String_Or_Array_Type_0_Predicate) return String;

   

   function Create_Type_Decl_P_Is_String_Or_Array_Type_0_Predicate
   (
         Error_Location : Bare_Lkt_Node
   )
      return Type_Decl_P_Is_String_Or_Array_Type_0_Predicate is
   begin
      
      return Type_Decl_P_Is_String_Or_Array_Type_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Type_Decl_P_Is_String_Or_Array_Type_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is
         pragma Unreferenced (Self);



      
      Node : Bare_Type_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Type_Decl_P_Is_String_Or_Array_Type (Node, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Type_Decl_P_Is_String_Or_Array_Type_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (1);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("expression must be a string or an array, got {}"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entity;
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Is_String_Or_Array_Type_0_Predicate) return String is
   begin
      return "TypeDecl.is_string_or_array_type";
   end Image;



         

         

   

   

   

   type Type_Decl_P_Is_Int_Type_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Type_Decl_P_Is_Int_Type_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Type_Decl_P_Is_Int_Type_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Type_Decl_P_Is_Int_Type_0_Predicate) return String;

   

   function Create_Type_Decl_P_Is_Int_Type_0_Predicate
   (
         Error_Location : Bare_Lkt_Node
   )
      return Type_Decl_P_Is_Int_Type_0_Predicate is
   begin
      
      return Type_Decl_P_Is_Int_Type_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Type_Decl_P_Is_Int_Type_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is
         pragma Unreferenced (Self);



      
      Node : Bare_Type_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Type_Decl_P_Is_Int_Type (Node, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Type_Decl_P_Is_Int_Type_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (1);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("expression must be of type Int or BigInt, got {}"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entity;
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Is_Int_Type_0_Predicate) return String is
   begin
      return "TypeDecl.is_int_type";
   end Image;



         

         

   

   

   

   type Type_Decl_P_Is_Int_Or_Node_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Type_Decl_P_Is_Int_Or_Node_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Type_Decl_P_Is_Int_Or_Node_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Type_Decl_P_Is_Int_Or_Node_0_Predicate) return String;

   

   function Create_Type_Decl_P_Is_Int_Or_Node_0_Predicate
   (
         Error_Location : Bare_Lkt_Node
   )
      return Type_Decl_P_Is_Int_Or_Node_0_Predicate is
   begin
      
      return Type_Decl_P_Is_Int_Or_Node_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Type_Decl_P_Is_Int_Or_Node_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is
         pragma Unreferenced (Self);



      
      Node : Bare_Type_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Type_Decl_P_Is_Int_Or_Node (Node, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Type_Decl_P_Is_Int_Or_Node_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (1);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("expression must be of type Int, BigInt or Node, got {}"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entity;
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Is_Int_Or_Node_0_Predicate) return String is
   begin
      return "TypeDecl.is_int_or_node";
   end Image;



         

         

         

         

   

   

   

   type Type_Decl_P_Is_Subtype_Or_Eq_0_Predicate is
   new Solver_Ifc.N_Predicate_Type
   with record
         Field_0 : Boolean;
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Type_Decl_P_Is_Subtype_Or_Eq_0_Predicate;
            Entities : Entity_Vars.Value_Array
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Type_Decl_P_Is_Subtype_Or_Eq_0_Predicate;
            Entities : Entity_Vars.Value_Array;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Type_Decl_P_Is_Subtype_Or_Eq_0_Predicate) return String;

   

   function Create_Type_Decl_P_Is_Subtype_Or_Eq_0_Predicate
   (
         N : Positive;
         Allow_Entity : Boolean;
         Error_Location : Bare_Lkt_Node
   )
      return Type_Decl_P_Is_Subtype_Or_Eq_0_Predicate is
   begin
      
         
      return Type_Decl_P_Is_Subtype_Or_Eq_0_Predicate'(N => N, Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location, Field_0 => Allow_Entity);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Type_Decl_P_Is_Subtype_Or_Eq_0_Predicate;
            Entities : Entity_Vars.Value_Array
        ) return Boolean
   
   is

         Entity : Internal_Entity := Entities (1);


      
      Node : Bare_Type_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;
            if Entities (2).Node /= null
               and then Entities (2).Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Type_Decl_P_Is_Subtype_Or_Eq (Node, (Node => Entities (2).Node, Info => Entities (2).Info), Allow_Entity => Self.Field_0, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Type_Decl_P_Is_Subtype_Or_Eq_0_Predicate;
            Entities : Entity_Vars.Value_Array;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (2);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("{} is not a subtype of {}"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entities (2);
      Args.Items (2) := Entities (1);
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Is_Subtype_Or_Eq_0_Predicate) return String is
   begin
      return "TypeDecl.is_subtype_or_eq";
   end Image;



         

         

         

         

         

   

   type Type_Decl_P_Imprecise_Common_Ancestor_List_0_Functor is new Solver_Ifc.Combiner_Type with
      null record;

   overriding function Combine (Self : Type_Decl_P_Imprecise_Common_Ancestor_List_0_Functor; Vals : Entity_Vars.Value_Array) return Internal_Entity with Inline;
   overriding function Image (Self : Type_Decl_P_Imprecise_Common_Ancestor_List_0_Functor) return String;


   

   function Create_Type_Decl_P_Imprecise_Common_Ancestor_List_0_Functor
   (
         N : Positive
   )
      return Type_Decl_P_Imprecise_Common_Ancestor_List_0_Functor is
   begin
      
      return Type_Decl_P_Imprecise_Common_Ancestor_List_0_Functor'(N => N, Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1);
   end;

   overriding function Combine (Self : Type_Decl_P_Imprecise_Common_Ancestor_List_0_Functor; Vals : Entity_Vars.Value_Array) return Internal_Entity is
         pragma Unreferenced (Self);

         From : constant Internal_Entity := Vals (1);

         
         Args : Internal_Entity_Type_Decl_Array_Access :=
           Create_Internal_Entity_Type_Decl_Array (Vals'Length - 1);

      

      Ret : Internal_Entity_Type_Decl;
   begin
            if From.Node /= null
               and then From.Node.Kind not in
                 Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (From.Node,
                  Property_Error'Identity,
                  "mismatching node type for comb_prop");
            end if;

      
      for I in 2 .. Vals'Last loop
            if Vals (I).Node /= null
               and then Vals (I).Node.Kind not in
                  Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Vals (I).Node,
                  Property_Error'Identity,
                  "mismatching node type for comb_prop");
            end if;
         Args.Items (I - 1) := (Vals (I).Node, Vals (I).Info);
      end loop;

      
      Ret := Type_Decl_P_Imprecise_Common_Ancestor_List (Node => From.Node, Other_Types => Args, E_Info => From.Info);

      Dec_Ref (Args);

      return (Node => Ret.Node, Info => Ret.Info);
   exception
      when Exc : Property_Error =>
         pragma Unreferenced (Exc);
         Dec_Ref (Args);
         raise;
   end Combine;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Imprecise_Common_Ancestor_List_0_Functor) return String is
   begin
      return ("TypeDecl.imprecise_common_ancestor_list");
   end Image;



         

   

   

   

   type Type_Decl_P_Commutative_Matching_Type_0_Predicate is
   new Solver_Ifc.N_Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Type_Decl_P_Commutative_Matching_Type_0_Predicate;
            Entities : Entity_Vars.Value_Array
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Type_Decl_P_Commutative_Matching_Type_0_Predicate;
            Entities : Entity_Vars.Value_Array;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Type_Decl_P_Commutative_Matching_Type_0_Predicate) return String;

   

   function Create_Type_Decl_P_Commutative_Matching_Type_0_Predicate
   (
         N : Positive;
         Error_Location : Bare_Lkt_Node
   )
      return Type_Decl_P_Commutative_Matching_Type_0_Predicate is
   begin
      
      return Type_Decl_P_Commutative_Matching_Type_0_Predicate'(N => N, Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Type_Decl_P_Commutative_Matching_Type_0_Predicate;
            Entities : Entity_Vars.Value_Array
        ) return Boolean
   
   is
         pragma Unreferenced (Self);

         Entity : Internal_Entity := Entities (1);


      
      Node : Bare_Type_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;
            if Entities (2).Node /= null
               and then Entities (2).Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Type_Decl_P_Commutative_Matching_Type (Node, (Node => Entities (2).Node, Info => Entities (2).Info), E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Type_Decl_P_Commutative_Matching_Type_0_Predicate;
            Entities : Entity_Vars.Value_Array;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (2);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("expected {}, got {}"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entities (1);
      Args.Items (2) := Entities (2);
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Commutative_Matching_Type_0_Predicate) return String is
   begin
      return "TypeDecl.commutative_matching_type";
   end Image;



   

   

   

   type Type_Decl_P_Commutative_Matching_Type_1_Predicate is
   new Solver_Ifc.N_Predicate_Type
   with record
         Field_0 : Boolean;
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Type_Decl_P_Commutative_Matching_Type_1_Predicate;
            Entities : Entity_Vars.Value_Array
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Type_Decl_P_Commutative_Matching_Type_1_Predicate;
            Entities : Entity_Vars.Value_Array;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Type_Decl_P_Commutative_Matching_Type_1_Predicate) return String;

   

   function Create_Type_Decl_P_Commutative_Matching_Type_1_Predicate
   (
         N : Positive;
         Allow_Common_Ancestor : Boolean;
         Error_Location : Bare_Lkt_Node
   )
      return Type_Decl_P_Commutative_Matching_Type_1_Predicate is
   begin
      
         
      return Type_Decl_P_Commutative_Matching_Type_1_Predicate'(N => N, Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location, Field_0 => Allow_Common_Ancestor);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Type_Decl_P_Commutative_Matching_Type_1_Predicate;
            Entities : Entity_Vars.Value_Array
        ) return Boolean
   
   is

         Entity : Internal_Entity := Entities (1);


      
      Node : Bare_Type_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;
            if Entities (2).Node /= null
               and then Entities (2).Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Type_Decl_P_Commutative_Matching_Type (Node, (Node => Entities (2).Node, Info => Entities (2).Info), Allow_Common_Ancestor => Self.Field_0, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Type_Decl_P_Commutative_Matching_Type_1_Predicate;
            Entities : Entity_Vars.Value_Array;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (2);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("expected {}, got {}"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entities (1);
      Args.Items (2) := Entities (2);
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Commutative_Matching_Type_1_Predicate) return String is
   begin
      return "TypeDecl.commutative_matching_type";
   end Image;



         

         

   

   

   

   type Type_Decl_P_Could_Determine_Type_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Type_Decl_P_Could_Determine_Type_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Type_Decl_P_Could_Determine_Type_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Type_Decl_P_Could_Determine_Type_0_Predicate) return String;

   

   function Create_Type_Decl_P_Could_Determine_Type_0_Predicate
   (
         Error_Location : Bare_Lkt_Node
   )
      return Type_Decl_P_Could_Determine_Type_0_Predicate is
   begin
      
      return Type_Decl_P_Could_Determine_Type_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Type_Decl_P_Could_Determine_Type_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is
         pragma Unreferenced (Self);



      
      Node : Bare_Type_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Type_Decl_P_Could_Determine_Type (Node);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Type_Decl_P_Could_Determine_Type_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (0);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("could not determine type"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Could_Determine_Type_0_Predicate) return String is
   begin
      return "TypeDecl.could_determine_type";
   end Image;



         

         

         

         

   

   

   

   type Type_Decl_P_Matching_Type_0_Predicate is
   new Solver_Ifc.N_Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Type_Decl_P_Matching_Type_0_Predicate;
            Entities : Entity_Vars.Value_Array
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Type_Decl_P_Matching_Type_0_Predicate;
            Entities : Entity_Vars.Value_Array;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Type_Decl_P_Matching_Type_0_Predicate) return String;

   

   function Create_Type_Decl_P_Matching_Type_0_Predicate
   (
         N : Positive;
         Error_Location : Bare_Lkt_Node
   )
      return Type_Decl_P_Matching_Type_0_Predicate is
   begin
      
      return Type_Decl_P_Matching_Type_0_Predicate'(N => N, Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Type_Decl_P_Matching_Type_0_Predicate;
            Entities : Entity_Vars.Value_Array
        ) return Boolean
   
   is
         pragma Unreferenced (Self);

         Entity : Internal_Entity := Entities (1);


      
      Node : Bare_Type_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;
            if Entities (2).Node /= null
               and then Entities (2).Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Type_Decl_P_Matching_Type (Node, (Node => Entities (2).Node, Info => Entities (2).Info), E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Type_Decl_P_Matching_Type_0_Predicate;
            Entities : Entity_Vars.Value_Array;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (2);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("expected {}, got {}"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entities (1);
      Args.Items (2) := Entities (2);
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Matching_Type_0_Predicate) return String is
   begin
      return "TypeDecl.matching_type";
   end Image;



   

   

   

   type Type_Decl_P_Matching_Type_1_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Field_0 : Internal_Entity_Type_Decl;
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Type_Decl_P_Matching_Type_1_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Type_Decl_P_Matching_Type_1_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Type_Decl_P_Matching_Type_1_Predicate) return String;

   

   function Create_Type_Decl_P_Matching_Type_1_Predicate
   (
         Other : Internal_Entity_Type_Decl;
         Error_Location : Bare_Lkt_Node
   )
      return Type_Decl_P_Matching_Type_1_Predicate is
   begin
      
         
      return Type_Decl_P_Matching_Type_1_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location, Field_0 => Other);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Type_Decl_P_Matching_Type_1_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is



      
      Node : Bare_Type_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Type_Decl_P_Matching_Type (Node, Other => Self.Field_0, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Type_Decl_P_Matching_Type_1_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (2);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("expected {}, got {}"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entity;
      Args.Items (2) := (Self.Field_0.Node, Self.Field_0.Info);
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Matching_Type_1_Predicate) return String is
   begin
      return "TypeDecl.matching_type";
   end Image;



         

         

   

   

   

   type Type_Decl_P_Matching_Logic_Type_0_Predicate is
   new Solver_Ifc.N_Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Type_Decl_P_Matching_Logic_Type_0_Predicate;
            Entities : Entity_Vars.Value_Array
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Type_Decl_P_Matching_Logic_Type_0_Predicate;
            Entities : Entity_Vars.Value_Array;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Type_Decl_P_Matching_Logic_Type_0_Predicate) return String;

   

   function Create_Type_Decl_P_Matching_Logic_Type_0_Predicate
   (
         N : Positive;
         Error_Location : Bare_Lkt_Node
   )
      return Type_Decl_P_Matching_Logic_Type_0_Predicate is
   begin
      
      return Type_Decl_P_Matching_Logic_Type_0_Predicate'(N => N, Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Type_Decl_P_Matching_Logic_Type_0_Predicate;
            Entities : Entity_Vars.Value_Array
        ) return Boolean
   
   is
         pragma Unreferenced (Self);

         Entity : Internal_Entity := Entities (1);


      
      Node : Bare_Type_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;
            if Entities (2).Node /= null
               and then Entities (2).Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Type_Decl_P_Matching_Logic_Type (Node, (Node => Entities (2).Node, Info => Entities (2).Info), E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Type_Decl_P_Matching_Logic_Type_0_Predicate;
            Entities : Entity_Vars.Value_Array;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (2);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("expected {}, got {}"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entities (1);
      Args.Items (2) := Entities (2);
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Matching_Logic_Type_0_Predicate) return String is
   begin
      return "TypeDecl.matching_logic_type";
   end Image;



   

   

   

   type Type_Decl_P_Matching_Logic_Type_1_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Field_0 : Internal_Entity_Type_Decl;
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Type_Decl_P_Matching_Logic_Type_1_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Type_Decl_P_Matching_Logic_Type_1_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Type_Decl_P_Matching_Logic_Type_1_Predicate) return String;

   

   function Create_Type_Decl_P_Matching_Logic_Type_1_Predicate
   (
         Other : Internal_Entity_Type_Decl;
         Error_Location : Bare_Lkt_Node
   )
      return Type_Decl_P_Matching_Logic_Type_1_Predicate is
   begin
      
         
      return Type_Decl_P_Matching_Logic_Type_1_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location, Field_0 => Other);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Type_Decl_P_Matching_Logic_Type_1_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is



      
      Node : Bare_Type_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Type_Decl_P_Matching_Logic_Type (Node, Other => Self.Field_0, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Type_Decl_P_Matching_Logic_Type_1_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (2);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("expected {}, got {}"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entity;
      Args.Items (2) := (Self.Field_0.Node, Self.Field_0.Info);
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Matching_Logic_Type_1_Predicate) return String is
   begin
      return "TypeDecl.matching_logic_type";
   end Image;



         

         

   

   

   

   type Type_Decl_P_Is_Of_Array_Type_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Type_Decl_P_Is_Of_Array_Type_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Type_Decl_P_Is_Of_Array_Type_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Type_Decl_P_Is_Of_Array_Type_0_Predicate) return String;

   

   function Create_Type_Decl_P_Is_Of_Array_Type_0_Predicate
   (
         Error_Location : Bare_Lkt_Node
   )
      return Type_Decl_P_Is_Of_Array_Type_0_Predicate is
   begin
      
      return Type_Decl_P_Is_Of_Array_Type_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Type_Decl_P_Is_Of_Array_Type_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is
         pragma Unreferenced (Self);



      
      Node : Bare_Type_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Type_Decl_P_Is_Of_Array_Type (Node, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Type_Decl_P_Is_Of_Array_Type_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (1);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("{} is not an array"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entity;
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Is_Of_Array_Type_0_Predicate) return String is
   begin
      return "TypeDecl.is_of_array_type";
   end Image;



         

         

   

   

   

   type Type_Decl_P_Is_Callable_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Type_Decl_P_Is_Callable_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Type_Decl_P_Is_Callable_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Type_Decl_P_Is_Callable_0_Predicate) return String;

   

   function Create_Type_Decl_P_Is_Callable_0_Predicate
   (
         Error_Location : Bare_Lkt_Node
   )
      return Type_Decl_P_Is_Callable_0_Predicate is
   begin
      
      return Type_Decl_P_Is_Callable_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Type_Decl_P_Is_Callable_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is
         pragma Unreferenced (Self);



      
      Node : Bare_Type_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Type_Decl_P_Is_Callable (Node, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Type_Decl_P_Is_Callable_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (1);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("{} is not callable"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entity;
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Is_Callable_0_Predicate) return String is
   begin
      return "TypeDecl.is_callable";
   end Image;



         

         

         

   

   type Type_Decl_P_Match_Param_Get_Type_0_Functor is new Solver_Ifc.Converter_Type with
      record
            Current_Name : Internal_Entity_Argument;
            In_Logic_Call : Boolean;
      end record;

   overriding function Convert (Self : Type_Decl_P_Match_Param_Get_Type_0_Functor; From : Internal_Entity) return Internal_Entity with Inline;
   overriding function Image (Self : Type_Decl_P_Match_Param_Get_Type_0_Functor) return String;


   

   function Create_Type_Decl_P_Match_Param_Get_Type_0_Functor
   (
         Current_Name : Internal_Entity_Argument;
         In_Logic_Call : Boolean
   )
      return Type_Decl_P_Match_Param_Get_Type_0_Functor is
   begin
      
         
         
      return Type_Decl_P_Match_Param_Get_Type_0_Functor'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Current_Name => Current_Name, In_Logic_Call => In_Logic_Call);
   end;

   overriding function Convert (Self : Type_Decl_P_Match_Param_Get_Type_0_Functor; From : Internal_Entity) return Internal_Entity is



      

      Ret : Internal_Entity_Decl;
   begin
            if From.Node /= null
               and then From.Node.Kind not in
                 Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (From.Node,
                  Property_Error'Identity,
                  "mismatching node type for conv_prop");
            end if;


      
      Ret := Type_Decl_P_Match_Param_Get_Type (Node => From.Node, Current_Name => Self.Current_Name, In_Logic_Call => Self.In_Logic_Call, E_Info => From.Info);


      return (Node => Ret.Node, Info => Ret.Info);
   end Convert;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Match_Param_Get_Type_0_Functor) return String is
   begin
      return ("TypeDecl.match_param_get_type");
   end Image;



         

         

   

   type Type_Decl_P_Match_Param_Get_Decl_0_Functor is new Solver_Ifc.Converter_Type with
      record
            Current_Name : Internal_Entity_Argument;
            In_Logic_Call : Boolean;
      end record;

   overriding function Convert (Self : Type_Decl_P_Match_Param_Get_Decl_0_Functor; From : Internal_Entity) return Internal_Entity with Inline;
   overriding function Image (Self : Type_Decl_P_Match_Param_Get_Decl_0_Functor) return String;


   

   function Create_Type_Decl_P_Match_Param_Get_Decl_0_Functor
   (
         Current_Name : Internal_Entity_Argument;
         In_Logic_Call : Boolean
   )
      return Type_Decl_P_Match_Param_Get_Decl_0_Functor is
   begin
      
         
         
      return Type_Decl_P_Match_Param_Get_Decl_0_Functor'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Current_Name => Current_Name, In_Logic_Call => In_Logic_Call);
   end;

   overriding function Convert (Self : Type_Decl_P_Match_Param_Get_Decl_0_Functor; From : Internal_Entity) return Internal_Entity is



      

      Ret : Internal_Entity_Decl;
   begin
            if From.Node /= null
               and then From.Node.Kind not in
                 Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (From.Node,
                  Property_Error'Identity,
                  "mismatching node type for conv_prop");
            end if;


      
      Ret := Type_Decl_P_Match_Param_Get_Decl (Node => From.Node, Current_Name => Self.Current_Name, In_Logic_Call => Self.In_Logic_Call, E_Info => From.Info);


      return (Node => Ret.Node, Info => Ret.Info);
   end Convert;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Match_Param_Get_Decl_0_Functor) return String is
   begin
      return ("TypeDecl.match_param_get_decl");
   end Image;



         

         

         

   

   

   

   type Type_Decl_P_Is_Valid_Call_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Field_0 : Internal_Entity_Argument_List;
         Field_1 : Boolean;
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Type_Decl_P_Is_Valid_Call_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Type_Decl_P_Is_Valid_Call_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Type_Decl_P_Is_Valid_Call_0_Predicate) return String;

   

   function Create_Type_Decl_P_Is_Valid_Call_0_Predicate
   (
         Args : Internal_Entity_Argument_List;
         In_Logic_Call : Boolean;
         Error_Location : Bare_Lkt_Node
   )
      return Type_Decl_P_Is_Valid_Call_0_Predicate is
   begin
      
         
         
      return Type_Decl_P_Is_Valid_Call_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location, Field_0 => Args, Field_1 => In_Logic_Call);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Type_Decl_P_Is_Valid_Call_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is



      
      Node : Bare_Type_Decl;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Type_Decl_P_Is_Valid_Call (Node, Args => Self.Field_0, In_Logic_Call => Self.Field_1, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Type_Decl_P_Is_Valid_Call_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (1);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("invalid call, expected {}"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      Args.Items (1) := Entity;
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Is_Valid_Call_0_Predicate) return String is
   begin
      return "TypeDecl.is_valid_call";
   end Image;



         

         

         

   

   type Type_Decl_P_Get_Return_Type_0_Functor is new Solver_Ifc.Converter_Type with
      null record;

   overriding function Convert (Self : Type_Decl_P_Get_Return_Type_0_Functor; From : Internal_Entity) return Internal_Entity with Inline;
   overriding function Image (Self : Type_Decl_P_Get_Return_Type_0_Functor) return String;


   

   function Create_Type_Decl_P_Get_Return_Type_0_Functor
      return Type_Decl_P_Get_Return_Type_0_Functor is
   begin
      
      return Type_Decl_P_Get_Return_Type_0_Functor'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1);
   end;

   overriding function Convert (Self : Type_Decl_P_Get_Return_Type_0_Functor; From : Internal_Entity) return Internal_Entity is
         pragma Unreferenced (Self);



      

      Ret : Internal_Entity_Type_Decl;
   begin
            if From.Node /= null
               and then From.Node.Kind not in
                 Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (From.Node,
                  Property_Error'Identity,
                  "mismatching node type for conv_prop");
            end if;


      
      Ret := Type_Decl_P_Get_Return_Type (Node => From.Node, E_Info => From.Info);


      return (Node => Ret.Node, Info => Ret.Info);
   end Convert;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Get_Return_Type_0_Functor) return String is
   begin
      return ("TypeDecl.get_return_type");
   end Image;



         

         

   

   type Type_Decl_P_Create_Function_Type_0_Functor is new Solver_Ifc.Combiner_Type with
      null record;

   overriding function Combine (Self : Type_Decl_P_Create_Function_Type_0_Functor; Vals : Entity_Vars.Value_Array) return Internal_Entity with Inline;
   overriding function Image (Self : Type_Decl_P_Create_Function_Type_0_Functor) return String;


   

   function Create_Type_Decl_P_Create_Function_Type_0_Functor
   (
         N : Positive
   )
      return Type_Decl_P_Create_Function_Type_0_Functor is
   begin
      
      return Type_Decl_P_Create_Function_Type_0_Functor'(N => N, Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1);
   end;

   overriding function Combine (Self : Type_Decl_P_Create_Function_Type_0_Functor; Vals : Entity_Vars.Value_Array) return Internal_Entity is
         pragma Unreferenced (Self);

         From : constant Internal_Entity := Vals (1);

         
         Args : Internal_Entity_Type_Decl_Array_Access :=
           Create_Internal_Entity_Type_Decl_Array (Vals'Length - 1);

      

      Ret : Internal_Entity_Type_Decl;
   begin
            if From.Node /= null
               and then From.Node.Kind not in
                 Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (From.Node,
                  Property_Error'Identity,
                  "mismatching node type for comb_prop");
            end if;

      
      for I in 2 .. Vals'Last loop
            if Vals (I).Node /= null
               and then Vals (I).Node.Kind not in
                  Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (Vals (I).Node,
                  Property_Error'Identity,
                  "mismatching node type for comb_prop");
            end if;
         Args.Items (I - 1) := (Vals (I).Node, Vals (I).Info);
      end loop;

      
      Ret := Type_Decl_P_Create_Function_Type (Node => From.Node, Params => Args, E_Info => From.Info);

      Dec_Ref (Args);

      return (Node => Ret.Node, Info => Ret.Info);
   exception
      when Exc : Property_Error =>
         pragma Unreferenced (Exc);
         Dec_Ref (Args);
         raise;
   end Combine;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Create_Function_Type_0_Functor) return String is
   begin
      return ("TypeDecl.create_function_type");
   end Image;



         

         

   

   type Type_Decl_P_Make_Array_Type_0_Functor is new Solver_Ifc.Converter_Type with
      null record;

   overriding function Convert (Self : Type_Decl_P_Make_Array_Type_0_Functor; From : Internal_Entity) return Internal_Entity with Inline;
   overriding function Image (Self : Type_Decl_P_Make_Array_Type_0_Functor) return String;


   

   function Create_Type_Decl_P_Make_Array_Type_0_Functor
      return Type_Decl_P_Make_Array_Type_0_Functor is
   begin
      
      return Type_Decl_P_Make_Array_Type_0_Functor'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1);
   end;

   overriding function Convert (Self : Type_Decl_P_Make_Array_Type_0_Functor; From : Internal_Entity) return Internal_Entity is
         pragma Unreferenced (Self);



      

      Ret : Internal_Entity_Type_Decl;
   begin
            if From.Node /= null
               and then From.Node.Kind not in
                 Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (From.Node,
                  Property_Error'Identity,
                  "mismatching node type for conv_prop");
            end if;


      
      Ret := Type_Decl_P_Make_Array_Type (Node => From.Node, E_Info => From.Info);


      return (Node => Ret.Node, Info => Ret.Info);
   end Convert;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Make_Array_Type_0_Functor) return String is
   begin
      return ("TypeDecl.make_array_type");
   end Image;



         

         

   

   type Type_Decl_P_Get_Array_Content_Type_0_Functor is new Solver_Ifc.Converter_Type with
      null record;

   overriding function Convert (Self : Type_Decl_P_Get_Array_Content_Type_0_Functor; From : Internal_Entity) return Internal_Entity with Inline;
   overriding function Image (Self : Type_Decl_P_Get_Array_Content_Type_0_Functor) return String;


   

   function Create_Type_Decl_P_Get_Array_Content_Type_0_Functor
      return Type_Decl_P_Get_Array_Content_Type_0_Functor is
   begin
      
      return Type_Decl_P_Get_Array_Content_Type_0_Functor'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1);
   end;

   overriding function Convert (Self : Type_Decl_P_Get_Array_Content_Type_0_Functor; From : Internal_Entity) return Internal_Entity is
         pragma Unreferenced (Self);



      

      Ret : Internal_Entity_Type_Decl;
   begin
            if From.Node /= null
               and then From.Node.Kind not in
                 Lkt_Type_Decl
            then
               Raise_Property_Exception
                 (From.Node,
                  Property_Error'Identity,
                  "mismatching node type for conv_prop");
            end if;


      
      Ret := Type_Decl_P_Get_Array_Content_Type (Node => From.Node, E_Info => From.Info);


      return (Node => Ret.Node, Info => Ret.Info);
   end Convert;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Type_Decl_P_Get_Array_Content_Type_0_Functor) return String is
   begin
      return ("TypeDecl.get_array_content_type");
   end Image;



         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

   

   

   

   type Function_Type_P_Returns_Entity_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Function_Type_P_Returns_Entity_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Function_Type_P_Returns_Entity_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Function_Type_P_Returns_Entity_0_Predicate) return String;

   

   function Create_Function_Type_P_Returns_Entity_0_Predicate
   (
         Error_Location : Bare_Lkt_Node
   )
      return Function_Type_P_Returns_Entity_0_Predicate is
   begin
      
      return Function_Type_P_Returns_Entity_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Function_Type_P_Returns_Entity_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is
         pragma Unreferenced (Self);



      
      Node : Bare_Function_Type;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Function_Type_Range
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Function_Type_P_Returns_Entity (Node, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Function_Type_P_Returns_Entity_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (0);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("Propagate functions must return entities"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Function_Type_P_Returns_Entity_0_Predicate) return String is
   begin
      return "FunctionType.returns_entity";
   end Image;



         

         

   

   

   

   type Function_Type_P_Returns_Bool_0_Predicate is
   new Solver_Ifc.Predicate_Type
   with record
         Error_Location : Bare_Lkt_Node;
   end record;

   
      overriding function Call
        (Self : Function_Type_P_Returns_Bool_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   ;

   
      overriding procedure Failed
        (Self : Function_Type_P_Returns_Bool_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   ;

   overriding function Image (Self : Function_Type_P_Returns_Bool_0_Predicate) return String;

   

   function Create_Function_Type_P_Returns_Bool_0_Predicate
   (
         Error_Location : Bare_Lkt_Node
   )
      return Function_Type_P_Returns_Bool_0_Predicate is
   begin
      
      return Function_Type_P_Returns_Bool_0_Predicate'(Cache_Set => False, Cache_Key => <>, Cache_Value => <>, Ref_Count => 1, Error_Location => Error_Location);
   end;

   ----------
   -- Call --
   ----------

   
      overriding function Call
        (Self : Function_Type_P_Returns_Bool_0_Predicate;
            Entity : Internal_Entity
        ) return Boolean
   
   is
         pragma Unreferenced (Self);



      
      Node : Bare_Function_Type;

      Ret : Boolean;
   begin

      
            if Entity.Node /= null
               and then Entity.Node.Kind
                        not in Lkt_Function_Type_Range
            then
               Raise_Property_Exception
                 (Node, Property_Error'Identity, "mismatching node type");
            end if;

      Node := Entity.Node;


      

      Ret := Function_Type_P_Returns_Bool (Node, E_Info => Entity.Info);


      return Ret;
   end Call;

   ------------
   -- Failed --
   ------------

   
      overriding procedure Failed
        (Self : Function_Type_P_Returns_Bool_0_Predicate;
            Entity : Internal_Entity;
         Ctxs    : Solver_Ifc.Logic_Context_Array;
         Round   : Natural;
         Emitter : Solver_Ifc.Diagnostic_Emitter
        )
   
   is
      
      Args : Internal_Entity_Array_Access :=
         Create_Internal_Entity_Array (0);

      Contexts : Internal_Logic_Context_Array_Access :=
         Create_Internal_Logic_Context_Array (Ctxs'Length);

      Diag : constant Internal_Solver_Diagnostic :=
        (Message_Template => Create_String ("Predicate functions must return booleans"),
         Args             => Args,
         Contexts         => Contexts,
         Location         => Self.Error_Location,
         Round            => Round);
   begin
      for I in Ctxs'Range loop
         Contexts.Items (I) := Ctxs (I).all;
      end loop;
      Emitter (Diag);
   end Failed;

   -----------
   -- Image --
   -----------

   overriding function Image (Self : Function_Type_P_Returns_Bool_0_Predicate) return String is
   begin
      return "FunctionType.returns_bool";
   end Image;



         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         

         



      

   --
   --  Primitives for Bare_Lkt_Node
   --

   





   







--# property-start LktNode.root_get nodes.lkt:64
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Root_Get
  
  (Node : Bare_Lkt_Node
      ; Entity_Name : Symbol_Type
  )

   return Internal_Entity_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   

   --# bind entity_name Entity_Name

   Property_Result : Internal_Entity_Decl;

      
            procedure Finalizer_Scope_21 with Inline_Always;

      Fld : Internal_Unit;
Fld_1 : Bare_Lkt_Node;
Fld_2 : Lexical_Env := Empty_Env;
Env_Get_Result : Internal_Entity;
Cast_Result : Internal_Entity_Decl;

            procedure Finalizer_Scope_21 is
            begin
                     Dec_Ref (Fld_2);
            end Finalizer_Scope_21;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 5 Cast Cast_Result nodes.lkt:65





--# expr-start 4 .get_first Env_Get_Result nodes.lkt:65
--# expr-start 3 LktNode.node_env Fld_2 nodes.lkt:65



--# expr-start 2 AnalysisUnit.root Fld_1 nodes.lkt:65



--# expr-start 1 LktNode.unit Fld nodes.lkt:65







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Unit (Node => Self);
--# expr-done 1



   if Fld = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Fld.Ast_Root;
--# expr-done 2



   if Fld_1 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Liblktlang.Implementation.Node_Env (Node => Fld_1);
--# expr-done 3



Env_Get_Result := AST_Envs.Get_First (Self => Fld_2, Key => Thin (Entity_Name), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 4



   if Env_Get_Result.Node = null
      or else Env_Get_Result.Node.Kind in Lkt_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Decl
        (Node => Env_Get_Result.Node,
         Info => Env_Get_Result.Info);

   else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "invalid object cast");
   end if;


--# expr-done 5

         Property_Result := Cast_Result;
         
   --# end
      Finalizer_Scope_21;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_21;




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Root_Get;
--# end

   







--# property-start LktNode.get_builtin_type nodes.lkt:68
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Get_Builtin_Type
  
  (Node : Bare_Lkt_Node
      ; Entity_Name : Symbol_Type
  )

   return Internal_Entity_Named_Type_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   

   --# bind entity_name Entity_Name

   Property_Result : Internal_Entity_Named_Type_Decl;

      

      Fld : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Named_Type_Decl;


      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Lkt_Node_Lkt_Node_P_Get_Builtin_Type,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Lkt_Node,
                                As_Bare_Lkt_Node => Self);
               Mmz_K.Items (2) := (Kind => Mmz_Symbol_Type,
                                      As_Symbol_Type => Entity_Name);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Entity_Named_Type_Decl;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 7 Cast Cast_Result nodes.lkt:69





--# expr-start 6 LktNode.root_get Fld nodes.lkt:69







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start LktNode.root_get
Fld := Liblktlang.Implementation.Lkt_Node_P_Root_Get (Node => Self, Entity_Name => Entity_Name);
--# end
--# expr-done 6



   if Fld.Node = null
      or else Fld.Node.Kind in Lkt_Named_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Named_Type_Decl
        (Node => Fld.Node,
         Info => Fld.Info);

   else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "invalid object cast");
   end if;


--# expr-done 7

         Property_Result := Cast_Result;
         
   --# end


      exception
         when Exc : Property_Error =>


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Entity_Named_Type_Decl,
                     As_Internal_Entity_Named_Type_Decl => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Lkt_Node_P_Get_Builtin_Type;
--# end

   







--# property-start LktNode.get_builtin_gen_decl nodes.lkt:71
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Get_Builtin_Gen_Decl
  
  (Node : Bare_Lkt_Node
      ; Entity_Name : Symbol_Type
  )

   return Internal_Entity_Generic_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   

   --# bind entity_name Entity_Name

   Property_Result : Internal_Entity_Generic_Decl;

      

      Fld : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Generic_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 9 Cast Cast_Result nodes.lkt:72





--# expr-start 8 LktNode.root_get Fld nodes.lkt:72







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start LktNode.root_get
Fld := Liblktlang.Implementation.Lkt_Node_P_Root_Get (Node => Self, Entity_Name => Entity_Name);
--# end
--# expr-done 8



   if Fld.Node = null
      or else Fld.Node.Kind in Lkt_Generic_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Generic_Decl
        (Node => Fld.Node,
         Info => Fld.Info);

   else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "invalid object cast");
   end if;


--# expr-done 9

         Property_Result := Cast_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Get_Builtin_Gen_Decl;
--# end

   







--# property-start LktNode.basic_trait_gen nodes.lkt:76
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Basic_Trait_Gen
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Generic_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Generic_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Generic_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 11 LktNode.get_builtin_gen_decl Fld nodes.lkt:77







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 10 SymbolLiteral Sym nodes.lkt:77
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Basictrait); 
--# expr-done 10
--# property-call-start LktNode.get_builtin_gen_decl
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Gen_Decl (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 11

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Basic_Trait_Gen;
--# end

   







--# property-start LktNode.basic_trait nodes.lkt:81
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Basic_Trait
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Trait_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Trait_Decl;

      

      Fld : Internal_Entity_Generic_Decl;
Fld_1 : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Trait_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 14 Cast Cast_Result nodes.lkt:82





--# expr-start 13 GenericDecl.decl Fld_1 nodes.lkt:82



--# expr-start 12 LktNode.basic_trait_gen Fld nodes.lkt:82







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.basic_trait_gen
Fld := Liblktlang.Implementation.Lkt_Node_P_Basic_Trait_Gen (Node => Self);
--# end
--# expr-done 12



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Decl (Node => Fld.Node.Generic_Decl_F_Decl, Info => Fld.Info);
--# expr-done 13



   if Fld_1.Node = null
      or else Fld_1.Node.Kind in Lkt_Trait_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Trait_Decl
        (Node => Fld_1.Node,
         Info => Fld_1.Info);

   else
         Cast_Result := No_Entity_Trait_Decl;
   end if;


--# expr-done 14

         Property_Result := Cast_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Basic_Trait;
--# end

   







--# property-start LktNode.node_gen_trait nodes.lkt:86
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Node_Gen_Trait
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Generic_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Generic_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Generic_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 16 LktNode.get_builtin_gen_decl Fld nodes.lkt:87







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 15 SymbolLiteral Sym nodes.lkt:87
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Node); 
--# expr-done 15
--# property-call-start LktNode.get_builtin_gen_decl
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Gen_Decl (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 16

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Node_Gen_Trait;
--# end

   







--# property-start LktNode.node_trait nodes.lkt:91
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Node_Trait
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Trait_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Trait_Decl;

      

      Fld : Internal_Entity_Generic_Decl;
Fld_1 : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Trait_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 19 Cast Cast_Result nodes.lkt:92





--# expr-start 18 GenericDecl.decl Fld_1 nodes.lkt:92



--# expr-start 17 LktNode.node_gen_trait Fld nodes.lkt:92







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.node_gen_trait
Fld := Liblktlang.Implementation.Lkt_Node_P_Node_Gen_Trait (Node => Self);
--# end
--# expr-done 17



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Decl (Node => Fld.Node.Generic_Decl_F_Decl, Info => Fld.Info);
--# expr-done 18



   if Fld_1.Node = null
      or else Fld_1.Node.Kind in Lkt_Trait_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Trait_Decl
        (Node => Fld_1.Node,
         Info => Fld_1.Info);

   else
         Cast_Result := No_Entity_Trait_Decl;
   end if;


--# expr-done 19

         Property_Result := Cast_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Node_Trait;
--# end

   







--# property-start LktNode.indexable_gen_trait nodes.lkt:96
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Indexable_Gen_Trait
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Generic_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Generic_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Generic_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 21 LktNode.get_builtin_gen_decl Fld nodes.lkt:97







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 20 SymbolLiteral Sym nodes.lkt:97
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Indexable); 
--# expr-done 20
--# property-call-start LktNode.get_builtin_gen_decl
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Gen_Decl (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 21

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Indexable_Gen_Trait;
--# end

   







--# property-start LktNode.indexable_trait nodes.lkt:101
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Indexable_Trait
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Trait_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Trait_Decl;

      

      Fld : Internal_Entity_Generic_Decl;
Fld_1 : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Trait_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 24 Cast Cast_Result nodes.lkt:102





--# expr-start 23 GenericDecl.decl Fld_1 nodes.lkt:102



--# expr-start 22 LktNode.indexable_gen_trait Fld nodes.lkt:102







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.indexable_gen_trait
Fld := Liblktlang.Implementation.Lkt_Node_P_Indexable_Gen_Trait (Node => Self);
--# end
--# expr-done 22



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Decl (Node => Fld.Node.Generic_Decl_F_Decl, Info => Fld.Info);
--# expr-done 23



   if Fld_1.Node = null
      or else Fld_1.Node.Kind in Lkt_Trait_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Trait_Decl
        (Node => Fld_1.Node,
         Info => Fld_1.Info);

   else
         Cast_Result := No_Entity_Trait_Decl;
   end if;


--# expr-done 24

         Property_Result := Cast_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Indexable_Trait;
--# end

   







--# property-start LktNode.token_node_trait nodes.lkt:106
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Token_Node_Trait
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Named_Type_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Named_Type_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Named_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 26 LktNode.get_builtin_type Fld nodes.lkt:107







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 25 SymbolLiteral Sym nodes.lkt:107
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Tokennode); 
--# expr-done 25
--# property-call-start LktNode.get_builtin_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Type (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 26

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Token_Node_Trait;
--# end

   







--# property-start LktNode.error_node_trait nodes.lkt:111
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Error_Node_Trait
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Named_Type_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Named_Type_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Named_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 28 LktNode.get_builtin_type Fld nodes.lkt:112







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 27 SymbolLiteral Sym nodes.lkt:112
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Errornode); 
--# expr-done 27
--# property-call-start LktNode.get_builtin_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Type (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 28

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Error_Node_Trait;
--# end

   







--# property-start LktNode.char_type nodes.lkt:116
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Char_Type
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Named_Type_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Named_Type_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Named_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 30 LktNode.get_builtin_type Fld nodes.lkt:116







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 29 SymbolLiteral Sym nodes.lkt:116
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Char); 
--# expr-done 29
--# property-call-start LktNode.get_builtin_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Type (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 30

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Char_Type;
--# end

   







--# property-start LktNode.int_type nodes.lkt:120
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Int_Type
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Named_Type_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Named_Type_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Named_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 32 LktNode.get_builtin_type Fld nodes.lkt:120







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 31 SymbolLiteral Sym nodes.lkt:120
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Int); 
--# expr-done 31
--# property-call-start LktNode.get_builtin_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Type (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 32

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Int_Type;
--# end

   







--# property-start LktNode.bool_type nodes.lkt:124
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Bool_Type
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Named_Type_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Named_Type_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Named_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 34 LktNode.get_builtin_type Fld nodes.lkt:124







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 33 SymbolLiteral Sym nodes.lkt:124
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Bool); 
--# expr-done 33
--# property-call-start LktNode.get_builtin_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Type (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 34

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Bool_Type;
--# end

   







--# property-start LktNode.bigint_type nodes.lkt:128
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Bigint_Type
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Named_Type_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Named_Type_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Named_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 36 LktNode.get_builtin_type Fld nodes.lkt:128







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 35 SymbolLiteral Sym nodes.lkt:128
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Bigint); 
--# expr-done 35
--# property-call-start LktNode.get_builtin_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Type (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 36

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Bigint_Type;
--# end

   







--# property-start LktNode.string_type nodes.lkt:132
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_String_Type
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Named_Type_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Named_Type_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Named_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 38 LktNode.get_builtin_type Fld nodes.lkt:132







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 37 SymbolLiteral Sym nodes.lkt:132
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_String); 
--# expr-done 37
--# property-call-start LktNode.get_builtin_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Type (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 38

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_String_Type;
--# end

   







--# property-start LktNode.symbol_type nodes.lkt:136
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Symbol_Type
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Named_Type_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Named_Type_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Named_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 40 LktNode.get_builtin_type Fld nodes.lkt:136







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 39 SymbolLiteral Sym nodes.lkt:136
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Symbol); 
--# expr-done 39
--# property-call-start LktNode.get_builtin_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Type (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 40

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Symbol_Type;
--# end

   







--# property-start LktNode.property_error_type nodes.lkt:140
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Property_Error_Type
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Named_Type_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Named_Type_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Named_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 42 LktNode.get_builtin_type Fld nodes.lkt:141







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 41 SymbolLiteral Sym nodes.lkt:141
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Propertyerror); 
--# expr-done 41
--# property-call-start LktNode.get_builtin_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Type (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 42

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Property_Error_Type;
--# end

   







--# property-start LktNode.regexp_type nodes.lkt:145
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Regexp_Type
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Named_Type_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Named_Type_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Named_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 44 LktNode.get_builtin_type Fld nodes.lkt:145







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 43 SymbolLiteral Sym nodes.lkt:145
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Regexp); 
--# expr-done 43
--# property-call-start LktNode.get_builtin_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Type (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 44

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Regexp_Type;
--# end

   







--# property-start LktNode.entity_gen_type nodes.lkt:149
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Entity_Gen_Type
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Generic_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Generic_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Generic_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 46 LktNode.get_builtin_gen_decl Fld nodes.lkt:150







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 45 SymbolLiteral Sym nodes.lkt:150
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Entity); 
--# expr-done 45
--# property-call-start LktNode.get_builtin_gen_decl
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Gen_Decl (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 46

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Entity_Gen_Type;
--# end

   







--# property-start LktNode.entity_type nodes.lkt:154
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Entity_Type
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Named_Type_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Named_Type_Decl;

      

      Fld : Internal_Entity_Generic_Decl;
Fld_1 : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Named_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 49 Cast Cast_Result nodes.lkt:155





--# expr-start 48 GenericDecl.decl Fld_1 nodes.lkt:155



--# expr-start 47 LktNode.entity_gen_type Fld nodes.lkt:155







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_gen_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Entity_Gen_Type (Node => Self);
--# end
--# expr-done 47



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Decl (Node => Fld.Node.Generic_Decl_F_Decl, Info => Fld.Info);
--# expr-done 48



   if Fld_1.Node = null
      or else Fld_1.Node.Kind in Lkt_Named_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Named_Type_Decl
        (Node => Fld_1.Node,
         Info => Fld_1.Info);

   else
         Cast_Result := No_Entity_Named_Type_Decl;
   end if;


--# expr-done 49

         Property_Result := Cast_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Entity_Type;
--# end

   







--# property-start LktNode.logicvar_type nodes.lkt:159
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Logicvar_Type
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Named_Type_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Named_Type_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Named_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 51 LktNode.get_builtin_type Fld nodes.lkt:160







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 50 SymbolLiteral Sym nodes.lkt:160
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Logicvar); 
--# expr-done 50
--# property-call-start LktNode.get_builtin_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Type (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 51

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Logicvar_Type;
--# end

   







--# property-start LktNode.equation_type nodes.lkt:164
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Equation_Type
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Named_Type_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Named_Type_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Named_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 53 LktNode.get_builtin_type Fld nodes.lkt:165







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 52 SymbolLiteral Sym nodes.lkt:165
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Equation); 
--# expr-done 52
--# property-call-start LktNode.get_builtin_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Type (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 53

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Equation_Type;
--# end

   







--# property-start LktNode.array_gen_type nodes.lkt:169
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Array_Gen_Type
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Generic_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Generic_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Generic_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 55 LktNode.get_builtin_gen_decl Fld nodes.lkt:170







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 54 SymbolLiteral Sym nodes.lkt:170
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Array); 
--# expr-done 54
--# property-call-start LktNode.get_builtin_gen_decl
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Gen_Decl (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 55

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Array_Gen_Type;
--# end

   







--# property-start LktNode.array_type nodes.lkt:174
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Array_Type
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Named_Type_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Named_Type_Decl;

      

      Fld : Internal_Entity_Generic_Decl;
Fld_1 : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Named_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 58 Cast Cast_Result nodes.lkt:175





--# expr-start 57 GenericDecl.decl Fld_1 nodes.lkt:175



--# expr-start 56 LktNode.array_gen_type Fld nodes.lkt:175







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.array_gen_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Array_Gen_Type (Node => Self);
--# end
--# expr-done 56



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Decl (Node => Fld.Node.Generic_Decl_F_Decl, Info => Fld.Info);
--# expr-done 57



   if Fld_1.Node = null
      or else Fld_1.Node.Kind in Lkt_Named_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Named_Type_Decl
        (Node => Fld_1.Node,
         Info => Fld_1.Info);

   else
         Cast_Result := No_Entity_Named_Type_Decl;
   end if;


--# expr-done 58

         Property_Result := Cast_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Array_Type;
--# end

   







--# property-start LktNode.astlist_gen_type nodes.lkt:179
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Astlist_Gen_Type
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Generic_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Generic_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Generic_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 60 LktNode.get_builtin_gen_decl Fld nodes.lkt:180







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 59 SymbolLiteral Sym nodes.lkt:180
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Astlist); 
--# expr-done 59
--# property-call-start LktNode.get_builtin_gen_decl
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Gen_Decl (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 60

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Astlist_Gen_Type;
--# end

   







--# property-start LktNode.astlist_type nodes.lkt:184
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Astlist_Type
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Named_Type_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Named_Type_Decl;

      

      Fld : Internal_Entity_Generic_Decl;
Fld_1 : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Named_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 63 Cast Cast_Result nodes.lkt:185





--# expr-start 62 GenericDecl.decl Fld_1 nodes.lkt:185



--# expr-start 61 LktNode.astlist_gen_type Fld nodes.lkt:185







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.astlist_gen_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Astlist_Gen_Type (Node => Self);
--# end
--# expr-done 61



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Decl (Node => Fld.Node.Generic_Decl_F_Decl, Info => Fld.Info);
--# expr-done 62



   if Fld_1.Node = null
      or else Fld_1.Node.Kind in Lkt_Named_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Named_Type_Decl
        (Node => Fld_1.Node,
         Info => Fld_1.Info);

   else
         Cast_Result := No_Entity_Named_Type_Decl;
   end if;


--# expr-done 63

         Property_Result := Cast_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Astlist_Type;
--# end

   







--# property-start LktNode.node_builder_gen_type nodes.lkt:189
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Node_Builder_Gen_Type
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Generic_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Generic_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Generic_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 65 LktNode.get_builtin_gen_decl Fld nodes.lkt:190







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 64 SymbolLiteral Sym nodes.lkt:190
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Nodebuilder); 
--# expr-done 64
--# property-call-start LktNode.get_builtin_gen_decl
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Gen_Decl (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 65

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Node_Builder_Gen_Type;
--# end

   







--# property-start LktNode.node_builder_type nodes.lkt:194
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Node_Builder_Type
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Named_Type_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Named_Type_Decl;

      

      Fld : Internal_Entity_Generic_Decl;
Fld_1 : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Named_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 68 Cast Cast_Result nodes.lkt:195





--# expr-start 67 GenericDecl.decl Fld_1 nodes.lkt:195



--# expr-start 66 LktNode.node_builder_gen_type Fld nodes.lkt:195







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.node_builder_gen_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Node_Builder_Gen_Type (Node => Self);
--# end
--# expr-done 66



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Decl (Node => Fld.Node.Generic_Decl_F_Decl, Info => Fld.Info);
--# expr-done 67



   if Fld_1.Node = null
      or else Fld_1.Node.Kind in Lkt_Named_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Named_Type_Decl
        (Node => Fld_1.Node,
         Info => Fld_1.Info);

   else
         Cast_Result := No_Entity_Named_Type_Decl;
   end if;


--# expr-done 68

         Property_Result := Cast_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Node_Builder_Type;
--# end

   







--# property-start LktNode.iterator_gen_trait nodes.lkt:199
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Iterator_Gen_Trait
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Generic_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Generic_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Generic_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 70 LktNode.get_builtin_gen_decl Fld nodes.lkt:200







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 69 SymbolLiteral Sym nodes.lkt:200
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Iterator); 
--# expr-done 69
--# property-call-start LktNode.get_builtin_gen_decl
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Gen_Decl (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 70

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Iterator_Gen_Trait;
--# end

   







--# property-start LktNode.iterator_trait nodes.lkt:204
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Iterator_Trait
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Trait_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Trait_Decl;

      

      Fld : Internal_Entity_Generic_Decl;
Fld_1 : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Trait_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 73 Cast Cast_Result nodes.lkt:205





--# expr-start 72 GenericDecl.decl Fld_1 nodes.lkt:205



--# expr-start 71 LktNode.iterator_gen_trait Fld nodes.lkt:205







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.iterator_gen_trait
Fld := Liblktlang.Implementation.Lkt_Node_P_Iterator_Gen_Trait (Node => Self);
--# end
--# expr-done 71



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Decl (Node => Fld.Node.Generic_Decl_F_Decl, Info => Fld.Info);
--# expr-done 72



   if Fld_1.Node = null
      or else Fld_1.Node.Kind in Lkt_Trait_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Trait_Decl
        (Node => Fld_1.Node,
         Info => Fld_1.Info);

   else
         Cast_Result := No_Entity_Trait_Decl;
   end if;


--# expr-done 73

         Property_Result := Cast_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Iterator_Trait;
--# end

   







--# property-start LktNode.analysis_unit_gen_trait nodes.lkt:209
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Analysis_Unit_Gen_Trait
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Generic_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Generic_Decl;

      

      Sym : Symbol_Type;
Fld : Internal_Entity_Generic_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 75 LktNode.get_builtin_gen_decl Fld nodes.lkt:210







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 74 SymbolLiteral Sym nodes.lkt:210
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Analysisunit); 
--# expr-done 74
--# property-call-start LktNode.get_builtin_gen_decl
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Gen_Decl (Node => Self, Entity_Name => Sym);
--# end
--# expr-done 75

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Analysis_Unit_Gen_Trait;
--# end

   







--# property-start LktNode.analysis_unit_trait nodes.lkt:214
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Analysis_Unit_Trait
  
  (Node : Bare_Lkt_Node
  )

   return Internal_Entity_Trait_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Internal_Entity_Trait_Decl;

      

      Fld : Internal_Entity_Generic_Decl;
Fld_1 : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Trait_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 78 Cast Cast_Result nodes.lkt:215





--# expr-start 77 GenericDecl.decl Fld_1 nodes.lkt:215



--# expr-start 76 LktNode.analysis_unit_gen_trait Fld nodes.lkt:215







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.analysis_unit_gen_trait
Fld := Liblktlang.Implementation.Lkt_Node_P_Analysis_Unit_Gen_Trait (Node => Self);
--# end
--# expr-done 76



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Decl (Node => Fld.Node.Generic_Decl_F_Decl, Info => Fld.Info);
--# expr-done 77



   if Fld_1.Node = null
      or else Fld_1.Node.Kind in Lkt_Trait_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Trait_Decl
        (Node => Fld_1.Node,
         Info => Fld_1.Info);

   else
         Cast_Result := No_Entity_Trait_Decl;
   end if;


--# expr-done 78

         Property_Result := Cast_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Analysis_Unit_Trait;
--# end

   







--# property-start LktNode.get_empty_type_ref_list nodes.lkt:219
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Get_Empty_Type_Ref_List
  
  (Node : Bare_Lkt_Node
  )

   return Bare_Synthetic_Type_Ref_List
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Bare_Synthetic_Type_Ref_List;

      

      Fld : Internal_Unit;
Fld_1 : Bare_Lkt_Node;
Cast_Result : Bare_Langkit_Root;
Fld_2 : Bare_Synthetic_Type_Ref_List;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 82 LangkitRoot.empty_type_ref_list Fld_2 nodes.lkt:220



--# expr-start 81 Cast Cast_Result nodes.lkt:220





--# expr-start 80 AnalysisUnit.root Fld_1 nodes.lkt:220



--# expr-start 79 LktNode.unit Fld nodes.lkt:220







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Unit (Node => Self);
--# expr-done 79



   if Fld = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Fld.Ast_Root;
--# expr-done 80



   if Fld_1 = null
      or else Fld_1.Kind in Lkt_Langkit_Root_Range
   then
      
      Cast_Result := Fld_1;

   else
         Cast_Result := No_Bare_Lkt_Node;
   end if;


--# expr-done 81



   if Cast_Result = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LangkitRoot.empty_type_ref_list
Fld_2 := Liblktlang.Implementation.Langkit_Root_F_Empty_Type_Ref_List (Node => Cast_Result);
--# end
--# expr-done 82

         Property_Result := Fld_2;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Get_Empty_Type_Ref_List;
--# end

   







--# property-start LktNode.any_type nodes.lkt:224
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Any_Type
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;

      

      Fld : Bare_Synthetic_Type_Ref_List;
New_Node : Bare_Any_Type_Decl;
As_Entity : Internal_Entity_Any_Type_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Any_Type_Decl;
Cast_Result : Internal_Entity_Type_Decl;


      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Lkt_Node_Lkt_Node_P_Any_Type,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Lkt_Node,
                                As_Bare_Lkt_Node => Self);
               Mmz_K.Items (2) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Entity_Type_Decl;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         




--# expr-start 85 .as_entity If_Result nodes.lkt:225



--# expr-start 84 'New[AnyTypeDecl]' New_Node nodes.lkt:225
--# expr-start 83 LktNode.get_empty_type_ref_list Fld nodes.lkt:225







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.get_empty_type_ref_list
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Empty_Type_Ref_List (Node => Self);
--# end
--# expr-done 83


if Is_Foreign_Strict (Self.Self_Env, Self) then
   Raise_Property_Exception
     (Self,
      Property_Error'Identity,
      "synthetic nodes cannot have foreign lexical envs");
end if;


New_Node := new Root_Node_Record
  (Lkt_Any_Type_Decl);
Initialize
  (Self => New_Node,
   Kind => Lkt_Any_Type_Decl,
   Unit => Self.Unit,

   Token_Start_Index => No_Token_Index,
   Token_End_Index   => No_Token_Index,

   Parent => Self,

   Self_Env => Self.Self_Env);
Register_Destroyable (Self.Unit, New_Node);

   Initialize_Fields_For_Any_Type_Decl
     (Self => New_Node,
      Any_Type_Decl_F_Traits => Fld);


--# expr-done 84
Is_Null := New_Node = null; 
if Is_Null then
   
   If_Result := No_Entity_Any_Type_Decl;
else
   

As_Entity := (Info => E_Info, Node => New_Node); 
   If_Result := As_Entity;
end if;



--# expr-done 85



   
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => If_Result.Node,
         Info => If_Result.Info);



         Property_Result := Cast_Result;
         
   --# end


      exception
         when Exc : Property_Error =>


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Entity_Type_Decl,
                     As_Internal_Entity_Type_Decl => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Lkt_Node_P_Any_Type;
--# end

   







--# property-start LktNode.topmost_invalid_decl nodes.lkt:234
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Topmost_Invalid_Decl
  
  (Node : Bare_Lkt_Node
  )

   return Bare_Lkt_Node
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   


   Property_Result : Bare_Lkt_Node;

      
            procedure Finalizer_Scope_57 with Inline_Always;

      Node_Parents : Bare_Lkt_Node_Array_Access;
Cast_Result : Bare_Full_Decl;
Var_Expr : Bare_Full_Decl;
Sym : Symbol_Type;
Fld : Boolean;
Scope_Result : Boolean;
Result_Var : Boolean;
Map_Result : Bare_Lkt_Node_Array_Access;
Neg : Integer;
Get_Result : Bare_Lkt_Node;

            procedure Finalizer_Scope_57 is
            begin
                     Dec_Ref (Node_Parents);
                     Dec_Ref (Map_Result);
            end Finalizer_Scope_57;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 93 .at Get_Result nodes.lkt:235

--# expr-start 91 .filter Map_Result nodes.lkt:235








   

   --# expr-start 86 LktNode.parents Node_Parents nodes.lkt:235







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



Node_Parents := Parents (Self, True); 
--# expr-done 86

   
      declare
         Map_Result_Vec : Bare_Lkt_Node_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Bare_Lkt_Node_Array_Access := Node_Parents;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind p Item

            
         --# expr-start 90 .do Result_Var nodes.lkt:236



--# expr-start 87 Cast Cast_Result nodes.lkt:236









   if Item = null
      or else Item.Kind in Lkt_Full_Decl_Range
   then
      
      Cast_Result := Item;

   else
         Cast_Result := No_Bare_Lkt_Node;
   end if;


--# expr-done 87
Var_Expr := Cast_Result;





if Var_Expr /= No_Bare_Lkt_Node then
   



   --# scope-start



--# expr-start 89 FullDecl.has_annotation Fld nodes.lkt:236







   if Var_Expr = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 88 SymbolLiteral Sym nodes.lkt:236
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Invalid); 
--# expr-done 88
--# property-call-start FullDecl.has_annotation
Fld := Liblktlang.Implementation.Full_Decl_P_Has_Annotation (Node => Var_Expr, Name => Sym);
--# end
--# expr-done 89
Scope_Result := Fld;


   --# end


   Result_Var := Scope_Result;
else
   
   Result_Var := False;
end if;



--# expr-done 90
         if Result_Var then
            
         
      
      

         declare
            Item_To_Append : constant Bare_Lkt_Node := Item;
         begin
            Bare_Lkt_Node_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
         end if;
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result := Create_Bare_Lkt_Node_Array
           (Items_Count => Natural (Bare_Lkt_Node_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Bare_Lkt_Node_Vectors.Get
              (Map_Result_Vec,
               I + Bare_Lkt_Node_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Bare_Lkt_Node_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 91
--# expr-start 92 UnaryNeg Neg nodes.lkt:237

Neg := -1; 
--# expr-done 92

Get_Result := Get (Self, Map_Result, Neg, True); 
--# expr-done 93

         Property_Result := Get_Result;
         
   --# end
      Finalizer_Scope_57;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_57;




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Topmost_Invalid_Decl;
--# end

   







--# property-start LktNode.nameres_diagnostics nodes.lkt:242
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Nameres_Diagnostics
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Solver_Diagnostic_Array_Access
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Solver_Diagnostic_Array_Access;

      
            procedure Finalizer_Scope_58 with Inline_Always;

      Fld : Internal_Solver_Result := No_Solver_Result;
Fld_1 : Internal_Solver_Diagnostic_Array_Access;

            procedure Finalizer_Scope_58 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_58;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 95 SolverResult.diagnostics Fld_1 nodes.lkt:244



--# expr-start 94 LktNode.solve_equation Fld nodes.lkt:244







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.solve_equation
Fld := Liblktlang.Implementation.Lkt_Node_P_Solve_Equation (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 94





Fld_1 := Fld.Diagnostics;
Inc_Ref (Fld_1);
--# expr-done 95

         Property_Result := Fld_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_58;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_58;




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Nameres_Diagnostics;
--# end

   







--# property-start LktNode.solve_equation nodes.lkt:250
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Solve_Equation
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Solver_Result
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Solver_Result;

      
            procedure Finalizer_Scope_59 with Inline_Always;

      Fld : Logic_Equation;
Solve_Success : Internal_Solver_Result := No_Solver_Result;

            procedure Finalizer_Scope_59 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Solve_Success);
            end Finalizer_Scope_59;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Lkt_Node_Lkt_Node_P_Solve_Equation,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Lkt_Node,
                                As_Bare_Lkt_Node => Self);
               Mmz_K.Items (2) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Solver_Result;
                  Inc_Ref (Property_Result);

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 97 .solve_with_diagnostics Solve_Success nodes.lkt:251
--# expr-start 96 LktNode.xref_equation Fld nodes.lkt:251







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 96

Solve_Success := Solve_With_Diagnostics (Fld, Self); 
--# expr-done 97

         Property_Result := Solve_Success;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_59;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_59;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Solver_Result,
                     As_Internal_Solver_Result => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
            if Mmz_Stored then
               Inc_Ref (Property_Result);
            end if;
      end if;



   return Property_Result;
end Lkt_Node_P_Solve_Equation;
--# end

   







--# property-start LktNode.solve_enclosing_context nodes.lkt:258
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Solve_Enclosing_Context
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Solver_Result
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Solver_Result;

      
            procedure Finalizer_Scope_60 with Inline_Always;
            procedure Finalizer_Scope_456 with Inline_Always;

      Fld : Internal_Entity_Array_Access;
Fld_1 : Boolean;
Find_Result : Internal_Entity;
Local_Enclosing_Context : Internal_Entity;
Var_Expr : Internal_Entity;
Fld_2 : Internal_Solver_Result := No_Solver_Result;
Result_Var : Internal_Solver_Result := No_Solver_Result;
Let_Result : Internal_Solver_Result := No_Solver_Result;
Scope_Result : Internal_Solver_Result := No_Solver_Result;

            procedure Finalizer_Scope_60 is
            begin
                     Dec_Ref (Scope_Result);
            end Finalizer_Scope_60;
            procedure Finalizer_Scope_456 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Fld_2);
                     Dec_Ref (Result_Var);
                     Dec_Ref (Let_Result);
            end Finalizer_Scope_456;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Lkt_Node_Lkt_Node_P_Solve_Enclosing_Context,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Lkt_Node,
                                As_Bare_Lkt_Node => Self);
               Mmz_K.Items (2) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Solver_Result;
                  Inc_Ref (Property_Result);

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 102 ValDecl Let_Result nodes.lkt:259
--# scope-start
--# expr-start 100 .find Find_Result nodes.lkt:260








   

   --# expr-start 98 LktNode.parents Fld nodes.lkt:260







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



Fld := Liblktlang.Implementation.Parents (Node => Ent.Node, With_Self => True, E_Info => Ent.Info);
--# expr-done 98

   
      Find_Result := No_Entity;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind p Item

            
      --# expr-start 99 LktNode.xref_entry_point Fld_1 nodes.lkt:260







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_entry_point'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Entry_Point (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 99
      if Fld_1 then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Fld_1;

         end loop;
      end;
   

   
   



--# expr-done 100
Local_Enclosing_Context := Find_Result; 
--# bind enclosing_context Local_Enclosing_Context




Var_Expr := Local_Enclosing_Context;





if Var_Expr /= No_Entity then
   --# expr-start 101 LktNode.solve_equation Fld_2 nodes.lkt:262







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.solve_equation
Fld_2 := Liblktlang.Implementation.Lkt_Node_P_Solve_Equation (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 101
   Result_Var := Fld_2;
else
   
   Result_Var := No_Solver_Result;
end if;

      Inc_Ref (Result_Var);


Let_Result := Result_Var; Inc_Ref (Let_Result);
--# end
--# expr-done 102
Scope_Result := Let_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_456;



         Property_Result := Scope_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_60;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_60;
                     Finalizer_Scope_456;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Solver_Result,
                     As_Internal_Solver_Result => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
            if Mmz_Stored then
               Inc_Ref (Property_Result);
            end if;
      end if;



   return Property_Result;
end Lkt_Node_P_Solve_Enclosing_Context;
--# end

   







--# property-start LktNode.expected_type_entry_point nodes.lkt:265
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Expected_Type_Entry_Point
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Ignored : Internal_Entity_Cast_Expr;
Ignored_1 : Internal_Entity_Isa;
Ignored_2 : Internal_Entity_Match_Expr;
Ignored_3 : Internal_Entity_Dot_Expr;
Ignored_4 : Internal_Entity_Base_Call_Expr;
Ignored_5 : Internal_Entity_Logic_Propagate;
Local_P : Internal_Entity_Paren_Expr;
Fld : Internal_Entity;
Fld_1 : Boolean;
Local_P_1 : Internal_Entity_Lambda_Expr;
Fld_2 : Boolean;
Ignored_6 : Internal_Entity;
Match_Prefix : Internal_Entity;
Cast_Result : Internal_Entity_Cast_Expr;
Let_Result : Boolean;
Scope_Result : Boolean;
Cast_Result_1 : Internal_Entity_Isa;
Let_Result_1 : Boolean;
Scope_Result_1 : Boolean;
Cast_Result_2 : Internal_Entity_Match_Expr;
Let_Result_2 : Boolean;
Scope_Result_2 : Boolean;
Cast_Result_3 : Internal_Entity_Dot_Expr;
Let_Result_3 : Boolean;
Scope_Result_3 : Boolean;
Cast_Result_4 : Internal_Entity_Base_Call_Expr;
Let_Result_4 : Boolean;
Scope_Result_4 : Boolean;
Cast_Result_5 : Internal_Entity_Logic_Propagate;
Let_Result_5 : Boolean;
Scope_Result_5 : Boolean;
Cast_Result_6 : Internal_Entity_Paren_Expr;
Let_Result_6 : Boolean;
Scope_Result_6 : Boolean;
Cast_Result_7 : Internal_Entity_Lambda_Expr;
Let_Result_7 : Boolean;
Scope_Result_7 : Boolean;
Cast_Result_8 : Internal_Entity;
Let_Result_8 : Boolean;
Scope_Result_8 : Boolean;
Match_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 106 Match Match_Result nodes.lkt:265










   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := Ent; 

case Lkt_Lkt_Node (Match_Prefix.Node.Kind) is
         when Lkt_Cast_Expr =>
            



   --# scope-start



--# scope-start









   
      Cast_Result := Create_Internal_Entity_Cast_Expr
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored := Cast_Result; 
--# bind _ Ignored

Let_Result := True; 
--# end
Scope_Result := Let_Result;


   --# end


            Match_Result := Scope_Result; 
         when Lkt_Isa =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_1 := Create_Internal_Entity_Isa
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_1 := Cast_Result_1; 
--# bind _ Ignored_1

Let_Result_1 := True; 
--# end
Scope_Result_1 := Let_Result_1;


   --# end


            Match_Result := Scope_Result_1; 
         when Lkt_Match_Expr =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_2 := Create_Internal_Entity_Match_Expr
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_2 := Cast_Result_2; 
--# bind _ Ignored_2

Let_Result_2 := True; 
--# end
Scope_Result_2 := Let_Result_2;


   --# end


            Match_Result := Scope_Result_2; 
         when Lkt_Dot_Expr =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_3 := Create_Internal_Entity_Dot_Expr
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_3 := Cast_Result_3; 
--# bind _ Ignored_3

Let_Result_3 := True; 
--# end
Scope_Result_3 := Let_Result_3;


   --# end


            Match_Result := Scope_Result_3; 
         when Lkt_Call_Expr .. Lkt_Logic_Propagate_Call =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_4 := Create_Internal_Entity_Base_Call_Expr
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_4 := Cast_Result_4; 
--# bind _ Ignored_4

Let_Result_4 := True; 
--# end
Scope_Result_4 := Let_Result_4;


   --# end


            Match_Result := Scope_Result_4; 
         when Lkt_Logic_Propagate =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_5 := Create_Internal_Entity_Logic_Propagate
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_5 := Cast_Result_5; 
--# bind _ Ignored_5

Let_Result_5 := True; 
--# end
Scope_Result_5 := Let_Result_5;


   --# end


            Match_Result := Scope_Result_5; 
         when Lkt_Paren_Expr =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_6 := Create_Internal_Entity_Paren_Expr
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_P := Cast_Result_6; 
--# bind p Local_P
--# expr-start 104 LktNode.expected_type_entry_point Fld_1 nodes.lkt:272



--# expr-start 103 .parent Fld nodes.lkt:272







   if Local_P.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Parent (Node => Local_P.Node, E_Info => Local_P.Info);
--# expr-done 103



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.expected_type_entry_point
Fld_1 := Liblktlang.Implementation.Lkt_Node_P_Expected_Type_Entry_Point (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 104
Let_Result_6 := Fld_1; 
--# end
Scope_Result_6 := Let_Result_6;


   --# end


            Match_Result := Scope_Result_6; 
         when Lkt_Lambda_Expr =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_7 := Create_Internal_Entity_Lambda_Expr
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_P_1 := Cast_Result_7; 
--# bind p Local_P_1
--# expr-start 105 Expr.xref_entry_point Fld_2 nodes.lkt:273







   if Local_P_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_entry_point'
Fld_2 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Entry_Point (Node => Local_P_1.Node, E_Info => Local_P_1.Info);
--# end
--# expr-done 105
Let_Result_7 := Fld_2; 
--# end
Scope_Result_7 := Let_Result_7;


   --# end


            Match_Result := Scope_Result_7; 
         when Lkt_Argument .. Lkt_Array_Literal | Lkt_Bin_Op .. Lkt_Block_Expr | Lkt_Error_On_Null .. Lkt_If_Expr | Lkt_Keep_Expr | Lkt_Big_Num_Lit .. Lkt_Logic_Expr | Lkt_Logic_Unify | Lkt_Not_Expr | Lkt_Query .. Lkt_Var_Bind =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_8 := Create_Internal_Entity
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_6 := Cast_Result_8; 
--# bind _ Ignored_6

Let_Result_8 := False; 
--# end
Scope_Result_8 := Let_Result_8;


   --# end


            Match_Result := Scope_Result_8; 
end case;

--# expr-done 106

         Property_Result := Match_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Expected_Type_Entry_Point;
--# end

   







--# property-start LktNode.solve_expected_types nodes.lkt:279
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Solve_Expected_Types
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      
            procedure Finalizer_Scope_62 with Inline_Always;

      Fld : Logic_Equation;
Solve_Success : Boolean;

            procedure Finalizer_Scope_62 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_62;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Lkt_Node_Lkt_Node_P_Solve_Expected_Types,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Lkt_Node,
                                As_Bare_Lkt_Node => Self);
               Mmz_K.Items (2) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Boolean;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 108 .solve Solve_Success nodes.lkt:279
--# expr-start 107 LktNode.expected_type_equation Fld nodes.lkt:279







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.expected_type_equation'
Fld := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Expected_Type_Equation (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 107

Solve_Success := Solve_Wrapper (Fld, Self); 
--# expr-done 108

         Property_Result := Solve_Success;
         
   --# end
      Finalizer_Scope_62;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_62;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Boolean,
                     As_Boolean => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Lkt_Node_P_Solve_Expected_Types;
--# end

   







--# property-start LktNode.generic_type_entry_point nodes.lkt:281
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Generic_Type_Entry_Point
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Is_A : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 109 IsA Is_A nodes.lkt:282

Is_A := Ent.Node /= null 
and then Ent.Node.Kind in Lkt_Base_Call_Expr; 
--# expr-done 109

         Property_Result := Is_A;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Generic_Type_Entry_Point;
--# end

   







--# property-start LktNode.solve_generic_types nodes.lkt:286
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Solve_Generic_Types
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      
            procedure Finalizer_Scope_64 with Inline_Always;

      Fld : Logic_Equation;
Solve_Success : Boolean;

            procedure Finalizer_Scope_64 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_64;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Lkt_Node_Lkt_Node_P_Solve_Generic_Types,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Lkt_Node,
                                As_Bare_Lkt_Node => Self);
               Mmz_K.Items (2) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Boolean;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 111 .solve Solve_Success nodes.lkt:286
--# expr-start 110 LktNode.generic_type_equation Fld nodes.lkt:286







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.generic_type_equation'
Fld := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Generic_Type_Equation (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 110

Solve_Success := Solve_Wrapper (Fld, Self); 
--# expr-done 111

         Property_Result := Solve_Success;
         
   --# end
      Finalizer_Scope_64;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_64;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Boolean,
                     As_Boolean => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Lkt_Node_P_Solve_Generic_Types;
--# end

   







--# property-start LktNode.function_type_helper nodes.lkt:290
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Function_Type_Helper
  
  (Node : Bare_Lkt_Node
      ; Param_Types : Internal_Entity_Type_Decl_Array_Access
      ; Return_Type : Internal_Entity_Type_Decl
      ; Origin : Internal_Entity_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Function_Type
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind param_types Param_Types
   --# bind return_type Return_Type
   --# bind origin Origin

   Property_Result : Internal_Entity_Function_Type;

      

      Fld : Bare_Synthetic_Type_Ref_List;
New_Node : Bare_Function_Type;
As_Entity : Internal_Entity_Function_Type;
Is_Null : Boolean;
If_Result : Internal_Entity_Function_Type;
Cast_Result : Internal_Entity;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result_1 : Internal_Entity;
Is_Equiv : Boolean;
Quantifier_Result : Boolean;
Is_Null_1 : Boolean;
If_Result_1 : Boolean;
If_Result_2 : Internal_Entity_Function_Type;


      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Lkt_Node_Lkt_Node_P_Function_Type_Helper,
            Items    => new Mmz_Key_Array (1 ..  5))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Lkt_Node,
                                As_Bare_Lkt_Node => Self);
               Mmz_K.Items (2) := (Kind => Mmz_Internal_Entity_Type_Decl_Array_Access,
                                      As_Internal_Entity_Type_Decl_Array_Access => Param_Types);
                  Inc_Ref (Mmz_K.Items (2).As_Internal_Entity_Type_Decl_Array_Access);
               Mmz_K.Items (3) := (Kind => Mmz_Internal_Entity_Type_Decl,
                                      As_Internal_Entity_Type_Decl => Return_Type);
               Mmz_K.Items (4) := (Kind => Mmz_Internal_Entity_Decl,
                                      As_Internal_Entity_Decl => Origin);
               Mmz_K.Items (5) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Entity_Function_Type;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 118 If If_Result_2 nodes.lkt:295



--# expr-start 114 BooleanOr If_Result_1 nodes.lkt:295



--# expr-start 112 .contains Quantifier_Result nodes.lkt:295








   

   

   
      Quantifier_Result := False;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Type_Decl_Array_Access := Param_Types;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start



            
      








   
      Cast_Result := Create_Internal_Entity
        (Node => Item.Node,
         Info => Item.Info);








Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Is_Equiv := Equivalent (Cast_Result, Cast_Result_1); 
      Quantifier_Result := Is_Equiv;
   

            
   --# end


               exit when Quantifier_Result;

         end loop;
      end;
   

   
   



--# expr-done 112
if Quantifier_Result then
   
   If_Result_1 := True;
else
   --# expr-start 113 .is_null Is_Null_1 nodes.lkt:295

Is_Null_1 := Return_Type.Node = null; 
--# expr-done 113
   If_Result_1 := Is_Null_1;
end if;



--# expr-done 114
if If_Result_1 then
   
   If_Result_2 := No_Entity_Function_Type;
else
   --# expr-start 117 .as_entity If_Result nodes.lkt:298



--# expr-start 116 'New[FunctionType]' New_Node nodes.lkt:298



--# expr-start 115 LktNode.get_empty_type_ref_list Fld nodes.lkt:302







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.get_empty_type_ref_list
Fld := Liblktlang.Implementation.Lkt_Node_P_Get_Empty_Type_Ref_List (Node => Self);
--# end
--# expr-done 115
Inc_Ref (Param_Types);


if Is_Foreign_Strict (Self.Self_Env, Self) then
   Raise_Property_Exception
     (Self,
      Property_Error'Identity,
      "synthetic nodes cannot have foreign lexical envs");
end if;


New_Node := new Root_Node_Record
  (Lkt_Function_Type);
Initialize
  (Self => New_Node,
   Kind => Lkt_Function_Type,
   Unit => Self.Unit,

   Token_Start_Index => No_Token_Index,
   Token_End_Index   => No_Token_Index,

   Parent => Self,

   Self_Env => Self.Self_Env);
Register_Destroyable (Self.Unit, New_Node);

   Initialize_Fields_For_Function_Type
     (Self => New_Node,
      Function_Type_F_Traits => Fld);

      New_Node.Function_Type_F_Origin :=
         Origin;
      New_Node.Function_Type_F_Params :=
         Param_Types;
      New_Node.Function_Type_F_Return_Type :=
         Return_Type;

--# expr-done 116
Is_Null := New_Node = null; 
if Is_Null then
   
   If_Result := No_Entity_Function_Type;
else
   

As_Entity := (Info => E_Info, Node => New_Node); 
   If_Result := As_Entity;
end if;



--# expr-done 117
   If_Result_2 := If_Result;
end if;



--# expr-done 118

         Property_Result := If_Result_2;
         
   --# end


      exception
         when Exc : Property_Error =>


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Entity_Function_Type,
                     As_Internal_Entity_Function_Type => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Lkt_Node_P_Function_Type_Helper;
--# end

   







--# property-start LktNode.shed_rebindings nodes.lkt:308
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Shed_Rebindings
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity;

      
            procedure Finalizer_Scope_67 with Inline_Always;

      Fld : Lexical_Env := Empty_Env;
Fld_1 : Internal_Entity_Info;
Shed_Entity_Info : Internal_Entity_Info;
New_Struct : Internal_Entity;

            procedure Finalizer_Scope_67 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_67;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 122 'New[Entity[LktNode]]' New_Struct nodes.lkt:309
--# expr-start 121 .shed_rebindings Shed_Entity_Info nodes.lkt:311
--# expr-start 119 'Entity[LktNode].info' Fld_1 nodes.lkt:311









Fld_1 := Ent.Info;
--# expr-done 119
--# expr-start 120 LktNode.children_env Fld nodes.lkt:311







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Children_Env (Node => Self);
--# expr-done 120
Shed_Entity_Info := AST_Envs.Shed_Rebindings (Fld_1, Fld); 
--# expr-done 121

New_Struct := (Info => Shed_Entity_Info, Node => Self); 
--# expr-done 122

         Property_Result := New_Struct;
         
   --# end
      Finalizer_Scope_67;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_67;




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Shed_Rebindings;
--# end

   







--# property-start '[dispatcher]LktNode.xref_entry_point' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Lkt_Node_P_Xref_Entry_Point
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Lkt_Node (Self.Kind) is
               when Lkt_Argument .. Lkt_Self_Decl | Lkt_Error_Decl .. Lkt_Trait_Decl | Lkt_Decl_Annotation_Args .. Lkt_Excludes_Null_Present | Lkt_Full_Decl .. Lkt_Selector_Call =>
                  --# property-call-start 'LktNode.[root-static]xref_entry_point'
                  Property_Result := Lkt_Node_P_Xref_Entry_Point
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Field_Decl .. Lkt_Lambda_Param_Decl | Lkt_Val_Decl .. Lkt_Fun_Decl =>
                  --# property-call-start UserValDecl.xref_entry_point
                  Property_Result := User_Val_Decl_P_Xref_Entry_Point
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Binding_Val_Decl =>
                  --# property-call-start BindingValDecl.xref_entry_point
                  Property_Result := Binding_Val_Decl_P_Xref_Entry_Point
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Enum_Lit_Decl =>
                  --# property-call-start EnumLitDecl.xref_entry_point
                  Property_Result := Enum_Lit_Decl_P_Xref_Entry_Point
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Dyn_Var_Decl =>
                  --# property-call-start DynVarDecl.xref_entry_point
                  Property_Result := Dyn_Var_Decl_P_Xref_Entry_Point
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Match_Val_Decl =>
                  --# property-call-start MatchValDecl.xref_entry_point
                  Property_Result := Match_Val_Decl_P_Xref_Entry_Point
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Env_Spec_Decl =>
                  --# property-call-start EnvSpecDecl.xref_entry_point
                  Property_Result := Env_Spec_Decl_P_Xref_Entry_Point
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Decl_Annotation =>
                  --# property-call-start DeclAnnotation.xref_entry_point
                  Property_Result := Decl_Annotation_P_Xref_Entry_Point
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Any_Of .. Lkt_Un_Op =>
                  --# property-call-start Expr.xref_entry_point
                  Property_Result := Expr_P_Xref_Entry_Point
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Default_List_Type_Ref .. Lkt_Simple_Type_Ref =>
                  --# property-call-start TypeRef.xref_entry_point
                  Property_Result := Type_Ref_P_Xref_Entry_Point
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Var_Bind =>
                  --# property-call-start VarBind.xref_entry_point
                  Property_Result := Var_Bind_P_Xref_Entry_Point
                    (Self
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Lkt_Node_P_Xref_Entry_Point;
--# end

   







--# property-start '[dispatcher]LktNode.xref_equation' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Lkt_Node_P_Xref_Equation
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Lkt_Node (Self.Kind) is
               when Lkt_Error_Lexer_Case_Rule_Alt .. Lkt_Enum_Lit_Decl | Lkt_Dyn_Var_Decl .. Lkt_Match_Val_Decl | Lkt_Error_Decl .. Lkt_Trait_Decl | Lkt_Decl_Annotation_Args .. Lkt_Excludes_Null_Present | Lkt_Error_Grammar_Expr .. Lkt_Module_Ref_Id | Lkt_Query | Lkt_Full_Decl .. Lkt_Default_List_Type_Ref =>
                  --# property-call-start 'LktNode.[root-static]xref_equation'
                  Property_Result := Lkt_Node_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Argument =>
                  --# property-call-start Argument.xref_equation
                  Property_Result := Argument_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Field_Decl .. Lkt_Lambda_Param_Decl =>
                  --# property-call-start ComponentDecl.xref_equation
                  Property_Result := Component_Decl_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Val_Decl =>
                  --# property-call-start ValDecl.xref_equation
                  Property_Result := Val_Decl_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Fun_Decl =>
                  --# property-call-start FunDecl.xref_equation
                  Property_Result := Fun_Decl_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Env_Spec_Decl =>
                  --# property-call-start EnvSpecDecl.xref_equation
                  Property_Result := Env_Spec_Decl_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Decl_Annotation =>
                  --# property-call-start DeclAnnotation.xref_equation
                  Property_Result := Decl_Annotation_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Any_Of =>
                  --# property-call-start AnyOf.xref_equation
                  Property_Result := Any_Of_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Array_Literal =>
                  --# property-call-start ArrayLiteral.xref_equation
                  Property_Result := Array_Literal_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Call_Expr | Lkt_Logic_Propagate_Call =>
                  --# property-call-start BaseCallExpr.xref_equation
                  Property_Result := Base_Call_Expr_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Logic_Predicate =>
                  --# property-call-start LogicPredicate.xref_equation
                  Property_Result := Logic_Predicate_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Bin_Op =>
                  --# property-call-start BinOp.xref_equation
                  Property_Result := Bin_Op_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Block_Expr =>
                  --# property-call-start BlockExpr.xref_equation
                  Property_Result := Block_Expr_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Cast_Expr =>
                  --# property-call-start CastExpr.xref_equation
                  Property_Result := Cast_Expr_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Dot_Expr =>
                  --# property-call-start DotExpr.xref_equation
                  Property_Result := Dot_Expr_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Error_On_Null =>
                  --# property-call-start ErrorOnNull.xref_equation
                  Property_Result := Error_On_Null_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Generic_Instantiation =>
                  --# property-call-start GenericInstantiation.xref_equation
                  Property_Result := Generic_Instantiation_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Ref_Id =>
                  --# property-call-start RefId.xref_equation
                  Property_Result := Ref_Id_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_If_Expr =>
                  --# property-call-start IfExpr.xref_equation
                  Property_Result := If_Expr_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Isa =>
                  --# property-call-start Isa.xref_equation
                  Property_Result := Isa_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Keep_Expr =>
                  --# property-call-start KeepExpr.xref_equation
                  Property_Result := Keep_Expr_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Lambda_Expr =>
                  --# property-call-start LambdaExpr.xref_equation
                  Property_Result := Lambda_Expr_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Big_Num_Lit =>
                  --# property-call-start BigNumLit.xref_equation
                  Property_Result := Big_Num_Lit_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Char_Lit =>
                  --# property-call-start CharLit.xref_equation
                  Property_Result := Char_Lit_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Null_Lit =>
                  --# property-call-start NullLit.xref_equation
                  Property_Result := Null_Lit_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Num_Lit =>
                  --# property-call-start NumLit.xref_equation
                  Property_Result := Num_Lit_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Block_String_Lit .. Lkt_Pattern_Single_Line_String_Lit =>
                  --# property-call-start StringLit.xref_equation
                  Property_Result := String_Lit_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Logic_Assign =>
                  --# property-call-start LogicAssign.xref_equation
                  Property_Result := Logic_Assign_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Logic_Expr =>
                  --# property-call-start LogicExpr.xref_equation
                  Property_Result := Logic_Expr_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Logic_Propagate =>
                  --# property-call-start LogicPropagate.xref_equation
                  Property_Result := Logic_Propagate_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Logic_Unify =>
                  --# property-call-start LogicUnify.xref_equation
                  Property_Result := Logic_Unify_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Match_Expr =>
                  --# property-call-start MatchExpr.xref_equation
                  Property_Result := Match_Expr_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Not_Expr =>
                  --# property-call-start NotExpr.xref_equation
                  Property_Result := Not_Expr_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Paren_Expr =>
                  --# property-call-start ParenExpr.xref_equation
                  Property_Result := Paren_Expr_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Raise_Expr =>
                  --# property-call-start RaiseExpr.xref_equation
                  Property_Result := Raise_Expr_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Subscript_Expr =>
                  --# property-call-start SubscriptExpr.xref_equation
                  Property_Result := Subscript_Expr_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Try_Expr =>
                  --# property-call-start TryExpr.xref_equation
                  Property_Result := Try_Expr_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Un_Op =>
                  --# property-call-start UnOp.xref_equation
                  Property_Result := Un_Op_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Function_Type_Ref =>
                  --# property-call-start FunctionTypeRef.xref_equation
                  Property_Result := Function_Type_Ref_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Generic_Type_Ref =>
                  --# property-call-start GenericTypeRef.xref_equation
                  Property_Result := Generic_Type_Ref_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Simple_Type_Ref =>
                  --# property-call-start SimpleTypeRef.xref_equation
                  Property_Result := Simple_Type_Ref_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Var_Bind =>
                  --# property-call-start VarBind.xref_equation
                  Property_Result := Var_Bind_P_Xref_Equation
                    (Self
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Lkt_Node_P_Xref_Equation;
--# end

   







--# property-start '[dispatcher]LktNode.expected_type_equation' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Lkt_Node_P_Expected_Type_Equation
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Lkt_Node (Self.Kind) is
               when Lkt_Error_Lexer_Case_Rule_Alt .. Lkt_Excludes_Null_Present | Lkt_Full_Decl .. Lkt_Var_Bind =>
                  --# property-call-start 'LktNode.[root-static]expected_type_equation'
                  Property_Result := Lkt_Node_P_Expected_Type_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Argument =>
                  --# property-call-start Argument.expected_type_equation
                  Property_Result := Argument_P_Expected_Type_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Any_Of .. Lkt_Array_Literal | Lkt_Bin_Op .. Lkt_Block_Expr | Lkt_Error_On_Null .. Lkt_If_Expr | Lkt_Keep_Expr | Lkt_Big_Num_Lit .. Lkt_Not_Expr | Lkt_Query .. Lkt_Un_Op =>
                  --# property-call-start Expr.expected_type_equation
                  Property_Result := Expr_P_Expected_Type_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Call_Expr .. Lkt_Logic_Propagate_Call =>
                  --# property-call-start BaseCallExpr.expected_type_equation
                  Property_Result := Base_Call_Expr_P_Expected_Type_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Cast_Expr =>
                  --# property-call-start CastExpr.expected_type_equation
                  Property_Result := Cast_Expr_P_Expected_Type_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Dot_Expr =>
                  --# property-call-start DotExpr.expected_type_equation
                  Property_Result := Dot_Expr_P_Expected_Type_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Isa =>
                  --# property-call-start Isa.expected_type_equation
                  Property_Result := Isa_P_Expected_Type_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Lambda_Expr =>
                  --# property-call-start LambdaExpr.expected_type_equation
                  Property_Result := Lambda_Expr_P_Expected_Type_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Paren_Expr =>
                  --# property-call-start ParenExpr.expected_type_equation
                  Property_Result := Paren_Expr_P_Expected_Type_Equation
                    (Self
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Lkt_Node_P_Expected_Type_Equation;
--# end

   







--# property-start '[dispatcher]LktNode.generic_type_equation' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Lkt_Node_P_Generic_Type_Equation
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Lkt_Node (Self.Kind) is
               when Lkt_Argument .. Lkt_Array_Literal | Lkt_Bin_Op .. Lkt_Cast_Expr | Lkt_Error_On_Null .. Lkt_Module_Ref_Id | Lkt_If_Expr .. Lkt_Keep_Expr | Lkt_Big_Num_Lit .. Lkt_Logic_Expr | Lkt_Logic_Unify .. Lkt_Var_Bind =>
                  --# property-call-start 'LktNode.[root-static]generic_type_equation'
                  Property_Result := Lkt_Node_P_Generic_Type_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Call_Expr | Lkt_Logic_Propagate_Call =>
                  --# property-call-start BaseCallExpr.generic_type_equation
                  Property_Result := Base_Call_Expr_P_Generic_Type_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Logic_Predicate =>
                  --# property-call-start LogicPredicate.generic_type_equation
                  Property_Result := Logic_Predicate_P_Generic_Type_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Dot_Expr =>
                  --# property-call-start DotExpr.generic_type_equation
                  Property_Result := Dot_Expr_P_Generic_Type_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Ref_Id =>
                  --# property-call-start RefId.generic_type_equation
                  Property_Result := Ref_Id_P_Generic_Type_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Lambda_Expr =>
                  --# property-call-start LambdaExpr.generic_type_equation
                  Property_Result := Lambda_Expr_P_Generic_Type_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Logic_Propagate =>
                  --# property-call-start LogicPropagate.generic_type_equation
                  Property_Result := Logic_Propagate_P_Generic_Type_Equation
                    (Self
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Lkt_Node_P_Generic_Type_Equation;
--# end

   







--# property-start '[dispatcher]LktNode.complete' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Lkt_Node_P_Complete
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Complete_Item_Array_Access
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Complete_Item_Array_Access;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Lkt_Node (Self.Kind) is
               when Lkt_Argument .. Lkt_Cast_Expr | Lkt_Error_On_Null .. Lkt_Module_Ref_Id | Lkt_If_Expr .. Lkt_Var_Bind =>
                  --# property-call-start 'LktNode.[root-static]complete'
                  Property_Result := Lkt_Node_P_Complete
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Dot_Expr =>
                  --# property-call-start DotExpr.complete
                  Property_Result := Dot_Expr_P_Complete
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Ref_Id =>
                  --# property-call-start RefId.complete
                  Property_Result := Ref_Id_P_Complete
                    (Self
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Lkt_Node_P_Complete;
--# end

   







--# property-start LktNode.can_reach '<builtin>:0'
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Can_Reach
  
  (Node : Bare_Lkt_Node
      ; From_Node : Bare_Lkt_Node
  )

   return Boolean
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
      --# bind node Self

   

   --# bind from_node From_Node

   Property_Result : Boolean;

      

      Is_Equal : Boolean;
Fld : Internal_Unit;
Fld_1 : Internal_Unit;
Is_Equal_1 : Boolean;
Not_Val : Boolean;
Node_Comp : Boolean;
If_Result : Boolean;
If_Result_1 : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         




Is_Equal := From_Node = No_Bare_Lkt_Node; 
if Is_Equal then
   
   If_Result_1 := True;
else
   









   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Unit (Node => Self);







   if From_Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Liblktlang.Implementation.Unit (Node => From_Node);
Is_Equal_1 := Fld = Fld_1; 
Not_Val := not (Is_Equal_1); 
if Not_Val then
   
   If_Result := True;
else
   


Node_Comp := Compare (Self, Self, From_Node, Less_Than); 
   If_Result := Node_Comp;
end if;



   If_Result_1 := If_Result;
end if;




         Property_Result := If_Result_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Can_Reach;
--# end

   







--# property-start 'LktNode.[root-static]xref_entry_point' nodes.lkt:318
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Xref_Entry_Point
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := False;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Xref_Entry_Point;
--# end

   







--# property-start 'LktNode.[root-static]xref_equation' nodes.lkt:323
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Xref_Equation
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := raise Property_Error with "Property LktNode.xref_equation not implemented";
            Inc_Ref (Property_Result);
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Xref_Equation;
--# end

   







--# property-start 'LktNode.[root-static]expected_type_equation' nodes.lkt:329
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Expected_Type_Equation
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := raise Property_Error with "Property LktNode.expected_type_equation not implemented";
            Inc_Ref (Property_Result);
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Expected_Type_Equation;
--# end

   







--# property-start 'LktNode.[root-static]generic_type_equation' nodes.lkt:335
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Generic_Type_Equation
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := raise Property_Error with "Property LktNode.generic_type_equation not implemented";
            Inc_Ref (Property_Result);
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Generic_Type_Equation;
--# end

   







--# property-start 'LktNode.[root-static]complete' nodes.lkt:342
pragma Warnings (Off, "is not referenced");

function Lkt_Node_P_Complete
  
  (Node : Bare_Lkt_Node
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Complete_Item_Array_Access
is
   Self : Bare_Lkt_Node :=
     Bare_Lkt_Node (Node);
     Ent : Internal_Entity :=
       Internal_Entity'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Complete_Item_Array_Access;

      
            procedure Finalizer_Scope_73 with Inline_Always;
            procedure Finalizer_Scope_468 with Inline_Always;

      Fld : Internal_Unit;
Fld_1 : Bare_Lkt_Node;
Fld_2 : Lexical_Env := Empty_Env;
Env_Get_Result : Internal_Entity_Array_Access;
Local_Items : Internal_Entity_Array_Access;
Cast_Result : Internal_Entity_Decl;
New_Struct : Internal_Complete_Item;
Map_Result : Internal_Complete_Item_Array_Access;
Fld_3 : Internal_Entity_Array_Access;
Is_A : Boolean;
Quantifier_Result : Boolean;
Cast_Result_1 : Internal_Entity_Decl;
New_Struct_1 : Internal_Complete_Item;
Is_A_1 : Boolean;
Map_Result_1 : Internal_Complete_Item_Array_Access;
If_Result : Internal_Complete_Item_Array_Access;
Let_Result : Internal_Complete_Item_Array_Access;
Scope_Result : Internal_Complete_Item_Array_Access;

            procedure Finalizer_Scope_73 is
            begin
                     Dec_Ref (Scope_Result);
            end Finalizer_Scope_73;
            procedure Finalizer_Scope_468 is
            begin
                     Dec_Ref (Fld_2);
                     Dec_Ref (Env_Get_Result);
                     Dec_Ref (Local_Items);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Fld_3);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (If_Result);
                     Dec_Ref (Let_Result);
            end Finalizer_Scope_468;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 138 ValDecl Let_Result nodes.lkt:344
--# scope-start
--# expr-start 126 .get Env_Get_Result nodes.lkt:344
--# expr-start 125 LktNode.node_env Fld_2 nodes.lkt:344



--# expr-start 124 AnalysisUnit.root Fld_1 nodes.lkt:344



--# expr-start 123 LktNode.unit Fld nodes.lkt:344







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Unit (Node => Ent.Node);
--# expr-done 123



   if Fld = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Fld.Ast_Root;
--# expr-done 124



   if Fld_1 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Liblktlang.Implementation.Node_Env (Node => Fld_1);
--# expr-done 125



Env_Get_Result := Construct_Entity_Array (AST_Envs.Get (Self => Fld_2, Key => Thin (No_Symbol), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True))); 
--# expr-done 126
Local_Items := Env_Get_Result; Inc_Ref (Local_Items);
--# bind items Local_Items
--# expr-start 137 If If_Result nodes.lkt:346



--# expr-start 129 .any Quantifier_Result nodes.lkt:346








   

   --# expr-start 127 LktNode.parents Fld_3 nodes.lkt:346







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



Fld_3 := Liblktlang.Implementation.Parents (Node => Ent.Node, With_Self => True, E_Info => Ent.Info);
--# expr-done 127

   
      Quantifier_Result := False;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Fld_3;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind p Item_1

            
      --# expr-start 128 IsA Is_A nodes.lkt:346

Is_A := Item_1.Node /= null 
and then Item_1.Node.Kind in Lkt_Type_Ref; 
--# expr-done 128
      Quantifier_Result := Is_A;
   

            
   --# end


               exit when Quantifier_Result;

         end loop;
      end;
   

   
   



--# expr-done 129
if Quantifier_Result then
   --# expr-start 133 .filtermap Map_Result_1 nodes.lkt:347








   

   

   
      declare
         Map_Result_1_Vec : Internal_Complete_Item_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Local_Items;
      begin
         for Item_2 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind d Item_2

            
         --# expr-start 130 IsA Is_A_1 nodes.lkt:349

Is_A_1 := Item_2.Node /= null 
and then Item_2.Node.Kind in Lkt_Type_Decl; 
--# expr-done 130
         if Is_A_1 then
            
         
      --# expr-start 132 'New[CompleteItem]' New_Struct_1 nodes.lkt:348
--# expr-start 131 Cast Cast_Result_1 nodes.lkt:348









   if Item_2.Node = null
      or else Item_2.Node.Kind in Lkt_Decl
   then
      
      Cast_Result_1 := Create_Internal_Entity_Decl
        (Node => Item_2.Node,
         Info => Item_2.Info);

   else
         Cast_Result_1 := No_Entity_Decl;
   end if;


--# expr-done 131
New_Struct_1 := (Declaration => Cast_Result_1); 
--# expr-done 132
      

         declare
            Item_To_Append : constant Internal_Complete_Item := New_Struct_1;
         begin
            Internal_Complete_Item_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
         end if;
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result_1 := Create_Internal_Complete_Item_Array
           (Items_Count => Natural (Internal_Complete_Item_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Internal_Complete_Item_Vectors.Get
              (Map_Result_1_Vec,
               I + Internal_Complete_Item_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Internal_Complete_Item_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 133
   If_Result := Map_Result_1;
else
   --# expr-start 136 .map Map_Result nodes.lkt:351








   

   

   
      declare
         Map_Result_Vec : Internal_Complete_Item_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Local_Items;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind d Item

            
         
         
      --# expr-start 135 'New[CompleteItem]' New_Struct nodes.lkt:351
--# expr-start 134 Cast Cast_Result nodes.lkt:351









   if Item.Node = null
      or else Item.Node.Kind in Lkt_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Decl
        (Node => Item.Node,
         Info => Item.Info);

   else
         Cast_Result := No_Entity_Decl;
   end if;


--# expr-done 134
New_Struct := (Declaration => Cast_Result); 
--# expr-done 135
      

         declare
            Item_To_Append : constant Internal_Complete_Item := New_Struct;
         begin
            Internal_Complete_Item_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Complete_Item_Array
           (Items_Count => Natural (Internal_Complete_Item_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Complete_Item_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Complete_Item_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Complete_Item_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 136
   If_Result := Map_Result;
end if;

      Inc_Ref (If_Result);


--# expr-done 137
Let_Result := If_Result; Inc_Ref (Let_Result);
--# end
--# expr-done 138
Scope_Result := Let_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_468;



         Property_Result := Scope_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_73;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_73;
                     Finalizer_Scope_468;




            raise;
      end;



   return Property_Result;
end Lkt_Node_P_Complete;
--# end


   
function Lkt_Node_P_Shed_Rebindings
  (E : Entity
  ) return Internal_Entity
is
   

      E_Info : Internal_Entity_Info :=
         Shed_Rebindings (E.Info, Children_Env (E.Node));
      
begin
   

   declare
      Result : constant Internal_Entity :=
         Lkt_Node_P_Shed_Rebindings (E.Node, E_Info);
   begin
         return (Node => Result.Node, Info => Result.Info);
   end;
end;


   


      

   --
   --  Primitives for Bare_Argument
   --

   



      
      procedure Initialize_Fields_For_Argument
        (Self : Bare_Argument
         ; Argument_F_Name : Bare_Ref_Id
         ; Argument_F_Value : Bare_Expr
        ) is
      begin

            Self.Argument_F_Name := Argument_F_Name;
            Self.Argument_F_Value := Argument_F_Value;
         

      end Initialize_Fields_For_Argument;

      
   function Argument_F_Name
     (Node : Bare_Argument) return Bare_Ref_Id
   is
      

   begin
         
         return Node.Argument_F_Name;
      
   end;

      
   function Argument_F_Value
     (Node : Bare_Argument) return Bare_Expr
   is
      

   begin
         
         return Node.Argument_F_Value;
      
   end;


   







--# property-start Argument.expected_type_equation nodes.lkt:5461
pragma Warnings (Off, "is not referenced");

function Argument_P_Expected_Type_Equation
  
  (Node : Bare_Argument
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Argument :=
     Bare_Argument (Node);
     Ent : Internal_Entity_Argument :=
       Internal_Entity_Argument'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_409 with Inline_Always;

      True_Rel : Logic_Equation;
Fld : Internal_Entity_Expr;
Fld_1 : Boolean;
Fld_2 : Internal_Entity_Expr;
Fld_3 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
If_Result : Logic_Equation;

            procedure Finalizer_Scope_409 is
            begin
                     Dec_Ref (True_Rel);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (If_Result);
            end Finalizer_Scope_409;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 145 If If_Result nodes.lkt:5465



--# expr-start 140 Expr.has_context_free_type Fld_1 nodes.lkt:5465



--# expr-start 139 Argument.value Fld nodes.lkt:5465







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Argument_F_Value, Info => Ent.Info);
--# expr-done 139



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 140
if Fld_1 then
   --# expr-start 143 LogicAssign Bind_Result nodes.lkt:5466
--# expr-start 142 Expr.expected_type_var Fld_3 nodes.lkt:5466



--# expr-start 141 Argument.value Fld_2 nodes.lkt:5466







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Ent.Node.Argument_F_Value, Info => Ent.Info);
--# expr-done 141



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Fld_2.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 142
Fld_3.Value := No_Entity;
Entity_Vars.Reset (Fld_3);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result := Solver.Create_Assign (Fld_3, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5466:14") else null)); 
--# expr-done 143
   If_Result := Bind_Result;
else
   --# expr-start 144 LogicTrue True_Rel nodes.lkt:5467
True_Rel := Solver.Create_True ((if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5467:14") else null)); 
--# expr-done 144
   If_Result := True_Rel;
end if;

      Inc_Ref (If_Result);


--# expr-done 145

         Property_Result := If_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_409;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_409;




            raise;
      end;



   return Property_Result;
end Argument_P_Expected_Type_Equation;
--# end

   







--# property-start Argument.xref_equation nodes.lkt:5469
pragma Warnings (Off, "is not referenced");

function Argument_P_Xref_Equation
  
  (Node : Bare_Argument
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Argument :=
     Bare_Argument (Node);
     Ent : Internal_Entity_Argument :=
       Internal_Entity_Argument'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_410 with Inline_Always;
            procedure Finalizer_Scope_853 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Internal_Entity_Ref_Id;
Var_Expr : Internal_Entity_Ref_Id;
Fld_3 : Logic_Equation;
Scope_Result : Logic_Equation;
True_Rel : Logic_Equation;
Result_Var : Logic_Equation;
And_Pred : Logic_Equation;

            procedure Finalizer_Scope_410 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (True_Rel);
                     Dec_Ref (Result_Var);
                     Dec_Ref (And_Pred);
            end Finalizer_Scope_410;
            procedure Finalizer_Scope_853 is
            begin
                     Dec_Ref (Fld_3);
            end Finalizer_Scope_853;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 152 LogicAnd And_Pred nodes.lkt:5470
--# expr-start 147 LktNode.xref_equation Fld_1 nodes.lkt:5470



--# expr-start 146 Argument.value Fld nodes.lkt:5470







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Argument_F_Value, Info => Ent.Info);
--# expr-done 146



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 147
--# expr-start 151 .do Result_Var nodes.lkt:5471



--# expr-start 148 Argument.name Fld_2 nodes.lkt:5471







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Argument_F_Name, Info => Ent.Info);
--# expr-done 148
Var_Expr := Fld_2;





if Var_Expr /= No_Entity_Ref_Id then
   



   --# scope-start



--# expr-start 149 RefId.xref_equation Fld_3 nodes.lkt:5471







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_3 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 149
Scope_Result := Fld_3;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_853;


   Result_Var := Scope_Result;
else
   --# expr-start 150 LogicTrue True_Rel nodes.lkt:5471
True_Rel := Solver.Create_True ((if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5471:65") else null)); 
--# expr-done 150
   Result_Var := True_Rel;
end if;

      Inc_Ref (Result_Var);


--# expr-done 151
And_Pred := Create_And (Fld_1, Result_Var, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5470:9") else null)); 
--# expr-done 152

         Property_Result := And_Pred;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_410;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_410;
                     Finalizer_Scope_853;




            raise;
      end;



   return Property_Result;
end Argument_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Base_Lexer_Case_Rule_Alt
   --

   







   


      

   --
   --  Primitives for Bare_Error_Lexer_Case_Rule_Alt
   --

   







   


      

   --
   --  Primitives for Bare_Lexer_Case_Rule_Cond_Alt
   --

   



      
      procedure Initialize_Fields_For_Lexer_Case_Rule_Cond_Alt
        (Self : Bare_Lexer_Case_Rule_Cond_Alt
         ; Lexer_Case_Rule_Cond_Alt_F_Cond_Exprs : Bare_Ref_Id_List
         ; Lexer_Case_Rule_Cond_Alt_F_Send : Bare_Lexer_Case_Rule_Send
        ) is
      begin

            Self.Lexer_Case_Rule_Cond_Alt_F_Cond_Exprs := Lexer_Case_Rule_Cond_Alt_F_Cond_Exprs;
            Self.Lexer_Case_Rule_Cond_Alt_F_Send := Lexer_Case_Rule_Cond_Alt_F_Send;
         

      end Initialize_Fields_For_Lexer_Case_Rule_Cond_Alt;

      
   function Lexer_Case_Rule_Cond_Alt_F_Cond_Exprs
     (Node : Bare_Lexer_Case_Rule_Cond_Alt) return Bare_Ref_Id_List
   is
      

   begin
         
         return Node.Lexer_Case_Rule_Cond_Alt_F_Cond_Exprs;
      
   end;

      
   function Lexer_Case_Rule_Cond_Alt_F_Send
     (Node : Bare_Lexer_Case_Rule_Cond_Alt) return Bare_Lexer_Case_Rule_Send
   is
      

   begin
         
         return Node.Lexer_Case_Rule_Cond_Alt_F_Send;
      
   end;




   


      

   --
   --  Primitives for Bare_Lexer_Case_Rule_Default_Alt
   --

   



      
      procedure Initialize_Fields_For_Lexer_Case_Rule_Default_Alt
        (Self : Bare_Lexer_Case_Rule_Default_Alt
         ; Lexer_Case_Rule_Default_Alt_F_Send : Bare_Lexer_Case_Rule_Send
        ) is
      begin

            Self.Lexer_Case_Rule_Default_Alt_F_Send := Lexer_Case_Rule_Default_Alt_F_Send;
         

      end Initialize_Fields_For_Lexer_Case_Rule_Default_Alt;

      
   function Lexer_Case_Rule_Default_Alt_F_Send
     (Node : Bare_Lexer_Case_Rule_Default_Alt) return Bare_Lexer_Case_Rule_Send
   is
      

   begin
         
         return Node.Lexer_Case_Rule_Default_Alt_F_Send;
      
   end;




   


      

   --
   --  Primitives for Bare_Base_Match_Branch
   --

   



   

   

   

   

   

   

   


      procedure Base_Match_Branch_Pre_Env_Actions
        (Self            : Bare_Base_Match_Branch;
         State           : in out PLE_Node_State;
         Add_To_Env_Only : Boolean := False) is
      begin
            


   
      if Add_To_Env_Only then
         return;
      end if;

      declare
         No_Parent         : constant Boolean :=
            False;
         Transitive_Parent : constant Boolean :=
            False;
         Names             : Symbol_Type_Array_Access :=
            null;
      begin
         Add_Env (Self, State, No_Parent, Transitive_Parent, Names);
      end;
   
   
      end;




      
   function Base_Match_Branch_F_Expr
     (Node : Bare_Base_Match_Branch) return Bare_Expr
   is
      

         Kind : constant Lkt_Base_Match_Branch := Node.Kind;
   begin
         case Kind is
               when Lkt_Match_Branch =>
                     
         return Node.Match_Branch_F_Expr;
      
               when Lkt_Pattern_Match_Branch =>
                     
         return Node.Pattern_Match_Branch_F_Expr;
      
         end case;
   end;


   







--# property-start '[dispatcher]BaseMatchBranch.match_part' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Base_Match_Branch_P_Match_Part
  
  (Node : Bare_Base_Match_Branch
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity
is
   Self : Bare_Base_Match_Branch :=
     Bare_Base_Match_Branch (Node);
     Ent : Internal_Entity_Base_Match_Branch :=
       Internal_Entity_Base_Match_Branch'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Base_Match_Branch (Self.Kind) is
               when Lkt_Match_Branch =>
                  --# property-call-start MatchBranch.match_part
                  Property_Result := Match_Branch_P_Match_Part
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Pattern_Match_Branch =>
                  --# property-call-start PatternMatchBranch.match_part
                  Property_Result := Pattern_Match_Branch_P_Match_Part
                    (Self
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Base_Match_Branch_P_Match_Part;
--# end



   


      

   --
   --  Primitives for Bare_Match_Branch
   --

   



      
      procedure Initialize_Fields_For_Match_Branch
        (Self : Bare_Match_Branch
         ; Match_Branch_F_Decl : Bare_Match_Val_Decl
         ; Match_Branch_F_Expr : Bare_Expr
        ) is
      begin

            Self.Match_Branch_F_Decl := Match_Branch_F_Decl;
            Self.Match_Branch_F_Expr := Match_Branch_F_Expr;
         

      end Initialize_Fields_For_Match_Branch;

      
   function Match_Branch_F_Decl
     (Node : Bare_Match_Branch) return Bare_Match_Val_Decl
   is
      

   begin
         
         return Node.Match_Branch_F_Decl;
      
   end;


   







--# property-start MatchBranch.match_part nodes.lkt:5389
pragma Warnings (Off, "is not referenced");

function Match_Branch_P_Match_Part
  
  (Node : Bare_Match_Branch
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity
is
   Self : Bare_Match_Branch :=
     Bare_Match_Branch (Node);
     Ent : Internal_Entity_Match_Branch :=
       Internal_Entity_Match_Branch'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity;

      

      Fld : Internal_Entity_Match_Val_Decl;
Cast_Result : Internal_Entity;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         




--# expr-start 153 MatchBranch.decl Fld nodes.lkt:5389







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Match_Val_Decl (Node => Ent.Node.Match_Branch_F_Decl, Info => Ent.Info);
--# expr-done 153



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld.Node,
         Info => Fld.Info);



         Property_Result := Cast_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Match_Branch_P_Match_Part;
--# end



   


      

   --
   --  Primitives for Bare_Pattern_Match_Branch
   --

   



      
      procedure Initialize_Fields_For_Pattern_Match_Branch
        (Self : Bare_Pattern_Match_Branch
         ; Pattern_Match_Branch_F_Pattern : Bare_Pattern
         ; Pattern_Match_Branch_F_Expr : Bare_Expr
        ) is
      begin

            Self.Pattern_Match_Branch_F_Pattern := Pattern_Match_Branch_F_Pattern;
            Self.Pattern_Match_Branch_F_Expr := Pattern_Match_Branch_F_Expr;
         

      end Initialize_Fields_For_Pattern_Match_Branch;

      
   function Pattern_Match_Branch_F_Pattern
     (Node : Bare_Pattern_Match_Branch) return Bare_Pattern
   is
      

   begin
         
         return Node.Pattern_Match_Branch_F_Pattern;
      
   end;


   







--# property-start PatternMatchBranch.match_part nodes.lkt:5401
pragma Warnings (Off, "is not referenced");

function Pattern_Match_Branch_P_Match_Part
  
  (Node : Bare_Pattern_Match_Branch
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity
is
   Self : Bare_Pattern_Match_Branch :=
     Bare_Pattern_Match_Branch (Node);
     Ent : Internal_Entity_Pattern_Match_Branch :=
       Internal_Entity_Pattern_Match_Branch'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity;

      

      Fld : Internal_Entity_Pattern;
Cast_Result : Internal_Entity;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         




--# expr-start 154 PatternMatchBranch.pattern Fld nodes.lkt:5401







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Pattern (Node => Ent.Node.Pattern_Match_Branch_F_Pattern, Info => Ent.Info);
--# expr-done 154



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld.Node,
         Info => Fld.Info);



         Property_Result := Cast_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Pattern_Match_Branch_P_Match_Part;
--# end



   


      

   --
   --  Primitives for Bare_Block_Expr_Clause
   --

   



      
      procedure Initialize_Fields_For_Block_Expr_Clause
        (Self : Bare_Block_Expr_Clause
         ; Block_Expr_Clause_F_Clause : Bare_Lkt_Node
        ) is
      begin

            Self.Block_Expr_Clause_F_Clause := Block_Expr_Clause_F_Clause;
         

      end Initialize_Fields_For_Block_Expr_Clause;

      
   function Block_Expr_Clause_F_Clause
     (Node : Bare_Block_Expr_Clause) return Bare_Lkt_Node
   is
      

   begin
         
         return Node.Block_Expr_Clause_F_Clause;
      
   end;




   


      

   --
   --  Primitives for Bare_Block_String_Line
   --

   







   


      

   --
   --  Primitives for Bare_Class_Qualifier
   --

   





   







--# property-start '[dispatcher]ClassQualifier.as_bool' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Class_Qualifier_P_As_Bool
  
  (Node : Bare_Class_Qualifier
  )

   return Boolean
is
   Self : Bare_Class_Qualifier :=
     Bare_Class_Qualifier (Node);
      --# bind node Self

   


   Property_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Class_Qualifier (Self.Kind) is
               when Lkt_Class_Qualifier_Absent =>
                  --# property-call-start ClassQualifier.Absent.as_bool
                  Property_Result := Class_Qualifier_Absent_P_As_Bool
                    (Self
                    );
                  --# end
               when Lkt_Class_Qualifier_Present =>
                  --# property-call-start ClassQualifier.Present.as_bool
                  Property_Result := Class_Qualifier_Present_P_As_Bool
                    (Self
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Class_Qualifier_P_As_Bool;
--# end



   


      

   --
   --  Primitives for Bare_Class_Qualifier_Absent
   --

   





   







--# property-start ClassQualifier.Absent.as_bool nodes.lkt:391
pragma Warnings (Off, "is not referenced");

function Class_Qualifier_Absent_P_As_Bool
  
  (Node : Bare_Class_Qualifier_Absent
  )

   return Boolean
is
   Self : Bare_Class_Qualifier_Absent :=
     Bare_Class_Qualifier_Absent (Node);
      --# bind node Self

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := False;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Class_Qualifier_Absent_P_As_Bool;
--# end



   


      

   --
   --  Primitives for Bare_Class_Qualifier_Present
   --

   





   







--# property-start ClassQualifier.Present.as_bool nodes.lkt:391
pragma Warnings (Off, "is not referenced");

function Class_Qualifier_Present_P_As_Bool
  
  (Node : Bare_Class_Qualifier_Present
  )

   return Boolean
is
   Self : Bare_Class_Qualifier_Present :=
     Bare_Class_Qualifier_Present (Node);
      --# bind node Self

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := True;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Class_Qualifier_Present_P_As_Bool;
--# end



   


      

   --
   --  Primitives for Bare_Decl
   --

   



   

   

   

   

   

   

   


      procedure Decl_Pre_Env_Actions
        (Self            : Bare_Decl;
         State           : in out PLE_Node_State;
         Add_To_Env_Only : Boolean := False) is
      begin
            


   

      declare
         Resolver : constant Entity_Resolver :=
            null;

         

         Mappings : Internal_Env_Assoc_Array_Access :=
            Liblktlang.Implementation.Internal_Env_Mappings_1 (Node => 
Self);
      begin
         for Mapping of Mappings.Items loop

         Add_To_Env
           (Self,
            State,
            Mapping.Key,
            Mapping.Value,
            Mapping.Metadata,
            Resolver,
            Mapping.Dest_Env,
            DSL_Location => "nodes.lkt:1054:9");

         end loop;
         Dec_Ref (Mappings);
      end;
   
   
      end;




      
   function Decl_F_Syn_Name
     (Node : Bare_Decl) return Bare_Def_Id
   is
      

         Kind : constant Lkt_Decl := Node.Kind;
   begin
         case Kind is
               when Lkt_Error_Decl =>
                     return No_Bare_Lkt_Node;
               when Lkt_Grammar_Rule_Decl =>
                     
         return Node.Grammar_Rule_Decl_F_Syn_Name;
      
               when Lkt_Synthetic_Lexer_Decl =>
                     return No_Bare_Lkt_Node;
               when Lkt_Node_Decl =>
                     return No_Bare_Lkt_Node;
               when Lkt_Self_Decl =>
                     return No_Bare_Lkt_Node;
               when Lkt_Enum_Lit_Decl =>
                     
         return Node.Enum_Lit_Decl_F_Syn_Name;
      
               when Lkt_Field_Decl =>
                     
         return Node.Field_Decl_F_Syn_Name;
      
               when Lkt_Fun_Param_Decl =>
                     
         return Node.Fun_Param_Decl_F_Syn_Name;
      
               when Lkt_Lambda_Param_Decl =>
                     
         return Node.Lambda_Param_Decl_F_Syn_Name;
      
               when Lkt_Dyn_Var_Decl =>
                     
         return Node.Dyn_Var_Decl_F_Syn_Name;
      
               when Lkt_Binding_Val_Decl =>
                     
         return Node.Binding_Val_Decl_F_Syn_Name;
      
               when Lkt_Match_Val_Decl =>
                     
         return Node.Match_Val_Decl_F_Syn_Name;
      
               when Lkt_Val_Decl =>
                     
         return Node.Val_Decl_F_Syn_Name;
      
               when Lkt_Fun_Decl =>
                     
         return Node.Fun_Decl_F_Syn_Name;
      
               when Lkt_Env_Spec_Decl =>
                     
         return Node.Env_Spec_Decl_F_Syn_Name;
      
               when Lkt_Generic_Decl =>
                     return No_Bare_Lkt_Node;
               when Lkt_Grammar_Decl =>
                     
         return Node.Grammar_Decl_F_Syn_Name;
      
               when Lkt_Lexer_Decl =>
                     
         return Node.Lexer_Decl_F_Syn_Name;
      
               when Lkt_Lexer_Family_Decl =>
                     
         return Node.Lexer_Family_Decl_F_Syn_Name;
      
               when Lkt_Synth_Param_Decl =>
                     return No_Bare_Lkt_Node;
               when Lkt_Synth_Fun_Decl =>
                     return No_Bare_Lkt_Node;
               when Lkt_Any_Type_Decl =>
                     return No_Bare_Lkt_Node;
               when Lkt_Enum_Class_Alt_Decl =>
                     
         return Node.Enum_Class_Alt_Decl_F_Syn_Name;
      
               when Lkt_Function_Type =>
                     return No_Bare_Lkt_Node;
               when Lkt_Generic_Param_Type_Decl =>
                     
         return Node.Generic_Param_Type_Decl_F_Syn_Name;
      
               when Lkt_Class_Decl | Lkt_Enum_Class_Decl =>
                     
         return Node.Basic_Class_Decl_F_Syn_Name;
      
               when Lkt_Enum_Type_Decl =>
                     
         return Node.Enum_Type_Decl_F_Syn_Name;
      
               when Lkt_Struct_Decl =>
                     
         return Node.Struct_Decl_F_Syn_Name;
      
               when Lkt_Trait_Decl =>
                     
         return Node.Trait_Decl_F_Syn_Name;
      
         end case;
   end;


   







--# property-start '[dispatcher]Decl.decl_type_name' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Decl_P_Decl_Type_Name
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Decl (Self.Kind) is
               when Lkt_Grammar_Rule_Decl =>
                  --# property-call-start GrammarRuleDecl.decl_type_name
                  Property_Result := Grammar_Rule_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Synthetic_Lexer_Decl =>
                  --# property-call-start SyntheticLexerDecl.decl_type_name
                  Property_Result := Synthetic_Lexer_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Node_Decl =>
                  --# property-call-start NodeDecl.decl_type_name
                  Property_Result := Node_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Self_Decl =>
                  --# property-call-start SelfDecl.decl_type_name
                  Property_Result := Self_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Binding_Val_Decl =>
                  --# property-call-start BindingValDecl.decl_type_name
                  Property_Result := Binding_Val_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Enum_Lit_Decl =>
                  --# property-call-start EnumLitDecl.decl_type_name
                  Property_Result := Enum_Lit_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Field_Decl =>
                  --# property-call-start FieldDecl.decl_type_name
                  Property_Result := Field_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Fun_Param_Decl =>
                  --# property-call-start FunParamDecl.decl_type_name
                  Property_Result := Fun_Param_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Lambda_Param_Decl =>
                  --# property-call-start LambdaParamDecl.decl_type_name
                  Property_Result := Lambda_Param_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Dyn_Var_Decl =>
                  --# property-call-start DynVarDecl.decl_type_name
                  Property_Result := Dyn_Var_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Match_Val_Decl =>
                  --# property-call-start MatchValDecl.decl_type_name
                  Property_Result := Match_Val_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Val_Decl =>
                  --# property-call-start ValDecl.decl_type_name
                  Property_Result := Val_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Fun_Decl =>
                  --# property-call-start FunDecl.decl_type_name
                  Property_Result := Fun_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Env_Spec_Decl =>
                  --# property-call-start EnvSpecDecl.decl_type_name
                  Property_Result := Env_Spec_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Error_Decl =>
                  --# property-call-start ErrorDecl.decl_type_name
                  Property_Result := Error_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Generic_Decl =>
                  --# property-call-start GenericDecl.decl_type_name
                  Property_Result := Generic_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Grammar_Decl =>
                  --# property-call-start GrammarDecl.decl_type_name
                  Property_Result := Grammar_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Lexer_Decl =>
                  --# property-call-start LexerDecl.decl_type_name
                  Property_Result := Lexer_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Lexer_Family_Decl =>
                  --# property-call-start LexerFamilyDecl.decl_type_name
                  Property_Result := Lexer_Family_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Synth_Fun_Decl =>
                  --# property-call-start SynthFunDecl.decl_type_name
                  Property_Result := Synth_Fun_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Synth_Param_Decl =>
                  --# property-call-start SynthParamDecl.decl_type_name
                  Property_Result := Synth_Param_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Any_Type_Decl =>
                  --# property-call-start AnyTypeDecl.decl_type_name
                  Property_Result := Any_Type_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Enum_Class_Alt_Decl =>
                  --# property-call-start EnumClassAltDecl.decl_type_name
                  Property_Result := Enum_Class_Alt_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Function_Type =>
                  --# property-call-start FunctionType.decl_type_name
                  Property_Result := Function_Type_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Generic_Param_Type_Decl =>
                  --# property-call-start GenericParamTypeDecl.decl_type_name
                  Property_Result := Generic_Param_Type_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Class_Decl =>
                  --# property-call-start ClassDecl.decl_type_name
                  Property_Result := Class_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Enum_Class_Decl =>
                  --# property-call-start EnumClassDecl.decl_type_name
                  Property_Result := Enum_Class_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Enum_Type_Decl =>
                  --# property-call-start EnumTypeDecl.decl_type_name
                  Property_Result := Enum_Type_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Struct_Decl =>
                  --# property-call-start StructDecl.decl_type_name
                  Property_Result := Struct_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Trait_Decl =>
                  --# property-call-start TraitDecl.decl_type_name
                  Property_Result := Trait_Decl_P_Decl_Type_Name
                    (Self
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Decl_P_Decl_Type_Name;
--# end

   







--# property-start Decl.full_decl nodes.lkt:421
pragma Warnings (Off, "is not referenced");

function Decl_P_Full_Decl
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Full_Decl
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Full_Decl;

      

      Fld : Internal_Entity;
Local_Fd : Internal_Entity_Full_Decl;
Local_Gd : Internal_Entity_Generic_Decl;
Fld_1 : Internal_Entity_Full_Decl;
Ignored : Internal_Entity;
Match_Prefix : Internal_Entity;
Cast_Result : Internal_Entity_Full_Decl;
Let_Result : Internal_Entity_Full_Decl;
Scope_Result : Internal_Entity_Full_Decl;
Cast_Result_1 : Internal_Entity_Generic_Decl;
Let_Result_1 : Internal_Entity_Full_Decl;
Scope_Result_1 : Internal_Entity_Full_Decl;
Cast_Result_2 : Internal_Entity;
Let_Result_2 : Internal_Entity_Full_Decl;
Scope_Result_2 : Internal_Entity_Full_Decl;
Match_Result : Internal_Entity_Full_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 157 Match Match_Result nodes.lkt:421






--# expr-start 155 .parent Fld nodes.lkt:421







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Parent (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 155



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := Fld; 

case Lkt_Lkt_Node (Match_Prefix.Node.Kind) is
         when Lkt_Full_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result := Create_Internal_Entity_Full_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Fd := Cast_Result; 
--# bind fd Local_Fd

Let_Result := Local_Fd; 
--# end
Scope_Result := Let_Result;


   --# end


            Match_Result := Scope_Result; 
         when Lkt_Generic_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_1 := Create_Internal_Entity_Generic_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Gd := Cast_Result_1; 
--# bind gd Local_Gd
--# expr-start 156 Decl.full_decl Fld_1 nodes.lkt:423







   if Local_Gd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.full_decl
Fld_1 := Liblktlang.Implementation.Decl_P_Full_Decl (Node => Local_Gd.Node, E_Info => Local_Gd.Info);
--# end
--# expr-done 156
Let_Result_1 := Fld_1; 
--# end
Scope_Result_1 := Let_Result_1;


   --# end


            Match_Result := Scope_Result_1; 
         when Lkt_Argument .. Lkt_Error_Decl | Lkt_Grammar_Decl .. Lkt_Un_Op | Lkt_Grammar_List_Sep .. Lkt_Var_Bind =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored := Cast_Result_2; 
--# bind _ Ignored

Let_Result_2 := No_Entity_Full_Decl; 
--# end
Scope_Result_2 := Let_Result_2;


   --# end


            Match_Result := Scope_Result_2; 
end case;

--# expr-done 157

         Property_Result := Match_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Decl_P_Full_Decl;
--# end

   







--# property-start Decl.def_ids nodes.lkt:429
pragma Warnings (Off, "is not referenced");

function Decl_P_Def_Ids
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Def_Id_Array_Access
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Def_Id_Array_Access;

      
            procedure Finalizer_Scope_85 with Inline_Always;

      Fld : Internal_Entity_Def_Id;
Array_Lit : Internal_Entity_Def_Id_Array_Access;

            procedure Finalizer_Scope_85 is
            begin
                     Dec_Ref (Array_Lit);
            end Finalizer_Scope_85;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 159 ArrayLiteral Array_Lit nodes.lkt:431
--# expr-start 158 Decl.syn_name Fld nodes.lkt:431







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Def_Id (Node => Implementation.Decl_F_Syn_Name (Ent.Node), Info => Ent.Info);
--# expr-done 158
Array_Lit := Create_Internal_Entity_Def_Id_Array (Internal_Internal_Entity_Def_Id_Array'(1 => Fld)); 
--# expr-done 159

         Property_Result := Array_Lit;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_85;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_85;




            raise;
      end;



   return Property_Result;
end Decl_P_Def_Ids;
--# end

   







--# property-start Decl.implements_node nodes.lkt:435
pragma Warnings (Off, "is not referenced");

function Decl_P_Implements_Node
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      
            procedure Finalizer_Scope_477 with Inline_Always;

      Cast_Result : Internal_Entity_Class_Decl;
Var_Expr : Internal_Entity_Class_Decl;
Fld : Internal_Entity_Type_Ref_List;
Item : Internal_Entity_Type_Ref;
Cast_Result_1 : Internal_Entity_Generic_Type_Ref;
Var_Expr_1 : Internal_Entity_Generic_Type_Ref;
Fld_1 : Lexical_Env := Empty_Env;
Fld_2 : Internal_Entity_Expr;
Cast_Result_2 : Internal_Entity_Ref_Id;
Var_Expr_2 : Internal_Entity_Ref_Id;
Fld_3 : Bare_Ref_Id;
Sym : Symbol_Type;
Result_Var : Symbol_Type;
Env_Get_Result : Internal_Entity;
Cast_Result_3 : Internal_Entity_Generic_Decl;
Fld_4 : Internal_Entity_Decl;
Scope_Result : Internal_Entity_Decl;
Result_Var_1 : Internal_Entity_Decl;
Fld_5 : Internal_Entity_Trait_Decl;
Cast_Result_4 : Internal_Entity;
Cast_Result_5 : Internal_Entity;
Is_Equiv : Boolean;
Fld_6 : Bare_Type_Ref_List;
Fld_7 : Internal_Entity_Info;
Bare_Item : Bare_Type_Ref;
As_Entity : Internal_Entity_Type_Ref;
Is_Null : Boolean;
If_Result : Internal_Entity_Type_Ref;
Find_Result : Internal_Entity_Type_Ref;
Is_Null_1 : Boolean;
Not_Val : Boolean;
Scope_Result_1 : Boolean;
Result_Var_2 : Boolean;

            procedure Finalizer_Scope_477 is
            begin
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_477;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 176 .do Result_Var_2 nodes.lkt:436



--# expr-start 160 Cast Cast_Result nodes.lkt:436









   if Ent.Node = null
      or else Ent.Node.Kind in Lkt_Class_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Class_Decl
        (Node => Ent.Node,
         Info => Ent.Info);

   else
         Cast_Result := No_Entity_Class_Decl;
   end if;


--# expr-done 160
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Class_Decl then
   



   --# scope-start



--# expr-start 175 Not Not_Val nodes.lkt:438
--# expr-start 174 .is_null Is_Null_1 nodes.lkt:438
--# expr-start 173 .find Find_Result nodes.lkt:438








   

   --# expr-start 161 BasicClassDecl.traits Fld nodes.lkt:438







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Type_Ref_List (Node => Var_Expr.Node.Basic_Class_Decl_F_Traits, Info => Var_Expr.Info);
--# expr-done 161









Fld_6 := Fld.Node;

   
      Find_Result := No_Entity_Type_Ref;
   

   

      if Fld_6 = null then
         
      Find_Result := No_Entity_Type_Ref;
   
      else
         

      declare
         
         Collection : constant Bare_Type_Ref_List := Fld_6;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Type_Ref;
else
   








Fld_7 := Fld.Info;

As_Entity := (Info => Fld_7, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind t Item

            
      --# expr-start 172 Eq Is_Equiv nodes.lkt:440





--# expr-start 170 .do Result_Var_1 nodes.lkt:440



--# expr-start 162 Cast Cast_Result_1 nodes.lkt:440









   if Item.Node = null
      or else Item.Node.Kind in Lkt_Generic_Type_Ref_Range
   then
      
      Cast_Result_1 := Create_Internal_Entity_Generic_Type_Ref
        (Node => Item.Node,
         Info => Item.Info);

   else
         Cast_Result_1 := No_Entity_Generic_Type_Ref;
   end if;


--# expr-done 162
Var_Expr_1 := Cast_Result_1;





if Var_Expr_1 /= No_Entity_Generic_Type_Ref then
   



   --# scope-start



--# expr-start 169 GenericDecl.decl Fld_4 nodes.lkt:442



--# expr-start 168 Cast Cast_Result_3 nodes.lkt:442





--# expr-start 167 .get_first Env_Get_Result nodes.lkt:442
--# expr-start 163 LktNode.children_env Fld_1 nodes.lkt:442







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Liblktlang.Implementation.Children_Env (Node => Self);
--# expr-done 163



--# expr-start 165 Cast Cast_Result_2 nodes.lkt:443





--# expr-start 164 GenericTypeRef.type_name Fld_2 nodes.lkt:443







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Var_Expr_1.Node.Generic_Type_Ref_F_Type_Name, Info => Var_Expr_1.Info);
--# expr-done 164



   if Fld_2.Node = null
      or else Fld_2.Node.Kind in Lkt_Ref_Id_Range
   then
      
      Cast_Result_2 := Create_Internal_Entity_Ref_Id
        (Node => Fld_2.Node,
         Info => Fld_2.Info);

   else
         Cast_Result_2 := No_Entity_Ref_Id;
   end if;


--# expr-done 165
Var_Expr_2 := Cast_Result_2;





if Var_Expr_2 /= No_Entity_Ref_Id then
   --# expr-start 166 .symbol Sym nodes.lkt:443









Fld_3 := Var_Expr_2.Node; 
Sym := Get_Symbol (Fld_3); 
--# expr-done 166
   Result_Var := Sym;
else
   
   Result_Var := No_Symbol;
end if;





Env_Get_Result := AST_Envs.Get_First (Self => Fld_1, Key => Thin (Result_Var), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 167



   if Env_Get_Result.Node = null
      or else Env_Get_Result.Node.Kind in Lkt_Generic_Decl_Range
   then
      
      Cast_Result_3 := Create_Internal_Entity_Generic_Decl
        (Node => Env_Get_Result.Node,
         Info => Env_Get_Result.Info);

   else
         Cast_Result_3 := No_Entity_Generic_Decl;
   end if;


--# expr-done 168



   if Cast_Result_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Decl (Node => Cast_Result_3.Node.Generic_Decl_F_Decl, Info => Cast_Result_3.Info);
--# expr-done 169
Scope_Result := Fld_4;


   --# end
      Finalizer_Scope_477;


   Result_Var_1 := Scope_Result;
else
   
   Result_Var_1 := No_Entity_Decl;
end if;



--# expr-done 170



   
      Cast_Result_4 := Create_Internal_Entity
        (Node => Result_Var_1.Node,
         Info => Result_Var_1.Info);







--# expr-start 171 LktNode.node_trait Fld_5 nodes.lkt:448







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.node_trait
Fld_5 := Liblktlang.Implementation.Lkt_Node_P_Node_Trait (Node => Self);
--# end
--# expr-done 171



   
      Cast_Result_5 := Create_Internal_Entity
        (Node => Fld_5.Node,
         Info => Fld_5.Info);


Is_Equiv := Equivalent (Cast_Result_4, Cast_Result_5); 
--# expr-done 172
      if Is_Equiv then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Is_Equiv;

         end loop;
      end;
   
      end if;

   
   



--# expr-done 173
Is_Null_1 := Find_Result.Node = null; 
--# expr-done 174
Not_Val := not (Is_Null_1); 
--# expr-done 175
Scope_Result_1 := Not_Val;


   --# end


   Result_Var_2 := Scope_Result_1;
else
   
   Result_Var_2 := False;
end if;



--# expr-done 176

         Property_Result := Result_Var_2;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_477;




            raise;
      end;



   return Property_Result;
end Decl_P_Implements_Node;
--# end

   







--# property-start Decl.as_bare_decl nodes.lkt:456
pragma Warnings (Off, "is not referenced");

function Decl_P_As_Bare_Decl
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Decl
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Decl;

      

      Fld : Bare_Decl;
As_Entity : Internal_Entity_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 178 .as_bare_entity If_Result nodes.lkt:461



--# expr-start 177 'Entity[Decl].node' Fld nodes.lkt:461









Fld := Ent.Node;
--# expr-done 177
Is_Null := Fld = null; 
if Is_Null then
   
   If_Result := No_Entity_Decl;
else
   

As_Entity := (Info => No_Entity_Info, Node => Fld); 
   If_Result := As_Entity;
end if;



--# expr-done 178

         Property_Result := If_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Decl_P_As_Bare_Decl;
--# end

   







--# property-start Decl.is_type_decl nodes.lkt:464
pragma Warnings (Off, "is not referenced");

function Decl_P_Is_Type_Decl
  
  (Node : Bare_Decl
  )

   return Boolean
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
      --# bind node Self

   


   Property_Result : Boolean;

      

      Is_A : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 179 IsA Is_A nodes.lkt:464

Is_A := Self /= null 
and then Self.Kind in Lkt_Type_Decl; 
--# expr-done 179

         Property_Result := Is_A;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Decl_P_Is_Type_Decl;
--# end

   







--# property-start Decl.is_defined nodes.lkt:467
pragma Warnings (Off, "is not referenced");

function Decl_P_Is_Defined
  
  (Node : Bare_Decl
  )

   return Boolean
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
      --# bind node Self

   


   Property_Result : Boolean;

      

      Is_Null : Boolean;
Not_Val : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 181 Not Not_Val nodes.lkt:467
--# expr-start 180 .is_null Is_Null nodes.lkt:467

Is_Null := Self = null; 
--# expr-done 180
Not_Val := not (Is_Null); 
--# expr-done 181

         Property_Result := Not_Val;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Decl_P_Is_Defined;
--# end

   







--# property-start Decl.infer_function_type nodes.lkt:475
pragma Warnings (Off, "is not referenced");

function Decl_P_Infer_Function_Type
  
  (Node : Bare_Decl
      ; Expected_Call : Internal_Entity_Function_Type
      ; In_Logic_Call : Boolean
         := False
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Function_Type
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind expected_call Expected_Call
   --# bind in_logic_call In_Logic_Call

   Property_Result : Internal_Entity_Function_Type;

      
            procedure Finalizer_Scope_478 with Inline_Always;
            procedure Finalizer_Scope_479 with Inline_Always;
            procedure Finalizer_Scope_480 with Inline_Always;

      Cast_Result : Internal_Entity_Function_Type;
Var_Expr : Internal_Entity_Function_Type;
Fld : Internal_Entity_Decl;
Result_Var : Internal_Entity_Decl;
Left_Var : Internal_Entity_Decl;
Result_Var_1 : Internal_Entity_Decl;
Local_Origin : Internal_Entity_Decl;
Cast_Result_1 : Internal_Entity_Function_Type;
Var_Expr_1 : Internal_Entity_Decl;
Fld_1 : Internal_Entity_Function_Type;
Result_Var_2 : Internal_Entity_Function_Type;
Left_Var_1 : Internal_Entity_Function_Type;
Result_Var_3 : Internal_Entity_Function_Type;
Local_Generic_Func : Internal_Entity_Function_Type;
Fld_2 : Internal_Entity;
Cast_Result_2 : Internal_Entity_Generic_Decl;
Fld_3 : Internal_Entity_Generic_Param_Type_Decl_Array_Access;
Cast_Result_3 : Internal_Entity_Type_Decl;
Cast_Result_4 : Internal_Entity_Type_Decl;
Fld_4 : Internal_Entity_Type_Decl_Array_Access;
Var_Expr_2 : Internal_Entity_Type_Decl_Array_Access;
Get_Result : Internal_Entity_Type_Decl;
Var_Expr_3 : Internal_Entity_Type_Decl;
Fld_5 : Internal_Entity_Type_Decl;
Var_Expr_4 : Internal_Entity_Type_Decl;
Cast_Result_5 : Internal_Entity_Type_Decl;
Fld_6 : Boolean;
If_Result : Internal_Entity_Type_Decl;
Scope_Result : Internal_Entity_Type_Decl;
Result_Var_4 : Internal_Entity_Type_Decl;
Result_Var_5 : Internal_Entity_Type_Decl;
Scope_Result_1 : Internal_Entity_Type_Decl;
Result_Var_6 : Internal_Entity_Type_Decl;
Map_Result : Internal_Entity_Type_Decl_Array_Access;
Fld_7 : Internal_Entity_Decl;
Var_Expr_5 : Internal_Entity_Decl;
Fld_8 : Internal_Entity_Function_Type;
Fld_9 : Internal_Entity_Function_Type;
If_Result_1 : Internal_Entity_Function_Type;
Scope_Result_2 : Internal_Entity_Function_Type;
Result_Var_7 : Internal_Entity_Function_Type;
Fld_10 : Boolean;
Not_Val : Boolean;
Fld_11 : Internal_Entity_Function_Type;
Fld_12 : Internal_Entity_Function_Type;
If_Result_2 : Internal_Entity_Function_Type;
If_Result_3 : Internal_Entity_Function_Type;
Is_Null : Boolean;
Is_Null_1 : Boolean;
If_Result_4 : Boolean;
If_Result_5 : Internal_Entity_Function_Type;
Let_Result : Internal_Entity_Function_Type;
Let_Result_1 : Internal_Entity_Function_Type;
Scope_Result_3 : Internal_Entity_Function_Type;

            procedure Finalizer_Scope_478 is
            begin
                     Dec_Ref (Fld_3);
                     Dec_Ref (Map_Result);
            end Finalizer_Scope_478;
            procedure Finalizer_Scope_479 is
            begin
                     Dec_Ref (Fld_4);
            end Finalizer_Scope_479;
            procedure Finalizer_Scope_480 is
            begin
                     Dec_Ref (Var_Expr_2);
            end Finalizer_Scope_480;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 215 ValDecl Let_Result_1 nodes.lkt:478
--# scope-start
--# expr-start 184 'or?' Result_Var_1 nodes.lkt:478






--# expr-start 182 Cast Cast_Result nodes.lkt:478









   if Ent.Node = null
      or else Ent.Node.Kind in Lkt_Function_Type_Range
   then
      
      Cast_Result := Create_Internal_Entity_Function_Type
        (Node => Ent.Node,
         Info => Ent.Info);

   else
         Cast_Result := No_Entity_Function_Type;
   end if;


--# expr-done 182
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Function_Type then
   --# expr-start 183 FunctionType.origin Fld nodes.lkt:478







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Var_Expr.Node.Function_Type_F_Origin;
--# expr-done 183
   Result_Var := Fld;
else
   
   Result_Var := No_Entity_Decl;
end if;



Left_Var := Result_Var;





if Left_Var /= No_Entity_Decl then
   
   Result_Var_1 := Left_Var;
else
   
   Result_Var_1 := Ent;
end if;



--# expr-done 184
Local_Origin := Result_Var_1; 
--# bind origin Local_Origin
--# expr-start 214 ValDecl Let_Result nodes.lkt:479
--# scope-start
--# expr-start 187 'or?' Result_Var_3 nodes.lkt:479



--# expr-start 185 Cast Cast_Result_1 nodes.lkt:479









   if Ent.Node = null
      or else Ent.Node.Kind in Lkt_Function_Type_Range
   then
      
      Cast_Result_1 := Create_Internal_Entity_Function_Type
        (Node => Ent.Node,
         Info => Ent.Info);

   else
         Cast_Result_1 := No_Entity_Function_Type;
   end if;


--# expr-done 185
Left_Var_1 := Cast_Result_1;





if Left_Var_1 /= No_Entity_Function_Type then
   
   Result_Var_3 := Left_Var_1;
else
   



Var_Expr_1 := Ent;





if Var_Expr_1 /= No_Entity_Decl then
   --# expr-start 186 Decl.function_type Fld_1 nodes.lkt:479







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.function_type
Fld_1 := Liblktlang.Implementation.Decl_P_Function_Type (Node => Var_Expr_1.Node, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 186
   Result_Var_2 := Fld_1;
else
   
   Result_Var_2 := No_Entity_Function_Type;
end if;



   Result_Var_3 := Result_Var_2;
end if;



--# expr-done 187
Local_Generic_Func := Result_Var_3; 
--# bind generic_func Local_Generic_Func
--# expr-start 213 If If_Result_5 nodes.lkt:481



--# expr-start 190 BooleanOr If_Result_4 nodes.lkt:481



--# expr-start 188 .is_null Is_Null nodes.lkt:481

Is_Null := Expected_Call.Node = null; 
--# expr-done 188
if Is_Null then
   
   If_Result_4 := True;
else
   --# expr-start 189 .is_null Is_Null_1 nodes.lkt:481

Is_Null_1 := Local_Origin.Node = null; 
--# expr-done 189
   If_Result_4 := Is_Null_1;
end if;



--# expr-done 190
if If_Result_4 then
   
   If_Result_5 := No_Entity_Function_Type;
else
   --# expr-start 212 If If_Result_3 nodes.lkt:481



--# expr-start 192 Not Not_Val nodes.lkt:483
--# expr-start 191 Decl.is_generic Fld_10 nodes.lkt:483







   if Local_Origin.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.is_generic
Fld_10 := Liblktlang.Implementation.Decl_P_Is_Generic (Node => Local_Origin.Node, E_Info => Local_Origin.Info);
--# end
--# expr-done 191
Not_Val := not (Fld_10); 
--# expr-done 192
if Not_Val then
   --# expr-start 195 If If_Result_2 nodes.lkt:485




if In_Logic_Call then
   --# expr-start 193 Decl.logic_function_type Fld_12 nodes.lkt:485







   if Local_Origin.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.logic_function_type
Fld_12 := Liblktlang.Implementation.Decl_P_Logic_Function_Type (Node => Local_Origin.Node, E_Info => Local_Origin.Info);
--# end
--# expr-done 193
   If_Result_2 := Fld_12;
else
   --# expr-start 194 Decl.function_type Fld_11 nodes.lkt:486







   if Local_Origin.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.function_type
Fld_11 := Liblktlang.Implementation.Decl_P_Function_Type (Node => Local_Origin.Node, E_Info => Local_Origin.Info);
--# end
--# expr-done 194
   If_Result_2 := Fld_11;
end if;



--# expr-done 195
   If_Result_3 := If_Result_2;
else
   --# expr-start 211 .do Result_Var_7 nodes.lkt:488



--# expr-start 207 Decl.instantiate_generic_decl Fld_7 nodes.lkt:488







   if Local_Origin.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 206 .map Map_Result nodes.lkt:489








   

   --# expr-start 198 GenericDecl.generic_params Fld_3 nodes.lkt:489



--# expr-start 197 Cast Cast_Result_2 nodes.lkt:489





--# expr-start 196 .parent Fld_2 nodes.lkt:489







   if Local_Origin.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Liblktlang.Implementation.Parent (Node => Local_Origin.Node, E_Info => Local_Origin.Info);
--# expr-done 196



   if Fld_2.Node = null
      or else Fld_2.Node.Kind in Lkt_Generic_Decl_Range
   then
      
      Cast_Result_2 := Create_Internal_Entity_Generic_Decl
        (Node => Fld_2.Node,
         Info => Fld_2.Info);

   else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "invalid object cast");
   end if;


--# expr-done 197



   if Cast_Result_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start GenericDecl.generic_params
Fld_3 := Liblktlang.Implementation.Generic_Decl_P_Generic_Params (Node => Cast_Result_2.Node, E_Info => Cast_Result_2.Info);
--# end
--# expr-done 198

   
      declare
         Map_Result_Vec : Internal_Entity_Type_Decl_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Generic_Param_Type_Decl_Array_Access := Fld_3;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind gf Item

            
         
         
      --# expr-start 205 .do Result_Var_6 nodes.lkt:491



--# expr-start 199 TypeDecl.find_types_that_replace_ty Fld_4 nodes.lkt:491







   if Expected_Call.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;











   
      Cast_Result_3 := Create_Internal_Entity_Type_Decl
        (Node => Item.Node,
         Info => Item.Info);











   
      Cast_Result_4 := Create_Internal_Entity_Type_Decl
        (Node => Local_Generic_Func.Node,
         Info => Local_Generic_Func.Info);


--# property-call-start TypeDecl.find_types_that_replace_ty
Fld_4 := Liblktlang.Implementation.Type_Decl_P_Find_Types_That_Replace_Ty (Node => Expected_Call.Node, Ty => Cast_Result_3, Origin => Cast_Result_4, E_Info => Expected_Call.Info);
--# end
--# expr-done 199
Var_Expr_2 := Fld_4;

      Inc_Ref (Var_Expr_2);




if Var_Expr_2 /= No_Internal_Entity_Type_Decl_Array_Type then
   



   --# scope-start






--# expr-start 200 .at Get_Result nodes.lkt:494




Get_Result := Get (Self, Var_Expr_2, 0, True); 
--# expr-done 200
Var_Expr_3 := Get_Result;





if Var_Expr_3 /= No_Entity_Type_Decl then
   --# expr-start 204 .do Result_Var_4 nodes.lkt:494



--# expr-start 201 TypeDecl.imprecise_common_ancestor_list Fld_5 nodes.lkt:494







   if Var_Expr_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start TypeDecl.imprecise_common_ancestor_list
Fld_5 := Liblktlang.Implementation.Type_Decl_P_Imprecise_Common_Ancestor_List (Node => Var_Expr_3.Node, Other_Types => Var_Expr_2, E_Info => Var_Expr_3.Info);
--# end
--# expr-done 201
Var_Expr_4 := Fld_5;





if Var_Expr_4 /= No_Entity_Type_Decl then
   



   --# scope-start



--# expr-start 203 If If_Result nodes.lkt:496



--# expr-start 202 TypeDecl.matching_type Fld_6 nodes.lkt:496







   if Var_Expr_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;











   
      Cast_Result_5 := Create_Internal_Entity_Type_Decl
        (Node => Item.Node,
         Info => Item.Info);


--# property-call-start TypeDecl.matching_type
Fld_6 := Liblktlang.Implementation.Type_Decl_P_Matching_Type (Node => Var_Expr_4.Node, Other => Cast_Result_5, E_Info => Var_Expr_4.Info);
--# end
--# expr-done 202
if Fld_6 then
   
   If_Result := No_Entity_Type_Decl;
else
   
   If_Result := Var_Expr_4;
end if;



--# expr-done 203
Scope_Result := If_Result;


   --# end


   Result_Var_4 := Scope_Result;
else
   
   Result_Var_4 := No_Entity_Type_Decl;
end if;



--# expr-done 204
   Result_Var_5 := Result_Var_4;
else
   
   Result_Var_5 := No_Entity_Type_Decl;
end if;



Scope_Result_1 := Result_Var_5;


   --# end
      Finalizer_Scope_480;


   Result_Var_6 := Scope_Result_1;
else
   
   Result_Var_6 := No_Entity_Type_Decl;
end if;



--# expr-done 205
      

         declare
            Item_To_Append : constant Internal_Entity_Type_Decl := Result_Var_6;
         begin
            Internal_Entity_Type_Decl_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_479;



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Entity_Type_Decl_Array
           (Items_Count => Natural (Internal_Entity_Type_Decl_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Type_Decl_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Type_Decl_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Type_Decl_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 206
--# property-call-start Decl.instantiate_generic_decl
Fld_7 := Liblktlang.Implementation.Decl_P_Instantiate_Generic_Decl (Node => Local_Origin.Node, Param_Types => Map_Result, E_Info => Local_Origin.Info);
--# end
--# expr-done 207
Var_Expr_5 := Fld_7;





if Var_Expr_5 /= No_Entity_Decl then
   



   --# scope-start



--# expr-start 210 If If_Result_1 nodes.lkt:504




if In_Logic_Call then
   --# expr-start 208 Decl.logic_function_type Fld_9 nodes.lkt:504







   if Var_Expr_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.logic_function_type
Fld_9 := Liblktlang.Implementation.Decl_P_Logic_Function_Type (Node => Var_Expr_5.Node, E_Info => Var_Expr_5.Info);
--# end
--# expr-done 208
   If_Result_1 := Fld_9;
else
   --# expr-start 209 Decl.function_type Fld_8 nodes.lkt:505







   if Var_Expr_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.function_type
Fld_8 := Liblktlang.Implementation.Decl_P_Function_Type (Node => Var_Expr_5.Node, E_Info => Var_Expr_5.Info);
--# end
--# expr-done 209
   If_Result_1 := Fld_8;
end if;



--# expr-done 210
Scope_Result_2 := If_Result_1;


   --# end


   Result_Var_7 := Scope_Result_2;
else
   
   Result_Var_7 := No_Entity_Function_Type;
end if;



--# expr-done 211
   If_Result_3 := Result_Var_7;
end if;



--# expr-done 212
   If_Result_5 := If_Result_3;
end if;



--# expr-done 213
Let_Result := If_Result_5; 
--# end
--# expr-done 214
Let_Result_1 := Let_Result; 
--# end
--# expr-done 215
Scope_Result_3 := Let_Result_1;


   --# end
      Finalizer_Scope_478;



         Property_Result := Scope_Result_3;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_478;
                     Finalizer_Scope_479;
                     Finalizer_Scope_480;




            raise;
      end;



   return Property_Result;
end Decl_P_Infer_Function_Type;
--# end

   







--# property-start Decl.function_type nodes.lkt:510
pragma Warnings (Off, "is not referenced");

function Decl_P_Function_Type
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Function_Type
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Function_Type;

      

      Local_Ft : Internal_Entity_Function_Type;
Local_Td : Internal_Entity_Struct_Decl;
Fld : Internal_Entity_Function_Type;
Local_Td_1 : Internal_Entity_Class_Decl;
Fld_1 : Internal_Entity_Function_Type;
Local_Td_2 : Internal_Entity_Fun_Decl;
Fld_2 : Internal_Entity_Function_Type;
Local_Td_3 : Internal_Entity_Synth_Fun_Decl;
Fld_3 : Internal_Entity_Function_Type;
Local_Td_4 : Internal_Entity_Generic_Decl;
Fld_4 : Internal_Entity_Decl;
Fld_5 : Internal_Entity_Function_Type;
Ignored : Internal_Entity_Decl;
Match_Prefix : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Function_Type;
Let_Result : Internal_Entity_Function_Type;
Scope_Result : Internal_Entity_Function_Type;
Cast_Result_1 : Internal_Entity_Struct_Decl;
Let_Result_1 : Internal_Entity_Function_Type;
Scope_Result_1 : Internal_Entity_Function_Type;
Cast_Result_2 : Internal_Entity_Class_Decl;
Let_Result_2 : Internal_Entity_Function_Type;
Scope_Result_2 : Internal_Entity_Function_Type;
Cast_Result_3 : Internal_Entity_Fun_Decl;
Let_Result_3 : Internal_Entity_Function_Type;
Scope_Result_3 : Internal_Entity_Function_Type;
Cast_Result_4 : Internal_Entity_Synth_Fun_Decl;
Let_Result_4 : Internal_Entity_Function_Type;
Scope_Result_4 : Internal_Entity_Function_Type;
Cast_Result_5 : Internal_Entity_Generic_Decl;
Let_Result_5 : Internal_Entity_Function_Type;
Scope_Result_5 : Internal_Entity_Function_Type;
Cast_Result_6 : Internal_Entity_Decl;
Let_Result_6 : Internal_Entity_Function_Type;
Scope_Result_6 : Internal_Entity_Function_Type;
Match_Result : Internal_Entity_Function_Type;
Is_Null : Boolean;
If_Result : Internal_Entity_Function_Type;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 224 If If_Result nodes.lkt:511



--# expr-start 216 .is_null Is_Null nodes.lkt:511

Is_Null := Ent.Node = null; 
--# expr-done 216
if Is_Null then
   
   If_Result := No_Entity_Function_Type;
else
   --# expr-start 223 Match Match_Result nodes.lkt:513










   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := Ent; 

case Lkt_Decl (Match_Prefix.Node.Kind) is
         when Lkt_Function_Type =>
            



   --# scope-start



--# scope-start









   
      Cast_Result := Create_Internal_Entity_Function_Type
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Ft := Cast_Result; 
--# bind ft Local_Ft

Let_Result := Local_Ft; 
--# end
Scope_Result := Let_Result;


   --# end


            Match_Result := Scope_Result; 
         when Lkt_Struct_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_1 := Create_Internal_Entity_Struct_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Td := Cast_Result_1; 
--# bind td Local_Td
--# expr-start 217 StructDecl.function_type_aux Fld nodes.lkt:515







   if Local_Td.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start StructDecl.function_type_aux
Fld := Liblktlang.Implementation.Struct_Decl_P_Function_Type_Aux (Node => Local_Td.Node, E_Info => Local_Td.Info);
--# end
--# expr-done 217
Let_Result_1 := Fld; 
--# end
Scope_Result_1 := Let_Result_1;


   --# end


            Match_Result := Scope_Result_1; 
         when Lkt_Class_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_2 := Create_Internal_Entity_Class_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Td_1 := Cast_Result_2; 
--# bind td Local_Td_1
--# expr-start 218 ClassDecl.function_type_aux Fld_1 nodes.lkt:516







   if Local_Td_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start ClassDecl.function_type_aux
Fld_1 := Liblktlang.Implementation.Class_Decl_P_Function_Type_Aux (Node => Local_Td_1.Node, E_Info => Local_Td_1.Info);
--# end
--# expr-done 218
Let_Result_2 := Fld_1; 
--# end
Scope_Result_2 := Let_Result_2;


   --# end


            Match_Result := Scope_Result_2; 
         when Lkt_Fun_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_3 := Create_Internal_Entity_Fun_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Td_2 := Cast_Result_3; 
--# bind td Local_Td_2
--# expr-start 219 FunDecl.function_type_aux Fld_2 nodes.lkt:517







   if Local_Td_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start FunDecl.function_type_aux
Fld_2 := Liblktlang.Implementation.Fun_Decl_P_Function_Type_Aux (Node => Local_Td_2.Node, E_Info => Local_Td_2.Info);
--# end
--# expr-done 219
Let_Result_3 := Fld_2; 
--# end
Scope_Result_3 := Let_Result_3;


   --# end


            Match_Result := Scope_Result_3; 
         when Lkt_Synth_Fun_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_4 := Create_Internal_Entity_Synth_Fun_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Td_3 := Cast_Result_4; 
--# bind td Local_Td_3
--# expr-start 220 SynthFunDecl.function_type_aux Fld_3 nodes.lkt:518







   if Local_Td_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start SynthFunDecl.function_type_aux
Fld_3 := Liblktlang.Implementation.Synth_Fun_Decl_P_Function_Type_Aux (Node => Local_Td_3.Node, E_Info => Local_Td_3.Info);
--# end
--# expr-done 220
Let_Result_4 := Fld_3; 
--# end
Scope_Result_4 := Let_Result_4;


   --# end


            Match_Result := Scope_Result_4; 
         when Lkt_Generic_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_5 := Create_Internal_Entity_Generic_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Td_4 := Cast_Result_5; 
--# bind td Local_Td_4
--# expr-start 222 Decl.function_type Fld_5 nodes.lkt:519



--# expr-start 221 GenericDecl.decl Fld_4 nodes.lkt:519







   if Local_Td_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Decl (Node => Local_Td_4.Node.Generic_Decl_F_Decl, Info => Local_Td_4.Info);
--# expr-done 221



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.function_type
Fld_5 := Liblktlang.Implementation.Decl_P_Function_Type (Node => Fld_4.Node, E_Info => Fld_4.Info);
--# end
--# expr-done 222
Let_Result_5 := Fld_5; 
--# end
Scope_Result_5 := Let_Result_5;


   --# end


            Match_Result := Scope_Result_5; 
         when Lkt_Grammar_Rule_Decl .. Lkt_Val_Decl | Lkt_Env_Spec_Decl .. Lkt_Error_Decl | Lkt_Grammar_Decl .. Lkt_Lexer_Family_Decl | Lkt_Synth_Param_Decl .. Lkt_Enum_Class_Alt_Decl | Lkt_Generic_Param_Type_Decl | Lkt_Enum_Class_Decl .. Lkt_Enum_Type_Decl | Lkt_Trait_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_6 := Create_Internal_Entity_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored := Cast_Result_6; 
--# bind _ Ignored

Let_Result_6 := No_Entity_Function_Type; 
--# end
Scope_Result_6 := Let_Result_6;


   --# end


            Match_Result := Scope_Result_6; 
end case;

--# expr-done 223
   If_Result := Match_Result;
end if;



--# expr-done 224

         Property_Result := If_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Decl_P_Function_Type;
--# end

   







--# property-start Decl.logic_function_type nodes.lkt:527
pragma Warnings (Off, "is not referenced");

function Decl_P_Logic_Function_Type
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Function_Type
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Function_Type;

      
            procedure Finalizer_Scope_491 with Inline_Always;

      Local_Td : Internal_Entity_Fun_Decl;
Fld : Internal_Entity_Function_Type;
Var_Expr : Internal_Entity_Function_Type;
Fld_1 : Internal_Entity_Named_Type_Decl;
Fld_2 : Bare_Type_Decl;
As_Entity : Internal_Entity_Type_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Type_Decl;
Array_Lit : Internal_Entity_Type_Decl_Array_Access;
Fld_3 : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Type_Decl;
Singleton : Internal_Entity_Type_Decl_Array_Access;
Fld_4 : Internal_Entity_Type_Decl_Array_Access;
Concat_Result : Internal_Entity_Type_Decl_Array_Access;
Fld_5 : Internal_Entity_Type_Decl;
Fld_6 : Internal_Entity_Decl;
Fld_7 : Bare_Synthetic_Type_Ref_List;
New_Node : Bare_Function_Type;
As_Entity_1 : Internal_Entity_Function_Type;
Is_Null_1 : Boolean;
If_Result_1 : Internal_Entity_Function_Type;
Fld_8 : Boolean;
Fld_9 : Internal_Entity_Named_Type_Decl;
Fld_10 : Internal_Entity_Type_Decl;
Array_Lit_1 : Internal_Entity_Type_Decl_Array_Access;
Fld_11 : Internal_Entity_Type_Decl_Array_Access;
Index : Integer;
Comp_Result : Boolean;
Map_Result : Internal_Entity_Type_Decl_Array_Access;
Concat_Result_1 : Internal_Entity_Type_Decl_Array_Access;
Fld_12 : Internal_Entity_Type_Decl;
Fld_13 : Internal_Entity_Decl;
Fld_14 : Bare_Synthetic_Type_Ref_List;
New_Node_1 : Bare_Function_Type;
As_Entity_2 : Internal_Entity_Function_Type;
Is_Null_2 : Boolean;
If_Result_2 : Internal_Entity_Function_Type;
If_Result_3 : Internal_Entity_Function_Type;
Scope_Result : Internal_Entity_Function_Type;
Result_Var : Internal_Entity_Function_Type;
Ignored : Internal_Entity_Decl;
Match_Prefix : Internal_Entity_Decl;
Cast_Result_1 : Internal_Entity_Fun_Decl;
Let_Result : Internal_Entity_Function_Type;
Scope_Result_1 : Internal_Entity_Function_Type;
Cast_Result_2 : Internal_Entity_Decl;
Let_Result_1 : Internal_Entity_Function_Type;
Scope_Result_2 : Internal_Entity_Function_Type;
Match_Result : Internal_Entity_Function_Type;

            procedure Finalizer_Scope_491 is
            begin
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Singleton);
                     Dec_Ref (Fld_4);
                     Dec_Ref (Concat_Result);
                     Dec_Ref (Array_Lit_1);
                     Dec_Ref (Fld_11);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Concat_Result_1);
            end Finalizer_Scope_491;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Decl_Decl_P_Logic_Function_Type,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Decl,
                                As_Bare_Decl => Self);
               Mmz_K.Items (2) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Entity_Function_Type;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 255 Match Match_Result nodes.lkt:527










   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := Ent; 

case Lkt_Decl (Match_Prefix.Node.Kind) is
         when Lkt_Fun_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_1 := Create_Internal_Entity_Fun_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Td := Cast_Result_1; 
--# bind td Local_Td
--# expr-start 254 .do Result_Var nodes.lkt:529



--# expr-start 225 FunDecl.function_type_aux Fld nodes.lkt:529







   if Local_Td.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start FunDecl.function_type_aux
Fld := Liblktlang.Implementation.Fun_Decl_P_Function_Type_Aux (Node => Local_Td.Node, E_Info => Local_Td.Info);
--# end
--# expr-done 225
Var_Expr := Fld;





if Var_Expr /= No_Entity_Function_Type then
   



   --# scope-start



--# expr-start 253 If If_Result_3 nodes.lkt:531



--# expr-start 226 FunDecl.is_dynamic_combiner Fld_8 nodes.lkt:531







   if Local_Td.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start FunDecl.is_dynamic_combiner
Fld_8 := Liblktlang.Implementation.Fun_Decl_P_Is_Dynamic_Combiner (Node => Local_Td.Node, E_Info => Local_Td.Info);
--# end
--# expr-done 226
if Fld_8 then
   --# expr-start 238 .as_entity If_Result_2 nodes.lkt:536



--# expr-start 237 'New[FunctionType]' New_Node_1 nodes.lkt:536
--# expr-start 227 FunctionType.origin Fld_13 nodes.lkt:540







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_13 := Var_Expr.Node.Function_Type_F_Origin;
--# expr-done 227
--# expr-start 234 ArrayConcat Concat_Result_1 nodes.lkt:537
--# expr-start 230 ArrayLiteral Array_Lit_1 nodes.lkt:537
--# expr-start 229 TypeDecl.make_array_type Fld_10 nodes.lkt:537



--# expr-start 228 LktNode.logicvar_type Fld_9 nodes.lkt:537







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.logicvar_type
Fld_9 := Liblktlang.Implementation.Lkt_Node_P_Logicvar_Type (Node => Ent.Node);
--# end
--# expr-done 228



   if Fld_9.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.make_array_type
Fld_10 := Liblktlang.Implementation.Type_Decl_P_Make_Array_Type (Node => Fld_9.Node, E_Info => Fld_9.Info);
--# end
--# expr-done 229
Array_Lit_1 := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Fld_10)); 
--# expr-done 230
--# expr-start 233 .ifilter Map_Result nodes.lkt:538








   

   --# expr-start 231 FunctionType.params Fld_11 nodes.lkt:538







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Var_Expr.Node.Function_Type_F_Params;
Inc_Ref (Fld_11);
--# expr-done 231

   
      declare
         Map_Result_Vec : Internal_Entity_Type_Decl_Vectors.Vector;
      begin
   

   

      
         Index := 0;

      declare
         
         Collection : constant Internal_Entity_Type_Decl_Array_Access := Fld_11;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind _ Item
               --# bind i Index

            
         --# expr-start 232 'OrderingTest <OrderingTestKind.greater_or_equal: 4>' Comp_Result nodes.lkt:538


Comp_Result := Index >= 1; 
--# expr-done 232
         if Comp_Result then
            
         
      
      

         declare
            Item_To_Append : constant Internal_Entity_Type_Decl := Item;
         begin
            Internal_Entity_Type_Decl_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
         end if;
   

            
   --# end



               Index := Index + 1;
         end loop;
      end;
   

   

         Map_Result := Create_Internal_Entity_Type_Decl_Array
           (Items_Count => Natural (Internal_Entity_Type_Decl_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Type_Decl_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Type_Decl_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Type_Decl_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 233
Concat_Result_1 := Concat (Array_Lit_1, Map_Result); 
--# expr-done 234
--# expr-start 235 FunctionType.return_type Fld_12 nodes.lkt:539







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_12 := Var_Expr.Node.Function_Type_F_Return_Type;
--# expr-done 235
--# expr-start 236 LktNode.get_empty_type_ref_list Fld_14 nodes.lkt:541







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.get_empty_type_ref_list
Fld_14 := Liblktlang.Implementation.Lkt_Node_P_Get_Empty_Type_Ref_List (Node => Self);
--# end
--# expr-done 236
Inc_Ref (Concat_Result_1);


if Is_Foreign_Strict (Self.Self_Env, Self) then
   Raise_Property_Exception
     (Self,
      Property_Error'Identity,
      "synthetic nodes cannot have foreign lexical envs");
end if;


New_Node_1 := new Root_Node_Record
  (Lkt_Function_Type);
Initialize
  (Self => New_Node_1,
   Kind => Lkt_Function_Type,
   Unit => Self.Unit,

   Token_Start_Index => No_Token_Index,
   Token_End_Index   => No_Token_Index,

   Parent => Self,

   Self_Env => Self.Self_Env);
Register_Destroyable (Self.Unit, New_Node_1);

   Initialize_Fields_For_Function_Type
     (Self => New_Node_1,
      Function_Type_F_Traits => Fld_14);

      New_Node_1.Function_Type_F_Origin :=
         Fld_13;
      New_Node_1.Function_Type_F_Params :=
         Concat_Result_1;
      New_Node_1.Function_Type_F_Return_Type :=
         Fld_12;

--# expr-done 237
Is_Null_2 := New_Node_1 = null; 
if Is_Null_2 then
   
   If_Result_2 := No_Entity_Function_Type;
else
   

As_Entity_2 := (Info => E_Info, Node => New_Node_1); 
   If_Result_2 := As_Entity_2;
end if;



--# expr-done 238
   If_Result_3 := If_Result_2;
else
   --# expr-start 252 .as_entity If_Result_1 nodes.lkt:548



--# expr-start 251 'New[FunctionType]' New_Node nodes.lkt:548
--# expr-start 239 FunctionType.origin Fld_6 nodes.lkt:558







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Var_Expr.Node.Function_Type_F_Origin;
--# expr-done 239
--# expr-start 248 ArrayConcat Concat_Result nodes.lkt:550
--# expr-start 246 .singleton Singleton nodes.lkt:550
--# expr-start 245 Cast Cast_Result nodes.lkt:550





--# expr-start 244 Decl.instantiate_generic_decl Fld_3 nodes.lkt:550



--# expr-start 240 LktNode.entity_type Fld_1 nodes.lkt:550







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_1 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Self);
--# end
--# expr-done 240



   if Fld_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 243 ArrayLiteral Array_Lit nodes.lkt:552
--# expr-start 242 .as_entity If_Result nodes.lkt:552



--# expr-start 241 FunDecl.owning_type Fld_2 nodes.lkt:552







   if Local_Td.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start FunDecl.owning_type
Fld_2 := Liblktlang.Implementation.Fun_Decl_P_Owning_Type (Node => Local_Td.Node);
--# end
--# expr-done 241
Is_Null := Fld_2 = null; 
if Is_Null then
   
   If_Result := No_Entity_Type_Decl;
else
   

As_Entity := (Info => E_Info, Node => Fld_2); 
   If_Result := As_Entity;
end if;



--# expr-done 242
Array_Lit := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => If_Result)); 
--# expr-done 243
--# property-call-start Decl.instantiate_generic_decl
Fld_3 := Liblktlang.Implementation.Decl_P_Instantiate_Generic_Decl (Node => Fld_1.Node, Param_Types => Array_Lit, E_Info => Fld_1.Info);
--# end
--# expr-done 244



   if Fld_3.Node = null
      or else Fld_3.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => Fld_3.Node,
         Info => Fld_3.Info);

   else
         Cast_Result := No_Entity_Type_Decl;
   end if;


--# expr-done 245
            Singleton := Create_Internal_Entity_Type_Decl_Array (Items_Count => 1);
            Singleton.Items (1) := Cast_Result;
            
        
--# expr-done 246
--# expr-start 247 FunctionType.params Fld_4 nodes.lkt:556







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Var_Expr.Node.Function_Type_F_Params;
Inc_Ref (Fld_4);
--# expr-done 247
Concat_Result := Concat (Singleton, Fld_4); 
--# expr-done 248
--# expr-start 249 FunctionType.return_type Fld_5 nodes.lkt:557







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Var_Expr.Node.Function_Type_F_Return_Type;
--# expr-done 249
--# expr-start 250 LktNode.get_empty_type_ref_list Fld_7 nodes.lkt:559







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.get_empty_type_ref_list
Fld_7 := Liblktlang.Implementation.Lkt_Node_P_Get_Empty_Type_Ref_List (Node => Self);
--# end
--# expr-done 250
Inc_Ref (Concat_Result);


if Is_Foreign_Strict (Self.Self_Env, Self) then
   Raise_Property_Exception
     (Self,
      Property_Error'Identity,
      "synthetic nodes cannot have foreign lexical envs");
end if;


New_Node := new Root_Node_Record
  (Lkt_Function_Type);
Initialize
  (Self => New_Node,
   Kind => Lkt_Function_Type,
   Unit => Self.Unit,

   Token_Start_Index => No_Token_Index,
   Token_End_Index   => No_Token_Index,

   Parent => Self,

   Self_Env => Self.Self_Env);
Register_Destroyable (Self.Unit, New_Node);

   Initialize_Fields_For_Function_Type
     (Self => New_Node,
      Function_Type_F_Traits => Fld_7);

      New_Node.Function_Type_F_Origin :=
         Fld_6;
      New_Node.Function_Type_F_Params :=
         Concat_Result;
      New_Node.Function_Type_F_Return_Type :=
         Fld_5;

--# expr-done 251
Is_Null_1 := New_Node = null; 
if Is_Null_1 then
   
   If_Result_1 := No_Entity_Function_Type;
else
   

As_Entity_1 := (Info => E_Info, Node => New_Node); 
   If_Result_1 := As_Entity_1;
end if;



--# expr-done 252
   If_Result_3 := If_Result_1;
end if;



--# expr-done 253
Scope_Result := If_Result_3;


   --# end
      Finalizer_Scope_491;


   Result_Var := Scope_Result;
else
   
   Result_Var := No_Entity_Function_Type;
end if;



--# expr-done 254
Let_Result := Result_Var; 
--# end
Scope_Result_1 := Let_Result;


   --# end


            Match_Result := Scope_Result_1; 
         when Lkt_Grammar_Rule_Decl .. Lkt_Val_Decl | Lkt_Env_Spec_Decl .. Lkt_Trait_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_2 := Create_Internal_Entity_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored := Cast_Result_2; 
--# bind _ Ignored

Let_Result_1 := No_Entity_Function_Type; 
--# end
Scope_Result_2 := Let_Result_1;


   --# end


            Match_Result := Scope_Result_2; 
end case;

--# expr-done 255

         Property_Result := Match_Result;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_491;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Entity_Function_Type,
                     As_Internal_Entity_Function_Type => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Decl_P_Logic_Function_Type;
--# end

   







--# property-start Decl.get_type nodes.lkt:570
pragma Warnings (Off, "is not referenced");

function Decl_P_Get_Type
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_498 with Inline_Always;
            procedure Finalizer_Scope_506 with Inline_Always;

      Var_Expr : Internal_Entity_Decl;
Local_Td : Internal_Entity_Type_Decl;
Local_Fd : Internal_Entity_Fun_Decl;
Fld : Internal_Entity_Function_Type;
Fld_1 : Internal_Entity_Full_Decl;
Sym : Symbol_Type;
Fld_2 : Boolean;
Fld_3 : Internal_Entity_Type_Ref;
Fld_4 : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity_Type_Decl;
If_Result : Internal_Entity_Type_Decl;
Local_Eld : Internal_Entity_Enum_Lit_Decl;
Fld_5 : Internal_Entity_Type_Decl;
Local_Vd : Internal_Entity_Val_Decl;
Fld_6 : Internal_Solver_Result := No_Solver_Result;
Fld_7 : Boolean;
Fld_8 : Internal_Entity_Expr;
Fld_9 : Internal_Entity_Type_Decl;
If_Result_1 : Internal_Entity_Type_Decl;
Fld_10 : Internal_Entity_Type_Ref;
Is_Null : Boolean;
Not_Val : Boolean;
Fld_11 : Internal_Entity_Type_Ref;
Fld_12 : Internal_Entity_Type_Decl;
If_Result_2 : Internal_Entity_Type_Decl;
Local_Mvd : Internal_Entity_Match_Val_Decl;
Fld_13 : Internal_Entity_Expr;
Fld_14 : Internal_Entity_Type_Decl;
Var_Expr_1 : Internal_Entity_Type_Decl;
Fld_15 : Internal_Entity_Type_Ref;
Fld_16 : Internal_Entity_Type_Decl;
Fld_17 : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;
Fld_18 : Internal_Entity_Type_Ref;
Is_Null_1 : Boolean;
Fld_19 : Internal_Entity_Expr;
Fld_20 : Internal_Entity_Type_Decl;
If_Result_3 : Internal_Entity_Type_Decl;
Local_Bvd : Internal_Entity_Binding_Val_Decl;
Fld_21 : Internal_Entity;
Fld_22 : Internal_Entity;
Cast_Result_1 : Internal_Entity_Pattern_Match_Branch;
Var_Expr_2 : Internal_Entity_Pattern_Match_Branch;
Fld_23 : Internal_Entity;
Fld_24 : Internal_Entity;
Cast_Result_2 : Internal_Entity_Match_Expr;
Fld_25 : Internal_Entity_Expr;
Fld_26 : Internal_Entity_Type_Decl;
Scope_Result : Internal_Entity_Type_Decl;
Result_Var_1 : Internal_Entity_Type_Decl;
Local_Lad : Internal_Entity_Lambda_Param_Decl;
Fld_27 : Internal_Entity_Type_Ref;
Fld_28 : Internal_Entity_Type_Decl;
Fld_29 : Internal_Entity_Type_Ref;
Is_Null_2 : Boolean;
Fld_30 : Internal_Entity;
Fld_31 : Internal_Entity;
Cast_Result_3 : Internal_Entity_Lambda_Expr;
Var_Expr_3 : Internal_Entity_Lambda_Expr;
Fld_32 : Boolean;
Fld_33 : Logic_Var;
Is_Logic_Var_Defined : Boolean;
Eq_Solution : Internal_Entity;
If_Result_4 : Internal_Entity;
Cast_Result_4 : Internal_Entity_Type_Decl;
If_Result_5 : Internal_Entity_Type_Decl;
Scope_Result_1 : Internal_Entity_Type_Decl;
Result_Var_2 : Internal_Entity_Type_Decl;
If_Result_6 : Internal_Entity_Type_Decl;
Local_Etd : Internal_Entity_Explicitly_Typed_Decl;
Fld_34 : Internal_Entity_Type_Ref;
Fld_35 : Internal_Entity_Type_Decl;
Local_Gd : Internal_Entity_Generic_Decl;
Fld_36 : Internal_Entity_Decl;
Fld_37 : Internal_Entity_Type_Decl;
Local_Sd : Internal_Entity_Self_Decl;
Fld_38 : Internal_Entity_Named_Type_Decl;
Fld_39 : Internal_Entity_Type_Decl;
Array_Lit : Internal_Entity_Type_Decl_Array_Access;
Fld_40 : Internal_Entity_Decl;
Cast_Result_5 : Internal_Entity_Type_Decl;
Local_Nd : Internal_Entity_Node_Decl;
Fld_41 : Internal_Entity_Type_Decl;
Ignored : Internal_Entity_Decl;
Match_Prefix : Internal_Entity_Decl;
Cast_Result_6 : Internal_Entity_Type_Decl;
Let_Result : Internal_Entity_Type_Decl;
Scope_Result_2 : Internal_Entity_Type_Decl;
Cast_Result_7 : Internal_Entity_Fun_Decl;
Let_Result_1 : Internal_Entity_Type_Decl;
Scope_Result_3 : Internal_Entity_Type_Decl;
Cast_Result_8 : Internal_Entity_Enum_Lit_Decl;
Let_Result_2 : Internal_Entity_Type_Decl;
Scope_Result_4 : Internal_Entity_Type_Decl;
Cast_Result_9 : Internal_Entity_Val_Decl;
Let_Result_3 : Internal_Entity_Type_Decl;
Scope_Result_5 : Internal_Entity_Type_Decl;
Cast_Result_10 : Internal_Entity_Match_Val_Decl;
Let_Result_4 : Internal_Entity_Type_Decl;
Scope_Result_6 : Internal_Entity_Type_Decl;
Cast_Result_11 : Internal_Entity_Binding_Val_Decl;
Let_Result_5 : Internal_Entity_Type_Decl;
Scope_Result_7 : Internal_Entity_Type_Decl;
Cast_Result_12 : Internal_Entity_Lambda_Param_Decl;
Let_Result_6 : Internal_Entity_Type_Decl;
Scope_Result_8 : Internal_Entity_Type_Decl;
Cast_Result_13 : Internal_Entity_Explicitly_Typed_Decl;
Let_Result_7 : Internal_Entity_Type_Decl;
Scope_Result_9 : Internal_Entity_Type_Decl;
Cast_Result_14 : Internal_Entity_Generic_Decl;
Let_Result_8 : Internal_Entity_Type_Decl;
Scope_Result_10 : Internal_Entity_Type_Decl;
Cast_Result_15 : Internal_Entity_Self_Decl;
Let_Result_9 : Internal_Entity_Type_Decl;
Scope_Result_11 : Internal_Entity_Type_Decl;
Cast_Result_16 : Internal_Entity_Node_Decl;
Let_Result_10 : Internal_Entity_Type_Decl;
Scope_Result_12 : Internal_Entity_Type_Decl;
Cast_Result_17 : Internal_Entity_Decl;
Let_Result_11 : Internal_Entity_Type_Decl;
Scope_Result_13 : Internal_Entity_Type_Decl;
Match_Result : Internal_Entity_Type_Decl;
Scope_Result_14 : Internal_Entity_Type_Decl;
Result_Var_3 : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_498 is
            begin
                     Dec_Ref (Fld_6);
            end Finalizer_Scope_498;
            procedure Finalizer_Scope_506 is
            begin
                     Dec_Ref (Array_Lit);
            end Finalizer_Scope_506;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Decl_Decl_P_Get_Type,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Decl,
                                As_Bare_Decl => Self);
               Mmz_K.Items (2) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Entity_Type_Decl;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 319 .do Result_Var_3 nodes.lkt:571




Var_Expr := Ent;





if Var_Expr /= No_Entity_Decl then
   



   --# scope-start



--# expr-start 318 Match Match_Result nodes.lkt:573










   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := Var_Expr; 

case Lkt_Decl (Match_Prefix.Node.Kind) is
         when Lkt_Any_Type_Decl .. Lkt_Trait_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_6 := Create_Internal_Entity_Type_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Td := Cast_Result_6; 
--# bind td Local_Td

Let_Result := Local_Td; 
--# end
Scope_Result_2 := Let_Result;


   --# end


            Match_Result := Scope_Result_2; 
         when Lkt_Fun_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_7 := Create_Internal_Entity_Fun_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Fd := Cast_Result_7; 
--# bind fd Local_Fd
--# expr-start 262 If If_Result nodes.lkt:576



--# expr-start 258 FullDecl.has_annotation Fld_2 nodes.lkt:576



--# expr-start 256 Decl.full_decl Fld_1 nodes.lkt:576







   if Local_Fd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.full_decl
Fld_1 := Liblktlang.Implementation.Decl_P_Full_Decl (Node => Local_Fd.Node, E_Info => Local_Fd.Info);
--# end
--# expr-done 256



   if Fld_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 257 SymbolLiteral Sym nodes.lkt:576
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Property); 
--# expr-done 257
--# property-call-start FullDecl.has_annotation
Fld_2 := Liblktlang.Implementation.Full_Decl_P_Has_Annotation (Node => Fld_1.Node, Name => Sym);
--# end
--# expr-done 258
if Fld_2 then
   --# expr-start 260 TypeRef.referenced_decl Fld_4 nodes.lkt:577



--# expr-start 259 FunDecl.return_type Fld_3 nodes.lkt:577







   if Local_Fd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Type_Ref (Node => Local_Fd.Node.Fun_Decl_F_Return_Type, Info => Local_Fd.Info);
--# expr-done 259



   if Fld_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_4 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Fld_3.Node, E_Info => Fld_3.Info);
--# end
--# expr-done 260
   If_Result := Fld_4;
else
   




--# expr-start 261 Decl.function_type Fld nodes.lkt:578







   if Local_Fd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.function_type
Fld := Liblktlang.Implementation.Decl_P_Function_Type (Node => Local_Fd.Node, E_Info => Local_Fd.Info);
--# end
--# expr-done 261



   
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => Fld.Node,
         Info => Fld.Info);


   If_Result := Cast_Result;
end if;



--# expr-done 262
Let_Result_1 := If_Result; 
--# end
Scope_Result_3 := Let_Result_1;


   --# end


            Match_Result := Scope_Result_3; 
         when Lkt_Enum_Lit_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_8 := Create_Internal_Entity_Enum_Lit_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Eld := Cast_Result_8; 
--# bind eld Local_Eld
--# expr-start 263 EnumLitDecl.parent_type Fld_5 nodes.lkt:579







   if Local_Eld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start EnumLitDecl.parent_type
Fld_5 := Liblktlang.Implementation.Enum_Lit_Decl_P_Parent_Type (Node => Local_Eld.Node, E_Info => Local_Eld.Info);
--# end
--# expr-done 263
Let_Result_2 := Fld_5; 
--# end
Scope_Result_4 := Let_Result_2;


   --# end


            Match_Result := Scope_Result_4; 
         when Lkt_Val_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_9 := Create_Internal_Entity_Val_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Vd := Cast_Result_9; 
--# bind vd Local_Vd
--# expr-start 274 If If_Result_2 nodes.lkt:581



--# expr-start 266 Not Not_Val nodes.lkt:581
--# expr-start 265 .is_null Is_Null nodes.lkt:581
--# expr-start 264 ValDecl.decl_type Fld_10 nodes.lkt:581







   if Local_Vd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Create_Internal_Entity_Type_Ref (Node => Local_Vd.Node.Val_Decl_F_Decl_Type, Info => Local_Vd.Info);
--# expr-done 264
Is_Null := Fld_10.Node = null; 
--# expr-done 265
Not_Val := not (Is_Null); 
--# expr-done 266
if Not_Val then
   --# expr-start 268 TypeRef.referenced_decl Fld_12 nodes.lkt:582



--# expr-start 267 ValDecl.decl_type Fld_11 nodes.lkt:582







   if Local_Vd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Create_Internal_Entity_Type_Ref (Node => Local_Vd.Node.Val_Decl_F_Decl_Type, Info => Local_Vd.Info);
--# expr-done 267



   if Fld_11.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_12 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Fld_11.Node, E_Info => Fld_11.Info);
--# end
--# expr-done 268
   If_Result_2 := Fld_12;
else
   --# expr-start 273 If If_Result_1 nodes.lkt:581



--# expr-start 270 SolverResult.success Fld_7 nodes.lkt:583



--# expr-start 269 LktNode.solve_enclosing_context Fld_6 nodes.lkt:583







   if Local_Vd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.solve_enclosing_context
Fld_6 := Liblktlang.Implementation.Lkt_Node_P_Solve_Enclosing_Context (Node => Local_Vd.Node, E_Info => Local_Vd.Info);
--# end
--# expr-done 269





Fld_7 := Fld_6.Success;
--# expr-done 270
if Fld_7 then
   --# expr-start 272 Expr.get_type Fld_9 nodes.lkt:584



--# expr-start 271 ValDecl.expr Fld_8 nodes.lkt:584







   if Local_Vd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Create_Internal_Entity_Expr (Node => Local_Vd.Node.Val_Decl_F_Expr, Info => Local_Vd.Info);
--# expr-done 271



   if Fld_8.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.get_type'
Fld_9 := Liblktlang.Implementation.Dispatcher_Expr_P_Get_Type (Node => Fld_8.Node, E_Info => Fld_8.Info);
--# end
--# expr-done 272
   If_Result_1 := Fld_9;
else
   
   If_Result_1 := No_Entity_Type_Decl;
end if;



--# expr-done 273
   If_Result_2 := If_Result_1;
end if;



--# expr-done 274
Let_Result_3 := If_Result_2; 
--# end
Scope_Result_5 := Let_Result_3;


   --# end
      Finalizer_Scope_498;


            Match_Result := Scope_Result_5; 
         when Lkt_Match_Val_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_10 := Create_Internal_Entity_Match_Val_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Mvd := Cast_Result_10; 
--# bind mvd Local_Mvd
--# expr-start 284 If If_Result_3 nodes.lkt:587



--# expr-start 276 .is_null Is_Null_1 nodes.lkt:587
--# expr-start 275 MatchValDecl.decl_type Fld_18 nodes.lkt:587







   if Local_Mvd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_18 := Create_Internal_Entity_Type_Ref (Node => Local_Mvd.Node.Match_Val_Decl_F_Decl_Type, Info => Local_Mvd.Info);
--# expr-done 275
Is_Null_1 := Fld_18.Node = null; 
--# expr-done 276
if Is_Null_1 then
   --# expr-start 278 Expr.get_type Fld_20 nodes.lkt:587



--# expr-start 277 MatchValDecl.match_expr Fld_19 nodes.lkt:587







   if Local_Mvd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start MatchValDecl.match_expr
Fld_19 := Liblktlang.Implementation.Match_Val_Decl_P_Match_Expr (Node => Local_Mvd.Node, E_Info => Local_Mvd.Info);
--# end
--# expr-done 277



   if Fld_19.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.get_type'
Fld_20 := Liblktlang.Implementation.Dispatcher_Expr_P_Get_Type (Node => Fld_19.Node, E_Info => Fld_19.Info);
--# end
--# expr-done 278
   If_Result_3 := Fld_20;
else
   


--# expr-start 280 Expr.get_type Fld_14 nodes.lkt:589



--# expr-start 279 MatchValDecl.match_expr Fld_13 nodes.lkt:589







   if Local_Mvd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start MatchValDecl.match_expr
Fld_13 := Liblktlang.Implementation.Match_Val_Decl_P_Match_Expr (Node => Local_Mvd.Node, E_Info => Local_Mvd.Info);
--# end
--# expr-done 279



   if Fld_13.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.get_type'
Fld_14 := Liblktlang.Implementation.Dispatcher_Expr_P_Get_Type (Node => Fld_13.Node, E_Info => Fld_13.Info);
--# end
--# expr-done 280
Var_Expr_1 := Fld_14;





if Var_Expr_1 /= No_Entity_Type_Decl then
   --# expr-start 283 Decl.get_cast_type Fld_17 nodes.lkt:589







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 282 TypeRef.referenced_decl Fld_16 nodes.lkt:590



--# expr-start 281 MatchValDecl.decl_type Fld_15 nodes.lkt:590







   if Local_Mvd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_15 := Create_Internal_Entity_Type_Ref (Node => Local_Mvd.Node.Match_Val_Decl_F_Decl_Type, Info => Local_Mvd.Info);
--# expr-done 281



   if Fld_15.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_16 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Fld_15.Node, E_Info => Fld_15.Info);
--# end
--# expr-done 282
--# property-call-start Decl.get_cast_type
Fld_17 := Liblktlang.Implementation.Decl_P_Get_Cast_Type (Node => Var_Expr_1.Node, Cast_To => Fld_16, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 283
   Result_Var := Fld_17;
else
   
   Result_Var := No_Entity_Type_Decl;
end if;



   If_Result_3 := Result_Var;
end if;



--# expr-done 284
Let_Result_4 := If_Result_3; 
--# end
Scope_Result_6 := Let_Result_4;


   --# end


            Match_Result := Scope_Result_6; 
         when Lkt_Binding_Val_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_11 := Create_Internal_Entity_Binding_Val_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Bvd := Cast_Result_11; 
--# bind bvd Local_Bvd
--# expr-start 293 .do Result_Var_1 nodes.lkt:598



--# expr-start 287 Cast Cast_Result_1 nodes.lkt:598





--# expr-start 286 .parent Fld_22 nodes.lkt:598



--# expr-start 285 .parent Fld_21 nodes.lkt:598







   if Local_Bvd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_21 := Liblktlang.Implementation.Parent (Node => Local_Bvd.Node, E_Info => Local_Bvd.Info);
--# expr-done 285



   if Fld_21.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_22 := Liblktlang.Implementation.Parent (Node => Fld_21.Node, E_Info => Fld_21.Info);
--# expr-done 286



   if Fld_22.Node = null
      or else Fld_22.Node.Kind in Lkt_Pattern_Match_Branch_Range
   then
      
      Cast_Result_1 := Create_Internal_Entity_Pattern_Match_Branch
        (Node => Fld_22.Node,
         Info => Fld_22.Info);

   else
         Cast_Result_1 := No_Entity_Pattern_Match_Branch;
   end if;


--# expr-done 287
Var_Expr_2 := Cast_Result_1;





if Var_Expr_2 /= No_Entity_Pattern_Match_Branch then
   



   --# scope-start



--# expr-start 292 Expr.get_type Fld_26 nodes.lkt:600



--# expr-start 291 MatchExpr.match_expr Fld_25 nodes.lkt:600



--# expr-start 290 Cast Cast_Result_2 nodes.lkt:600





--# expr-start 289 .parent Fld_24 nodes.lkt:600



--# expr-start 288 .parent Fld_23 nodes.lkt:600







   if Var_Expr_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_23 := Liblktlang.Implementation.Parent (Node => Var_Expr_2.Node, E_Info => Var_Expr_2.Info);
--# expr-done 288



   if Fld_23.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_24 := Liblktlang.Implementation.Parent (Node => Fld_23.Node, E_Info => Fld_23.Info);
--# expr-done 289



   if Fld_24.Node = null
      or else Fld_24.Node.Kind in Lkt_Match_Expr_Range
   then
      
      Cast_Result_2 := Create_Internal_Entity_Match_Expr
        (Node => Fld_24.Node,
         Info => Fld_24.Info);

   else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "invalid object cast");
   end if;


--# expr-done 290



   if Cast_Result_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_25 := Create_Internal_Entity_Expr (Node => Cast_Result_2.Node.Match_Expr_F_Match_Expr, Info => Cast_Result_2.Info);
--# expr-done 291



   if Fld_25.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.get_type'
Fld_26 := Liblktlang.Implementation.Dispatcher_Expr_P_Get_Type (Node => Fld_25.Node, E_Info => Fld_25.Info);
--# end
--# expr-done 292
Scope_Result := Fld_26;


   --# end


   Result_Var_1 := Scope_Result;
else
   
   Result_Var_1 := raise Property_Error with "Patterns typing not implemented yet";
end if;



--# expr-done 293
Let_Result_5 := Result_Var_1; 
--# end
Scope_Result_7 := Let_Result_5;


   --# end


            Match_Result := Scope_Result_7; 
         when Lkt_Lambda_Param_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_12 := Create_Internal_Entity_Lambda_Param_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Lad := Cast_Result_12; 
--# bind lad Local_Lad
--# expr-start 307 If If_Result_6 nodes.lkt:606



--# expr-start 295 .is_null Is_Null_2 nodes.lkt:606
--# expr-start 294 LambdaParamDecl.decl_type Fld_29 nodes.lkt:606







   if Local_Lad.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_29 := Create_Internal_Entity_Type_Ref (Node => Local_Lad.Node.Lambda_Param_Decl_F_Decl_Type, Info => Local_Lad.Info);
--# expr-done 294
Is_Null_2 := Fld_29.Node = null; 
--# expr-done 295
if Is_Null_2 then
   --# expr-start 304 .do Result_Var_2 nodes.lkt:608



--# expr-start 298 Cast Cast_Result_3 nodes.lkt:608





--# expr-start 297 .parent Fld_31 nodes.lkt:608



--# expr-start 296 .parent Fld_30 nodes.lkt:608







   if Local_Lad.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_30 := Liblktlang.Implementation.Parent (Node => Local_Lad.Node, E_Info => Local_Lad.Info);
--# expr-done 296



   if Fld_30.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_31 := Liblktlang.Implementation.Parent (Node => Fld_30.Node, E_Info => Fld_30.Info);
--# expr-done 297



   if Fld_31.Node = null
      or else Fld_31.Node.Kind in Lkt_Lambda_Expr_Range
   then
      
      Cast_Result_3 := Create_Internal_Entity_Lambda_Expr
        (Node => Fld_31.Node,
         Info => Fld_31.Info);

   else
         Cast_Result_3 := No_Entity_Lambda_Expr;
   end if;


--# expr-done 298
Var_Expr_3 := Cast_Result_3;





if Var_Expr_3 /= No_Entity_Lambda_Expr then
   



   --# scope-start



--# expr-start 303 If If_Result_5 nodes.lkt:610



--# expr-start 299 LktNode.solve_generic_types Fld_32 nodes.lkt:610







   if Var_Expr_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.solve_generic_types
Fld_32 := Liblktlang.Implementation.Lkt_Node_P_Solve_Generic_Types (Node => Var_Expr_3.Node, E_Info => Var_Expr_3.Info);
--# end
--# expr-done 299
if Fld_32 then
   --# expr-start 302 Cast Cast_Result_4 nodes.lkt:611





--# expr-start 301 .get_value If_Result_4 nodes.lkt:611



--# expr-start 300 LambdaParamDecl.type_var Fld_33 nodes.lkt:611







   if Local_Lad.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_33 := Local_Lad.Node.Lambda_Param_Decl_F_Type_Var'Unrestricted_Access;
--# expr-done 300
Is_Logic_Var_Defined := Entity_Vars.Is_Defined (Fld_33); 
if Is_Logic_Var_Defined then
   
Eq_Solution := Entity_Vars.Get_Value (Fld_33); 
   If_Result_4 := Eq_Solution;
else
   
   If_Result_4 := No_Entity;
end if;



--# expr-done 301



   if If_Result_4.Node = null
      or else If_Result_4.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_4 := Create_Internal_Entity_Type_Decl
        (Node => If_Result_4.Node,
         Info => If_Result_4.Info);

   else
         Cast_Result_4 := No_Entity_Type_Decl;
   end if;


--# expr-done 302
   If_Result_5 := Cast_Result_4;
else
   
   If_Result_5 := No_Entity_Type_Decl;
end if;



--# expr-done 303
Scope_Result_1 := If_Result_5;


   --# end


   Result_Var_2 := Scope_Result_1;
else
   
   Result_Var_2 := No_Entity_Type_Decl;
end if;



--# expr-done 304
   If_Result_6 := Result_Var_2;
else
   --# expr-start 306 TypeRef.referenced_decl Fld_28 nodes.lkt:614



--# expr-start 305 LambdaParamDecl.decl_type Fld_27 nodes.lkt:614







   if Local_Lad.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_27 := Create_Internal_Entity_Type_Ref (Node => Local_Lad.Node.Lambda_Param_Decl_F_Decl_Type, Info => Local_Lad.Info);
--# expr-done 305



   if Fld_27.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_28 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Fld_27.Node, E_Info => Fld_27.Info);
--# end
--# expr-done 306
   If_Result_6 := Fld_28;
end if;



--# expr-done 307
Let_Result_6 := If_Result_6; 
--# end
Scope_Result_8 := Let_Result_6;


   --# end


            Match_Result := Scope_Result_8; 
         when Lkt_Field_Decl .. Lkt_Fun_Param_Decl | Lkt_Dyn_Var_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_13 := Create_Internal_Entity_Explicitly_Typed_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Etd := Cast_Result_13; 
--# bind etd Local_Etd
--# expr-start 309 TypeRef.referenced_decl Fld_35 nodes.lkt:616



--# expr-start 308 ExplicitlyTypedDecl.decl_type Fld_34 nodes.lkt:616







   if Local_Etd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_34 := Create_Internal_Entity_Type_Ref (Node => Implementation.Explicitly_Typed_Decl_F_Decl_Type (Local_Etd.Node), Info => Local_Etd.Info);
--# expr-done 308



   if Fld_34.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_35 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Fld_34.Node, E_Info => Fld_34.Info);
--# end
--# expr-done 309
Let_Result_7 := Fld_35; 
--# end
Scope_Result_9 := Let_Result_7;


   --# end


            Match_Result := Scope_Result_9; 
         when Lkt_Generic_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_14 := Create_Internal_Entity_Generic_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Gd := Cast_Result_14; 
--# bind gd Local_Gd
--# expr-start 311 Decl.get_type Fld_37 nodes.lkt:617



--# expr-start 310 GenericDecl.decl Fld_36 nodes.lkt:617







   if Local_Gd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_36 := Create_Internal_Entity_Decl (Node => Local_Gd.Node.Generic_Decl_F_Decl, Info => Local_Gd.Info);
--# expr-done 310



   if Fld_36.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.get_type
Fld_37 := Liblktlang.Implementation.Decl_P_Get_Type (Node => Fld_36.Node, E_Info => Fld_36.Info);
--# end
--# expr-done 311
Let_Result_8 := Fld_37; 
--# end
Scope_Result_10 := Let_Result_8;


   --# end


            Match_Result := Scope_Result_10; 
         when Lkt_Self_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_15 := Create_Internal_Entity_Self_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Sd := Cast_Result_15; 
--# bind sd Local_Sd
--# expr-start 316 Cast Cast_Result_5 nodes.lkt:619





--# expr-start 315 Decl.instantiate_generic_decl Fld_40 nodes.lkt:619



--# expr-start 312 LktNode.entity_type Fld_38 nodes.lkt:619







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_38 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Ent.Node);
--# end
--# expr-done 312



   if Fld_38.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 314 ArrayLiteral Array_Lit nodes.lkt:620
--# expr-start 313 SelfDecl.owning_type Fld_39 nodes.lkt:620







   if Local_Sd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start SelfDecl.owning_type
Fld_39 := Liblktlang.Implementation.Self_Decl_P_Owning_Type (Node => Local_Sd.Node, E_Info => Local_Sd.Info);
--# end
--# expr-done 313
Array_Lit := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Fld_39)); 
--# expr-done 314
--# property-call-start Decl.instantiate_generic_decl
Fld_40 := Liblktlang.Implementation.Decl_P_Instantiate_Generic_Decl (Node => Fld_38.Node, Param_Types => Array_Lit, E_Info => Fld_38.Info);
--# end
--# expr-done 315



   if Fld_40.Node = null
      or else Fld_40.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_5 := Create_Internal_Entity_Type_Decl
        (Node => Fld_40.Node,
         Info => Fld_40.Info);

   else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "invalid object cast");
   end if;


--# expr-done 316
Let_Result_9 := Cast_Result_5; 
--# end
Scope_Result_11 := Let_Result_9;


   --# end
      Finalizer_Scope_506;


            Match_Result := Scope_Result_11; 
         when Lkt_Node_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_16 := Create_Internal_Entity_Node_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Nd := Cast_Result_16; 
--# bind nd Local_Nd
--# expr-start 317 NodeDecl.owning_type Fld_41 nodes.lkt:623







   if Local_Nd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start NodeDecl.owning_type
Fld_41 := Liblktlang.Implementation.Node_Decl_P_Owning_Type (Node => Local_Nd.Node, E_Info => Local_Nd.Info);
--# end
--# expr-done 317
Let_Result_10 := Fld_41; 
--# end
Scope_Result_12 := Let_Result_10;


   --# end


            Match_Result := Scope_Result_12; 
         when Lkt_Grammar_Rule_Decl .. Lkt_Synthetic_Lexer_Decl | Lkt_Env_Spec_Decl .. Lkt_Error_Decl | Lkt_Grammar_Decl .. Lkt_Synth_Param_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_17 := Create_Internal_Entity_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored := Cast_Result_17; 
--# bind _ Ignored

Let_Result_11 := No_Entity_Type_Decl; 
--# end
Scope_Result_13 := Let_Result_11;


   --# end


            Match_Result := Scope_Result_13; 
end case;

--# expr-done 318
Scope_Result_14 := Match_Result;


   --# end


   Result_Var_3 := Scope_Result_14;
else
   
   Result_Var_3 := No_Entity_Type_Decl;
end if;



--# expr-done 319

         Property_Result := Result_Var_3;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_498;
                     Finalizer_Scope_506;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Entity_Type_Decl,
                     As_Internal_Entity_Type_Decl => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Decl_P_Get_Type;
--# end

   







--# property-start Decl.get_cast_type nodes.lkt:631
pragma Warnings (Off, "is not referenced");

function Decl_P_Get_Cast_Type
  
  (Node : Bare_Decl
      ; Cast_To : Internal_Entity_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind cast_to Cast_To

   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_94 with Inline_Always;

      Is_Null : Boolean;
Is_Null_1 : Boolean;
If_Result : Boolean;
Not_Val : Boolean;
Fld : Internal_Entity_Named_Type_Decl;
Fld_1 : Bare_Named_Type_Decl;
Cast_Result : Bare_Decl;
Is_Equal : Boolean;
If_Result_1 : Boolean;
Fld_2 : Bare_Type_Decl;
Fld_3 : Internal_Entity_Named_Type_Decl;
Fld_4 : Bare_Named_Type_Decl;
Cast_Result_1 : Bare_Type_Decl;
Is_Equal_1 : Boolean;
Not_Val_1 : Boolean;
If_Result_2 : Boolean;
Fld_5 : Internal_Entity_Named_Type_Decl;
Array_Lit : Internal_Entity_Type_Decl_Array_Access;
Fld_6 : Internal_Entity_Decl;
Cast_Result_2 : Internal_Entity_Decl;
If_Result_3 : Internal_Entity_Decl;
Cast_Result_3 : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_94 is
            begin
                     Dec_Ref (Array_Lit);
            end Finalizer_Scope_94;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 337 Cast Cast_Result_3 nodes.lkt:632





--# expr-start 336 If If_Result_3 nodes.lkt:633



--# expr-start 332 BooleanAnd If_Result_2 nodes.lkt:634



--# expr-start 327 BooleanAnd If_Result_1 nodes.lkt:635



--# expr-start 323 Not Not_Val nodes.lkt:635
--# expr-start 322 BooleanOr If_Result nodes.lkt:635



--# expr-start 320 .is_null Is_Null nodes.lkt:635

Is_Null := Cast_To.Node = null; 
--# expr-done 320
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 321 .is_null Is_Null_1 nodes.lkt:635

Is_Null_1 := Ent.Node = null; 
--# expr-done 321
   If_Result := Is_Null_1;
end if;



--# expr-done 322
Not_Val := not (If_Result); 
--# expr-done 323
if Not_Val then
   --# expr-start 326 Eq Is_Equal nodes.lkt:636






--# expr-start 325 'Entity[NamedTypeDecl].node' Fld_1 nodes.lkt:636



--# expr-start 324 LktNode.entity_type Fld nodes.lkt:636







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Self);
--# end
--# expr-done 324





Fld_1 := Fld.Node;
--# expr-done 325



   
      Cast_Result := Fld_1;


Is_Equal := Self = Cast_Result; 
--# expr-done 326
   If_Result_1 := Is_Equal;
else
   
   If_Result_1 := False;
end if;



--# expr-done 327
if If_Result_1 then
   --# expr-start 331 NotEqual Not_Val_1 nodes.lkt:638
--# expr-start 328 'Entity[TypeDecl].node' Fld_2 nodes.lkt:638









Fld_2 := Cast_To.Node;
--# expr-done 328





--# expr-start 330 'Entity[NamedTypeDecl].node' Fld_4 nodes.lkt:638



--# expr-start 329 LktNode.entity_type Fld_3 nodes.lkt:638







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_3 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Self);
--# end
--# expr-done 329





Fld_4 := Fld_3.Node;
--# expr-done 330



   
      Cast_Result_1 := Fld_4;


Is_Equal_1 := Fld_2 = Cast_Result_1; 
Not_Val_1 := not (Is_Equal_1); 
--# expr-done 331
   If_Result_2 := Not_Val_1;
else
   
   If_Result_2 := False;
end if;



--# expr-done 332
if If_Result_2 then
   --# expr-start 335 Decl.instantiate_generic_decl Fld_6 nodes.lkt:639



--# expr-start 333 LktNode.entity_type Fld_5 nodes.lkt:639







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_5 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Self);
--# end
--# expr-done 333



   if Fld_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 334 ArrayLiteral Array_Lit nodes.lkt:639

Array_Lit := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Cast_To)); 
--# expr-done 334
--# property-call-start Decl.instantiate_generic_decl
Fld_6 := Liblktlang.Implementation.Decl_P_Instantiate_Generic_Decl (Node => Fld_5.Node, Param_Types => Array_Lit, E_Info => Fld_5.Info);
--# end
--# expr-done 335
   If_Result_3 := Fld_6;
else
   








   
      Cast_Result_2 := Create_Internal_Entity_Decl
        (Node => Cast_To.Node,
         Info => Cast_To.Info);


   If_Result_3 := Cast_Result_2;
end if;



--# expr-done 336



   if If_Result_3.Node = null
      or else If_Result_3.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_3 := Create_Internal_Entity_Type_Decl
        (Node => If_Result_3.Node,
         Info => If_Result_3.Info);

   else
         Cast_Result_3 := No_Entity_Type_Decl;
   end if;


--# expr-done 337

         Property_Result := Cast_Result_3;
         
   --# end
      Finalizer_Scope_94;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_94;




            raise;
      end;



   return Property_Result;
end Decl_P_Get_Cast_Type;
--# end

   







--# property-start Decl.get_keep_type nodes.lkt:648
pragma Warnings (Off, "is not referenced");

function Decl_P_Get_Keep_Type
  
  (Node : Bare_Decl
      ; Keep_Type : Internal_Entity_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind keep_type Keep_Type

   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_95 with Inline_Always;

      Is_Null : Boolean;
Is_Null_1 : Boolean;
If_Result : Boolean;
Not_Val : Boolean;
Fld : Internal_Entity_Named_Type_Decl;
Fld_1 : Bare_Named_Type_Decl;
Cast_Result : Bare_Decl;
Is_Equal : Boolean;
Fld_2 : Internal_Entity_Named_Type_Decl;
Fld_3 : Bare_Named_Type_Decl;
Cast_Result_1 : Bare_Decl;
Is_Equal_1 : Boolean;
Cast_Result_2 : Internal_Entity_Type_Decl;
Fld_4 : Internal_Entity_Type_Decl;
Fld_5 : Bare_Type_Decl;
Fld_6 : Internal_Entity_Named_Type_Decl;
Fld_7 : Bare_Named_Type_Decl;
Cast_Result_3 : Bare_Type_Decl;
Is_Equal_2 : Boolean;
If_Result_1 : Boolean;
If_Result_2 : Boolean;
If_Result_3 : Boolean;
Fld_8 : Bare_Type_Decl;
Fld_9 : Internal_Entity_Named_Type_Decl;
Fld_10 : Bare_Named_Type_Decl;
Cast_Result_4 : Bare_Type_Decl;
Is_Equal_3 : Boolean;
Not_Val_1 : Boolean;
If_Result_4 : Boolean;
Fld_11 : Internal_Entity_Named_Type_Decl;
Array_Lit : Internal_Entity_Type_Decl_Array_Access;
Fld_12 : Internal_Entity_Decl;
Cast_Result_5 : Internal_Entity_Decl;
If_Result_5 : Internal_Entity_Decl;
Cast_Result_6 : Internal_Entity_Type_Decl;
Var_Expr : Internal_Entity_Type_Decl;
Fld_13 : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_95 is
            begin
                     Dec_Ref (Array_Lit);
            end Finalizer_Scope_95;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         


--# expr-start 366 Cast Cast_Result_6 nodes.lkt:649





--# expr-start 365 If If_Result_5 nodes.lkt:650



--# expr-start 361 BooleanAnd If_Result_4 nodes.lkt:651



--# expr-start 356 BooleanAnd If_Result_3 nodes.lkt:652



--# expr-start 341 Not Not_Val nodes.lkt:652
--# expr-start 340 BooleanOr If_Result nodes.lkt:652



--# expr-start 338 .is_null Is_Null nodes.lkt:652

Is_Null := Keep_Type.Node = null; 
--# expr-done 338
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 339 .is_null Is_Null_1 nodes.lkt:652

Is_Null_1 := Ent.Node = null; 
--# expr-done 339
   If_Result := Is_Null_1;
end if;



--# expr-done 340
Not_Val := not (If_Result); 
--# expr-done 341
if Not_Val then
   --# expr-start 355 BooleanOr If_Result_2 nodes.lkt:654



--# expr-start 344 Eq Is_Equal nodes.lkt:654






--# expr-start 343 'Entity[NamedTypeDecl].node' Fld_1 nodes.lkt:654



--# expr-start 342 LktNode.entity_type Fld nodes.lkt:654







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Self);
--# end
--# expr-done 342





Fld_1 := Fld.Node;
--# expr-done 343



   
      Cast_Result := Fld_1;


Is_Equal := Self = Cast_Result; 
--# expr-done 344
if Is_Equal then
   
   If_Result_2 := True;
else
   --# expr-start 354 BooleanAnd If_Result_1 nodes.lkt:656



--# expr-start 347 Eq Is_Equal_1 nodes.lkt:656






--# expr-start 346 'Entity[NamedTypeDecl].node' Fld_3 nodes.lkt:656



--# expr-start 345 LktNode.array_type Fld_2 nodes.lkt:656







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.array_type
Fld_2 := Liblktlang.Implementation.Lkt_Node_P_Array_Type (Node => Self);
--# end
--# expr-done 345





Fld_3 := Fld_2.Node;
--# expr-done 346



   
      Cast_Result_1 := Fld_3;


Is_Equal_1 := Self = Cast_Result_1; 
--# expr-done 347
if Is_Equal_1 then
   --# expr-start 353 Eq Is_Equal_2 nodes.lkt:657
--# expr-start 350 'Entity[TypeDecl].node' Fld_5 nodes.lkt:657



--# expr-start 349 TypeDecl.get_array_content_type Fld_4 nodes.lkt:657



--# expr-start 348 Cast Cast_Result_2 nodes.lkt:657









   if Ent.Node = null
      or else Ent.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_2 := Create_Internal_Entity_Type_Decl
        (Node => Ent.Node,
         Info => Ent.Info);

   else
         Cast_Result_2 := No_Entity_Type_Decl;
   end if;


--# expr-done 348



   if Cast_Result_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.get_array_content_type
Fld_4 := Liblktlang.Implementation.Type_Decl_P_Get_Array_Content_Type (Node => Cast_Result_2.Node, E_Info => Cast_Result_2.Info);
--# end
--# expr-done 349





Fld_5 := Fld_4.Node;
--# expr-done 350





--# expr-start 352 'Entity[NamedTypeDecl].node' Fld_7 nodes.lkt:658



--# expr-start 351 LktNode.entity_type Fld_6 nodes.lkt:658







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_6 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Self);
--# end
--# expr-done 351





Fld_7 := Fld_6.Node;
--# expr-done 352



   
      Cast_Result_3 := Fld_7;


Is_Equal_2 := Fld_5 = Cast_Result_3; 
--# expr-done 353
   If_Result_1 := Is_Equal_2;
else
   
   If_Result_1 := False;
end if;



--# expr-done 354
   If_Result_2 := If_Result_1;
end if;



--# expr-done 355
   If_Result_3 := If_Result_2;
else
   
   If_Result_3 := False;
end if;



--# expr-done 356
if If_Result_3 then
   --# expr-start 360 NotEqual Not_Val_1 nodes.lkt:662
--# expr-start 357 'Entity[TypeDecl].node' Fld_8 nodes.lkt:662









Fld_8 := Keep_Type.Node;
--# expr-done 357





--# expr-start 359 'Entity[NamedTypeDecl].node' Fld_10 nodes.lkt:662



--# expr-start 358 LktNode.entity_type Fld_9 nodes.lkt:662







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_9 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Self);
--# end
--# expr-done 358





Fld_10 := Fld_9.Node;
--# expr-done 359



   
      Cast_Result_4 := Fld_10;


Is_Equal_3 := Fld_8 = Cast_Result_4; 
Not_Val_1 := not (Is_Equal_3); 
--# expr-done 360
   If_Result_4 := Not_Val_1;
else
   
   If_Result_4 := False;
end if;



--# expr-done 361
if If_Result_4 then
   --# expr-start 364 Decl.instantiate_generic_decl Fld_12 nodes.lkt:663



--# expr-start 362 LktNode.entity_type Fld_11 nodes.lkt:663







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_11 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Self);
--# end
--# expr-done 362



   if Fld_11.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 363 ArrayLiteral Array_Lit nodes.lkt:663

Array_Lit := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Keep_Type)); 
--# expr-done 363
--# property-call-start Decl.instantiate_generic_decl
Fld_12 := Liblktlang.Implementation.Decl_P_Instantiate_Generic_Decl (Node => Fld_11.Node, Param_Types => Array_Lit, E_Info => Fld_11.Info);
--# end
--# expr-done 364
   If_Result_5 := Fld_12;
else
   








   
      Cast_Result_5 := Create_Internal_Entity_Decl
        (Node => Keep_Type.Node,
         Info => Keep_Type.Info);


   If_Result_5 := Cast_Result_5;
end if;



--# expr-done 365



   if If_Result_5.Node = null
      or else If_Result_5.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_6 := Create_Internal_Entity_Type_Decl
        (Node => If_Result_5.Node,
         Info => If_Result_5.Info);

   else
         Cast_Result_6 := No_Entity_Type_Decl;
   end if;


--# expr-done 366
Var_Expr := Cast_Result_6;





if Var_Expr /= No_Entity_Type_Decl then
   --# expr-start 367 TypeDecl.make_array_type Fld_13 nodes.lkt:649







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.make_array_type
Fld_13 := Liblktlang.Implementation.Type_Decl_P_Make_Array_Type (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 367
   Result_Var := Fld_13;
else
   
   Result_Var := No_Entity_Type_Decl;
end if;




         Property_Result := Result_Var;
         
   --# end
      Finalizer_Scope_95;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_95;




            raise;
      end;



   return Property_Result;
end Decl_P_Get_Keep_Type;
--# end

   







--# property-start Decl.get_suffix_type nodes.lkt:672
pragma Warnings (Off, "is not referenced");

function Decl_P_Get_Suffix_Type
  
  (Node : Bare_Decl
      ; Prefix_Type : Internal_Entity_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind prefix_type Prefix_Type

   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_509 with Inline_Always;

      Var_Expr : Internal_Entity_Decl;
Fld : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;
Local_Suffix_Type : Internal_Entity_Type_Decl;
Is_Null : Boolean;
Not_Val : Boolean;
Is_Null_1 : Boolean;
If_Result : Boolean;
Is_A : Boolean;
If_Result_1 : Boolean;
Fld_1 : Internal_Entity_Full_Decl;
Sym : Symbol_Type;
Fld_2 : Boolean;
If_Result_2 : Boolean;
Fld_3 : Internal_Entity_Function_Type;
Cast_Result : Internal_Entity_Type_Decl;
If_Result_3 : Internal_Entity_Type_Decl;
Is_Null_2 : Boolean;
Not_Val_1 : Boolean;
Is_Null_3 : Boolean;
If_Result_4 : Boolean;
Is_A_1 : Boolean;
If_Result_5 : Boolean;
Fld_4 : Internal_Entity_Full_Decl;
Sym_1 : Symbol_Type;
Fld_5 : Boolean;
If_Result_6 : Boolean;
Cast_Result_1 : Internal_Entity_Field_Decl;
Fld_6 : Internal_Entity_Function_Type;
Cast_Result_2 : Internal_Entity_Type_Decl;
If_Result_7 : Internal_Entity_Type_Decl;
Is_Null_4 : Boolean;
Not_Val_2 : Boolean;
Is_Null_5 : Boolean;
Not_Val_3 : Boolean;
If_Result_8 : Boolean;
Fld_7 : Bare_Type_Decl;
Fld_8 : Internal_Entity_Named_Type_Decl;
Fld_9 : Bare_Named_Type_Decl;
Cast_Result_3 : Bare_Type_Decl;
Is_Equal : Boolean;
If_Result_9 : Boolean;
Fld_10 : Internal_Entity_Full_Decl;
Var_Expr_1 : Internal_Entity_Full_Decl;
Sym_2 : Symbol_Type;
Fld_11 : Boolean;
Result_Var_1 : Boolean;
If_Result_10 : Boolean;
Fld_12 : Internal_Entity_Named_Type_Decl;
Array_Lit : Internal_Entity_Type_Decl_Array_Access;
Fld_13 : Internal_Entity_Decl;
Cast_Result_4 : Internal_Entity_Decl;
If_Result_11 : Internal_Entity_Decl;
Cast_Result_5 : Internal_Entity_Type_Decl;
Let_Result : Internal_Entity_Type_Decl;
Scope_Result : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_509 is
            begin
                     Dec_Ref (Array_Lit);
            end Finalizer_Scope_509;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 413 ValDecl Let_Result nodes.lkt:673
--# scope-start




Var_Expr := Ent;





if Var_Expr /= No_Entity_Decl then
   --# expr-start 368 Decl.get_type Fld nodes.lkt:673







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.get_type
Fld := Liblktlang.Implementation.Decl_P_Get_Type (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 368
   Result_Var := Fld;
else
   
   Result_Var := No_Entity_Type_Decl;
end if;



Local_Suffix_Type := Result_Var; 
--# bind suffix_type Local_Suffix_Type
--# expr-start 412 Cast Cast_Result_5 nodes.lkt:675





--# expr-start 411 If If_Result_11 nodes.lkt:676



--# expr-start 382 BooleanAnd If_Result_10 nodes.lkt:677



--# expr-start 378 BooleanAnd If_Result_9 nodes.lkt:678



--# expr-start 373 BooleanAnd If_Result_8 nodes.lkt:678



--# expr-start 370 Not Not_Val_2 nodes.lkt:678
--# expr-start 369 .is_null Is_Null_4 nodes.lkt:678

Is_Null_4 := Prefix_Type.Node = null; 
--# expr-done 369
Not_Val_2 := not (Is_Null_4); 
--# expr-done 370
if Not_Val_2 then
   --# expr-start 372 Not Not_Val_3 nodes.lkt:678
--# expr-start 371 .is_null Is_Null_5 nodes.lkt:678

Is_Null_5 := Ent.Node = null; 
--# expr-done 371
Not_Val_3 := not (Is_Null_5); 
--# expr-done 372
   If_Result_8 := Not_Val_3;
else
   
   If_Result_8 := False;
end if;



--# expr-done 373
if If_Result_8 then
   --# expr-start 377 Eq Is_Equal nodes.lkt:679
--# expr-start 374 'Entity[TypeDecl].node' Fld_7 nodes.lkt:679









Fld_7 := Prefix_Type.Node;
--# expr-done 374





--# expr-start 376 'Entity[NamedTypeDecl].node' Fld_9 nodes.lkt:679



--# expr-start 375 LktNode.entity_type Fld_8 nodes.lkt:679







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_8 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Self);
--# end
--# expr-done 375





Fld_9 := Fld_8.Node;
--# expr-done 376



   
      Cast_Result_3 := Fld_9;


Is_Equal := Fld_7 = Cast_Result_3; 
--# expr-done 377
   If_Result_9 := Is_Equal;
else
   
   If_Result_9 := False;
end if;



--# expr-done 378
if If_Result_9 then
   


--# expr-start 379 Decl.full_decl Fld_10 nodes.lkt:681







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.full_decl
Fld_10 := Liblktlang.Implementation.Decl_P_Full_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 379
Var_Expr_1 := Fld_10;





if Var_Expr_1 /= No_Entity_Full_Decl then
   --# expr-start 381 FullDecl.has_annotation Fld_11 nodes.lkt:681







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 380 SymbolLiteral Sym_2 nodes.lkt:681
Sym_2 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Parse_Field); 
--# expr-done 380
--# property-call-start FullDecl.has_annotation
Fld_11 := Liblktlang.Implementation.Full_Decl_P_Has_Annotation (Node => Var_Expr_1.Node, Name => Sym_2);
--# end
--# expr-done 381
   Result_Var_1 := Fld_11;
else
   
   Result_Var_1 := False;
end if;



   If_Result_10 := Result_Var_1;
else
   
   If_Result_10 := False;
end if;



--# expr-done 382
if If_Result_10 then
   --# expr-start 385 Decl.instantiate_generic_decl Fld_13 nodes.lkt:682



--# expr-start 383 LktNode.entity_type Fld_12 nodes.lkt:682







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_12 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Self);
--# end
--# expr-done 383



   if Fld_12.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 384 ArrayLiteral Array_Lit nodes.lkt:682

Array_Lit := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Local_Suffix_Type)); 
--# expr-done 384
--# property-call-start Decl.instantiate_generic_decl
Fld_13 := Liblktlang.Implementation.Decl_P_Instantiate_Generic_Decl (Node => Fld_12.Node, Param_Types => Array_Lit, E_Info => Fld_12.Info);
--# end
--# expr-done 385
   If_Result_11 := Fld_13;
else
   




--# expr-start 410 If If_Result_7 nodes.lkt:676



--# expr-start 395 BooleanAnd If_Result_6 nodes.lkt:688



--# expr-start 391 BooleanAnd If_Result_5 nodes.lkt:689



--# expr-start 389 BooleanAnd If_Result_4 nodes.lkt:689



--# expr-start 387 Not Not_Val_1 nodes.lkt:689
--# expr-start 386 .is_null Is_Null_2 nodes.lkt:689

Is_Null_2 := Ent.Node = null; 
--# expr-done 386
Not_Val_1 := not (Is_Null_2); 
--# expr-done 387
if Not_Val_1 then
   --# expr-start 388 .is_null Is_Null_3 nodes.lkt:689

Is_Null_3 := Prefix_Type.Node = null; 
--# expr-done 388
   If_Result_4 := Is_Null_3;
else
   
   If_Result_4 := False;
end if;



--# expr-done 389
if If_Result_4 then
   --# expr-start 390 IsA Is_A_1 nodes.lkt:690

Is_A_1 := Self /= null 
and then Self.Kind in Lkt_Field_Decl_Range; 
--# expr-done 390
   If_Result_5 := Is_A_1;
else
   
   If_Result_5 := False;
end if;



--# expr-done 391
if If_Result_5 then
   --# expr-start 394 FullDecl.has_annotation Fld_5 nodes.lkt:692



--# expr-start 392 Decl.full_decl Fld_4 nodes.lkt:692







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.full_decl
Fld_4 := Liblktlang.Implementation.Decl_P_Full_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 392



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 393 SymbolLiteral Sym_1 nodes.lkt:692
Sym_1 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Lazy); 
--# expr-done 393
--# property-call-start FullDecl.has_annotation
Fld_5 := Liblktlang.Implementation.Full_Decl_P_Has_Annotation (Node => Fld_4.Node, Name => Sym_1);
--# end
--# expr-done 394
   If_Result_6 := Fld_5;
else
   
   If_Result_6 := False;
end if;



--# expr-done 395
if If_Result_6 then
   




--# expr-start 397 FieldDecl.lazy_field_function_type Fld_6 nodes.lkt:693



--# expr-start 396 Cast Cast_Result_1 nodes.lkt:693









   if Ent.Node = null
      or else Ent.Node.Kind in Lkt_Field_Decl_Range
   then
      
      Cast_Result_1 := Create_Internal_Entity_Field_Decl
        (Node => Ent.Node,
         Info => Ent.Info);

   else
         Cast_Result_1 := No_Entity_Field_Decl;
   end if;


--# expr-done 396



   if Cast_Result_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start FieldDecl.lazy_field_function_type
Fld_6 := Liblktlang.Implementation.Field_Decl_P_Lazy_Field_Function_Type (Node => Cast_Result_1.Node, E_Info => Cast_Result_1.Info);
--# end
--# expr-done 397



   
      Cast_Result_2 := Create_Internal_Entity_Type_Decl
        (Node => Fld_6.Node,
         Info => Fld_6.Info);


   If_Result_7 := Cast_Result_2;
else
   --# expr-start 409 If If_Result_3 nodes.lkt:676



--# expr-start 407 BooleanAnd If_Result_2 nodes.lkt:695



--# expr-start 403 BooleanAnd If_Result_1 nodes.lkt:696



--# expr-start 401 BooleanAnd If_Result nodes.lkt:696



--# expr-start 399 Not Not_Val nodes.lkt:696
--# expr-start 398 .is_null Is_Null nodes.lkt:696

Is_Null := Ent.Node = null; 
--# expr-done 398
Not_Val := not (Is_Null); 
--# expr-done 399
if Not_Val then
   --# expr-start 400 .is_null Is_Null_1 nodes.lkt:696

Is_Null_1 := Prefix_Type.Node = null; 
--# expr-done 400
   If_Result := Is_Null_1;
else
   
   If_Result := False;
end if;



--# expr-done 401
if If_Result then
   --# expr-start 402 IsA Is_A nodes.lkt:697

Is_A := Self /= null 
and then Self.Kind in Lkt_Fun_Decl_Range; 
--# expr-done 402
   If_Result_1 := Is_A;
else
   
   If_Result_1 := False;
end if;



--# expr-done 403
if If_Result_1 then
   --# expr-start 406 FullDecl.has_annotation Fld_2 nodes.lkt:699



--# expr-start 404 Decl.full_decl Fld_1 nodes.lkt:699







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.full_decl
Fld_1 := Liblktlang.Implementation.Decl_P_Full_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 404



   if Fld_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 405 SymbolLiteral Sym nodes.lkt:699
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Property); 
--# expr-done 405
--# property-call-start FullDecl.has_annotation
Fld_2 := Liblktlang.Implementation.Full_Decl_P_Has_Annotation (Node => Fld_1.Node, Name => Sym);
--# end
--# expr-done 406
   If_Result_2 := Fld_2;
else
   
   If_Result_2 := False;
end if;



--# expr-done 407
if If_Result_2 then
   




--# expr-start 408 Decl.function_type Fld_3 nodes.lkt:700







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.function_type
Fld_3 := Liblktlang.Implementation.Decl_P_Function_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 408



   
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => Fld_3.Node,
         Info => Fld_3.Info);


   If_Result_3 := Cast_Result;
else
   
   If_Result_3 := Local_Suffix_Type;
end if;



--# expr-done 409
   If_Result_7 := If_Result_3;
end if;



--# expr-done 410



   
      Cast_Result_4 := Create_Internal_Entity_Decl
        (Node => If_Result_7.Node,
         Info => If_Result_7.Info);


   If_Result_11 := Cast_Result_4;
end if;



--# expr-done 411



   if If_Result_11.Node = null
      or else If_Result_11.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_5 := Create_Internal_Entity_Type_Decl
        (Node => If_Result_11.Node,
         Info => If_Result_11.Info);

   else
         Cast_Result_5 := No_Entity_Type_Decl;
   end if;


--# expr-done 412
Let_Result := Cast_Result_5; 
--# end
--# expr-done 413
Scope_Result := Let_Result;


   --# end
      Finalizer_Scope_509;



         Property_Result := Scope_Result;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_509;




            raise;
      end;



   return Property_Result;
end Decl_P_Get_Suffix_Type;
--# end

   







--# property-start Decl.type_var_suffix_ref nodes.lkt:715
pragma Warnings (Off, "is not referenced");

function Decl_P_Type_Var_Suffix_Ref
  
  (Node : Bare_Decl
      ; Current_Name : Internal_Entity_Ref_Id
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Decl
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind current_name Current_Name

   Property_Result : Internal_Entity_Decl;

      
            procedure Finalizer_Scope_512 with Inline_Always;
            procedure Finalizer_Scope_514 with Inline_Always;

      Var_Expr : Internal_Entity_Decl;
Local_E : Internal_Entity_Enum_Type_Decl;
Origin : Internal_Entity;
Fld : Internal_Entity_Type_Decl;
Fld_1 : Lexical_Env := Empty_Env;
Fld_2 : Bare_Ref_Id;
Sym : Symbol_Type;
Env_Get_Result : Internal_Entity;
Cast_Result : Internal_Entity_Decl;
Var_Expr_1 : Internal_Entity_Decl;
Fld_3 : Internal_Entity_Decl;
Result_Var : Internal_Entity_Decl;
Cast_Result_1 : Internal_Entity;
Dyn_Var_Bind_Result : Internal_Entity_Decl;
Scope_Result : Internal_Entity_Decl;
Ignored : Internal_Entity_Decl;
Origin_1 : Internal_Entity;
Fld_4 : Lexical_Env := Empty_Env;
Fld_5 : Bare_Ref_Id;
Sym_1 : Symbol_Type;
Env_Get_Result_1 : Internal_Entity;
Cast_Result_2 : Internal_Entity_Decl;
Var_Expr_2 : Internal_Entity_Decl;
Fld_6 : Internal_Entity_Decl;
Result_Var_1 : Internal_Entity_Decl;
Cast_Result_3 : Internal_Entity;
Dyn_Var_Bind_Result_1 : Internal_Entity_Decl;
Scope_Result_1 : Internal_Entity_Decl;
Match_Prefix : Internal_Entity_Decl;
Cast_Result_4 : Internal_Entity_Enum_Type_Decl;
Let_Result : Internal_Entity_Decl;
Scope_Result_2 : Internal_Entity_Decl;
Cast_Result_5 : Internal_Entity_Decl;
Let_Result_1 : Internal_Entity_Decl;
Scope_Result_3 : Internal_Entity_Decl;
Match_Result : Internal_Entity_Decl;
Scope_Result_4 : Internal_Entity_Decl;
Result_Var_2 : Internal_Entity_Decl;

            procedure Finalizer_Scope_512 is
            begin
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_512;
            procedure Finalizer_Scope_514 is
            begin
                     Dec_Ref (Fld_4);
            end Finalizer_Scope_514;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 428 .do Result_Var_2 nodes.lkt:716




Var_Expr := Ent;





if Var_Expr /= No_Entity_Decl then
   



   --# scope-start



--# expr-start 427 Match Match_Result nodes.lkt:718










   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := Var_Expr; 

case Lkt_Decl (Match_Prefix.Node.Kind) is
         when Lkt_Enum_Type_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_4 := Create_Internal_Entity_Enum_Type_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_E := Cast_Result_4; 
--# bind e Local_E




   --# scope-start



--# expr-start 420 bind Dyn_Var_Bind_Result nodes.lkt:721









   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);


Origin := Cast_Result_1; 



--# expr-start 418 Cast Cast_Result nodes.lkt:723





--# expr-start 417 .get_first Env_Get_Result nodes.lkt:723
--# expr-start 415 Decl.defined_scope Fld_1 nodes.lkt:723



--# expr-start 414 TypeDecl.basic_trait_from_self Fld nodes.lkt:723







   if Local_E.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.basic_trait_from_self
Fld := Liblktlang.Implementation.Type_Decl_P_Basic_Trait_From_Self (Node => Local_E.Node, E_Info => Local_E.Info);
--# end
--# expr-done 414



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_1 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Fld.Node, Origin => Origin, E_Info => Fld.Info);
--# end
--# expr-done 415
--# expr-start 416 .symbol Sym nodes.lkt:724









Fld_2 := Current_Name.Node; 
Sym := Get_Symbol (Fld_2); 
--# expr-done 416


Env_Get_Result := AST_Envs.Get_First (Self => Fld_1, Key => Thin (Sym), Lookup_Kind => To_Lookup_Kind_Type (Flat), Categories => (Nocat => True)); 
--# expr-done 417



   if Env_Get_Result.Node = null
      or else Env_Get_Result.Node.Kind in Lkt_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Decl
        (Node => Env_Get_Result.Node,
         Info => Env_Get_Result.Info);

   else
         Cast_Result := No_Entity_Decl;
   end if;


--# expr-done 418
Var_Expr_1 := Cast_Result;





if Var_Expr_1 /= No_Entity_Decl then
   --# expr-start 419 Decl.subdecl_if_generic Fld_3 nodes.lkt:723







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.subdecl_if_generic
Fld_3 := Liblktlang.Implementation.Decl_P_Subdecl_If_Generic (Node => Var_Expr_1.Node, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 419
   Result_Var := Fld_3;
else
   
   Result_Var := No_Entity_Decl;
end if;



Dyn_Var_Bind_Result := Result_Var; 
--# expr-done 420
Scope_Result := Dyn_Var_Bind_Result;


   --# end
      Finalizer_Scope_512;


Let_Result := Scope_Result; 
--# end
Scope_Result_2 := Let_Result;


   --# end


            Match_Result := Scope_Result_2; 
         when Lkt_Grammar_Rule_Decl .. Lkt_Enum_Class_Decl | Lkt_Struct_Decl .. Lkt_Trait_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_5 := Create_Internal_Entity_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored := Cast_Result_5; 
--# bind _ Ignored




   --# scope-start



--# expr-start 426 bind Dyn_Var_Bind_Result_1 nodes.lkt:732









   
      Cast_Result_3 := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);


Origin_1 := Cast_Result_3; 



--# expr-start 424 Cast Cast_Result_2 nodes.lkt:734





--# expr-start 423 .get_first Env_Get_Result_1 nodes.lkt:734
--# expr-start 421 Decl.defined_scope Fld_4 nodes.lkt:734







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_4 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Ent.Node, Origin => Origin_1, E_Info => Ent.Info);
--# end
--# expr-done 421
--# expr-start 422 .symbol Sym_1 nodes.lkt:735









Fld_5 := Current_Name.Node; 
Sym_1 := Get_Symbol (Fld_5); 
--# expr-done 422


Env_Get_Result_1 := AST_Envs.Get_First (Self => Fld_4, Key => Thin (Sym_1), Lookup_Kind => To_Lookup_Kind_Type (Flat), Categories => (Nocat => True)); 
--# expr-done 423



   if Env_Get_Result_1.Node = null
      or else Env_Get_Result_1.Node.Kind in Lkt_Decl
   then
      
      Cast_Result_2 := Create_Internal_Entity_Decl
        (Node => Env_Get_Result_1.Node,
         Info => Env_Get_Result_1.Info);

   else
         Cast_Result_2 := No_Entity_Decl;
   end if;


--# expr-done 424
Var_Expr_2 := Cast_Result_2;





if Var_Expr_2 /= No_Entity_Decl then
   --# expr-start 425 Decl.subdecl_if_generic Fld_6 nodes.lkt:734







   if Var_Expr_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.subdecl_if_generic
Fld_6 := Liblktlang.Implementation.Decl_P_Subdecl_If_Generic (Node => Var_Expr_2.Node, E_Info => Var_Expr_2.Info);
--# end
--# expr-done 425
   Result_Var_1 := Fld_6;
else
   
   Result_Var_1 := No_Entity_Decl;
end if;



Dyn_Var_Bind_Result_1 := Result_Var_1; 
--# expr-done 426
Scope_Result_1 := Dyn_Var_Bind_Result_1;


   --# end
      Finalizer_Scope_514;


Let_Result_1 := Scope_Result_1; 
--# end
Scope_Result_3 := Let_Result_1;


   --# end


            Match_Result := Scope_Result_3; 
end case;

--# expr-done 427
Scope_Result_4 := Match_Result;


   --# end


   Result_Var_2 := Scope_Result_4;
else
   
   Result_Var_2 := No_Entity_Decl;
end if;



--# expr-done 428

         Property_Result := Result_Var_2;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_512;
                     Finalizer_Scope_514;




            raise;
      end;



   return Property_Result;
end Decl_P_Type_Var_Suffix_Ref;
--# end

   







--# property-start Decl.ref_var_suffix_ref nodes.lkt:746
pragma Warnings (Off, "is not referenced");

function Decl_P_Ref_Var_Suffix_Ref
  
  (Node : Bare_Decl
      ; Type_Var : Internal_Entity_Type_Decl
      ; Current_Name : Internal_Entity_Ref_Id
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Decl
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind type_var Type_Var
   --# bind current_name Current_Name

   Property_Result : Internal_Entity_Decl;

      
            procedure Finalizer_Scope_517 with Inline_Always;
            procedure Finalizer_Scope_519 with Inline_Always;
            procedure Finalizer_Scope_521 with Inline_Always;
            procedure Finalizer_Scope_526 with Inline_Always;
            procedure Finalizer_Scope_529 with Inline_Always;

      Var_Expr : Internal_Entity_Decl;
Local_E : Internal_Entity_Enum_Type_Decl;
Origin : Internal_Entity;
Fld : Lexical_Env := Empty_Env;
Fld_1 : Bare_Ref_Id;
Sym : Symbol_Type;
Env_Get_Result : Internal_Entity;
Cast_Result : Internal_Entity_Decl;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result_1 : Internal_Entity;
Dyn_Var_Bind_Result : Internal_Entity_Decl;
Scope_Result : Internal_Entity_Decl;
Local_E_1 : Internal_Entity_Enum_Lit_Decl;
Origin_1 : Internal_Entity;
Fld_2 : Lexical_Env := Empty_Env;
Fld_3 : Bare_Ref_Id;
Sym_1 : Symbol_Type;
Env_Get_Result_1 : Internal_Entity;
Cast_Result_2 : Internal_Entity_Decl;
Var_Expr_1 : Internal_Entity_Decl;
Fld_4 : Internal_Entity_Decl;
Result_Var : Internal_Entity_Decl;
Cast_Expr_1 : Internal_Entity_Type_Decl;
Cast_Result_3 : Internal_Entity;
Dyn_Var_Bind_Result_1 : Internal_Entity_Decl;
Scope_Result_1 : Internal_Entity_Decl;
Local_Td : Internal_Entity_Type_Decl;
Origin_2 : Internal_Entity;
Fld_5 : Lexical_Env := Empty_Env;
Fld_6 : Lexical_Env := Empty_Env;
Array_Lit : Lexical_Env_Array_Access;
Group_Env : Lexical_Env := Empty_Env;
Fld_7 : Bare_Ref_Id;
Sym_2 : Symbol_Type;
Env_Get_Result_2 : Internal_Entity_Array_Access;
Is_A : Boolean;
Cast_Result_4 : Internal_Entity_Field_Decl;
Var_Expr_2 : Internal_Entity_Field_Decl;
Fld_8 : Internal_Entity_Full_Decl;
Sym_3 : Symbol_Type;
Fld_9 : Boolean;
Result_Var_1 : Boolean;
If_Result : Boolean;
Find_Result : Internal_Entity;
Cast_Result_5 : Internal_Entity_Decl;
Var_Expr_3 : Internal_Entity_Decl;
Fld_10 : Internal_Entity_Decl;
Result_Var_2 : Internal_Entity_Decl;
Cast_Expr_2 : Internal_Entity_Type_Decl;
Cast_Result_6 : Internal_Entity;
Dyn_Var_Bind_Result_2 : Internal_Entity_Decl;
Scope_Result_2 : Internal_Entity_Decl;
Local_Mvd : Internal_Entity_Lambda_Param_Decl;
Fld_11 : Internal_Entity_Type_Ref;
Var_Expr_4 : Internal_Entity_Type_Ref;
Fld_12 : Internal_Entity_Type_Decl;
Scope_Result_3 : Internal_Entity_Type_Decl;
Result_Var_3 : Internal_Entity_Type_Decl;
Var_Expr_5 : Internal_Entity_Type_Decl;
Origin_3 : Internal_Entity;
Fld_13 : Lexical_Env := Empty_Env;
Fld_14 : Bare_Ref_Id;
Sym_4 : Symbol_Type;
Env_Get_Result_3 : Internal_Entity;
Cast_Result_7 : Internal_Entity_Decl;
Var_Expr_6 : Internal_Entity_Decl;
Fld_15 : Internal_Entity_Decl;
Result_Var_4 : Internal_Entity_Decl;
Cast_Result_8 : Internal_Entity;
Dyn_Var_Bind_Result_3 : Internal_Entity_Decl;
Scope_Result_4 : Internal_Entity_Decl;
Scope_Result_5 : Internal_Entity_Decl;
Result_Var_5 : Internal_Entity_Decl;
Ignored : Internal_Entity_Decl;
Fld_16 : Boolean;
Is_Null : Boolean;
If_Result_1 : Boolean;
Cast_Result_9 : Internal_Entity_Decl;
If_Result_2 : Internal_Entity_Decl;
Var_Expr_7 : Internal_Entity_Decl;
Origin_4 : Internal_Entity;
Fld_17 : Lexical_Env := Empty_Env;
Fld_18 : Bare_Ref_Id;
Sym_5 : Symbol_Type;
Env_Get_Result_4 : Internal_Entity;
Cast_Result_10 : Internal_Entity_Decl;
Var_Expr_8 : Internal_Entity_Decl;
Fld_19 : Internal_Entity_Decl;
Result_Var_6 : Internal_Entity_Decl;
Cast_Result_11 : Internal_Entity;
Dyn_Var_Bind_Result_4 : Internal_Entity_Decl;
Scope_Result_6 : Internal_Entity_Decl;
Scope_Result_7 : Internal_Entity_Decl;
Result_Var_7 : Internal_Entity_Decl;
Match_Prefix : Internal_Entity_Decl;
Cast_Result_12 : Internal_Entity_Enum_Type_Decl;
Let_Result : Internal_Entity_Decl;
Scope_Result_8 : Internal_Entity_Decl;
Cast_Result_13 : Internal_Entity_Enum_Lit_Decl;
Let_Result_1 : Internal_Entity_Decl;
Scope_Result_9 : Internal_Entity_Decl;
Cast_Result_14 : Internal_Entity_Type_Decl;
Let_Result_2 : Internal_Entity_Decl;
Scope_Result_10 : Internal_Entity_Decl;
Cast_Result_15 : Internal_Entity_Lambda_Param_Decl;
Let_Result_3 : Internal_Entity_Decl;
Scope_Result_11 : Internal_Entity_Decl;
Cast_Result_16 : Internal_Entity_Decl;
Let_Result_4 : Internal_Entity_Decl;
Scope_Result_12 : Internal_Entity_Decl;
Match_Result : Internal_Entity_Decl;
Scope_Result_13 : Internal_Entity_Decl;
Result_Var_8 : Internal_Entity_Decl;

            procedure Finalizer_Scope_517 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_517;
            procedure Finalizer_Scope_519 is
            begin
                     Dec_Ref (Fld_2);
            end Finalizer_Scope_519;
            procedure Finalizer_Scope_521 is
            begin
                     Dec_Ref (Fld_5);
                     Dec_Ref (Fld_6);
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Group_Env);
                     Dec_Ref (Env_Get_Result_2);
            end Finalizer_Scope_521;
            procedure Finalizer_Scope_526 is
            begin
                     Dec_Ref (Fld_13);
            end Finalizer_Scope_526;
            procedure Finalizer_Scope_529 is
            begin
                     Dec_Ref (Fld_17);
            end Finalizer_Scope_529;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 478 .do Result_Var_8 nodes.lkt:750




Var_Expr := Ent;





if Var_Expr /= No_Entity_Decl then
   



   --# scope-start



--# expr-start 477 Match Match_Result nodes.lkt:752










   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := Var_Expr; 

case Lkt_Decl (Match_Prefix.Node.Kind) is
         when Lkt_Enum_Type_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_12 := Create_Internal_Entity_Enum_Type_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_E := Cast_Result_12; 
--# bind e Local_E




   --# scope-start



--# expr-start 433 bind Dyn_Var_Bind_Result nodes.lkt:755






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Origin := Cast_Result_1; 
--# expr-start 432 Cast Cast_Result nodes.lkt:757





--# expr-start 431 .get_first Env_Get_Result nodes.lkt:757
--# expr-start 429 NamedTypeDecl.defined_scope Fld nodes.lkt:757







   if Local_E.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Local_E.Node, Origin => Origin, E_Info => Local_E.Info);
--# end
--# expr-done 429
--# expr-start 430 .symbol Sym nodes.lkt:758









Fld_1 := Current_Name.Node; 
Sym := Get_Symbol (Fld_1); 
--# expr-done 430


Env_Get_Result := AST_Envs.Get_First (Self => Fld, Key => Thin (Sym), Lookup_Kind => To_Lookup_Kind_Type (Flat), Categories => (Nocat => True)); 
--# expr-done 431



   if Env_Get_Result.Node = null
      or else Env_Get_Result.Node.Kind in Lkt_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Decl
        (Node => Env_Get_Result.Node,
         Info => Env_Get_Result.Info);

   else
         Cast_Result := No_Entity_Decl;
   end if;


--# expr-done 432
Dyn_Var_Bind_Result := Cast_Result; 
--# expr-done 433
Scope_Result := Dyn_Var_Bind_Result;


   --# end
      Finalizer_Scope_517;


Let_Result := Scope_Result; 
--# end
Scope_Result_8 := Let_Result;


   --# end


            Match_Result := Scope_Result_8; 
         when Lkt_Enum_Lit_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_13 := Create_Internal_Entity_Enum_Lit_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_E_1 := Cast_Result_13; 
--# bind e Local_E_1




   --# scope-start



--# expr-start 439 bind Dyn_Var_Bind_Result_1 nodes.lkt:765






Cast_Expr_1 := No_Entity_Type_Decl; 



   
      Cast_Result_3 := Create_Internal_Entity
        (Node => Cast_Expr_1.Node,
         Info => Cast_Expr_1.Info);


Origin_1 := Cast_Result_3; 



--# expr-start 437 Cast Cast_Result_2 nodes.lkt:767





--# expr-start 436 .get_first Env_Get_Result_1 nodes.lkt:767
--# expr-start 434 EnumLitDecl.defined_scope Fld_2 nodes.lkt:767







   if Local_E_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_2 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Local_E_1.Node, Origin => Origin_1, E_Info => Local_E_1.Info);
--# end
--# expr-done 434
--# expr-start 435 .symbol Sym_1 nodes.lkt:768









Fld_3 := Current_Name.Node; 
Sym_1 := Get_Symbol (Fld_3); 
--# expr-done 435


Env_Get_Result_1 := AST_Envs.Get_First (Self => Fld_2, Key => Thin (Sym_1), Lookup_Kind => To_Lookup_Kind_Type (Flat), Categories => (Nocat => True)); 
--# expr-done 436



   if Env_Get_Result_1.Node = null
      or else Env_Get_Result_1.Node.Kind in Lkt_Decl
   then
      
      Cast_Result_2 := Create_Internal_Entity_Decl
        (Node => Env_Get_Result_1.Node,
         Info => Env_Get_Result_1.Info);

   else
         Cast_Result_2 := No_Entity_Decl;
   end if;


--# expr-done 437
Var_Expr_1 := Cast_Result_2;





if Var_Expr_1 /= No_Entity_Decl then
   --# expr-start 438 Decl.subdecl_if_generic Fld_4 nodes.lkt:767







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.subdecl_if_generic
Fld_4 := Liblktlang.Implementation.Decl_P_Subdecl_If_Generic (Node => Var_Expr_1.Node, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 438
   Result_Var := Fld_4;
else
   
   Result_Var := No_Entity_Decl;
end if;



Dyn_Var_Bind_Result_1 := Result_Var; 
--# expr-done 439
Scope_Result_1 := Dyn_Var_Bind_Result_1;


   --# end
      Finalizer_Scope_519;


Let_Result_1 := Scope_Result_1; 
--# end
Scope_Result_9 := Let_Result_1;


   --# end


            Match_Result := Scope_Result_9; 
         when Lkt_Any_Type_Decl .. Lkt_Enum_Class_Decl | Lkt_Struct_Decl .. Lkt_Trait_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_14 := Create_Internal_Entity_Type_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Td := Cast_Result_14; 
--# bind td Local_Td




   --# scope-start



--# expr-start 455 bind Dyn_Var_Bind_Result_2 nodes.lkt:776






Cast_Expr_2 := No_Entity_Type_Decl; 



   
      Cast_Result_6 := Create_Internal_Entity
        (Node => Cast_Expr_2.Node,
         Info => Cast_Expr_2.Info);


Origin_2 := Cast_Result_6; 



--# expr-start 453 Cast Cast_Result_5 nodes.lkt:778





--# expr-start 452 .find Find_Result nodes.lkt:778








   

   --# expr-start 445 .get Env_Get_Result_2 nodes.lkt:778
--# expr-start 443 .env_group Group_Env nodes.lkt:778
--# expr-start 442 ArrayLiteral Array_Lit nodes.lkt:778
--# expr-start 440 Decl.defined_scope Fld_5 nodes.lkt:778







   if Local_Td.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_5 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Local_Td.Node, Origin => Origin_2, E_Info => Local_Td.Info);
--# end
--# expr-done 440
--# expr-start 441 TypeDecl.node_builder_scope Fld_6 nodes.lkt:778







   if Local_Td.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.node_builder_scope
Fld_6 := Liblktlang.Implementation.Type_Decl_P_Node_Builder_Scope (Node => Local_Td.Node, E_Info => Local_Td.Info);
--# end
--# expr-done 441
Array_Lit := Create_Lexical_Env_Array (Internal_Lexical_Env_Array'(1 => Fld_5, 2 => Fld_6)); 
--# expr-done 442

Group_Env := Group (Array_Lit, No_Metadata); 
--# expr-done 443
--# expr-start 444 .symbol Sym_2 nodes.lkt:780









Fld_7 := Current_Name.Node; 
Sym_2 := Get_Symbol (Fld_7); 
--# expr-done 444


Env_Get_Result_2 := Construct_Entity_Array (AST_Envs.Get (Self => Group_Env, Key => Thin (Sym_2), Lookup_Kind => To_Lookup_Kind_Type (Flat), Categories => (Nocat => True))); 
--# expr-done 445

   
      Find_Result := No_Entity;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Env_Get_Result_2;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind d Item

            
      --# expr-start 451 BooleanOr If_Result nodes.lkt:783



--# expr-start 446 IsA Is_A nodes.lkt:783

Is_A := Item.Node /= null 
and then Item.Node.Kind in Lkt_Type_Decl | Lkt_Fun_Decl_Range; 
--# expr-done 446
if Is_A then
   
   If_Result := True;
else
   


--# expr-start 447 Cast Cast_Result_4 nodes.lkt:784









   if Item.Node = null
      or else Item.Node.Kind in Lkt_Field_Decl_Range
   then
      
      Cast_Result_4 := Create_Internal_Entity_Field_Decl
        (Node => Item.Node,
         Info => Item.Info);

   else
         Cast_Result_4 := No_Entity_Field_Decl;
   end if;


--# expr-done 447
Var_Expr_2 := Cast_Result_4;





if Var_Expr_2 /= No_Entity_Field_Decl then
   --# expr-start 450 FullDecl.has_annotation Fld_9 nodes.lkt:784



--# expr-start 448 Decl.full_decl Fld_8 nodes.lkt:784







   if Var_Expr_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.full_decl
Fld_8 := Liblktlang.Implementation.Decl_P_Full_Decl (Node => Var_Expr_2.Node, E_Info => Var_Expr_2.Info);
--# end
--# expr-done 448



   if Fld_8.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 449 SymbolLiteral Sym_3 nodes.lkt:785
Sym_3 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Lazy); 
--# expr-done 449
--# property-call-start FullDecl.has_annotation
Fld_9 := Liblktlang.Implementation.Full_Decl_P_Has_Annotation (Node => Fld_8.Node, Name => Sym_3);
--# end
--# expr-done 450
   Result_Var_1 := Fld_9;
else
   
   Result_Var_1 := False;
end if;



   If_Result := Result_Var_1;
end if;



--# expr-done 451
      if If_Result then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when If_Result;

         end loop;
      end;
   

   
   



--# expr-done 452



   if Find_Result.Node = null
      or else Find_Result.Node.Kind in Lkt_Decl
   then
      
      Cast_Result_5 := Create_Internal_Entity_Decl
        (Node => Find_Result.Node,
         Info => Find_Result.Info);

   else
         Cast_Result_5 := No_Entity_Decl;
   end if;


--# expr-done 453
Var_Expr_3 := Cast_Result_5;





if Var_Expr_3 /= No_Entity_Decl then
   --# expr-start 454 Decl.subdecl_if_generic Fld_10 nodes.lkt:778







   if Var_Expr_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.subdecl_if_generic
Fld_10 := Liblktlang.Implementation.Decl_P_Subdecl_If_Generic (Node => Var_Expr_3.Node, E_Info => Var_Expr_3.Info);
--# end
--# expr-done 454
   Result_Var_2 := Fld_10;
else
   
   Result_Var_2 := No_Entity_Decl;
end if;



Dyn_Var_Bind_Result_2 := Result_Var_2; 
--# expr-done 455
Scope_Result_2 := Dyn_Var_Bind_Result_2;


   --# end
      Finalizer_Scope_521;


Let_Result_2 := Scope_Result_2; 
--# end
Scope_Result_10 := Let_Result_2;


   --# end


            Match_Result := Scope_Result_10; 
         when Lkt_Lambda_Param_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_15 := Create_Internal_Entity_Lambda_Param_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Mvd := Cast_Result_15; 
--# bind mvd Local_Mvd
--# expr-start 465 .do Result_Var_5 nodes.lkt:795



--# expr-start 458 .do Result_Var_3 nodes.lkt:795



--# expr-start 456 LambdaParamDecl.decl_type Fld_11 nodes.lkt:795







   if Local_Mvd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Create_Internal_Entity_Type_Ref (Node => Local_Mvd.Node.Lambda_Param_Decl_F_Decl_Type, Info => Local_Mvd.Info);
--# expr-done 456
Var_Expr_4 := Fld_11;





if Var_Expr_4 /= No_Entity_Type_Ref then
   



   --# scope-start



--# expr-start 457 Decl.get_type Fld_12 nodes.lkt:796







   if Local_Mvd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.get_type
Fld_12 := Liblktlang.Implementation.Decl_P_Get_Type (Node => Local_Mvd.Node, E_Info => Local_Mvd.Info);
--# end
--# expr-done 457
Scope_Result_3 := Fld_12;


   --# end


   Result_Var_3 := Scope_Result_3;
else
   
   Result_Var_3 := Type_Var;
end if;



--# expr-done 458
Var_Expr_5 := Result_Var_3;





if Var_Expr_5 /= No_Entity_Type_Decl then
   



   --# scope-start







   --# scope-start



--# expr-start 464 bind Dyn_Var_Bind_Result_3 nodes.lkt:801









   
      Cast_Result_8 := Create_Internal_Entity
        (Node => Var_Expr_5.Node,
         Info => Var_Expr_5.Info);


Origin_3 := Cast_Result_8; 



--# expr-start 462 Cast Cast_Result_7 nodes.lkt:803





--# expr-start 461 .get_first Env_Get_Result_3 nodes.lkt:803
--# expr-start 459 Decl.defined_scope Fld_13 nodes.lkt:803







   if Var_Expr_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_13 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Var_Expr_5.Node, Origin => Origin_3, E_Info => Var_Expr_5.Info);
--# end
--# expr-done 459
--# expr-start 460 .symbol Sym_4 nodes.lkt:804









Fld_14 := Current_Name.Node; 
Sym_4 := Get_Symbol (Fld_14); 
--# expr-done 460


Env_Get_Result_3 := AST_Envs.Get_First (Self => Fld_13, Key => Thin (Sym_4), Lookup_Kind => To_Lookup_Kind_Type (Flat), Categories => (Nocat => True)); 
--# expr-done 461



   if Env_Get_Result_3.Node = null
      or else Env_Get_Result_3.Node.Kind in Lkt_Decl
   then
      
      Cast_Result_7 := Create_Internal_Entity_Decl
        (Node => Env_Get_Result_3.Node,
         Info => Env_Get_Result_3.Info);

   else
         Cast_Result_7 := No_Entity_Decl;
   end if;


--# expr-done 462
Var_Expr_6 := Cast_Result_7;





if Var_Expr_6 /= No_Entity_Decl then
   --# expr-start 463 Decl.subdecl_if_generic Fld_15 nodes.lkt:803







   if Var_Expr_6.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.subdecl_if_generic
Fld_15 := Liblktlang.Implementation.Decl_P_Subdecl_If_Generic (Node => Var_Expr_6.Node, E_Info => Var_Expr_6.Info);
--# end
--# expr-done 463
   Result_Var_4 := Fld_15;
else
   
   Result_Var_4 := No_Entity_Decl;
end if;



Dyn_Var_Bind_Result_3 := Result_Var_4; 
--# expr-done 464
Scope_Result_4 := Dyn_Var_Bind_Result_3;


   --# end
      Finalizer_Scope_526;


Scope_Result_5 := Scope_Result_4;


   --# end


   Result_Var_5 := Scope_Result_5;
else
   
   Result_Var_5 := No_Entity_Decl;
end if;



--# expr-done 465
Let_Result_3 := Result_Var_5; 
--# end
Scope_Result_11 := Let_Result_3;


   --# end


            Match_Result := Scope_Result_11; 
         when Lkt_Grammar_Rule_Decl .. Lkt_Binding_Val_Decl | Lkt_Field_Decl .. Lkt_Fun_Param_Decl | Lkt_Dyn_Var_Decl .. Lkt_Synth_Param_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_16 := Create_Internal_Entity_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored := Cast_Result_16; 
--# bind _ Ignored
--# expr-start 476 .do Result_Var_7 nodes.lkt:812



--# expr-start 469 If If_Result_2 nodes.lkt:813



--# expr-start 468 BooleanAnd If_Result_1 nodes.lkt:813



--# expr-start 466 LktNode.xref_entry_point Fld_16 nodes.lkt:813







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_entry_point'
Fld_16 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Entry_Point (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 466
if Fld_16 then
   --# expr-start 467 .is_null Is_Null nodes.lkt:813

Is_Null := Type_Var.Node = null; 
--# expr-done 467
   If_Result_1 := Is_Null;
else
   
   If_Result_1 := False;
end if;



--# expr-done 468
if If_Result_1 then
   
   If_Result_2 := Ent;
else
   








   
      Cast_Result_9 := Create_Internal_Entity_Decl
        (Node => Type_Var.Node,
         Info => Type_Var.Info);


   If_Result_2 := Cast_Result_9;
end if;



--# expr-done 469
Var_Expr_7 := If_Result_2;





if Var_Expr_7 /= No_Entity_Decl then
   



   --# scope-start







   --# scope-start



--# expr-start 475 bind Dyn_Var_Bind_Result_4 nodes.lkt:819









   
      Cast_Result_11 := Create_Internal_Entity
        (Node => Var_Expr_7.Node,
         Info => Var_Expr_7.Info);


Origin_4 := Cast_Result_11; 



--# expr-start 473 Cast Cast_Result_10 nodes.lkt:821





--# expr-start 472 .get_first Env_Get_Result_4 nodes.lkt:821
--# expr-start 470 Decl.defined_scope Fld_17 nodes.lkt:821







   if Var_Expr_7.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_17 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Var_Expr_7.Node, Origin => Origin_4, E_Info => Var_Expr_7.Info);
--# end
--# expr-done 470
--# expr-start 471 .symbol Sym_5 nodes.lkt:822









Fld_18 := Current_Name.Node; 
Sym_5 := Get_Symbol (Fld_18); 
--# expr-done 471


Env_Get_Result_4 := AST_Envs.Get_First (Self => Fld_17, Key => Thin (Sym_5), Lookup_Kind => To_Lookup_Kind_Type (Flat), Categories => (Nocat => True)); 
--# expr-done 472



   if Env_Get_Result_4.Node = null
      or else Env_Get_Result_4.Node.Kind in Lkt_Decl
   then
      
      Cast_Result_10 := Create_Internal_Entity_Decl
        (Node => Env_Get_Result_4.Node,
         Info => Env_Get_Result_4.Info);

   else
         Cast_Result_10 := No_Entity_Decl;
   end if;


--# expr-done 473
Var_Expr_8 := Cast_Result_10;





if Var_Expr_8 /= No_Entity_Decl then
   --# expr-start 474 Decl.subdecl_if_generic Fld_19 nodes.lkt:821







   if Var_Expr_8.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.subdecl_if_generic
Fld_19 := Liblktlang.Implementation.Decl_P_Subdecl_If_Generic (Node => Var_Expr_8.Node, E_Info => Var_Expr_8.Info);
--# end
--# expr-done 474
   Result_Var_6 := Fld_19;
else
   
   Result_Var_6 := No_Entity_Decl;
end if;



Dyn_Var_Bind_Result_4 := Result_Var_6; 
--# expr-done 475
Scope_Result_6 := Dyn_Var_Bind_Result_4;


   --# end
      Finalizer_Scope_529;


Scope_Result_7 := Scope_Result_6;


   --# end


   Result_Var_7 := Scope_Result_7;
else
   
   Result_Var_7 := No_Entity_Decl;
end if;



--# expr-done 476
Let_Result_4 := Result_Var_7; 
--# end
Scope_Result_12 := Let_Result_4;


   --# end


            Match_Result := Scope_Result_12; 
end case;

--# expr-done 477
Scope_Result_13 := Match_Result;


   --# end


   Result_Var_8 := Scope_Result_13;
else
   
   Result_Var_8 := No_Entity_Decl;
end if;



--# expr-done 478

         Property_Result := Result_Var_8;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_517;
                     Finalizer_Scope_519;
                     Finalizer_Scope_521;
                     Finalizer_Scope_526;
                     Finalizer_Scope_529;




            raise;
      end;



   return Property_Result;
end Decl_P_Ref_Var_Suffix_Ref;
--# end

   







--# property-start Decl.get_params nodes.lkt:835
pragma Warnings (Off, "is not referenced");

function Decl_P_Get_Params
  
  (Node : Bare_Decl
      ; Is_Logic : Boolean
         := False
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Resolved_Param_Array_Access
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind is_logic Is_Logic

   Property_Result : Internal_Resolved_Param_Array_Access;

      
            procedure Finalizer_Scope_100 with Inline_Always;
            procedure Finalizer_Scope_530 with Inline_Always;
            procedure Finalizer_Scope_531 with Inline_Always;
            procedure Finalizer_Scope_537 with Inline_Always;
            procedure Finalizer_Scope_538 with Inline_Always;
            procedure Finalizer_Scope_540 with Inline_Always;
            procedure Finalizer_Scope_544 with Inline_Always;

      Var_Expr : Internal_Entity_Decl;
Local_Fd : Internal_Entity_Fun_Decl;
Sym : Symbol_Type;
Fld : Internal_Entity_Named_Type_Decl;
Fld_1 : Bare_Type_Decl;
As_Entity : Internal_Entity_Type_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Type_Decl;
Array_Lit : Internal_Entity_Type_Decl_Array_Access;
Fld_2 : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Type_Decl;
New_Node : Bare_Synth_Param_Decl;
As_Entity_1 : Internal_Entity_Synth_Param_Decl;
Is_Null_1 : Boolean;
If_Result_1 : Internal_Entity_Synth_Param_Decl;
Cast_Result_1 : Internal_Entity_Decl;
New_Struct : Internal_Resolved_Param;
Array_Lit_1 : Internal_Resolved_Param_Array_Access;
Fld_3 : Internal_Entity_Fun_Param_Decl_List;
Item : Internal_Entity_Fun_Param_Decl;
Fld_4 : Internal_Resolved_Param;
Fld_5 : Bare_Fun_Param_Decl_List;
Fld_6 : Internal_Entity_Info;
Bare_Item : Bare_Fun_Param_Decl;
As_Entity_2 : Internal_Entity_Fun_Param_Decl;
Is_Null_2 : Boolean;
If_Result_2 : Internal_Entity_Fun_Param_Decl;
Map_Result : Internal_Resolved_Param_Array_Access;
Concat_Result : Internal_Resolved_Param_Array_Access;
Fld_7 : Boolean;
Fld_8 : Internal_Entity_Fun_Param_Decl_List;
Fld_9 : Bare_Fun_Param_Decl_List;
Fld_10 : Internal_Entity_Info;
Get_Result : Bare_Fun_Param_Decl;
As_Entity_3 : Internal_Entity_Fun_Param_Decl;
Is_Null_3 : Boolean;
If_Result_3 : Internal_Entity_Fun_Param_Decl;
Fld_11 : Symbol_Type;
Fld_12 : Internal_Entity_Named_Type_Decl;
Fld_13 : Internal_Entity_Type_Decl;
Fld_14 : Internal_Entity_Fun_Param_Decl_List;
Fld_15 : Bare_Fun_Param_Decl_List;
Fld_16 : Internal_Entity_Info;
Get_Result_1 : Bare_Fun_Param_Decl;
As_Entity_4 : Internal_Entity_Fun_Param_Decl;
Is_Null_4 : Boolean;
If_Result_4 : Internal_Entity_Fun_Param_Decl;
Cast_Expr : Internal_Entity_Fun_Param_Decl;
Cast_Result_2 : Internal_Entity_Decl;
New_Struct_1 : Internal_Resolved_Param;
Array_Lit_2 : Internal_Resolved_Param_Array_Access;
Fld_17 : Internal_Entity_Fun_Param_Decl_List;
Item_1 : Internal_Entity_Fun_Param_Decl;
Index : Integer;
Comp_Result : Boolean;
Fld_18 : Bare_Fun_Param_Decl_List;
Fld_19 : Internal_Entity_Info;
Bare_Item_1 : Bare_Fun_Param_Decl;
As_Entity_5 : Internal_Entity_Fun_Param_Decl;
Is_Null_5 : Boolean;
If_Result_5 : Internal_Entity_Fun_Param_Decl;
Map_Result_1 : Internal_Entity_Fun_Param_Decl_Array_Access;
Fld_20 : Internal_Resolved_Param;
Map_Result_2 : Internal_Resolved_Param_Array_Access;
Concat_Result_1 : Internal_Resolved_Param_Array_Access;
If_Result_6 : Internal_Resolved_Param_Array_Access;
Not_Val : Boolean;
Fld_21 : Internal_Entity_Fun_Param_Decl_List;
Item_3 : Internal_Entity_Fun_Param_Decl;
Fld_22 : Internal_Resolved_Param;
Fld_23 : Bare_Fun_Param_Decl_List;
Fld_24 : Internal_Entity_Info;
Bare_Item_3 : Bare_Fun_Param_Decl;
As_Entity_6 : Internal_Entity_Fun_Param_Decl;
Is_Null_6 : Boolean;
If_Result_7 : Internal_Entity_Fun_Param_Decl;
Map_Result_3 : Internal_Resolved_Param_Array_Access;
If_Result_8 : Internal_Resolved_Param_Array_Access;
Local_Lfd : Internal_Entity_Synth_Fun_Decl;
Fld_25 : Internal_Resolved_Param_Array_Access;
Local_Cd : Internal_Entity_Class_Decl;
Fld_26 : Internal_Entity_Field_Decl_Array_Access;
Fld_27 : Internal_Resolved_Param;
Map_Result_4 : Internal_Resolved_Param_Array_Access;
Local_Td : Internal_Entity_Named_Type_Decl;
Fld_28 : Internal_Entity_Decl_Block;
Item_5 : Internal_Entity_Full_Decl;
Fld_29 : Internal_Entity_Decl;
Is_A : Boolean;
Fld_30 : Bare_Decl_Block;
Fld_31 : Internal_Entity_Info;
Bare_Item_5 : Bare_Full_Decl;
As_Entity_7 : Internal_Entity_Full_Decl;
Is_Null_7 : Boolean;
If_Result_9 : Internal_Entity_Full_Decl;
Map_Result_5 : Internal_Entity_Full_Decl_Array_Access;
Fld_32 : Internal_Entity_Decl;
Cast_Result_3 : Internal_Entity_Field_Decl;
Fld_33 : Internal_Resolved_Param;
Map_Result_6 : Internal_Resolved_Param_Array_Access;
Ignored : Internal_Entity_Decl;
Match_Prefix : Internal_Entity_Decl;
Cast_Result_4 : Internal_Entity_Fun_Decl;
Let_Result : Internal_Resolved_Param_Array_Access;
Scope_Result : Internal_Resolved_Param_Array_Access;
Cast_Result_5 : Internal_Entity_Synth_Fun_Decl;
Let_Result_1 : Internal_Resolved_Param_Array_Access;
Scope_Result_1 : Internal_Resolved_Param_Array_Access;
Cast_Result_6 : Internal_Entity_Class_Decl;
Let_Result_2 : Internal_Resolved_Param_Array_Access;
Scope_Result_2 : Internal_Resolved_Param_Array_Access;
Cast_Result_7 : Internal_Entity_Named_Type_Decl;
Let_Result_3 : Internal_Resolved_Param_Array_Access;
Scope_Result_3 : Internal_Resolved_Param_Array_Access;
Cast_Result_8 : Internal_Entity_Decl;
Let_Result_4 : Internal_Resolved_Param_Array_Access;
Scope_Result_4 : Internal_Resolved_Param_Array_Access;
Match_Result : Internal_Resolved_Param_Array_Access;
Scope_Result_5 : Internal_Resolved_Param_Array_Access;
Result_Var : Internal_Resolved_Param_Array_Access;

            procedure Finalizer_Scope_100 is
            begin
                     Dec_Ref (Scope_Result_5);
                     Dec_Ref (Result_Var);
            end Finalizer_Scope_100;
            procedure Finalizer_Scope_530 is
            begin
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (Scope_Result_2);
                     Dec_Ref (Scope_Result_3);
                     Dec_Ref (Scope_Result_4);
                     Dec_Ref (Match_Result);
            end Finalizer_Scope_530;
            procedure Finalizer_Scope_531 is
            begin
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Array_Lit_1);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Concat_Result);
                     Dec_Ref (Array_Lit_2);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (Map_Result_2);
                     Dec_Ref (Concat_Result_1);
                     Dec_Ref (If_Result_6);
                     Dec_Ref (Map_Result_3);
                     Dec_Ref (If_Result_8);
                     Dec_Ref (Let_Result);
            end Finalizer_Scope_531;
            procedure Finalizer_Scope_537 is
            begin
                     Dec_Ref (Fld_25);
                     Dec_Ref (Let_Result_1);
            end Finalizer_Scope_537;
            procedure Finalizer_Scope_538 is
            begin
                     Dec_Ref (Fld_26);
                     Dec_Ref (Map_Result_4);
                     Dec_Ref (Let_Result_2);
            end Finalizer_Scope_538;
            procedure Finalizer_Scope_540 is
            begin
                     Dec_Ref (Map_Result_5);
                     Dec_Ref (Map_Result_6);
                     Dec_Ref (Let_Result_3);
            end Finalizer_Scope_540;
            procedure Finalizer_Scope_544 is
            begin
                     Dec_Ref (Let_Result_4);
            end Finalizer_Scope_544;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Decl_Decl_P_Get_Params,
            Items    => new Mmz_Key_Array (1 ..  3))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Decl,
                                As_Bare_Decl => Self);
               Mmz_K.Items (2) := (Kind => Mmz_Boolean,
                                      As_Boolean => Is_Logic);
               Mmz_K.Items (3) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Resolved_Param_Array_Access;
                  Inc_Ref (Property_Result);

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 527 .do Result_Var nodes.lkt:836




Var_Expr := Ent;





if Var_Expr /= No_Entity_Decl then
   



   --# scope-start



--# expr-start 526 Match Match_Result nodes.lkt:838










   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := Var_Expr; 

case Lkt_Decl (Match_Prefix.Node.Kind) is
         when Lkt_Fun_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_4 := Create_Internal_Entity_Fun_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Fd := Cast_Result_4; 
--# bind fd Local_Fd
--# expr-start 513 If If_Result_8 nodes.lkt:840



--# expr-start 479 Not Not_Val nodes.lkt:840

Not_Val := not (Is_Logic); 
--# expr-done 479
if Not_Val then
   --# expr-start 482 .map Map_Result_3 nodes.lkt:841








   

   --# expr-start 480 FunDecl.params Fld_21 nodes.lkt:841







   if Local_Fd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_21 := Create_Internal_Entity_Fun_Param_Decl_List (Node => Local_Fd.Node.Fun_Decl_F_Params, Info => Local_Fd.Info);
--# expr-done 480









Fld_23 := Fld_21.Node;

   
      declare
         Map_Result_3_Vec : Internal_Resolved_Param_Vectors.Vector;
      begin
   

   

      if Fld_23 = null then
         
      Map_Result_3 := Create_Internal_Resolved_Param_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Fun_Param_Decl_List := Fld_23;
      begin
         for Untyped_Item_3 of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item_3 := Untyped_Item_3; 
                  



Is_Null_6 := Bare_Item_3 = null; 
if Is_Null_6 then
   
   If_Result_7 := No_Entity_Fun_Param_Decl;
else
   








Fld_24 := Fld_21.Info;

As_Entity_6 := (Info => Fld_24, Node => Bare_Item_3); 
   If_Result_7 := As_Entity_6;
end if;



                  Item_3 := If_Result_7; 

            
   --# scope-start


               --# bind p Item_3

            
         
         
      --# expr-start 481 ComponentDecl.to_generic_param Fld_22 nodes.lkt:841







   if Item_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start ComponentDecl.to_generic_param
Fld_22 := Liblktlang.Implementation.Component_Decl_P_To_Generic_Param (Node => Item_3.Node, E_Info => Item_3.Info);
--# end
--# expr-done 481
      

         declare
            Item_To_Append : constant Internal_Resolved_Param := Fld_22;
         begin
            Internal_Resolved_Param_Vectors.Append (Map_Result_3_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result_3 := Create_Internal_Resolved_Param_Array
           (Items_Count => Natural (Internal_Resolved_Param_Vectors.Length (Map_Result_3_Vec)));
         for I in Map_Result_3.Items'Range loop
            Map_Result_3.Items (I) := Internal_Resolved_Param_Vectors.Get
              (Map_Result_3_Vec,
               I + Internal_Resolved_Param_Vectors.Index_Type'First - Map_Result_3.Items'First);
         end loop;
         Internal_Resolved_Param_Vectors.Destroy (Map_Result_3_Vec);

      end;
   



--# expr-done 482
   If_Result_8 := Map_Result_3;
else
   --# expr-start 512 If If_Result_6 nodes.lkt:840



--# expr-start 483 FunDecl.is_dynamic_combiner Fld_7 nodes.lkt:842







   if Local_Fd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start FunDecl.is_dynamic_combiner
Fld_7 := Liblktlang.Implementation.Fun_Decl_P_Is_Dynamic_Combiner (Node => Local_Fd.Node, E_Info => Local_Fd.Info);
--# end
--# expr-done 483
if Fld_7 then
   --# expr-start 496 ArrayConcat Concat_Result_1 nodes.lkt:844
--# expr-start 490 ArrayLiteral Array_Lit_2 nodes.lkt:844
--# expr-start 489 'New[ResolvedParam]' New_Struct_1 nodes.lkt:845






--# expr-start 484 FunDecl.params Fld_14 nodes.lkt:850







   if Local_Fd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_14 := Create_Internal_Entity_Fun_Param_Decl_List (Node => Local_Fd.Node.Fun_Decl_F_Params, Info => Local_Fd.Info);
--# expr-done 484
















Fld_15 := Fld_14.Node;



   if Fld_15 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;




Get_Result_1 := Get (Self, Fld_15, 0, True); 
Is_Null_4 := Get_Result_1 = null; 
if Is_Null_4 then
   
   If_Result_4 := No_Entity_Fun_Param_Decl;
else
   








Fld_16 := Fld_14.Info;

As_Entity_4 := (Info => Fld_16, Node => Get_Result_1); 
   If_Result_4 := As_Entity_4;
end if;



Cast_Expr := If_Result_4; 



   
      Cast_Result_2 := Create_Internal_Entity_Decl
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);



--# expr-start 486 Decl.name Fld_11 nodes.lkt:846



--# expr-start 485 FunDecl.params Fld_8 nodes.lkt:846







   if Local_Fd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Create_Internal_Entity_Fun_Param_Decl_List (Node => Local_Fd.Node.Fun_Decl_F_Params, Info => Local_Fd.Info);
--# expr-done 485
















Fld_9 := Fld_8.Node;



   if Fld_9 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;




Get_Result := Get (Self, Fld_9, 0, True); 
Is_Null_3 := Get_Result = null; 
if Is_Null_3 then
   
   If_Result_3 := No_Entity_Fun_Param_Decl;
else
   








Fld_10 := Fld_8.Info;

As_Entity_3 := (Info => Fld_10, Node => Get_Result); 
   If_Result_3 := As_Entity_3;
end if;






   if If_Result_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_11 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => If_Result_3.Node);
--# end
--# expr-done 486
--# expr-start 488 TypeDecl.make_array_type Fld_13 nodes.lkt:847



--# expr-start 487 LktNode.logicvar_type Fld_12 nodes.lkt:847







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.logicvar_type
Fld_12 := Liblktlang.Implementation.Lkt_Node_P_Logicvar_Type (Node => Ent.Node);
--# end
--# expr-done 487



   if Fld_12.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.make_array_type
Fld_13 := Liblktlang.Implementation.Type_Decl_P_Make_Array_Type (Node => Fld_12.Node, E_Info => Fld_12.Info);
--# end
--# expr-done 488
New_Struct_1 := (Accept_Logical_Var => False, Decl => Cast_Result_2, Has_Default_Value => False, Name => Fld_11, Param_Type => Fld_13); 
--# expr-done 489
Array_Lit_2 := Create_Internal_Resolved_Param_Array (Internal_Internal_Resolved_Param_Array'(1 => New_Struct_1)); 
--# expr-done 490
--# expr-start 495 .map Map_Result_2 nodes.lkt:853








   

   --# expr-start 493 .ifilter Map_Result_1 nodes.lkt:853








   

   --# expr-start 491 FunDecl.params Fld_17 nodes.lkt:853







   if Local_Fd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_17 := Create_Internal_Entity_Fun_Param_Decl_List (Node => Local_Fd.Node.Fun_Decl_F_Params, Info => Local_Fd.Info);
--# expr-done 491









Fld_18 := Fld_17.Node;

   
      declare
         Map_Result_1_Vec : Internal_Entity_Fun_Param_Decl_Vectors.Vector;
      begin
   

   

      if Fld_18 = null then
         
      Map_Result_1 := Create_Internal_Entity_Fun_Param_Decl_Array (0);
   
      else
         
         Index := 0;

      declare
         
         Collection : constant Bare_Fun_Param_Decl_List := Fld_18;
      begin
         for Untyped_Item_1 of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item_1 := Untyped_Item_1; 
                  



Is_Null_5 := Bare_Item_1 = null; 
if Is_Null_5 then
   
   If_Result_5 := No_Entity_Fun_Param_Decl;
else
   








Fld_19 := Fld_17.Info;

As_Entity_5 := (Info => Fld_19, Node => Bare_Item_1); 
   If_Result_5 := As_Entity_5;
end if;



                  Item_1 := If_Result_5; 

            
   --# scope-start


               --# bind _ Item_1
               --# bind i Index

            
         --# expr-start 492 'OrderingTest <OrderingTestKind.greater_or_equal: 4>' Comp_Result nodes.lkt:853


Comp_Result := Index >= 1; 
--# expr-done 492
         if Comp_Result then
            
         
      
      

         declare
            Item_To_Append : constant Internal_Entity_Fun_Param_Decl := Item_1;
         begin
            Internal_Entity_Fun_Param_Decl_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
         end if;
   

            
   --# end



               Index := Index + 1;
         end loop;
      end;
   
      end if;

   

         Map_Result_1 := Create_Internal_Entity_Fun_Param_Decl_Array
           (Items_Count => Natural (Internal_Entity_Fun_Param_Decl_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Internal_Entity_Fun_Param_Decl_Vectors.Get
              (Map_Result_1_Vec,
               I + Internal_Entity_Fun_Param_Decl_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Internal_Entity_Fun_Param_Decl_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 493

   
      declare
         Map_Result_2_Vec : Internal_Resolved_Param_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Fun_Param_Decl_Array_Access := Map_Result_1;
      begin
         for Item_2 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind p Item_2

            
         
         
      --# expr-start 494 ComponentDecl.to_generic_param Fld_20 nodes.lkt:854







   if Item_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start ComponentDecl.to_generic_param
Fld_20 := Liblktlang.Implementation.Component_Decl_P_To_Generic_Param (Node => Item_2.Node, E_Info => Item_2.Info);
--# end
--# expr-done 494
      

         declare
            Item_To_Append : constant Internal_Resolved_Param := Fld_20;
         begin
            Internal_Resolved_Param_Vectors.Append (Map_Result_2_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result_2 := Create_Internal_Resolved_Param_Array
           (Items_Count => Natural (Internal_Resolved_Param_Vectors.Length (Map_Result_2_Vec)));
         for I in Map_Result_2.Items'Range loop
            Map_Result_2.Items (I) := Internal_Resolved_Param_Vectors.Get
              (Map_Result_2_Vec,
               I + Internal_Resolved_Param_Vectors.Index_Type'First - Map_Result_2.Items'First);
         end loop;
         Internal_Resolved_Param_Vectors.Destroy (Map_Result_2_Vec);

      end;
   



--# expr-done 495
Concat_Result_1 := Concat (Array_Lit_2, Map_Result_2); 
--# expr-done 496
   If_Result_6 := Concat_Result_1;
else
   --# expr-start 511 ArrayConcat Concat_Result nodes.lkt:856
--# expr-start 507 ArrayLiteral Array_Lit_1 nodes.lkt:856
--# expr-start 506 'New[ResolvedParam]' New_Struct nodes.lkt:857






--# expr-start 498 .as_entity If_Result_1 nodes.lkt:866



--# expr-start 497 'New[SynthParamDecl]' New_Node nodes.lkt:866



if Is_Foreign_Strict (Self.Self_Env, Self) then
   Raise_Property_Exception
     (Self,
      Property_Error'Identity,
      "synthetic nodes cannot have foreign lexical envs");
end if;


New_Node := new Root_Node_Record
  (Lkt_Synth_Param_Decl);
Initialize
  (Self => New_Node,
   Kind => Lkt_Synth_Param_Decl,
   Unit => Self.Unit,

   Token_Start_Index => No_Token_Index,
   Token_End_Index   => No_Token_Index,

   Parent => Self,

   Self_Env => Self.Self_Env);
Register_Destroyable (Self.Unit, New_Node);



--# expr-done 497
Is_Null_1 := New_Node = null; 
if Is_Null_1 then
   
   If_Result_1 := No_Entity_Synth_Param_Decl;
else
   

As_Entity_1 := (Info => E_Info, Node => New_Node); 
   If_Result_1 := As_Entity_1;
end if;



--# expr-done 498



   
      Cast_Result_1 := Create_Internal_Entity_Decl
        (Node => If_Result_1.Node,
         Info => If_Result_1.Info);



--# expr-start 499 SymbolLiteral Sym nodes.lkt:858
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Var); 
--# expr-done 499
--# expr-start 505 Cast Cast_Result nodes.lkt:860





--# expr-start 504 Decl.instantiate_generic_decl Fld_2 nodes.lkt:860



--# expr-start 500 LktNode.entity_type Fld nodes.lkt:860







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Self);
--# end
--# expr-done 500



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 503 ArrayLiteral Array_Lit nodes.lkt:862
--# expr-start 502 .as_entity If_Result nodes.lkt:862



--# expr-start 501 FunDecl.owning_type Fld_1 nodes.lkt:862







   if Local_Fd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start FunDecl.owning_type
Fld_1 := Liblktlang.Implementation.Fun_Decl_P_Owning_Type (Node => Local_Fd.Node);
--# end
--# expr-done 501
Is_Null := Fld_1 = null; 
if Is_Null then
   
   If_Result := No_Entity_Type_Decl;
else
   

As_Entity := (Info => E_Info, Node => Fld_1); 
   If_Result := As_Entity;
end if;



--# expr-done 502
Array_Lit := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => If_Result)); 
--# expr-done 503
--# property-call-start Decl.instantiate_generic_decl
Fld_2 := Liblktlang.Implementation.Decl_P_Instantiate_Generic_Decl (Node => Fld.Node, Param_Types => Array_Lit, E_Info => Fld.Info);
--# end
--# expr-done 504



   if Fld_2.Node = null
      or else Fld_2.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => Fld_2.Node,
         Info => Fld_2.Info);

   else
         Cast_Result := No_Entity_Type_Decl;
   end if;


--# expr-done 505
New_Struct := (Accept_Logical_Var => False, Decl => Cast_Result_1, Has_Default_Value => False, Name => Sym, Param_Type => Cast_Result); 
--# expr-done 506
Array_Lit_1 := Create_Internal_Resolved_Param_Array (Internal_Internal_Resolved_Param_Array'(1 => New_Struct)); 
--# expr-done 507
--# expr-start 510 .map Map_Result nodes.lkt:869








   

   --# expr-start 508 FunDecl.params Fld_3 nodes.lkt:869







   if Local_Fd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Fun_Param_Decl_List (Node => Local_Fd.Node.Fun_Decl_F_Params, Info => Local_Fd.Info);
--# expr-done 508









Fld_5 := Fld_3.Node;

   
      declare
         Map_Result_Vec : Internal_Resolved_Param_Vectors.Vector;
      begin
   

   

      if Fld_5 = null then
         
      Map_Result := Create_Internal_Resolved_Param_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Fun_Param_Decl_List := Fld_5;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null_2 := Bare_Item = null; 
if Is_Null_2 then
   
   If_Result_2 := No_Entity_Fun_Param_Decl;
else
   








Fld_6 := Fld_3.Info;

As_Entity_2 := (Info => Fld_6, Node => Bare_Item); 
   If_Result_2 := As_Entity_2;
end if;



                  Item := If_Result_2; 

            
   --# scope-start


               --# bind p Item

            
         
         
      --# expr-start 509 ComponentDecl.to_generic_param Fld_4 nodes.lkt:869







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start ComponentDecl.to_generic_param
Fld_4 := Liblktlang.Implementation.Component_Decl_P_To_Generic_Param (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 509
      

         declare
            Item_To_Append : constant Internal_Resolved_Param := Fld_4;
         begin
            Internal_Resolved_Param_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Internal_Resolved_Param_Array
           (Items_Count => Natural (Internal_Resolved_Param_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Resolved_Param_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Resolved_Param_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Resolved_Param_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 510
Concat_Result := Concat (Array_Lit_1, Map_Result); 
--# expr-done 511
   If_Result_6 := Concat_Result;
end if;

      Inc_Ref (If_Result_6);


--# expr-done 512
   If_Result_8 := If_Result_6;
end if;

      Inc_Ref (If_Result_8);


--# expr-done 513
Let_Result := If_Result_8; Inc_Ref (Let_Result);
--# end
Scope_Result := Let_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_531;


            Match_Result := Scope_Result; Inc_Ref (Match_Result);
         when Lkt_Synth_Fun_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_5 := Create_Internal_Entity_Synth_Fun_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Lfd := Cast_Result_5; 
--# bind lfd Local_Lfd
--# expr-start 514 SynthFunDecl.params Fld_25 nodes.lkt:870







   if Local_Lfd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_25 := Local_Lfd.Node.Synth_Fun_Decl_F_Params;
Inc_Ref (Fld_25);
--# expr-done 514
Let_Result_1 := Fld_25; Inc_Ref (Let_Result_1);
--# end
Scope_Result_1 := Let_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_537;


            Match_Result := Scope_Result_1; Inc_Ref (Match_Result);
         when Lkt_Class_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_6 := Create_Internal_Entity_Class_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Cd := Cast_Result_6; 
--# bind cd Local_Cd
--# expr-start 517 .map Map_Result_4 nodes.lkt:872








   

   --# expr-start 515 ClassDecl.constructor_fields Fld_26 nodes.lkt:872







   if Local_Cd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start ClassDecl.constructor_fields
Fld_26 := Liblktlang.Implementation.Class_Decl_P_Constructor_Fields (Node => Local_Cd.Node, E_Info => Local_Cd.Info);
--# end
--# expr-done 515

   
      declare
         Map_Result_4_Vec : Internal_Resolved_Param_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Field_Decl_Array_Access := Fld_26;
      begin
         for Item_4 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind d Item_4

            
         
         
      --# expr-start 516 ComponentDecl.to_generic_param Fld_27 nodes.lkt:872







   if Item_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start ComponentDecl.to_generic_param
Fld_27 := Liblktlang.Implementation.Component_Decl_P_To_Generic_Param (Node => Item_4.Node, E_Info => Item_4.Info);
--# end
--# expr-done 516
      

         declare
            Item_To_Append : constant Internal_Resolved_Param := Fld_27;
         begin
            Internal_Resolved_Param_Vectors.Append (Map_Result_4_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result_4 := Create_Internal_Resolved_Param_Array
           (Items_Count => Natural (Internal_Resolved_Param_Vectors.Length (Map_Result_4_Vec)));
         for I in Map_Result_4.Items'Range loop
            Map_Result_4.Items (I) := Internal_Resolved_Param_Vectors.Get
              (Map_Result_4_Vec,
               I + Internal_Resolved_Param_Vectors.Index_Type'First - Map_Result_4.Items'First);
         end loop;
         Internal_Resolved_Param_Vectors.Destroy (Map_Result_4_Vec);

      end;
   



--# expr-done 517
Let_Result_2 := Map_Result_4; Inc_Ref (Let_Result_2);
--# end
Scope_Result_2 := Let_Result_2;
   Inc_Ref (Scope_Result_2);


   --# end
      Finalizer_Scope_538;


            Match_Result := Scope_Result_2; Inc_Ref (Match_Result);
         when Lkt_Enum_Class_Decl .. Lkt_Trait_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_7 := Create_Internal_Entity_Named_Type_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Td := Cast_Result_7; 
--# bind td Local_Td
--# expr-start 525 .map Map_Result_6 nodes.lkt:874








   

   --# expr-start 521 .filter Map_Result_5 nodes.lkt:874








   

   --# expr-start 518 NamedTypeDecl.decls Fld_28 nodes.lkt:874







   if Local_Td.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_28 := Create_Internal_Entity_Decl_Block (Node => Implementation.Named_Type_Decl_F_Decls (Local_Td.Node), Info => Local_Td.Info);
--# expr-done 518









Fld_30 := Fld_28.Node;

   
      declare
         Map_Result_5_Vec : Internal_Entity_Full_Decl_Vectors.Vector;
      begin
   

   

      if Fld_30 = null then
         
      Map_Result_5 := Create_Internal_Entity_Full_Decl_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Decl_Block := Fld_30;
      begin
         for Untyped_Item_5 of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item_5 := Untyped_Item_5; 
                  



Is_Null_7 := Bare_Item_5 = null; 
if Is_Null_7 then
   
   If_Result_9 := No_Entity_Full_Decl;
else
   








Fld_31 := Fld_28.Info;

As_Entity_7 := (Info => Fld_31, Node => Bare_Item_5); 
   If_Result_9 := As_Entity_7;
end if;



                  Item_5 := If_Result_9; 

            
   --# scope-start


               --# bind d Item_5

            
         --# expr-start 520 IsA Is_A nodes.lkt:874
--# expr-start 519 FullDecl.decl Fld_29 nodes.lkt:874







   if Item_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_29 := Create_Internal_Entity_Decl (Node => Item_5.Node.Full_Decl_F_Decl, Info => Item_5.Info);
--# expr-done 519
Is_A := Fld_29.Node /= null 
and then Fld_29.Node.Kind in Lkt_Field_Decl_Range; 
--# expr-done 520
         if Is_A then
            
         
      
      

         declare
            Item_To_Append : constant Internal_Entity_Full_Decl := Item_5;
         begin
            Internal_Entity_Full_Decl_Vectors.Append (Map_Result_5_Vec, Item_To_Append);
         end;
   
   
         end if;
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result_5 := Create_Internal_Entity_Full_Decl_Array
           (Items_Count => Natural (Internal_Entity_Full_Decl_Vectors.Length (Map_Result_5_Vec)));
         for I in Map_Result_5.Items'Range loop
            Map_Result_5.Items (I) := Internal_Entity_Full_Decl_Vectors.Get
              (Map_Result_5_Vec,
               I + Internal_Entity_Full_Decl_Vectors.Index_Type'First - Map_Result_5.Items'First);
         end loop;
         Internal_Entity_Full_Decl_Vectors.Destroy (Map_Result_5_Vec);

      end;
   



--# expr-done 521

   
      declare
         Map_Result_6_Vec : Internal_Resolved_Param_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Full_Decl_Array_Access := Map_Result_5;
      begin
         for Item_6 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind d Item_6

            
         
         
      --# expr-start 524 ComponentDecl.to_generic_param Fld_33 nodes.lkt:875



--# expr-start 523 Cast Cast_Result_3 nodes.lkt:875





--# expr-start 522 FullDecl.decl Fld_32 nodes.lkt:875







   if Item_6.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_32 := Create_Internal_Entity_Decl (Node => Item_6.Node.Full_Decl_F_Decl, Info => Item_6.Info);
--# expr-done 522



   if Fld_32.Node = null
      or else Fld_32.Node.Kind in Lkt_Field_Decl_Range
   then
      
      Cast_Result_3 := Create_Internal_Entity_Field_Decl
        (Node => Fld_32.Node,
         Info => Fld_32.Info);

   else
         Cast_Result_3 := No_Entity_Field_Decl;
   end if;


--# expr-done 523



   if Cast_Result_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start ComponentDecl.to_generic_param
Fld_33 := Liblktlang.Implementation.Component_Decl_P_To_Generic_Param (Node => Cast_Result_3.Node, E_Info => Cast_Result_3.Info);
--# end
--# expr-done 524
      

         declare
            Item_To_Append : constant Internal_Resolved_Param := Fld_33;
         begin
            Internal_Resolved_Param_Vectors.Append (Map_Result_6_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result_6 := Create_Internal_Resolved_Param_Array
           (Items_Count => Natural (Internal_Resolved_Param_Vectors.Length (Map_Result_6_Vec)));
         for I in Map_Result_6.Items'Range loop
            Map_Result_6.Items (I) := Internal_Resolved_Param_Vectors.Get
              (Map_Result_6_Vec,
               I + Internal_Resolved_Param_Vectors.Index_Type'First - Map_Result_6.Items'First);
         end loop;
         Internal_Resolved_Param_Vectors.Destroy (Map_Result_6_Vec);

      end;
   



--# expr-done 525
Let_Result_3 := Map_Result_6; Inc_Ref (Let_Result_3);
--# end
Scope_Result_3 := Let_Result_3;
   Inc_Ref (Scope_Result_3);


   --# end
      Finalizer_Scope_540;


            Match_Result := Scope_Result_3; Inc_Ref (Match_Result);
         when Lkt_Grammar_Rule_Decl .. Lkt_Val_Decl | Lkt_Env_Spec_Decl .. Lkt_Lexer_Family_Decl | Lkt_Synth_Param_Decl .. Lkt_Generic_Param_Type_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_8 := Create_Internal_Entity_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored := Cast_Result_8; 
--# bind _ Ignored

Let_Result_4 := No_Internal_Resolved_Param_Array_Type; Inc_Ref (Let_Result_4);
--# end
Scope_Result_4 := Let_Result_4;
   Inc_Ref (Scope_Result_4);


   --# end
      Finalizer_Scope_544;


            Match_Result := Scope_Result_4; Inc_Ref (Match_Result);
end case;

--# expr-done 526
Scope_Result_5 := Match_Result;
   Inc_Ref (Scope_Result_5);


   --# end
      Finalizer_Scope_530;


   Result_Var := Scope_Result_5;
else
   
   Result_Var := No_Internal_Resolved_Param_Array_Type;
end if;

      Inc_Ref (Result_Var);


--# expr-done 527

         Property_Result := Result_Var;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_100;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_100;
                     Finalizer_Scope_530;
                     Finalizer_Scope_531;
                     Finalizer_Scope_537;
                     Finalizer_Scope_538;
                     Finalizer_Scope_540;
                     Finalizer_Scope_544;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Resolved_Param_Array_Access,
                     As_Internal_Resolved_Param_Array_Access => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
            if Mmz_Stored then
               Inc_Ref (Property_Result);
            end if;
      end if;



   return Property_Result;
end Decl_P_Get_Params;
--# end

   







--# property-start Decl.subdecl_if_generic nodes.lkt:885
pragma Warnings (Off, "is not referenced");

function Decl_P_Subdecl_If_Generic
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Decl
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Decl;

      

      Local_Gc : Internal_Entity_Generic_Decl;
Fld : Internal_Entity_Decl;
Ignored : Internal_Entity_Decl;
Match_Prefix : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Generic_Decl;
Let_Result : Internal_Entity_Decl;
Scope_Result : Internal_Entity_Decl;
Cast_Result_1 : Internal_Entity_Decl;
Let_Result_1 : Internal_Entity_Decl;
Scope_Result_1 : Internal_Entity_Decl;
Match_Result : Internal_Entity_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 529 Match Match_Result nodes.lkt:885










   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := Ent; 

case Lkt_Decl (Match_Prefix.Node.Kind) is
         when Lkt_Generic_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result := Create_Internal_Entity_Generic_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Gc := Cast_Result; 
--# bind gc Local_Gc
--# expr-start 528 GenericDecl.decl Fld nodes.lkt:886







   if Local_Gc.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Decl (Node => Local_Gc.Node.Generic_Decl_F_Decl, Info => Local_Gc.Info);
--# expr-done 528
Let_Result := Fld; 
--# end
Scope_Result := Let_Result;


   --# end


            Match_Result := Scope_Result; 
         when Lkt_Grammar_Rule_Decl .. Lkt_Error_Decl | Lkt_Grammar_Decl .. Lkt_Trait_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_1 := Create_Internal_Entity_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored := Cast_Result_1; 
--# bind _ Ignored

Let_Result_1 := Ent; 
--# end
Scope_Result_1 := Let_Result_1;


   --# end


            Match_Result := Scope_Result_1; 
end case;

--# expr-done 529

         Property_Result := Match_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Decl_P_Subdecl_If_Generic;
--# end

   







--# property-start Decl.is_generic nodes.lkt:893
pragma Warnings (Off, "is not referenced");

function Decl_P_Is_Generic
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Is_Null : Boolean;
Fld : Internal_Entity;
Is_A : Boolean;
If_Result : Boolean;
Cast_Result : Internal_Entity_Function_Type;
Var_Expr : Internal_Entity_Function_Type;
Fld_1 : Internal_Entity_Decl;
Var_Expr_1 : Internal_Entity_Decl;
Fld_2 : Boolean;
Result_Var : Boolean;
Scope_Result : Boolean;
Result_Var_1 : Boolean;
If_Result_1 : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 538 BooleanOr If_Result_1 nodes.lkt:894



--# expr-start 533 BooleanOr If_Result nodes.lkt:894



--# expr-start 530 .is_null Is_Null nodes.lkt:894

Is_Null := Ent.Node = null; 
--# expr-done 530
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 532 IsA Is_A nodes.lkt:894
--# expr-start 531 .parent Fld nodes.lkt:894







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Parent (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 531
Is_A := Fld.Node /= null 
and then Fld.Node.Kind in Lkt_Generic_Decl_Range; 
--# expr-done 532
   If_Result := Is_A;
end if;



--# expr-done 533
if If_Result then
   
   If_Result_1 := True;
else
   --# expr-start 537 .do Result_Var_1 nodes.lkt:895



--# expr-start 534 Cast Cast_Result nodes.lkt:895









   if Ent.Node = null
      or else Ent.Node.Kind in Lkt_Function_Type_Range
   then
      
      Cast_Result := Create_Internal_Entity_Function_Type
        (Node => Ent.Node,
         Info => Ent.Info);

   else
         Cast_Result := No_Entity_Function_Type;
   end if;


--# expr-done 534
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Function_Type then
   



   --# scope-start






--# expr-start 535 FunctionType.origin Fld_1 nodes.lkt:896







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Var_Expr.Node.Function_Type_F_Origin;
--# expr-done 535
Var_Expr_1 := Fld_1;





if Var_Expr_1 /= No_Entity_Decl then
   --# expr-start 536 Decl.is_generic Fld_2 nodes.lkt:896







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.is_generic
Fld_2 := Liblktlang.Implementation.Decl_P_Is_Generic (Node => Var_Expr_1.Node, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 536
   Result_Var := Fld_2;
else
   
   Result_Var := False;
end if;



Scope_Result := Result_Var;


   --# end


   Result_Var_1 := Scope_Result;
else
   
   Result_Var_1 := False;
end if;



--# expr-done 537
   If_Result_1 := Result_Var_1;
end if;



--# expr-done 538

         Property_Result := If_Result_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Decl_P_Is_Generic;
--# end

   







--# property-start Decl.return_type_is_instantiated nodes.lkt:902
pragma Warnings (Off, "is not referenced");

function Decl_P_Return_Type_Is_Instantiated
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Cast_Result : Internal_Entity_Function_Type;
Var_Expr : Internal_Entity_Function_Type;
Fld : Internal_Entity_Type_Decl;
Fld_1 : Boolean;
Result_Var : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         


--# expr-start 539 Cast Cast_Result nodes.lkt:903









   if Ent.Node = null
      or else Ent.Node.Kind in Lkt_Function_Type_Range
   then
      
      Cast_Result := Create_Internal_Entity_Function_Type
        (Node => Ent.Node,
         Info => Ent.Info);

   else
         Cast_Result := No_Entity_Function_Type;
   end if;


--# expr-done 539
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Function_Type then
   --# expr-start 541 Decl.is_instantiated Fld_1 nodes.lkt:903



--# expr-start 540 FunctionType.return_type Fld nodes.lkt:903







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Var_Expr.Node.Function_Type_F_Return_Type;
--# expr-done 540



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.is_instantiated
Fld_1 := Liblktlang.Implementation.Decl_P_Is_Instantiated (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 541
   Result_Var := Fld_1;
else
   
   Result_Var := False;
end if;




         Property_Result := Result_Var;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Decl_P_Return_Type_Is_Instantiated;
--# end

   







--# property-start Decl.is_instantiated nodes.lkt:908
pragma Warnings (Off, "is not referenced");

function Decl_P_Is_Instantiated
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      
            procedure Finalizer_Scope_548 with Inline_Always;
            procedure Finalizer_Scope_549 with Inline_Always;

      Fld : Internal_Entity;
Cast_Result : Internal_Entity_Generic_Decl;
Var_Expr : Internal_Entity_Generic_Decl;
Fld_1 : Internal_Entity_Generic_Param_Type_Decl_Array_Access;
Fld_2 : Lexical_Env := Empty_Env;
Fld_3 : Symbol_Type;
Env_Get_Result : Internal_Entity;
Cast_Result_1 : Internal_Entity_Type_Decl;
Cast_Result_2 : Internal_Entity_Type_Decl;
Fld_4 : Boolean;
Not_Val : Boolean;
Quantifier_Result : Boolean;
Scope_Result : Boolean;
Result_Var : Boolean;
Is_A : Boolean;
If_Result : Boolean;
Is_Null : Boolean;
If_Result_1 : Boolean;

            procedure Finalizer_Scope_548 is
            begin
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_548;
            procedure Finalizer_Scope_549 is
            begin
                     Dec_Ref (Fld_2);
            end Finalizer_Scope_549;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 556 If If_Result_1 nodes.lkt:909



--# expr-start 542 .is_null Is_Null nodes.lkt:909

Is_Null := Ent.Node = null; 
--# expr-done 542
if Is_Null then
   
   If_Result_1 := True;
else
   --# expr-start 555 If If_Result nodes.lkt:909



--# expr-start 543 IsA Is_A nodes.lkt:910

Is_A := Ent.Node /= null 
and then Ent.Node.Kind in Lkt_Generic_Param_Type_Decl_Range; 
--# expr-done 543
if Is_A then
   
   If_Result := False;
else
   --# expr-start 554 .do Result_Var nodes.lkt:912



--# expr-start 545 Cast Cast_Result nodes.lkt:912





--# expr-start 544 .parent Fld nodes.lkt:912







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Parent (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 544



   if Fld.Node = null
      or else Fld.Node.Kind in Lkt_Generic_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Generic_Decl
        (Node => Fld.Node,
         Info => Fld.Info);

   else
         Cast_Result := No_Entity_Generic_Decl;
   end if;


--# expr-done 545
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Generic_Decl then
   



   --# scope-start



--# expr-start 553 .all Quantifier_Result nodes.lkt:914








   

   --# expr-start 546 GenericDecl.generic_params Fld_1 nodes.lkt:914







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start GenericDecl.generic_params
Fld_1 := Liblktlang.Implementation.Generic_Decl_P_Generic_Params (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 546

   
      Quantifier_Result := True;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Generic_Param_Type_Decl_Array_Access := Fld_1;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind gf Item

            
      --# expr-start 552 Not Not_Val nodes.lkt:916
--# expr-start 551 TypeDecl.matching_type Fld_4 nodes.lkt:916



--# expr-start 550 Cast Cast_Result_1 nodes.lkt:916





--# expr-start 549 .get_first Env_Get_Result nodes.lkt:916
--# expr-start 547 LktNode.children_env Fld_2 nodes.lkt:916







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Liblktlang.Implementation.Children_Env (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# expr-done 547
--# expr-start 548 Decl.name Fld_3 nodes.lkt:916







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_3 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Item.Node);
--# end
--# expr-done 548


Env_Get_Result := AST_Envs.Get_First (Self => Fld_2, Key => Thin (Fld_3), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 549



   if Env_Get_Result.Node = null
      or else Env_Get_Result.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_1 := Create_Internal_Entity_Type_Decl
        (Node => Env_Get_Result.Node,
         Info => Env_Get_Result.Info);

   else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "invalid object cast");
   end if;


--# expr-done 550



   if Cast_Result_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;











   
      Cast_Result_2 := Create_Internal_Entity_Type_Decl
        (Node => Item.Node,
         Info => Item.Info);


--# property-call-start TypeDecl.matching_type
Fld_4 := Liblktlang.Implementation.Type_Decl_P_Matching_Type (Node => Cast_Result_1.Node, Other => Cast_Result_2, E_Info => Cast_Result_1.Info);
--# end
--# expr-done 551
Not_Val := not (Fld_4); 
--# expr-done 552
      Quantifier_Result := Not_Val;
   

            
   --# end
      Finalizer_Scope_549;


               exit when not Quantifier_Result;

         end loop;
      end;
   

   
   



--# expr-done 553
Scope_Result := Quantifier_Result;


   --# end
      Finalizer_Scope_548;


   Result_Var := Scope_Result;
else
   
   Result_Var := True;
end if;



--# expr-done 554
   If_Result := Result_Var;
end if;



--# expr-done 555
   If_Result_1 := If_Result;
end if;



--# expr-done 556

         Property_Result := If_Result_1;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_548;
                     Finalizer_Scope_549;




            raise;
      end;



   return Property_Result;
end Decl_P_Is_Instantiated;
--# end

   







--# property-start Decl.has_correct_type_arg_number nodes.lkt:925
pragma Warnings (Off, "is not referenced");

function Decl_P_Has_Correct_Type_Arg_Number
  
  (Node : Bare_Decl
      ; Nb_Types : Integer
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind nb_types Nb_Types

   Property_Result : Boolean;

      

      Is_Null : Boolean;
Fld : Internal_Entity;
Local_Gd : Internal_Entity_Generic_Decl;
Fld_1 : Internal_Entity_Generic_Param_Decl_List;
Fld_2 : Bare_Generic_Param_Decl_List;
Len : Integer;
Is_Equal : Boolean;
Ignored : Internal_Entity;
Match_Prefix : Internal_Entity;
Cast_Result : Internal_Entity_Generic_Decl;
Let_Result : Boolean;
Scope_Result : Boolean;
Cast_Result_1 : Internal_Entity;
Let_Result_1 : Boolean;
Scope_Result_1 : Boolean;
Match_Result : Boolean;
If_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 563 BooleanOr If_Result nodes.lkt:926



--# expr-start 557 .is_null Is_Null nodes.lkt:926

Is_Null := Ent.Node = null; 
--# expr-done 557
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 562 Match Match_Result nodes.lkt:927






--# expr-start 558 .parent Fld nodes.lkt:927







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Parent (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 558



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := Fld; 

case Lkt_Lkt_Node (Match_Prefix.Node.Kind) is
         when Lkt_Generic_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result := Create_Internal_Entity_Generic_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Gd := Cast_Result; 
--# bind gd Local_Gd
--# expr-start 561 Eq Is_Equal nodes.lkt:929
--# expr-start 560 .length Len nodes.lkt:929



--# expr-start 559 GenericDecl.generic_param_decls Fld_1 nodes.lkt:929







   if Local_Gd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Generic_Param_Decl_List (Node => Local_Gd.Node.Generic_Decl_F_Generic_Param_Decls, Info => Local_Gd.Info);
--# expr-done 559





Fld_2 := Fld_1.Node; 
Len := Length (Fld_2); 
--# expr-done 560

Is_Equal := Len = Nb_Types; 
--# expr-done 561
Let_Result := Is_Equal; 
--# end
Scope_Result := Let_Result;


   --# end


            Match_Result := Scope_Result; 
         when Lkt_Argument .. Lkt_Error_Decl | Lkt_Grammar_Decl .. Lkt_Var_Bind =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored := Cast_Result_1; 
--# bind _ Ignored

Let_Result_1 := True; 
--# end
Scope_Result_1 := Let_Result_1;


   --# end


            Match_Result := Scope_Result_1; 
end case;

--# expr-done 562
   If_Result := Match_Result;
end if;



--# expr-done 563

         Property_Result := If_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Decl_P_Has_Correct_Type_Arg_Number;
--# end

   







--# property-start Decl.could_infer nodes.lkt:936
pragma Warnings (Off, "is not referenced");

function Decl_P_Could_Infer
  
  (Node : Bare_Decl
      ; Generic_Type : Internal_Entity_Function_Type
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind generic_type Generic_Type

   Property_Result : Boolean;

      

      Is_Null : Boolean;
Is_Null_1 : Boolean;
Not_Val : Boolean;
If_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 567 BooleanOr If_Result nodes.lkt:937



--# expr-start 564 .is_null Is_Null nodes.lkt:937

Is_Null := Generic_Type.Node = null; 
--# expr-done 564
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 566 Not Not_Val nodes.lkt:937
--# expr-start 565 .is_null Is_Null_1 nodes.lkt:937

Is_Null_1 := Ent.Node = null; 
--# expr-done 565
Not_Val := not (Is_Null_1); 
--# expr-done 566
   If_Result := Not_Val;
end if;



--# expr-done 567

         Property_Result := If_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Decl_P_Could_Infer;
--# end

   







--# property-start Decl.instantiate_generic_decl nodes.lkt:942
pragma Warnings (Off, "is not referenced");

function Decl_P_Instantiate_Generic_Decl
  
  (Node : Bare_Decl
      ; Param_Types : Internal_Entity_Type_Decl_Array_Access
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Decl
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind param_types Param_Types

   Property_Result : Internal_Entity_Decl;

      
            procedure Finalizer_Scope_107 with Inline_Always;
            procedure Finalizer_Scope_552 with Inline_Always;

      Fld : Internal_Entity;
Cast_Result : Internal_Entity_Generic_Decl;
Fld_1 : Symbol_Type_Array_Access;
New_Node : Bare_Dyn_Env_Wrapper;
Var_Expr : Bare_Dyn_Env_Wrapper;
Fld_2 : Lexical_Env := Empty_Env;
Fld_3 : Internal_Entity_Decl;
Scope_Result : Internal_Entity_Decl;
Result_Var : Internal_Entity_Decl;
Is_Null : Boolean;
Is_Null_1 : Boolean;
Quantifier_Result : Boolean;
If_Result : Boolean;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result_1 : Internal_Entity_Decl;
If_Result_1 : Internal_Entity_Decl;

            procedure Finalizer_Scope_107 is
            begin
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_107;
            procedure Finalizer_Scope_552 is
            begin
                     Dec_Ref (Fld_2);
            end Finalizer_Scope_552;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Decl_Decl_P_Instantiate_Generic_Decl,
            Items    => new Mmz_Key_Array (1 ..  3))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Decl,
                                As_Bare_Decl => Self);
               Mmz_K.Items (2) := (Kind => Mmz_Internal_Entity_Type_Decl_Array_Access,
                                      As_Internal_Entity_Type_Decl_Array_Access => Param_Types);
                  Inc_Ref (Mmz_K.Items (2).As_Internal_Entity_Type_Decl_Array_Access);
               Mmz_K.Items (3) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Entity_Decl;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 579 If If_Result_1 nodes.lkt:945



--# expr-start 571 BooleanOr If_Result nodes.lkt:945



--# expr-start 568 .is_null Is_Null nodes.lkt:945

Is_Null := Ent.Node = null; 
--# expr-done 568
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 570 .any Quantifier_Result nodes.lkt:945








   

   

   
      Quantifier_Result := False;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Type_Decl_Array_Access := Param_Types;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind t Item

            
      --# expr-start 569 .is_null Is_Null_1 nodes.lkt:945

Is_Null_1 := Item.Node = null; 
--# expr-done 569
      Quantifier_Result := Is_Null_1;
   

            
   --# end


               exit when Quantifier_Result;

         end loop;
      end;
   

   
   



--# expr-done 570
   If_Result := Quantifier_Result;
end if;



--# expr-done 571
if If_Result then
   





Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result_1 := Create_Internal_Entity_Decl
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


   If_Result_1 := Cast_Result_1;
else
   --# expr-start 578 .do Result_Var nodes.lkt:948



--# expr-start 575 'New[DynEnvWrapper]' New_Node nodes.lkt:948
--# expr-start 574 GenericDecl.generic_params_names Fld_1 nodes.lkt:949



--# expr-start 573 Cast Cast_Result nodes.lkt:949





--# expr-start 572 .parent Fld nodes.lkt:949







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Parent (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 572



   if Fld.Node = null
      or else Fld.Node.Kind in Lkt_Generic_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Generic_Decl
        (Node => Fld.Node,
         Info => Fld.Info);

   else
         Cast_Result := No_Entity_Generic_Decl;
   end if;


--# expr-done 573



   if Cast_Result.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start GenericDecl.generic_params_names
Fld_1 := Liblktlang.Implementation.Generic_Decl_P_Generic_Params_Names (Node => Cast_Result.Node, E_Info => Cast_Result.Info);
--# end
--# expr-done 574

Inc_Ref (Fld_1);
Inc_Ref (Param_Types);


if Is_Foreign_Strict (Self.Self_Env, Self) then
   Raise_Property_Exception
     (Self,
      Property_Error'Identity,
      "synthetic nodes cannot have foreign lexical envs");
end if;


New_Node := new Root_Node_Record
  (Lkt_Dyn_Env_Wrapper);
Initialize
  (Self => New_Node,
   Kind => Lkt_Dyn_Env_Wrapper,
   Unit => Self.Unit,

   Token_Start_Index => No_Token_Index,
   Token_End_Index   => No_Token_Index,

   Parent => Self,

   Self_Env => Self.Self_Env);
Register_Destroyable (Self.Unit, New_Node);


      New_Node.Dyn_Env_Wrapper_F_Names :=
         Fld_1;
      New_Node.Dyn_Env_Wrapper_F_Types :=
         Param_Types;

--# expr-done 575
Var_Expr := New_Node;





if Var_Expr /= No_Bare_Lkt_Node then
   



   --# scope-start



--# expr-start 577 Decl.get_rebinded_decl Fld_3 nodes.lkt:954







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 576 DynEnvWrapper.dynenvwrapper_instantiation_env Fld_2 nodes.lkt:954







   if Var_Expr = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DynEnvWrapper.dynenvwrapper_instantiation_env
Fld_2 := Liblktlang.Implementation.Dyn_Env_Wrapper_F_Dynenvwrapper_Instantiation_Env (Node => Var_Expr);
--# end
--# expr-done 576
--# property-call-start Decl.get_rebinded_decl
Fld_3 := Liblktlang.Implementation.Decl_P_Get_Rebinded_Decl (Node => Ent.Node, Rebindings_Env => Fld_2, E_Info => Ent.Info);
--# end
--# expr-done 577
Scope_Result := Fld_3;


   --# end
      Finalizer_Scope_552;


   Result_Var := Scope_Result;
else
   
   Result_Var := No_Entity_Decl;
end if;



--# expr-done 578
   If_Result_1 := Result_Var;
end if;



--# expr-done 579

         Property_Result := If_Result_1;
         
   --# end
      Finalizer_Scope_107;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_107;
                     Finalizer_Scope_552;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Entity_Decl,
                     As_Internal_Entity_Decl => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Decl_P_Instantiate_Generic_Decl;
--# end

   







--# property-start Decl.get_rebinded_decl nodes.lkt:959
pragma Warnings (Off, "is not referenced");

function Decl_P_Get_Rebinded_Decl
  
  (Node : Bare_Decl
      ; Rebindings_Env : Lexical_Env
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Decl
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind rebindings_env Rebindings_Env

   Property_Result : Internal_Entity_Decl;

      
            procedure Finalizer_Scope_554 with Inline_Always;

      Fld : Bare_Lkt_Node;
Fld_1 : Lexical_Env := Empty_Env;
Fld_2 : Internal_Entity_Info;
Shed_Entity_Info : Internal_Entity_Info;
Local_Shed_Current : Internal_Entity_Info;
Fld_3 : Bare_Lkt_Node;
Cast_Result : Bare_Generic_Decl;
Var_Expr : Bare_Generic_Decl;
Fld_4 : Bare_Decl;
Result_Var : Bare_Decl;
Fld_5 : Env_Rebindings;
Fld_6 : Lexical_Env := Empty_Env;
Rebinding : Env_Rebindings;
New_Struct : Internal_Entity_Info;
New_Struct_1 : Internal_Entity_Decl;
Is_Null : Boolean;
Fld_7 : Internal_Entity;
Is_A : Boolean;
Not_Val : Boolean;
If_Result : Boolean;
If_Result_1 : Internal_Entity_Decl;
Let_Result : Internal_Entity_Decl;
Scope_Result : Internal_Entity_Decl;

            procedure Finalizer_Scope_554 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Fld_6);
            end Finalizer_Scope_554;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 598 ValDecl Let_Result nodes.lkt:960
--# scope-start
--# expr-start 583 .shed_rebindings Shed_Entity_Info nodes.lkt:960
--# expr-start 580 'Entity[Decl].info' Fld_2 nodes.lkt:960









Fld_2 := Ent.Info;
--# expr-done 580
--# expr-start 582 LktNode.node_env Fld_1 nodes.lkt:960



--# expr-start 581 .parent Fld nodes.lkt:960







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Self.Parent; 
--# expr-done 581



   if Fld = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Liblktlang.Implementation.Node_Env (Node => Fld);
--# expr-done 582
Shed_Entity_Info := AST_Envs.Shed_Rebindings (Fld_2, Fld_1); 
--# expr-done 583
Local_Shed_Current := Shed_Entity_Info; 
--# bind shed_current Local_Shed_Current
--# expr-start 597 If If_Result_1 nodes.lkt:962



--# expr-start 588 BooleanOr If_Result nodes.lkt:962



--# expr-start 584 .is_null Is_Null nodes.lkt:962

Is_Null := Ent.Node = null; 
--# expr-done 584
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 587 Not Not_Val nodes.lkt:962
--# expr-start 586 IsA Is_A nodes.lkt:962
--# expr-start 585 .parent Fld_7 nodes.lkt:962







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Liblktlang.Implementation.Parent (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 585
Is_A := Fld_7.Node /= null 
and then Fld_7.Node.Kind in Lkt_Generic_Decl_Range; 
--# expr-done 586
Not_Val := not (Is_A); 
--# expr-done 587
   If_Result := Not_Val;
end if;



--# expr-done 588
if If_Result then
   
   If_Result_1 := No_Entity_Decl;
else
   --# expr-start 596 'New[Entity[Decl]]' New_Struct_1 nodes.lkt:965
--# expr-start 592 'New[EntityInfo]' New_Struct nodes.lkt:967


--# expr-start 591 .append_rebinding Rebinding nodes.lkt:969
--# expr-start 589 EntityInfo.rebindings Fld_5 nodes.lkt:969









Fld_5 := Local_Shed_Current.Rebindings;
--# expr-done 589
--# expr-start 590 LktNode.node_env Fld_6 nodes.lkt:970







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Liblktlang.Implementation.Node_Env (Node => Self);
--# expr-done 590

Rebinding := AST_Envs.Append_Rebinding (Fld_5, Fld_6, Rebindings_Env); 
--# expr-done 591
New_Struct := (From_Rebound => False, Md => No_Metadata, Rebindings => Rebinding); 
--# expr-done 592



--# expr-start 594 Cast Cast_Result nodes.lkt:966





--# expr-start 593 .parent Fld_3 nodes.lkt:966







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Self.Parent; 
--# expr-done 593



   if Fld_3 = null
      or else Fld_3.Kind in Lkt_Generic_Decl_Range
   then
      
      Cast_Result := Fld_3;

   else
         Cast_Result := No_Bare_Lkt_Node;
   end if;


--# expr-done 594
Var_Expr := Cast_Result;





if Var_Expr /= No_Bare_Lkt_Node then
   --# expr-start 595 GenericDecl.decl Fld_4 nodes.lkt:966







   if Var_Expr = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Var_Expr.Generic_Decl_F_Decl;
--# expr-done 595
   Result_Var := Fld_4;
else
   
   Result_Var := No_Bare_Lkt_Node;
end if;



New_Struct_1 := (Info => New_Struct, Node => Result_Var); 
--# expr-done 596
   If_Result_1 := New_Struct_1;
end if;



--# expr-done 597
Let_Result := If_Result_1; 
--# end
--# expr-done 598
Scope_Result := Let_Result;


   --# end
      Finalizer_Scope_554;



         Property_Result := Scope_Result;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_554;




            raise;
      end;



   return Property_Result;
end Decl_P_Get_Rebinded_Decl;
--# end

   







--# property-start Decl.is_dynvar nodes.lkt:979
pragma Warnings (Off, "is not referenced");

function Decl_P_Is_Dynvar
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Is_Null : Boolean;
Is_A : Boolean;
If_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 601 BooleanOr If_Result nodes.lkt:979



--# expr-start 599 .is_null Is_Null nodes.lkt:979

Is_Null := Ent.Node = null; 
--# expr-done 599
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 600 IsA Is_A nodes.lkt:979

Is_A := Ent.Node /= null 
and then Ent.Node.Kind in Lkt_Dyn_Var_Decl_Range; 
--# expr-done 600
   If_Result := Is_A;
end if;



--# expr-done 601

         Property_Result := If_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Decl_P_Is_Dynvar;
--# end

   







--# property-start '[dispatcher]Decl.name' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Decl_P_Name
  
  (Node : Bare_Decl
  )

   return Symbol_Type
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
      --# bind node Self

   


   Property_Result : Symbol_Type;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Decl (Self.Kind) is
               when Lkt_Grammar_Rule_Decl | Lkt_Binding_Val_Decl .. Lkt_Error_Decl | Lkt_Grammar_Decl .. Lkt_Trait_Decl =>
                  --# property-call-start 'Decl.[root-static]name'
                  Property_Result := Decl_P_Name
                    (Self
                    );
                  --# end
               when Lkt_Synthetic_Lexer_Decl =>
                  --# property-call-start SyntheticLexerDecl.name
                  Property_Result := Synthetic_Lexer_Decl_P_Name
                    (Self
                    );
                  --# end
               when Lkt_Node_Decl =>
                  --# property-call-start NodeDecl.name
                  Property_Result := Node_Decl_P_Name
                    (Self
                    );
                  --# end
               when Lkt_Self_Decl =>
                  --# property-call-start SelfDecl.name
                  Property_Result := Self_Decl_P_Name
                    (Self
                    );
                  --# end
               when Lkt_Generic_Decl =>
                  --# property-call-start GenericDecl.name
                  Property_Result := Generic_Decl_P_Name
                    (Self
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Decl_P_Name;
--# end

   







--# property-start '[dispatcher]Decl.full_name_internal' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Decl_P_Full_Name_Internal
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Decl (Self.Kind) is
               when Lkt_Grammar_Rule_Decl .. Lkt_Synth_Fun_Decl | Lkt_Enum_Class_Alt_Decl | Lkt_Generic_Param_Type_Decl .. Lkt_Trait_Decl =>
                  --# property-call-start 'Decl.[root-static]full_name_internal'
                  Property_Result := Decl_P_Full_Name_Internal
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Synth_Param_Decl =>
                  --# property-call-start SynthParamDecl.full_name_internal
                  Property_Result := Synth_Param_Decl_P_Full_Name_Internal
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Any_Type_Decl =>
                  --# property-call-start AnyTypeDecl.full_name_internal
                  Property_Result := Any_Type_Decl_P_Full_Name_Internal
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Function_Type =>
                  --# property-call-start FunctionType.full_name_internal
                  Property_Result := Function_Type_P_Full_Name_Internal
                    (Self
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Decl_P_Full_Name_Internal;
--# end

   







--# property-start '[dispatcher]Decl.full_name' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Decl_P_Full_Name
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Decl (Self.Kind) is
               when Lkt_Grammar_Rule_Decl .. Lkt_Synth_Param_Decl =>
                  --# property-call-start 'Decl.[root-static]full_name'
                  Property_Result := Decl_P_Full_Name
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Any_Type_Decl .. Lkt_Trait_Decl =>
                  --# property-call-start TypeDecl.full_name
                  Property_Result := Type_Decl_P_Full_Name
                    (Self
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Decl_P_Full_Name;
--# end

   







--# property-start '[dispatcher]Decl.defined_scope' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Decl_P_Defined_Scope
  
  (Node : Bare_Decl
      ; Origin : Internal_Entity
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Lexical_Env
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind origin Origin

   Property_Result : Lexical_Env;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Decl (Self.Kind) is
               when Lkt_Grammar_Rule_Decl .. Lkt_Synthetic_Lexer_Decl | Lkt_Env_Spec_Decl .. Lkt_Any_Type_Decl | Lkt_Generic_Param_Type_Decl =>
                  --# property-call-start 'Decl.[root-static]defined_scope'
                  Property_Result := Decl_P_Defined_Scope
                    (Self
                        , Origin
                        , E_Info
                    );
                  --# end
               when Lkt_Node_Decl .. Lkt_Binding_Val_Decl | Lkt_Field_Decl .. Lkt_Fun_Decl =>
                  --# property-call-start BaseValDecl.defined_scope
                  Property_Result := Base_Val_Decl_P_Defined_Scope
                    (Self
                        , Origin
                        , E_Info
                    );
                  --# end
               when Lkt_Enum_Lit_Decl =>
                  --# property-call-start EnumLitDecl.defined_scope
                  Property_Result := Enum_Lit_Decl_P_Defined_Scope
                    (Self
                        , Origin
                        , E_Info
                    );
                  --# end
               when Lkt_Enum_Class_Alt_Decl =>
                  --# property-call-start EnumClassAltDecl.defined_scope
                  Property_Result := Enum_Class_Alt_Decl_P_Defined_Scope
                    (Self
                        , Origin
                        , E_Info
                    );
                  --# end
               when Lkt_Function_Type =>
                  --# property-call-start FunctionType.defined_scope
                  Property_Result := Function_Type_P_Defined_Scope
                    (Self
                        , Origin
                        , E_Info
                    );
                  --# end
               when Lkt_Enum_Type_Decl | Lkt_Trait_Decl =>
                  --# property-call-start NamedTypeDecl.defined_scope
                  Property_Result := Named_Type_Decl_P_Defined_Scope
                    (Self
                        , Origin
                        , E_Info
                    );
                  --# end
               when Lkt_Class_Decl .. Lkt_Enum_Class_Decl =>
                  --# property-call-start BasicClassDecl.defined_scope
                  Property_Result := Basic_Class_Decl_P_Defined_Scope
                    (Self
                        , Origin
                        , E_Info
                    );
                  --# end
               when Lkt_Struct_Decl =>
                  --# property-call-start StructDecl.defined_scope
                  Property_Result := Struct_Decl_P_Defined_Scope
                    (Self
                        , Origin
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Decl_P_Defined_Scope;
--# end

   







--# property-start '[dispatcher]Decl.defined_scope_as_entity' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Decl_P_Defined_Scope_As_Entity
  
  (Node : Bare_Decl
      ; Origin : Internal_Entity
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Lexical_Env
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind origin Origin

   Property_Result : Lexical_Env;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Decl (Self.Kind) is
               when Lkt_Grammar_Rule_Decl .. Lkt_Generic_Param_Type_Decl | Lkt_Enum_Type_Decl .. Lkt_Struct_Decl =>
                  --# property-call-start 'Decl.[root-static]defined_scope_as_entity'
                  Property_Result := Decl_P_Defined_Scope_As_Entity
                    (Self
                        , Origin
                        , E_Info
                    );
                  --# end
               when Lkt_Class_Decl .. Lkt_Enum_Class_Decl =>
                  --# property-call-start BasicClassDecl.defined_scope_as_entity
                  Property_Result := Basic_Class_Decl_P_Defined_Scope_As_Entity
                    (Self
                        , Origin
                        , E_Info
                    );
                  --# end
               when Lkt_Trait_Decl =>
                  --# property-call-start TraitDecl.defined_scope_as_entity
                  Property_Result := Trait_Decl_P_Defined_Scope_As_Entity
                    (Self
                        , Origin
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Decl_P_Defined_Scope_As_Entity;
--# end

   







--# property-start Decl.is_directly_referenceable nodes.lkt:1022
pragma Warnings (Off, "is not referenced");

function Decl_P_Is_Directly_Referenceable
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Is_Null : Boolean;
Is_A : Boolean;
Not_Val : Boolean;
Cast_Result : Internal_Entity_Fun_Decl;
Var_Expr : Internal_Entity_Fun_Decl;
Fld : Bare_Type_Decl;
Is_Null_1 : Boolean;
Scope_Result : Boolean;
Result_Var : Boolean;
If_Result : Boolean;
If_Result_1 : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 610 BooleanOr If_Result_1 nodes.lkt:1023



--# expr-start 602 .is_null Is_Null nodes.lkt:1023

Is_Null := Ent.Node = null; 
--# expr-done 602
if Is_Null then
   
   If_Result_1 := True;
else
   --# expr-start 609 BooleanAnd If_Result nodes.lkt:1024



--# expr-start 604 Not Not_Val nodes.lkt:1024
--# expr-start 603 IsA Is_A nodes.lkt:1024

Is_A := Ent.Node /= null 
and then Ent.Node.Kind in Lkt_Field_Decl_Range; 
--# expr-done 603
Not_Val := not (Is_A); 
--# expr-done 604
if Not_Val then
   --# expr-start 608 .do Result_Var nodes.lkt:1025



--# expr-start 605 Cast Cast_Result nodes.lkt:1025









   if Ent.Node = null
      or else Ent.Node.Kind in Lkt_Fun_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Fun_Decl
        (Node => Ent.Node,
         Info => Ent.Info);

   else
         Cast_Result := No_Entity_Fun_Decl;
   end if;


--# expr-done 605
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Fun_Decl then
   



   --# scope-start



--# expr-start 607 .is_null Is_Null_1 nodes.lkt:1026
--# expr-start 606 FunDecl.owning_type Fld nodes.lkt:1026







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start FunDecl.owning_type
Fld := Liblktlang.Implementation.Fun_Decl_P_Owning_Type (Node => Var_Expr.Node);
--# end
--# expr-done 606
Is_Null_1 := Fld = null; 
--# expr-done 607
Scope_Result := Is_Null_1;


   --# end


   Result_Var := Scope_Result;
else
   
   Result_Var := True;
end if;



--# expr-done 608
   If_Result := Result_Var;
else
   
   If_Result := False;
end if;



--# expr-done 609
   If_Result_1 := If_Result;
end if;



--# expr-done 610

         Property_Result := If_Result_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Decl_P_Is_Directly_Referenceable;
--# end

   







--# property-start Decl.extraneous_parameter nodes.lkt:1036
pragma Warnings (Off, "is not referenced");

function Decl_P_Extraneous_Parameter
  
  (Node : Bare_Decl
      ; Callee_Type : Internal_Entity_Type_Decl
      ; Callee : Internal_Entity_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind callee_type Callee_Type
   --# bind callee Callee

   Property_Result : Boolean;

      

      Is_Null : Boolean;
Is_Null_1 : Boolean;
Not_Val : Boolean;
If_Result : Boolean;
Is_Null_2 : Boolean;
If_Result_1 : Boolean;
Cast_Result : Internal_Entity_Function_Type;
Var_Expr : Internal_Entity_Function_Type;
Fld : Boolean;
Result_Var : Boolean;
If_Result_2 : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 619 BooleanOr If_Result_2 nodes.lkt:1040



--# expr-start 616 BooleanOr If_Result_1 nodes.lkt:1040



--# expr-start 614 BooleanOr If_Result nodes.lkt:1040



--# expr-start 611 .is_null Is_Null nodes.lkt:1040

Is_Null := Callee.Node = null; 
--# expr-done 611
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 613 Not Not_Val nodes.lkt:1041
--# expr-start 612 .is_null Is_Null_1 nodes.lkt:1041

Is_Null_1 := Ent.Node = null; 
--# expr-done 612
Not_Val := not (Is_Null_1); 
--# expr-done 613
   If_Result := Not_Val;
end if;



--# expr-done 614
if If_Result then
   
   If_Result_1 := True;
else
   --# expr-start 615 .is_null Is_Null_2 nodes.lkt:1042

Is_Null_2 := Callee_Type.Node = null; 
--# expr-done 615
   If_Result_1 := Is_Null_2;
end if;



--# expr-done 616
if If_Result_1 then
   
   If_Result_2 := True;
else
   


--# expr-start 617 Cast Cast_Result nodes.lkt:1043









   if Callee_Type.Node = null
      or else Callee_Type.Node.Kind in Lkt_Function_Type_Range
   then
      
      Cast_Result := Create_Internal_Entity_Function_Type
        (Node => Callee_Type.Node,
         Info => Callee_Type.Info);

   else
         Cast_Result := No_Entity_Function_Type;
   end if;


--# expr-done 617
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Function_Type then
   --# expr-start 618 FunctionType.should_ignore_constructor_arg Fld nodes.lkt:1043







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start FunctionType.should_ignore_constructor_arg
Fld := Liblktlang.Implementation.Function_Type_P_Should_Ignore_Constructor_Arg (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 618
   Result_Var := Fld;
else
   
   Result_Var := False;
end if;



   If_Result_2 := Result_Var;
end if;



--# expr-done 619

         Property_Result := If_Result_2;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Decl_P_Extraneous_Parameter;
--# end

   







--# property-start Decl.unmatched_argument nodes.lkt:1048
pragma Warnings (Off, "is not referenced");

function Decl_P_Unmatched_Argument
  
  (Node : Bare_Decl
      ; Callee_Type : Internal_Entity_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind callee_type Callee_Type

   Property_Result : Boolean;

      

      Is_Null : Boolean;
Not_Val : Boolean;
Is_Null_1 : Boolean;
If_Result : Boolean;
Cast_Result : Internal_Entity_Function_Type;
Var_Expr : Internal_Entity_Function_Type;
Fld : Boolean;
Result_Var : Boolean;
If_Result_1 : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 626 BooleanOr If_Result_1 nodes.lkt:1049



--# expr-start 623 BooleanOr If_Result nodes.lkt:1049



--# expr-start 621 Not Not_Val nodes.lkt:1049
--# expr-start 620 .is_null Is_Null nodes.lkt:1049

Is_Null := Ent.Node = null; 
--# expr-done 620
Not_Val := not (Is_Null); 
--# expr-done 621
if Not_Val then
   
   If_Result := True;
else
   --# expr-start 622 .is_null Is_Null_1 nodes.lkt:1050

Is_Null_1 := Callee_Type.Node = null; 
--# expr-done 622
   If_Result := Is_Null_1;
end if;



--# expr-done 623
if If_Result then
   
   If_Result_1 := True;
else
   


--# expr-start 624 Cast Cast_Result nodes.lkt:1051









   if Callee_Type.Node = null
      or else Callee_Type.Node.Kind in Lkt_Function_Type_Range
   then
      
      Cast_Result := Create_Internal_Entity_Function_Type
        (Node => Callee_Type.Node,
         Info => Callee_Type.Info);

   else
         Cast_Result := No_Entity_Function_Type;
   end if;


--# expr-done 624
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Function_Type then
   --# expr-start 625 FunctionType.should_ignore_constructor_arg Fld nodes.lkt:1051







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start FunctionType.should_ignore_constructor_arg
Fld := Liblktlang.Implementation.Function_Type_P_Should_Ignore_Constructor_Arg (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 625
   Result_Var := Fld;
else
   
   Result_Var := False;
end if;



   If_Result_1 := Result_Var;
end if;



--# expr-done 626

         Property_Result := If_Result_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Decl_P_Unmatched_Argument;
--# end

   







--# property-start 'Decl.[internal]internal_env_mappings_1' nodes.lkt:1058
pragma Warnings (Off, "is not referenced");

function Internal_Env_Mappings_1
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Env_Assoc_Array_Access
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Env_Assoc_Array_Access;

      
            procedure Finalizer_Scope_416 with Inline_Always;

      Fld : Symbol_Type;
New_Struct : Internal_Designated_Env := No_Designated_Env;
Cast_Result : Bare_Lkt_Node;
New_Struct_1 : Internal_Env_Assoc := No_Env_Assoc;
Array_Lit : Internal_Env_Assoc_Array_Access;
Fld_1 : Internal_Entity_Full_Decl;
Var_Expr : Internal_Entity_Full_Decl;
Sym : Symbol_Type;
Fld_2 : Boolean;
Result_Var : Boolean;
Fld_3 : Symbol_Type;
Sym_1 : Symbol_Type;
Is_Equal : Boolean;
Not_Val : Boolean;
If_Result : Boolean;
Sym_2 : Symbol_Type;
New_Struct_2 : Internal_Designated_Env := No_Designated_Env;
Cast_Result_1 : Bare_Lkt_Node;
New_Struct_3 : Internal_Env_Assoc := No_Env_Assoc;
Fld_4 : Symbol_Type;
New_Struct_4 : Internal_Designated_Env := No_Designated_Env;
Cast_Result_2 : Bare_Lkt_Node;
New_Struct_5 : Internal_Env_Assoc := No_Env_Assoc;
Array_Lit_1 : Internal_Env_Assoc_Array_Access;
If_Result_1 : Internal_Env_Assoc_Array_Access;
Fld_5 : Internal_Entity_Full_Decl;
Var_Expr_1 : Internal_Entity_Full_Decl;
Sym_3 : Symbol_Type;
Fld_6 : Boolean;
Result_Var_1 : Boolean;
Fld_7 : Boolean;
If_Result_2 : Boolean;
Fld_8 : Symbol_Type;
Sym_4 : Symbol_Type;
Is_Equal_1 : Boolean;
Not_Val_1 : Boolean;
If_Result_3 : Boolean;
Sym_5 : Symbol_Type;
New_Struct_6 : Internal_Designated_Env := No_Designated_Env;
Cast_Result_3 : Bare_Lkt_Node;
New_Struct_7 : Internal_Env_Assoc := No_Env_Assoc;
Fld_9 : Symbol_Type;
New_Struct_8 : Internal_Designated_Env := No_Designated_Env;
Cast_Result_4 : Bare_Lkt_Node;
New_Struct_9 : Internal_Env_Assoc := No_Env_Assoc;
Array_Lit_2 : Internal_Env_Assoc_Array_Access;
If_Result_4 : Internal_Env_Assoc_Array_Access;

            procedure Finalizer_Scope_416 is
            begin
                     Dec_Ref (New_Struct);
                     Dec_Ref (New_Struct_1);
                     Dec_Ref (Array_Lit);
                     Dec_Ref (New_Struct_2);
                     Dec_Ref (New_Struct_3);
                     Dec_Ref (New_Struct_4);
                     Dec_Ref (New_Struct_5);
                     Dec_Ref (Array_Lit_1);
                     Dec_Ref (If_Result_1);
                     Dec_Ref (New_Struct_6);
                     Dec_Ref (New_Struct_7);
                     Dec_Ref (New_Struct_8);
                     Dec_Ref (New_Struct_9);
                     Dec_Ref (Array_Lit_2);
                     Dec_Ref (If_Result_4);
            end Finalizer_Scope_416;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 662 If If_Result_4 nodes.lkt:1058



--# expr-start 635 BooleanAnd If_Result_3 nodes.lkt:1059



--# expr-start 631 BooleanOr If_Result_2 nodes.lkt:1060






--# expr-start 627 Decl.full_decl Fld_5 nodes.lkt:1060







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.full_decl
Fld_5 := Liblktlang.Implementation.Decl_P_Full_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 627
Var_Expr_1 := Fld_5;





if Var_Expr_1 /= No_Entity_Full_Decl then
   --# expr-start 629 FullDecl.has_annotation Fld_6 nodes.lkt:1060







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 628 SymbolLiteral Sym_3 nodes.lkt:1060
Sym_3 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Root_Node); 
--# expr-done 628
--# property-call-start FullDecl.has_annotation
Fld_6 := Liblktlang.Implementation.Full_Decl_P_Has_Annotation (Node => Var_Expr_1.Node, Name => Sym_3);
--# end
--# expr-done 629
   Result_Var_1 := Fld_6;
else
   
   Result_Var_1 := False;
end if;



if Result_Var_1 then
   
   If_Result_2 := True;
else
   --# expr-start 630 Decl.implements_node Fld_7 nodes.lkt:1061







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.implements_node
Fld_7 := Liblktlang.Implementation.Decl_P_Implements_Node (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 630
   If_Result_2 := Fld_7;
end if;



--# expr-done 631
if If_Result_2 then
   --# expr-start 634 NotEqual Not_Val_1 nodes.lkt:1063
--# expr-start 632 Decl.name Fld_8 nodes.lkt:1063







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_8 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Ent.Node);
--# end
--# expr-done 632
--# expr-start 633 SymbolLiteral Sym_4 nodes.lkt:1063
Sym_4 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Rootnode); 
--# expr-done 633
Is_Equal_1 := Fld_8 = Sym_4; 
Not_Val_1 := not (Is_Equal_1); 
--# expr-done 634
   If_Result_3 := Not_Val_1;
else
   
   If_Result_3 := False;
end if;



--# expr-done 635
if If_Result_3 then
   --# expr-start 642 ArrayLiteral Array_Lit_2 nodes.lkt:1065
--# expr-start 638 'New[EnvAssoc]' New_Struct_7 nodes.lkt:1066
--# expr-start 636 'New[DesignatedEnv]' New_Struct_6 nodes.lkt:1069



Inc_Ref (Empty_Env);
New_Struct_6 := (Direct_Env => Empty_Env, Env_Name => No_Symbol, Kind => Current_Env); 
--# expr-done 636
--# expr-start 637 SymbolLiteral Sym_5 nodes.lkt:1067
Sym_5 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Rootnode); 
--# expr-done 637










   
      Cast_Result_3 := Self;


Inc_Ref (New_Struct_6);
New_Struct_7 := (Dest_Env => New_Struct_6, Key => Sym_5, Metadata => No_Metadata, Value => Cast_Result_3); 
--# expr-done 638
--# expr-start 641 'New[EnvAssoc]' New_Struct_9 nodes.lkt:1076
--# expr-start 639 'New[DesignatedEnv]' New_Struct_8 nodes.lkt:1079



Inc_Ref (Empty_Env);
New_Struct_8 := (Direct_Env => Empty_Env, Env_Name => No_Symbol, Kind => Current_Env); 
--# expr-done 639
--# expr-start 640 Decl.name Fld_9 nodes.lkt:1077







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_9 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Ent.Node);
--# end
--# expr-done 640










   
      Cast_Result_4 := Self;


Inc_Ref (New_Struct_8);
New_Struct_9 := (Dest_Env => New_Struct_8, Key => Fld_9, Metadata => No_Metadata, Value => Cast_Result_4); 
--# expr-done 641
Array_Lit_2 := Create_Internal_Env_Assoc_Array (Internal_Internal_Env_Assoc_Array'(1 => New_Struct_7, 2 => New_Struct_9)); 
--# expr-done 642
   If_Result_4 := Array_Lit_2;
else
   --# expr-start 661 If If_Result_1 nodes.lkt:1058



--# expr-start 649 BooleanAnd If_Result nodes.lkt:1088






--# expr-start 643 Decl.full_decl Fld_1 nodes.lkt:1088







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.full_decl
Fld_1 := Liblktlang.Implementation.Decl_P_Full_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 643
Var_Expr := Fld_1;





if Var_Expr /= No_Entity_Full_Decl then
   --# expr-start 645 FullDecl.has_annotation Fld_2 nodes.lkt:1088







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 644 SymbolLiteral Sym nodes.lkt:1088
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Metadata_46); 
--# expr-done 644
--# property-call-start FullDecl.has_annotation
Fld_2 := Liblktlang.Implementation.Full_Decl_P_Has_Annotation (Node => Var_Expr.Node, Name => Sym);
--# end
--# expr-done 645
   Result_Var := Fld_2;
else
   
   Result_Var := False;
end if;



if Result_Var then
   --# expr-start 648 NotEqual Not_Val nodes.lkt:1089
--# expr-start 646 Decl.name Fld_3 nodes.lkt:1089







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_3 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Ent.Node);
--# end
--# expr-done 646
--# expr-start 647 SymbolLiteral Sym_1 nodes.lkt:1089
Sym_1 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Metadata); 
--# expr-done 647
Is_Equal := Fld_3 = Sym_1; 
Not_Val := not (Is_Equal); 
--# expr-done 648
   If_Result := Not_Val;
else
   
   If_Result := False;
end if;



--# expr-done 649
if If_Result then
   --# expr-start 656 ArrayLiteral Array_Lit_1 nodes.lkt:1091
--# expr-start 652 'New[EnvAssoc]' New_Struct_3 nodes.lkt:1092
--# expr-start 650 'New[DesignatedEnv]' New_Struct_2 nodes.lkt:1095



Inc_Ref (Empty_Env);
New_Struct_2 := (Direct_Env => Empty_Env, Env_Name => No_Symbol, Kind => Current_Env); 
--# expr-done 650
--# expr-start 651 SymbolLiteral Sym_2 nodes.lkt:1093
Sym_2 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Metadata); 
--# expr-done 651










   
      Cast_Result_1 := Self;


Inc_Ref (New_Struct_2);
New_Struct_3 := (Dest_Env => New_Struct_2, Key => Sym_2, Metadata => No_Metadata, Value => Cast_Result_1); 
--# expr-done 652
--# expr-start 655 'New[EnvAssoc]' New_Struct_5 nodes.lkt:1102
--# expr-start 653 'New[DesignatedEnv]' New_Struct_4 nodes.lkt:1105



Inc_Ref (Empty_Env);
New_Struct_4 := (Direct_Env => Empty_Env, Env_Name => No_Symbol, Kind => Current_Env); 
--# expr-done 653
--# expr-start 654 Decl.name Fld_4 nodes.lkt:1103







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_4 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Ent.Node);
--# end
--# expr-done 654










   
      Cast_Result_2 := Self;


Inc_Ref (New_Struct_4);
New_Struct_5 := (Dest_Env => New_Struct_4, Key => Fld_4, Metadata => No_Metadata, Value => Cast_Result_2); 
--# expr-done 655
Array_Lit_1 := Create_Internal_Env_Assoc_Array (Internal_Internal_Env_Assoc_Array'(1 => New_Struct_3, 2 => New_Struct_5)); 
--# expr-done 656
   If_Result_1 := Array_Lit_1;
else
   --# expr-start 660 ArrayLiteral Array_Lit nodes.lkt:1114
--# expr-start 659 'New[EnvAssoc]' New_Struct_1 nodes.lkt:1115
--# expr-start 657 'New[DesignatedEnv]' New_Struct nodes.lkt:1118



Inc_Ref (Empty_Env);
New_Struct := (Direct_Env => Empty_Env, Env_Name => No_Symbol, Kind => Current_Env); 
--# expr-done 657
--# expr-start 658 Decl.name Fld nodes.lkt:1116







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Ent.Node);
--# end
--# expr-done 658










   
      Cast_Result := Self;


Inc_Ref (New_Struct);
New_Struct_1 := (Dest_Env => New_Struct, Key => Fld, Metadata => No_Metadata, Value => Cast_Result); 
--# expr-done 659
Array_Lit := Create_Internal_Env_Assoc_Array (Internal_Internal_Env_Assoc_Array'(1 => New_Struct_1)); 
--# expr-done 660
   If_Result_1 := Array_Lit;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 661
   If_Result_4 := If_Result_1;
end if;

      Inc_Ref (If_Result_4);


--# expr-done 662

         Property_Result := If_Result_4;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_416;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_416;




            raise;
      end;



   return Property_Result;
end Internal_Env_Mappings_1;
--# end

   







--# property-start 'Decl.[root-static]name' nodes.lkt:983
pragma Warnings (Off, "is not referenced");

function Decl_P_Name
  
  (Node : Bare_Decl
  )

   return Symbol_Type
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
      --# bind node Self

   


   Property_Result : Symbol_Type;

      

      Fld : Bare_Def_Id;
Var_Expr : Bare_Def_Id;
Sym : Symbol_Type;
Result_Var : Symbol_Type;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         


--# expr-start 663 Decl.syn_name Fld nodes.lkt:983







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Implementation.Decl_F_Syn_Name (Self);
--# expr-done 663
Var_Expr := Fld;





if Var_Expr /= No_Bare_Lkt_Node then
   --# expr-start 664 .symbol Sym nodes.lkt:983

Sym := Get_Symbol (Var_Expr); 
--# expr-done 664
   Result_Var := Sym;
else
   
   Result_Var := No_Symbol;
end if;




         Property_Result := Result_Var;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Decl_P_Name;
--# end

   







--# property-start 'Decl.[root-static]full_name_internal' nodes.lkt:988
pragma Warnings (Off, "is not referenced");

function Decl_P_Full_Name_Internal
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_111 with Inline_Always;

      Fld : Symbol_Type;
Fld_1 : String_Type;
Fld_2 : Internal_Entity;
Cast_Result : Internal_Entity_Generic_Decl;
Var_Expr : Internal_Entity_Generic_Decl;
Fld_3 : String_Type;
Result_Var : String_Type;
Concat_Result : String_Type;

            procedure Finalizer_Scope_111 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Fld_3);
                     Dec_Ref (Result_Var);
                     Dec_Ref (Concat_Result);
            end Finalizer_Scope_111;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 670 StringConcat Concat_Result nodes.lkt:989
--# expr-start 666 Symbol.image Fld_1 nodes.lkt:989



--# expr-start 665 Decl.name Fld nodes.lkt:989







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Ent.Node);
--# end
--# expr-done 665





Fld_1 := Liblktlang.Implementation.Image (Self => Fld);
--# expr-done 666



--# expr-start 668 Cast Cast_Result nodes.lkt:990





--# expr-start 667 .parent Fld_2 nodes.lkt:990







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Liblktlang.Implementation.Parent (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 667



   if Fld_2.Node = null
      or else Fld_2.Node.Kind in Lkt_Generic_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Generic_Decl
        (Node => Fld_2.Node,
         Info => Fld_2.Info);

   else
         Cast_Result := No_Entity_Generic_Decl;
   end if;


--# expr-done 668
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Generic_Decl then
   --# expr-start 669 GenericDecl.image_suffix Fld_3 nodes.lkt:990







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start GenericDecl.image_suffix
Fld_3 := Liblktlang.Implementation.Generic_Decl_P_Image_Suffix (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 669
   Result_Var := Fld_3;
else
   
   Result_Var := Empty_String;
end if;

      Inc_Ref (Result_Var);


Concat_Result := Concat_String (Fld_1, Result_Var); 
--# expr-done 670

         Property_Result := Concat_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_111;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_111;




            raise;
      end;



   return Property_Result;
end Decl_P_Full_Name_Internal;
--# end

   







--# property-start 'Decl.[root-static]full_name' nodes.lkt:995
pragma Warnings (Off, "is not referenced");

function Decl_P_Full_Name
  
  (Node : Bare_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_112 with Inline_Always;

      Fld : String_Type;

            procedure Finalizer_Scope_112 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_112;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 671 Decl.full_name_internal Fld nodes.lkt:996







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.full_name_internal'
Fld := Liblktlang.Implementation.Dispatcher_Decl_P_Full_Name_Internal (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 671

         Property_Result := Fld;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_112;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_112;




            raise;
      end;



   return Property_Result;
end Decl_P_Full_Name;
--# end

   







--# property-start 'Decl.[root-static]defined_scope' nodes.lkt:1001
pragma Warnings (Off, "is not referenced");

function Decl_P_Defined_Scope
  
  (Node : Bare_Decl
      ; Origin : Internal_Entity
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Lexical_Env
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind origin Origin

   Property_Result : Lexical_Env;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := Empty_Env;
            Inc_Ref (Property_Result);
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Decl_P_Defined_Scope;
--# end

   







--# property-start 'Decl.[root-static]defined_scope_as_entity' nodes.lkt:1019
pragma Warnings (Off, "is not referenced");

function Decl_P_Defined_Scope_As_Entity
  
  (Node : Bare_Decl
      ; Origin : Internal_Entity
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Lexical_Env
is
   Self : Bare_Decl :=
     Bare_Decl (Node);
     Ent : Internal_Entity_Decl :=
       Internal_Entity_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind origin Origin

   Property_Result : Lexical_Env;

      
            procedure Finalizer_Scope_114 with Inline_Always;

      Fld : Lexical_Env := Empty_Env;

            procedure Finalizer_Scope_114 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_114;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 672 Decl.defined_scope Fld nodes.lkt:1019







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Ent.Node, Origin => Origin, E_Info => Ent.Info);
--# end
--# expr-done 672

         Property_Result := Fld;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_114;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_114;




            raise;
      end;



   return Property_Result;
end Decl_P_Defined_Scope_As_Entity;
--# end



   


      

   --
   --  Primitives for Bare_Base_Grammar_Rule_Decl
   --

   




      
   function Base_Grammar_Rule_Decl_F_Expr
     (Node : Bare_Base_Grammar_Rule_Decl) return Bare_Grammar_Expr
   is
      

         Kind : constant Lkt_Base_Grammar_Rule_Decl := Node.Kind;
   begin
         case Kind is
               when Lkt_Grammar_Rule_Decl =>
                     
         return Node.Grammar_Rule_Decl_F_Expr;
      
               when Lkt_Synthetic_Lexer_Decl =>
                     return No_Bare_Lkt_Node;
         end case;
   end;




   


      

   --
   --  Primitives for Bare_Grammar_Rule_Decl
   --

   



      
      procedure Initialize_Fields_For_Grammar_Rule_Decl
        (Self : Bare_Grammar_Rule_Decl
         ; Grammar_Rule_Decl_F_Syn_Name : Bare_Def_Id
         ; Grammar_Rule_Decl_F_Expr : Bare_Grammar_Expr
        ) is
      begin

            Self.Grammar_Rule_Decl_F_Syn_Name := Grammar_Rule_Decl_F_Syn_Name;
            Self.Grammar_Rule_Decl_F_Expr := Grammar_Rule_Decl_F_Expr;
         

      end Initialize_Fields_For_Grammar_Rule_Decl;


   







--# property-start GrammarRuleDecl.decl_type_name nodes.lkt:1155
pragma Warnings (Off, "is not referenced");

function Grammar_Rule_Decl_P_Decl_Type_Name
  
  (Node : Bare_Grammar_Rule_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Grammar_Rule_Decl :=
     Bare_Grammar_Rule_Decl (Node);
     Ent : Internal_Entity_Grammar_Rule_Decl :=
       Internal_Entity_Grammar_Rule_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_119 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_119 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_119;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 673 StringLiteral Str nodes.lkt:1155
Str := Create_String ("grammar rule declaration"); 
--# expr-done 673

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_119;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_119;




            raise;
      end;



   return Property_Result;
end Grammar_Rule_Decl_P_Decl_Type_Name;
--# end



   


      

   --
   --  Primitives for Bare_Synthetic_Lexer_Decl
   --

   



      
      procedure Initialize_Fields_For_Synthetic_Lexer_Decl
        (Self : Bare_Synthetic_Lexer_Decl
        ) is
      begin

         
      Self.Synthetic_Lexer_Decl_F_Sym := No_Symbol;

      end Initialize_Fields_For_Synthetic_Lexer_Decl;


   







--# property-start SyntheticLexerDecl.name nodes.lkt:1169
pragma Warnings (Off, "is not referenced");

function Synthetic_Lexer_Decl_P_Name
  
  (Node : Bare_Synthetic_Lexer_Decl
  )

   return Symbol_Type
is
   Self : Bare_Synthetic_Lexer_Decl :=
     Bare_Synthetic_Lexer_Decl (Node);
      --# bind node Self

   


   Property_Result : Symbol_Type;

      

      Fld : Symbol_Type;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 674 SyntheticLexerDecl.sym Fld nodes.lkt:1169







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Self.Synthetic_Lexer_Decl_F_Sym;
--# expr-done 674

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Synthetic_Lexer_Decl_P_Name;
--# end

   







--# property-start SyntheticLexerDecl.decl_type_name nodes.lkt:1171
pragma Warnings (Off, "is not referenced");

function Synthetic_Lexer_Decl_P_Decl_Type_Name
  
  (Node : Bare_Synthetic_Lexer_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Synthetic_Lexer_Decl :=
     Bare_Synthetic_Lexer_Decl (Node);
     Ent : Internal_Entity_Synthetic_Lexer_Decl :=
       Internal_Entity_Synthetic_Lexer_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_121 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_121 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_121;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 675 StringLiteral Str nodes.lkt:1171
Str := Create_String ("synthetic lexer declaration"); 
--# expr-done 675

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_121;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_121;




            raise;
      end;



   return Property_Result;
end Synthetic_Lexer_Decl_P_Decl_Type_Name;
--# end



   


      

   --
   --  Primitives for Bare_Base_Val_Decl
   --

   





   







--# property-start BaseValDecl.defined_scope nodes.lkt:1179
pragma Warnings (Off, "is not referenced");

function Base_Val_Decl_P_Defined_Scope
  
  (Node : Bare_Base_Val_Decl
      ; Origin : Internal_Entity
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Lexical_Env
is
   Self : Bare_Base_Val_Decl :=
     Bare_Base_Val_Decl (Node);
     Ent : Internal_Entity_Base_Val_Decl :=
       Internal_Entity_Base_Val_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind origin Origin

   Property_Result : Lexical_Env;

      
            procedure Finalizer_Scope_122 with Inline_Always;
            procedure Finalizer_Scope_556 with Inline_Always;
            procedure Finalizer_Scope_557 with Inline_Always;

      Fld : Internal_Entity_Type_Decl;
Var_Expr : Internal_Entity_Type_Decl;
Origin_1 : Internal_Entity;
Fld_1 : Lexical_Env := Empty_Env;
Cast_Result : Internal_Entity;
Dyn_Var_Bind_Result : Lexical_Env := Empty_Env;
Scope_Result : Lexical_Env := Empty_Env;
Scope_Result_1 : Lexical_Env := Empty_Env;
Result_Var : Lexical_Env := Empty_Env;

            procedure Finalizer_Scope_122 is
            begin
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (Result_Var);
            end Finalizer_Scope_122;
            procedure Finalizer_Scope_556 is
            begin
                     Dec_Ref (Scope_Result);
            end Finalizer_Scope_556;
            procedure Finalizer_Scope_557 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_557;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 679 .do Result_Var nodes.lkt:1180



--# expr-start 676 Decl.get_type Fld nodes.lkt:1180







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.get_type
Fld := Liblktlang.Implementation.Decl_P_Get_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 676
Var_Expr := Fld;





if Var_Expr /= No_Entity_Type_Decl then
   



   --# scope-start







   --# scope-start



--# expr-start 678 bind Dyn_Var_Bind_Result nodes.lkt:1182









   
      Cast_Result := Create_Internal_Entity
        (Node => Var_Expr.Node,
         Info => Var_Expr.Info);


Origin_1 := Cast_Result; 
--# expr-start 677 Decl.defined_scope Fld_1 nodes.lkt:1184







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_1 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Var_Expr.Node, Origin => Origin_1, E_Info => Var_Expr.Info);
--# end
--# expr-done 677
Dyn_Var_Bind_Result := Fld_1; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 678
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_557;


Scope_Result_1 := Scope_Result;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_556;


   Result_Var := Scope_Result_1;
else
   
   Result_Var := Empty_Env;
end if;

      Inc_Ref (Result_Var);


--# expr-done 679

         Property_Result := Result_Var;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_122;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_122;
                     Finalizer_Scope_556;
                     Finalizer_Scope_557;




            raise;
      end;



   return Property_Result;
end Base_Val_Decl_P_Defined_Scope;
--# end



   


      

   --
   --  Primitives for Bare_Node_Decl
   --

   





   







--# property-start NodeDecl.name nodes.lkt:1197
pragma Warnings (Off, "is not referenced");

function Node_Decl_P_Name
  
  (Node : Bare_Node_Decl
  )

   return Symbol_Type
is
   Self : Bare_Node_Decl :=
     Bare_Node_Decl (Node);
      --# bind node Self

   


   Property_Result : Symbol_Type;

      

      Sym : Symbol_Type;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 680 SymbolLiteral Sym nodes.lkt:1197
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Node_49); 
--# expr-done 680

         Property_Result := Sym;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Node_Decl_P_Name;
--# end

   







--# property-start NodeDecl.decl_type_name nodes.lkt:1199
pragma Warnings (Off, "is not referenced");

function Node_Decl_P_Decl_Type_Name
  
  (Node : Bare_Node_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Node_Decl :=
     Bare_Node_Decl (Node);
     Ent : Internal_Entity_Node_Decl :=
       Internal_Entity_Node_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_124 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_124 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_124;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 681 StringLiteral Str nodes.lkt:1199
Str := Create_String ("node declaration"); 
--# expr-done 681

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_124;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_124;




            raise;
      end;



   return Property_Result;
end Node_Decl_P_Decl_Type_Name;
--# end

   







--# property-start NodeDecl.owning_type nodes.lkt:1201
pragma Warnings (Off, "is not referenced");

function Node_Decl_P_Owning_Type
  
  (Node : Bare_Node_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Node_Decl :=
     Bare_Node_Decl (Node);
     Ent : Internal_Entity_Node_Decl :=
       Internal_Entity_Node_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_125 with Inline_Always;

      Fld : Internal_Entity_Array_Access;
Is_A : Boolean;
Find_Result : Internal_Entity;
Cast_Result : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_125 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_125;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 685 Cast Cast_Result nodes.lkt:1202





--# expr-start 684 .find Find_Result nodes.lkt:1202








   

   --# expr-start 682 LktNode.parents Fld nodes.lkt:1202







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



Fld := Liblktlang.Implementation.Parents (Node => Ent.Node, With_Self => True, E_Info => Ent.Info);
--# expr-done 682

   
      Find_Result := No_Entity;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind t Item

            
      --# expr-start 683 IsA Is_A nodes.lkt:1202

Is_A := Item.Node /= null 
and then Item.Node.Kind in Lkt_Type_Decl; 
--# expr-done 683
      if Is_A then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Is_A;

         end loop;
      end;
   

   
   



--# expr-done 684



   if Find_Result.Node = null
      or else Find_Result.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => Find_Result.Node,
         Info => Find_Result.Info);

   else
         Cast_Result := No_Entity_Type_Decl;
   end if;


--# expr-done 685

         Property_Result := Cast_Result;
         
   --# end
      Finalizer_Scope_125;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_125;




            raise;
      end;



   return Property_Result;
end Node_Decl_P_Owning_Type;
--# end



   


      

   --
   --  Primitives for Bare_Self_Decl
   --

   





   







--# property-start SelfDecl.name nodes.lkt:1213
pragma Warnings (Off, "is not referenced");

function Self_Decl_P_Name
  
  (Node : Bare_Self_Decl
  )

   return Symbol_Type
is
   Self : Bare_Self_Decl :=
     Bare_Self_Decl (Node);
      --# bind node Self

   


   Property_Result : Symbol_Type;

      

      Sym : Symbol_Type;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 686 SymbolLiteral Sym nodes.lkt:1213
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Self); 
--# expr-done 686

         Property_Result := Sym;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Self_Decl_P_Name;
--# end

   







--# property-start SelfDecl.decl_type_name nodes.lkt:1215
pragma Warnings (Off, "is not referenced");

function Self_Decl_P_Decl_Type_Name
  
  (Node : Bare_Self_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Self_Decl :=
     Bare_Self_Decl (Node);
     Ent : Internal_Entity_Self_Decl :=
       Internal_Entity_Self_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_127 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_127 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_127;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 687 StringLiteral Str nodes.lkt:1215
Str := Create_String ("self declaration"); 
--# expr-done 687

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_127;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_127;




            raise;
      end;



   return Property_Result;
end Self_Decl_P_Decl_Type_Name;
--# end

   







--# property-start SelfDecl.owning_type nodes.lkt:1217
pragma Warnings (Off, "is not referenced");

function Self_Decl_P_Owning_Type
  
  (Node : Bare_Self_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Self_Decl :=
     Bare_Self_Decl (Node);
     Ent : Internal_Entity_Self_Decl :=
       Internal_Entity_Self_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_128 with Inline_Always;

      Fld : Internal_Entity_Array_Access;
Is_A : Boolean;
Find_Result : Internal_Entity;
Cast_Result : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_128 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_128;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 691 Cast Cast_Result nodes.lkt:1218





--# expr-start 690 .find Find_Result nodes.lkt:1218








   

   --# expr-start 688 LktNode.parents Fld nodes.lkt:1218







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



Fld := Liblktlang.Implementation.Parents (Node => Ent.Node, With_Self => True, E_Info => Ent.Info);
--# expr-done 688

   
      Find_Result := No_Entity;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind t Item

            
      --# expr-start 689 IsA Is_A nodes.lkt:1218

Is_A := Item.Node /= null 
and then Item.Node.Kind in Lkt_Type_Decl; 
--# expr-done 689
      if Is_A then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Is_A;

         end loop;
      end;
   

   
   



--# expr-done 690



   if Find_Result.Node = null
      or else Find_Result.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => Find_Result.Node,
         Info => Find_Result.Info);

   else
         Cast_Result := No_Entity_Type_Decl;
   end if;


--# expr-done 691

         Property_Result := Cast_Result;
         
   --# end
      Finalizer_Scope_128;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_128;




            raise;
      end;



   return Property_Result;
end Self_Decl_P_Owning_Type;
--# end



   


      

   --
   --  Primitives for Bare_User_Val_Decl
   --

   





   







--# property-start UserValDecl.xref_entry_point nodes.lkt:1224
pragma Warnings (Off, "is not referenced");

function User_Val_Decl_P_Xref_Entry_Point
  
  (Node : Bare_User_Val_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_User_Val_Decl :=
     Bare_User_Val_Decl (Node);
     Ent : Internal_Entity_User_Val_Decl :=
       Internal_Entity_User_Val_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := True;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end User_Val_Decl_P_Xref_Entry_Point;
--# end



   


      

   --
   --  Primitives for Bare_Binding_Val_Decl
   --

   



      
      procedure Initialize_Fields_For_Binding_Val_Decl
        (Self : Bare_Binding_Val_Decl
         ; Binding_Val_Decl_F_Syn_Name : Bare_Def_Id
        ) is
      begin

            Self.Binding_Val_Decl_F_Syn_Name := Binding_Val_Decl_F_Syn_Name;
         

      end Initialize_Fields_For_Binding_Val_Decl;


   







--# property-start BindingValDecl.decl_type_name nodes.lkt:1394
pragma Warnings (Off, "is not referenced");

function Binding_Val_Decl_P_Decl_Type_Name
  
  (Node : Bare_Binding_Val_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Binding_Val_Decl :=
     Bare_Binding_Val_Decl (Node);
     Ent : Internal_Entity_Binding_Val_Decl :=
       Internal_Entity_Binding_Val_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_143 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_143 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_143;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 692 StringLiteral Str nodes.lkt:1394
Str := Create_String ("pattern bound value declaration"); 
--# expr-done 692

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_143;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_143;




            raise;
      end;



   return Property_Result;
end Binding_Val_Decl_P_Decl_Type_Name;
--# end

   







--# property-start BindingValDecl.xref_entry_point nodes.lkt:1396
pragma Warnings (Off, "is not referenced");

function Binding_Val_Decl_P_Xref_Entry_Point
  
  (Node : Bare_Binding_Val_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Binding_Val_Decl :=
     Bare_Binding_Val_Decl (Node);
     Ent : Internal_Entity_Binding_Val_Decl :=
       Internal_Entity_Binding_Val_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := False;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Binding_Val_Decl_P_Xref_Entry_Point;
--# end



   


      

   --
   --  Primitives for Bare_Enum_Lit_Decl
   --

   



      
      procedure Initialize_Fields_For_Enum_Lit_Decl
        (Self : Bare_Enum_Lit_Decl
         ; Enum_Lit_Decl_F_Syn_Name : Bare_Def_Id
        ) is
      begin

            Self.Enum_Lit_Decl_F_Syn_Name := Enum_Lit_Decl_F_Syn_Name;
         

      end Initialize_Fields_For_Enum_Lit_Decl;


   







--# property-start EnumLitDecl.decl_type_name nodes.lkt:1232
pragma Warnings (Off, "is not referenced");

function Enum_Lit_Decl_P_Decl_Type_Name
  
  (Node : Bare_Enum_Lit_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Enum_Lit_Decl :=
     Bare_Enum_Lit_Decl (Node);
     Ent : Internal_Entity_Enum_Lit_Decl :=
       Internal_Entity_Enum_Lit_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_130 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_130 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_130;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 693 StringLiteral Str nodes.lkt:1232
Str := Create_String ("enum literal declaration"); 
--# expr-done 693

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_130;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_130;




            raise;
      end;



   return Property_Result;
end Enum_Lit_Decl_P_Decl_Type_Name;
--# end

   







--# property-start EnumLitDecl.xref_entry_point nodes.lkt:1234
pragma Warnings (Off, "is not referenced");

function Enum_Lit_Decl_P_Xref_Entry_Point
  
  (Node : Bare_Enum_Lit_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Enum_Lit_Decl :=
     Bare_Enum_Lit_Decl (Node);
     Ent : Internal_Entity_Enum_Lit_Decl :=
       Internal_Entity_Enum_Lit_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := False;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Enum_Lit_Decl_P_Xref_Entry_Point;
--# end

   







--# property-start EnumLitDecl.defined_scope nodes.lkt:1237
pragma Warnings (Off, "is not referenced");

function Enum_Lit_Decl_P_Defined_Scope
  
  (Node : Bare_Enum_Lit_Decl
      ; Origin : Internal_Entity
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Lexical_Env
is
   Self : Bare_Enum_Lit_Decl :=
     Bare_Enum_Lit_Decl (Node);
     Ent : Internal_Entity_Enum_Lit_Decl :=
       Internal_Entity_Enum_Lit_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind origin Origin

   Property_Result : Lexical_Env;

      
            procedure Finalizer_Scope_132 with Inline_Always;

      Fld : Internal_Entity_Type_Decl;
Fld_1 : Internal_Entity_Type_Decl;
Fld_2 : Lexical_Env := Empty_Env;

            procedure Finalizer_Scope_132 is
            begin
                     Dec_Ref (Fld_2);
            end Finalizer_Scope_132;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 696 Decl.defined_scope Fld_2 nodes.lkt:1238



--# expr-start 695 TypeDecl.basic_trait_from_self Fld_1 nodes.lkt:1238



--# expr-start 694 EnumLitDecl.parent_type Fld nodes.lkt:1238







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start EnumLitDecl.parent_type
Fld := Liblktlang.Implementation.Enum_Lit_Decl_P_Parent_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 694



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.basic_trait_from_self
Fld_1 := Liblktlang.Implementation.Type_Decl_P_Basic_Trait_From_Self (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 695



   if Fld_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_2 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Fld_1.Node, Origin => Origin, E_Info => Fld_1.Info);
--# end
--# expr-done 696

         Property_Result := Fld_2;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_132;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_132;




            raise;
      end;



   return Property_Result;
end Enum_Lit_Decl_P_Defined_Scope;
--# end

   







--# property-start EnumLitDecl.parent_type nodes.lkt:1241
pragma Warnings (Off, "is not referenced");

function Enum_Lit_Decl_P_Parent_Type
  
  (Node : Bare_Enum_Lit_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Enum_Lit_Decl :=
     Bare_Enum_Lit_Decl (Node);
     Ent : Internal_Entity_Enum_Lit_Decl :=
       Internal_Entity_Enum_Lit_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;

      

      Fld : Internal_Entity;
Fld_1 : Internal_Entity;
Cast_Result : Internal_Entity_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 699 Cast Cast_Result nodes.lkt:1241





--# expr-start 698 .parent Fld_1 nodes.lkt:1241



--# expr-start 697 .parent Fld nodes.lkt:1241







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Parent (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 697



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Liblktlang.Implementation.Parent (Node => Fld.Node, E_Info => Fld.Info);
--# expr-done 698



   if Fld_1.Node = null
      or else Fld_1.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => Fld_1.Node,
         Info => Fld_1.Info);

   else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "invalid object cast");
   end if;


--# expr-done 699

         Property_Result := Cast_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Enum_Lit_Decl_P_Parent_Type;
--# end



   


      

   --
   --  Primitives for Bare_Explicitly_Typed_Decl
   --

   




      
   function Explicitly_Typed_Decl_F_Decl_Type
     (Node : Bare_Explicitly_Typed_Decl) return Bare_Type_Ref
   is
      

         Kind : constant Lkt_Explicitly_Typed_Decl := Node.Kind;
   begin
         case Kind is
               when Lkt_Field_Decl =>
                     
         return Node.Field_Decl_F_Decl_Type;
      
               when Lkt_Fun_Param_Decl =>
                     
         return Node.Fun_Param_Decl_F_Decl_Type;
      
               when Lkt_Lambda_Param_Decl =>
                     
         return Node.Lambda_Param_Decl_F_Decl_Type;
      
               when Lkt_Dyn_Var_Decl =>
                     
         return Node.Dyn_Var_Decl_F_Decl_Type;
      
               when Lkt_Match_Val_Decl =>
                     
         return Node.Match_Val_Decl_F_Decl_Type;
      
               when Lkt_Val_Decl =>
                     
         return Node.Val_Decl_F_Decl_Type;
      
         end case;
   end;




   


      

   --
   --  Primitives for Bare_Component_Decl
   --

   




      
   function Component_Decl_F_Default_Val
     (Node : Bare_Component_Decl) return Bare_Expr
   is
      

         Kind : constant Lkt_Component_Decl := Node.Kind;
   begin
         case Kind is
               when Lkt_Field_Decl =>
                     
         return Node.Field_Decl_F_Default_Val;
      
               when Lkt_Fun_Param_Decl =>
                     
         return Node.Fun_Param_Decl_F_Default_Val;
      
               when Lkt_Lambda_Param_Decl =>
                     
         return Node.Lambda_Param_Decl_F_Default_Val;
      
         end case;
   end;


   







--# property-start ComponentDecl.xref_equation nodes.lkt:1270
pragma Warnings (Off, "is not referenced");

function Component_Decl_P_Xref_Equation
  
  (Node : Bare_Component_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Component_Decl :=
     Bare_Component_Decl (Node);
     Ent : Internal_Entity_Component_Decl :=
       Internal_Entity_Component_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_134 with Inline_Always;
            procedure Finalizer_Scope_560 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Internal_Entity_Expr;
Fld_3 : Logic_Var;
Fld_4 : Internal_Entity_Type_Ref;
Var_Expr : Internal_Entity_Type_Ref;
Fld_5 : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
And_Pred : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_6 : Bare_Expr;
Fld_7 : Internal_Entity_Expr;
Fld_8 : Logic_Var;
Fld_9 : Internal_Entity_Expr;
Fld_10 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;
Fld_11 : Internal_Entity_Expr;
Is_Null : Boolean;
True_Rel : Logic_Equation;
If_Result : Logic_Equation;

            procedure Finalizer_Scope_134 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (True_Rel);
                     Dec_Ref (If_Result);
            end Finalizer_Scope_134;
            procedure Finalizer_Scope_560 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_560;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 719 If If_Result nodes.lkt:1271



--# expr-start 701 .is_null Is_Null nodes.lkt:1271
--# expr-start 700 ComponentDecl.default_val Fld_11 nodes.lkt:1271







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Create_Internal_Entity_Expr (Node => Implementation.Component_Decl_F_Default_Val (Ent.Node), Info => Ent.Info);
--# expr-done 700
Is_Null := Fld_11.Node = null; 
--# expr-done 701
if Is_Null then
   --# expr-start 702 LogicTrue True_Rel nodes.lkt:1271
True_Rel := Solver.Create_True ((if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1271:42") else null)); 
--# expr-done 702
   If_Result := True_Rel;
else
   --# expr-start 718 LogicAnd And_Pred_1 nodes.lkt:1273
--# expr-start 710 LogicAnd And_Pred nodes.lkt:1274
--# expr-start 704 LktNode.xref_equation Fld_1 nodes.lkt:1274



--# expr-start 703 ComponentDecl.default_val Fld nodes.lkt:1274







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Implementation.Component_Decl_F_Default_Val (Ent.Node), Info => Ent.Info);
--# expr-done 703



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 704
--# expr-start 709 LogicAssign Bind_Result nodes.lkt:1275
--# expr-start 706 Expr.expected_type_var Fld_3 nodes.lkt:1275



--# expr-start 705 ComponentDecl.default_val Fld_2 nodes.lkt:1275







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Implementation.Component_Decl_F_Default_Val (Ent.Node), Info => Ent.Info);
--# expr-done 705



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Fld_2.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 706
Fld_3.Value := No_Entity;
Entity_Vars.Reset (Fld_3);








--# expr-start 707 ExplicitlyTypedDecl.decl_type Fld_4 nodes.lkt:1276







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Type_Ref (Node => Implementation.Explicitly_Typed_Decl_F_Decl_Type (Ent.Node), Info => Ent.Info);
--# expr-done 707
Var_Expr := Fld_4;





if Var_Expr /= No_Entity_Type_Ref then
   --# expr-start 708 TypeRef.referenced_decl Fld_5 nodes.lkt:1276







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_5 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 708
   Result_Var := Fld_5;
else
   
   Result_Var := No_Entity_Type_Decl;
end if;






   
      Cast_Result := Create_Internal_Entity
        (Node => Result_Var.Node,
         Info => Result_Var.Info);


Bind_Result := Solver.Create_Assign (Fld_3, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1275:22") else null)); 
--# expr-done 709
And_Pred := Create_And (Fld_1, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1274:17") else null)); 
--# expr-done 710




   --# scope-start



--# expr-start 717 bind Dyn_Var_Bind_Result nodes.lkt:1279





--# expr-start 711 ComponentDecl.default_val Fld_6 nodes.lkt:1279







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Implementation.Component_Decl_F_Default_Val (Self);
--# expr-done 711



   
      Cast_Result_1 := Fld_6;


Error_Location := Cast_Result_1; 
--# expr-start 716 LogicPropagate Pred nodes.lkt:1280
--# expr-start 713 Expr.expected_type_var Fld_8 nodes.lkt:1281



--# expr-start 712 ComponentDecl.default_val Fld_7 nodes.lkt:1281







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Create_Internal_Entity_Expr (Node => Implementation.Component_Decl_F_Default_Val (Ent.Node), Info => Ent.Info);
--# expr-done 712



   if Fld_7.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Fld_7.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 713
Fld_8.Value := No_Entity;
Entity_Vars.Reset (Fld_8);
--# expr-start 715 Expr.actual_type_var Fld_10 nodes.lkt:1282



--# expr-start 714 ComponentDecl.default_val Fld_9 nodes.lkt:1282







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Create_Internal_Entity_Expr (Node => Implementation.Component_Decl_F_Default_Val (Ent.Node), Info => Ent.Info);
--# expr-done 714



   if Fld_9.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Fld_9.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 715
Fld_10.Value := No_Entity;
Entity_Vars.Reset (Fld_10);


Pred := Solver.Create_N_Predicate ((Fld_8, Fld_10), Create_Type_Decl_P_Matching_Type_0_Predicate (2, Error_Location)); 
--# expr-done 716
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 717
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_560;


And_Pred_1 := Create_And (And_Pred, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1273:13") else null)); 
--# expr-done 718
   If_Result := And_Pred_1;
end if;

      Inc_Ref (If_Result);


--# expr-done 719

         Property_Result := If_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_134;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_134;
                     Finalizer_Scope_560;




            raise;
      end;



   return Property_Result;
end Component_Decl_P_Xref_Equation;
--# end

   







--# property-start ComponentDecl.to_generic_param nodes.lkt:1287
pragma Warnings (Off, "is not referenced");

function Component_Decl_P_To_Generic_Param
  
  (Node : Bare_Component_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Resolved_Param
is
   Self : Bare_Component_Decl :=
     Bare_Component_Decl (Node);
     Ent : Internal_Entity_Component_Decl :=
       Internal_Entity_Component_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Resolved_Param;

      

      Fld : Internal_Entity_Def_Id;
Fld_1 : Bare_Def_Id;
Sym : Symbol_Type;
Fld_2 : Internal_Entity_Type_Ref;
Fld_3 : Internal_Entity_Type_Decl;
Fld_4 : Internal_Entity_Expr;
Is_Null : Boolean;
Not_Val : Boolean;
Fld_5 : Internal_Entity_Full_Decl;
Var_Expr : Internal_Entity_Full_Decl;
Sym_1 : Symbol_Type;
Fld_6 : Boolean;
Result_Var : Boolean;
If_Result : Boolean;
Cast_Result : Internal_Entity_Decl;
New_Struct : Internal_Resolved_Param;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 731 'New[ResolvedParam]' New_Struct nodes.lkt:1288










   
      Cast_Result := Create_Internal_Entity_Decl
        (Node => Ent.Node,
         Info => Ent.Info);


--# expr-start 726 BooleanOr If_Result nodes.lkt:1291



--# expr-start 722 Not Not_Val nodes.lkt:1291
--# expr-start 721 .is_null Is_Null nodes.lkt:1291
--# expr-start 720 ComponentDecl.default_val Fld_4 nodes.lkt:1291







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Expr (Node => Implementation.Component_Decl_F_Default_Val (Ent.Node), Info => Ent.Info);
--# expr-done 720
Is_Null := Fld_4.Node = null; 
--# expr-done 721
Not_Val := not (Is_Null); 
--# expr-done 722
if Not_Val then
   
   If_Result := True;
else
   


--# expr-start 723 Decl.full_decl Fld_5 nodes.lkt:1292







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.full_decl
Fld_5 := Liblktlang.Implementation.Decl_P_Full_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 723
Var_Expr := Fld_5;





if Var_Expr /= No_Entity_Full_Decl then
   --# expr-start 725 FullDecl.has_annotation Fld_6 nodes.lkt:1292







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 724 SymbolLiteral Sym_1 nodes.lkt:1292
Sym_1 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Nullable); 
--# expr-done 724
--# property-call-start FullDecl.has_annotation
Fld_6 := Liblktlang.Implementation.Full_Decl_P_Has_Annotation (Node => Var_Expr.Node, Name => Sym_1);
--# end
--# expr-done 725
   Result_Var := Fld_6;
else
   
   Result_Var := False;
end if;



   If_Result := Result_Var;
end if;



--# expr-done 726
--# expr-start 728 .symbol Sym nodes.lkt:1289



--# expr-start 727 Decl.syn_name Fld nodes.lkt:1289







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Def_Id (Node => Implementation.Decl_F_Syn_Name (Ent.Node), Info => Ent.Info);
--# expr-done 727





Fld_1 := Fld.Node; 
Sym := Get_Symbol (Fld_1); 
--# expr-done 728
--# expr-start 730 TypeRef.referenced_decl Fld_3 nodes.lkt:1290



--# expr-start 729 ExplicitlyTypedDecl.decl_type Fld_2 nodes.lkt:1290







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Type_Ref (Node => Implementation.Explicitly_Typed_Decl_F_Decl_Type (Ent.Node), Info => Ent.Info);
--# expr-done 729



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_3 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Fld_2.Node, E_Info => Fld_2.Info);
--# end
--# expr-done 730
New_Struct := (Accept_Logical_Var => False, Decl => Cast_Result, Has_Default_Value => If_Result, Name => Sym, Param_Type => Fld_3); 
--# expr-done 731

         Property_Result := New_Struct;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Component_Decl_P_To_Generic_Param;
--# end



   


      

   --
   --  Primitives for Bare_Field_Decl
   --

   



   

   

   

   

   

   

   


      procedure Field_Decl_Pre_Env_Actions
        (Self            : Bare_Field_Decl;
         State           : in out PLE_Node_State;
         Add_To_Env_Only : Boolean := False) is
      begin
            


   

      declare
         Resolver : constant Entity_Resolver :=
            null;

         

         Mapping : Internal_Env_Assoc :=
            Liblktlang.Implementation.Internal_Env_Mappings_2 (Node => 
Self);
      begin

         Add_To_Env
           (Self,
            State,
            Mapping.Key,
            Mapping.Value,
            Mapping.Metadata,
            Resolver,
            Mapping.Dest_Env,
            DSL_Location => "nodes.lkt:1325:9");
         Dec_Ref (Mapping.Dest_Env);

      end;
   
   
            


   
      if Add_To_Env_Only then
         return;
      end if;

      declare
         No_Parent         : constant Boolean :=
            False;
         Transitive_Parent : constant Boolean :=
            False;
         Names             : Symbol_Type_Array_Access :=
            null;
      begin
         Add_Env (Self, State, No_Parent, Transitive_Parent, Names);
      end;
   
   
            


   

      declare
         Resolver : constant Entity_Resolver :=
            null;

         

         Mappings : Internal_Env_Assoc_Array_Access :=
            Liblktlang.Implementation.Internal_Env_Mappings_3 (Node => 
Self);
      begin
         for Mapping of Mappings.Items loop

         Add_To_Env
           (Self,
            State,
            Mapping.Key,
            Mapping.Value,
            Mapping.Metadata,
            Resolver,
            Mapping.Dest_Env,
            DSL_Location => "nodes.lkt:1327:9");

         end loop;
         Dec_Ref (Mappings);
      end;
   
   
      end;



      
      procedure Initialize_Fields_For_Field_Decl
        (Self : Bare_Field_Decl
         ; Field_Decl_F_Syn_Name : Bare_Def_Id
         ; Field_Decl_F_Decl_Type : Bare_Type_Ref
         ; Field_Decl_F_Trait_Ref : Bare_Dot_Expr
         ; Field_Decl_F_Default_Val : Bare_Expr
        ) is
      begin

            Self.Field_Decl_F_Syn_Name := Field_Decl_F_Syn_Name;
            Self.Field_Decl_F_Decl_Type := Field_Decl_F_Decl_Type;
            Self.Field_Decl_F_Trait_Ref := Field_Decl_F_Trait_Ref;
            Self.Field_Decl_F_Default_Val := Field_Decl_F_Default_Val;
         

      end Initialize_Fields_For_Field_Decl;

      
   function Field_Decl_F_Trait_Ref
     (Node : Bare_Field_Decl) return Bare_Dot_Expr
   is
      

   begin
         
         return Node.Field_Decl_F_Trait_Ref;
      
   end;


   







--# property-start FieldDecl.decl_type_name nodes.lkt:1309
pragma Warnings (Off, "is not referenced");

function Field_Decl_P_Decl_Type_Name
  
  (Node : Bare_Field_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Field_Decl :=
     Bare_Field_Decl (Node);
     Ent : Internal_Entity_Field_Decl :=
       Internal_Entity_Field_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_136 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_136 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_136;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 732 StringLiteral Str nodes.lkt:1309
Str := Create_String ("field declaration"); 
--# expr-done 732

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_136;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_136;




            raise;
      end;



   return Property_Result;
end Field_Decl_P_Decl_Type_Name;
--# end

   







--# property-start FieldDecl.owning_type nodes.lkt:1311
pragma Warnings (Off, "is not referenced");

function Field_Decl_P_Owning_Type
  
  (Node : Bare_Field_Decl
  )

   return Bare_Type_Decl
is
   Self : Bare_Field_Decl :=
     Bare_Field_Decl (Node);
      --# bind node Self

   


   Property_Result : Bare_Type_Decl;

      
            procedure Finalizer_Scope_137 with Inline_Always;

      Node_Parents : Bare_Lkt_Node_Array_Access;
Is_A : Boolean;
Find_Result : Bare_Lkt_Node;
Cast_Result : Bare_Type_Decl;

            procedure Finalizer_Scope_137 is
            begin
                     Dec_Ref (Node_Parents);
            end Finalizer_Scope_137;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 736 Cast Cast_Result nodes.lkt:1312





--# expr-start 735 .find Find_Result nodes.lkt:1312








   

   --# expr-start 733 LktNode.parents Node_Parents nodes.lkt:1312







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



Node_Parents := Parents (Self, True); 
--# expr-done 733

   
      Find_Result := No_Bare_Lkt_Node;
   

   

      

      declare
         
         Collection : constant Bare_Lkt_Node_Array_Access := Node_Parents;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind t Item

            
      --# expr-start 734 IsA Is_A nodes.lkt:1312

Is_A := Item /= null 
and then Item.Kind in Lkt_Type_Decl; 
--# expr-done 734
      if Is_A then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Is_A;

         end loop;
      end;
   

   
   



--# expr-done 735



   if Find_Result = null
      or else Find_Result.Kind in Lkt_Type_Decl
   then
      
      Cast_Result := Find_Result;

   else
         Cast_Result := No_Bare_Lkt_Node;
   end if;


--# expr-done 736

         Property_Result := Cast_Result;
         
   --# end
      Finalizer_Scope_137;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_137;




            raise;
      end;



   return Property_Result;
end Field_Decl_P_Owning_Type;
--# end

   







--# property-start FieldDecl.lazy_field_function_type nodes.lkt:1317
pragma Warnings (Off, "is not referenced");

function Field_Decl_P_Lazy_Field_Function_Type
  
  (Node : Bare_Field_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Function_Type
is
   Self : Bare_Field_Decl :=
     Bare_Field_Decl (Node);
     Ent : Internal_Entity_Field_Decl :=
       Internal_Entity_Field_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Function_Type;

      

      Fld : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity_Decl;
Fld_1 : Internal_Entity_Function_Type;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 738 LktNode.function_type_helper Fld_1 nodes.lkt:1318







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# expr-start 737 Decl.get_type Fld nodes.lkt:1320







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.get_type
Fld := Liblktlang.Implementation.Decl_P_Get_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 737









   
      Cast_Result := Create_Internal_Entity_Decl
        (Node => Ent.Node,
         Info => Ent.Info);


--# property-call-start LktNode.function_type_helper
Fld_1 := Liblktlang.Implementation.Lkt_Node_P_Function_Type_Helper (Node => Ent.Node, Param_Types => No_Internal_Entity_Type_Decl_Array_Type, Return_Type => Fld, Origin => Cast_Result, E_Info => Ent.Info);
--# end
--# expr-done 738

         Property_Result := Fld_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Field_Decl_P_Lazy_Field_Function_Type;
--# end

   







--# property-start 'FieldDecl.[internal]internal_env_mappings_2' nodes.lkt:1325
pragma Warnings (Off, "is not referenced");

function Internal_Env_Mappings_2
  
  (Node : Bare_Field_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Env_Assoc
is
   Self : Bare_Field_Decl :=
     Bare_Field_Decl (Node);
     Ent : Internal_Entity_Field_Decl :=
       Internal_Entity_Field_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Env_Assoc;

      
            procedure Finalizer_Scope_419 with Inline_Always;

      Fld : Symbol_Type;
Cast_Result : Bare_Lkt_Node;
New_Struct : Internal_Designated_Env := No_Designated_Env;
New_Struct_1 : Internal_Env_Assoc := No_Env_Assoc;

            procedure Finalizer_Scope_419 is
            begin
                     Dec_Ref (New_Struct);
                     Dec_Ref (New_Struct_1);
            end Finalizer_Scope_419;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         


Inc_Ref (Empty_Env);
New_Struct := (Direct_Env => Empty_Env, Env_Name => No_Symbol, Kind => Current_Env); 
--# expr-start 739 Decl.name Fld nodes.lkt:1325







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Ent.Node);
--# end
--# expr-done 739










   
      Cast_Result := Self;


Inc_Ref (New_Struct);
New_Struct_1 := (Dest_Env => New_Struct, Key => Fld, Metadata => No_Metadata, Value => Cast_Result); 

         Property_Result := New_Struct_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_419;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_419;




            raise;
      end;



   return Property_Result;
end Internal_Env_Mappings_2;
--# end

   







--# property-start 'FieldDecl.[internal]internal_env_mappings_3' nodes.lkt:1328
pragma Warnings (Off, "is not referenced");

function Internal_Env_Mappings_3
  
  (Node : Bare_Field_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Env_Assoc_Array_Access
is
   Self : Bare_Field_Decl :=
     Bare_Field_Decl (Node);
     Ent : Internal_Entity_Field_Decl :=
       Internal_Entity_Field_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Env_Assoc_Array_Access;

      
            procedure Finalizer_Scope_420 with Inline_Always;
            procedure Finalizer_Scope_865 with Inline_Always;

      Fld : Internal_Entity_Full_Decl;
Sym : Symbol_Type;
Fld_1 : Boolean;
Fld_2 : Bare_Type_Decl;
Var_Expr : Bare_Type_Decl;
Sym_1 : Symbol_Type;
Fld_3 : Bare_Node_Decl;
New_Struct : Internal_Designated_Env := No_Designated_Env;
Cast_Result : Bare_Lkt_Node;
New_Struct_1 : Internal_Env_Assoc := No_Env_Assoc;
Array_Lit : Internal_Env_Assoc_Array_Access;
Scope_Result : Internal_Env_Assoc_Array_Access;
Result_Var : Internal_Env_Assoc_Array_Access;
If_Result : Internal_Env_Assoc_Array_Access;

            procedure Finalizer_Scope_420 is
            begin
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Result_Var);
                     Dec_Ref (If_Result);
            end Finalizer_Scope_420;
            procedure Finalizer_Scope_865 is
            begin
                     Dec_Ref (New_Struct);
                     Dec_Ref (New_Struct_1);
                     Dec_Ref (Array_Lit);
            end Finalizer_Scope_865;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 750 If If_Result nodes.lkt:1328



--# expr-start 742 FullDecl.has_annotation Fld_1 nodes.lkt:1328



--# expr-start 740 Decl.full_decl Fld nodes.lkt:1328







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.full_decl
Fld := Liblktlang.Implementation.Decl_P_Full_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 740



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 741 SymbolLiteral Sym nodes.lkt:1328
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Lazy); 
--# expr-done 741
--# property-call-start FullDecl.has_annotation
Fld_1 := Liblktlang.Implementation.Full_Decl_P_Has_Annotation (Node => Fld.Node, Name => Sym);
--# end
--# expr-done 742
if Fld_1 then
   --# expr-start 749 .do Result_Var nodes.lkt:1330



--# expr-start 743 FieldDecl.owning_type Fld_2 nodes.lkt:1330







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start FieldDecl.owning_type
Fld_2 := Liblktlang.Implementation.Field_Decl_P_Owning_Type (Node => Self);
--# end
--# expr-done 743
Var_Expr := Fld_2;





if Var_Expr /= No_Bare_Lkt_Node then
   



   --# scope-start



--# expr-start 748 ArrayLiteral Array_Lit nodes.lkt:1332
--# expr-start 747 'New[EnvAssoc]' New_Struct_1 nodes.lkt:1333
--# expr-start 744 'New[DesignatedEnv]' New_Struct nodes.lkt:1336



Inc_Ref (Empty_Env);
New_Struct := (Direct_Env => Empty_Env, Env_Name => No_Symbol, Kind => Current_Env); 
--# expr-done 744
--# expr-start 745 SymbolLiteral Sym_1 nodes.lkt:1334
Sym_1 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Node_49); 
--# expr-done 745






--# expr-start 746 TypeDecl.node_decl Fld_3 nodes.lkt:1335







   if Var_Expr = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.node_decl
Fld_3 := Liblktlang.Implementation.Type_Decl_P_Node_Decl (Node => Var_Expr);
--# end
--# expr-done 746



   
      Cast_Result := Fld_3;


Inc_Ref (New_Struct);
New_Struct_1 := (Dest_Env => New_Struct, Key => Sym_1, Metadata => No_Metadata, Value => Cast_Result); 
--# expr-done 747
Array_Lit := Create_Internal_Env_Assoc_Array (Internal_Internal_Env_Assoc_Array'(1 => New_Struct_1)); 
--# expr-done 748
Scope_Result := Array_Lit;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_865;


   Result_Var := Scope_Result;
else
   
   Result_Var := No_Internal_Env_Assoc_Array_Type;
end if;

      Inc_Ref (Result_Var);


--# expr-done 749
   If_Result := Result_Var;
else
   
   If_Result := No_Internal_Env_Assoc_Array_Type;
end if;

      Inc_Ref (If_Result);


--# expr-done 750

         Property_Result := If_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_420;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_420;
                     Finalizer_Scope_865;




            raise;
      end;



   return Property_Result;
end Internal_Env_Mappings_3;
--# end



   


      

   --
   --  Primitives for Bare_Fun_Param_Decl
   --

   



      
      procedure Initialize_Fields_For_Fun_Param_Decl
        (Self : Bare_Fun_Param_Decl
         ; Fun_Param_Decl_F_Decl_Annotations : Bare_Decl_Annotation_List
         ; Fun_Param_Decl_F_Syn_Name : Bare_Def_Id
         ; Fun_Param_Decl_F_Decl_Type : Bare_Type_Ref
         ; Fun_Param_Decl_F_Default_Val : Bare_Expr
        ) is
      begin

            Self.Fun_Param_Decl_F_Decl_Annotations := Fun_Param_Decl_F_Decl_Annotations;
            Self.Fun_Param_Decl_F_Syn_Name := Fun_Param_Decl_F_Syn_Name;
            Self.Fun_Param_Decl_F_Decl_Type := Fun_Param_Decl_F_Decl_Type;
            Self.Fun_Param_Decl_F_Default_Val := Fun_Param_Decl_F_Default_Val;
         

      end Initialize_Fields_For_Fun_Param_Decl;

      
   function Fun_Param_Decl_F_Decl_Annotations
     (Node : Bare_Fun_Param_Decl) return Bare_Decl_Annotation_List
   is
      

   begin
         
         return Node.Fun_Param_Decl_F_Decl_Annotations;
      
   end;


   







--# property-start FunParamDecl.decl_type_name nodes.lkt:1361
pragma Warnings (Off, "is not referenced");

function Fun_Param_Decl_P_Decl_Type_Name
  
  (Node : Bare_Fun_Param_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Fun_Param_Decl :=
     Bare_Fun_Param_Decl (Node);
     Ent : Internal_Entity_Fun_Param_Decl :=
       Internal_Entity_Fun_Param_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_139 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_139 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_139;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 751 StringLiteral Str nodes.lkt:1361
Str := Create_String ("function parameter declaration"); 
--# expr-done 751

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_139;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_139;




            raise;
      end;



   return Property_Result;
end Fun_Param_Decl_P_Decl_Type_Name;
--# end



   


      

   --
   --  Primitives for Bare_Lambda_Param_Decl
   --

   



      
      procedure Initialize_Fields_For_Lambda_Param_Decl
        (Self : Bare_Lambda_Param_Decl
         ; Lambda_Param_Decl_F_Syn_Name : Bare_Def_Id
         ; Lambda_Param_Decl_F_Decl_Type : Bare_Type_Ref
         ; Lambda_Param_Decl_F_Default_Val : Bare_Expr
        ) is
      begin

            Self.Lambda_Param_Decl_F_Syn_Name := Lambda_Param_Decl_F_Syn_Name;
            Self.Lambda_Param_Decl_F_Decl_Type := Lambda_Param_Decl_F_Decl_Type;
            Self.Lambda_Param_Decl_F_Default_Val := Lambda_Param_Decl_F_Default_Val;
         
      Self.Lambda_Param_Decl_F_Type_Var := Null_Var_Record;

      end Initialize_Fields_For_Lambda_Param_Decl;


   







--# property-start LambdaParamDecl.decl_type_name nodes.lkt:1374
pragma Warnings (Off, "is not referenced");

function Lambda_Param_Decl_P_Decl_Type_Name
  
  (Node : Bare_Lambda_Param_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Lambda_Param_Decl :=
     Bare_Lambda_Param_Decl (Node);
     Ent : Internal_Entity_Lambda_Param_Decl :=
       Internal_Entity_Lambda_Param_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_140 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_140 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_140;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 752 StringLiteral Str nodes.lkt:1374
Str := Create_String ("lambda function parameter declaration"); 
--# expr-done 752

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_140;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_140;




            raise;
      end;



   return Property_Result;
end Lambda_Param_Decl_P_Decl_Type_Name;
--# end



   


      

   --
   --  Primitives for Bare_Dyn_Var_Decl
   --

   



      
      procedure Initialize_Fields_For_Dyn_Var_Decl
        (Self : Bare_Dyn_Var_Decl
         ; Dyn_Var_Decl_F_Syn_Name : Bare_Def_Id
         ; Dyn_Var_Decl_F_Decl_Type : Bare_Type_Ref
        ) is
      begin

            Self.Dyn_Var_Decl_F_Syn_Name := Dyn_Var_Decl_F_Syn_Name;
            Self.Dyn_Var_Decl_F_Decl_Type := Dyn_Var_Decl_F_Decl_Type;
         

      end Initialize_Fields_For_Dyn_Var_Decl;


   







--# property-start DynVarDecl.decl_type_name nodes.lkt:1384
pragma Warnings (Off, "is not referenced");

function Dyn_Var_Decl_P_Decl_Type_Name
  
  (Node : Bare_Dyn_Var_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Dyn_Var_Decl :=
     Bare_Dyn_Var_Decl (Node);
     Ent : Internal_Entity_Dyn_Var_Decl :=
       Internal_Entity_Dyn_Var_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_141 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_141 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_141;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 753 StringLiteral Str nodes.lkt:1384
Str := Create_String ("dynamic variable declaration"); 
--# expr-done 753

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_141;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_141;




            raise;
      end;



   return Property_Result;
end Dyn_Var_Decl_P_Decl_Type_Name;
--# end

   







--# property-start DynVarDecl.xref_entry_point nodes.lkt:1386
pragma Warnings (Off, "is not referenced");

function Dyn_Var_Decl_P_Xref_Entry_Point
  
  (Node : Bare_Dyn_Var_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Dyn_Var_Decl :=
     Bare_Dyn_Var_Decl (Node);
     Ent : Internal_Entity_Dyn_Var_Decl :=
       Internal_Entity_Dyn_Var_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := False;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Dyn_Var_Decl_P_Xref_Entry_Point;
--# end



   


      

   --
   --  Primitives for Bare_Match_Val_Decl
   --

   



      
      procedure Initialize_Fields_For_Match_Val_Decl
        (Self : Bare_Match_Val_Decl
         ; Match_Val_Decl_F_Syn_Name : Bare_Def_Id
         ; Match_Val_Decl_F_Decl_Type : Bare_Type_Ref
        ) is
      begin

            Self.Match_Val_Decl_F_Syn_Name := Match_Val_Decl_F_Syn_Name;
            Self.Match_Val_Decl_F_Decl_Type := Match_Val_Decl_F_Decl_Type;
         

      end Initialize_Fields_For_Match_Val_Decl;


   







--# property-start MatchValDecl.decl_type_name nodes.lkt:1407
pragma Warnings (Off, "is not referenced");

function Match_Val_Decl_P_Decl_Type_Name
  
  (Node : Bare_Match_Val_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Match_Val_Decl :=
     Bare_Match_Val_Decl (Node);
     Ent : Internal_Entity_Match_Val_Decl :=
       Internal_Entity_Match_Val_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_145 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_145 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_145;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 754 StringLiteral Str nodes.lkt:1407
Str := Create_String ("match value declaration"); 
--# expr-done 754

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_145;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_145;




            raise;
      end;



   return Property_Result;
end Match_Val_Decl_P_Decl_Type_Name;
--# end

   







--# property-start MatchValDecl.xref_entry_point nodes.lkt:1409
pragma Warnings (Off, "is not referenced");

function Match_Val_Decl_P_Xref_Entry_Point
  
  (Node : Bare_Match_Val_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Match_Val_Decl :=
     Bare_Match_Val_Decl (Node);
     Ent : Internal_Entity_Match_Val_Decl :=
       Internal_Entity_Match_Val_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := False;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Match_Val_Decl_P_Xref_Entry_Point;
--# end

   







--# property-start MatchValDecl.match_expr nodes.lkt:1411
pragma Warnings (Off, "is not referenced");

function Match_Val_Decl_P_Match_Expr
  
  (Node : Bare_Match_Val_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Expr
is
   Self : Bare_Match_Val_Decl :=
     Bare_Match_Val_Decl (Node);
     Ent : Internal_Entity_Match_Val_Decl :=
       Internal_Entity_Match_Val_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Expr;

      
            procedure Finalizer_Scope_147 with Inline_Always;

      Fld : Internal_Entity_Array_Access;
Is_A : Boolean;
Find_Result : Internal_Entity;
Cast_Result : Internal_Entity_Match_Expr;
Fld_1 : Internal_Entity_Expr;

            procedure Finalizer_Scope_147 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_147;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 759 MatchExpr.match_expr Fld_1 nodes.lkt:1412



--# expr-start 758 Cast Cast_Result nodes.lkt:1412





--# expr-start 757 .find Find_Result nodes.lkt:1412








   

   --# expr-start 755 LktNode.parents Fld nodes.lkt:1412







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



Fld := Liblktlang.Implementation.Parents (Node => Ent.Node, With_Self => True, E_Info => Ent.Info);
--# expr-done 755

   
      Find_Result := No_Entity;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind p Item

            
      --# expr-start 756 IsA Is_A nodes.lkt:1412

Is_A := Item.Node /= null 
and then Item.Node.Kind in Lkt_Match_Expr_Range; 
--# expr-done 756
      if Is_A then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Is_A;

         end loop;
      end;
   

   
   



--# expr-done 757



   if Find_Result.Node = null
      or else Find_Result.Node.Kind in Lkt_Match_Expr_Range
   then
      
      Cast_Result := Create_Internal_Entity_Match_Expr
        (Node => Find_Result.Node,
         Info => Find_Result.Info);

   else
         Cast_Result := No_Entity_Match_Expr;
   end if;


--# expr-done 758



   if Cast_Result.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Expr (Node => Cast_Result.Node.Match_Expr_F_Match_Expr, Info => Cast_Result.Info);
--# expr-done 759

         Property_Result := Fld_1;
         
   --# end
      Finalizer_Scope_147;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_147;




            raise;
      end;



   return Property_Result;
end Match_Val_Decl_P_Match_Expr;
--# end



   


      

   --
   --  Primitives for Bare_Val_Decl
   --

   



      
      procedure Initialize_Fields_For_Val_Decl
        (Self : Bare_Val_Decl
         ; Val_Decl_F_Syn_Name : Bare_Def_Id
         ; Val_Decl_F_Decl_Type : Bare_Type_Ref
         ; Val_Decl_F_Expr : Bare_Expr
        ) is
      begin

            Self.Val_Decl_F_Syn_Name := Val_Decl_F_Syn_Name;
            Self.Val_Decl_F_Decl_Type := Val_Decl_F_Decl_Type;
            Self.Val_Decl_F_Expr := Val_Decl_F_Expr;
         

      end Initialize_Fields_For_Val_Decl;

      
   function Val_Decl_F_Expr
     (Node : Bare_Val_Decl) return Bare_Expr
   is
      

   begin
         
         return Node.Val_Decl_F_Expr;
      
   end;


   







--# property-start ValDecl.decl_type_name nodes.lkt:1424
pragma Warnings (Off, "is not referenced");

function Val_Decl_P_Decl_Type_Name
  
  (Node : Bare_Val_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Val_Decl :=
     Bare_Val_Decl (Node);
     Ent : Internal_Entity_Val_Decl :=
       Internal_Entity_Val_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_148 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_148 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_148;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 760 StringLiteral Str nodes.lkt:1424
Str := Create_String ("value declaration"); 
--# expr-done 760

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_148;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_148;




            raise;
      end;



   return Property_Result;
end Val_Decl_P_Decl_Type_Name;
--# end

   







--# property-start ValDecl.xref_equation nodes.lkt:1426
pragma Warnings (Off, "is not referenced");

function Val_Decl_P_Xref_Equation
  
  (Node : Bare_Val_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Val_Decl :=
     Bare_Val_Decl (Node);
     Ent : Internal_Entity_Val_Decl :=
       Internal_Entity_Val_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_149 with Inline_Always;
            procedure Finalizer_Scope_564 with Inline_Always;
            procedure Finalizer_Scope_565 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Internal_Entity_Expr;
Fld_3 : Logic_Var;
Fld_4 : Internal_Entity_Type_Ref;
Fld_5 : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
And_Pred : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_6 : Bare_Expr;
Fld_7 : Internal_Entity_Expr;
Fld_8 : Logic_Var;
Fld_9 : Internal_Entity_Expr;
Fld_10 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
Fld_11 : Internal_Entity_Type_Ref;
Fld_12 : Internal_Entity_Type_Decl;
Is_Null : Boolean;
False_Rel : Logic_Equation;
If_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;
Fld_13 : Internal_Entity_Type_Ref;
Is_Null_1 : Boolean;
Fld_14 : Internal_Entity_Expr;
Fld_15 : Logic_Equation;
Fld_16 : Internal_Entity_Expr;
Fld_17 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result_2 : Internal_Entity;
Bind_Result_1 : Logic_Equation;
And_Pred_2 : Logic_Equation;
If_Result_1 : Logic_Equation;
Error_Location_1 : Bare_Lkt_Node;
Fld_18 : Bare_Def_Id;
Fld_19 : Internal_Entity_Expr;
Fld_20 : Logic_Var;
Pred_1 : Logic_Equation;
Cast_Result_3 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_1 : Logic_Equation;
Scope_Result_1 : Logic_Equation;
And_Pred_3 : Logic_Equation;

            procedure Finalizer_Scope_149 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (False_Rel);
                     Dec_Ref (If_Result);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Fld_15);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (If_Result_1);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (And_Pred_3);
            end Finalizer_Scope_149;
            procedure Finalizer_Scope_564 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_564;
            procedure Finalizer_Scope_565 is
            begin
                     Dec_Ref (Pred_1);
                     Dec_Ref (Dyn_Var_Bind_Result_1);
            end Finalizer_Scope_565;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 796 LogicAnd And_Pred_3 nodes.lkt:1427
--# expr-start 790 If If_Result_1 nodes.lkt:1428



--# expr-start 762 .is_null Is_Null_1 nodes.lkt:1428
--# expr-start 761 ValDecl.decl_type Fld_13 nodes.lkt:1428







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_13 := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Val_Decl_F_Decl_Type, Info => Ent.Info);
--# expr-done 761
Is_Null_1 := Fld_13.Node = null; 
--# expr-done 762
if Is_Null_1 then
   --# expr-start 768 LogicAnd And_Pred_2 nodes.lkt:1430
--# expr-start 764 LktNode.xref_equation Fld_15 nodes.lkt:1430



--# expr-start 763 ValDecl.expr Fld_14 nodes.lkt:1430







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_14 := Create_Internal_Entity_Expr (Node => Ent.Node.Val_Decl_F_Expr, Info => Ent.Info);
--# expr-done 763



   if Fld_14.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_15 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld_14.Node, E_Info => Fld_14.Info);
--# end
--# expr-done 764
--# expr-start 767 LogicAssign Bind_Result_1 nodes.lkt:1431
--# expr-start 766 Expr.expected_type_var Fld_17 nodes.lkt:1431



--# expr-start 765 ValDecl.expr Fld_16 nodes.lkt:1431







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_16 := Create_Internal_Entity_Expr (Node => Ent.Node.Val_Decl_F_Expr, Info => Ent.Info);
--# expr-done 765



   if Fld_16.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_17 := Fld_16.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 766
Fld_17.Value := No_Entity;
Entity_Vars.Reset (Fld_17);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_17, Cast_Result_2, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1431:22") else null)); 
--# expr-done 767
And_Pred_2 := Create_And (Fld_15, Bind_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1430:17") else null)); 
--# expr-done 768
   If_Result_1 := And_Pred_2;
else
   --# expr-start 789 LogicAnd And_Pred_1 nodes.lkt:1433
--# expr-start 776 LogicAnd And_Pred nodes.lkt:1434
--# expr-start 770 LktNode.xref_equation Fld_1 nodes.lkt:1434



--# expr-start 769 ValDecl.expr Fld nodes.lkt:1434







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Val_Decl_F_Expr, Info => Ent.Info);
--# expr-done 769



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 770
--# expr-start 775 LogicAssign Bind_Result nodes.lkt:1435
--# expr-start 772 Expr.expected_type_var Fld_3 nodes.lkt:1435



--# expr-start 771 ValDecl.expr Fld_2 nodes.lkt:1435







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Ent.Node.Val_Decl_F_Expr, Info => Ent.Info);
--# expr-done 771



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Fld_2.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 772
Fld_3.Value := No_Entity;
Entity_Vars.Reset (Fld_3);





--# expr-start 774 TypeRef.referenced_decl Fld_5 nodes.lkt:1436



--# expr-start 773 ValDecl.decl_type Fld_4 nodes.lkt:1436







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Val_Decl_F_Decl_Type, Info => Ent.Info);
--# expr-done 773



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_5 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Fld_4.Node, E_Info => Fld_4.Info);
--# end
--# expr-done 774



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_5.Node,
         Info => Fld_5.Info);


Bind_Result := Solver.Create_Assign (Fld_3, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1435:26") else null)); 
--# expr-done 775
And_Pred := Create_And (Fld_1, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1434:21") else null)); 
--# expr-done 776
--# expr-start 788 If If_Result nodes.lkt:1439



--# expr-start 779 .is_null Is_Null nodes.lkt:1439
--# expr-start 778 TypeRef.referenced_decl Fld_12 nodes.lkt:1439



--# expr-start 777 ValDecl.decl_type Fld_11 nodes.lkt:1439







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Val_Decl_F_Decl_Type, Info => Ent.Info);
--# expr-done 777



   if Fld_11.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_12 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Fld_11.Node, E_Info => Fld_11.Info);
--# end
--# expr-done 778
Is_Null := Fld_12.Node = null; 
--# expr-done 779
if Is_Null then
   --# expr-start 780 LogicFalse False_Rel nodes.lkt:1439
False_Rel := Solver.Create_False ((if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1439:70") else null)); 
--# expr-done 780
   If_Result := False_Rel;
else
   



   --# scope-start



--# expr-start 787 bind Dyn_Var_Bind_Result nodes.lkt:1441





--# expr-start 781 ValDecl.expr Fld_6 nodes.lkt:1441







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Self.Val_Decl_F_Expr;
--# expr-done 781



   
      Cast_Result_1 := Fld_6;


Error_Location := Cast_Result_1; 
--# expr-start 786 LogicPropagate Pred nodes.lkt:1442
--# expr-start 783 Expr.expected_type_var Fld_8 nodes.lkt:1443



--# expr-start 782 ValDecl.expr Fld_7 nodes.lkt:1443







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Create_Internal_Entity_Expr (Node => Ent.Node.Val_Decl_F_Expr, Info => Ent.Info);
--# expr-done 782



   if Fld_7.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Fld_7.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 783
Fld_8.Value := No_Entity;
Entity_Vars.Reset (Fld_8);
--# expr-start 785 Expr.actual_type_var Fld_10 nodes.lkt:1444



--# expr-start 784 ValDecl.expr Fld_9 nodes.lkt:1444







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Create_Internal_Entity_Expr (Node => Ent.Node.Val_Decl_F_Expr, Info => Ent.Info);
--# expr-done 784



   if Fld_9.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Fld_9.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 785
Fld_10.Value := No_Entity;
Entity_Vars.Reset (Fld_10);


Pred := Solver.Create_N_Predicate ((Fld_8, Fld_10), Create_Type_Decl_P_Matching_Type_0_Predicate (2, Error_Location)); 
--# expr-done 786
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 787
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_564;


   If_Result := Scope_Result;
end if;

      Inc_Ref (If_Result);


--# expr-done 788
And_Pred_1 := Create_And (And_Pred, If_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1433:17") else null)); 
--# expr-done 789
   If_Result_1 := And_Pred_1;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 790




   --# scope-start



--# expr-start 795 bind Dyn_Var_Bind_Result_1 nodes.lkt:1450





--# expr-start 791 ValDecl.syn_name Fld_18 nodes.lkt:1450







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_18 := Self.Val_Decl_F_Syn_Name;
--# expr-done 791



   
      Cast_Result_3 := Fld_18;


Error_Location_1 := Cast_Result_3; 
--# expr-start 794 LogicPropagate Pred_1 nodes.lkt:1451
--# expr-start 793 Expr.actual_type_var Fld_20 nodes.lkt:1451



--# expr-start 792 ValDecl.expr Fld_19 nodes.lkt:1451







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_19 := Create_Internal_Entity_Expr (Node => Ent.Node.Val_Decl_F_Expr, Info => Ent.Info);
--# expr-done 792



   if Fld_19.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_20 := Fld_19.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 793
Fld_20.Value := No_Entity;
Entity_Vars.Reset (Fld_20);

Pred_1 := Solver.Create_Predicate (Fld_20, Create_Type_Decl_P_Could_Determine_Type_0_Predicate (Error_Location_1)); 
--# expr-done 794
Dyn_Var_Bind_Result_1 := Pred_1; Inc_Ref (Dyn_Var_Bind_Result_1);
--# expr-done 795
Scope_Result_1 := Dyn_Var_Bind_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_565;


And_Pred_3 := Create_And (If_Result_1, Scope_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1427:9") else null)); 
--# expr-done 796

         Property_Result := And_Pred_3;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_149;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_149;
                     Finalizer_Scope_564;
                     Finalizer_Scope_565;




            raise;
      end;



   return Property_Result;
end Val_Decl_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Fun_Decl
   --

   



   

   

   

   

   

   

   


      procedure Fun_Decl_Pre_Env_Actions
        (Self            : Bare_Fun_Decl;
         State           : in out PLE_Node_State;
         Add_To_Env_Only : Boolean := False) is
      begin
            


   

      declare
         Resolver : constant Entity_Resolver :=
            null;

         

         Mapping : Internal_Env_Assoc :=
            Liblktlang.Implementation.Internal_Env_Mappings_4 (Node => 
Self);
      begin

         Add_To_Env
           (Self,
            State,
            Mapping.Key,
            Mapping.Value,
            Mapping.Metadata,
            Resolver,
            Mapping.Dest_Env,
            DSL_Location => "nodes.lkt:1512:9");
         Dec_Ref (Mapping.Dest_Env);

      end;
   
   
            


   
      if Add_To_Env_Only then
         return;
      end if;

      declare
         No_Parent         : constant Boolean :=
            False;
         Transitive_Parent : constant Boolean :=
            False;
         Names             : Symbol_Type_Array_Access :=
            null;
      begin
         Add_Env (Self, State, No_Parent, Transitive_Parent, Names);
      end;
   
   
            


   

      declare
         Resolver : constant Entity_Resolver :=
            null;

         

         Mappings : Internal_Env_Assoc_Array_Access :=
            Liblktlang.Implementation.Internal_Env_Mappings_5 (Node => 
Self);
      begin
         for Mapping of Mappings.Items loop

         Add_To_Env
           (Self,
            State,
            Mapping.Key,
            Mapping.Value,
            Mapping.Metadata,
            Resolver,
            Mapping.Dest_Env,
            DSL_Location => "nodes.lkt:1515:9");

         end loop;
         Dec_Ref (Mappings);
      end;
   
   
      end;



      
      procedure Initialize_Fields_For_Fun_Decl
        (Self : Bare_Fun_Decl
         ; Fun_Decl_F_Syn_Name : Bare_Def_Id
         ; Fun_Decl_F_Params : Bare_Fun_Param_Decl_List
         ; Fun_Decl_F_Return_Type : Bare_Type_Ref
         ; Fun_Decl_F_Trait_Ref : Bare_Dot_Expr
         ; Fun_Decl_F_Body : Bare_Expr
        ) is
      begin

            Self.Fun_Decl_F_Syn_Name := Fun_Decl_F_Syn_Name;
            Self.Fun_Decl_F_Params := Fun_Decl_F_Params;
            Self.Fun_Decl_F_Return_Type := Fun_Decl_F_Return_Type;
            Self.Fun_Decl_F_Trait_Ref := Fun_Decl_F_Trait_Ref;
            Self.Fun_Decl_F_Body := Fun_Decl_F_Body;
         

      end Initialize_Fields_For_Fun_Decl;

      
   function Fun_Decl_F_Params
     (Node : Bare_Fun_Decl) return Bare_Fun_Param_Decl_List
   is
      

   begin
         
         return Node.Fun_Decl_F_Params;
      
   end;

      
   function Fun_Decl_F_Return_Type
     (Node : Bare_Fun_Decl) return Bare_Type_Ref
   is
      

   begin
         
         return Node.Fun_Decl_F_Return_Type;
      
   end;

      
   function Fun_Decl_F_Trait_Ref
     (Node : Bare_Fun_Decl) return Bare_Dot_Expr
   is
      

   begin
         
         return Node.Fun_Decl_F_Trait_Ref;
      
   end;

      
   function Fun_Decl_F_Body
     (Node : Bare_Fun_Decl) return Bare_Expr
   is
      

   begin
         
         return Node.Fun_Decl_F_Body;
      
   end;


   







--# property-start FunDecl.decl_type_name nodes.lkt:1470
pragma Warnings (Off, "is not referenced");

function Fun_Decl_P_Decl_Type_Name
  
  (Node : Bare_Fun_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Fun_Decl :=
     Bare_Fun_Decl (Node);
     Ent : Internal_Entity_Fun_Decl :=
       Internal_Entity_Fun_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_150 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_150 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_150;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 797 StringLiteral Str nodes.lkt:1470
Str := Create_String ("function declaration"); 
--# expr-done 797

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_150;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_150;




            raise;
      end;



   return Property_Result;
end Fun_Decl_P_Decl_Type_Name;
--# end

   







--# property-start FunDecl.owning_type nodes.lkt:1472
pragma Warnings (Off, "is not referenced");

function Fun_Decl_P_Owning_Type
  
  (Node : Bare_Fun_Decl
  )

   return Bare_Type_Decl
is
   Self : Bare_Fun_Decl :=
     Bare_Fun_Decl (Node);
      --# bind node Self

   


   Property_Result : Bare_Type_Decl;

      
            procedure Finalizer_Scope_151 with Inline_Always;

      Node_Parents : Bare_Lkt_Node_Array_Access;
Is_A : Boolean;
Find_Result : Bare_Lkt_Node;
Cast_Result : Bare_Type_Decl;

            procedure Finalizer_Scope_151 is
            begin
                     Dec_Ref (Node_Parents);
            end Finalizer_Scope_151;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 801 Cast Cast_Result nodes.lkt:1473





--# expr-start 800 .find Find_Result nodes.lkt:1473








   

   --# expr-start 798 LktNode.parents Node_Parents nodes.lkt:1473







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



Node_Parents := Parents (Self, True); 
--# expr-done 798

   
      Find_Result := No_Bare_Lkt_Node;
   

   

      

      declare
         
         Collection : constant Bare_Lkt_Node_Array_Access := Node_Parents;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind t Item

            
      --# expr-start 799 IsA Is_A nodes.lkt:1473

Is_A := Item /= null 
and then Item.Kind in Lkt_Type_Decl; 
--# expr-done 799
      if Is_A then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Is_A;

         end loop;
      end;
   

   
   



--# expr-done 800



   if Find_Result = null
      or else Find_Result.Kind in Lkt_Type_Decl
   then
      
      Cast_Result := Find_Result;

   else
         Cast_Result := No_Bare_Lkt_Node;
   end if;


--# expr-done 801

         Property_Result := Cast_Result;
         
   --# end
      Finalizer_Scope_151;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_151;




            raise;
      end;



   return Property_Result;
end Fun_Decl_P_Owning_Type;
--# end

   







--# property-start FunDecl.is_dynamic_combiner nodes.lkt:1479
pragma Warnings (Off, "is not referenced");

function Fun_Decl_P_Is_Dynamic_Combiner
  
  (Node : Bare_Fun_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Fun_Decl :=
     Bare_Fun_Decl (Node);
     Ent : Internal_Entity_Fun_Decl :=
       Internal_Entity_Fun_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Fld : Internal_Entity_Fun_Param_Decl_List;
Fld_1 : Bare_Fun_Param_Decl_List;
Fld_2 : Internal_Entity_Info;
Get_Result : Bare_Fun_Param_Decl;
As_Entity : Internal_Entity_Fun_Param_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Fun_Param_Decl;
Var_Expr : Internal_Entity_Fun_Param_Decl;
Fld_3 : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;
Local_Array_Type : Internal_Entity_Type_Decl;
Var_Expr_1 : Internal_Entity_Type_Decl;
Fld_4 : Bare_Type_Decl;
Result_Var_1 : Bare_Type_Decl;
Fld_5 : Internal_Entity_Named_Type_Decl;
Fld_6 : Bare_Named_Type_Decl;
Cast_Result : Bare_Type_Decl;
Is_Equal : Boolean;
Var_Expr_2 : Internal_Entity_Type_Decl;
Fld_7 : Internal_Entity_Type_Decl;
Fld_8 : Bare_Type_Decl;
Result_Var_2 : Bare_Type_Decl;
Fld_9 : Internal_Entity_Named_Type_Decl;
Fld_10 : Bare_Named_Type_Decl;
Cast_Result_1 : Bare_Type_Decl;
Is_Equal_1 : Boolean;
If_Result_1 : Boolean;
Let_Result : Boolean;
Scope_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 814 ValDecl Let_Result nodes.lkt:1480
--# scope-start



--# expr-start 802 FunDecl.params Fld nodes.lkt:1480







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Fun_Param_Decl_List (Node => Ent.Node.Fun_Decl_F_Params, Info => Ent.Info);
--# expr-done 802
















Fld_1 := Fld.Node;



   if Fld_1 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;




Get_Result := Get (Self, Fld_1, 0, True); 
Is_Null := Get_Result = null; 
if Is_Null then
   
   If_Result := No_Entity_Fun_Param_Decl;
else
   








Fld_2 := Fld.Info;

As_Entity := (Info => Fld_2, Node => Get_Result); 
   If_Result := As_Entity;
end if;



Var_Expr := If_Result;





if Var_Expr /= No_Entity_Fun_Param_Decl then
   --# expr-start 803 Decl.get_type Fld_3 nodes.lkt:1480







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.get_type
Fld_3 := Liblktlang.Implementation.Decl_P_Get_Type (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 803
   Result_Var := Fld_3;
else
   
   Result_Var := No_Entity_Type_Decl;
end if;



Local_Array_Type := Result_Var; 
--# bind array_type Local_Array_Type
--# expr-start 813 BooleanAnd If_Result_1 nodes.lkt:1482



--# expr-start 807 Eq Is_Equal nodes.lkt:1482




Var_Expr_1 := Local_Array_Type;





if Var_Expr_1 /= No_Entity_Type_Decl then
   --# expr-start 804 'Entity[TypeDecl].node' Fld_4 nodes.lkt:1482









Fld_4 := Var_Expr_1.Node;
--# expr-done 804
   Result_Var_1 := Fld_4;
else
   
   Result_Var_1 := No_Bare_Lkt_Node;
end if;








--# expr-start 806 'Entity[NamedTypeDecl].node' Fld_6 nodes.lkt:1482



--# expr-start 805 LktNode.array_type Fld_5 nodes.lkt:1482







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.array_type
Fld_5 := Liblktlang.Implementation.Lkt_Node_P_Array_Type (Node => Ent.Node);
--# end
--# expr-done 805





Fld_6 := Fld_5.Node;
--# expr-done 806



   
      Cast_Result := Fld_6;


Is_Equal := Result_Var_1 = Cast_Result; 
--# expr-done 807
if Is_Equal then
   --# expr-start 812 Eq Is_Equal_1 nodes.lkt:1483




Var_Expr_2 := Local_Array_Type;





if Var_Expr_2 /= No_Entity_Type_Decl then
   --# expr-start 809 'Entity[TypeDecl].node' Fld_8 nodes.lkt:1483



--# expr-start 808 TypeDecl.get_array_content_type Fld_7 nodes.lkt:1483







   if Var_Expr_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.get_array_content_type
Fld_7 := Liblktlang.Implementation.Type_Decl_P_Get_Array_Content_Type (Node => Var_Expr_2.Node, E_Info => Var_Expr_2.Info);
--# end
--# expr-done 808





Fld_8 := Fld_7.Node;
--# expr-done 809
   Result_Var_2 := Fld_8;
else
   
   Result_Var_2 := No_Bare_Lkt_Node;
end if;








--# expr-start 811 'Entity[NamedTypeDecl].node' Fld_10 nodes.lkt:1484



--# expr-start 810 LktNode.entity_type Fld_9 nodes.lkt:1484







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_9 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Ent.Node);
--# end
--# expr-done 810





Fld_10 := Fld_9.Node;
--# expr-done 811



   
      Cast_Result_1 := Fld_10;


Is_Equal_1 := Result_Var_2 = Cast_Result_1; 
--# expr-done 812
   If_Result_1 := Is_Equal_1;
else
   
   If_Result_1 := False;
end if;



--# expr-done 813
Let_Result := If_Result_1; 
--# end
--# expr-done 814
Scope_Result := Let_Result;


   --# end



         Property_Result := Scope_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Fun_Decl_P_Is_Dynamic_Combiner;
--# end

   







--# property-start FunDecl.xref_equation nodes.lkt:1487
pragma Warnings (Off, "is not referenced");

function Fun_Decl_P_Xref_Equation
  
  (Node : Bare_Fun_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Fun_Decl :=
     Bare_Fun_Decl (Node);
     Ent : Internal_Entity_Fun_Decl :=
       Internal_Entity_Fun_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_153 with Inline_Always;
            procedure Finalizer_Scope_568 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Internal_Entity_Expr;
Fld_3 : Logic_Var;
Fld_4 : Internal_Entity_Type_Ref;
Fld_5 : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
And_Pred : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_6 : Bare_Expr;
Fld_7 : Internal_Entity_Expr;
Fld_8 : Logic_Var;
Fld_9 : Internal_Entity_Expr;
Fld_10 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;
Fld_11 : Internal_Entity_Expr;
Is_Null : Boolean;
True_Rel : Logic_Equation;
If_Result : Logic_Equation;

            procedure Finalizer_Scope_153 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (True_Rel);
                     Dec_Ref (If_Result);
            end Finalizer_Scope_153;
            procedure Finalizer_Scope_568 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_568;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 834 If If_Result nodes.lkt:1488



--# expr-start 816 .is_null Is_Null nodes.lkt:1488
--# expr-start 815 FunDecl.body Fld_11 nodes.lkt:1488







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Create_Internal_Entity_Expr (Node => Ent.Node.Fun_Decl_F_Body, Info => Ent.Info);
--# expr-done 815
Is_Null := Fld_11.Node = null; 
--# expr-done 816
if Is_Null then
   --# expr-start 817 LogicTrue True_Rel nodes.lkt:1488
True_Rel := Solver.Create_True ((if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1488:35") else null)); 
--# expr-done 817
   If_Result := True_Rel;
else
   --# expr-start 833 LogicAnd And_Pred_1 nodes.lkt:1490
--# expr-start 825 LogicAnd And_Pred nodes.lkt:1491
--# expr-start 819 LktNode.xref_equation Fld_1 nodes.lkt:1491



--# expr-start 818 FunDecl.body Fld nodes.lkt:1491







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Fun_Decl_F_Body, Info => Ent.Info);
--# expr-done 818



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 819
--# expr-start 824 LogicAssign Bind_Result nodes.lkt:1492
--# expr-start 821 Expr.expected_type_var Fld_3 nodes.lkt:1492



--# expr-start 820 FunDecl.body Fld_2 nodes.lkt:1492







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Ent.Node.Fun_Decl_F_Body, Info => Ent.Info);
--# expr-done 820



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Fld_2.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 821
Fld_3.Value := No_Entity;
Entity_Vars.Reset (Fld_3);





--# expr-start 823 TypeRef.referenced_decl Fld_5 nodes.lkt:1493



--# expr-start 822 FunDecl.return_type Fld_4 nodes.lkt:1493







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Fun_Decl_F_Return_Type, Info => Ent.Info);
--# expr-done 822



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_5 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Fld_4.Node, E_Info => Fld_4.Info);
--# end
--# expr-done 823



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_5.Node,
         Info => Fld_5.Info);


Bind_Result := Solver.Create_Assign (Fld_3, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1492:22") else null)); 
--# expr-done 824
And_Pred := Create_And (Fld_1, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1491:17") else null)); 
--# expr-done 825




   --# scope-start



--# expr-start 832 bind Dyn_Var_Bind_Result nodes.lkt:1496





--# expr-start 826 FunDecl.body Fld_6 nodes.lkt:1496







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Self.Fun_Decl_F_Body;
--# expr-done 826



   
      Cast_Result_1 := Fld_6;


Error_Location := Cast_Result_1; 
--# expr-start 831 LogicPropagate Pred nodes.lkt:1497
--# expr-start 828 Expr.expected_type_var Fld_8 nodes.lkt:1498



--# expr-start 827 FunDecl.body Fld_7 nodes.lkt:1498







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Create_Internal_Entity_Expr (Node => Ent.Node.Fun_Decl_F_Body, Info => Ent.Info);
--# expr-done 827



   if Fld_7.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Fld_7.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 828
Fld_8.Value := No_Entity;
Entity_Vars.Reset (Fld_8);
--# expr-start 830 Expr.actual_type_var Fld_10 nodes.lkt:1499



--# expr-start 829 FunDecl.body Fld_9 nodes.lkt:1499







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Create_Internal_Entity_Expr (Node => Ent.Node.Fun_Decl_F_Body, Info => Ent.Info);
--# expr-done 829



   if Fld_9.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Fld_9.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 830
Fld_10.Value := No_Entity;
Entity_Vars.Reset (Fld_10);


Pred := Solver.Create_N_Predicate ((Fld_8, Fld_10), Create_Type_Decl_P_Matching_Type_0_Predicate (2, Error_Location)); 
--# expr-done 831
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 832
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_568;


And_Pred_1 := Create_And (And_Pred, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1490:13") else null)); 
--# expr-done 833
   If_Result := And_Pred_1;
end if;

      Inc_Ref (If_Result);


--# expr-done 834

         Property_Result := If_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_153;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_153;
                     Finalizer_Scope_568;




            raise;
      end;



   return Property_Result;
end Fun_Decl_P_Xref_Equation;
--# end

   







--# property-start FunDecl.function_type_aux nodes.lkt:1504
pragma Warnings (Off, "is not referenced");

function Fun_Decl_P_Function_Type_Aux
  
  (Node : Bare_Fun_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Function_Type
is
   Self : Bare_Fun_Decl :=
     Bare_Fun_Decl (Node);
     Ent : Internal_Entity_Fun_Decl :=
       Internal_Entity_Fun_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Function_Type;

      
            procedure Finalizer_Scope_154 with Inline_Always;

      Fld : Internal_Entity_Fun_Param_Decl_List;
Item : Internal_Entity_Fun_Param_Decl;
Fld_1 : Internal_Entity_Type_Decl;
Fld_2 : Bare_Fun_Param_Decl_List;
Fld_3 : Internal_Entity_Info;
Bare_Item : Bare_Fun_Param_Decl;
As_Entity : Internal_Entity_Fun_Param_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Fun_Param_Decl;
Map_Result : Internal_Entity_Type_Decl_Array_Access;
Fld_4 : Internal_Entity_Type_Ref;
Fld_5 : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity_Decl;
Fld_6 : Internal_Entity_Function_Type;

            procedure Finalizer_Scope_154 is
            begin
                     Dec_Ref (Map_Result);
            end Finalizer_Scope_154;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 840 LktNode.function_type_helper Fld_6 nodes.lkt:1505







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 837 .map Map_Result nodes.lkt:1506








   

   --# expr-start 835 FunDecl.params Fld nodes.lkt:1506







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Fun_Param_Decl_List (Node => Ent.Node.Fun_Decl_F_Params, Info => Ent.Info);
--# expr-done 835









Fld_2 := Fld.Node;

   
      declare
         Map_Result_Vec : Internal_Entity_Type_Decl_Vectors.Vector;
      begin
   

   

      if Fld_2 = null then
         
      Map_Result := Create_Internal_Entity_Type_Decl_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Fun_Param_Decl_List := Fld_2;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Fun_Param_Decl;
else
   








Fld_3 := Fld.Info;

As_Entity := (Info => Fld_3, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind a Item

            
         
         
      --# expr-start 836 Decl.get_type Fld_1 nodes.lkt:1506







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.get_type
Fld_1 := Liblktlang.Implementation.Decl_P_Get_Type (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 836
      

         declare
            Item_To_Append : constant Internal_Entity_Type_Decl := Fld_1;
         begin
            Internal_Entity_Type_Decl_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Internal_Entity_Type_Decl_Array
           (Items_Count => Natural (Internal_Entity_Type_Decl_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Type_Decl_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Type_Decl_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Type_Decl_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 837
--# expr-start 839 TypeRef.referenced_decl Fld_5 nodes.lkt:1507



--# expr-start 838 FunDecl.return_type Fld_4 nodes.lkt:1507







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Fun_Decl_F_Return_Type, Info => Ent.Info);
--# expr-done 838



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_5 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Fld_4.Node, E_Info => Fld_4.Info);
--# end
--# expr-done 839









   
      Cast_Result := Create_Internal_Entity_Decl
        (Node => Ent.Node,
         Info => Ent.Info);


--# property-call-start LktNode.function_type_helper
Fld_6 := Liblktlang.Implementation.Lkt_Node_P_Function_Type_Helper (Node => Ent.Node, Param_Types => Map_Result, Return_Type => Fld_5, Origin => Cast_Result, E_Info => Ent.Info);
--# end
--# expr-done 840

         Property_Result := Fld_6;
         
   --# end
      Finalizer_Scope_154;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_154;




            raise;
      end;



   return Property_Result;
end Fun_Decl_P_Function_Type_Aux;
--# end

   







--# property-start FunDecl.find_all_overrides_helper nodes.lkt:1544
pragma Warnings (Off, "is not referenced");

function Fun_Decl_P_Find_All_Overrides_Helper
  
  (Node : Bare_Fun_Decl
      ; Current_Node : Internal_Entity
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Fun_Decl_Array_Access
is
   Self : Bare_Fun_Decl :=
     Bare_Fun_Decl (Node);
     Ent : Internal_Entity_Fun_Decl :=
       Internal_Entity_Fun_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind current_node Current_Node

   Property_Result : Internal_Entity_Fun_Decl_Array_Access;

      
            procedure Finalizer_Scope_156 with Inline_Always;
            procedure Finalizer_Scope_570 with Inline_Always;

      Fld : Internal_Entity_Array_Access;
Fld_1 : Internal_Entity_Fun_Decl_Array_Access;
Is_Null : Boolean;
If_Result : Internal_Entity_Fun_Decl_Array_Access;
Map_Result : Internal_Entity_Fun_Decl_Array_Access;
Cast_Result : Internal_Entity_Fun_Decl;
Var_Expr : Internal_Entity_Fun_Decl;
Fld_2 : Internal_Entity_Def_Id;
Fld_3 : Bare_Def_Id;
Sym : Symbol_Type;
Fld_4 : Internal_Entity_Def_Id;
Fld_5 : Bare_Def_Id;
Sym_1 : Symbol_Type;
Is_Equal : Boolean;
Fld_6 : Bare_Type_Decl;
As_Entity : Internal_Entity_Type_Decl;
Is_Null_1 : Boolean;
If_Result_1 : Internal_Entity_Type_Decl;
Var_Expr_1 : Internal_Entity_Type_Decl;
Fld_7 : Bare_Type_Decl;
As_Entity_1 : Internal_Entity_Type_Decl;
Is_Null_2 : Boolean;
If_Result_2 : Internal_Entity_Type_Decl;
Fld_8 : Internal_Entity_Type_Decl;
Is_Null_3 : Boolean;
Result_Var : Boolean;
Not_Val : Boolean;
If_Result_3 : Boolean;
Scope_Result : Boolean;
Result_Var_1 : Boolean;
Cast_Result_1 : Internal_Entity_Fun_Decl;
Singleton : Internal_Entity_Fun_Decl_Array_Access;
If_Result_4 : Internal_Entity_Fun_Decl_Array_Access;

            procedure Finalizer_Scope_156 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Singleton);
                     Dec_Ref (If_Result_4);
            end Finalizer_Scope_156;
            procedure Finalizer_Scope_570 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (If_Result);
            end Finalizer_Scope_570;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 863 If If_Result_4 nodes.lkt:1547



--# expr-start 855 .do Result_Var_1 nodes.lkt:1547



--# expr-start 841 Cast Cast_Result nodes.lkt:1547









   if Current_Node.Node = null
      or else Current_Node.Node.Kind in Lkt_Fun_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Fun_Decl
        (Node => Current_Node.Node,
         Info => Current_Node.Info);

   else
         Cast_Result := No_Entity_Fun_Decl;
   end if;


--# expr-done 841
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Fun_Decl then
   



   --# scope-start



--# expr-start 854 BooleanAnd If_Result_3 nodes.lkt:1548



--# expr-start 846 Eq Is_Equal nodes.lkt:1548
--# expr-start 843 .symbol Sym nodes.lkt:1548



--# expr-start 842 FunDecl.syn_name Fld_2 nodes.lkt:1548







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Def_Id (Node => Var_Expr.Node.Fun_Decl_F_Syn_Name, Info => Var_Expr.Info);
--# expr-done 842





Fld_3 := Fld_2.Node; 
Sym := Get_Symbol (Fld_3); 
--# expr-done 843
--# expr-start 845 .symbol Sym_1 nodes.lkt:1548



--# expr-start 844 FunDecl.syn_name Fld_4 nodes.lkt:1548







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Def_Id (Node => Ent.Node.Fun_Decl_F_Syn_Name, Info => Ent.Info);
--# expr-done 844





Fld_5 := Fld_4.Node; 
Sym_1 := Get_Symbol (Fld_5); 
--# expr-done 845
Is_Equal := Sym = Sym_1; 
--# expr-done 846
if Is_Equal then
   --# expr-start 853 Not Not_Val nodes.lkt:1549



--# expr-start 848 .as_entity If_Result_1 nodes.lkt:1549



--# expr-start 847 FunDecl.owning_type Fld_6 nodes.lkt:1549







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start FunDecl.owning_type
Fld_6 := Liblktlang.Implementation.Fun_Decl_P_Owning_Type (Node => Var_Expr.Node);
--# end
--# expr-done 847
Is_Null_1 := Fld_6 = null; 
if Is_Null_1 then
   
   If_Result_1 := No_Entity_Type_Decl;
else
   

As_Entity := (Info => E_Info, Node => Fld_6); 
   If_Result_1 := As_Entity;
end if;



--# expr-done 848
Var_Expr_1 := If_Result_1;





if Var_Expr_1 /= No_Entity_Type_Decl then
   --# expr-start 852 .is_null Is_Null_3 nodes.lkt:1549
--# expr-start 851 TypeDecl.common_ancestor Fld_8 nodes.lkt:1549







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 850 .as_entity If_Result_2 nodes.lkt:1550



--# expr-start 849 FunDecl.owning_type Fld_7 nodes.lkt:1550







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start FunDecl.owning_type
Fld_7 := Liblktlang.Implementation.Fun_Decl_P_Owning_Type (Node => Ent.Node);
--# end
--# expr-done 849
Is_Null_2 := Fld_7 = null; 
if Is_Null_2 then
   
   If_Result_2 := No_Entity_Type_Decl;
else
   

As_Entity_1 := (Info => E_Info, Node => Fld_7); 
   If_Result_2 := As_Entity_1;
end if;



--# expr-done 850
--# property-call-start '[dispatcher]TypeDecl.common_ancestor'
Fld_8 := Liblktlang.Implementation.Dispatcher_Type_Decl_P_Common_Ancestor (Node => Var_Expr_1.Node, Other => If_Result_2, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 851
Is_Null_3 := Fld_8.Node = null; 
--# expr-done 852
   Result_Var := Is_Null_3;
else
   
   Result_Var := False;
end if;



Not_Val := not (Result_Var); 
--# expr-done 853
   If_Result_3 := Not_Val;
else
   
   If_Result_3 := False;
end if;



--# expr-done 854
Scope_Result := If_Result_3;


   --# end


   Result_Var_1 := Scope_Result;
else
   
   Result_Var_1 := False;
end if;



--# expr-done 855
if Result_Var_1 then
   --# expr-start 857 .singleton Singleton nodes.lkt:1552
--# expr-start 856 Cast Cast_Result_1 nodes.lkt:1552









   if Current_Node.Node = null
      or else Current_Node.Node.Kind in Lkt_Fun_Decl_Range
   then
      
      Cast_Result_1 := Create_Internal_Entity_Fun_Decl
        (Node => Current_Node.Node,
         Info => Current_Node.Info);

   else
         Cast_Result_1 := No_Entity_Fun_Decl;
   end if;


--# expr-done 856
            Singleton := Create_Internal_Entity_Fun_Decl_Array (Items_Count => 1);
            Singleton.Items (1) := Cast_Result_1;
            
        
--# expr-done 857
   If_Result_4 := Singleton;
else
   --# expr-start 862 .mapcat Map_Result nodes.lkt:1553








   

   --# expr-start 858 .children Fld nodes.lkt:1553







   if Current_Node.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Children (Node => Current_Node.Node, E_Info => Current_Node.Info);
--# expr-done 858

   
      declare
         Map_Result_Vec : Internal_Entity_Fun_Decl_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind child Item

            
         
         
      --# expr-start 861 If If_Result nodes.lkt:1555



--# expr-start 859 .is_null Is_Null nodes.lkt:1555

Is_Null := Item.Node = null; 
--# expr-done 859
if Is_Null then
   
   If_Result := No_Internal_Entity_Fun_Decl_Array_Type;
else
   --# expr-start 860 FunDecl.find_all_overrides_helper Fld_1 nodes.lkt:1557







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start FunDecl.find_all_overrides_helper
Fld_1 := Liblktlang.Implementation.Fun_Decl_P_Find_All_Overrides_Helper (Node => Ent.Node, Current_Node => Item, E_Info => Ent.Info);
--# end
--# expr-done 860
   If_Result := Fld_1;
end if;

      Inc_Ref (If_Result);


--# expr-done 861
      

         for Item_To_Append of
               If_Result.Items
         loop
            Internal_Entity_Fun_Decl_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end loop;

   
   
   

            
   --# end
      Finalizer_Scope_570;



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Entity_Fun_Decl_Array
           (Items_Count => Natural (Internal_Entity_Fun_Decl_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Fun_Decl_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Fun_Decl_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Fun_Decl_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 862
   If_Result_4 := Map_Result;
end if;

      Inc_Ref (If_Result_4);


--# expr-done 863

         Property_Result := If_Result_4;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_156;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_156;
                     Finalizer_Scope_570;




            raise;
      end;



   return Property_Result;
end Fun_Decl_P_Find_All_Overrides_Helper;
--# end

   







--# property-start FunDecl.find_all_overrides nodes.lkt:1562
pragma Warnings (Off, "is not referenced");

function Fun_Decl_P_Find_All_Overrides
  
  (Node : Bare_Fun_Decl
      ; Units : Internal_Unit_Array_Access
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Fun_Decl_Array_Access
is
   Self : Bare_Fun_Decl :=
     Bare_Fun_Decl (Node);
     Ent : Internal_Entity_Fun_Decl :=
       Internal_Entity_Fun_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind units Units

   Property_Result : Internal_Entity_Fun_Decl_Array_Access;

      
            procedure Finalizer_Scope_157 with Inline_Always;
            procedure Finalizer_Scope_572 with Inline_Always;

      Fld : Bare_Lkt_Node;
As_Entity : Internal_Entity;
Is_Null : Boolean;
If_Result : Internal_Entity;
Fld_1 : Internal_Entity_Fun_Decl_Array_Access;
Map_Result : Internal_Entity_Fun_Decl_Array_Access;

            procedure Finalizer_Scope_157 is
            begin
                     Dec_Ref (Map_Result);
            end Finalizer_Scope_157;
            procedure Finalizer_Scope_572 is
            begin
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_572;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 867 .mapcat Map_Result nodes.lkt:1565








   

   

   
      declare
         Map_Result_Vec : Internal_Entity_Fun_Decl_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Unit_Array_Access := Units;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind unit Item

            
         
         
      --# expr-start 866 FunDecl.find_all_overrides_helper Fld_1 nodes.lkt:1566







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 865 .as_entity If_Result nodes.lkt:1566



--# expr-start 864 AnalysisUnit.root Fld nodes.lkt:1566







   if Item = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Item.Ast_Root;
--# expr-done 864
Is_Null := Fld = null; 
if Is_Null then
   
   If_Result := No_Entity;
else
   

As_Entity := (Info => E_Info, Node => Fld); 
   If_Result := As_Entity;
end if;



--# expr-done 865
--# property-call-start FunDecl.find_all_overrides_helper
Fld_1 := Liblktlang.Implementation.Fun_Decl_P_Find_All_Overrides_Helper (Node => Ent.Node, Current_Node => If_Result, E_Info => Ent.Info);
--# end
--# expr-done 866
      

         for Item_To_Append of
               Fld_1.Items
         loop
            Internal_Entity_Fun_Decl_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end loop;

   
   
   

            
   --# end
      Finalizer_Scope_572;



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Entity_Fun_Decl_Array
           (Items_Count => Natural (Internal_Entity_Fun_Decl_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Fun_Decl_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Fun_Decl_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Fun_Decl_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 867

         Property_Result := Map_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_157;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_157;
                     Finalizer_Scope_572;




            raise;
      end;



   return Property_Result;
end Fun_Decl_P_Find_All_Overrides;
--# end

   







--# property-start FunDecl.base_fun_decls nodes.lkt:1571
pragma Warnings (Off, "is not referenced");

function Fun_Decl_P_Base_Fun_Decls
  
  (Node : Bare_Fun_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Fun_Decl_Array_Access
is
   Self : Bare_Fun_Decl :=
     Bare_Fun_Decl (Node);
     Ent : Internal_Entity_Fun_Decl :=
       Internal_Entity_Fun_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Fun_Decl_Array_Access;

      
            procedure Finalizer_Scope_159 with Inline_Always;
            procedure Finalizer_Scope_573 with Inline_Always;

      Origin : Internal_Entity;
Fld : Bare_Type_Decl;
As_Entity : Internal_Entity_Type_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Type_Decl;
Fld_1 : Lexical_Env := Empty_Env;
Fld_2 : Symbol_Type;
Env_Get_Result : Internal_Entity_Array_Access;
Cast_Result : Internal_Entity_Fun_Decl;
Is_A : Boolean;
Map_Result : Internal_Entity_Fun_Decl_Array_Access;
Dyn_Var_Bind_Result : Internal_Entity_Fun_Decl_Array_Access;
Scope_Result : Internal_Entity_Fun_Decl_Array_Access;

            procedure Finalizer_Scope_159 is
            begin
                     Dec_Ref (Scope_Result);
            end Finalizer_Scope_159;
            procedure Finalizer_Scope_573 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Env_Get_Result);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_573;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 874 bind Dyn_Var_Bind_Result nodes.lkt:1572

Origin := No_Entity; 
--# expr-start 873 Keep Map_Result nodes.lkt:1573








   

   --# expr-start 872 .get Env_Get_Result nodes.lkt:1573
--# expr-start 870 Decl.defined_scope Fld_1 nodes.lkt:1573



--# expr-start 869 .as_entity If_Result nodes.lkt:1573



--# expr-start 868 FunDecl.owning_type Fld nodes.lkt:1573







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start FunDecl.owning_type
Fld := Liblktlang.Implementation.Fun_Decl_P_Owning_Type (Node => Ent.Node);
--# end
--# expr-done 868
Is_Null := Fld = null; 
if Is_Null then
   
   If_Result := No_Entity_Type_Decl;
else
   

As_Entity := (Info => E_Info, Node => Fld); 
   If_Result := As_Entity;
end if;



--# expr-done 869



   if If_Result.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_1 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => If_Result.Node, Origin => Origin, E_Info => If_Result.Info);
--# end
--# expr-done 870
--# expr-start 871 Decl.name Fld_2 nodes.lkt:1576







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_2 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Ent.Node);
--# end
--# expr-done 871


Env_Get_Result := Construct_Entity_Array (AST_Envs.Get (Self => Fld_1, Key => Thin (Fld_2), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True))); 
--# expr-done 872

   
      declare
         Map_Result_Vec : Internal_Entity_Fun_Decl_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Env_Get_Result;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start



            
         
Is_A := Item.Node /= null 
and then Item.Node.Kind in Lkt_Fun_Decl_Range; 
         if Is_A then
            
         
      








   if Item.Node = null
      or else Item.Node.Kind in Lkt_Fun_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Fun_Decl
        (Node => Item.Node,
         Info => Item.Info);

   else
         Cast_Result := No_Entity_Fun_Decl;
   end if;


      

         declare
            Item_To_Append : constant Internal_Entity_Fun_Decl := Cast_Result;
         begin
            Internal_Entity_Fun_Decl_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
         end if;
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Entity_Fun_Decl_Array
           (Items_Count => Natural (Internal_Entity_Fun_Decl_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Fun_Decl_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Fun_Decl_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Fun_Decl_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 873
Dyn_Var_Bind_Result := Map_Result; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 874
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_573;



         Property_Result := Scope_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_159;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_159;
                     Finalizer_Scope_573;




            raise;
      end;



   return Property_Result;
end Fun_Decl_P_Base_Fun_Decls;
--# end

   







--# property-start 'FunDecl.[internal]internal_env_mappings_4' nodes.lkt:1512
pragma Warnings (Off, "is not referenced");

function Internal_Env_Mappings_4
  
  (Node : Bare_Fun_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Env_Assoc
is
   Self : Bare_Fun_Decl :=
     Bare_Fun_Decl (Node);
     Ent : Internal_Entity_Fun_Decl :=
       Internal_Entity_Fun_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Env_Assoc;

      
            procedure Finalizer_Scope_422 with Inline_Always;

      Fld : Symbol_Type;
Cast_Result : Bare_Lkt_Node;
New_Struct : Internal_Designated_Env := No_Designated_Env;
New_Struct_1 : Internal_Env_Assoc := No_Env_Assoc;

            procedure Finalizer_Scope_422 is
            begin
                     Dec_Ref (New_Struct);
                     Dec_Ref (New_Struct_1);
            end Finalizer_Scope_422;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         


Inc_Ref (Empty_Env);
New_Struct := (Direct_Env => Empty_Env, Env_Name => No_Symbol, Kind => Current_Env); 
--# expr-start 875 Decl.name Fld nodes.lkt:1512







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Ent.Node);
--# end
--# expr-done 875










   
      Cast_Result := Self;


Inc_Ref (New_Struct);
New_Struct_1 := (Dest_Env => New_Struct, Key => Fld, Metadata => No_Metadata, Value => Cast_Result); 

         Property_Result := New_Struct_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_422;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_422;




            raise;
      end;



   return Property_Result;
end Internal_Env_Mappings_4;
--# end

   







--# property-start 'FunDecl.[internal]internal_env_mappings_5' nodes.lkt:1516
pragma Warnings (Off, "is not referenced");

function Internal_Env_Mappings_5
  
  (Node : Bare_Fun_Decl
  )

   return Internal_Env_Assoc_Array_Access
is
   Self : Bare_Fun_Decl :=
     Bare_Fun_Decl (Node);
      --# bind node Self

   


   Property_Result : Internal_Env_Assoc_Array_Access;

      
            procedure Finalizer_Scope_423 with Inline_Always;
            procedure Finalizer_Scope_866 with Inline_Always;

      Fld : Bare_Type_Decl;
Var_Expr : Bare_Type_Decl;
Sym : Symbol_Type;
Fld_1 : Bare_Self_Decl;
New_Struct : Internal_Designated_Env := No_Designated_Env;
Cast_Result : Bare_Lkt_Node;
New_Struct_1 : Internal_Env_Assoc := No_Env_Assoc;
Sym_1 : Symbol_Type;
Fld_2 : Bare_Node_Decl;
New_Struct_2 : Internal_Designated_Env := No_Designated_Env;
Cast_Result_1 : Bare_Lkt_Node;
New_Struct_3 : Internal_Env_Assoc := No_Env_Assoc;
Array_Lit : Internal_Env_Assoc_Array_Access;
Scope_Result : Internal_Env_Assoc_Array_Access;
Result_Var : Internal_Env_Assoc_Array_Access;

            procedure Finalizer_Scope_423 is
            begin
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Result_Var);
            end Finalizer_Scope_423;
            procedure Finalizer_Scope_866 is
            begin
                     Dec_Ref (New_Struct);
                     Dec_Ref (New_Struct_1);
                     Dec_Ref (New_Struct_2);
                     Dec_Ref (New_Struct_3);
                     Dec_Ref (Array_Lit);
            end Finalizer_Scope_866;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 886 .do Result_Var nodes.lkt:1516



--# expr-start 876 FunDecl.owning_type Fld nodes.lkt:1516







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start FunDecl.owning_type
Fld := Liblktlang.Implementation.Fun_Decl_P_Owning_Type (Node => Self);
--# end
--# expr-done 876
Var_Expr := Fld;





if Var_Expr /= No_Bare_Lkt_Node then
   



   --# scope-start



--# expr-start 885 ArrayLiteral Array_Lit nodes.lkt:1518
--# expr-start 880 'New[EnvAssoc]' New_Struct_1 nodes.lkt:1519
--# expr-start 877 'New[DesignatedEnv]' New_Struct nodes.lkt:1522



Inc_Ref (Empty_Env);
New_Struct := (Direct_Env => Empty_Env, Env_Name => No_Symbol, Kind => Current_Env); 
--# expr-done 877
--# expr-start 878 SymbolLiteral Sym nodes.lkt:1520
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Self); 
--# expr-done 878






--# expr-start 879 TypeDecl.self_decl Fld_1 nodes.lkt:1521







   if Var_Expr = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.self_decl
Fld_1 := Liblktlang.Implementation.Type_Decl_P_Self_Decl (Node => Var_Expr);
--# end
--# expr-done 879



   
      Cast_Result := Fld_1;


Inc_Ref (New_Struct);
New_Struct_1 := (Dest_Env => New_Struct, Key => Sym, Metadata => No_Metadata, Value => Cast_Result); 
--# expr-done 880
--# expr-start 884 'New[EnvAssoc]' New_Struct_3 nodes.lkt:1529
--# expr-start 881 'New[DesignatedEnv]' New_Struct_2 nodes.lkt:1532



Inc_Ref (Empty_Env);
New_Struct_2 := (Direct_Env => Empty_Env, Env_Name => No_Symbol, Kind => Current_Env); 
--# expr-done 881
--# expr-start 882 SymbolLiteral Sym_1 nodes.lkt:1530
Sym_1 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Node_49); 
--# expr-done 882






--# expr-start 883 TypeDecl.node_decl Fld_2 nodes.lkt:1531







   if Var_Expr = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.node_decl
Fld_2 := Liblktlang.Implementation.Type_Decl_P_Node_Decl (Node => Var_Expr);
--# end
--# expr-done 883



   
      Cast_Result_1 := Fld_2;


Inc_Ref (New_Struct_2);
New_Struct_3 := (Dest_Env => New_Struct_2, Key => Sym_1, Metadata => No_Metadata, Value => Cast_Result_1); 
--# expr-done 884
Array_Lit := Create_Internal_Env_Assoc_Array (Internal_Internal_Env_Assoc_Array'(1 => New_Struct_1, 2 => New_Struct_3)); 
--# expr-done 885
Scope_Result := Array_Lit;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_866;


   Result_Var := Scope_Result;
else
   
   Result_Var := No_Internal_Env_Assoc_Array_Type;
end if;

      Inc_Ref (Result_Var);


--# expr-done 886

         Property_Result := Result_Var;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_423;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_423;
                     Finalizer_Scope_866;




            raise;
      end;



   return Property_Result;
end Internal_Env_Mappings_5;
--# end



   


      

   --
   --  Primitives for Bare_Env_Spec_Decl
   --

   



   

   

   

   

   

   

   


      procedure Env_Spec_Decl_Pre_Env_Actions
        (Self            : Bare_Env_Spec_Decl;
         State           : in out PLE_Node_State;
         Add_To_Env_Only : Boolean := False) is
      begin
            


   
      if Add_To_Env_Only then
         return;
      end if;

      declare
         No_Parent         : constant Boolean :=
            False;
         Transitive_Parent : constant Boolean :=
            False;
         Names             : Symbol_Type_Array_Access :=
            null;
      begin
         Add_Env (Self, State, No_Parent, Transitive_Parent, Names);
      end;
   
   
            


   

      declare
         Resolver : constant Entity_Resolver :=
            null;

         

         Mappings : Internal_Env_Assoc_Array_Access :=
            Liblktlang.Implementation.Internal_Env_Mappings_6 (Node => 
Self);
      begin
         for Mapping of Mappings.Items loop

         Add_To_Env
           (Self,
            State,
            Mapping.Key,
            Mapping.Value,
            Mapping.Metadata,
            Resolver,
            Mapping.Dest_Env,
            DSL_Location => "nodes.lkt:1618:9");

         end loop;
         Dec_Ref (Mappings);
      end;
   
   
      end;



      
      procedure Initialize_Fields_For_Env_Spec_Decl
        (Self : Bare_Env_Spec_Decl
         ; Env_Spec_Decl_F_Syn_Name : Bare_Def_Id
         ; Env_Spec_Decl_F_Actions : Bare_Call_Expr_List
        ) is
      begin

            Self.Env_Spec_Decl_F_Syn_Name := Env_Spec_Decl_F_Syn_Name;
            Self.Env_Spec_Decl_F_Actions := Env_Spec_Decl_F_Actions;
         

      end Initialize_Fields_For_Env_Spec_Decl;

      
   function Env_Spec_Decl_F_Actions
     (Node : Bare_Env_Spec_Decl) return Bare_Call_Expr_List
   is
      

   begin
         
         return Node.Env_Spec_Decl_F_Actions;
      
   end;


   







--# property-start EnvSpecDecl.owning_type nodes.lkt:1591
pragma Warnings (Off, "is not referenced");

function Env_Spec_Decl_P_Owning_Type
  
  (Node : Bare_Env_Spec_Decl
  )

   return Bare_Type_Decl
is
   Self : Bare_Env_Spec_Decl :=
     Bare_Env_Spec_Decl (Node);
      --# bind node Self

   


   Property_Result : Bare_Type_Decl;

      
            procedure Finalizer_Scope_160 with Inline_Always;

      Node_Parents : Bare_Lkt_Node_Array_Access;
Is_A : Boolean;
Find_Result : Bare_Lkt_Node;
Cast_Result : Bare_Type_Decl;

            procedure Finalizer_Scope_160 is
            begin
                     Dec_Ref (Node_Parents);
            end Finalizer_Scope_160;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 890 Cast Cast_Result nodes.lkt:1592





--# expr-start 889 .find Find_Result nodes.lkt:1592








   

   --# expr-start 887 LktNode.parents Node_Parents nodes.lkt:1592







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



Node_Parents := Parents (Self, True); 
--# expr-done 887

   
      Find_Result := No_Bare_Lkt_Node;
   

   

      

      declare
         
         Collection : constant Bare_Lkt_Node_Array_Access := Node_Parents;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind t Item

            
      --# expr-start 888 IsA Is_A nodes.lkt:1592

Is_A := Item /= null 
and then Item.Kind in Lkt_Type_Decl; 
--# expr-done 888
      if Is_A then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Is_A;

         end loop;
      end;
   

   
   



--# expr-done 889



   if Find_Result = null
      or else Find_Result.Kind in Lkt_Type_Decl
   then
      
      Cast_Result := Find_Result;

   else
         Cast_Result := No_Bare_Lkt_Node;
   end if;


--# expr-done 890

         Property_Result := Cast_Result;
         
   --# end
      Finalizer_Scope_160;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_160;




            raise;
      end;



   return Property_Result;
end Env_Spec_Decl_P_Owning_Type;
--# end

   







--# property-start EnvSpecDecl.decl_type_name nodes.lkt:1594
pragma Warnings (Off, "is not referenced");

function Env_Spec_Decl_P_Decl_Type_Name
  
  (Node : Bare_Env_Spec_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Env_Spec_Decl :=
     Bare_Env_Spec_Decl (Node);
     Ent : Internal_Entity_Env_Spec_Decl :=
       Internal_Entity_Env_Spec_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_161 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_161 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_161;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 891 StringLiteral Str nodes.lkt:1594
Str := Create_String ("env spec declaration"); 
--# expr-done 891

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_161;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_161;




            raise;
      end;



   return Property_Result;
end Env_Spec_Decl_P_Decl_Type_Name;
--# end

   







--# property-start EnvSpecDecl.xref_entry_point nodes.lkt:1596
pragma Warnings (Off, "is not referenced");

function Env_Spec_Decl_P_Xref_Entry_Point
  
  (Node : Bare_Env_Spec_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Env_Spec_Decl :=
     Bare_Env_Spec_Decl (Node);
     Ent : Internal_Entity_Env_Spec_Decl :=
       Internal_Entity_Env_Spec_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := True;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Env_Spec_Decl_P_Xref_Entry_Point;
--# end

   







--# property-start EnvSpecDecl.xref_equation nodes.lkt:1598
pragma Warnings (Off, "is not referenced");

function Env_Spec_Decl_P_Xref_Equation
  
  (Node : Bare_Env_Spec_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Env_Spec_Decl :=
     Bare_Env_Spec_Decl (Node);
     Ent : Internal_Entity_Env_Spec_Decl :=
       Internal_Entity_Env_Spec_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_163 with Inline_Always;
            procedure Finalizer_Scope_576 with Inline_Always;
            procedure Finalizer_Scope_577 with Inline_Always;

      Fld : Internal_Entity_Call_Expr_List;
Item : Internal_Entity_Call_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Logic_Var;
Sym : Symbol_Type;
Fld_3 : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
And_Pred : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_4 : Bare_Call_Expr;
Fld_5 : Logic_Var;
Fld_6 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;
Fld_7 : Bare_Call_Expr_List;
Fld_8 : Internal_Entity_Info;
Bare_Item : Bare_Call_Expr;
As_Entity : Internal_Entity_Call_Expr;
Is_Null : Boolean;
If_Result : Internal_Entity_Call_Expr;
Map_Result : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;

            procedure Finalizer_Scope_163 is
            begin
                     Dec_Ref (Map_Result);
                     Dec_Ref (Logic_Boolean_Op);
            end Finalizer_Scope_163;
            procedure Finalizer_Scope_576 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_1);
            end Finalizer_Scope_576;
            procedure Finalizer_Scope_577 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_577;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 905 .logic_all Logic_Boolean_Op nodes.lkt:1599








   

   --# expr-start 892 EnvSpecDecl.actions Fld nodes.lkt:1599







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Call_Expr_List (Node => Ent.Node.Env_Spec_Decl_F_Actions, Info => Ent.Info);
--# expr-done 892









Fld_7 := Fld.Node;

   
      declare
         Map_Result_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      if Fld_7 = null then
         
      Map_Result := Create_Logic_Equation_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Call_Expr_List := Fld_7;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Call_Expr;
else
   








Fld_8 := Fld.Info;

As_Entity := (Info => Fld_8, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind action Item

            
         
         
      --# expr-start 904 LogicAnd And_Pred_1 nodes.lkt:1601
--# expr-start 898 LogicAnd And_Pred nodes.lkt:1602
--# expr-start 893 BaseCallExpr.xref_equation Fld_1 nodes.lkt:1602







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 893
--# expr-start 897 LogicAssign Bind_Result nodes.lkt:1603
--# expr-start 894 Expr.expected_type_var Fld_2 nodes.lkt:1603







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Item.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 894
Fld_2.Value := No_Entity;
Entity_Vars.Reset (Fld_2);





--# expr-start 896 LktNode.get_builtin_type Fld_3 nodes.lkt:1604







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 895 SymbolLiteral Sym nodes.lkt:1604
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Envaction); 
--# expr-done 895
--# property-call-start LktNode.get_builtin_type
Fld_3 := Liblktlang.Implementation.Lkt_Node_P_Get_Builtin_Type (Node => Ent.Node, Entity_Name => Sym);
--# end
--# expr-done 896



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_3.Node,
         Info => Fld_3.Info);


Bind_Result := Solver.Create_Assign (Fld_2, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1603:22") else null)); 
--# expr-done 897
And_Pred := Create_And (Fld_1, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1602:17") else null)); 
--# expr-done 898




   --# scope-start



--# expr-start 903 bind Dyn_Var_Bind_Result nodes.lkt:1607





--# expr-start 899 'Entity[CallExpr].node' Fld_4 nodes.lkt:1607









Fld_4 := Item.Node;
--# expr-done 899



   
      Cast_Result_1 := Fld_4;


Error_Location := Cast_Result_1; 
--# expr-start 902 LogicPropagate Pred nodes.lkt:1608
--# expr-start 900 Expr.expected_type_var Fld_5 nodes.lkt:1609







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Item.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 900
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);
--# expr-start 901 Expr.actual_type_var Fld_6 nodes.lkt:1610







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Item.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 901
Fld_6.Value := No_Entity;
Entity_Vars.Reset (Fld_6);


Pred := Solver.Create_N_Predicate ((Fld_5, Fld_6), Create_Type_Decl_P_Matching_Type_0_Predicate (2, Error_Location)); 
--# expr-done 902
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 903
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_577;


And_Pred_1 := Create_And (And_Pred, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1601:13") else null)); 
--# expr-done 904
      

         declare
            Item_To_Append : constant Logic_Equation := And_Pred_1;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_576;



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:1599:22") else null)); 
--# expr-done 905

         Property_Result := Logic_Boolean_Op;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_163;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_163;
                     Finalizer_Scope_576;
                     Finalizer_Scope_577;




            raise;
      end;



   return Property_Result;
end Env_Spec_Decl_P_Xref_Equation;
--# end

   







--# property-start 'EnvSpecDecl.[internal]internal_env_mappings_6' nodes.lkt:1619
pragma Warnings (Off, "is not referenced");

function Internal_Env_Mappings_6
  
  (Node : Bare_Env_Spec_Decl
  )

   return Internal_Env_Assoc_Array_Access
is
   Self : Bare_Env_Spec_Decl :=
     Bare_Env_Spec_Decl (Node);
      --# bind node Self

   


   Property_Result : Internal_Env_Assoc_Array_Access;

      
            procedure Finalizer_Scope_425 with Inline_Always;
            procedure Finalizer_Scope_867 with Inline_Always;

      Fld : Bare_Type_Decl;
Var_Expr : Bare_Type_Decl;
Sym : Symbol_Type;
Fld_1 : Bare_Self_Decl;
New_Struct : Internal_Designated_Env := No_Designated_Env;
Cast_Result : Bare_Lkt_Node;
New_Struct_1 : Internal_Env_Assoc := No_Env_Assoc;
Sym_1 : Symbol_Type;
Fld_2 : Bare_Node_Decl;
New_Struct_2 : Internal_Designated_Env := No_Designated_Env;
Cast_Result_1 : Bare_Lkt_Node;
New_Struct_3 : Internal_Env_Assoc := No_Env_Assoc;
Array_Lit : Internal_Env_Assoc_Array_Access;
Scope_Result : Internal_Env_Assoc_Array_Access;
Result_Var : Internal_Env_Assoc_Array_Access;

            procedure Finalizer_Scope_425 is
            begin
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Result_Var);
            end Finalizer_Scope_425;
            procedure Finalizer_Scope_867 is
            begin
                     Dec_Ref (New_Struct);
                     Dec_Ref (New_Struct_1);
                     Dec_Ref (New_Struct_2);
                     Dec_Ref (New_Struct_3);
                     Dec_Ref (Array_Lit);
            end Finalizer_Scope_867;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 916 .do Result_Var nodes.lkt:1619



--# expr-start 906 EnvSpecDecl.owning_type Fld nodes.lkt:1619







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start EnvSpecDecl.owning_type
Fld := Liblktlang.Implementation.Env_Spec_Decl_P_Owning_Type (Node => Self);
--# end
--# expr-done 906
Var_Expr := Fld;





if Var_Expr /= No_Bare_Lkt_Node then
   



   --# scope-start



--# expr-start 915 ArrayLiteral Array_Lit nodes.lkt:1621
--# expr-start 910 'New[EnvAssoc]' New_Struct_1 nodes.lkt:1622
--# expr-start 907 'New[DesignatedEnv]' New_Struct nodes.lkt:1625



Inc_Ref (Empty_Env);
New_Struct := (Direct_Env => Empty_Env, Env_Name => No_Symbol, Kind => Current_Env); 
--# expr-done 907
--# expr-start 908 SymbolLiteral Sym nodes.lkt:1623
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Self); 
--# expr-done 908






--# expr-start 909 TypeDecl.self_decl Fld_1 nodes.lkt:1624







   if Var_Expr = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.self_decl
Fld_1 := Liblktlang.Implementation.Type_Decl_P_Self_Decl (Node => Var_Expr);
--# end
--# expr-done 909



   
      Cast_Result := Fld_1;


Inc_Ref (New_Struct);
New_Struct_1 := (Dest_Env => New_Struct, Key => Sym, Metadata => No_Metadata, Value => Cast_Result); 
--# expr-done 910
--# expr-start 914 'New[EnvAssoc]' New_Struct_3 nodes.lkt:1632
--# expr-start 911 'New[DesignatedEnv]' New_Struct_2 nodes.lkt:1635



Inc_Ref (Empty_Env);
New_Struct_2 := (Direct_Env => Empty_Env, Env_Name => No_Symbol, Kind => Current_Env); 
--# expr-done 911
--# expr-start 912 SymbolLiteral Sym_1 nodes.lkt:1633
Sym_1 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Node_49); 
--# expr-done 912






--# expr-start 913 TypeDecl.node_decl Fld_2 nodes.lkt:1634







   if Var_Expr = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.node_decl
Fld_2 := Liblktlang.Implementation.Type_Decl_P_Node_Decl (Node => Var_Expr);
--# end
--# expr-done 913



   
      Cast_Result_1 := Fld_2;


Inc_Ref (New_Struct_2);
New_Struct_3 := (Dest_Env => New_Struct_2, Key => Sym_1, Metadata => No_Metadata, Value => Cast_Result_1); 
--# expr-done 914
Array_Lit := Create_Internal_Env_Assoc_Array (Internal_Internal_Env_Assoc_Array'(1 => New_Struct_1, 2 => New_Struct_3)); 
--# expr-done 915
Scope_Result := Array_Lit;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_867;


   Result_Var := Scope_Result;
else
   
   Result_Var := No_Internal_Env_Assoc_Array_Type;
end if;

      Inc_Ref (Result_Var);


--# expr-done 916

         Property_Result := Result_Var;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_425;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_425;
                     Finalizer_Scope_867;




            raise;
      end;



   return Property_Result;
end Internal_Env_Mappings_6;
--# end



   


      

   --
   --  Primitives for Bare_Error_Decl
   --

   





   







--# property-start ErrorDecl.decl_type_name nodes.lkt:1136
pragma Warnings (Off, "is not referenced");

function Error_Decl_P_Decl_Type_Name
  
  (Node : Bare_Error_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Error_Decl :=
     Bare_Error_Decl (Node);
     Ent : Internal_Entity_Error_Decl :=
       Internal_Entity_Error_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_118 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_118 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_118;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 917 StringLiteral Str nodes.lkt:1136
Str := Create_String ("syntax error declaration"); 
--# expr-done 917

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_118;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_118;




            raise;
      end;



   return Property_Result;
end Error_Decl_P_Decl_Type_Name;
--# end



   


      

   --
   --  Primitives for Bare_Generic_Decl
   --

   



   

   

   

   

   

   

   


      procedure Generic_Decl_Pre_Env_Actions
        (Self            : Bare_Generic_Decl;
         State           : in out PLE_Node_State;
         Add_To_Env_Only : Boolean := False) is
      begin
            


   

      declare
         Resolver : constant Entity_Resolver :=
            null;

         

         Mapping : Internal_Env_Assoc :=
            Liblktlang.Implementation.Internal_Env_Mappings_7 (Node => 
Self);
      begin

         Add_To_Env
           (Self,
            State,
            Mapping.Key,
            Mapping.Value,
            Mapping.Metadata,
            Resolver,
            Mapping.Dest_Env,
            DSL_Location => "nodes.lkt:1697:9");
         Dec_Ref (Mapping.Dest_Env);

      end;
   
   
            


   
      if Add_To_Env_Only then
         return;
      end if;

      declare
         No_Parent         : constant Boolean :=
            False;
         Transitive_Parent : constant Boolean :=
            False;
         Names             : Symbol_Type_Array_Access :=
            null;
      begin
         Add_Env (Self, State, No_Parent, Transitive_Parent, Names);
      end;
   
   
      end;



      
      procedure Initialize_Fields_For_Generic_Decl
        (Self : Bare_Generic_Decl
         ; Generic_Decl_F_Generic_Param_Decls : Bare_Generic_Param_Decl_List
         ; Generic_Decl_F_Decl : Bare_Decl
        ) is
      begin

            Self.Generic_Decl_F_Generic_Param_Decls := Generic_Decl_F_Generic_Param_Decls;
            Self.Generic_Decl_F_Decl := Generic_Decl_F_Decl;
         

      end Initialize_Fields_For_Generic_Decl;

      
   function Generic_Decl_F_Generic_Param_Decls
     (Node : Bare_Generic_Decl) return Bare_Generic_Param_Decl_List
   is
      

   begin
         
         return Node.Generic_Decl_F_Generic_Param_Decls;
      
   end;

      
   function Generic_Decl_F_Decl
     (Node : Bare_Generic_Decl) return Bare_Decl
   is
      

   begin
         
         return Node.Generic_Decl_F_Decl;
      
   end;


   







--# property-start GenericDecl.name nodes.lkt:1659
pragma Warnings (Off, "is not referenced");

function Generic_Decl_P_Name
  
  (Node : Bare_Generic_Decl
  )

   return Symbol_Type
is
   Self : Bare_Generic_Decl :=
     Bare_Generic_Decl (Node);
      --# bind node Self

   


   Property_Result : Symbol_Type;

      

      Fld : Bare_Decl;
Fld_1 : Symbol_Type;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 919 Decl.name Fld_1 nodes.lkt:1659



--# expr-start 918 GenericDecl.decl Fld nodes.lkt:1659







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Self.Generic_Decl_F_Decl;
--# expr-done 918



   if Fld = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_1 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Fld);
--# end
--# expr-done 919

         Property_Result := Fld_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Generic_Decl_P_Name;
--# end

   







--# property-start GenericDecl.image_suffix nodes.lkt:1662
pragma Warnings (Off, "is not referenced");

function Generic_Decl_P_Image_Suffix
  
  (Node : Bare_Generic_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Generic_Decl :=
     Bare_Generic_Decl (Node);
     Ent : Internal_Entity_Generic_Decl :=
       Internal_Entity_Generic_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_165 with Inline_Always;
            procedure Finalizer_Scope_579 with Inline_Always;
            procedure Finalizer_Scope_581 with Inline_Always;

      Str : String_Type;
Str_1 : String_Type;
Fld : Internal_Entity_Type_Decl_Array_Access;
Fld_1 : String_Type;
Map_Result : String_Type_Array_Access;
Join_Result : String_Type;
Fld_2 : Internal_Entity_Info;
Fld_3 : Env_Rebindings;
Is_Equal : Boolean;
Str_2 : String_Type;
Fld_4 : Internal_Entity_Generic_Param_Decl_List;
Item_1 : Internal_Entity_Full_Decl;
Fld_5 : Internal_Entity_Decl;
Fld_6 : String_Type;
Fld_7 : Bare_Generic_Param_Decl_List;
Fld_8 : Internal_Entity_Info;
Bare_Item_1 : Bare_Full_Decl;
As_Entity : Internal_Entity_Full_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Full_Decl;
Map_Result_1 : String_Type_Array_Access;
Join_Result_1 : String_Type;
If_Result_1 : String_Type;
Concat_Result : String_Type;
Str_3 : String_Type;
Concat_Result_1 : String_Type;

            procedure Finalizer_Scope_165 is
            begin
                     Dec_Ref (Str);
                     Dec_Ref (Str_1);
                     Dec_Ref (Fld);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Join_Result);
                     Dec_Ref (Str_2);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (Join_Result_1);
                     Dec_Ref (If_Result_1);
                     Dec_Ref (Concat_Result);
                     Dec_Ref (Str_3);
                     Dec_Ref (Concat_Result_1);
            end Finalizer_Scope_165;
            procedure Finalizer_Scope_579 is
            begin
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_579;
            procedure Finalizer_Scope_581 is
            begin
                     Dec_Ref (Fld_6);
            end Finalizer_Scope_581;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 938 StringConcat Concat_Result_1 nodes.lkt:1663
--# expr-start 936 StringConcat Concat_Result nodes.lkt:1663
--# expr-start 920 StringLiteral Str nodes.lkt:1663
Str := Create_String ("["); 
--# expr-done 920
--# expr-start 935 If If_Result_1 nodes.lkt:1668



--# expr-start 923 .is_null Is_Equal nodes.lkt:1668
--# expr-start 922 EntityInfo.rebindings Fld_3 nodes.lkt:1668



--# expr-start 921 'Entity[GenericDecl].info' Fld_2 nodes.lkt:1668









Fld_2 := Ent.Info;
--# expr-done 921





Fld_3 := Fld_2.Rebindings;
--# expr-done 922

Is_Equal := Fld_3 = null; 
--# expr-done 923
if Is_Equal then
   --# expr-start 929 .join Join_Result_1 nodes.lkt:1670
--# expr-start 924 StringLiteral Str_2 nodes.lkt:1670
Str_2 := Create_String (", "); 
--# expr-done 924
--# expr-start 928 .map Map_Result_1 nodes.lkt:1670








   

   --# expr-start 925 GenericDecl.generic_param_decls Fld_4 nodes.lkt:1670







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Generic_Param_Decl_List (Node => Ent.Node.Generic_Decl_F_Generic_Param_Decls, Info => Ent.Info);
--# expr-done 925









Fld_7 := Fld_4.Node;

   
      declare
         Map_Result_1_Vec : String_Type_Vectors.Vector;
      begin
   

   

      if Fld_7 = null then
         
      Map_Result_1 := Create_String_Type_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Generic_Param_Decl_List := Fld_7;
      begin
         for Untyped_Item_1 of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item_1 := Untyped_Item_1; 
                  



Is_Null := Bare_Item_1 = null; 
if Is_Null then
   
   If_Result := No_Entity_Full_Decl;
else
   








Fld_8 := Fld_4.Info;

As_Entity := (Info => Fld_8, Node => Bare_Item_1); 
   If_Result := As_Entity;
end if;



                  Item_1 := If_Result; 

            
   --# scope-start


               --# bind gp Item_1

            
         
         
      --# expr-start 927 Decl.full_name_internal Fld_6 nodes.lkt:1671



--# expr-start 926 FullDecl.decl Fld_5 nodes.lkt:1671







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Decl (Node => Item_1.Node.Full_Decl_F_Decl, Info => Item_1.Info);
--# expr-done 926



   if Fld_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.full_name_internal'
Fld_6 := Liblktlang.Implementation.Dispatcher_Decl_P_Full_Name_Internal (Node => Fld_5.Node, E_Info => Fld_5.Info);
--# end
--# expr-done 927
      

         declare
            Item_To_Append : constant String_Type := Fld_6;
         begin
               Inc_Ref (Item_To_Append);
            String_Type_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_581;



         end loop;
      end;
   
      end if;

   

         Map_Result_1 := Create_String_Type_Array
           (Items_Count => Natural (String_Type_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := String_Type_Vectors.Get
              (Map_Result_1_Vec,
               I + String_Type_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         String_Type_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 928
Join_Result_1 := Join_Strings (Str_2, Map_Result_1); 
--# expr-done 929
   If_Result_1 := Join_Result_1;
else
   --# expr-start 934 .join Join_Result nodes.lkt:1674
--# expr-start 930 StringLiteral Str_1 nodes.lkt:1674
Str_1 := Create_String (", "); 
--# expr-done 930
--# expr-start 933 .map Map_Result nodes.lkt:1674








   

   --# expr-start 931 GenericDecl.instantiated_generic_params Fld nodes.lkt:1674







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start GenericDecl.instantiated_generic_params
Fld := Liblktlang.Implementation.Generic_Decl_P_Instantiated_Generic_Params (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 931

   
      declare
         Map_Result_Vec : String_Type_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Type_Decl_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind gp Item

            
         
         
      --# expr-start 932 Decl.full_name_internal Fld_1 nodes.lkt:1675







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.full_name_internal'
Fld_1 := Liblktlang.Implementation.Dispatcher_Decl_P_Full_Name_Internal (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 932
      

         declare
            Item_To_Append : constant String_Type := Fld_1;
         begin
               Inc_Ref (Item_To_Append);
            String_Type_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_579;



         end loop;
      end;
   

   

         Map_Result := Create_String_Type_Array
           (Items_Count => Natural (String_Type_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := String_Type_Vectors.Get
              (Map_Result_Vec,
               I + String_Type_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         String_Type_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 933
Join_Result := Join_Strings (Str_1, Map_Result); 
--# expr-done 934
   If_Result_1 := Join_Result;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 935
Concat_Result := Concat_String (Str, If_Result_1); 
--# expr-done 936
--# expr-start 937 StringLiteral Str_3 nodes.lkt:1677
Str_3 := Create_String ("]"); 
--# expr-done 937
Concat_Result_1 := Concat_String (Concat_Result, Str_3); 
--# expr-done 938

         Property_Result := Concat_Result_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_165;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_165;
                     Finalizer_Scope_579;
                     Finalizer_Scope_581;




            raise;
      end;



   return Property_Result;
end Generic_Decl_P_Image_Suffix;
--# end

   







--# property-start GenericDecl.generic_params nodes.lkt:1679
pragma Warnings (Off, "is not referenced");

function Generic_Decl_P_Generic_Params
  
  (Node : Bare_Generic_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Generic_Param_Type_Decl_Array_Access
is
   Self : Bare_Generic_Decl :=
     Bare_Generic_Decl (Node);
     Ent : Internal_Entity_Generic_Decl :=
       Internal_Entity_Generic_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Generic_Param_Type_Decl_Array_Access;

      
            procedure Finalizer_Scope_167 with Inline_Always;

      Fld : Internal_Entity_Generic_Param_Decl_List;
Item : Internal_Entity_Full_Decl;
Fld_1 : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Generic_Param_Type_Decl;
Fld_2 : Bare_Generic_Param_Decl_List;
Fld_3 : Internal_Entity_Info;
Bare_Item : Bare_Full_Decl;
As_Entity : Internal_Entity_Full_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Full_Decl;
Map_Result : Internal_Entity_Generic_Param_Type_Decl_Array_Access;

            procedure Finalizer_Scope_167 is
            begin
                     Dec_Ref (Map_Result);
            end Finalizer_Scope_167;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 942 .map Map_Result nodes.lkt:1680








   

   --# expr-start 939 GenericDecl.generic_param_decls Fld nodes.lkt:1680







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Generic_Param_Decl_List (Node => Ent.Node.Generic_Decl_F_Generic_Param_Decls, Info => Ent.Info);
--# expr-done 939









Fld_2 := Fld.Node;

   
      declare
         Map_Result_Vec : Internal_Entity_Generic_Param_Type_Decl_Vectors.Vector;
      begin
   

   

      if Fld_2 = null then
         
      Map_Result := Create_Internal_Entity_Generic_Param_Type_Decl_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Generic_Param_Decl_List := Fld_2;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Full_Decl;
else
   








Fld_3 := Fld.Info;

As_Entity := (Info => Fld_3, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind gfd Item

            
         
         
      --# expr-start 941 Cast Cast_Result nodes.lkt:1681





--# expr-start 940 FullDecl.decl Fld_1 nodes.lkt:1681







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Decl (Node => Item.Node.Full_Decl_F_Decl, Info => Item.Info);
--# expr-done 940



   if Fld_1.Node = null
      or else Fld_1.Node.Kind in Lkt_Generic_Param_Type_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Generic_Param_Type_Decl
        (Node => Fld_1.Node,
         Info => Fld_1.Info);

   else
         Cast_Result := No_Entity_Generic_Param_Type_Decl;
   end if;


--# expr-done 941
      

         declare
            Item_To_Append : constant Internal_Entity_Generic_Param_Type_Decl := Cast_Result;
         begin
            Internal_Entity_Generic_Param_Type_Decl_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Internal_Entity_Generic_Param_Type_Decl_Array
           (Items_Count => Natural (Internal_Entity_Generic_Param_Type_Decl_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Generic_Param_Type_Decl_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Generic_Param_Type_Decl_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Generic_Param_Type_Decl_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 942

         Property_Result := Map_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_167;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_167;




            raise;
      end;



   return Property_Result;
end Generic_Decl_P_Generic_Params;
--# end

   







--# property-start GenericDecl.generic_params_names nodes.lkt:1684
pragma Warnings (Off, "is not referenced");

function Generic_Decl_P_Generic_Params_Names
  
  (Node : Bare_Generic_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Symbol_Type_Array_Access
is
   Self : Bare_Generic_Decl :=
     Bare_Generic_Decl (Node);
     Ent : Internal_Entity_Generic_Decl :=
       Internal_Entity_Generic_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Symbol_Type_Array_Access;

      
            procedure Finalizer_Scope_169 with Inline_Always;

      Fld : Internal_Entity_Generic_Param_Decl_List;
Item : Internal_Entity_Full_Decl;
Fld_1 : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Generic_Param_Type_Decl;
Fld_2 : Symbol_Type;
Fld_3 : Bare_Generic_Param_Decl_List;
Fld_4 : Internal_Entity_Info;
Bare_Item : Bare_Full_Decl;
As_Entity : Internal_Entity_Full_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Full_Decl;
Map_Result : Symbol_Type_Array_Access;

            procedure Finalizer_Scope_169 is
            begin
                     Dec_Ref (Map_Result);
            end Finalizer_Scope_169;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 947 .map Map_Result nodes.lkt:1685








   

   --# expr-start 943 GenericDecl.generic_param_decls Fld nodes.lkt:1685







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Generic_Param_Decl_List (Node => Ent.Node.Generic_Decl_F_Generic_Param_Decls, Info => Ent.Info);
--# expr-done 943









Fld_3 := Fld.Node;

   
      declare
         Map_Result_Vec : Symbol_Type_Vectors.Vector;
      begin
   

   

      if Fld_3 = null then
         
      Map_Result := Create_Symbol_Type_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Generic_Param_Decl_List := Fld_3;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Full_Decl;
else
   








Fld_4 := Fld.Info;

As_Entity := (Info => Fld_4, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind gfd Item

            
         
         
      --# expr-start 946 Decl.name Fld_2 nodes.lkt:1686



--# expr-start 945 Cast Cast_Result nodes.lkt:1686





--# expr-start 944 FullDecl.decl Fld_1 nodes.lkt:1686







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Decl (Node => Item.Node.Full_Decl_F_Decl, Info => Item.Info);
--# expr-done 944



   if Fld_1.Node = null
      or else Fld_1.Node.Kind in Lkt_Generic_Param_Type_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Generic_Param_Type_Decl
        (Node => Fld_1.Node,
         Info => Fld_1.Info);

   else
         Cast_Result := No_Entity_Generic_Param_Type_Decl;
   end if;


--# expr-done 945



   if Cast_Result.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_2 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Cast_Result.Node);
--# end
--# expr-done 946
      

         declare
            Item_To_Append : constant Symbol_Type := Fld_2;
         begin
            Symbol_Type_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Symbol_Type_Array
           (Items_Count => Natural (Symbol_Type_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Symbol_Type_Vectors.Get
              (Map_Result_Vec,
               I + Symbol_Type_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Symbol_Type_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 947

         Property_Result := Map_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_169;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_169;




            raise;
      end;



   return Property_Result;
end Generic_Decl_P_Generic_Params_Names;
--# end

   







--# property-start GenericDecl.decl_type_name nodes.lkt:1689
pragma Warnings (Off, "is not referenced");

function Generic_Decl_P_Decl_Type_Name
  
  (Node : Bare_Generic_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Generic_Decl :=
     Bare_Generic_Decl (Node);
     Ent : Internal_Entity_Generic_Decl :=
       Internal_Entity_Generic_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_170 with Inline_Always;

      Str : String_Type;
Fld : Internal_Entity_Decl;
Fld_1 : String_Type;
Concat_Result : String_Type;

            procedure Finalizer_Scope_170 is
            begin
                     Dec_Ref (Str);
                     Dec_Ref (Fld_1);
                     Dec_Ref (Concat_Result);
            end Finalizer_Scope_170;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 951 StringConcat Concat_Result nodes.lkt:1689
--# expr-start 948 StringLiteral Str nodes.lkt:1689
Str := Create_String ("generic "); 
--# expr-done 948
--# expr-start 950 Decl.decl_type_name Fld_1 nodes.lkt:1689



--# expr-start 949 GenericDecl.decl Fld nodes.lkt:1689







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Decl (Node => Ent.Node.Generic_Decl_F_Decl, Info => Ent.Info);
--# expr-done 949



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.decl_type_name'
Fld_1 := Liblktlang.Implementation.Dispatcher_Decl_P_Decl_Type_Name (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 950
Concat_Result := Concat_String (Str, Fld_1); 
--# expr-done 951

         Property_Result := Concat_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_170;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_170;




            raise;
      end;



   return Property_Result;
end Generic_Decl_P_Decl_Type_Name;
--# end

   







--# property-start GenericDecl.instantiated_generic_params nodes.lkt:1691
pragma Warnings (Off, "is not referenced");

function Generic_Decl_P_Instantiated_Generic_Params
  
  (Node : Bare_Generic_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl_Array_Access
is
   Self : Bare_Generic_Decl :=
     Bare_Generic_Decl (Node);
     Ent : Internal_Entity_Generic_Decl :=
       Internal_Entity_Generic_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl_Array_Access;

      
            procedure Finalizer_Scope_171 with Inline_Always;
            procedure Finalizer_Scope_584 with Inline_Always;

      Fld : Internal_Entity_Generic_Param_Decl_List;
Item : Internal_Entity_Full_Decl;
Fld_1 : Lexical_Env := Empty_Env;
Fld_2 : Internal_Entity_Decl;
Fld_3 : Symbol_Type;
Env_Get_Result : Internal_Entity;
Cast_Result : Internal_Entity_Type_Decl;
Fld_4 : Bare_Generic_Param_Decl_List;
Fld_5 : Internal_Entity_Info;
Bare_Item : Bare_Full_Decl;
As_Entity : Internal_Entity_Full_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Full_Decl;
Map_Result : Internal_Entity_Type_Decl_Array_Access;

            procedure Finalizer_Scope_171 is
            begin
                     Dec_Ref (Map_Result);
            end Finalizer_Scope_171;
            procedure Finalizer_Scope_584 is
            begin
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_584;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 958 .map Map_Result nodes.lkt:1692








   

   --# expr-start 952 GenericDecl.generic_param_decls Fld nodes.lkt:1692







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Generic_Param_Decl_List (Node => Ent.Node.Generic_Decl_F_Generic_Param_Decls, Info => Ent.Info);
--# expr-done 952









Fld_4 := Fld.Node;

   
      declare
         Map_Result_Vec : Internal_Entity_Type_Decl_Vectors.Vector;
      begin
   

   

      if Fld_4 = null then
         
      Map_Result := Create_Internal_Entity_Type_Decl_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Generic_Param_Decl_List := Fld_4;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Full_Decl;
else
   








Fld_5 := Fld.Info;

As_Entity := (Info => Fld_5, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind gfd Item

            
         
         
      --# expr-start 957 Cast Cast_Result nodes.lkt:1693





--# expr-start 956 .get_first Env_Get_Result nodes.lkt:1693
--# expr-start 953 LktNode.children_env Fld_1 nodes.lkt:1693







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Liblktlang.Implementation.Children_Env (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 953
--# expr-start 955 Decl.name Fld_3 nodes.lkt:1693



--# expr-start 954 FullDecl.decl Fld_2 nodes.lkt:1693







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Decl (Node => Item.Node.Full_Decl_F_Decl, Info => Item.Info);
--# expr-done 954



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_3 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Fld_2.Node);
--# end
--# expr-done 955


Env_Get_Result := AST_Envs.Get_First (Self => Fld_1, Key => Thin (Fld_3), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 956



   if Env_Get_Result.Node = null
      or else Env_Get_Result.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => Env_Get_Result.Node,
         Info => Env_Get_Result.Info);

   else
         Cast_Result := No_Entity_Type_Decl;
   end if;


--# expr-done 957
      

         declare
            Item_To_Append : constant Internal_Entity_Type_Decl := Cast_Result;
         begin
            Internal_Entity_Type_Decl_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_584;



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Internal_Entity_Type_Decl_Array
           (Items_Count => Natural (Internal_Entity_Type_Decl_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Type_Decl_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Type_Decl_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Type_Decl_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 958

         Property_Result := Map_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_171;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_171;
                     Finalizer_Scope_584;




            raise;
      end;



   return Property_Result;
end Generic_Decl_P_Instantiated_Generic_Params;
--# end

   







--# property-start 'GenericDecl.[internal]internal_env_mappings_7' nodes.lkt:1697
pragma Warnings (Off, "is not referenced");

function Internal_Env_Mappings_7
  
  (Node : Bare_Generic_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Env_Assoc
is
   Self : Bare_Generic_Decl :=
     Bare_Generic_Decl (Node);
     Ent : Internal_Entity_Generic_Decl :=
       Internal_Entity_Generic_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Env_Assoc;

      
            procedure Finalizer_Scope_427 with Inline_Always;

      Fld : Symbol_Type;
Cast_Result : Bare_Lkt_Node;
New_Struct : Internal_Designated_Env := No_Designated_Env;
New_Struct_1 : Internal_Env_Assoc := No_Env_Assoc;

            procedure Finalizer_Scope_427 is
            begin
                     Dec_Ref (New_Struct);
                     Dec_Ref (New_Struct_1);
            end Finalizer_Scope_427;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         


Inc_Ref (Empty_Env);
New_Struct := (Direct_Env => Empty_Env, Env_Name => No_Symbol, Kind => Current_Env); 
--# expr-start 959 GenericDecl.name Fld nodes.lkt:1697







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Ent.Node);
--# end
--# expr-done 959










   
      Cast_Result := Self;


Inc_Ref (New_Struct);
New_Struct_1 := (Dest_Env => New_Struct, Key => Fld, Metadata => No_Metadata, Value => Cast_Result); 

         Property_Result := New_Struct_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_427;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_427;




            raise;
      end;



   return Property_Result;
end Internal_Env_Mappings_7;
--# end



   


      

   --
   --  Primitives for Bare_Grammar_Decl
   --

   



   

   

   

   

   

   

   


      procedure Grammar_Decl_Pre_Env_Actions
        (Self            : Bare_Grammar_Decl;
         State           : in out PLE_Node_State;
         Add_To_Env_Only : Boolean := False) is
      begin
            


   

      declare
         Resolver : constant Entity_Resolver :=
            null;

         

         Mapping : Internal_Env_Assoc :=
            Liblktlang.Implementation.Internal_Env_Mappings_8 (Node => 
Self);
      begin

         Add_To_Env
           (Self,
            State,
            Mapping.Key,
            Mapping.Value,
            Mapping.Metadata,
            Resolver,
            Mapping.Dest_Env,
            DSL_Location => "nodes.lkt:1712:9");
         Dec_Ref (Mapping.Dest_Env);

      end;
   
   
            


   
      if Add_To_Env_Only then
         return;
      end if;

      declare
         No_Parent         : constant Boolean :=
            False;
         Transitive_Parent : constant Boolean :=
            False;
         Names             : Symbol_Type_Array_Access :=
            null;
      begin
         Add_Env (Self, State, No_Parent, Transitive_Parent, Names);
      end;
   
   
      end;



      
      procedure Initialize_Fields_For_Grammar_Decl
        (Self : Bare_Grammar_Decl
         ; Grammar_Decl_F_Syn_Name : Bare_Def_Id
         ; Grammar_Decl_F_Rules : Bare_Full_Decl_List
        ) is
      begin

            Self.Grammar_Decl_F_Syn_Name := Grammar_Decl_F_Syn_Name;
            Self.Grammar_Decl_F_Rules := Grammar_Decl_F_Rules;
         

      end Initialize_Fields_For_Grammar_Decl;

      
   function Grammar_Decl_F_Rules
     (Node : Bare_Grammar_Decl) return Bare_Full_Decl_List
   is
      

   begin
         
         return Node.Grammar_Decl_F_Rules;
      
   end;


   







--# property-start GrammarDecl.decl_type_name nodes.lkt:1709
pragma Warnings (Off, "is not referenced");

function Grammar_Decl_P_Decl_Type_Name
  
  (Node : Bare_Grammar_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Grammar_Decl :=
     Bare_Grammar_Decl (Node);
     Ent : Internal_Entity_Grammar_Decl :=
       Internal_Entity_Grammar_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_172 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_172 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_172;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 960 StringLiteral Str nodes.lkt:1709
Str := Create_String ("grammar declaration"); 
--# expr-done 960

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_172;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_172;




            raise;
      end;



   return Property_Result;
end Grammar_Decl_P_Decl_Type_Name;
--# end

   







--# property-start 'GrammarDecl.[internal]internal_env_mappings_8' nodes.lkt:1712
pragma Warnings (Off, "is not referenced");

function Internal_Env_Mappings_8
  
  (Node : Bare_Grammar_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Env_Assoc
is
   Self : Bare_Grammar_Decl :=
     Bare_Grammar_Decl (Node);
     Ent : Internal_Entity_Grammar_Decl :=
       Internal_Entity_Grammar_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Env_Assoc;

      
            procedure Finalizer_Scope_429 with Inline_Always;

      Fld : Symbol_Type;
Cast_Result : Bare_Lkt_Node;
New_Struct : Internal_Designated_Env := No_Designated_Env;
New_Struct_1 : Internal_Env_Assoc := No_Env_Assoc;

            procedure Finalizer_Scope_429 is
            begin
                     Dec_Ref (New_Struct);
                     Dec_Ref (New_Struct_1);
            end Finalizer_Scope_429;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         


Inc_Ref (Empty_Env);
New_Struct := (Direct_Env => Empty_Env, Env_Name => No_Symbol, Kind => Current_Env); 
--# expr-start 961 Decl.name Fld nodes.lkt:1712







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Ent.Node);
--# end
--# expr-done 961










   
      Cast_Result := Self;


Inc_Ref (New_Struct);
New_Struct_1 := (Dest_Env => New_Struct, Key => Fld, Metadata => No_Metadata, Value => Cast_Result); 

         Property_Result := New_Struct_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_429;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_429;




            raise;
      end;



   return Property_Result;
end Internal_Env_Mappings_8;
--# end



   


      

   --
   --  Primitives for Bare_Lexer_Decl
   --

   



   

   

   

   

   

   

   


      procedure Lexer_Decl_Pre_Env_Actions
        (Self            : Bare_Lexer_Decl;
         State           : in out PLE_Node_State;
         Add_To_Env_Only : Boolean := False) is
      begin
            


   

      declare
         Resolver : constant Entity_Resolver :=
            null;

         

         Mapping : Internal_Env_Assoc :=
            Liblktlang.Implementation.Internal_Env_Mappings_9 (Node => 
Self);
      begin

         Add_To_Env
           (Self,
            State,
            Mapping.Key,
            Mapping.Value,
            Mapping.Metadata,
            Resolver,
            Mapping.Dest_Env,
            DSL_Location => "nodes.lkt:1743:9");
         Dec_Ref (Mapping.Dest_Env);

      end;
   
   
            


   
      if Add_To_Env_Only then
         return;
      end if;

      declare
         No_Parent         : constant Boolean :=
            False;
         Transitive_Parent : constant Boolean :=
            False;
         Names             : Symbol_Type_Array_Access :=
            null;
      begin
         Add_Env (Self, State, No_Parent, Transitive_Parent, Names);
      end;
   
   
            


   

      declare
         Resolver : constant Entity_Resolver :=
            null;

         

         Mappings : Internal_Env_Assoc_Array_Access :=
            Liblktlang.Implementation.Internal_Env_Mappings_10 (Node => 
Self);
      begin
         for Mapping of Mappings.Items loop

         Add_To_Env
           (Self,
            State,
            Mapping.Key,
            Mapping.Value,
            Mapping.Metadata,
            Resolver,
            Mapping.Dest_Env,
            DSL_Location => "nodes.lkt:1745:9");

         end loop;
         Dec_Ref (Mappings);
      end;
   
   
      end;



      
      procedure Initialize_Fields_For_Lexer_Decl
        (Self : Bare_Lexer_Decl
         ; Lexer_Decl_F_Syn_Name : Bare_Def_Id
         ; Lexer_Decl_F_Rules : Bare_Lkt_Node_List
        ) is
      begin

            Self.Lexer_Decl_F_Syn_Name := Lexer_Decl_F_Syn_Name;
            Self.Lexer_Decl_F_Rules := Lexer_Decl_F_Rules;
         

      end Initialize_Fields_For_Lexer_Decl;

      
   function Lexer_Decl_F_Rules
     (Node : Bare_Lexer_Decl) return Bare_Lkt_Node_List
   is
      

   begin
         
         return Node.Lexer_Decl_F_Rules;
      
   end;


   







--# property-start LexerDecl.decl_type_name nodes.lkt:1724
pragma Warnings (Off, "is not referenced");

function Lexer_Decl_P_Decl_Type_Name
  
  (Node : Bare_Lexer_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Lexer_Decl :=
     Bare_Lexer_Decl (Node);
     Ent : Internal_Entity_Lexer_Decl :=
       Internal_Entity_Lexer_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_173 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_173 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_173;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 962 StringLiteral Str nodes.lkt:1724
Str := Create_String ("lexer declaration"); 
--# expr-done 962

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_173;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_173;




            raise;
      end;



   return Property_Result;
end Lexer_Decl_P_Decl_Type_Name;
--# end

   







--# property-start LexerDecl.builtin_decls nodes.lkt:1727
pragma Warnings (Off, "is not referenced");

function Lexer_Decl_P_Builtin_Decls
  
  (Node : Bare_Lexer_Decl
  )

   return Internal_Env_Assoc_Array_Access
is
   Self : Bare_Lexer_Decl :=
     Bare_Lexer_Decl (Node);
      --# bind node Self

   


   Property_Result : Internal_Env_Assoc_Array_Access;

      
            procedure Finalizer_Scope_175 with Inline_Always;
            procedure Finalizer_Scope_585 with Inline_Always;

      Sym : Symbol_Type;
Sym_1 : Symbol_Type;
Sym_2 : Symbol_Type;
Array_Lit : Symbol_Type_Array_Access;
New_Node : Bare_Synthetic_Lexer_Decl;
Fld : Lexical_Env := Empty_Env;
New_Struct : Internal_Designated_Env := No_Designated_Env;
Cast_Result : Bare_Lkt_Node;
New_Struct_1 : Internal_Env_Assoc := No_Env_Assoc;
Map_Result : Internal_Env_Assoc_Array_Access;

            procedure Finalizer_Scope_175 is
            begin
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Map_Result);
            end Finalizer_Scope_175;
            procedure Finalizer_Scope_585 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (New_Struct);
                     Dec_Ref (New_Struct_1);
            end Finalizer_Scope_585;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Lexer_Decl_Lexer_Decl_P_Builtin_Decls,
            Items    => new Mmz_Key_Array (1 ..  1))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Lexer_Decl,
                                As_Bare_Lexer_Decl => Self);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Env_Assoc_Array_Access;
                  Inc_Ref (Property_Result);

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 971 .map Map_Result nodes.lkt:1728








   

   --# expr-start 966 ArrayLiteral Array_Lit nodes.lkt:1728
--# expr-start 963 SymbolLiteral Sym nodes.lkt:1728
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Newline); 
--# expr-done 963
--# expr-start 964 SymbolLiteral Sym_1 nodes.lkt:1728
Sym_1 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Indent); 
--# expr-done 964
--# expr-start 965 SymbolLiteral Sym_2 nodes.lkt:1728
Sym_2 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Dedent); 
--# expr-done 965
Array_Lit := Create_Symbol_Type_Array (Internal_Symbol_Type_Array'(1 => Sym, 2 => Sym_1, 3 => Sym_2)); 
--# expr-done 966

   
      declare
         Map_Result_Vec : Internal_Env_Assoc_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Symbol_Type_Array_Access := Array_Lit;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind sym Item

            
         
         
      --# expr-start 970 'New[EnvAssoc]' New_Struct_1 nodes.lkt:1730
--# expr-start 968 'New[DesignatedEnv]' New_Struct nodes.lkt:1733
--# expr-start 967 LktNode.children_env Fld nodes.lkt:1736







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Children_Env (Node => Self);
--# expr-done 967


Inc_Ref (Fld);
New_Struct := (Direct_Env => Fld, Env_Name => No_Symbol, Kind => Direct_Env); 
--# expr-done 968







--# expr-start 969 'New[SyntheticLexerDecl]' New_Node nodes.lkt:1732



if Is_Foreign_Strict (Self.Self_Env, Self) then
   Raise_Property_Exception
     (Self,
      Property_Error'Identity,
      "synthetic nodes cannot have foreign lexical envs");
end if;


New_Node := new Root_Node_Record
  (Lkt_Synthetic_Lexer_Decl);
Initialize
  (Self => New_Node,
   Kind => Lkt_Synthetic_Lexer_Decl,
   Unit => Self.Unit,

   Token_Start_Index => No_Token_Index,
   Token_End_Index   => No_Token_Index,

   Parent => Self,

   Self_Env => Self.Self_Env);
Register_Destroyable (Self.Unit, New_Node);


      New_Node.Synthetic_Lexer_Decl_F_Sym :=
         Item;

--# expr-done 969



   
      Cast_Result := New_Node;


Inc_Ref (New_Struct);
New_Struct_1 := (Dest_Env => New_Struct, Key => Item, Metadata => No_Metadata, Value => Cast_Result); 
--# expr-done 970
      

         declare
            Item_To_Append : constant Internal_Env_Assoc := New_Struct_1;
         begin
               Inc_Ref (Item_To_Append);
            Internal_Env_Assoc_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_585;



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Env_Assoc_Array
           (Items_Count => Natural (Internal_Env_Assoc_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Env_Assoc_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Env_Assoc_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Env_Assoc_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 971

         Property_Result := Map_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_175;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_175;
                     Finalizer_Scope_585;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Env_Assoc_Array_Access,
                     As_Internal_Env_Assoc_Array_Access => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
            if Mmz_Stored then
               Inc_Ref (Property_Result);
            end if;
      end if;



   return Property_Result;
end Lexer_Decl_P_Builtin_Decls;
--# end

   







--# property-start 'LexerDecl.[internal]internal_env_mappings_9' nodes.lkt:1743
pragma Warnings (Off, "is not referenced");

function Internal_Env_Mappings_9
  
  (Node : Bare_Lexer_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Env_Assoc
is
   Self : Bare_Lexer_Decl :=
     Bare_Lexer_Decl (Node);
     Ent : Internal_Entity_Lexer_Decl :=
       Internal_Entity_Lexer_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Env_Assoc;

      
            procedure Finalizer_Scope_431 with Inline_Always;

      Fld : Symbol_Type;
Cast_Result : Bare_Lkt_Node;
New_Struct : Internal_Designated_Env := No_Designated_Env;
New_Struct_1 : Internal_Env_Assoc := No_Env_Assoc;

            procedure Finalizer_Scope_431 is
            begin
                     Dec_Ref (New_Struct);
                     Dec_Ref (New_Struct_1);
            end Finalizer_Scope_431;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         


Inc_Ref (Empty_Env);
New_Struct := (Direct_Env => Empty_Env, Env_Name => No_Symbol, Kind => Current_Env); 
--# expr-start 972 Decl.name Fld nodes.lkt:1743







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Ent.Node);
--# end
--# expr-done 972










   
      Cast_Result := Self;


Inc_Ref (New_Struct);
New_Struct_1 := (Dest_Env => New_Struct, Key => Fld, Metadata => No_Metadata, Value => Cast_Result); 

         Property_Result := New_Struct_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_431;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_431;




            raise;
      end;



   return Property_Result;
end Internal_Env_Mappings_9;
--# end

   







--# property-start 'LexerDecl.[internal]internal_env_mappings_10' nodes.lkt:1745
pragma Warnings (Off, "is not referenced");

function Internal_Env_Mappings_10
  
  (Node : Bare_Lexer_Decl
  )

   return Internal_Env_Assoc_Array_Access
is
   Self : Bare_Lexer_Decl :=
     Bare_Lexer_Decl (Node);
      --# bind node Self

   


   Property_Result : Internal_Env_Assoc_Array_Access;

      
            procedure Finalizer_Scope_432 with Inline_Always;

      Fld : Internal_Env_Assoc_Array_Access;

            procedure Finalizer_Scope_432 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_432;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 973 LexerDecl.builtin_decls Fld nodes.lkt:1745







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LexerDecl.builtin_decls
Fld := Liblktlang.Implementation.Lexer_Decl_P_Builtin_Decls (Node => Self);
--# end
--# expr-done 973

         Property_Result := Fld;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_432;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_432;




            raise;
      end;



   return Property_Result;
end Internal_Env_Mappings_10;
--# end



   


      

   --
   --  Primitives for Bare_Lexer_Family_Decl
   --

   



      
      procedure Initialize_Fields_For_Lexer_Family_Decl
        (Self : Bare_Lexer_Family_Decl
         ; Lexer_Family_Decl_F_Syn_Name : Bare_Def_Id
         ; Lexer_Family_Decl_F_Rules : Bare_Full_Decl_List
        ) is
      begin

            Self.Lexer_Family_Decl_F_Syn_Name := Lexer_Family_Decl_F_Syn_Name;
            Self.Lexer_Family_Decl_F_Rules := Lexer_Family_Decl_F_Rules;
         

      end Initialize_Fields_For_Lexer_Family_Decl;

      
   function Lexer_Family_Decl_F_Rules
     (Node : Bare_Lexer_Family_Decl) return Bare_Full_Decl_List
   is
      

   begin
         
         return Node.Lexer_Family_Decl_F_Rules;
      
   end;


   







--# property-start LexerFamilyDecl.decl_type_name nodes.lkt:1756
pragma Warnings (Off, "is not referenced");

function Lexer_Family_Decl_P_Decl_Type_Name
  
  (Node : Bare_Lexer_Family_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Lexer_Family_Decl :=
     Bare_Lexer_Family_Decl (Node);
     Ent : Internal_Entity_Lexer_Family_Decl :=
       Internal_Entity_Lexer_Family_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_176 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_176 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_176;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 974 StringLiteral Str nodes.lkt:1756
Str := Create_String ("lexer family declaration"); 
--# expr-done 974

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_176;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_176;




            raise;
      end;



   return Property_Result;
end Lexer_Family_Decl_P_Decl_Type_Name;
--# end



   


      

   --
   --  Primitives for Bare_Synth_Fun_Decl
   --

   



      
      procedure Initialize_Fields_For_Synth_Fun_Decl
        (Self : Bare_Synth_Fun_Decl
        ) is
      begin

         
      Self.Synth_Fun_Decl_F_Params := No_Internal_Resolved_Param_Array_Type;
      Self.Synth_Fun_Decl_F_Return_Type := No_Entity_Type_Decl;

      end Initialize_Fields_For_Synth_Fun_Decl;


   







--# property-start SynthFunDecl.function_type_aux nodes.lkt:1780
pragma Warnings (Off, "is not referenced");

function Synth_Fun_Decl_P_Function_Type_Aux
  
  (Node : Bare_Synth_Fun_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Function_Type
is
   Self : Bare_Synth_Fun_Decl :=
     Bare_Synth_Fun_Decl (Node);
     Ent : Internal_Entity_Synth_Fun_Decl :=
       Internal_Entity_Synth_Fun_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Function_Type;

      
            procedure Finalizer_Scope_179 with Inline_Always;

      Fld : Internal_Resolved_Param_Array_Access;
Fld_1 : Internal_Entity_Type_Decl;
Map_Result : Internal_Entity_Type_Decl_Array_Access;
Fld_2 : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity_Decl;
Fld_3 : Internal_Entity_Function_Type;

            procedure Finalizer_Scope_179 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Map_Result);
            end Finalizer_Scope_179;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 979 LktNode.function_type_helper Fld_3 nodes.lkt:1781







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 977 .map Map_Result nodes.lkt:1782








   

   --# expr-start 975 SynthFunDecl.params Fld nodes.lkt:1782







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Ent.Node.Synth_Fun_Decl_F_Params;
Inc_Ref (Fld);
--# expr-done 975

   
      declare
         Map_Result_Vec : Internal_Entity_Type_Decl_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Resolved_Param_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind a Item

            
         
         
      --# expr-start 976 ResolvedParam.param_type Fld_1 nodes.lkt:1782









Fld_1 := Item.Param_Type;
--# expr-done 976
      

         declare
            Item_To_Append : constant Internal_Entity_Type_Decl := Fld_1;
         begin
            Internal_Entity_Type_Decl_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Entity_Type_Decl_Array
           (Items_Count => Natural (Internal_Entity_Type_Decl_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Type_Decl_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Type_Decl_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Type_Decl_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 977
--# expr-start 978 SynthFunDecl.return_type Fld_2 nodes.lkt:1783







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Ent.Node.Synth_Fun_Decl_F_Return_Type;
--# expr-done 978









   
      Cast_Result := Create_Internal_Entity_Decl
        (Node => Ent.Node,
         Info => Ent.Info);


--# property-call-start LktNode.function_type_helper
Fld_3 := Liblktlang.Implementation.Lkt_Node_P_Function_Type_Helper (Node => Ent.Node, Param_Types => Map_Result, Return_Type => Fld_2, Origin => Cast_Result, E_Info => Ent.Info);
--# end
--# expr-done 979

         Property_Result := Fld_3;
         
   --# end
      Finalizer_Scope_179;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_179;




            raise;
      end;



   return Property_Result;
end Synth_Fun_Decl_P_Function_Type_Aux;
--# end

   







--# property-start SynthFunDecl.decl_type_name nodes.lkt:1787
pragma Warnings (Off, "is not referenced");

function Synth_Fun_Decl_P_Decl_Type_Name
  
  (Node : Bare_Synth_Fun_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Synth_Fun_Decl :=
     Bare_Synth_Fun_Decl (Node);
     Ent : Internal_Entity_Synth_Fun_Decl :=
       Internal_Entity_Synth_Fun_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_180 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_180 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_180;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 980 StringLiteral Str nodes.lkt:1787
Str := Create_String ("function declaration"); 
--# expr-done 980

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_180;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_180;




            raise;
      end;



   return Property_Result;
end Synth_Fun_Decl_P_Decl_Type_Name;
--# end



   


      

   --
   --  Primitives for Bare_Synth_Param_Decl
   --

   





   







--# property-start SynthParamDecl.full_name_internal nodes.lkt:1766
pragma Warnings (Off, "is not referenced");

function Synth_Param_Decl_P_Full_Name_Internal
  
  (Node : Bare_Synth_Param_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Synth_Param_Decl :=
     Bare_Synth_Param_Decl (Node);
     Ent : Internal_Entity_Synth_Param_Decl :=
       Internal_Entity_Synth_Param_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_177 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_177 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_177;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 981 StringLiteral Str nodes.lkt:1766
Str := Create_String ("[Synthetic parameter]"); 
--# expr-done 981

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_177;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_177;




            raise;
      end;



   return Property_Result;
end Synth_Param_Decl_P_Full_Name_Internal;
--# end

   







--# property-start SynthParamDecl.decl_type_name nodes.lkt:1768
pragma Warnings (Off, "is not referenced");

function Synth_Param_Decl_P_Decl_Type_Name
  
  (Node : Bare_Synth_Param_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Synth_Param_Decl :=
     Bare_Synth_Param_Decl (Node);
     Ent : Internal_Entity_Synth_Param_Decl :=
       Internal_Entity_Synth_Param_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_178 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_178 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_178;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 982 StringLiteral Str nodes.lkt:1768
Str := Create_String ("function parameter declaration"); 
--# expr-done 982

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_178;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_178;




            raise;
      end;



   return Property_Result;
end Synth_Param_Decl_P_Decl_Type_Name;
--# end



   


      

   --
   --  Primitives for Bare_Type_Decl
   --

   




      
   function Type_Decl_F_Traits
     (Node : Bare_Type_Decl) return Bare_Type_Ref_List
   is
      

         Kind : constant Lkt_Type_Decl := Node.Kind;
   begin
         case Kind is
               when Lkt_Any_Type_Decl =>
                     
         return Node.Any_Type_Decl_F_Traits;
      
               when Lkt_Enum_Class_Alt_Decl =>
                     
         return Node.Enum_Class_Alt_Decl_F_Traits;
      
               when Lkt_Function_Type =>
                     
         return Node.Function_Type_F_Traits;
      
               when Lkt_Generic_Param_Type_Decl =>
                     
         return Node.Generic_Param_Type_Decl_F_Traits;
      
               when Lkt_Class_Decl | Lkt_Enum_Class_Decl =>
                     
         return Node.Basic_Class_Decl_F_Traits;
      
               when Lkt_Enum_Type_Decl =>
                     
         return Node.Enum_Type_Decl_F_Traits;
      
               when Lkt_Struct_Decl =>
                     
         return Node.Struct_Decl_F_Traits;
      
               when Lkt_Trait_Decl =>
                     
         return Node.Trait_Decl_F_Traits;
      
         end case;
   end;

      
   function Type_Decl_F_Syn_Base_Type
     (Node : Bare_Type_Decl) return Bare_Type_Ref
   is
      

         Kind : constant Lkt_Type_Decl := Node.Kind;
   begin
         case Kind is
               when Lkt_Any_Type_Decl =>
                     return No_Bare_Lkt_Node;
               when Lkt_Enum_Class_Alt_Decl =>
                     return No_Bare_Lkt_Node;
               when Lkt_Function_Type =>
                     return No_Bare_Lkt_Node;
               when Lkt_Generic_Param_Type_Decl =>
                     return No_Bare_Lkt_Node;
               when Lkt_Class_Decl | Lkt_Enum_Class_Decl =>
                     
         return Node.Basic_Class_Decl_F_Syn_Base_Type;
      
               when Lkt_Enum_Type_Decl =>
                     return No_Bare_Lkt_Node;
               when Lkt_Struct_Decl =>
                     return No_Bare_Lkt_Node;
               when Lkt_Trait_Decl =>
                     return No_Bare_Lkt_Node;
         end case;
   end;


   







--# property-start TypeDecl.self_decl nodes.lkt:1803
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Self_Decl
  
  (Node : Bare_Type_Decl
  )

   return Bare_Self_Decl
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
      --# bind node Self

   


   Property_Result : Bare_Self_Decl;

      

      New_Node : Bare_Self_Decl;


      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Type_Decl_Type_Decl_P_Self_Decl,
            Items    => new Mmz_Key_Array (1 ..  1))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Type_Decl,
                                As_Bare_Type_Decl => Self);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Bare_Self_Decl;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 983 'New[SelfDecl]' New_Node nodes.lkt:1803



if Is_Foreign_Strict (Self.Self_Env, Self) then
   Raise_Property_Exception
     (Self,
      Property_Error'Identity,
      "synthetic nodes cannot have foreign lexical envs");
end if;


New_Node := new Root_Node_Record
  (Lkt_Self_Decl);
Initialize
  (Self => New_Node,
   Kind => Lkt_Self_Decl,
   Unit => Self.Unit,

   Token_Start_Index => No_Token_Index,
   Token_End_Index   => No_Token_Index,

   Parent => Self,

   Self_Env => Self.Self_Env);
Register_Destroyable (Self.Unit, New_Node);



--# expr-done 983

         Property_Result := New_Node;
         
   --# end


      exception
         when Exc : Property_Error =>


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Bare_Self_Decl,
                     As_Bare_Self_Decl => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Type_Decl_P_Self_Decl;
--# end

   







--# property-start TypeDecl.node_decl nodes.lkt:1806
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Node_Decl
  
  (Node : Bare_Type_Decl
  )

   return Bare_Node_Decl
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
      --# bind node Self

   


   Property_Result : Bare_Node_Decl;

      

      New_Node : Bare_Node_Decl;


      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Type_Decl_Type_Decl_P_Node_Decl,
            Items    => new Mmz_Key_Array (1 ..  1))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Type_Decl,
                                As_Bare_Type_Decl => Self);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Bare_Node_Decl;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 984 'New[NodeDecl]' New_Node nodes.lkt:1806



if Is_Foreign_Strict (Self.Self_Env, Self) then
   Raise_Property_Exception
     (Self,
      Property_Error'Identity,
      "synthetic nodes cannot have foreign lexical envs");
end if;


New_Node := new Root_Node_Record
  (Lkt_Node_Decl);
Initialize
  (Self => New_Node,
   Kind => Lkt_Node_Decl,
   Unit => Self.Unit,

   Token_Start_Index => No_Token_Index,
   Token_End_Index   => No_Token_Index,

   Parent => Self,

   Self_Env => Self.Self_Env);
Register_Destroyable (Self.Unit, New_Node);



--# expr-done 984

         Property_Result := New_Node;
         
   --# end


      exception
         when Exc : Property_Error =>


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Bare_Node_Decl,
                     As_Bare_Node_Decl => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Type_Decl_P_Node_Decl;
--# end

   







--# property-start TypeDecl.full_name nodes.lkt:1808
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Full_Name
  
  (Node : Bare_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_183 with Inline_Always;

      Fld : String_Type;

            procedure Finalizer_Scope_183 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_183;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 985 Decl.full_name Fld nodes.lkt:1809







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start 'Decl.[root-static]full_name'
Fld := Liblktlang.Implementation.Decl_P_Full_Name (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 985

         Property_Result := Fld;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_183;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_183;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Full_Name;
--# end

   







--# property-start TypeDecl.def_id nodes.lkt:1813
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Def_Id
  
  (Node : Bare_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Def_Id
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Def_Id;

      

      Fld : Internal_Entity_Def_Id;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 986 Decl.syn_name Fld nodes.lkt:1814







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Def_Id (Node => Implementation.Decl_F_Syn_Name (Ent.Node), Info => Ent.Info);
--# expr-done 986

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Def_Id;
--# end

   







--# property-start TypeDecl.base_type nodes.lkt:1818
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Base_Type
  
  (Node : Bare_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Ref
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Ref;

      

      Fld : Internal_Entity_Type_Ref;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 987 TypeDecl.syn_base_type Fld nodes.lkt:1818







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Type_Ref (Node => Implementation.Type_Decl_F_Syn_Base_Type (Ent.Node), Info => Ent.Info);
--# expr-done 987

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Base_Type;
--# end

   







--# property-start TypeDecl.base_type_if_entity nodes.lkt:1822
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Base_Type_If_Entity
  
  (Node : Bare_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;

      

      Fld : Internal_Entity_Named_Type_Decl;
Fld_1 : Bare_Named_Type_Decl;
Cast_Result : Bare_Type_Decl;
Is_Equal : Boolean;
Fld_2 : Internal_Entity_Type_Decl;
If_Result : Internal_Entity_Type_Decl;
Fld_3 : Internal_Entity_Type_Ref;
Var_Expr : Internal_Entity_Type_Ref;
Fld_4 : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         


--# expr-start 993 TypeDecl.base_type Fld_3 nodes.lkt:1823



--# expr-start 992 If If_Result nodes.lkt:1824



--# expr-start 990 Eq Is_Equal nodes.lkt:1824






--# expr-start 989 'Entity[NamedTypeDecl].node' Fld_1 nodes.lkt:1824



--# expr-start 988 LktNode.entity_type Fld nodes.lkt:1824







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Self);
--# end
--# expr-done 988





Fld_1 := Fld.Node;
--# expr-done 989



   
      Cast_Result := Fld_1;


Is_Equal := Self = Cast_Result; 
--# expr-done 990
if Is_Equal then
   --# expr-start 991 TypeDecl.get_entity_node_type Fld_2 nodes.lkt:1824







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.get_entity_node_type
Fld_2 := Liblktlang.Implementation.Type_Decl_P_Get_Entity_Node_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 991
   If_Result := Fld_2;
else
   
   If_Result := Ent;
end if;



--# expr-done 992



   if If_Result.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.base_type
Fld_3 := Liblktlang.Implementation.Type_Decl_P_Base_Type (Node => If_Result.Node, E_Info => If_Result.Info);
--# end
--# expr-done 993
Var_Expr := Fld_3;





if Var_Expr /= No_Entity_Type_Ref then
   --# expr-start 994 TypeRef.referenced_decl Fld_4 nodes.lkt:1823







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_4 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 994
   Result_Var := Fld_4;
else
   
   Result_Var := No_Entity_Type_Decl;
end if;




         Property_Result := Result_Var;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Base_Type_If_Entity;
--# end

   







--# property-start TypeDecl.is_equation nodes.lkt:1833
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Is_Equation
  
  (Node : Bare_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Is_Null : Boolean;
Fld : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Cast_Result_1 : Internal_Entity;
Is_Equiv : Boolean;
If_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 998 BooleanOr If_Result nodes.lkt:1833



--# expr-start 995 .is_null Is_Null nodes.lkt:1833

Is_Null := Ent.Node = null; 
--# expr-done 995
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 997 Eq Is_Equiv nodes.lkt:1833









   
      Cast_Result := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);







--# expr-start 996 LktNode.equation_type Fld nodes.lkt:1833







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.equation_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Equation_Type (Node => Self);
--# end
--# expr-done 996



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Fld.Node,
         Info => Fld.Info);


Is_Equiv := Equivalent (Cast_Result, Cast_Result_1); 
--# expr-done 997
   If_Result := Is_Equiv;
end if;



--# expr-done 998

         Property_Result := If_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Is_Equation;
--# end

   







--# property-start TypeDecl.is_bool nodes.lkt:1840
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Is_Bool
  
  (Node : Bare_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Is_Null : Boolean;
Fld : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Cast_Result_1 : Internal_Entity;
Is_Equiv : Boolean;
If_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1002 BooleanOr If_Result nodes.lkt:1840



--# expr-start 999 .is_null Is_Null nodes.lkt:1840

Is_Null := Ent.Node = null; 
--# expr-done 999
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 1001 Eq Is_Equiv nodes.lkt:1840









   
      Cast_Result := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);







--# expr-start 1000 LktNode.bool_type Fld nodes.lkt:1840







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.bool_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Bool_Type (Node => Self);
--# end
--# expr-done 1000



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Fld.Node,
         Info => Fld.Info);


Is_Equiv := Equivalent (Cast_Result, Cast_Result_1); 
--# expr-done 1001
   If_Result := Is_Equiv;
end if;



--# expr-done 1002

         Property_Result := If_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Is_Bool;
--# end

   







--# property-start TypeDecl.is_string_or_array_type nodes.lkt:1843
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Is_String_Or_Array_Type
  
  (Node : Bare_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Is_Null : Boolean;
Fld : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Cast_Result_1 : Internal_Entity;
Is_Equiv : Boolean;
If_Result : Boolean;
Fld_1 : Internal_Entity_Named_Type_Decl;
Fld_2 : Bare_Named_Type_Decl;
Cast_Result_2 : Bare_Type_Decl;
Is_Equal : Boolean;
If_Result_1 : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1010 BooleanOr If_Result_1 nodes.lkt:1844



--# expr-start 1006 BooleanOr If_Result nodes.lkt:1844



--# expr-start 1003 .is_null Is_Null nodes.lkt:1844

Is_Null := Ent.Node = null; 
--# expr-done 1003
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 1005 Eq Is_Equiv nodes.lkt:1844









   
      Cast_Result := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);







--# expr-start 1004 LktNode.string_type Fld nodes.lkt:1844







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.string_type
Fld := Liblktlang.Implementation.Lkt_Node_P_String_Type (Node => Ent.Node);
--# end
--# expr-done 1004



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Fld.Node,
         Info => Fld.Info);


Is_Equiv := Equivalent (Cast_Result, Cast_Result_1); 
--# expr-done 1005
   If_Result := Is_Equiv;
end if;



--# expr-done 1006
if If_Result then
   
   If_Result_1 := True;
else
   --# expr-start 1009 Eq Is_Equal nodes.lkt:1845






--# expr-start 1008 'Entity[NamedTypeDecl].node' Fld_2 nodes.lkt:1845



--# expr-start 1007 LktNode.array_type Fld_1 nodes.lkt:1845







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.array_type
Fld_1 := Liblktlang.Implementation.Lkt_Node_P_Array_Type (Node => Ent.Node);
--# end
--# expr-done 1007





Fld_2 := Fld_1.Node;
--# expr-done 1008



   
      Cast_Result_2 := Fld_2;


Is_Equal := Self = Cast_Result_2; 
--# expr-done 1009
   If_Result_1 := Is_Equal;
end if;



--# expr-done 1010

         Property_Result := If_Result_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Is_String_Or_Array_Type;
--# end

   







--# property-start TypeDecl.is_int_type nodes.lkt:1848
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Is_Int_Type
  
  (Node : Bare_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Is_Null : Boolean;
Fld : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Cast_Result_1 : Internal_Entity;
Is_Equiv : Boolean;
If_Result : Boolean;
Fld_1 : Internal_Entity_Named_Type_Decl;
Cast_Result_2 : Internal_Entity;
Cast_Result_3 : Internal_Entity;
Is_Equiv_1 : Boolean;
If_Result_1 : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1017 BooleanOr If_Result_1 nodes.lkt:1849



--# expr-start 1014 BooleanOr If_Result nodes.lkt:1849



--# expr-start 1011 .is_null Is_Null nodes.lkt:1849

Is_Null := Ent.Node = null; 
--# expr-done 1011
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 1013 Eq Is_Equiv nodes.lkt:1849









   
      Cast_Result := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);







--# expr-start 1012 LktNode.int_type Fld nodes.lkt:1849







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.int_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Int_Type (Node => Ent.Node);
--# end
--# expr-done 1012



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Fld.Node,
         Info => Fld.Info);


Is_Equiv := Equivalent (Cast_Result, Cast_Result_1); 
--# expr-done 1013
   If_Result := Is_Equiv;
end if;



--# expr-done 1014
if If_Result then
   
   If_Result_1 := True;
else
   --# expr-start 1016 Eq Is_Equiv_1 nodes.lkt:1849









   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);







--# expr-start 1015 LktNode.bigint_type Fld_1 nodes.lkt:1849







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.bigint_type
Fld_1 := Liblktlang.Implementation.Lkt_Node_P_Bigint_Type (Node => Ent.Node);
--# end
--# expr-done 1015



   
      Cast_Result_3 := Create_Internal_Entity
        (Node => Fld_1.Node,
         Info => Fld_1.Info);


Is_Equiv_1 := Equivalent (Cast_Result_2, Cast_Result_3); 
--# expr-done 1016
   If_Result_1 := Is_Equiv_1;
end if;



--# expr-done 1017

         Property_Result := If_Result_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Is_Int_Type;
--# end

   







--# property-start TypeDecl.is_int_or_node nodes.lkt:1854
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Is_Int_Or_Node
  
  (Node : Bare_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      
            procedure Finalizer_Scope_191 with Inline_Always;

      Is_Null : Boolean;
Fld : Boolean;
If_Result : Boolean;
Fld_1 : Lexical_Env := Empty_Env;
Sym : Symbol_Type;
Env_Get_Result : Internal_Entity;
Cast_Result : Internal_Entity_Type_Decl;
Fld_2 : Boolean;
If_Result_1 : Boolean;

            procedure Finalizer_Scope_191 is
            begin
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_191;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1026 BooleanOr If_Result_1 nodes.lkt:1855



--# expr-start 1020 BooleanOr If_Result nodes.lkt:1855



--# expr-start 1018 .is_null Is_Null nodes.lkt:1855

Is_Null := Ent.Node = null; 
--# expr-done 1018
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 1019 TypeDecl.is_int_type Fld nodes.lkt:1855







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.is_int_type
Fld := Liblktlang.Implementation.Type_Decl_P_Is_Int_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1019
   If_Result := Fld;
end if;



--# expr-done 1020
if If_Result then
   
   If_Result_1 := True;
else
   --# expr-start 1025 TypeDecl.is_subtype_or_eq Fld_2 nodes.lkt:1856



--# expr-start 1024 Cast Cast_Result nodes.lkt:1856





--# expr-start 1023 .get_first Env_Get_Result nodes.lkt:1856
--# expr-start 1021 LktNode.node_env Fld_1 nodes.lkt:1856







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Liblktlang.Implementation.Node_Env (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 1021
--# expr-start 1022 SymbolLiteral Sym nodes.lkt:1856
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Rootnode); 
--# expr-done 1022


Env_Get_Result := AST_Envs.Get_First (Self => Fld_1, Key => Thin (Sym), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 1023



   if Env_Get_Result.Node = null
      or else Env_Get_Result.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => Env_Get_Result.Node,
         Info => Env_Get_Result.Info);

   else
         Cast_Result := No_Entity_Type_Decl;
   end if;


--# expr-done 1024



   if Cast_Result.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start TypeDecl.is_subtype_or_eq
Fld_2 := Liblktlang.Implementation.Type_Decl_P_Is_Subtype_Or_Eq (Node => Cast_Result.Node, Rhs => Ent, E_Info => Cast_Result.Info);
--# end
--# expr-done 1025
   If_Result_1 := Fld_2;
end if;



--# expr-done 1026

         Property_Result := If_Result_1;
         
   --# end
      Finalizer_Scope_191;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_191;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Is_Int_Or_Node;
--# end

   







--# property-start TypeDecl.get_entity_node_type nodes.lkt:1862
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Get_Entity_Node_Type
  
  (Node : Bare_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_192 with Inline_Always;

      Fld : Internal_Entity_Named_Type_Decl;
Fld_1 : Bare_Named_Type_Decl;
Cast_Result : Bare_Type_Decl;
Is_Equal : Boolean;
Fld_2 : Internal_Entity;
Cast_Result_1 : Internal_Entity_Generic_Decl;
Var_Expr : Internal_Entity_Generic_Decl;
Fld_3 : Lexical_Env := Empty_Env;
Fld_4 : Internal_Entity_Generic_Decl;
Fld_5 : Internal_Entity_Generic_Param_Decl_List;
Fld_6 : Bare_Generic_Param_Decl_List;
Fld_7 : Internal_Entity_Info;
Get_Result : Bare_Full_Decl;
As_Entity : Internal_Entity_Full_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Full_Decl;
Fld_8 : Internal_Entity_Decl;
Fld_9 : Symbol_Type;
Env_Get_Result : Internal_Entity;
Result_Var : Internal_Entity;
Cast_Result_2 : Internal_Entity_Type_Decl;
Var_Expr_1 : Internal_Entity_Type_Decl;
Fld_10 : Internal_Entity_Decl;
Cast_Result_3 : Internal_Entity_Type_Decl;
Fld_11 : Boolean;
If_Result_1 : Internal_Entity_Type_Decl;
Scope_Result : Internal_Entity_Type_Decl;
Result_Var_1 : Internal_Entity_Type_Decl;
If_Result_2 : Internal_Entity_Type_Decl;
Is_Null_1 : Boolean;
If_Result_3 : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_192 is
            begin
                     Dec_Ref (Fld_3);
            end Finalizer_Scope_192;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1046 If If_Result_3 nodes.lkt:1863



--# expr-start 1027 .is_null Is_Null_1 nodes.lkt:1863

Is_Null_1 := Ent.Node = null; 
--# expr-done 1027
if Is_Null_1 then
   
   If_Result_3 := No_Entity_Type_Decl;
else
   --# expr-start 1045 If If_Result_2 nodes.lkt:1863



--# expr-start 1030 Eq Is_Equal nodes.lkt:1864






--# expr-start 1029 'Entity[NamedTypeDecl].node' Fld_1 nodes.lkt:1864



--# expr-start 1028 LktNode.entity_type Fld nodes.lkt:1864







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Ent.Node);
--# end
--# expr-done 1028





Fld_1 := Fld.Node;
--# expr-done 1029



   
      Cast_Result := Fld_1;


Is_Equal := Self = Cast_Result; 
--# expr-done 1030
if Is_Equal then
   --# expr-start 1044 .do Result_Var_1 nodes.lkt:1866



--# expr-start 1039 Cast Cast_Result_2 nodes.lkt:1866








--# expr-start 1032 Cast Cast_Result_1 nodes.lkt:1866





--# expr-start 1031 .parent Fld_2 nodes.lkt:1866







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Liblktlang.Implementation.Parent (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 1031



   if Fld_2.Node = null
      or else Fld_2.Node.Kind in Lkt_Generic_Decl_Range
   then
      
      Cast_Result_1 := Create_Internal_Entity_Generic_Decl
        (Node => Fld_2.Node,
         Info => Fld_2.Info);

   else
         Cast_Result_1 := No_Entity_Generic_Decl;
   end if;


--# expr-done 1032
Var_Expr := Cast_Result_1;





if Var_Expr /= No_Entity_Generic_Decl then
   --# expr-start 1038 .get_first Env_Get_Result nodes.lkt:1866
--# expr-start 1033 LktNode.children_env Fld_3 nodes.lkt:1866







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Liblktlang.Implementation.Children_Env (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# expr-done 1033
--# expr-start 1037 Decl.name Fld_9 nodes.lkt:1867



--# expr-start 1036 FullDecl.decl Fld_8 nodes.lkt:1867



--# expr-start 1035 GenericDecl.generic_param_decls Fld_5 nodes.lkt:1867



--# expr-start 1034 LktNode.entity_gen_type Fld_4 nodes.lkt:1867







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_gen_type
Fld_4 := Liblktlang.Implementation.Lkt_Node_P_Entity_Gen_Type (Node => Ent.Node);
--# end
--# expr-done 1034



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Generic_Param_Decl_List (Node => Fld_4.Node.Generic_Decl_F_Generic_Param_Decls, Info => Fld_4.Info);
--# expr-done 1035
















Fld_6 := Fld_5.Node;



   if Fld_6 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;




Get_Result := Get (Self, Fld_6, 0, True); 
Is_Null := Get_Result = null; 
if Is_Null then
   
   If_Result := No_Entity_Full_Decl;
else
   








Fld_7 := Fld_5.Info;

As_Entity := (Info => Fld_7, Node => Get_Result); 
   If_Result := As_Entity;
end if;






   if If_Result.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Create_Internal_Entity_Decl (Node => If_Result.Node.Full_Decl_F_Decl, Info => If_Result.Info);
--# expr-done 1036



   if Fld_8.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_9 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Fld_8.Node);
--# end
--# expr-done 1037


Env_Get_Result := AST_Envs.Get_First (Self => Fld_3, Key => Thin (Fld_9), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 1038
   Result_Var := Env_Get_Result;
else
   
   Result_Var := No_Entity;
end if;






   if Result_Var.Node = null
      or else Result_Var.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_2 := Create_Internal_Entity_Type_Decl
        (Node => Result_Var.Node,
         Info => Result_Var.Info);

   else
         Cast_Result_2 := No_Entity_Type_Decl;
   end if;


--# expr-done 1039
Var_Expr_1 := Cast_Result_2;





if Var_Expr_1 /= No_Entity_Type_Decl then
   



   --# scope-start



--# expr-start 1043 If If_Result_1 nodes.lkt:1872



--# expr-start 1040 Decl.is_generic Fld_11 nodes.lkt:1872







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.is_generic
Fld_11 := Liblktlang.Implementation.Decl_P_Is_Generic (Node => Var_Expr_1.Node, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 1040
if Fld_11 then
   
   If_Result_1 := Var_Expr_1;
else
   --# expr-start 1042 Cast Cast_Result_3 nodes.lkt:1872





--# expr-start 1041 Decl.as_bare_decl Fld_10 nodes.lkt:1872







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.as_bare_decl
Fld_10 := Liblktlang.Implementation.Decl_P_As_Bare_Decl (Node => Var_Expr_1.Node, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 1041



   if Fld_10.Node = null
      or else Fld_10.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_3 := Create_Internal_Entity_Type_Decl
        (Node => Fld_10.Node,
         Info => Fld_10.Info);

   else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "invalid object cast");
   end if;


--# expr-done 1042
   If_Result_1 := Cast_Result_3;
end if;



--# expr-done 1043
Scope_Result := If_Result_1;


   --# end


   Result_Var_1 := Scope_Result;
else
   
   Result_Var_1 := No_Entity_Type_Decl;
end if;



--# expr-done 1044
   If_Result_2 := Result_Var_1;
else
   
   If_Result_2 := Ent;
end if;



--# expr-done 1045
   If_Result_3 := If_Result_2;
end if;



--# expr-done 1046

         Property_Result := If_Result_3;
         
   --# end
      Finalizer_Scope_192;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_192;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Get_Entity_Node_Type;
--# end

   







--# property-start TypeDecl.is_subtype_or_eq nodes.lkt:1880
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Is_Subtype_Or_Eq
  
  (Node : Bare_Type_Decl
      ; Rhs : Internal_Entity_Type_Decl
      ; Allow_Entity : Boolean
         := False
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind rhs Rhs
   --# bind allow_entity Allow_Entity

   Property_Result : Boolean;

      
            procedure Finalizer_Scope_193 with Inline_Always;

      Is_Null : Boolean;
Is_Null_1 : Boolean;
If_Result : Boolean;
Cast_Result : Internal_Entity;
Cast_Result_1 : Internal_Entity;
Is_Equiv : Boolean;
If_Result_1 : Boolean;
Fld : Internal_Entity_Type_Decl_Array_Access;
Cast_Result_2 : Internal_Entity;
Cast_Result_3 : Internal_Entity;
Is_Equiv_1 : Boolean;
Quantifier_Result : Boolean;
If_Result_2 : Boolean;
Is_Null_2 : Boolean;
Is_Null_3 : Boolean;
If_Result_3 : Boolean;
Not_Val : Boolean;
If_Result_4 : Boolean;
Fld_1 : Internal_Entity_Type_Decl;
Fld_2 : Internal_Entity_Type_Decl;
Fld_3 : Boolean;
If_Result_5 : Boolean;

            procedure Finalizer_Scope_193 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_193;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1063 If If_Result_5 nodes.lkt:1884



--# expr-start 1051 BooleanAnd If_Result_4 nodes.lkt:1884




if Allow_Entity then
   --# expr-start 1050 Not Not_Val nodes.lkt:1884
--# expr-start 1049 BooleanOr If_Result_3 nodes.lkt:1884



--# expr-start 1047 .is_null Is_Null_2 nodes.lkt:1884

Is_Null_2 := Ent.Node = null; 
--# expr-done 1047
if Is_Null_2 then
   
   If_Result_3 := True;
else
   --# expr-start 1048 .is_null Is_Null_3 nodes.lkt:1884

Is_Null_3 := Rhs.Node = null; 
--# expr-done 1048
   If_Result_3 := Is_Null_3;
end if;



--# expr-done 1049
Not_Val := not (If_Result_3); 
--# expr-done 1050
   If_Result_4 := Not_Val;
else
   
   If_Result_4 := False;
end if;



--# expr-done 1051
if If_Result_4 then
   --# expr-start 1054 TypeDecl.is_subtype_or_eq Fld_3 nodes.lkt:1886



--# expr-start 1052 TypeDecl.get_entity_node_type Fld_1 nodes.lkt:1886







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.get_entity_node_type
Fld_1 := Liblktlang.Implementation.Type_Decl_P_Get_Entity_Node_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1052



   if Fld_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1053 TypeDecl.get_entity_node_type Fld_2 nodes.lkt:1887







   if Rhs.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.get_entity_node_type
Fld_2 := Liblktlang.Implementation.Type_Decl_P_Get_Entity_Node_Type (Node => Rhs.Node, E_Info => Rhs.Info);
--# end
--# expr-done 1053
--# property-call-start TypeDecl.is_subtype_or_eq
Fld_3 := Liblktlang.Implementation.Type_Decl_P_Is_Subtype_Or_Eq (Node => Fld_1.Node, Rhs => Fld_2, E_Info => Fld_1.Info);
--# end
--# expr-done 1054
   If_Result_5 := Fld_3;
else
   --# expr-start 1062 BooleanOr If_Result_2 nodes.lkt:1890



--# expr-start 1059 BooleanOr If_Result_1 nodes.lkt:1890



--# expr-start 1057 BooleanOr If_Result nodes.lkt:1890



--# expr-start 1055 .is_null Is_Null nodes.lkt:1890

Is_Null := Ent.Node = null; 
--# expr-done 1055
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 1056 .is_null Is_Null_1 nodes.lkt:1890

Is_Null_1 := Rhs.Node = null; 
--# expr-done 1056
   If_Result := Is_Null_1;
end if;



--# expr-done 1057
if If_Result then
   
   If_Result_1 := True;
else
   --# expr-start 1058 Eq Is_Equiv nodes.lkt:1890









   
      Cast_Result := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);











   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Rhs.Node,
         Info => Rhs.Info);


Is_Equiv := Equivalent (Cast_Result, Cast_Result_1); 
--# expr-done 1058
   If_Result_1 := Is_Equiv;
end if;



--# expr-done 1059
if If_Result_1 then
   
   If_Result_2 := True;
else
   --# expr-start 1061 .contains Quantifier_Result nodes.lkt:1891








   

   --# expr-start 1060 TypeDecl.base_types Fld nodes.lkt:1891







   if Rhs.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]TypeDecl.base_types'
Fld := Liblktlang.Implementation.Dispatcher_Type_Decl_P_Base_Types (Node => Rhs.Node, E_Info => Rhs.Info);
--# end
--# expr-done 1060

   
      Quantifier_Result := False;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Type_Decl_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start



            
      








   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Item.Node,
         Info => Item.Info);











   
      Cast_Result_3 := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);


Is_Equiv_1 := Equivalent (Cast_Result_2, Cast_Result_3); 
      Quantifier_Result := Is_Equiv_1;
   

            
   --# end


               exit when Quantifier_Result;

         end loop;
      end;
   

   
   



--# expr-done 1061
   If_Result_2 := Quantifier_Result;
end if;



--# expr-done 1062
   If_Result_5 := If_Result_2;
end if;



--# expr-done 1063

         Property_Result := If_Result_5;
         
   --# end
      Finalizer_Scope_193;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_193;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Is_Subtype_Or_Eq;
--# end

   







--# property-start TypeDecl.common_ancestor_helper nodes.lkt:1893
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Common_Ancestor_Helper
  
  (Node : Bare_Type_Decl
      ; Other_Types : Internal_Entity_Type_Decl_Array_Access
      ; Idx : Integer
      ; Imprecise : Boolean
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind other_types Other_Types
   --# bind idx Idx
   --# bind imprecise Imprecise

   Property_Result : Internal_Entity_Type_Decl;

      

      Get_Result : Internal_Entity_Type_Decl;
Var_Expr : Internal_Entity_Type_Decl;
Arith_Result : Integer;
Fld : Internal_Entity_Type_Decl;
Fld_1 : Internal_Entity_Type_Decl;
Scope_Result : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;
Len : Integer;
Arith_Result_1 : Integer;
Is_Equal : Boolean;
Get_Result_1 : Internal_Entity_Type_Decl;
Fld_2 : Internal_Entity_Type_Decl;
If_Result : Internal_Entity_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1074 If If_Result nodes.lkt:1898



--# expr-start 1066 Eq Is_Equal nodes.lkt:1898

--# expr-start 1065 'Arithmetic '"'"'-'"'"'' Arith_Result_1 nodes.lkt:1898
--# expr-start 1064 .length Len nodes.lkt:1898

Len := Length (Other_Types); 
--# expr-done 1064

Arith_Result_1 := (Len - 1); 
--# expr-done 1065
Is_Equal := Idx = Arith_Result_1; 
--# expr-done 1066
if Is_Equal then
   --# expr-start 1068 TypeDecl.common_ancestor Fld_2 nodes.lkt:1899







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1067 .at Get_Result_1 nodes.lkt:1899




Get_Result_1 := Get (Self, Other_Types, Idx, True); 
--# expr-done 1067

--# property-call-start '[dispatcher]TypeDecl.common_ancestor'
Fld_2 := Liblktlang.Implementation.Dispatcher_Type_Decl_P_Common_Ancestor (Node => Ent.Node, Other => Get_Result_1, Imprecise => Imprecise, E_Info => Ent.Info);
--# end
--# expr-done 1068
   If_Result := Fld_2;
else
   --# expr-start 1073 .do Result_Var nodes.lkt:1901



--# expr-start 1069 .at Get_Result nodes.lkt:1901




Get_Result := Get (Self, Other_Types, Idx, True); 
--# expr-done 1069
Var_Expr := Get_Result;





if Var_Expr /= No_Entity_Type_Decl then
   



   --# scope-start



--# expr-start 1072 TypeDecl.common_ancestor Fld_1 nodes.lkt:1903







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1071 TypeDecl.common_ancestor_helper Fld nodes.lkt:1904







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# expr-start 1070 'Arithmetic '"'"'+'"'"'' Arith_Result nodes.lkt:1906


Arith_Result := (Idx + 1); 
--# expr-done 1070

--# property-call-start TypeDecl.common_ancestor_helper
Fld := Liblktlang.Implementation.Type_Decl_P_Common_Ancestor_Helper (Node => Ent.Node, Other_Types => Other_Types, Idx => Arith_Result, Imprecise => Imprecise, E_Info => Ent.Info);
--# end
--# expr-done 1071

--# property-call-start '[dispatcher]TypeDecl.common_ancestor'
Fld_1 := Liblktlang.Implementation.Dispatcher_Type_Decl_P_Common_Ancestor (Node => Var_Expr.Node, Other => Fld, Imprecise => Imprecise, E_Info => Var_Expr.Info);
--# end
--# expr-done 1072
Scope_Result := Fld_1;


   --# end


   Result_Var := Scope_Result;
else
   
   Result_Var := No_Entity_Type_Decl;
end if;



--# expr-done 1073
   If_Result := Result_Var;
end if;



--# expr-done 1074

         Property_Result := If_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Common_Ancestor_Helper;
--# end

   







--# property-start TypeDecl.imprecise_common_ancestor_list nodes.lkt:1918
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Imprecise_Common_Ancestor_List
  
  (Node : Bare_Type_Decl
      ; Other_Types : Internal_Entity_Type_Decl_Array_Access
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind other_types Other_Types

   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_590 with Inline_Always;
            procedure Finalizer_Scope_593 with Inline_Always;

      Var_Expr : Internal_Entity_Type_Decl;
Fld : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;
Map_Result : Internal_Entity_Type_Decl_Array_Access;
Local_No_Entity_Other_Types : Internal_Entity_Type_Decl_Array_Access;
Fld_1 : Internal_Entity_Type_Decl;
Fld_2 : Internal_Entity_Type_Decl;
Is_Null : Boolean;
Is_Null_1 : Boolean;
Not_Val : Boolean;
Find_Result : Internal_Entity_Type_Decl;
Var_Expr_1 : Internal_Entity_Type_Decl;
Fld_3 : Internal_Entity_Type_Decl;
Result_Var_1 : Internal_Entity_Type_Decl;
If_Result : Internal_Entity_Type_Decl;
Len : Integer;
Is_Equal : Boolean;
If_Result_1 : Internal_Entity_Type_Decl;
Var_Expr_2 : Internal_Entity_Type_Decl;
Fld_4 : Bare_Type_Decl;
Fld_5 : Internal_Entity_Named_Type_Decl;
Fld_6 : Bare_Named_Type_Decl;
Cast_Result : Bare_Type_Decl;
Is_Equal_1 : Boolean;
Not_Val_1 : Boolean;
Fld_7 : Internal_Entity_Named_Type_Decl;
Fld_8 : Bare_Named_Type_Decl;
Cast_Result_1 : Bare_Type_Decl;
Is_Equal_2 : Boolean;
Var_Expr_3 : Internal_Entity_Type_Decl;
Fld_9 : Bare_Type_Decl;
Result_Var_2 : Bare_Type_Decl;
Fld_10 : Internal_Entity_Named_Type_Decl;
Fld_11 : Bare_Named_Type_Decl;
Cast_Result_2 : Bare_Type_Decl;
Is_Equal_3 : Boolean;
Quantifier_Result : Boolean;
If_Result_2 : Boolean;
If_Result_3 : Boolean;
Fld_12 : Internal_Entity_Named_Type_Decl;
Array_Lit : Internal_Entity_Type_Decl_Array_Access;
Fld_13 : Internal_Entity_Decl;
Cast_Result_3 : Internal_Entity_Type_Decl;
If_Result_4 : Internal_Entity_Type_Decl;
Scope_Result : Internal_Entity_Type_Decl;
Result_Var_3 : Internal_Entity_Type_Decl;
Let_Result : Internal_Entity_Type_Decl;
Scope_Result_1 : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_590 is
            begin
                     Dec_Ref (Map_Result);
                     Dec_Ref (Local_No_Entity_Other_Types);
            end Finalizer_Scope_590;
            procedure Finalizer_Scope_593 is
            begin
                     Dec_Ref (Array_Lit);
            end Finalizer_Scope_593;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 1108 ValDecl Let_Result nodes.lkt:1921
--# scope-start
--# expr-start 1076 .map Map_Result nodes.lkt:1922








   

   

   
      declare
         Map_Result_Vec : Internal_Entity_Type_Decl_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Type_Decl_Array_Access := Other_Types;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind t Item

            
         
         
      



Var_Expr := Item;





if Var_Expr /= No_Entity_Type_Decl then
   --# expr-start 1075 TypeDecl.get_entity_node_type Fld nodes.lkt:1922







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.get_entity_node_type
Fld := Liblktlang.Implementation.Type_Decl_P_Get_Entity_Node_Type (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 1075
   Result_Var := Fld;
else
   
   Result_Var := No_Entity_Type_Decl;
end if;



      

         declare
            Item_To_Append : constant Internal_Entity_Type_Decl := Result_Var;
         begin
            Internal_Entity_Type_Decl_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Entity_Type_Decl_Array
           (Items_Count => Natural (Internal_Entity_Type_Decl_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Type_Decl_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Type_Decl_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Type_Decl_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1076
Local_No_Entity_Other_Types := Map_Result; Inc_Ref (Local_No_Entity_Other_Types);
--# bind no_entity_other_types Local_No_Entity_Other_Types
--# expr-start 1107 .do Result_Var_3 nodes.lkt:1924



--# expr-start 1087 If If_Result_1 nodes.lkt:1925



--# expr-start 1078 Eq Is_Equal nodes.lkt:1925
--# expr-start 1077 .length Len nodes.lkt:1925

Len := Length (Other_Types); 
--# expr-done 1077

Is_Equal := Len = 0; 
--# expr-done 1078
if Is_Equal then
   
   If_Result_1 := Ent;
else
   --# expr-start 1086 If If_Result nodes.lkt:1925



--# expr-start 1079 .is_null Is_Null nodes.lkt:1926

Is_Null := Ent.Node = null; 
--# expr-done 1079
if Is_Null then
   


--# expr-start 1082 .find Find_Result nodes.lkt:1928








   

   

   
      Find_Result := No_Entity_Type_Decl;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Type_Decl_Array_Access := Local_No_Entity_Other_Types;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind t Item_1

            
      --# expr-start 1081 Not Not_Val nodes.lkt:1928
--# expr-start 1080 .is_null Is_Null_1 nodes.lkt:1928

Is_Null_1 := Item_1.Node = null; 
--# expr-done 1080
Not_Val := not (Is_Null_1); 
--# expr-done 1081
      if Not_Val then
         Find_Result := Item_1; 
      end if;
   

            
   --# end


               exit when Not_Val;

         end loop;
      end;
   

   
   



--# expr-done 1082
Var_Expr_1 := Find_Result;





if Var_Expr_1 /= No_Entity_Type_Decl then
   --# expr-start 1083 TypeDecl.imprecise_common_ancestor_list Fld_3 nodes.lkt:1928







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start TypeDecl.imprecise_common_ancestor_list
Fld_3 := Liblktlang.Implementation.Type_Decl_P_Imprecise_Common_Ancestor_List (Node => Var_Expr_1.Node, Other_Types => Local_No_Entity_Other_Types, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 1083
   Result_Var_1 := Fld_3;
else
   
   Result_Var_1 := No_Entity_Type_Decl;
end if;



   If_Result := Result_Var_1;
else
   --# expr-start 1085 TypeDecl.common_ancestor_helper Fld_2 nodes.lkt:1931



--# expr-start 1084 TypeDecl.get_entity_node_type Fld_1 nodes.lkt:1931







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.get_entity_node_type
Fld_1 := Liblktlang.Implementation.Type_Decl_P_Get_Entity_Node_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1084



   if Fld_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;





--# property-call-start TypeDecl.common_ancestor_helper
Fld_2 := Liblktlang.Implementation.Type_Decl_P_Common_Ancestor_Helper (Node => Fld_1.Node, Other_Types => Local_No_Entity_Other_Types, Idx => 0, Imprecise => True, E_Info => Fld_1.Info);
--# end
--# expr-done 1085
   If_Result := Fld_2;
end if;



--# expr-done 1086
   If_Result_1 := If_Result;
end if;



--# expr-done 1087
Var_Expr_2 := If_Result_1;





if Var_Expr_2 /= No_Entity_Type_Decl then
   



   --# scope-start



--# expr-start 1106 If If_Result_4 nodes.lkt:1939



--# expr-start 1101 BooleanAnd If_Result_3 nodes.lkt:1940



--# expr-start 1091 NotEqual Not_Val_1 nodes.lkt:1940
--# expr-start 1088 'Entity[TypeDecl].node' Fld_4 nodes.lkt:1940









Fld_4 := Var_Expr_2.Node;
--# expr-done 1088





--# expr-start 1090 'Entity[NamedTypeDecl].node' Fld_6 nodes.lkt:1940



--# expr-start 1089 LktNode.entity_type Fld_5 nodes.lkt:1940







   if Var_Expr_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_5 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Var_Expr_2.Node);
--# end
--# expr-done 1089





Fld_6 := Fld_5.Node;
--# expr-done 1090



   
      Cast_Result := Fld_6;


Is_Equal_1 := Fld_4 = Cast_Result; 
Not_Val_1 := not (Is_Equal_1); 
--# expr-done 1091
if Not_Val_1 then
   --# expr-start 1100 BooleanOr If_Result_2 nodes.lkt:1942



--# expr-start 1094 Eq Is_Equal_2 nodes.lkt:1942






--# expr-start 1093 'Entity[NamedTypeDecl].node' Fld_8 nodes.lkt:1942



--# expr-start 1092 LktNode.entity_type Fld_7 nodes.lkt:1942







   if Var_Expr_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_7 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Var_Expr_2.Node);
--# end
--# expr-done 1092





Fld_8 := Fld_7.Node;
--# expr-done 1093



   
      Cast_Result_1 := Fld_8;


Is_Equal_2 := Self = Cast_Result_1; 
--# expr-done 1094
if Is_Equal_2 then
   
   If_Result_2 := True;
else
   --# expr-start 1099 .any Quantifier_Result nodes.lkt:1943








   

   

   
      Quantifier_Result := False;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Type_Decl_Array_Access := Other_Types;
      begin
         for Item_2 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind ot Item_2

            
      --# expr-start 1098 Eq Is_Equal_3 nodes.lkt:1944




Var_Expr_3 := Item_2;





if Var_Expr_3 /= No_Entity_Type_Decl then
   --# expr-start 1095 'Entity[TypeDecl].node' Fld_9 nodes.lkt:1944









Fld_9 := Var_Expr_3.Node;
--# expr-done 1095
   Result_Var_2 := Fld_9;
else
   
   Result_Var_2 := No_Bare_Lkt_Node;
end if;








--# expr-start 1097 'Entity[NamedTypeDecl].node' Fld_11 nodes.lkt:1944



--# expr-start 1096 LktNode.entity_type Fld_10 nodes.lkt:1944







   if Var_Expr_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_10 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Var_Expr_2.Node);
--# end
--# expr-done 1096





Fld_11 := Fld_10.Node;
--# expr-done 1097



   
      Cast_Result_2 := Fld_11;


Is_Equal_3 := Result_Var_2 = Cast_Result_2; 
--# expr-done 1098
      Quantifier_Result := Is_Equal_3;
   

            
   --# end


               exit when Quantifier_Result;

         end loop;
      end;
   

   
   



--# expr-done 1099
   If_Result_2 := Quantifier_Result;
end if;



--# expr-done 1100
   If_Result_3 := If_Result_2;
else
   
   If_Result_3 := False;
end if;



--# expr-done 1101
if If_Result_3 then
   --# expr-start 1105 Cast Cast_Result_3 nodes.lkt:1947





--# expr-start 1104 Decl.instantiate_generic_decl Fld_13 nodes.lkt:1947



--# expr-start 1102 LktNode.entity_type Fld_12 nodes.lkt:1947







   if Var_Expr_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_12 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Var_Expr_2.Node);
--# end
--# expr-done 1102



   if Fld_12.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1103 ArrayLiteral Array_Lit nodes.lkt:1947

Array_Lit := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Var_Expr_2)); 
--# expr-done 1103
--# property-call-start Decl.instantiate_generic_decl
Fld_13 := Liblktlang.Implementation.Decl_P_Instantiate_Generic_Decl (Node => Fld_12.Node, Param_Types => Array_Lit, E_Info => Fld_12.Info);
--# end
--# expr-done 1104



   if Fld_13.Node = null
      or else Fld_13.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_3 := Create_Internal_Entity_Type_Decl
        (Node => Fld_13.Node,
         Info => Fld_13.Info);

   else
         Cast_Result_3 := No_Entity_Type_Decl;
   end if;


--# expr-done 1105
   If_Result_4 := Cast_Result_3;
else
   
   If_Result_4 := Var_Expr_2;
end if;



--# expr-done 1106
Scope_Result := If_Result_4;


   --# end
      Finalizer_Scope_593;


   Result_Var_3 := Scope_Result;
else
   
   Result_Var_3 := No_Entity_Type_Decl;
end if;



--# expr-done 1107
Let_Result := Result_Var_3; 
--# end
--# expr-done 1108
Scope_Result_1 := Let_Result;


   --# end
      Finalizer_Scope_590;



         Property_Result := Scope_Result_1;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_590;
                     Finalizer_Scope_593;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Imprecise_Common_Ancestor_List;
--# end

   







--# property-start TypeDecl.commutative_matching_type nodes.lkt:1954
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Commutative_Matching_Type
  
  (Node : Bare_Type_Decl
      ; Other : Internal_Entity_Type_Decl
      ; Allow_Common_Ancestor : Boolean
         := False
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind other Other
   --# bind allow_common_ancestor Allow_Common_Ancestor

   Property_Result : Boolean;

      

      Is_Null : Boolean;
Is_Null_1 : Boolean;
If_Result : Boolean;
Fld : Boolean;
If_Result_1 : Boolean;
Fld_1 : Boolean;
If_Result_2 : Boolean;
Fld_2 : Internal_Entity_Type_Decl;
Is_Null_2 : Boolean;
Not_Val : Boolean;
If_Result_3 : Boolean;
If_Result_4 : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1120 BooleanOr If_Result_4 nodes.lkt:1958



--# expr-start 1115 BooleanOr If_Result_2 nodes.lkt:1959



--# expr-start 1113 BooleanOr If_Result_1 nodes.lkt:1959



--# expr-start 1111 BooleanOr If_Result nodes.lkt:1959



--# expr-start 1109 .is_null Is_Null nodes.lkt:1959

Is_Null := Ent.Node = null; 
--# expr-done 1109
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 1110 .is_null Is_Null_1 nodes.lkt:1959

Is_Null_1 := Other.Node = null; 
--# expr-done 1110
   If_Result := Is_Null_1;
end if;



--# expr-done 1111
if If_Result then
   
   If_Result_1 := True;
else
   --# expr-start 1112 TypeDecl.matching_type Fld nodes.lkt:1959







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start TypeDecl.matching_type
Fld := Liblktlang.Implementation.Type_Decl_P_Matching_Type (Node => Ent.Node, Other => Other, E_Info => Ent.Info);
--# end
--# expr-done 1112
   If_Result_1 := Fld;
end if;



--# expr-done 1113
if If_Result_1 then
   
   If_Result_2 := True;
else
   --# expr-start 1114 TypeDecl.matching_type Fld_1 nodes.lkt:1960







   if Other.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start TypeDecl.matching_type
Fld_1 := Liblktlang.Implementation.Type_Decl_P_Matching_Type (Node => Other.Node, Other => Ent, E_Info => Other.Info);
--# end
--# expr-done 1114
   If_Result_2 := Fld_1;
end if;



--# expr-done 1115
if If_Result_2 then
   
   If_Result_4 := True;
else
   --# expr-start 1119 BooleanAnd If_Result_3 nodes.lkt:1962




if Allow_Common_Ancestor then
   --# expr-start 1118 Not Not_Val nodes.lkt:1962
--# expr-start 1117 .is_null Is_Null_2 nodes.lkt:1962
--# expr-start 1116 TypeDecl.common_ancestor Fld_2 nodes.lkt:1962







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start '[dispatcher]TypeDecl.common_ancestor'
Fld_2 := Liblktlang.Implementation.Dispatcher_Type_Decl_P_Common_Ancestor (Node => Ent.Node, Other => Other, E_Info => Ent.Info);
--# end
--# expr-done 1116
Is_Null_2 := Fld_2.Node = null; 
--# expr-done 1117
Not_Val := not (Is_Null_2); 
--# expr-done 1118
   If_Result_3 := Not_Val;
else
   
   If_Result_3 := False;
end if;



--# expr-done 1119
   If_Result_4 := If_Result_3;
end if;



--# expr-done 1120

         Property_Result := If_Result_4;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Commutative_Matching_Type;
--# end

   







--# property-start TypeDecl.could_determine_type nodes.lkt:1966
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Could_Determine_Type
  
  (Node : Bare_Type_Decl
  )

   return Boolean
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
      --# bind node Self

   


   Property_Result : Boolean;

      

      Is_Null : Boolean;
Not_Val : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1122 Not Not_Val nodes.lkt:1966
--# expr-start 1121 .is_null Is_Null nodes.lkt:1966

Is_Null := Self = null; 
--# expr-done 1121
Not_Val := not (Is_Null); 
--# expr-done 1122

         Property_Result := Not_Val;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Could_Determine_Type;
--# end

   







--# property-start TypeDecl.matching_generic_types nodes.lkt:1970
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Matching_Generic_Types
  
  (Node : Bare_Type_Decl
      ; Other : Internal_Entity_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind other Other

   Property_Result : Boolean;

      
            procedure Finalizer_Scope_597 with Inline_Always;

      Fld : Internal_Entity;
Cast_Result : Internal_Entity_Generic_Decl;
Var_Expr : Internal_Entity_Generic_Decl;
Fld_1 : Internal_Entity;
Cast_Result_1 : Internal_Entity_Generic_Decl;
Var_Expr_1 : Internal_Entity_Generic_Decl;
Fld_2 : Internal_Entity_Decl;
Fld_3 : Bare_Decl;
Fld_4 : Internal_Entity_Decl;
Fld_5 : Bare_Decl;
Cast_Result_2 : Bare_Decl;
Is_Equal : Boolean;
Fld_6 : Internal_Entity_Generic_Param_Decl_List;
Item : Internal_Entity_Full_Decl;
Fld_7 : Lexical_Env := Empty_Env;
Fld_8 : Internal_Entity_Decl;
Fld_9 : Symbol_Type;
Env_Get_Result : Internal_Entity;
Cast_Result_3 : Internal_Entity_Type_Decl;
Fld_10 : Lexical_Env := Empty_Env;
Fld_11 : Internal_Entity_Decl;
Fld_12 : Symbol_Type;
Env_Get_Result_1 : Internal_Entity;
Cast_Result_4 : Internal_Entity_Type_Decl;
Fld_13 : Boolean;
Fld_14 : Bare_Generic_Param_Decl_List;
Fld_15 : Internal_Entity_Info;
Bare_Item : Bare_Full_Decl;
As_Entity : Internal_Entity_Full_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Full_Decl;
Quantifier_Result : Boolean;
If_Result_1 : Boolean;
Scope_Result : Boolean;
Result_Var : Boolean;
Scope_Result_1 : Boolean;
Fld_16 : Bare_Type_Decl;
Cast_Result_5 : Bare_Type_Decl;
Is_Equal_1 : Boolean;
Result_Var_1 : Boolean;

            procedure Finalizer_Scope_597 is
            begin
                     Dec_Ref (Fld_7);
                     Dec_Ref (Fld_10);
            end Finalizer_Scope_597;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1149 .do Result_Var_1 nodes.lkt:1971



--# expr-start 1124 Cast Cast_Result nodes.lkt:1971





--# expr-start 1123 .parent Fld nodes.lkt:1971







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Parent (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 1123



   if Fld.Node = null
      or else Fld.Node.Kind in Lkt_Generic_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Generic_Decl
        (Node => Fld.Node,
         Info => Fld.Info);

   else
         Cast_Result := No_Entity_Generic_Decl;
   end if;


--# expr-done 1124
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Generic_Decl then
   



   --# scope-start



--# expr-start 1146 .do Result_Var nodes.lkt:1973



--# expr-start 1126 Cast Cast_Result_1 nodes.lkt:1973





--# expr-start 1125 .parent Fld_1 nodes.lkt:1973







   if Other.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Liblktlang.Implementation.Parent (Node => Other.Node, E_Info => Other.Info);
--# expr-done 1125



   if Fld_1.Node = null
      or else Fld_1.Node.Kind in Lkt_Generic_Decl_Range
   then
      
      Cast_Result_1 := Create_Internal_Entity_Generic_Decl
        (Node => Fld_1.Node,
         Info => Fld_1.Info);

   else
         Cast_Result_1 := No_Entity_Generic_Decl;
   end if;


--# expr-done 1126
Var_Expr_1 := Cast_Result_1;





if Var_Expr_1 /= No_Entity_Generic_Decl then
   



   --# scope-start



--# expr-start 1145 BooleanAnd If_Result_1 nodes.lkt:1975



--# expr-start 1131 Eq Is_Equal nodes.lkt:1975





--# expr-start 1128 'Entity[Decl].node' Fld_3 nodes.lkt:1975



--# expr-start 1127 GenericDecl.decl Fld_2 nodes.lkt:1975







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Decl (Node => Var_Expr.Node.Generic_Decl_F_Decl, Info => Var_Expr.Info);
--# expr-done 1127





Fld_3 := Fld_2.Node;
--# expr-done 1128



   
      Cast_Result_2 := Fld_3;


--# expr-start 1130 'Entity[Decl].node' Fld_5 nodes.lkt:1975



--# expr-start 1129 GenericDecl.decl Fld_4 nodes.lkt:1975







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Decl (Node => Var_Expr_1.Node.Generic_Decl_F_Decl, Info => Var_Expr_1.Info);
--# expr-done 1129





Fld_5 := Fld_4.Node;
--# expr-done 1130
Is_Equal := Cast_Result_2 = Fld_5; 
--# expr-done 1131
if Is_Equal then
   --# expr-start 1144 .all Quantifier_Result nodes.lkt:1976








   

   --# expr-start 1132 GenericDecl.generic_param_decls Fld_6 nodes.lkt:1976







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Generic_Param_Decl_List (Node => Var_Expr.Node.Generic_Decl_F_Generic_Param_Decls, Info => Var_Expr.Info);
--# expr-done 1132









Fld_14 := Fld_6.Node;

   
      Quantifier_Result := True;
   

   

      if Fld_14 = null then
         
      null;
   
      else
         

      declare
         
         Collection : constant Bare_Generic_Param_Decl_List := Fld_14;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Full_Decl;
else
   








Fld_15 := Fld_6.Info;

As_Entity := (Info => Fld_15, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind f Item

            
      --# expr-start 1143 TypeDecl.matching_type Fld_13 nodes.lkt:1978



--# expr-start 1137 Cast Cast_Result_3 nodes.lkt:1978





--# expr-start 1136 .get_first Env_Get_Result nodes.lkt:1978
--# expr-start 1133 LktNode.children_env Fld_7 nodes.lkt:1978







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Liblktlang.Implementation.Children_Env (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# expr-done 1133
--# expr-start 1135 Decl.name Fld_9 nodes.lkt:1978



--# expr-start 1134 FullDecl.decl Fld_8 nodes.lkt:1978







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Create_Internal_Entity_Decl (Node => Item.Node.Full_Decl_F_Decl, Info => Item.Info);
--# expr-done 1134



   if Fld_8.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_9 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Fld_8.Node);
--# end
--# expr-done 1135


Env_Get_Result := AST_Envs.Get_First (Self => Fld_7, Key => Thin (Fld_9), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 1136



   if Env_Get_Result.Node = null
      or else Env_Get_Result.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_3 := Create_Internal_Entity_Type_Decl
        (Node => Env_Get_Result.Node,
         Info => Env_Get_Result.Info);

   else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "invalid object cast");
   end if;


--# expr-done 1137



   if Cast_Result_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1142 Cast Cast_Result_4 nodes.lkt:1981





--# expr-start 1141 .get_first Env_Get_Result_1 nodes.lkt:1981
--# expr-start 1138 LktNode.children_env Fld_10 nodes.lkt:1981







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Liblktlang.Implementation.Children_Env (Node => Var_Expr_1.Node, E_Info => Var_Expr_1.Info);
--# expr-done 1138
--# expr-start 1140 Decl.name Fld_12 nodes.lkt:1981



--# expr-start 1139 FullDecl.decl Fld_11 nodes.lkt:1981







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Create_Internal_Entity_Decl (Node => Item.Node.Full_Decl_F_Decl, Info => Item.Info);
--# expr-done 1139



   if Fld_11.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_12 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Fld_11.Node);
--# end
--# expr-done 1140


Env_Get_Result_1 := AST_Envs.Get_First (Self => Fld_10, Key => Thin (Fld_12), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 1141



   if Env_Get_Result_1.Node = null
      or else Env_Get_Result_1.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_4 := Create_Internal_Entity_Type_Decl
        (Node => Env_Get_Result_1.Node,
         Info => Env_Get_Result_1.Info);

   else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "invalid object cast");
   end if;


--# expr-done 1142
--# property-call-start TypeDecl.matching_type
Fld_13 := Liblktlang.Implementation.Type_Decl_P_Matching_Type (Node => Cast_Result_3.Node, Other => Cast_Result_4, E_Info => Cast_Result_3.Info);
--# end
--# expr-done 1143
      Quantifier_Result := Fld_13;
   

            
   --# end
      Finalizer_Scope_597;


               exit when not Quantifier_Result;

         end loop;
      end;
   
      end if;

   
   



--# expr-done 1144
   If_Result_1 := Quantifier_Result;
else
   
   If_Result_1 := False;
end if;



--# expr-done 1145
Scope_Result := If_Result_1;


   --# end


   Result_Var := Scope_Result;
else
   
   Result_Var := False;
end if;



--# expr-done 1146
Scope_Result_1 := Result_Var;


   --# end


   Result_Var_1 := Scope_Result_1;
else
   --# expr-start 1148 Eq Is_Equal_1 nodes.lkt:1987









   
      Cast_Result_5 := Self;


--# expr-start 1147 'Entity[TypeDecl].node' Fld_16 nodes.lkt:1987









Fld_16 := Other.Node;
--# expr-done 1147
Is_Equal_1 := Cast_Result_5 = Fld_16; 
--# expr-done 1148
   Result_Var_1 := Is_Equal_1;
end if;



--# expr-done 1149

         Property_Result := Result_Var_1;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_597;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Matching_Generic_Types;
--# end

   







--# property-start TypeDecl.matching_type nodes.lkt:1992
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Matching_Type
  
  (Node : Bare_Type_Decl
      ; Other : Internal_Entity_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind other Other

   Property_Result : Boolean;

      
            procedure Finalizer_Scope_599 with Inline_Always;
            procedure Finalizer_Scope_600 with Inline_Always;

      Is_Null : Boolean;
Is_Null_1 : Boolean;
If_Result : Boolean;
Local_Ft : Internal_Entity_Function_Type;
Cast_Result : Internal_Entity_Function_Type;
Var_Expr : Internal_Entity_Function_Type;
Fld : Internal_Entity_Type_Decl_Array_Access;
Len : Integer;
Fld_1 : Internal_Entity_Type_Decl_Array_Access;
Len_1 : Integer;
Is_Equal : Boolean;
Fld_2 : Internal_Entity_Type_Decl_Array_Access;
Index : Integer;
Fld_3 : Internal_Entity_Type_Decl_Array_Access;
Get_Result : Internal_Entity_Type_Decl;
Fld_4 : Boolean;
Quantifier_Result : Boolean;
If_Result_1 : Boolean;
Fld_5 : Internal_Entity_Type_Decl;
Fld_6 : Internal_Entity_Type_Decl;
Fld_7 : Boolean;
If_Result_2 : Boolean;
Scope_Result : Boolean;
Result_Var : Boolean;
Ignored : Internal_Entity_Type_Decl;
Cast_Result_1 : Internal_Entity;
Cast_Result_2 : Internal_Entity;
Is_Equiv : Boolean;
Fld_8 : Boolean;
If_Result_3 : Boolean;
Fld_9 : Boolean;
If_Result_4 : Boolean;
Match_Prefix : Internal_Entity_Type_Decl;
Cast_Result_3 : Internal_Entity_Function_Type;
Let_Result : Boolean;
Scope_Result_1 : Boolean;
Cast_Result_4 : Internal_Entity_Type_Decl;
Let_Result_1 : Boolean;
Scope_Result_2 : Boolean;
Match_Result : Boolean;
If_Result_5 : Boolean;
Is_A : Boolean;
Is_A_1 : Boolean;
If_Result_6 : Boolean;
If_Result_7 : Boolean;

            procedure Finalizer_Scope_599 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Fld_1);
                     Dec_Ref (Fld_2);
            end Finalizer_Scope_599;
            procedure Finalizer_Scope_600 is
            begin
                     Dec_Ref (Fld_3);
            end Finalizer_Scope_600;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1180 If If_Result_7 nodes.lkt:1993



--# expr-start 1152 BooleanOr If_Result_6 nodes.lkt:1993



--# expr-start 1150 IsA Is_A nodes.lkt:1993

Is_A := Ent.Node /= null 
and then Ent.Node.Kind in Lkt_Any_Type_Decl_Range; 
--# expr-done 1150
if Is_A then
   
   If_Result_6 := True;
else
   --# expr-start 1151 IsA Is_A_1 nodes.lkt:1993

Is_A_1 := Other.Node /= null 
and then Other.Node.Kind in Lkt_Any_Type_Decl_Range; 
--# expr-done 1151
   If_Result_6 := Is_A_1;
end if;



--# expr-done 1152
if If_Result_6 then
   
   If_Result_7 := True;
else
   --# expr-start 1179 BooleanOr If_Result_5 nodes.lkt:1998



--# expr-start 1155 BooleanOr If_Result nodes.lkt:1998



--# expr-start 1153 .is_null Is_Null nodes.lkt:1998

Is_Null := Ent.Node = null; 
--# expr-done 1153
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 1154 .is_null Is_Null_1 nodes.lkt:1998

Is_Null_1 := Other.Node = null; 
--# expr-done 1154
   If_Result := Is_Null_1;
end if;



--# expr-done 1155
if If_Result then
   
   If_Result_5 := True;
else
   --# expr-start 1178 Match Match_Result nodes.lkt:1999










   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := Ent; 

case Lkt_Type_Decl (Match_Prefix.Node.Kind) is
         when Lkt_Function_Type =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_3 := Create_Internal_Entity_Function_Type
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Ft := Cast_Result_3; 
--# bind ft Local_Ft
--# expr-start 1172 .do Result_Var nodes.lkt:2001



--# expr-start 1156 Cast Cast_Result nodes.lkt:2001









   if Other.Node = null
      or else Other.Node.Kind in Lkt_Function_Type_Range
   then
      
      Cast_Result := Create_Internal_Entity_Function_Type
        (Node => Other.Node,
         Info => Other.Info);

   else
         Cast_Result := No_Entity_Function_Type;
   end if;


--# expr-done 1156
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Function_Type then
   



   --# scope-start



--# expr-start 1171 BooleanAnd If_Result_2 nodes.lkt:2003



--# expr-start 1167 BooleanAnd If_Result_1 nodes.lkt:2004



--# expr-start 1161 Eq Is_Equal nodes.lkt:2004
--# expr-start 1158 .length Len nodes.lkt:2004
--# expr-start 1157 FunctionType.params Fld nodes.lkt:2004







   if Local_Ft.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Local_Ft.Node.Function_Type_F_Params;
Inc_Ref (Fld);
--# expr-done 1157
Len := Length (Fld); 
--# expr-done 1158
--# expr-start 1160 .length Len_1 nodes.lkt:2004
--# expr-start 1159 FunctionType.params Fld_1 nodes.lkt:2004







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Var_Expr.Node.Function_Type_F_Params;
Inc_Ref (Fld_1);
--# expr-done 1159
Len_1 := Length (Fld_1); 
--# expr-done 1160
Is_Equal := Len = Len_1; 
--# expr-done 1161
if Is_Equal then
   --# expr-start 1166 .iall Quantifier_Result nodes.lkt:2005








   

   --# expr-start 1162 FunctionType.params Fld_2 nodes.lkt:2005







   if Local_Ft.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Local_Ft.Node.Function_Type_F_Params;
Inc_Ref (Fld_2);
--# expr-done 1162

   
      Quantifier_Result := True;
   

   

      
         Index := 0;

      declare
         
         Collection : constant Internal_Entity_Type_Decl_Array_Access := Fld_2;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind a Item
               --# bind idx Index

            
      --# expr-start 1165 TypeDecl.matching_type Fld_4 nodes.lkt:2006







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1164 .at Get_Result nodes.lkt:2006

--# expr-start 1163 FunctionType.params Fld_3 nodes.lkt:2006







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Var_Expr.Node.Function_Type_F_Params;
Inc_Ref (Fld_3);
--# expr-done 1163


Get_Result := Get (Self, Fld_3, Index, True); 
--# expr-done 1164
--# property-call-start TypeDecl.matching_type
Fld_4 := Liblktlang.Implementation.Type_Decl_P_Matching_Type (Node => Item.Node, Other => Get_Result, E_Info => Item.Info);
--# end
--# expr-done 1165
      Quantifier_Result := Fld_4;
   

            
   --# end
      Finalizer_Scope_600;


               exit when not Quantifier_Result;

               Index := Index + 1;
         end loop;
      end;
   

   
   



--# expr-done 1166
   If_Result_1 := Quantifier_Result;
else
   
   If_Result_1 := False;
end if;



--# expr-done 1167
if If_Result_1 then
   --# expr-start 1170 TypeDecl.matching_type Fld_7 nodes.lkt:2009



--# expr-start 1168 FunctionType.return_type Fld_5 nodes.lkt:2009







   if Local_Ft.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Local_Ft.Node.Function_Type_F_Return_Type;
--# expr-done 1168



   if Fld_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1169 FunctionType.return_type Fld_6 nodes.lkt:2009







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Var_Expr.Node.Function_Type_F_Return_Type;
--# expr-done 1169
--# property-call-start TypeDecl.matching_type
Fld_7 := Liblktlang.Implementation.Type_Decl_P_Matching_Type (Node => Fld_5.Node, Other => Fld_6, E_Info => Fld_5.Info);
--# end
--# expr-done 1170
   If_Result_2 := Fld_7;
else
   
   If_Result_2 := False;
end if;



--# expr-done 1171
Scope_Result := If_Result_2;


   --# end
      Finalizer_Scope_599;


   Result_Var := Scope_Result;
else
   
   Result_Var := False;
end if;



--# expr-done 1172
Let_Result := Result_Var; 
--# end
Scope_Result_1 := Let_Result;


   --# end


            Match_Result := Scope_Result_1; 
         when Lkt_Any_Type_Decl .. Lkt_Enum_Class_Alt_Decl | Lkt_Generic_Param_Type_Decl .. Lkt_Trait_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_4 := Create_Internal_Entity_Type_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored := Cast_Result_4; 
--# bind _ Ignored
--# expr-start 1177 BooleanOr If_Result_4 nodes.lkt:2013



--# expr-start 1175 BooleanOr If_Result_3 nodes.lkt:2013



--# expr-start 1173 Eq Is_Equiv nodes.lkt:2013









   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);











   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Other.Node,
         Info => Other.Info);


Is_Equiv := Equivalent (Cast_Result_1, Cast_Result_2); 
--# expr-done 1173
if Is_Equiv then
   
   If_Result_3 := True;
else
   --# expr-start 1174 TypeDecl.is_subtype Fld_8 nodes.lkt:2013







   if Other.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start '[dispatcher]TypeDecl.is_subtype'
Fld_8 := Liblktlang.Implementation.Dispatcher_Type_Decl_P_Is_Subtype (Node => Other.Node, Other => Ent, E_Info => Other.Info);
--# end
--# expr-done 1174
   If_Result_3 := Fld_8;
end if;



--# expr-done 1175
if If_Result_3 then
   
   If_Result_4 := True;
else
   --# expr-start 1176 TypeDecl.matching_generic_types Fld_9 nodes.lkt:2014







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start TypeDecl.matching_generic_types
Fld_9 := Liblktlang.Implementation.Type_Decl_P_Matching_Generic_Types (Node => Ent.Node, Other => Other, E_Info => Ent.Info);
--# end
--# expr-done 1176
   If_Result_4 := Fld_9;
end if;



--# expr-done 1177
Let_Result_1 := If_Result_4; 
--# end
Scope_Result_2 := Let_Result_1;


   --# end


            Match_Result := Scope_Result_2; 
end case;

--# expr-done 1178
   If_Result_5 := Match_Result;
end if;



--# expr-done 1179
   If_Result_7 := If_Result_5;
end if;



--# expr-done 1180

         Property_Result := If_Result_7;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_599;
                     Finalizer_Scope_600;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Matching_Type;
--# end

   







--# property-start TypeDecl.matching_logic_type nodes.lkt:2021
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Matching_Logic_Type
  
  (Node : Bare_Type_Decl
      ; Other : Internal_Entity_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind other Other

   Property_Result : Boolean;

      

      Is_Null : Boolean;
Is_Null_1 : Boolean;
If_Result : Boolean;
Fld : Internal_Entity_Named_Type_Decl;
Fld_1 : Bare_Named_Type_Decl;
Cast_Result : Bare_Type_Decl;
Is_Equal : Boolean;
Fld_2 : Internal_Entity_Named_Type_Decl;
Cast_Result_1 : Internal_Entity_Type_Decl;
Fld_3 : Boolean;
If_Result_1 : Boolean;
If_Result_2 : Boolean;
Fld_4 : Boolean;
If_Result_3 : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1192 BooleanOr If_Result_3 nodes.lkt:2022



--# expr-start 1190 BooleanOr If_Result_2 nodes.lkt:2023



--# expr-start 1183 BooleanOr If_Result nodes.lkt:2023



--# expr-start 1181 .is_null Is_Null nodes.lkt:2023

Is_Null := Ent.Node = null; 
--# expr-done 1181
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 1182 .is_null Is_Null_1 nodes.lkt:2023

Is_Null_1 := Other.Node = null; 
--# expr-done 1182
   If_Result := Is_Null_1;
end if;



--# expr-done 1183
if If_Result then
   
   If_Result_2 := True;
else
   --# expr-start 1189 BooleanAnd If_Result_1 nodes.lkt:2025



--# expr-start 1186 Eq Is_Equal nodes.lkt:2025






--# expr-start 1185 'Entity[NamedTypeDecl].node' Fld_1 nodes.lkt:2025



--# expr-start 1184 LktNode.entity_type Fld nodes.lkt:2025







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Ent.Node);
--# end
--# expr-done 1184





Fld_1 := Fld.Node;
--# expr-done 1185



   
      Cast_Result := Fld_1;


Is_Equal := Self = Cast_Result; 
--# expr-done 1186
if Is_Equal then
   --# expr-start 1188 TypeDecl.matching_type Fld_3 nodes.lkt:2026







   if Other.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;







--# expr-start 1187 LktNode.logicvar_type Fld_2 nodes.lkt:2026







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.logicvar_type
Fld_2 := Liblktlang.Implementation.Lkt_Node_P_Logicvar_Type (Node => Self);
--# end
--# expr-done 1187



   
      Cast_Result_1 := Create_Internal_Entity_Type_Decl
        (Node => Fld_2.Node,
         Info => Fld_2.Info);


--# property-call-start TypeDecl.matching_type
Fld_3 := Liblktlang.Implementation.Type_Decl_P_Matching_Type (Node => Other.Node, Other => Cast_Result_1, E_Info => Other.Info);
--# end
--# expr-done 1188
   If_Result_1 := Fld_3;
else
   
   If_Result_1 := False;
end if;



--# expr-done 1189
   If_Result_2 := If_Result_1;
end if;



--# expr-done 1190
if If_Result_2 then
   
   If_Result_3 := True;
else
   --# expr-start 1191 TypeDecl.matching_type Fld_4 nodes.lkt:2029







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start TypeDecl.matching_type
Fld_4 := Liblktlang.Implementation.Type_Decl_P_Matching_Type (Node => Ent.Node, Other => Other, E_Info => Ent.Info);
--# end
--# expr-done 1191
   If_Result_3 := Fld_4;
end if;



--# expr-done 1192

         Property_Result := If_Result_3;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Matching_Logic_Type;
--# end

   







--# property-start TypeDecl.is_of_array_type nodes.lkt:2034
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Is_Of_Array_Type
  
  (Node : Bare_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      
            procedure Finalizer_Scope_602 with Inline_Always;

      Is_Null : Boolean;
Origin : Internal_Entity;
Fld : Lexical_Env := Empty_Env;
Sym : Symbol_Type;
Env_Get_Result : Internal_Entity;
Cast_Result : Internal_Entity_Fun_Decl;
Var_Expr : Internal_Entity_Fun_Decl;
Fld_1 : Bare_Type_Decl;
Result_Var : Bare_Type_Decl;
Cast_Result_1 : Internal_Entity;
Dyn_Var_Bind_Result : Bare_Type_Decl;
Scope_Result : Bare_Type_Decl;
Fld_2 : Internal_Entity_Trait_Decl;
Fld_3 : Bare_Trait_Decl;
Cast_Result_2 : Bare_Type_Decl;
Is_Equal : Boolean;
If_Result : Boolean;

            procedure Finalizer_Scope_602 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_602;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1203 BooleanOr If_Result nodes.lkt:2035



--# expr-start 1193 .is_null Is_Null nodes.lkt:2035

Is_Null := Ent.Node = null; 
--# expr-done 1193
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 1202 Eq Is_Equal nodes.lkt:2036




   --# scope-start



--# expr-start 1199 bind Dyn_Var_Bind_Result nodes.lkt:2037









   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);


Origin := Cast_Result_1; 



--# expr-start 1197 Cast Cast_Result nodes.lkt:2039





--# expr-start 1196 .get_first Env_Get_Result nodes.lkt:2039
--# expr-start 1194 Decl.defined_scope Fld nodes.lkt:2039







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Ent.Node, Origin => Origin, E_Info => Ent.Info);
--# end
--# expr-done 1194
--# expr-start 1195 SymbolLiteral Sym nodes.lkt:2039
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Call); 
--# expr-done 1195


Env_Get_Result := AST_Envs.Get_First (Self => Fld, Key => Thin (Sym), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 1196



   if Env_Get_Result.Node = null
      or else Env_Get_Result.Node.Kind in Lkt_Fun_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Fun_Decl
        (Node => Env_Get_Result.Node,
         Info => Env_Get_Result.Info);

   else
         Cast_Result := No_Entity_Fun_Decl;
   end if;


--# expr-done 1197
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Fun_Decl then
   --# expr-start 1198 FunDecl.owning_type Fld_1 nodes.lkt:2039







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start FunDecl.owning_type
Fld_1 := Liblktlang.Implementation.Fun_Decl_P_Owning_Type (Node => Var_Expr.Node);
--# end
--# expr-done 1198
   Result_Var := Fld_1;
else
   
   Result_Var := No_Bare_Lkt_Node;
end if;



Dyn_Var_Bind_Result := Result_Var; 
--# expr-done 1199
Scope_Result := Dyn_Var_Bind_Result;


   --# end
      Finalizer_Scope_602;







--# expr-start 1201 'Entity[TraitDecl].node' Fld_3 nodes.lkt:2043



--# expr-start 1200 LktNode.indexable_trait Fld_2 nodes.lkt:2043







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.indexable_trait
Fld_2 := Liblktlang.Implementation.Lkt_Node_P_Indexable_Trait (Node => Self);
--# end
--# expr-done 1200





Fld_3 := Fld_2.Node;
--# expr-done 1201



   
      Cast_Result_2 := Fld_3;


Is_Equal := Scope_Result = Cast_Result_2; 
--# expr-done 1202
   If_Result := Is_Equal;
end if;



--# expr-done 1203

         Property_Result := If_Result;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_602;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Is_Of_Array_Type;
--# end

   







--# property-start TypeDecl.is_callable nodes.lkt:2048
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Is_Callable
  
  (Node : Bare_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Is_Null : Boolean;
Is_A : Boolean;
If_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1206 BooleanOr If_Result nodes.lkt:2048



--# expr-start 1204 .is_null Is_Null nodes.lkt:2048

Is_Null := Ent.Node = null; 
--# expr-done 1204
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 1205 IsA Is_A nodes.lkt:2048

Is_A := Ent.Node /= null 
and then Ent.Node.Kind in Lkt_Function_Type_Range; 
--# expr-done 1205
   If_Result := Is_A;
end if;



--# expr-done 1206

         Property_Result := If_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Is_Callable;
--# end

   







--# property-start TypeDecl.match_param_get_type nodes.lkt:2052
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Match_Param_Get_Type
  
  (Node : Bare_Type_Decl
      ; Current_Name : Internal_Entity_Argument
      ; In_Logic_Call : Boolean
         := False
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Decl
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind current_name Current_Name
   --# bind in_logic_call In_Logic_Call

   Property_Result : Internal_Entity_Decl;

      
            procedure Finalizer_Scope_603 with Inline_Always;
            procedure Finalizer_Scope_604 with Inline_Always;

      Cast_Result : Internal_Entity_Function_Type;
Local_Ft : Internal_Entity_Function_Type;
Var_Expr : Internal_Entity_Function_Type;
Fld : Internal_Entity_Decl;
Result_Var : Internal_Entity_Decl;
Local_Origin : Internal_Entity_Decl;
Fld_1 : Internal_Entity;
Fld_2 : Internal_Entity;
Cast_Result_1 : Internal_Entity_Base_Call_Expr;
Var_Expr_1 : Internal_Entity_Base_Call_Expr;
Fld_3 : Internal_Resolved_Param_Array_Access;
Fld_4 : Internal_Entity_Argument_List;
Fld_5 : Internal_Param_Match_Array_Access;
Scope_Result : Internal_Param_Match_Array_Access;
Result_Var_1 : Internal_Param_Match_Array_Access;
Fld_6 : Internal_Entity_Argument;
Cast_Result_2 : Internal_Entity;
Cast_Result_3 : Internal_Entity;
Is_Equiv : Boolean;
Find_Result : Internal_Param_Match;
Var_Expr_2 : Internal_Param_Match;
Fld_7 : Internal_Resolved_Param;
Fld_8 : Internal_Entity_Type_Decl;
Result_Var_2 : Internal_Entity_Type_Decl;
Is_Null : Boolean;
Cast_Result_4 : Internal_Entity_Decl;
If_Result : Internal_Entity_Decl;
Let_Result : Internal_Entity_Decl;
Let_Result_1 : Internal_Entity_Decl;
Scope_Result_1 : Internal_Entity_Decl;

            procedure Finalizer_Scope_603 is
            begin
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Result_Var_1);
            end Finalizer_Scope_603;
            procedure Finalizer_Scope_604 is
            begin
                     Dec_Ref (Fld_3);
                     Dec_Ref (Fld_5);
            end Finalizer_Scope_604;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 1224 ValDecl Let_Result_1 nodes.lkt:2053
--# scope-start
--# expr-start 1207 Cast Cast_Result nodes.lkt:2053









   if Ent.Node = null
      or else Ent.Node.Kind in Lkt_Function_Type_Range
   then
      
      Cast_Result := Create_Internal_Entity_Function_Type
        (Node => Ent.Node,
         Info => Ent.Info);

   else
         Cast_Result := No_Entity_Function_Type;
   end if;


--# expr-done 1207
Local_Ft := Cast_Result; 
--# bind ft Local_Ft
--# expr-start 1223 ValDecl Let_Result nodes.lkt:2054
--# scope-start




Var_Expr := Local_Ft;





if Var_Expr /= No_Entity_Function_Type then
   --# expr-start 1208 FunctionType.origin Fld nodes.lkt:2054







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Var_Expr.Node.Function_Type_F_Origin;
--# expr-done 1208
   Result_Var := Fld;
else
   
   Result_Var := No_Entity_Decl;
end if;



Local_Origin := Result_Var; 
--# bind origin Local_Origin
--# expr-start 1222 If If_Result nodes.lkt:2056



--# expr-start 1209 .is_null Is_Null nodes.lkt:2056

Is_Null := Local_Origin.Node = null; 
--# expr-done 1209
if Is_Null then
   
   If_Result := No_Entity_Decl;
else
   







--# expr-start 1219 .find Find_Result nodes.lkt:2059








   

   --# expr-start 1216 .do Result_Var_1 nodes.lkt:2059



--# expr-start 1212 Cast Cast_Result_1 nodes.lkt:2059





--# expr-start 1211 .parent Fld_2 nodes.lkt:2059



--# expr-start 1210 .parent Fld_1 nodes.lkt:2059







   if Current_Name.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Liblktlang.Implementation.Parent (Node => Current_Name.Node, E_Info => Current_Name.Info);
--# expr-done 1210



   if Fld_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Liblktlang.Implementation.Parent (Node => Fld_1.Node, E_Info => Fld_1.Info);
--# expr-done 1211



   if Fld_2.Node = null
      or else Fld_2.Node.Kind in Lkt_Base_Call_Expr
   then
      
      Cast_Result_1 := Create_Internal_Entity_Base_Call_Expr
        (Node => Fld_2.Node,
         Info => Fld_2.Info);

   else
         Cast_Result_1 := No_Entity_Base_Call_Expr;
   end if;


--# expr-done 1212
Var_Expr_1 := Cast_Result_1;





if Var_Expr_1 /= No_Entity_Base_Call_Expr then
   



   --# scope-start



--# expr-start 1215 Expr.match_params Fld_5 nodes.lkt:2061







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1213 Decl.get_params Fld_3 nodes.lkt:2062







   if Local_Origin.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start Decl.get_params
Fld_3 := Liblktlang.Implementation.Decl_P_Get_Params (Node => Local_Origin.Node, Is_Logic => In_Logic_Call, E_Info => Local_Origin.Info);
--# end
--# expr-done 1213
--# expr-start 1214 BaseCallExpr.args Fld_4 nodes.lkt:2063







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Argument_List (Node => Var_Expr_1.Node.Base_Call_Expr_F_Args, Info => Var_Expr_1.Info);
--# expr-done 1214
--# property-call-start Expr.match_params
Fld_5 := Liblktlang.Implementation.Expr_P_Match_Params (Node => Var_Expr_1.Node, Params => Fld_3, Args => Fld_4);
--# end
--# expr-done 1215
Scope_Result := Fld_5;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_604;


   Result_Var_1 := Scope_Result;
else
   
   Result_Var_1 := No_Internal_Param_Match_Array_Type;
end if;

      Inc_Ref (Result_Var_1);


--# expr-done 1216

   
      Find_Result := No_Param_Match;
   

   

      

      declare
         
         Collection : constant Internal_Param_Match_Array_Access := Result_Var_1;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind pm Item

            
      --# expr-start 1218 Eq Is_Equiv nodes.lkt:2066





--# expr-start 1217 ParamMatch.arg Fld_6 nodes.lkt:2066









Fld_6 := Item.Arg;
--# expr-done 1217



   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Fld_6.Node,
         Info => Fld_6.Info);











   
      Cast_Result_3 := Create_Internal_Entity
        (Node => Current_Name.Node,
         Info => Current_Name.Info);


Is_Equiv := Equivalent (Cast_Result_2, Cast_Result_3); 
--# expr-done 1218
      if Is_Equiv then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Is_Equiv;

         end loop;
      end;
   

   
   



--# expr-done 1219
Var_Expr_2 := Find_Result;





if Var_Expr_2 /= No_Param_Match then
   --# expr-start 1221 ResolvedParam.param_type Fld_8 nodes.lkt:2059



--# expr-start 1220 ParamMatch.param Fld_7 nodes.lkt:2059









Fld_7 := Var_Expr_2.Param;
--# expr-done 1220





Fld_8 := Fld_7.Param_Type;
--# expr-done 1221
   Result_Var_2 := Fld_8;
else
   
   Result_Var_2 := No_Entity_Type_Decl;
end if;






   
      Cast_Result_4 := Create_Internal_Entity_Decl
        (Node => Result_Var_2.Node,
         Info => Result_Var_2.Info);


   If_Result := Cast_Result_4;
end if;



--# expr-done 1222
Let_Result := If_Result; 
--# end
--# expr-done 1223
Let_Result_1 := Let_Result; 
--# end
--# expr-done 1224
Scope_Result_1 := Let_Result_1;


   --# end
      Finalizer_Scope_603;



         Property_Result := Scope_Result_1;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_603;
                     Finalizer_Scope_604;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Match_Param_Get_Type;
--# end

   







--# property-start TypeDecl.match_param_get_decl nodes.lkt:2073
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Match_Param_Get_Decl
  
  (Node : Bare_Type_Decl
      ; Current_Name : Internal_Entity_Argument
      ; In_Logic_Call : Boolean
         := False
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Decl
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind current_name Current_Name
   --# bind in_logic_call In_Logic_Call

   Property_Result : Internal_Entity_Decl;

      
            procedure Finalizer_Scope_606 with Inline_Always;
            procedure Finalizer_Scope_607 with Inline_Always;

      Cast_Result : Internal_Entity_Function_Type;
Local_Ft : Internal_Entity_Function_Type;
Var_Expr : Internal_Entity_Function_Type;
Fld : Internal_Entity_Decl;
Result_Var : Internal_Entity_Decl;
Local_Origin : Internal_Entity_Decl;
Fld_1 : Internal_Entity;
Fld_2 : Internal_Entity;
Cast_Result_1 : Internal_Entity_Call_Expr;
Var_Expr_1 : Internal_Entity_Call_Expr;
Fld_3 : Internal_Resolved_Param_Array_Access;
Fld_4 : Internal_Entity_Argument_List;
Fld_5 : Internal_Param_Match_Array_Access;
Scope_Result : Internal_Param_Match_Array_Access;
Result_Var_1 : Internal_Param_Match_Array_Access;
Fld_6 : Internal_Entity_Argument;
Cast_Result_2 : Internal_Entity;
Cast_Result_3 : Internal_Entity;
Is_Equiv : Boolean;
Find_Result : Internal_Param_Match;
Var_Expr_2 : Internal_Param_Match;
Fld_7 : Internal_Resolved_Param;
Fld_8 : Internal_Entity_Decl;
Result_Var_2 : Internal_Entity_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Decl;
Let_Result : Internal_Entity_Decl;
Let_Result_1 : Internal_Entity_Decl;
Scope_Result_1 : Internal_Entity_Decl;

            procedure Finalizer_Scope_606 is
            begin
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Result_Var_1);
            end Finalizer_Scope_606;
            procedure Finalizer_Scope_607 is
            begin
                     Dec_Ref (Fld_3);
                     Dec_Ref (Fld_5);
            end Finalizer_Scope_607;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 1242 ValDecl Let_Result_1 nodes.lkt:2074
--# scope-start
--# expr-start 1225 Cast Cast_Result nodes.lkt:2074









   if Ent.Node = null
      or else Ent.Node.Kind in Lkt_Function_Type_Range
   then
      
      Cast_Result := Create_Internal_Entity_Function_Type
        (Node => Ent.Node,
         Info => Ent.Info);

   else
         Cast_Result := No_Entity_Function_Type;
   end if;


--# expr-done 1225
Local_Ft := Cast_Result; 
--# bind ft Local_Ft
--# expr-start 1241 ValDecl Let_Result nodes.lkt:2075
--# scope-start




Var_Expr := Local_Ft;





if Var_Expr /= No_Entity_Function_Type then
   --# expr-start 1226 FunctionType.origin Fld nodes.lkt:2075







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Var_Expr.Node.Function_Type_F_Origin;
--# expr-done 1226
   Result_Var := Fld;
else
   
   Result_Var := No_Entity_Decl;
end if;



Local_Origin := Result_Var; 
--# bind origin Local_Origin
--# expr-start 1240 If If_Result nodes.lkt:2077



--# expr-start 1227 .is_null Is_Null nodes.lkt:2077

Is_Null := Local_Origin.Node = null; 
--# expr-done 1227
if Is_Null then
   
   If_Result := No_Entity_Decl;
else
   


--# expr-start 1237 .find Find_Result nodes.lkt:2079








   

   --# expr-start 1234 .do Result_Var_1 nodes.lkt:2079



--# expr-start 1230 Cast Cast_Result_1 nodes.lkt:2079





--# expr-start 1229 .parent Fld_2 nodes.lkt:2079



--# expr-start 1228 .parent Fld_1 nodes.lkt:2079







   if Current_Name.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Liblktlang.Implementation.Parent (Node => Current_Name.Node, E_Info => Current_Name.Info);
--# expr-done 1228



   if Fld_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Liblktlang.Implementation.Parent (Node => Fld_1.Node, E_Info => Fld_1.Info);
--# expr-done 1229



   if Fld_2.Node = null
      or else Fld_2.Node.Kind in Lkt_Call_Expr_Range
   then
      
      Cast_Result_1 := Create_Internal_Entity_Call_Expr
        (Node => Fld_2.Node,
         Info => Fld_2.Info);

   else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "invalid object cast");
   end if;


--# expr-done 1230
Var_Expr_1 := Cast_Result_1;





if Var_Expr_1 /= No_Entity_Call_Expr then
   



   --# scope-start



--# expr-start 1233 Expr.match_params Fld_5 nodes.lkt:2080







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1231 Decl.get_params Fld_3 nodes.lkt:2081







   if Local_Origin.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start Decl.get_params
Fld_3 := Liblktlang.Implementation.Decl_P_Get_Params (Node => Local_Origin.Node, Is_Logic => In_Logic_Call, E_Info => Local_Origin.Info);
--# end
--# expr-done 1231
--# expr-start 1232 BaseCallExpr.args Fld_4 nodes.lkt:2082







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Argument_List (Node => Var_Expr_1.Node.Base_Call_Expr_F_Args, Info => Var_Expr_1.Info);
--# expr-done 1232
--# property-call-start Expr.match_params
Fld_5 := Liblktlang.Implementation.Expr_P_Match_Params (Node => Var_Expr_1.Node, Params => Fld_3, Args => Fld_4);
--# end
--# expr-done 1233
Scope_Result := Fld_5;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_607;


   Result_Var_1 := Scope_Result;
else
   
   Result_Var_1 := No_Internal_Param_Match_Array_Type;
end if;

      Inc_Ref (Result_Var_1);


--# expr-done 1234

   
      Find_Result := No_Param_Match;
   

   

      

      declare
         
         Collection : constant Internal_Param_Match_Array_Access := Result_Var_1;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind pm Item

            
      --# expr-start 1236 Eq Is_Equiv nodes.lkt:2085





--# expr-start 1235 ParamMatch.arg Fld_6 nodes.lkt:2085









Fld_6 := Item.Arg;
--# expr-done 1235



   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Fld_6.Node,
         Info => Fld_6.Info);











   
      Cast_Result_3 := Create_Internal_Entity
        (Node => Current_Name.Node,
         Info => Current_Name.Info);


Is_Equiv := Equivalent (Cast_Result_2, Cast_Result_3); 
--# expr-done 1236
      if Is_Equiv then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Is_Equiv;

         end loop;
      end;
   

   
   



--# expr-done 1237
Var_Expr_2 := Find_Result;





if Var_Expr_2 /= No_Param_Match then
   --# expr-start 1239 ResolvedParam.decl Fld_8 nodes.lkt:2079



--# expr-start 1238 ParamMatch.param Fld_7 nodes.lkt:2079









Fld_7 := Var_Expr_2.Param;
--# expr-done 1238





Fld_8 := Fld_7.Decl;
--# expr-done 1239
   Result_Var_2 := Fld_8;
else
   
   Result_Var_2 := No_Entity_Decl;
end if;



   If_Result := Result_Var_2;
end if;



--# expr-done 1240
Let_Result := If_Result; 
--# end
--# expr-done 1241
Let_Result_1 := Let_Result; 
--# end
--# expr-done 1242
Scope_Result_1 := Let_Result_1;


   --# end
      Finalizer_Scope_606;



         Property_Result := Scope_Result_1;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_606;
                     Finalizer_Scope_607;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Match_Param_Get_Decl;
--# end

   







--# property-start TypeDecl.lambda_param_get_type nodes.lkt:2091
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Lambda_Param_Get_Type
  
  (Node : Bare_Type_Decl
      ; Param_Decl : Internal_Entity_Lambda_Param_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind param_decl Param_Decl

   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_609 with Inline_Always;
            procedure Finalizer_Scope_613 with Inline_Always;

      Fld : Internal_Entity;
Fld_1 : Internal_Entity;
Cast_Result : Internal_Entity_Lambda_Expr;
Fld_2 : Internal_Entity_Lambda_Param_Decl_List;
Item : Internal_Entity_Lambda_Param_Decl;
Index : Integer;
Neg : Integer;
Cast_Result_1 : Internal_Entity;
Cast_Result_2 : Internal_Entity;
Is_Equiv : Boolean;
If_Result : Integer;
Fld_3 : Bare_Lambda_Param_Decl_List;
Fld_4 : Internal_Entity_Info;
Bare_Item : Bare_Lambda_Param_Decl;
As_Entity : Internal_Entity_Lambda_Param_Decl;
Is_Null : Boolean;
If_Result_1 : Internal_Entity_Lambda_Param_Decl;
Map_Result : Integer_Array_Access;
Neg_1 : Integer;
Is_Equal : Boolean;
Not_Val : Boolean;
Map_Result_1 : Integer_Array_Access;
Get_Result : Integer;
Local_Param_Idx : Integer;
Cast_Result_3 : Internal_Entity_Function_Type;
Var_Expr : Internal_Entity_Function_Type;
Fld_5 : Internal_Entity_Type_Decl_Array_Access;
Get_Result_1 : Internal_Entity_Type_Decl;
Scope_Result : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;
Let_Result : Internal_Entity_Type_Decl;
Scope_Result_1 : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_609 is
            begin
                     Dec_Ref (Map_Result);
                     Dec_Ref (Map_Result_1);
            end Finalizer_Scope_609;
            procedure Finalizer_Scope_613 is
            begin
                     Dec_Ref (Fld_5);
            end Finalizer_Scope_613;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 1259 ValDecl Let_Result nodes.lkt:2094
--# scope-start
--# expr-start 1254 .at Get_Result nodes.lkt:2095

--# expr-start 1253 .filter Map_Result_1 nodes.lkt:2095








   

   --# expr-start 1250 .imap Map_Result nodes.lkt:2095








   

   --# expr-start 1246 LambdaExpr.params Fld_2 nodes.lkt:2095



--# expr-start 1245 Cast Cast_Result nodes.lkt:2095





--# expr-start 1244 .parent Fld_1 nodes.lkt:2095



--# expr-start 1243 .parent Fld nodes.lkt:2095







   if Param_Decl.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Parent (Node => Param_Decl.Node, E_Info => Param_Decl.Info);
--# expr-done 1243



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Liblktlang.Implementation.Parent (Node => Fld.Node, E_Info => Fld.Info);
--# expr-done 1244



   if Fld_1.Node = null
      or else Fld_1.Node.Kind in Lkt_Lambda_Expr_Range
   then
      
      Cast_Result := Create_Internal_Entity_Lambda_Expr
        (Node => Fld_1.Node,
         Info => Fld_1.Info);

   else
         Cast_Result := No_Entity_Lambda_Expr;
   end if;


--# expr-done 1245



   if Cast_Result.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Lambda_Param_Decl_List (Node => Cast_Result.Node.Lambda_Expr_F_Params, Info => Cast_Result.Info);
--# expr-done 1246









Fld_3 := Fld_2.Node;

   
      declare
         Map_Result_Vec : Integer_Vectors.Vector;
      begin
   

   

      if Fld_3 = null then
         
      Map_Result := Create_Integer_Array (0);
   
      else
         
         Index := 0;

      declare
         
         Collection : constant Bare_Lambda_Param_Decl_List := Fld_3;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result_1 := No_Entity_Lambda_Param_Decl;
else
   








Fld_4 := Fld_2.Info;

As_Entity := (Info => Fld_4, Node => Bare_Item); 
   If_Result_1 := As_Entity;
end if;



                  Item := If_Result_1; 

            
   --# scope-start


               --# bind p Item
               --# bind idx Index

            
         
         
      --# expr-start 1249 If If_Result nodes.lkt:2096



--# expr-start 1247 Eq Is_Equiv nodes.lkt:2096









   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Item.Node,
         Info => Item.Info);











   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Param_Decl.Node,
         Info => Param_Decl.Info);


Is_Equiv := Equivalent (Cast_Result_1, Cast_Result_2); 
--# expr-done 1247
if Is_Equiv then
   
   If_Result := Index;
else
   --# expr-start 1248 UnaryNeg Neg nodes.lkt:2096

Neg := -1; 
--# expr-done 1248
   If_Result := Neg;
end if;



--# expr-done 1249
      

         declare
            Item_To_Append : constant Integer := If_Result;
         begin
            Integer_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



               Index := Index + 1;
         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Integer_Array
           (Items_Count => Natural (Integer_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Integer_Vectors.Get
              (Map_Result_Vec,
               I + Integer_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Integer_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1250

   
      declare
         Map_Result_1_Vec : Integer_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Integer_Array_Access := Map_Result;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind i Item_1

            
         --# expr-start 1252 NotEqual Not_Val nodes.lkt:2098

--# expr-start 1251 UnaryNeg Neg_1 nodes.lkt:2098

Neg_1 := -1; 
--# expr-done 1251
Is_Equal := Item_1 = Neg_1; 
Not_Val := not (Is_Equal); 
--# expr-done 1252
         if Not_Val then
            
         
      
      

         declare
            Item_To_Append : constant Integer := Item_1;
         begin
            Integer_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
         end if;
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result_1 := Create_Integer_Array
           (Items_Count => Natural (Integer_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Integer_Vectors.Get
              (Map_Result_1_Vec,
               I + Integer_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Integer_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 1253


Get_Result := Get (Self, Map_Result_1, 0, True); 
--# expr-done 1254
Local_Param_Idx := Get_Result; 
--# bind param_idx Local_Param_Idx
--# expr-start 1258 .do Result_Var nodes.lkt:2100



--# expr-start 1255 Cast Cast_Result_3 nodes.lkt:2100









   if Ent.Node = null
      or else Ent.Node.Kind in Lkt_Function_Type_Range
   then
      
      Cast_Result_3 := Create_Internal_Entity_Function_Type
        (Node => Ent.Node,
         Info => Ent.Info);

   else
         Cast_Result_3 := No_Entity_Function_Type;
   end if;


--# expr-done 1255
Var_Expr := Cast_Result_3;





if Var_Expr /= No_Entity_Function_Type then
   



   --# scope-start



--# expr-start 1257 .at Get_Result_1 nodes.lkt:2100

--# expr-start 1256 FunctionType.params Fld_5 nodes.lkt:2100







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Var_Expr.Node.Function_Type_F_Params;
Inc_Ref (Fld_5);
--# expr-done 1256


Get_Result_1 := Get (Self, Fld_5, Local_Param_Idx, True); 
--# expr-done 1257
Scope_Result := Get_Result_1;


   --# end
      Finalizer_Scope_613;


   Result_Var := Scope_Result;
else
   
   Result_Var := No_Entity_Type_Decl;
end if;



--# expr-done 1258
Let_Result := Result_Var; 
--# end
--# expr-done 1259
Scope_Result_1 := Let_Result;


   --# end
      Finalizer_Scope_609;



         Property_Result := Scope_Result_1;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_609;
                     Finalizer_Scope_613;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Lambda_Param_Get_Type;
--# end

   







--# property-start TypeDecl.is_valid_call nodes.lkt:2107
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Is_Valid_Call
  
  (Node : Bare_Type_Decl
      ; Args : Internal_Entity_Argument_List
      ; In_Logic_Call : Boolean
         := False
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind args Args
   --# bind in_logic_call In_Logic_Call

   Property_Result : Boolean;

      
            procedure Finalizer_Scope_614 with Inline_Always;
            procedure Finalizer_Scope_615 with Inline_Always;
            procedure Finalizer_Scope_616 with Inline_Always;

      Cast_Result : Internal_Entity_Function_Type;
Var_Expr : Internal_Entity_Function_Type;
Fld : Internal_Entity;
Cast_Result_1 : Internal_Entity_Expr;
Fld_1 : Internal_Entity_Decl;
Var_Expr_1 : Internal_Entity_Decl;
Fld_2 : Internal_Resolved_Param_Array_Access;
Result_Var : Internal_Resolved_Param_Array_Access;
Fld_3 : Internal_Param_Match_Array_Access;
Scope_Result : Internal_Param_Match_Array_Access;
Result_Var_1 : Internal_Param_Match_Array_Access;
Local_Matched : Internal_Param_Match_Array_Access;
Cast_Result_2 : Internal_Entity_Function_Type;
Var_Expr_2 : Internal_Entity_Function_Type;
Is_Equal : Boolean;
Fld_4 : Bare_Argument_List;
Len : Integer;
Fld_5 : Internal_Entity_Type_Decl_Array_Access;
Len_1 : Integer;
Is_Equal_1 : Boolean;
If_Result : Boolean;
Item : Internal_Entity_Argument;
Fld_6 : Internal_Entity_Ref_Id;
Is_Null : Boolean;
Fld_7 : Internal_Entity_Argument;
Cast_Result_3 : Internal_Entity;
Cast_Result_4 : Internal_Entity;
Is_Equiv : Boolean;
Find_Result : Internal_Param_Match;
Is_Equal_2 : Boolean;
If_Result_1 : Boolean;
Not_Val : Boolean;
Fld_8 : Bare_Argument_List;
Fld_9 : Internal_Entity_Info;
Bare_Item : Bare_Argument;
As_Entity : Internal_Entity_Argument;
Is_Null_1 : Boolean;
If_Result_2 : Internal_Entity_Argument;
Quantifier_Result : Boolean;
Fld_10 : Internal_Entity_Argument;
Is_Null_2 : Boolean;
Not_Val_1 : Boolean;
Fld_11 : Internal_Resolved_Param;
Fld_12 : Boolean;
If_Result_3 : Boolean;
Quantifier_Result_1 : Boolean;
If_Result_4 : Boolean;
If_Result_5 : Boolean;
Scope_Result_1 : Boolean;
Result_Var_2 : Boolean;
Let_Result : Boolean;
Scope_Result_2 : Boolean;

            procedure Finalizer_Scope_614 is
            begin
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Result_Var_1);
                     Dec_Ref (Local_Matched);
            end Finalizer_Scope_614;
            procedure Finalizer_Scope_615 is
            begin
                     Dec_Ref (Fld_2);
                     Dec_Ref (Result_Var);
                     Dec_Ref (Fld_3);
            end Finalizer_Scope_615;
            procedure Finalizer_Scope_616 is
            begin
                     Dec_Ref (Fld_5);
            end Finalizer_Scope_616;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 1293 ValDecl Let_Result nodes.lkt:2108
--# scope-start
--# expr-start 1266 .do Result_Var_1 nodes.lkt:2109



--# expr-start 1260 Cast Cast_Result nodes.lkt:2109









   if Ent.Node = null
      or else Ent.Node.Kind in Lkt_Function_Type_Range
   then
      
      Cast_Result := Create_Internal_Entity_Function_Type
        (Node => Ent.Node,
         Info => Ent.Info);

   else
         Cast_Result := No_Entity_Function_Type;
   end if;


--# expr-done 1260
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Function_Type then
   



   --# scope-start



--# expr-start 1265 Expr.match_params Fld_3 nodes.lkt:2111



--# expr-start 1262 Cast Cast_Result_1 nodes.lkt:2111





--# expr-start 1261 .parent Fld nodes.lkt:2111







   if Args.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Parent (Node => Args.Node, E_Info => Args.Info);
--# expr-done 1261



   if Fld.Node = null
      or else Fld.Node.Kind in Lkt_Expr
   then
      
      Cast_Result_1 := Create_Internal_Entity_Expr
        (Node => Fld.Node,
         Info => Fld.Info);

   else
         Cast_Result_1 := No_Entity_Expr;
   end if;


--# expr-done 1262



   if Cast_Result_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;





--# expr-start 1263 FunctionType.origin Fld_1 nodes.lkt:2112







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Var_Expr.Node.Function_Type_F_Origin;
--# expr-done 1263
Var_Expr_1 := Fld_1;





if Var_Expr_1 /= No_Entity_Decl then
   --# expr-start 1264 Decl.get_params Fld_2 nodes.lkt:2112







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start Decl.get_params
Fld_2 := Liblktlang.Implementation.Decl_P_Get_Params (Node => Var_Expr_1.Node, Is_Logic => In_Logic_Call, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 1264
   Result_Var := Fld_2;
else
   
   Result_Var := No_Internal_Resolved_Param_Array_Type;
end if;

      Inc_Ref (Result_Var);



--# property-call-start Expr.match_params
Fld_3 := Liblktlang.Implementation.Expr_P_Match_Params (Node => Cast_Result_1.Node, Params => Result_Var, Args => Args);
--# end
--# expr-done 1265
Scope_Result := Fld_3;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_615;


   Result_Var_1 := Scope_Result;
else
   
   Result_Var_1 := No_Internal_Param_Match_Array_Type;
end if;

      Inc_Ref (Result_Var_1);


--# expr-done 1266
Local_Matched := Result_Var_1; Inc_Ref (Local_Matched);
--# bind matched Local_Matched
--# expr-start 1292 .do Result_Var_2 nodes.lkt:2117



--# expr-start 1267 Cast Cast_Result_2 nodes.lkt:2117









   if Ent.Node = null
      or else Ent.Node.Kind in Lkt_Function_Type_Range
   then
      
      Cast_Result_2 := Create_Internal_Entity_Function_Type
        (Node => Ent.Node,
         Info => Ent.Info);

   else
         Cast_Result_2 := No_Entity_Function_Type;
   end if;


--# expr-done 1267
Var_Expr_2 := Cast_Result_2;





if Var_Expr_2 /= No_Entity_Function_Type then
   



   --# scope-start



--# expr-start 1291 BooleanOr If_Result_5 nodes.lkt:2119



--# expr-start 1273 BooleanAnd If_Result nodes.lkt:2120



--# expr-start 1268 Eq Is_Equal nodes.lkt:2120


Is_Equal := Equivalent (Local_Matched, No_Internal_Param_Match_Array_Type); 
--# expr-done 1268
if Is_Equal then
   --# expr-start 1272 Eq Is_Equal_1 nodes.lkt:2121
--# expr-start 1269 .length Len nodes.lkt:2121









Fld_4 := Args.Node; 
Len := Length (Fld_4); 
--# expr-done 1269
--# expr-start 1271 .length Len_1 nodes.lkt:2121
--# expr-start 1270 FunctionType.params Fld_5 nodes.lkt:2121







   if Var_Expr_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Var_Expr_2.Node.Function_Type_F_Params;
Inc_Ref (Fld_5);
--# expr-done 1270
Len_1 := Length (Fld_5); 
--# expr-done 1271
Is_Equal_1 := Len = Len_1; 
--# expr-done 1272
   If_Result := Is_Equal_1;
else
   
   If_Result := False;
end if;



--# expr-done 1273
if If_Result then
   
   If_Result_5 := True;
else
   --# expr-start 1290 BooleanAnd If_Result_4 nodes.lkt:2126



--# expr-start 1282 .all Quantifier_Result nodes.lkt:2126








   

   









Fld_8 := Args.Node;

   
      Quantifier_Result := True;
   

   

      if Fld_8 = null then
         
      null;
   
      else
         

      declare
         
         Collection : constant Bare_Argument_List := Fld_8;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null_1 := Bare_Item = null; 
if Is_Null_1 then
   
   If_Result_2 := No_Entity_Argument;
else
   








Fld_9 := Args.Info;

As_Entity := (Info => Fld_9, Node => Bare_Item); 
   If_Result_2 := As_Entity;
end if;



                  Item := If_Result_2; 

            
   --# scope-start


               --# bind a Item

            
      --# expr-start 1281 Not Not_Val nodes.lkt:2128
--# expr-start 1280 BooleanAnd If_Result_1 nodes.lkt:2129



--# expr-start 1275 .is_null Is_Null nodes.lkt:2129
--# expr-start 1274 Argument.name Fld_6 nodes.lkt:2129







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Ref_Id (Node => Item.Node.Argument_F_Name, Info => Item.Info);
--# expr-done 1274
Is_Null := Fld_6.Node = null; 
--# expr-done 1275
if Is_Null then
   --# expr-start 1279 .is_null Is_Equal_2 nodes.lkt:2130
--# expr-start 1278 .find Find_Result nodes.lkt:2130








   

   

   
      Find_Result := No_Param_Match;
   

   

      

      declare
         
         Collection : constant Internal_Param_Match_Array_Access := Local_Matched;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind m Item_1

            
      --# expr-start 1277 Eq Is_Equiv nodes.lkt:2130





--# expr-start 1276 ParamMatch.arg Fld_7 nodes.lkt:2130









Fld_7 := Item_1.Arg;
--# expr-done 1276



   
      Cast_Result_3 := Create_Internal_Entity
        (Node => Fld_7.Node,
         Info => Fld_7.Info);











   
      Cast_Result_4 := Create_Internal_Entity
        (Node => Item.Node,
         Info => Item.Info);


Is_Equiv := Equivalent (Cast_Result_3, Cast_Result_4); 
--# expr-done 1277
      if Is_Equiv then
         Find_Result := Item_1; 
      end if;
   

            
   --# end


               exit when Is_Equiv;

         end loop;
      end;
   

   
   



--# expr-done 1278

Is_Equal_2 := Find_Result = No_Param_Match; 
--# expr-done 1279
   If_Result_1 := Is_Equal_2;
else
   
   If_Result_1 := False;
end if;



--# expr-done 1280
Not_Val := not (If_Result_1); 
--# expr-done 1281
      Quantifier_Result := Not_Val;
   

            
   --# end


               exit when not Quantifier_Result;

         end loop;
      end;
   
      end if;

   
   



--# expr-done 1282
if Quantifier_Result then
   --# expr-start 1289 .all Quantifier_Result_1 nodes.lkt:2136








   

   

   
      Quantifier_Result_1 := True;
   

   

      

      declare
         
         Collection : constant Internal_Param_Match_Array_Access := Local_Matched;
      begin
         for Item_2 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind p Item_2

            
      --# expr-start 1288 BooleanOr If_Result_3 nodes.lkt:2138



--# expr-start 1285 Not Not_Val_1 nodes.lkt:2138
--# expr-start 1284 .is_null Is_Null_2 nodes.lkt:2138
--# expr-start 1283 ParamMatch.arg Fld_10 nodes.lkt:2138









Fld_10 := Item_2.Arg;
--# expr-done 1283
Is_Null_2 := Fld_10.Node = null; 
--# expr-done 1284
Not_Val_1 := not (Is_Null_2); 
--# expr-done 1285
if Not_Val_1 then
   
   If_Result_3 := True;
else
   --# expr-start 1287 ResolvedParam.has_default_value Fld_12 nodes.lkt:2138



--# expr-start 1286 ParamMatch.param Fld_11 nodes.lkt:2138









Fld_11 := Item_2.Param;
--# expr-done 1286





Fld_12 := Fld_11.Has_Default_Value;
--# expr-done 1287
   If_Result_3 := Fld_12;
end if;



--# expr-done 1288
      Quantifier_Result_1 := If_Result_3;
   

            
   --# end


               exit when not Quantifier_Result_1;

         end loop;
      end;
   

   
   



--# expr-done 1289
   If_Result_4 := Quantifier_Result_1;
else
   
   If_Result_4 := False;
end if;



--# expr-done 1290
   If_Result_5 := If_Result_4;
end if;



--# expr-done 1291
Scope_Result_1 := If_Result_5;


   --# end
      Finalizer_Scope_616;


   Result_Var_2 := Scope_Result_1;
else
   
   Result_Var_2 := True;
end if;



--# expr-done 1292
Let_Result := Result_Var_2; 
--# end
--# expr-done 1293
Scope_Result_2 := Let_Result;


   --# end
      Finalizer_Scope_614;



         Property_Result := Scope_Result_2;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_614;
                     Finalizer_Scope_615;
                     Finalizer_Scope_616;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Is_Valid_Call;
--# end

   







--# property-start TypeDecl.get_return_type nodes.lkt:2147
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Get_Return_Type
  
  (Node : Bare_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;

      

      Cast_Result : Internal_Entity_Function_Type;
Var_Expr : Internal_Entity_Function_Type;
Fld : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         


--# expr-start 1294 Cast Cast_Result nodes.lkt:2148









   if Ent.Node = null
      or else Ent.Node.Kind in Lkt_Function_Type_Range
   then
      
      Cast_Result := Create_Internal_Entity_Function_Type
        (Node => Ent.Node,
         Info => Ent.Info);

   else
         Cast_Result := No_Entity_Function_Type;
   end if;


--# expr-done 1294
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Function_Type then
   --# expr-start 1295 FunctionType.return_type Fld nodes.lkt:2148







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Var_Expr.Node.Function_Type_F_Return_Type;
--# expr-done 1295
   Result_Var := Fld;
else
   
   Result_Var := No_Entity_Type_Decl;
end if;




         Property_Result := Result_Var;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Get_Return_Type;
--# end

   







--# property-start TypeDecl.create_function_type nodes.lkt:2152
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Create_Function_Type
  
  (Node : Bare_Type_Decl
      ; Params : Internal_Entity_Type_Decl_Array_Access
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind params Params

   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_208 with Inline_Always;

      Array_Lit : Internal_Entity_Type_Decl_Array_Access;
Concat_Result : Internal_Entity_Type_Decl_Array_Access;
Is_Null : Boolean;
Not_Val : Boolean;
Find_Result : Internal_Entity_Type_Decl;
Var_Expr : Internal_Entity_Type_Decl;
Var_Expr_1 : Internal_Entity_Type_Decl;
Scope_Result : Internal_Entity_Type_Decl;
Fld : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;
Fld_1 : Internal_Entity_Function_Type;
Scope_Result_1 : Internal_Entity_Function_Type;
Result_Var_1 : Internal_Entity_Function_Type;
Cast_Result : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_208 is
            begin
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Concat_Result);
            end Finalizer_Scope_208;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         




--# expr-start 1304 .do Result_Var_1 nodes.lkt:2155



--# expr-start 1300 .find Find_Result nodes.lkt:2155








   

   --# expr-start 1297 ArrayConcat Concat_Result nodes.lkt:2155
--# expr-start 1296 ArrayLiteral Array_Lit nodes.lkt:2155

Array_Lit := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Ent)); 
--# expr-done 1296

Concat_Result := Concat (Array_Lit, Params); 
--# expr-done 1297

   
      Find_Result := No_Entity_Type_Decl;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Type_Decl_Array_Access := Concat_Result;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind t Item

            
      --# expr-start 1299 Not Not_Val nodes.lkt:2155
--# expr-start 1298 .is_null Is_Null nodes.lkt:2155

Is_Null := Item.Node = null; 
--# expr-done 1298
Not_Val := not (Is_Null); 
--# expr-done 1299
      if Not_Val then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Not_Val;

         end loop;
      end;
   

   
   



--# expr-done 1300
Var_Expr := Find_Result;





if Var_Expr /= No_Entity_Type_Decl then
   



   --# scope-start



--# expr-start 1303 LktNode.function_type_helper Fld_1 nodes.lkt:2157







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# expr-start 1302 .do Result_Var nodes.lkt:2159




Var_Expr_1 := Ent;





if Var_Expr_1 /= No_Entity_Type_Decl then
   



   --# scope-start




Scope_Result := Var_Expr_1;


   --# end


   Result_Var := Scope_Result;
else
   --# expr-start 1301 LktNode.any_type Fld nodes.lkt:2159







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.any_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Any_Type (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 1301
   Result_Var := Fld;
end if;



--# expr-done 1302

--# property-call-start LktNode.function_type_helper
Fld_1 := Liblktlang.Implementation.Lkt_Node_P_Function_Type_Helper (Node => Var_Expr.Node, Param_Types => Params, Return_Type => Result_Var, Origin => No_Entity_Decl, E_Info => Var_Expr.Info);
--# end
--# expr-done 1303
Scope_Result_1 := Fld_1;


   --# end


   Result_Var_1 := Scope_Result_1;
else
   
   Result_Var_1 := No_Entity_Function_Type;
end if;



--# expr-done 1304



   
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => Result_Var_1.Node,
         Info => Result_Var_1.Info);



         Property_Result := Cast_Result;
         
   --# end
      Finalizer_Scope_208;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_208;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Create_Function_Type;
--# end

   







--# property-start TypeDecl.make_array_type nodes.lkt:2167
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Make_Array_Type
  
  (Node : Bare_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_209 with Inline_Always;

      Var_Expr : Internal_Entity_Type_Decl;
Fld : Internal_Entity_Named_Type_Decl;
Array_Lit : Internal_Entity_Type_Decl_Array_Access;
Fld_1 : Internal_Entity_Decl;
Result_Var : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_209 is
            begin
                     Dec_Ref (Array_Lit);
            end Finalizer_Scope_209;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Type_Decl_Type_Decl_P_Make_Array_Type,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Type_Decl,
                                As_Bare_Type_Decl => Self);
               Mmz_K.Items (2) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Entity_Type_Decl;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 1308 Cast Cast_Result nodes.lkt:2168









Var_Expr := Ent;





if Var_Expr /= No_Entity_Type_Decl then
   --# expr-start 1307 Decl.instantiate_generic_decl Fld_1 nodes.lkt:2168



--# expr-start 1305 LktNode.array_type Fld nodes.lkt:2168







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.array_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Array_Type (Node => Var_Expr.Node);
--# end
--# expr-done 1305



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1306 ArrayLiteral Array_Lit nodes.lkt:2168

Array_Lit := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Ent)); 
--# expr-done 1306
--# property-call-start Decl.instantiate_generic_decl
Fld_1 := Liblktlang.Implementation.Decl_P_Instantiate_Generic_Decl (Node => Fld.Node, Param_Types => Array_Lit, E_Info => Fld.Info);
--# end
--# expr-done 1307
   Result_Var := Fld_1;
else
   
   Result_Var := No_Entity_Decl;
end if;






   if Result_Var.Node = null
      or else Result_Var.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => Result_Var.Node,
         Info => Result_Var.Info);

   else
         Cast_Result := No_Entity_Type_Decl;
   end if;


--# expr-done 1308

         Property_Result := Cast_Result;
         
   --# end
      Finalizer_Scope_209;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_209;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Entity_Type_Decl,
                     As_Internal_Entity_Type_Decl => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Type_Decl_P_Make_Array_Type;
--# end

   







--# property-start TypeDecl.get_array_content_type nodes.lkt:2171
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Get_Array_Content_Type
  
  (Node : Bare_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_623 with Inline_Always;

      Fld : Boolean;
Origin : Internal_Entity;
Fld_1 : Lexical_Env := Empty_Env;
Sym : Symbol_Type;
Env_Get_Result : Internal_Entity;
Cast_Result : Internal_Entity_Fun_Decl;
Fld_2 : Internal_Entity_Type_Ref;
Fld_3 : Internal_Entity_Type_Decl;
Cast_Result_1 : Internal_Entity;
Dyn_Var_Bind_Result : Internal_Entity_Type_Decl;
Scope_Result : Internal_Entity_Type_Decl;
If_Result : Internal_Entity_Type_Decl;
Is_Null : Boolean;
If_Result_1 : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_623 is
            begin
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_623;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1319 If If_Result_1 nodes.lkt:2172



--# expr-start 1309 .is_null Is_Null nodes.lkt:2172

Is_Null := Ent.Node = null; 
--# expr-done 1309
if Is_Null then
   
   If_Result_1 := No_Entity_Type_Decl;
else
   --# expr-start 1318 If If_Result nodes.lkt:2172



--# expr-start 1310 TypeDecl.is_of_array_type Fld nodes.lkt:2173







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.is_of_array_type
Fld := Liblktlang.Implementation.Type_Decl_P_Is_Of_Array_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1310
if Fld then
   



   --# scope-start



--# expr-start 1317 bind Dyn_Var_Bind_Result nodes.lkt:2179









   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);


Origin := Cast_Result_1; 
--# expr-start 1316 TypeRef.referenced_decl Fld_3 nodes.lkt:2181



--# expr-start 1315 FunDecl.return_type Fld_2 nodes.lkt:2181



--# expr-start 1314 Cast Cast_Result nodes.lkt:2181





--# expr-start 1313 .get_first Env_Get_Result nodes.lkt:2181
--# expr-start 1311 Decl.defined_scope Fld_1 nodes.lkt:2181







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_1 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Ent.Node, Origin => Origin, E_Info => Ent.Info);
--# end
--# expr-done 1311
--# expr-start 1312 SymbolLiteral Sym nodes.lkt:2181
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Call); 
--# expr-done 1312


Env_Get_Result := AST_Envs.Get_First (Self => Fld_1, Key => Thin (Sym), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 1313



   if Env_Get_Result.Node = null
      or else Env_Get_Result.Node.Kind in Lkt_Fun_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Fun_Decl
        (Node => Env_Get_Result.Node,
         Info => Env_Get_Result.Info);

   else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "invalid object cast");
   end if;


--# expr-done 1314



   if Cast_Result.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Type_Ref (Node => Cast_Result.Node.Fun_Decl_F_Return_Type, Info => Cast_Result.Info);
--# expr-done 1315



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_3 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Fld_2.Node, E_Info => Fld_2.Info);
--# end
--# expr-done 1316
Dyn_Var_Bind_Result := Fld_3; 
--# expr-done 1317
Scope_Result := Dyn_Var_Bind_Result;


   --# end
      Finalizer_Scope_623;


   If_Result := Scope_Result;
else
   
   If_Result := No_Entity_Type_Decl;
end if;



--# expr-done 1318
   If_Result_1 := If_Result;
end if;



--# expr-done 1319

         Property_Result := If_Result_1;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_623;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Get_Array_Content_Type;
--# end

   







--# property-start TypeDecl.get_super_of_parent nodes.lkt:2190
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Get_Super_Of_Parent
  
  (Node : Bare_Type_Decl
      ; Origin : Internal_Entity
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Decl
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind origin Origin

   Property_Result : Internal_Entity_Decl;

      
            procedure Finalizer_Scope_211 with Inline_Always;

      Var_Expr : Internal_Entity_Type_Decl;
Fld : Internal_Entity_Type_Decl;
Var_Expr_1 : Internal_Entity_Type_Decl;
Fld_1 : Lexical_Env := Empty_Env;
Cast_Result : Internal_Entity_Fun_Decl;
Fld_2 : Symbol_Type;
Env_Get_Result : Internal_Entity;
Result_Var : Internal_Entity;
Result_Var_1 : Internal_Entity;
Cast_Result_1 : Internal_Entity_Decl;
Var_Expr_2 : Internal_Entity_Decl;
Fld_3 : Internal_Entity_Decl;
Result_Var_2 : Internal_Entity_Decl;

            procedure Finalizer_Scope_211 is
            begin
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_211;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         


--# expr-start 1325 Cast Cast_Result_1 nodes.lkt:2191









Var_Expr := Ent;





if Var_Expr /= No_Entity_Type_Decl then
   


--# expr-start 1320 TypeDecl.base_type_if_entity Fld nodes.lkt:2191







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.base_type_if_entity
Fld := Liblktlang.Implementation.Type_Decl_P_Base_Type_If_Entity (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 1320
Var_Expr_1 := Fld;





if Var_Expr_1 /= No_Entity_Type_Decl then
   --# expr-start 1324 .get_first Env_Get_Result nodes.lkt:2191
--# expr-start 1321 Decl.defined_scope Fld_1 nodes.lkt:2191







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_1 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Var_Expr_1.Node, Origin => Origin, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 1321
--# expr-start 1323 Decl.name Fld_2 nodes.lkt:2192



--# expr-start 1322 Cast Cast_Result nodes.lkt:2192









   if Origin.Node = null
      or else Origin.Node.Kind in Lkt_Fun_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Fun_Decl
        (Node => Origin.Node,
         Info => Origin.Info);

   else
         Cast_Result := No_Entity_Fun_Decl;
   end if;


--# expr-done 1322



   if Cast_Result.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_2 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Cast_Result.Node);
--# end
--# expr-done 1323


Env_Get_Result := AST_Envs.Get_First (Self => Fld_1, Key => Thin (Fld_2), Lookup_Kind => To_Lookup_Kind_Type (Flat), Categories => (Nocat => True)); 
--# expr-done 1324
   Result_Var := Env_Get_Result;
else
   
   Result_Var := No_Entity;
end if;



   Result_Var_1 := Result_Var;
else
   
   Result_Var_1 := No_Entity;
end if;






   if Result_Var_1.Node = null
      or else Result_Var_1.Node.Kind in Lkt_Decl
   then
      
      Cast_Result_1 := Create_Internal_Entity_Decl
        (Node => Result_Var_1.Node,
         Info => Result_Var_1.Info);

   else
         Cast_Result_1 := No_Entity_Decl;
   end if;


--# expr-done 1325
Var_Expr_2 := Cast_Result_1;





if Var_Expr_2 /= No_Entity_Decl then
   --# expr-start 1326 Decl.subdecl_if_generic Fld_3 nodes.lkt:2191







   if Var_Expr_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.subdecl_if_generic
Fld_3 := Liblktlang.Implementation.Decl_P_Subdecl_If_Generic (Node => Var_Expr_2.Node, E_Info => Var_Expr_2.Info);
--# end
--# expr-done 1326
   Result_Var_2 := Fld_3;
else
   
   Result_Var_2 := No_Entity_Decl;
end if;




         Property_Result := Result_Var_2;
         
   --# end
      Finalizer_Scope_211;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_211;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Get_Super_Of_Parent;
--# end

   







--# property-start TypeDecl.basic_trait_from_self nodes.lkt:2200
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Basic_Trait_From_Self
  
  (Node : Bare_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_212 with Inline_Always;

      Fld : Internal_Entity_Trait_Decl;
Array_Lit : Internal_Entity_Type_Decl_Array_Access;
Fld_1 : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_212 is
            begin
                     Dec_Ref (Array_Lit);
            end Finalizer_Scope_212;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1330 Cast Cast_Result nodes.lkt:2201





--# expr-start 1329 Decl.instantiate_generic_decl Fld_1 nodes.lkt:2201



--# expr-start 1327 LktNode.basic_trait Fld nodes.lkt:2201







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.basic_trait
Fld := Liblktlang.Implementation.Lkt_Node_P_Basic_Trait (Node => Ent.Node);
--# end
--# expr-done 1327



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1328 ArrayLiteral Array_Lit nodes.lkt:2201

Array_Lit := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Ent)); 
--# expr-done 1328
--# property-call-start Decl.instantiate_generic_decl
Fld_1 := Liblktlang.Implementation.Decl_P_Instantiate_Generic_Decl (Node => Fld.Node, Param_Types => Array_Lit, E_Info => Fld.Info);
--# end
--# expr-done 1329



   if Fld_1.Node = null
      or else Fld_1.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => Fld_1.Node,
         Info => Fld_1.Info);

   else
         Cast_Result := No_Entity_Type_Decl;
   end if;


--# expr-done 1330

         Property_Result := Cast_Result;
         
   --# end
      Finalizer_Scope_212;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_212;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Basic_Trait_From_Self;
--# end

   







--# property-start TypeDecl.find_types_that_replace_ty nodes.lkt:2212
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Find_Types_That_Replace_Ty
  
  (Node : Bare_Type_Decl
      ; Ty : Internal_Entity_Type_Decl
      ; Origin : Internal_Entity_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl_Array_Access
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind ty Ty
   --# bind origin Origin

   Property_Result : Internal_Entity_Type_Decl_Array_Access;

      
            procedure Finalizer_Scope_213 with Inline_Always;
            procedure Finalizer_Scope_624 with Inline_Always;
            procedure Finalizer_Scope_625 with Inline_Always;
            procedure Finalizer_Scope_626 with Inline_Always;
            procedure Finalizer_Scope_627 with Inline_Always;
            procedure Finalizer_Scope_628 with Inline_Always;
            procedure Finalizer_Scope_629 with Inline_Always;
            procedure Finalizer_Scope_630 with Inline_Always;

      Cast_Result : Internal_Entity_Function_Type;
Var_Expr : Internal_Entity_Function_Type;
Fld : Internal_Entity_Type_Decl_Array_Access;
Fld_1 : Internal_Entity_Type_Decl;
Array_Lit : Internal_Entity_Type_Decl_Array_Access;
Concat_Result : Internal_Entity_Type_Decl_Array_Access;
Var_Expr_1 : Internal_Entity_Type_Decl_Array_Access;
Cast_Result_1 : Internal_Entity_Function_Type;
Var_Expr_2 : Internal_Entity_Function_Type;
Fld_2 : Internal_Entity_Type_Decl_Array_Access;
Fld_3 : Internal_Entity_Type_Decl;
Array_Lit_1 : Internal_Entity_Type_Decl_Array_Access;
Concat_Result_1 : Internal_Entity_Type_Decl_Array_Access;
Index : Integer;
Get_Result : Internal_Entity_Type_Decl;
Var_Expr_3 : Internal_Entity_Type_Decl;
Fld_4 : Internal_Entity_Type_Decl_Array_Access;
Result_Var : Internal_Entity_Type_Decl_Array_Access;
Map_Result : Internal_Entity_Type_Decl_Array_Access;
Scope_Result : Internal_Entity_Type_Decl_Array_Access;
Result_Var_1 : Internal_Entity_Type_Decl_Array_Access;
Scope_Result_1 : Internal_Entity_Type_Decl_Array_Access;
Result_Var_2 : Internal_Entity_Type_Decl_Array_Access;
Scope_Result_2 : Internal_Entity_Type_Decl_Array_Access;
Fld_5 : Internal_Entity;
Cast_Result_2 : Internal_Entity_Generic_Decl;
Var_Expr_4 : Internal_Entity_Generic_Decl;
Fld_6 : Internal_Entity;
Cast_Result_3 : Internal_Entity_Generic_Decl;
Var_Expr_5 : Internal_Entity_Generic_Decl;
Fld_7 : Internal_Entity_Type_Decl_Array_Access;
Index_1 : Integer;
Fld_8 : Internal_Entity_Type_Decl_Array_Access;
Get_Result_1 : Internal_Entity_Type_Decl;
Fld_9 : Internal_Entity_Type_Decl_Array_Access;
Map_Result_1 : Internal_Entity_Type_Decl_Array_Access;
Scope_Result_3 : Internal_Entity_Type_Decl_Array_Access;
Result_Var_3 : Internal_Entity_Type_Decl_Array_Access;
Scope_Result_4 : Internal_Entity_Type_Decl_Array_Access;
Result_Var_4 : Internal_Entity_Type_Decl_Array_Access;
Result_Var_5 : Internal_Entity_Type_Decl_Array_Access;
Cast_Result_4 : Internal_Entity;
Cast_Result_5 : Internal_Entity;
Is_Equiv : Boolean;
Is_A : Boolean;
Not_Val : Boolean;
If_Result : Boolean;
Array_Lit_2 : Internal_Entity_Type_Decl_Array_Access;
If_Result_1 : Internal_Entity_Type_Decl_Array_Access;

            procedure Finalizer_Scope_213 is
            begin
                     Dec_Ref (Scope_Result_2);
                     Dec_Ref (Scope_Result_4);
                     Dec_Ref (Result_Var_4);
                     Dec_Ref (Result_Var_5);
                     Dec_Ref (Array_Lit_2);
                     Dec_Ref (If_Result_1);
            end Finalizer_Scope_213;
            procedure Finalizer_Scope_624 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Concat_Result);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (Result_Var_2);
            end Finalizer_Scope_624;
            procedure Finalizer_Scope_625 is
            begin
                     Dec_Ref (Var_Expr_1);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Result_Var_1);
            end Finalizer_Scope_625;
            procedure Finalizer_Scope_626 is
            begin
                     Dec_Ref (Fld_2);
                     Dec_Ref (Array_Lit_1);
                     Dec_Ref (Concat_Result_1);
                     Dec_Ref (Map_Result);
            end Finalizer_Scope_626;
            procedure Finalizer_Scope_627 is
            begin
                     Dec_Ref (Fld_4);
                     Dec_Ref (Result_Var);
            end Finalizer_Scope_627;
            procedure Finalizer_Scope_628 is
            begin
                     Dec_Ref (Scope_Result_3);
                     Dec_Ref (Result_Var_3);
            end Finalizer_Scope_628;
            procedure Finalizer_Scope_629 is
            begin
                     Dec_Ref (Fld_7);
                     Dec_Ref (Map_Result_1);
            end Finalizer_Scope_629;
            procedure Finalizer_Scope_630 is
            begin
                     Dec_Ref (Fld_8);
                     Dec_Ref (Fld_9);
            end Finalizer_Scope_630;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1363 If If_Result_1 nodes.lkt:2216



--# expr-start 1334 BooleanAnd If_Result nodes.lkt:2216



--# expr-start 1331 Eq Is_Equiv nodes.lkt:2216









   
      Cast_Result_4 := Create_Internal_Entity
        (Node => Origin.Node,
         Info => Origin.Info);











   
      Cast_Result_5 := Create_Internal_Entity
        (Node => Ty.Node,
         Info => Ty.Info);


Is_Equiv := Equivalent (Cast_Result_4, Cast_Result_5); 
--# expr-done 1331
if Is_Equiv then
   --# expr-start 1333 Not Not_Val nodes.lkt:2216
--# expr-start 1332 IsA Is_A nodes.lkt:2216

Is_A := Ent.Node /= null 
and then Ent.Node.Kind in Lkt_Any_Type_Decl_Range; 
--# expr-done 1332
Not_Val := not (Is_A); 
--# expr-done 1333
   If_Result := Not_Val;
else
   
   If_Result := False;
end if;



--# expr-done 1334
if If_Result then
   --# expr-start 1335 ArrayLiteral Array_Lit_2 nodes.lkt:2219

Array_Lit_2 := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Ent)); 
--# expr-done 1335
   If_Result_1 := Array_Lit_2;
else
   --# expr-start 1362 .do Result_Var_5 nodes.lkt:2223



--# expr-start 1336 Cast Cast_Result nodes.lkt:2223









   if Ent.Node = null
      or else Ent.Node.Kind in Lkt_Function_Type_Range
   then
      
      Cast_Result := Create_Internal_Entity_Function_Type
        (Node => Ent.Node,
         Info => Ent.Info);

   else
         Cast_Result := No_Entity_Function_Type;
   end if;


--# expr-done 1336
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Function_Type then
   



   --# scope-start



--# expr-start 1350 .do Result_Var_2 nodes.lkt:2225



--# expr-start 1340 ArrayConcat Concat_Result nodes.lkt:2225
--# expr-start 1337 FunctionType.params Fld nodes.lkt:2225







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Var_Expr.Node.Function_Type_F_Params;
Inc_Ref (Fld);
--# expr-done 1337
--# expr-start 1339 ArrayLiteral Array_Lit nodes.lkt:2225
--# expr-start 1338 FunctionType.return_type Fld_1 nodes.lkt:2225







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Var_Expr.Node.Function_Type_F_Return_Type;
--# expr-done 1338
Array_Lit := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Fld_1)); 
--# expr-done 1339
Concat_Result := Concat (Fld, Array_Lit); 
--# expr-done 1340
Var_Expr_1 := Concat_Result;

      Inc_Ref (Var_Expr_1);




if Var_Expr_1 /= No_Internal_Entity_Type_Decl_Array_Type then
   



   --# scope-start



--# expr-start 1349 .do Result_Var_1 nodes.lkt:2227



--# expr-start 1341 Cast Cast_Result_1 nodes.lkt:2227









   if Origin.Node = null
      or else Origin.Node.Kind in Lkt_Function_Type_Range
   then
      
      Cast_Result_1 := Create_Internal_Entity_Function_Type
        (Node => Origin.Node,
         Info => Origin.Info);

   else
         Cast_Result_1 := No_Entity_Function_Type;
   end if;


--# expr-done 1341
Var_Expr_2 := Cast_Result_1;





if Var_Expr_2 /= No_Entity_Function_Type then
   



   --# scope-start



--# expr-start 1348 .imapcat Map_Result nodes.lkt:2229








   

   --# expr-start 1345 ArrayConcat Concat_Result_1 nodes.lkt:2229
--# expr-start 1342 FunctionType.params Fld_2 nodes.lkt:2229







   if Var_Expr_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Var_Expr_2.Node.Function_Type_F_Params;
Inc_Ref (Fld_2);
--# expr-done 1342
--# expr-start 1344 ArrayLiteral Array_Lit_1 nodes.lkt:2229
--# expr-start 1343 FunctionType.return_type Fld_3 nodes.lkt:2229







   if Var_Expr_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Var_Expr_2.Node.Function_Type_F_Return_Type;
--# expr-done 1343
Array_Lit_1 := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Fld_3)); 
--# expr-done 1344
Concat_Result_1 := Concat (Fld_2, Array_Lit_1); 
--# expr-done 1345

   
      declare
         Map_Result_Vec : Internal_Entity_Type_Decl_Vectors.Vector;
      begin
   

   

      
         Index := 0;

      declare
         
         Collection : constant Internal_Entity_Type_Decl_Array_Access := Concat_Result_1;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind ot Item
               --# bind idx Index

            
         
         
      


--# expr-start 1346 .at Get_Result nodes.lkt:2231




Get_Result := Get (Self, Var_Expr_1, Index, True); 
--# expr-done 1346
Var_Expr_3 := Get_Result;





if Var_Expr_3 /= No_Entity_Type_Decl then
   --# expr-start 1347 TypeDecl.find_types_that_replace_ty Fld_4 nodes.lkt:2231







   if Var_Expr_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;




--# property-call-start TypeDecl.find_types_that_replace_ty
Fld_4 := Liblktlang.Implementation.Type_Decl_P_Find_Types_That_Replace_Ty (Node => Var_Expr_3.Node, Ty => Ty, Origin => Item, E_Info => Var_Expr_3.Info);
--# end
--# expr-done 1347
   Result_Var := Fld_4;
else
   
   Result_Var := No_Internal_Entity_Type_Decl_Array_Type;
end if;

      Inc_Ref (Result_Var);


      

         for Item_To_Append of
               Result_Var.Items
         loop
            Internal_Entity_Type_Decl_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end loop;

   
   
   

            
   --# end
      Finalizer_Scope_627;



               Index := Index + 1;
         end loop;
      end;
   

   

         Map_Result := Create_Internal_Entity_Type_Decl_Array
           (Items_Count => Natural (Internal_Entity_Type_Decl_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Type_Decl_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Type_Decl_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Type_Decl_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1348
Scope_Result := Map_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_626;


   Result_Var_1 := Scope_Result;
else
   
   Result_Var_1 := No_Internal_Entity_Type_Decl_Array_Type;
end if;

      Inc_Ref (Result_Var_1);


--# expr-done 1349
Scope_Result_1 := Result_Var_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_625;


   Result_Var_2 := Scope_Result_1;
else
   
   Result_Var_2 := No_Internal_Entity_Type_Decl_Array_Type;
end if;

      Inc_Ref (Result_Var_2);


--# expr-done 1350
Scope_Result_2 := Result_Var_2;
   Inc_Ref (Scope_Result_2);


   --# end
      Finalizer_Scope_624;


   Result_Var_5 := Scope_Result_2;
else
   --# expr-start 1361 .do Result_Var_4 nodes.lkt:2238



--# expr-start 1352 Cast Cast_Result_2 nodes.lkt:2238





--# expr-start 1351 .parent Fld_5 nodes.lkt:2238







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Liblktlang.Implementation.Parent (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 1351



   if Fld_5.Node = null
      or else Fld_5.Node.Kind in Lkt_Generic_Decl_Range
   then
      
      Cast_Result_2 := Create_Internal_Entity_Generic_Decl
        (Node => Fld_5.Node,
         Info => Fld_5.Info);

   else
         Cast_Result_2 := No_Entity_Generic_Decl;
   end if;


--# expr-done 1352
Var_Expr_4 := Cast_Result_2;





if Var_Expr_4 /= No_Entity_Generic_Decl then
   



   --# scope-start



--# expr-start 1360 .do Result_Var_3 nodes.lkt:2240



--# expr-start 1354 Cast Cast_Result_3 nodes.lkt:2240





--# expr-start 1353 .parent Fld_6 nodes.lkt:2240







   if Origin.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Liblktlang.Implementation.Parent (Node => Origin.Node, E_Info => Origin.Info);
--# expr-done 1353



   if Fld_6.Node = null
      or else Fld_6.Node.Kind in Lkt_Generic_Decl_Range
   then
      
      Cast_Result_3 := Create_Internal_Entity_Generic_Decl
        (Node => Fld_6.Node,
         Info => Fld_6.Info);

   else
         Cast_Result_3 := No_Entity_Generic_Decl;
   end if;


--# expr-done 1354
Var_Expr_5 := Cast_Result_3;





if Var_Expr_5 /= No_Entity_Generic_Decl then
   



   --# scope-start



--# expr-start 1359 .imapcat Map_Result_1 nodes.lkt:2242








   

   --# expr-start 1355 GenericDecl.instantiated_generic_params Fld_7 nodes.lkt:2242







   if Var_Expr_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start GenericDecl.instantiated_generic_params
Fld_7 := Liblktlang.Implementation.Generic_Decl_P_Instantiated_Generic_Params (Node => Var_Expr_4.Node, E_Info => Var_Expr_4.Info);
--# end
--# expr-done 1355

   
      declare
         Map_Result_1_Vec : Internal_Entity_Type_Decl_Vectors.Vector;
      begin
   

   

      
         Index_1 := 0;

      declare
         
         Collection : constant Internal_Entity_Type_Decl_Array_Access := Fld_7;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind t Item_1
               --# bind i Index_1

            
         
         
      --# expr-start 1358 TypeDecl.find_types_that_replace_ty Fld_9 nodes.lkt:2244







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# expr-start 1357 .at Get_Result_1 nodes.lkt:2246

--# expr-start 1356 GenericDecl.instantiated_generic_params Fld_8 nodes.lkt:2246







   if Var_Expr_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start GenericDecl.instantiated_generic_params
Fld_8 := Liblktlang.Implementation.Generic_Decl_P_Instantiated_Generic_Params (Node => Var_Expr_5.Node, E_Info => Var_Expr_5.Info);
--# end
--# expr-done 1356


Get_Result_1 := Get (Self, Fld_8, Index_1, True); 
--# expr-done 1357
--# property-call-start TypeDecl.find_types_that_replace_ty
Fld_9 := Liblktlang.Implementation.Type_Decl_P_Find_Types_That_Replace_Ty (Node => Item_1.Node, Ty => Ty, Origin => Get_Result_1, E_Info => Item_1.Info);
--# end
--# expr-done 1358
      

         for Item_To_Append of
               Fld_9.Items
         loop
            Internal_Entity_Type_Decl_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end loop;

   
   
   

            
   --# end
      Finalizer_Scope_630;



               Index_1 := Index_1 + 1;
         end loop;
      end;
   

   

         Map_Result_1 := Create_Internal_Entity_Type_Decl_Array
           (Items_Count => Natural (Internal_Entity_Type_Decl_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Internal_Entity_Type_Decl_Vectors.Get
              (Map_Result_1_Vec,
               I + Internal_Entity_Type_Decl_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Internal_Entity_Type_Decl_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 1359
Scope_Result_3 := Map_Result_1;
   Inc_Ref (Scope_Result_3);


   --# end
      Finalizer_Scope_629;


   Result_Var_3 := Scope_Result_3;
else
   
   Result_Var_3 := No_Internal_Entity_Type_Decl_Array_Type;
end if;

      Inc_Ref (Result_Var_3);


--# expr-done 1360
Scope_Result_4 := Result_Var_3;
   Inc_Ref (Scope_Result_4);


   --# end
      Finalizer_Scope_628;


   Result_Var_4 := Scope_Result_4;
else
   
   Result_Var_4 := No_Internal_Entity_Type_Decl_Array_Type;
end if;

      Inc_Ref (Result_Var_4);


--# expr-done 1361
   Result_Var_5 := Result_Var_4;
end if;

      Inc_Ref (Result_Var_5);


--# expr-done 1362
   If_Result_1 := Result_Var_5;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 1363

         Property_Result := If_Result_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_213;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_213;
                     Finalizer_Scope_624;
                     Finalizer_Scope_625;
                     Finalizer_Scope_626;
                     Finalizer_Scope_627;
                     Finalizer_Scope_628;
                     Finalizer_Scope_629;
                     Finalizer_Scope_630;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Find_Types_That_Replace_Ty;
--# end

   







--# property-start TypeDecl.as_node_builder_type nodes.lkt:2257
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_As_Node_Builder_Type
  
  (Node : Bare_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_631 with Inline_Always;

      Cast_Result : Internal_Entity_Class_Decl;
Var_Expr : Internal_Entity_Class_Decl;
Fld : Internal_Entity_Named_Type_Decl;
Array_Lit : Internal_Entity_Type_Decl_Array_Access;
Fld_1 : Internal_Entity_Decl;
Scope_Result : Internal_Entity_Decl;
Cast_Result_1 : Internal_Entity_Decl;
Result_Var : Internal_Entity_Decl;
Cast_Result_2 : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_631 is
            begin
                     Dec_Ref (Array_Lit);
            end Finalizer_Scope_631;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1369 Cast Cast_Result_2 nodes.lkt:2258





--# expr-start 1368 .do Result_Var nodes.lkt:2258



--# expr-start 1364 Cast Cast_Result nodes.lkt:2258









   if Ent.Node = null
      or else Ent.Node.Kind in Lkt_Class_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Class_Decl
        (Node => Ent.Node,
         Info => Ent.Info);

   else
         Cast_Result := No_Entity_Class_Decl;
   end if;


--# expr-done 1364
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Class_Decl then
   



   --# scope-start



--# expr-start 1367 Decl.instantiate_generic_decl Fld_1 nodes.lkt:2259



--# expr-start 1365 LktNode.node_builder_type Fld nodes.lkt:2259







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.node_builder_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Node_Builder_Type (Node => Ent.Node);
--# end
--# expr-done 1365



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1366 ArrayLiteral Array_Lit nodes.lkt:2259

Array_Lit := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Ent)); 
--# expr-done 1366
--# property-call-start Decl.instantiate_generic_decl
Fld_1 := Liblktlang.Implementation.Decl_P_Instantiate_Generic_Decl (Node => Fld.Node, Param_Types => Array_Lit, E_Info => Fld.Info);
--# end
--# expr-done 1367
Scope_Result := Fld_1;


   --# end
      Finalizer_Scope_631;


   Result_Var := Scope_Result;
else
   








   
      Cast_Result_1 := Create_Internal_Entity_Decl
        (Node => Ent.Node,
         Info => Ent.Info);


   Result_Var := Cast_Result_1;
end if;



--# expr-done 1368



   if Result_Var.Node = null
      or else Result_Var.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_2 := Create_Internal_Entity_Type_Decl
        (Node => Result_Var.Node,
         Info => Result_Var.Info);

   else
         Cast_Result_2 := No_Entity_Type_Decl;
   end if;


--# expr-done 1369

         Property_Result := Cast_Result_2;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_631;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_As_Node_Builder_Type;
--# end

   







--# property-start '[dispatcher]TypeDecl.base_types' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Type_Decl_P_Base_Types
  
  (Node : Bare_Type_Decl
      ; Include_Self : Boolean
         := False
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl_Array_Access
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind include_self Include_Self

   Property_Result : Internal_Entity_Type_Decl_Array_Access;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Type_Decl (Self.Kind) is
               when Lkt_Any_Type_Decl | Lkt_Function_Type .. Lkt_Trait_Decl =>
                  --# property-call-start 'TypeDecl.[root-static]base_types'
                  Property_Result := Type_Decl_P_Base_Types
                    (Self
                        , Include_Self
                        , E_Info
                    );
                  --# end
               when Lkt_Enum_Class_Alt_Decl =>
                  --# property-call-start EnumClassAltDecl.base_types
                  Property_Result := Enum_Class_Alt_Decl_P_Base_Types
                    (Self
                        , Include_Self
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Type_Decl_P_Base_Types;
--# end

   







--# property-start '[dispatcher]TypeDecl.is_subtype' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Type_Decl_P_Is_Subtype
  
  (Node : Bare_Type_Decl
      ; Other : Internal_Entity_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind other Other

   Property_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Type_Decl (Self.Kind) is
               when Lkt_Any_Type_Decl | Lkt_Function_Type .. Lkt_Generic_Param_Type_Decl | Lkt_Enum_Type_Decl .. Lkt_Trait_Decl =>
                  --# property-call-start 'TypeDecl.[root-static]is_subtype'
                  Property_Result := Type_Decl_P_Is_Subtype
                    (Self
                        , Other
                        , E_Info
                    );
                  --# end
               when Lkt_Enum_Class_Alt_Decl =>
                  --# property-call-start EnumClassAltDecl.is_subtype
                  Property_Result := Enum_Class_Alt_Decl_P_Is_Subtype
                    (Self
                        , Other
                        , E_Info
                    );
                  --# end
               when Lkt_Class_Decl .. Lkt_Enum_Class_Decl =>
                  --# property-call-start BasicClassDecl.is_subtype
                  Property_Result := Basic_Class_Decl_P_Is_Subtype
                    (Self
                        , Other
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Type_Decl_P_Is_Subtype;
--# end

   







--# property-start '[dispatcher]TypeDecl.common_ancestor' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Type_Decl_P_Common_Ancestor
  
  (Node : Bare_Type_Decl
      ; Other : Internal_Entity_Type_Decl
      ; Imprecise : Boolean
         := False
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind other Other
   --# bind imprecise Imprecise

   Property_Result : Internal_Entity_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Type_Decl (Self.Kind) is
               when Lkt_Any_Type_Decl .. Lkt_Generic_Param_Type_Decl | Lkt_Enum_Type_Decl .. Lkt_Trait_Decl =>
                  --# property-call-start 'TypeDecl.[root-static]common_ancestor'
                  Property_Result := Type_Decl_P_Common_Ancestor
                    (Self
                        , Other
                        , Imprecise
                        , E_Info
                    );
                  --# end
               when Lkt_Class_Decl .. Lkt_Enum_Class_Decl =>
                  --# property-call-start BasicClassDecl.common_ancestor
                  Property_Result := Basic_Class_Decl_P_Common_Ancestor
                    (Self
                        , Other
                        , Imprecise
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Type_Decl_P_Common_Ancestor;
--# end

   







--# property-start TypeDecl.node_builder_scope nodes.lkt:2305
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Node_Builder_Scope
  
  (Node : Bare_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Lexical_Env
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Lexical_Env;

      
            procedure Finalizer_Scope_218 with Inline_Always;
            procedure Finalizer_Scope_635 with Inline_Always;
            procedure Finalizer_Scope_637 with Inline_Always;
            procedure Finalizer_Scope_638 with Inline_Always;
            procedure Finalizer_Scope_640 with Inline_Always;

      Fld : Internal_Entity_Full_Decl;
Sym : Symbol_Type;
Fld_1 : Boolean;
Is_A : Boolean;
If_Result : Boolean;
Fld_2 : Internal_Entity_Type_Decl_Array_Access;
Fld_3 : Bare_Type_Decl;
Fld_4 : Internal_Entity_Named_Type_Decl;
Fld_5 : Bare_Named_Type_Decl;
Cast_Result : Bare_Type_Decl;
Is_Equal : Boolean;
Find_Result : Internal_Entity_Type_Decl;
Var_Expr : Internal_Entity_Type_Decl;
Fld_6 : Internal_Entity_Type_Decl;
Local_Elt_T : Internal_Entity_Type_Decl;
Sym_1 : Symbol_Type;
Fld_7 : Internal_Entity_Type_Decl;
Fld_8 : Internal_Entity_Type_Decl;
New_Node : Bare_Synth_Param_Decl;
As_Entity : Internal_Entity_Synth_Param_Decl;
Is_Null : Boolean;
If_Result_1 : Internal_Entity_Synth_Param_Decl;
Cast_Result_1 : Internal_Entity_Decl;
New_Struct : Internal_Resolved_Param;
Singleton : Internal_Resolved_Param_Array_Access;
Let_Result : Internal_Resolved_Param_Array_Access;
Scope_Result : Internal_Resolved_Param_Array_Access;
Scope_Result_1 : Internal_Resolved_Param_Array_Access;
Result_Var : Internal_Resolved_Param_Array_Access;
Cast_Result_2 : Internal_Entity_Class_Decl;
Fld_9 : Internal_Entity_Field_Decl_Array_Access;
Fld_10 : Symbol_Type;
Fld_11 : Internal_Entity_Type_Decl;
Var_Expr_1 : Internal_Entity_Type_Decl;
Fld_12 : Internal_Entity_Type_Decl;
Result_Var_1 : Internal_Entity_Type_Decl;
New_Node_1 : Bare_Synth_Param_Decl;
As_Entity_1 : Internal_Entity_Synth_Param_Decl;
Is_Null_1 : Boolean;
If_Result_2 : Internal_Entity_Synth_Param_Decl;
Cast_Result_3 : Internal_Entity_Decl;
New_Struct_1 : Internal_Resolved_Param;
Map_Result : Internal_Resolved_Param_Array_Access;
Concat_Result : Internal_Resolved_Param_Array_Access;
Local_Params : Internal_Resolved_Param_Array_Access;
Sym_2 : Symbol_Type;
Array_Lit : Symbol_Type_Array_Access;
Fld_13 : Internal_Entity_Type_Decl;
New_Node_2 : Bare_Synth_Fun_Decl;
As_Entity_2 : Internal_Entity_Synth_Fun_Decl;
Is_Null_2 : Boolean;
If_Result_3 : Internal_Entity_Synth_Fun_Decl;
Fld_14 : Internal_Entity_Function_Type;
Cast_Result_4 : Internal_Entity_Type_Decl;
Array_Lit_1 : Internal_Entity_Type_Decl_Array_Access;
New_Node_3 : Bare_Dyn_Env_Wrapper;
Var_Expr_2 : Bare_Dyn_Env_Wrapper;
Fld_15 : Lexical_Env := Empty_Env;
Scope_Result_2 : Lexical_Env := Empty_Env;
Result_Var_2 : Lexical_Env := Empty_Env;
Let_Result_1 : Lexical_Env := Empty_Env;
Scope_Result_3 : Lexical_Env := Empty_Env;
If_Result_4 : Lexical_Env := Empty_Env;

            procedure Finalizer_Scope_218 is
            begin
                     Dec_Ref (Scope_Result_3);
                     Dec_Ref (If_Result_4);
            end Finalizer_Scope_218;
            procedure Finalizer_Scope_635 is
            begin
                     Dec_Ref (Fld_2);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (Result_Var);
                     Dec_Ref (Fld_9);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Concat_Result);
                     Dec_Ref (Local_Params);
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Array_Lit_1);
                     Dec_Ref (Scope_Result_2);
                     Dec_Ref (Result_Var_2);
                     Dec_Ref (Let_Result_1);
            end Finalizer_Scope_635;
            procedure Finalizer_Scope_637 is
            begin
                     Dec_Ref (Scope_Result);
            end Finalizer_Scope_637;
            procedure Finalizer_Scope_638 is
            begin
                     Dec_Ref (Singleton);
                     Dec_Ref (Let_Result);
            end Finalizer_Scope_638;
            procedure Finalizer_Scope_640 is
            begin
                     Dec_Ref (Fld_15);
            end Finalizer_Scope_640;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Type_Decl_Type_Decl_P_Node_Builder_Scope,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Type_Decl,
                                As_Bare_Type_Decl => Self);
               Mmz_K.Items (2) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Lexical_Env;
                  Inc_Ref (Property_Result);

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 1413 If If_Result_4 nodes.lkt:2306



--# expr-start 1374 BooleanAnd If_Result nodes.lkt:2306



--# expr-start 1372 FullDecl.has_annotation Fld_1 nodes.lkt:2306



--# expr-start 1370 Decl.full_decl Fld nodes.lkt:2306







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.full_decl
Fld := Liblktlang.Implementation.Decl_P_Full_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1370



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1371 SymbolLiteral Sym nodes.lkt:2306
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Synthetic); 
--# expr-done 1371
--# property-call-start FullDecl.has_annotation
Fld_1 := Liblktlang.Implementation.Full_Decl_P_Has_Annotation (Node => Fld.Node, Name => Sym);
--# end
--# expr-done 1372
if Fld_1 then
   --# expr-start 1373 IsA Is_A nodes.lkt:2306

Is_A := Ent.Node /= null 
and then Ent.Node.Kind in Lkt_Class_Decl_Range; 
--# expr-done 1373
   If_Result := Is_A;
else
   
   If_Result := False;
end if;



--# expr-done 1374
if If_Result then
   



   --# scope-start



--# expr-start 1412 ValDecl Let_Result_1 nodes.lkt:2308
--# scope-start
--# expr-start 1400 ArrayConcat Concat_Result nodes.lkt:2309
--# expr-start 1390 .do Result_Var nodes.lkt:2309



--# expr-start 1380 .find Find_Result nodes.lkt:2309








   

   --# expr-start 1375 TypeDecl.base_types Fld_2 nodes.lkt:2309







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]TypeDecl.base_types'
Fld_2 := Liblktlang.Implementation.Dispatcher_Type_Decl_P_Base_Types (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1375

   
      Find_Result := No_Entity_Type_Decl;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Type_Decl_Array_Access := Fld_2;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind t Item

            
      --# expr-start 1379 Eq Is_Equal nodes.lkt:2310
--# expr-start 1376 'Entity[TypeDecl].node' Fld_3 nodes.lkt:2310









Fld_3 := Item.Node;
--# expr-done 1376





--# expr-start 1378 'Entity[NamedTypeDecl].node' Fld_5 nodes.lkt:2310



--# expr-start 1377 LktNode.astlist_type Fld_4 nodes.lkt:2310







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.astlist_type
Fld_4 := Liblktlang.Implementation.Lkt_Node_P_Astlist_Type (Node => Ent.Node);
--# end
--# expr-done 1377





Fld_5 := Fld_4.Node;
--# expr-done 1378



   
      Cast_Result := Fld_5;


Is_Equal := Fld_3 = Cast_Result; 
--# expr-done 1379
      if Is_Equal then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Is_Equal;

         end loop;
      end;
   

   
   



--# expr-done 1380
Var_Expr := Find_Result;





if Var_Expr /= No_Entity_Type_Decl then
   



   --# scope-start







   --# scope-start



--# expr-start 1389 ValDecl Let_Result nodes.lkt:2317
--# scope-start
--# expr-start 1381 TypeDecl.get_array_content_type Fld_6 nodes.lkt:2317







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.get_array_content_type
Fld_6 := Liblktlang.Implementation.Type_Decl_P_Get_Array_Content_Type (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 1381
Local_Elt_T := Fld_6; 
--# bind elt_t Local_Elt_T
--# expr-start 1388 .singleton Singleton nodes.lkt:2318
--# expr-start 1387 'New[ResolvedParam]' New_Struct nodes.lkt:2318






--# expr-start 1383 .as_entity If_Result_1 nodes.lkt:2323



--# expr-start 1382 'New[SynthParamDecl]' New_Node nodes.lkt:2323



if Is_Foreign_Strict (Self.Self_Env, Self) then
   Raise_Property_Exception
     (Self,
      Property_Error'Identity,
      "synthetic nodes cannot have foreign lexical envs");
end if;


New_Node := new Root_Node_Record
  (Lkt_Synth_Param_Decl);
Initialize
  (Self => New_Node,
   Kind => Lkt_Synth_Param_Decl,
   Unit => Self.Unit,

   Token_Start_Index => No_Token_Index,
   Token_End_Index   => No_Token_Index,

   Parent => Self,

   Self_Env => Self.Self_Env);
Register_Destroyable (Self.Unit, New_Node);



--# expr-done 1382
Is_Null := New_Node = null; 
if Is_Null then
   
   If_Result_1 := No_Entity_Synth_Param_Decl;
else
   

As_Entity := (Info => E_Info, Node => New_Node); 
   If_Result_1 := As_Entity;
end if;



--# expr-done 1383



   
      Cast_Result_1 := Create_Internal_Entity_Decl
        (Node => If_Result_1.Node,
         Info => If_Result_1.Info);



--# expr-start 1384 SymbolLiteral Sym_1 nodes.lkt:2319
Sym_1 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_List_Elements); 
--# expr-done 1384
--# expr-start 1386 TypeDecl.make_array_type Fld_8 nodes.lkt:2320



--# expr-start 1385 TypeDecl.as_node_builder_type Fld_7 nodes.lkt:2320







   if Local_Elt_T.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.as_node_builder_type
Fld_7 := Liblktlang.Implementation.Type_Decl_P_As_Node_Builder_Type (Node => Local_Elt_T.Node, E_Info => Local_Elt_T.Info);
--# end
--# expr-done 1385



   if Fld_7.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.make_array_type
Fld_8 := Liblktlang.Implementation.Type_Decl_P_Make_Array_Type (Node => Fld_7.Node, E_Info => Fld_7.Info);
--# end
--# expr-done 1386
New_Struct := (Accept_Logical_Var => False, Decl => Cast_Result_1, Has_Default_Value => False, Name => Sym_1, Param_Type => Fld_8); 
--# expr-done 1387
            Singleton := Create_Internal_Resolved_Param_Array (Items_Count => 1);
            Singleton.Items (1) := New_Struct;
            
        
--# expr-done 1388
Let_Result := Singleton; Inc_Ref (Let_Result);
--# end
--# expr-done 1389
Scope_Result := Let_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_638;


Scope_Result_1 := Scope_Result;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_637;


   Result_Var := Scope_Result_1;
else
   
   Result_Var := No_Internal_Resolved_Param_Array_Type;
end if;

      Inc_Ref (Result_Var);


--# expr-done 1390
--# expr-start 1399 .map Map_Result nodes.lkt:2329








   

   --# expr-start 1392 ClassDecl.constructor_fields Fld_9 nodes.lkt:2329



--# expr-start 1391 Cast Cast_Result_2 nodes.lkt:2329









   if Ent.Node = null
      or else Ent.Node.Kind in Lkt_Class_Decl_Range
   then
      
      Cast_Result_2 := Create_Internal_Entity_Class_Decl
        (Node => Ent.Node,
         Info => Ent.Info);

   else
         Cast_Result_2 := No_Entity_Class_Decl;
   end if;


--# expr-done 1391



   if Cast_Result_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start ClassDecl.constructor_fields
Fld_9 := Liblktlang.Implementation.Class_Decl_P_Constructor_Fields (Node => Cast_Result_2.Node, E_Info => Cast_Result_2.Info);
--# end
--# expr-done 1392

   
      declare
         Map_Result_Vec : Internal_Resolved_Param_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Field_Decl_Array_Access := Fld_9;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind a Item_1

            
         
         
      --# expr-start 1398 'New[ResolvedParam]' New_Struct_1 nodes.lkt:2331






--# expr-start 1394 .as_entity If_Result_2 nodes.lkt:2335



--# expr-start 1393 'New[SynthParamDecl]' New_Node_1 nodes.lkt:2335



if Is_Foreign_Strict (Self.Self_Env, Self) then
   Raise_Property_Exception
     (Self,
      Property_Error'Identity,
      "synthetic nodes cannot have foreign lexical envs");
end if;


New_Node_1 := new Root_Node_Record
  (Lkt_Synth_Param_Decl);
Initialize
  (Self => New_Node_1,
   Kind => Lkt_Synth_Param_Decl,
   Unit => Self.Unit,

   Token_Start_Index => No_Token_Index,
   Token_End_Index   => No_Token_Index,

   Parent => Self,

   Self_Env => Self.Self_Env);
Register_Destroyable (Self.Unit, New_Node_1);



--# expr-done 1393
Is_Null_1 := New_Node_1 = null; 
if Is_Null_1 then
   
   If_Result_2 := No_Entity_Synth_Param_Decl;
else
   

As_Entity_1 := (Info => E_Info, Node => New_Node_1); 
   If_Result_2 := As_Entity_1;
end if;



--# expr-done 1394



   
      Cast_Result_3 := Create_Internal_Entity_Decl
        (Node => If_Result_2.Node,
         Info => If_Result_2.Info);



--# expr-start 1395 Decl.name Fld_10 nodes.lkt:2332







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_10 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Item_1.Node);
--# end
--# expr-done 1395



--# expr-start 1396 Decl.get_type Fld_11 nodes.lkt:2333







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.get_type
Fld_11 := Liblktlang.Implementation.Decl_P_Get_Type (Node => Item_1.Node, E_Info => Item_1.Info);
--# end
--# expr-done 1396
Var_Expr_1 := Fld_11;





if Var_Expr_1 /= No_Entity_Type_Decl then
   --# expr-start 1397 TypeDecl.as_node_builder_type Fld_12 nodes.lkt:2333







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.as_node_builder_type
Fld_12 := Liblktlang.Implementation.Type_Decl_P_As_Node_Builder_Type (Node => Var_Expr_1.Node, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 1397
   Result_Var_1 := Fld_12;
else
   
   Result_Var_1 := No_Entity_Type_Decl;
end if;



New_Struct_1 := (Accept_Logical_Var => False, Decl => Cast_Result_3, Has_Default_Value => False, Name => Fld_10, Param_Type => Result_Var_1); 
--# expr-done 1398
      

         declare
            Item_To_Append : constant Internal_Resolved_Param := New_Struct_1;
         begin
            Internal_Resolved_Param_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Resolved_Param_Array
           (Items_Count => Natural (Internal_Resolved_Param_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Resolved_Param_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Resolved_Param_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Resolved_Param_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1399
Concat_Result := Concat (Result_Var, Map_Result); 
--# expr-done 1400
Local_Params := Concat_Result; Inc_Ref (Local_Params);
--# bind params Local_Params
--# expr-start 1411 .do Result_Var_2 nodes.lkt:2340



--# expr-start 1409 'New[DynEnvWrapper]' New_Node_3 nodes.lkt:2340
--# expr-start 1402 ArrayLiteral Array_Lit nodes.lkt:2341
--# expr-start 1401 SymbolLiteral Sym_2 nodes.lkt:2341
Sym_2 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Builder); 
--# expr-done 1401
Array_Lit := Create_Symbol_Type_Array (Internal_Symbol_Type_Array'(1 => Sym_2)); 
--# expr-done 1402
--# expr-start 1408 ArrayLiteral Array_Lit_1 nodes.lkt:2342
--# expr-start 1407 Cast Cast_Result_4 nodes.lkt:2343





--# expr-start 1406 SynthFunDecl.function_type_aux Fld_14 nodes.lkt:2343



--# expr-start 1405 .as_bare_entity If_Result_3 nodes.lkt:2343



--# expr-start 1404 'New[SynthFunDecl]' New_Node_2 nodes.lkt:2343

--# expr-start 1403 TypeDecl.as_node_builder_type Fld_13 nodes.lkt:2345







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.as_node_builder_type
Fld_13 := Liblktlang.Implementation.Type_Decl_P_As_Node_Builder_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1403
Inc_Ref (Local_Params);


if Is_Foreign_Strict (Self.Self_Env, Self) then
   Raise_Property_Exception
     (Self,
      Property_Error'Identity,
      "synthetic nodes cannot have foreign lexical envs");
end if;


New_Node_2 := new Root_Node_Record
  (Lkt_Synth_Fun_Decl);
Initialize
  (Self => New_Node_2,
   Kind => Lkt_Synth_Fun_Decl,
   Unit => Self.Unit,

   Token_Start_Index => No_Token_Index,
   Token_End_Index   => No_Token_Index,

   Parent => Self,

   Self_Env => Self.Self_Env);
Register_Destroyable (Self.Unit, New_Node_2);


      New_Node_2.Synth_Fun_Decl_F_Params :=
         Local_Params;
      New_Node_2.Synth_Fun_Decl_F_Return_Type :=
         Fld_13;

--# expr-done 1404
Is_Null_2 := New_Node_2 = null; 
if Is_Null_2 then
   
   If_Result_3 := No_Entity_Synth_Fun_Decl;
else
   

As_Entity_2 := (Info => No_Entity_Info, Node => New_Node_2); 
   If_Result_3 := As_Entity_2;
end if;



--# expr-done 1405



   if If_Result_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start SynthFunDecl.function_type_aux
Fld_14 := Liblktlang.Implementation.Synth_Fun_Decl_P_Function_Type_Aux (Node => If_Result_3.Node, E_Info => If_Result_3.Info);
--# end
--# expr-done 1406



   
      Cast_Result_4 := Create_Internal_Entity_Type_Decl
        (Node => Fld_14.Node,
         Info => Fld_14.Info);


--# expr-done 1407
Array_Lit_1 := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Cast_Result_4)); 
--# expr-done 1408
Inc_Ref (Array_Lit);
Inc_Ref (Array_Lit_1);


if Is_Foreign_Strict (Self.Self_Env, Self) then
   Raise_Property_Exception
     (Self,
      Property_Error'Identity,
      "synthetic nodes cannot have foreign lexical envs");
end if;


New_Node_3 := new Root_Node_Record
  (Lkt_Dyn_Env_Wrapper);
Initialize
  (Self => New_Node_3,
   Kind => Lkt_Dyn_Env_Wrapper,
   Unit => Self.Unit,

   Token_Start_Index => No_Token_Index,
   Token_End_Index   => No_Token_Index,

   Parent => Self,

   Self_Env => Self.Self_Env);
Register_Destroyable (Self.Unit, New_Node_3);


      New_Node_3.Dyn_Env_Wrapper_F_Names :=
         Array_Lit;
      New_Node_3.Dyn_Env_Wrapper_F_Types :=
         Array_Lit_1;

--# expr-done 1409
Var_Expr_2 := New_Node_3;





if Var_Expr_2 /= No_Bare_Lkt_Node then
   



   --# scope-start



--# expr-start 1410 DynEnvWrapper.dynenvwrapper_instantiation_env Fld_15 nodes.lkt:2352







   if Var_Expr_2 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DynEnvWrapper.dynenvwrapper_instantiation_env
Fld_15 := Liblktlang.Implementation.Dyn_Env_Wrapper_F_Dynenvwrapper_Instantiation_Env (Node => Var_Expr_2);
--# end
--# expr-done 1410
Scope_Result_2 := Fld_15;
   Inc_Ref (Scope_Result_2);


   --# end
      Finalizer_Scope_640;


   Result_Var_2 := Scope_Result_2;
else
   
   Result_Var_2 := Empty_Env;
end if;

      Inc_Ref (Result_Var_2);


--# expr-done 1411
Let_Result_1 := Result_Var_2; Inc_Ref (Let_Result_1);
--# end
--# expr-done 1412
Scope_Result_3 := Let_Result_1;
   Inc_Ref (Scope_Result_3);


   --# end
      Finalizer_Scope_635;


   If_Result_4 := Scope_Result_3;
else
   
   If_Result_4 := Empty_Env;
end if;

      Inc_Ref (If_Result_4);


--# expr-done 1413

         Property_Result := If_Result_4;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_218;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_218;
                     Finalizer_Scope_635;
                     Finalizer_Scope_637;
                     Finalizer_Scope_638;
                     Finalizer_Scope_640;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Lexical_Env,
                     As_Lexical_Env => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
            if Mmz_Stored then
               Inc_Ref (Property_Result);
            end if;
      end if;



   return Property_Result;
end Type_Decl_P_Node_Builder_Scope;
--# end

   







--# property-start 'TypeDecl.[root-static]base_types' nodes.lkt:2265
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Base_Types
  
  (Node : Bare_Type_Decl
      ; Include_Self : Boolean
         := False
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl_Array_Access
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind include_self Include_Self

   Property_Result : Internal_Entity_Type_Decl_Array_Access;

      
            procedure Finalizer_Scope_215 with Inline_Always;
            procedure Finalizer_Scope_632 with Inline_Always;
            procedure Finalizer_Scope_633 with Inline_Always;

      Array_Lit : Internal_Entity_Type_Decl_Array_Access;
If_Result : Internal_Entity_Type_Decl_Array_Access;
Fld : Internal_Entity_Type_Ref;
Var_Expr : Internal_Entity_Type_Ref;
Fld_1 : Internal_Entity_Type_Decl;
Var_Expr_1 : Internal_Entity_Type_Decl;
Array_Lit_1 : Internal_Entity_Type_Decl_Array_Access;
Fld_2 : Internal_Entity_Type_Decl_Array_Access;
Concat_Result : Internal_Entity_Type_Decl_Array_Access;
Scope_Result : Internal_Entity_Type_Decl_Array_Access;
Result_Var : Internal_Entity_Type_Decl_Array_Access;
Scope_Result_1 : Internal_Entity_Type_Decl_Array_Access;
Result_Var_1 : Internal_Entity_Type_Decl_Array_Access;
Concat_Result_1 : Internal_Entity_Type_Decl_Array_Access;

            procedure Finalizer_Scope_215 is
            begin
                     Dec_Ref (Array_Lit);
                     Dec_Ref (If_Result);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (Result_Var_1);
                     Dec_Ref (Concat_Result_1);
            end Finalizer_Scope_215;
            procedure Finalizer_Scope_632 is
            begin
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Result_Var);
            end Finalizer_Scope_632;
            procedure Finalizer_Scope_633 is
            begin
                     Dec_Ref (Array_Lit_1);
                     Dec_Ref (Fld_2);
                     Dec_Ref (Concat_Result);
            end Finalizer_Scope_633;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1423 ArrayConcat Concat_Result_1 nodes.lkt:2266
--# expr-start 1415 If If_Result nodes.lkt:2266




if Include_Self then
   --# expr-start 1414 ArrayLiteral Array_Lit nodes.lkt:2266

Array_Lit := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Ent)); 
--# expr-done 1414
   If_Result := Array_Lit;
else
   
   If_Result := No_Internal_Entity_Type_Decl_Array_Type;
end if;

      Inc_Ref (If_Result);


--# expr-done 1415
--# expr-start 1422 .do Result_Var_1 nodes.lkt:2267



--# expr-start 1416 TypeDecl.base_type Fld nodes.lkt:2267







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.base_type
Fld := Liblktlang.Implementation.Type_Decl_P_Base_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1416
Var_Expr := Fld;





if Var_Expr /= No_Entity_Type_Ref then
   



   --# scope-start



--# expr-start 1421 .do Result_Var nodes.lkt:2268



--# expr-start 1417 TypeRef.referenced_decl Fld_1 nodes.lkt:2268







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_1 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 1417
Var_Expr_1 := Fld_1;





if Var_Expr_1 /= No_Entity_Type_Decl then
   



   --# scope-start



--# expr-start 1420 ArrayConcat Concat_Result nodes.lkt:2268
--# expr-start 1418 ArrayLiteral Array_Lit_1 nodes.lkt:2268

Array_Lit_1 := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Var_Expr_1)); 
--# expr-done 1418
--# expr-start 1419 TypeDecl.base_types Fld_2 nodes.lkt:2268







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]TypeDecl.base_types'
Fld_2 := Liblktlang.Implementation.Dispatcher_Type_Decl_P_Base_Types (Node => Var_Expr_1.Node, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 1419
Concat_Result := Concat (Array_Lit_1, Fld_2); 
--# expr-done 1420
Scope_Result := Concat_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_633;


   Result_Var := Scope_Result;
else
   
   Result_Var := No_Internal_Entity_Type_Decl_Array_Type;
end if;

      Inc_Ref (Result_Var);


--# expr-done 1421
Scope_Result_1 := Result_Var;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_632;


   Result_Var_1 := Scope_Result_1;
else
   
   Result_Var_1 := No_Internal_Entity_Type_Decl_Array_Type;
end if;

      Inc_Ref (Result_Var_1);


--# expr-done 1422
Concat_Result_1 := Concat (If_Result, Result_Var_1); 
--# expr-done 1423

         Property_Result := Concat_Result_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_215;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_215;
                     Finalizer_Scope_632;
                     Finalizer_Scope_633;




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Base_Types;
--# end

   







--# property-start 'TypeDecl.[root-static]is_subtype' nodes.lkt:2272
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Is_Subtype
  
  (Node : Bare_Type_Decl
      ; Other : Internal_Entity_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind other Other

   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := False;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Is_Subtype;
--# end

   







--# property-start 'TypeDecl.[root-static]common_ancestor' nodes.lkt:2280
pragma Warnings (Off, "is not referenced");

function Type_Decl_P_Common_Ancestor
  
  (Node : Bare_Type_Decl
      ; Other : Internal_Entity_Type_Decl
      ; Imprecise : Boolean
         := False
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Type_Decl :=
     Bare_Type_Decl (Node);
     Ent : Internal_Entity_Type_Decl :=
       Internal_Entity_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind other Other
   --# bind imprecise Imprecise

   Property_Result : Internal_Entity_Type_Decl;

      

      Cast_Result : Internal_Entity;
Cast_Result_1 : Internal_Entity;
Is_Equiv : Boolean;
If_Result : Internal_Entity_Type_Decl;
Fld : Internal_Entity_Named_Type_Decl;
Fld_1 : Bare_Named_Type_Decl;
Cast_Result_2 : Bare_Type_Decl;
Is_Equal : Boolean;
Fld_2 : Bare_Type_Decl;
Fld_3 : Internal_Entity_Named_Type_Decl;
Fld_4 : Bare_Named_Type_Decl;
Cast_Result_3 : Bare_Type_Decl;
Is_Equal_1 : Boolean;
If_Result_1 : Boolean;
Fld_5 : Internal_Entity_Type_Decl;
Fld_6 : Internal_Entity_Type_Decl;
Fld_7 : Internal_Entity_Type_Decl;
If_Result_2 : Internal_Entity_Type_Decl;
Var_Expr : Internal_Entity_Type_Decl;
Scope_Result : Internal_Entity_Type_Decl;
Is_Null : Boolean;
If_Result_3 : Internal_Entity_Type_Decl;
If_Result_4 : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1441 .do Result_Var nodes.lkt:2284



--# expr-start 1437 If If_Result_2 nodes.lkt:2285



--# expr-start 1431 BooleanAnd If_Result_1 nodes.lkt:2286



--# expr-start 1426 Eq Is_Equal nodes.lkt:2286






--# expr-start 1425 'Entity[NamedTypeDecl].node' Fld_1 nodes.lkt:2286



--# expr-start 1424 LktNode.entity_type Fld nodes.lkt:2286







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Ent.Node);
--# end
--# expr-done 1424





Fld_1 := Fld.Node;
--# expr-done 1425



   
      Cast_Result_2 := Fld_1;


Is_Equal := Self = Cast_Result_2; 
--# expr-done 1426
if Is_Equal then
   --# expr-start 1430 Eq Is_Equal_1 nodes.lkt:2287
--# expr-start 1427 'Entity[TypeDecl].node' Fld_2 nodes.lkt:2287









Fld_2 := Other.Node;
--# expr-done 1427





--# expr-start 1429 'Entity[NamedTypeDecl].node' Fld_4 nodes.lkt:2287



--# expr-start 1428 LktNode.entity_type Fld_3 nodes.lkt:2287







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_3 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Ent.Node);
--# end
--# expr-done 1428





Fld_4 := Fld_3.Node;
--# expr-done 1429



   
      Cast_Result_3 := Fld_4;


Is_Equal_1 := Fld_2 = Cast_Result_3; 
--# expr-done 1430
   If_Result_1 := Is_Equal_1;
else
   
   If_Result_1 := False;
end if;



--# expr-done 1431
if If_Result_1 then
   --# expr-start 1434 TypeDecl.common_ancestor Fld_7 nodes.lkt:2289



--# expr-start 1432 TypeDecl.get_entity_node_type Fld_5 nodes.lkt:2289







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.get_entity_node_type
Fld_5 := Liblktlang.Implementation.Type_Decl_P_Get_Entity_Node_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1432



   if Fld_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1433 TypeDecl.get_entity_node_type Fld_6 nodes.lkt:2290







   if Other.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.get_entity_node_type
Fld_6 := Liblktlang.Implementation.Type_Decl_P_Get_Entity_Node_Type (Node => Other.Node, E_Info => Other.Info);
--# end
--# expr-done 1433
--# property-call-start '[dispatcher]TypeDecl.common_ancestor'
Fld_7 := Liblktlang.Implementation.Dispatcher_Type_Decl_P_Common_Ancestor (Node => Fld_5.Node, Other => Fld_6, E_Info => Fld_5.Info);
--# end
--# expr-done 1434
   If_Result_2 := Fld_7;
else
   --# expr-start 1436 If If_Result nodes.lkt:2285



--# expr-start 1435 Eq Is_Equiv nodes.lkt:2292









   
      Cast_Result := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);











   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Other.Node,
         Info => Other.Info);


Is_Equiv := Equivalent (Cast_Result, Cast_Result_1); 
--# expr-done 1435
if Is_Equiv then
   
   If_Result := Ent;
else
   
   If_Result := No_Entity_Type_Decl;
end if;



--# expr-done 1436
   If_Result_2 := If_Result;
end if;



--# expr-done 1437
Var_Expr := If_Result_2;





if Var_Expr /= No_Entity_Type_Decl then
   



   --# scope-start




Scope_Result := Var_Expr;


   --# end


   Result_Var := Scope_Result;
else
   --# expr-start 1440 If If_Result_4 nodes.lkt:2297




if Imprecise then
   --# expr-start 1439 If If_Result_3 nodes.lkt:2297



--# expr-start 1438 .is_null Is_Null nodes.lkt:2297

Is_Null := Ent.Node = null; 
--# expr-done 1438
if Is_Null then
   
   If_Result_3 := Other;
else
   
   If_Result_3 := Ent;
end if;



--# expr-done 1439
   If_Result_4 := If_Result_3;
else
   
   If_Result_4 := No_Entity_Type_Decl;
end if;



--# expr-done 1440
   Result_Var := If_Result_4;
end if;



--# expr-done 1441

         Property_Result := Result_Var;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Type_Decl_P_Common_Ancestor;
--# end



   


      

   --
   --  Primitives for Bare_Any_Type_Decl
   --

   



      
      procedure Initialize_Fields_For_Any_Type_Decl
        (Self : Bare_Any_Type_Decl
         ; Any_Type_Decl_F_Traits : Bare_Synthetic_Type_Ref_List
        ) is
      begin

            Self.Any_Type_Decl_F_Traits := Any_Type_Decl_F_Traits;
         

      end Initialize_Fields_For_Any_Type_Decl;


   







--# property-start AnyTypeDecl.full_name_internal nodes.lkt:2378
pragma Warnings (Off, "is not referenced");

function Any_Type_Decl_P_Full_Name_Internal
  
  (Node : Bare_Any_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Any_Type_Decl :=
     Bare_Any_Type_Decl (Node);
     Ent : Internal_Entity_Any_Type_Decl :=
       Internal_Entity_Any_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_221 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_221 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_221;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1442 StringLiteral Str nodes.lkt:2378
Str := Create_String ("[Any]"); 
--# expr-done 1442

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_221;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_221;




            raise;
      end;



   return Property_Result;
end Any_Type_Decl_P_Full_Name_Internal;
--# end

   







--# property-start AnyTypeDecl.decl_type_name nodes.lkt:2380
pragma Warnings (Off, "is not referenced");

function Any_Type_Decl_P_Decl_Type_Name
  
  (Node : Bare_Any_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Any_Type_Decl :=
     Bare_Any_Type_Decl (Node);
     Ent : Internal_Entity_Any_Type_Decl :=
       Internal_Entity_Any_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_222 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_222 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_222;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1443 StringLiteral Str nodes.lkt:2380
Str := Create_String ("Any Type"); 
--# expr-done 1443

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_222;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_222;




            raise;
      end;



   return Property_Result;
end Any_Type_Decl_P_Decl_Type_Name;
--# end



   


      

   --
   --  Primitives for Bare_Enum_Class_Alt_Decl
   --

   



      
      procedure Initialize_Fields_For_Enum_Class_Alt_Decl
        (Self : Bare_Enum_Class_Alt_Decl
         ; Enum_Class_Alt_Decl_F_Syn_Name : Bare_Def_Id
         ; Enum_Class_Alt_Decl_F_Traits : Bare_Type_Ref_List
        ) is
      begin

            Self.Enum_Class_Alt_Decl_F_Syn_Name := Enum_Class_Alt_Decl_F_Syn_Name;
            Self.Enum_Class_Alt_Decl_F_Traits := Enum_Class_Alt_Decl_F_Traits;
         

      end Initialize_Fields_For_Enum_Class_Alt_Decl;


   







--# property-start EnumClassAltDecl.decl_type_name nodes.lkt:2393
pragma Warnings (Off, "is not referenced");

function Enum_Class_Alt_Decl_P_Decl_Type_Name
  
  (Node : Bare_Enum_Class_Alt_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Enum_Class_Alt_Decl :=
     Bare_Enum_Class_Alt_Decl (Node);
     Ent : Internal_Entity_Enum_Class_Alt_Decl :=
       Internal_Entity_Enum_Class_Alt_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_223 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_223 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_223;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1444 StringLiteral Str nodes.lkt:2393
Str := Create_String ("enum class alt declaration"); 
--# expr-done 1444

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_223;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_223;




            raise;
      end;



   return Property_Result;
end Enum_Class_Alt_Decl_P_Decl_Type_Name;
--# end

   







--# property-start EnumClassAltDecl.is_subtype nodes.lkt:2395
pragma Warnings (Off, "is not referenced");

function Enum_Class_Alt_Decl_P_Is_Subtype
  
  (Node : Bare_Enum_Class_Alt_Decl
      ; Other : Internal_Entity_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Enum_Class_Alt_Decl :=
     Bare_Enum_Class_Alt_Decl (Node);
     Ent : Internal_Entity_Enum_Class_Alt_Decl :=
       Internal_Entity_Enum_Class_Alt_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind other Other

   Property_Result : Boolean;

      

      Fld : Internal_Entity_Type_Decl;
Fld_1 : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1446 TypeDecl.is_subtype Fld_1 nodes.lkt:2396



--# expr-start 1445 EnumClassAltDecl.parent_type Fld nodes.lkt:2396







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start EnumClassAltDecl.parent_type
Fld := Liblktlang.Implementation.Enum_Class_Alt_Decl_P_Parent_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1445



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start '[dispatcher]TypeDecl.is_subtype'
Fld_1 := Liblktlang.Implementation.Dispatcher_Type_Decl_P_Is_Subtype (Node => Fld.Node, Other => Other, E_Info => Fld.Info);
--# end
--# expr-done 1446

         Property_Result := Fld_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Enum_Class_Alt_Decl_P_Is_Subtype;
--# end

   







--# property-start EnumClassAltDecl.defined_scope nodes.lkt:2399
pragma Warnings (Off, "is not referenced");

function Enum_Class_Alt_Decl_P_Defined_Scope
  
  (Node : Bare_Enum_Class_Alt_Decl
      ; Origin : Internal_Entity
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Lexical_Env
is
   Self : Bare_Enum_Class_Alt_Decl :=
     Bare_Enum_Class_Alt_Decl (Node);
     Ent : Internal_Entity_Enum_Class_Alt_Decl :=
       Internal_Entity_Enum_Class_Alt_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind origin Origin

   Property_Result : Lexical_Env;

      
            procedure Finalizer_Scope_225 with Inline_Always;

      Fld : Internal_Entity_Type_Decl;
Fld_1 : Lexical_Env := Empty_Env;

            procedure Finalizer_Scope_225 is
            begin
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_225;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1448 Decl.defined_scope Fld_1 nodes.lkt:2399



--# expr-start 1447 EnumClassAltDecl.parent_type Fld nodes.lkt:2399







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start EnumClassAltDecl.parent_type
Fld := Liblktlang.Implementation.Enum_Class_Alt_Decl_P_Parent_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1447



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_1 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Fld.Node, Origin => Origin, E_Info => Fld.Info);
--# end
--# expr-done 1448

         Property_Result := Fld_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_225;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_225;




            raise;
      end;



   return Property_Result;
end Enum_Class_Alt_Decl_P_Defined_Scope;
--# end

   







--# property-start EnumClassAltDecl.parent_type nodes.lkt:2402
pragma Warnings (Off, "is not referenced");

function Enum_Class_Alt_Decl_P_Parent_Type
  
  (Node : Bare_Enum_Class_Alt_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Enum_Class_Alt_Decl :=
     Bare_Enum_Class_Alt_Decl (Node);
     Ent : Internal_Entity_Enum_Class_Alt_Decl :=
       Internal_Entity_Enum_Class_Alt_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;

      

      Fld : Internal_Entity;
Fld_1 : Internal_Entity;
Fld_2 : Internal_Entity;
Fld_3 : Internal_Entity;
Cast_Result : Internal_Entity_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1453 Cast Cast_Result nodes.lkt:2403





--# expr-start 1452 .parent Fld_3 nodes.lkt:2403



--# expr-start 1451 .parent Fld_2 nodes.lkt:2403



--# expr-start 1450 .parent Fld_1 nodes.lkt:2403



--# expr-start 1449 .parent Fld nodes.lkt:2403







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Parent (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 1449



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Liblktlang.Implementation.Parent (Node => Fld.Node, E_Info => Fld.Info);
--# expr-done 1450



   if Fld_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Liblktlang.Implementation.Parent (Node => Fld_1.Node, E_Info => Fld_1.Info);
--# expr-done 1451



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Liblktlang.Implementation.Parent (Node => Fld_2.Node, E_Info => Fld_2.Info);
--# expr-done 1452



   if Fld_3.Node = null
      or else Fld_3.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => Fld_3.Node,
         Info => Fld_3.Info);

   else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "invalid object cast");
   end if;


--# expr-done 1453

         Property_Result := Cast_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Enum_Class_Alt_Decl_P_Parent_Type;
--# end

   







--# property-start EnumClassAltDecl.base_types nodes.lkt:2406
pragma Warnings (Off, "is not referenced");

function Enum_Class_Alt_Decl_P_Base_Types
  
  (Node : Bare_Enum_Class_Alt_Decl
      ; Include_Self : Boolean
         := False
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl_Array_Access
is
   Self : Bare_Enum_Class_Alt_Decl :=
     Bare_Enum_Class_Alt_Decl (Node);
     Ent : Internal_Entity_Enum_Class_Alt_Decl :=
       Internal_Entity_Enum_Class_Alt_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind include_self Include_Self

   Property_Result : Internal_Entity_Type_Decl_Array_Access;

      
            procedure Finalizer_Scope_227 with Inline_Always;

      Cast_Result : Internal_Entity_Type_Decl;
Array_Lit : Internal_Entity_Type_Decl_Array_Access;
If_Result : Internal_Entity_Type_Decl_Array_Access;
Fld : Internal_Entity_Type_Decl;
Fld_1 : Internal_Entity_Type_Decl_Array_Access;
Concat_Result : Internal_Entity_Type_Decl_Array_Access;

            procedure Finalizer_Scope_227 is
            begin
                     Dec_Ref (Array_Lit);
                     Dec_Ref (If_Result);
                     Dec_Ref (Fld_1);
                     Dec_Ref (Concat_Result);
            end Finalizer_Scope_227;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1459 ArrayConcat Concat_Result nodes.lkt:2407
--# expr-start 1456 If If_Result nodes.lkt:2408




if Include_Self then
   --# expr-start 1455 ArrayLiteral Array_Lit nodes.lkt:2408
--# expr-start 1454 Cast Cast_Result nodes.lkt:2408









   
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => Ent.Node,
         Info => Ent.Info);


--# expr-done 1454
Array_Lit := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Cast_Result)); 
--# expr-done 1455
   If_Result := Array_Lit;
else
   
   If_Result := No_Internal_Entity_Type_Decl_Array_Type;
end if;

      Inc_Ref (If_Result);


--# expr-done 1456
--# expr-start 1458 TypeDecl.base_types Fld_1 nodes.lkt:2411



--# expr-start 1457 EnumClassAltDecl.parent_type Fld nodes.lkt:2411







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start EnumClassAltDecl.parent_type
Fld := Liblktlang.Implementation.Enum_Class_Alt_Decl_P_Parent_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1457



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start '[dispatcher]TypeDecl.base_types'
Fld_1 := Liblktlang.Implementation.Dispatcher_Type_Decl_P_Base_Types (Node => Fld.Node, Include_Self => True, E_Info => Fld.Info);
--# end
--# expr-done 1458
Concat_Result := Concat (If_Result, Fld_1); 
--# expr-done 1459

         Property_Result := Concat_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_227;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_227;




            raise;
      end;



   return Property_Result;
end Enum_Class_Alt_Decl_P_Base_Types;
--# end



   


      

   --
   --  Primitives for Bare_Function_Type
   --

   



      
      procedure Initialize_Fields_For_Function_Type
        (Self : Bare_Function_Type
         ; Function_Type_F_Traits : Bare_Synthetic_Type_Ref_List
        ) is
      begin

            Self.Function_Type_F_Traits := Function_Type_F_Traits;
         
      Self.Function_Type_F_Params := No_Internal_Entity_Type_Decl_Array_Type;
      Self.Function_Type_F_Return_Type := No_Entity_Type_Decl;
      Self.Function_Type_F_Origin := No_Entity_Decl;

      end Initialize_Fields_For_Function_Type;


   







--# property-start FunctionType.full_name_internal nodes.lkt:2433
pragma Warnings (Off, "is not referenced");

function Function_Type_P_Full_Name_Internal
  
  (Node : Bare_Function_Type
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Function_Type :=
     Bare_Function_Type (Node);
     Ent : Internal_Entity_Function_Type :=
       Internal_Entity_Function_Type'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_228 with Inline_Always;
            procedure Finalizer_Scope_641 with Inline_Always;

      Str : String_Type;
Str_1 : String_Type;
Fld : Internal_Entity_Type_Decl_Array_Access;
Fld_1 : String_Type;
Map_Result : String_Type_Array_Access;
Join_Result : String_Type;
Concat_Result : String_Type;
Str_2 : String_Type;
Concat_Result_1 : String_Type;
Fld_2 : Internal_Entity_Type_Decl;
Fld_3 : String_Type;
Concat_Result_2 : String_Type;

            procedure Finalizer_Scope_228 is
            begin
                     Dec_Ref (Str);
                     Dec_Ref (Str_1);
                     Dec_Ref (Fld);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Join_Result);
                     Dec_Ref (Concat_Result);
                     Dec_Ref (Str_2);
                     Dec_Ref (Concat_Result_1);
                     Dec_Ref (Fld_3);
                     Dec_Ref (Concat_Result_2);
            end Finalizer_Scope_228;
            procedure Finalizer_Scope_641 is
            begin
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_641;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1471 StringConcat Concat_Result_2 nodes.lkt:2434
--# expr-start 1468 StringConcat Concat_Result_1 nodes.lkt:2434
--# expr-start 1466 StringConcat Concat_Result nodes.lkt:2434
--# expr-start 1460 StringLiteral Str nodes.lkt:2434
Str := Create_String ("("); 
--# expr-done 1460
--# expr-start 1465 .join Join_Result nodes.lkt:2435
--# expr-start 1461 StringLiteral Str_1 nodes.lkt:2435
Str_1 := Create_String (", "); 
--# expr-done 1461
--# expr-start 1464 .map Map_Result nodes.lkt:2435








   

   --# expr-start 1462 FunctionType.params Fld nodes.lkt:2435







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Ent.Node.Function_Type_F_Params;
Inc_Ref (Fld);
--# expr-done 1462

   
      declare
         Map_Result_Vec : String_Type_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Type_Decl_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind t Item

            
         
         
      --# expr-start 1463 Decl.full_name_internal Fld_1 nodes.lkt:2435







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.full_name_internal'
Fld_1 := Liblktlang.Implementation.Dispatcher_Decl_P_Full_Name_Internal (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 1463
      

         declare
            Item_To_Append : constant String_Type := Fld_1;
         begin
               Inc_Ref (Item_To_Append);
            String_Type_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_641;



         end loop;
      end;
   

   

         Map_Result := Create_String_Type_Array
           (Items_Count => Natural (String_Type_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := String_Type_Vectors.Get
              (Map_Result_Vec,
               I + String_Type_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         String_Type_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1464
Join_Result := Join_Strings (Str_1, Map_Result); 
--# expr-done 1465
Concat_Result := Concat_String (Str, Join_Result); 
--# expr-done 1466
--# expr-start 1467 StringLiteral Str_2 nodes.lkt:2435
Str_2 := Create_String (") -> "); 
--# expr-done 1467
Concat_Result_1 := Concat_String (Concat_Result, Str_2); 
--# expr-done 1468
--# expr-start 1470 Decl.full_name_internal Fld_3 nodes.lkt:2436



--# expr-start 1469 FunctionType.return_type Fld_2 nodes.lkt:2436







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Ent.Node.Function_Type_F_Return_Type;
--# expr-done 1469



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.full_name_internal'
Fld_3 := Liblktlang.Implementation.Dispatcher_Decl_P_Full_Name_Internal (Node => Fld_2.Node, E_Info => Fld_2.Info);
--# end
--# expr-done 1470
Concat_Result_2 := Concat_String (Concat_Result_1, Fld_3); 
--# expr-done 1471

         Property_Result := Concat_Result_2;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_228;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_228;
                     Finalizer_Scope_641;




            raise;
      end;



   return Property_Result;
end Function_Type_P_Full_Name_Internal;
--# end

   







--# property-start FunctionType.decl_type_name nodes.lkt:2438
pragma Warnings (Off, "is not referenced");

function Function_Type_P_Decl_Type_Name
  
  (Node : Bare_Function_Type
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Function_Type :=
     Bare_Function_Type (Node);
     Ent : Internal_Entity_Function_Type :=
       Internal_Entity_Function_Type'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_229 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_229 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_229;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1472 StringLiteral Str nodes.lkt:2438
Str := Create_String ("function type"); 
--# expr-done 1472

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_229;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_229;




            raise;
      end;



   return Property_Result;
end Function_Type_P_Decl_Type_Name;
--# end

   







--# property-start FunctionType.defined_scope nodes.lkt:2441
pragma Warnings (Off, "is not referenced");

function Function_Type_P_Defined_Scope
  
  (Node : Bare_Function_Type
      ; Origin : Internal_Entity
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Lexical_Env
is
   Self : Bare_Function_Type :=
     Bare_Function_Type (Node);
     Ent : Internal_Entity_Function_Type :=
       Internal_Entity_Function_Type'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind origin Origin

   Property_Result : Lexical_Env;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := Empty_Env;
            Inc_Ref (Property_Result);
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Function_Type_P_Defined_Scope;
--# end

   







--# property-start FunctionType.should_ignore_constructor_arg nodes.lkt:2444
pragma Warnings (Off, "is not referenced");

function Function_Type_P_Should_Ignore_Constructor_Arg
  
  (Node : Bare_Function_Type
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Function_Type :=
     Bare_Function_Type (Node);
     Ent : Internal_Entity_Function_Type :=
       Internal_Entity_Function_Type'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Var_Expr : Internal_Entity_Function_Type;
Fld : Internal_Entity_Decl;
Var_Expr_1 : Internal_Entity_Decl;
Fld_1 : Internal_Entity_Full_Decl;
Var_Expr_2 : Internal_Entity_Full_Decl;
Sym : Symbol_Type;
Fld_2 : Boolean;
Result_Var : Boolean;
Result_Var_1 : Boolean;
Result_Var_2 : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         



Var_Expr := Ent;





if Var_Expr /= No_Entity_Function_Type then
   


--# expr-start 1473 FunctionType.origin Fld nodes.lkt:2445







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Var_Expr.Node.Function_Type_F_Origin;
--# expr-done 1473
Var_Expr_1 := Fld;





if Var_Expr_1 /= No_Entity_Decl then
   


--# expr-start 1474 Decl.full_decl Fld_1 nodes.lkt:2445







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.full_decl
Fld_1 := Liblktlang.Implementation.Decl_P_Full_Decl (Node => Var_Expr_1.Node, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 1474
Var_Expr_2 := Fld_1;





if Var_Expr_2 /= No_Entity_Full_Decl then
   --# expr-start 1476 FullDecl.has_annotation Fld_2 nodes.lkt:2445







   if Var_Expr_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1475 SymbolLiteral Sym nodes.lkt:2445
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Ignore_Constructor_Arg); 
--# expr-done 1475
--# property-call-start FullDecl.has_annotation
Fld_2 := Liblktlang.Implementation.Full_Decl_P_Has_Annotation (Node => Var_Expr_2.Node, Name => Sym);
--# end
--# expr-done 1476
   Result_Var := Fld_2;
else
   
   Result_Var := False;
end if;



   Result_Var_1 := Result_Var;
else
   
   Result_Var_1 := False;
end if;



   Result_Var_2 := Result_Var_1;
else
   
   Result_Var_2 := False;
end if;




         Property_Result := Result_Var_2;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Function_Type_P_Should_Ignore_Constructor_Arg;
--# end

   







--# property-start FunctionType.returns_entity nodes.lkt:2448
pragma Warnings (Off, "is not referenced");

function Function_Type_P_Returns_Entity
  
  (Node : Bare_Function_Type
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Function_Type :=
     Bare_Function_Type (Node);
     Ent : Internal_Entity_Function_Type :=
       Internal_Entity_Function_Type'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Is_Null : Boolean;
Fld : Internal_Entity_Type_Decl;
Fld_1 : Bare_Type_Decl;
Fld_2 : Internal_Entity_Named_Type_Decl;
Fld_3 : Bare_Named_Type_Decl;
Cast_Result : Bare_Type_Decl;
Is_Equal : Boolean;
If_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1483 BooleanOr If_Result nodes.lkt:2449



--# expr-start 1477 .is_null Is_Null nodes.lkt:2449

Is_Null := Ent.Node = null; 
--# expr-done 1477
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 1482 Eq Is_Equal nodes.lkt:2449
--# expr-start 1479 'Entity[TypeDecl].node' Fld_1 nodes.lkt:2449



--# expr-start 1478 FunctionType.return_type Fld nodes.lkt:2449







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Ent.Node.Function_Type_F_Return_Type;
--# expr-done 1478





Fld_1 := Fld.Node;
--# expr-done 1479





--# expr-start 1481 'Entity[NamedTypeDecl].node' Fld_3 nodes.lkt:2449



--# expr-start 1480 LktNode.entity_type Fld_2 nodes.lkt:2449







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_2 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Ent.Node);
--# end
--# expr-done 1480





Fld_3 := Fld_2.Node;
--# expr-done 1481



   
      Cast_Result := Fld_3;


Is_Equal := Fld_1 = Cast_Result; 
--# expr-done 1482
   If_Result := Is_Equal;
end if;



--# expr-done 1483

         Property_Result := If_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Function_Type_P_Returns_Entity;
--# end

   







--# property-start FunctionType.returns_bool nodes.lkt:2452
pragma Warnings (Off, "is not referenced");

function Function_Type_P_Returns_Bool
  
  (Node : Bare_Function_Type
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Function_Type :=
     Bare_Function_Type (Node);
     Ent : Internal_Entity_Function_Type :=
       Internal_Entity_Function_Type'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Is_Null : Boolean;
Fld : Internal_Entity_Type_Decl;
Fld_1 : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity_Type_Decl;
Fld_2 : Boolean;
If_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1488 BooleanOr If_Result nodes.lkt:2453



--# expr-start 1484 .is_null Is_Null nodes.lkt:2453

Is_Null := Ent.Node = null; 
--# expr-done 1484
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 1487 TypeDecl.matching_type Fld_2 nodes.lkt:2453



--# expr-start 1485 FunctionType.return_type Fld nodes.lkt:2453







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Ent.Node.Function_Type_F_Return_Type;
--# expr-done 1485



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;







--# expr-start 1486 LktNode.bool_type Fld_1 nodes.lkt:2453







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.bool_type
Fld_1 := Liblktlang.Implementation.Lkt_Node_P_Bool_Type (Node => Ent.Node);
--# end
--# expr-done 1486



   
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => Fld_1.Node,
         Info => Fld_1.Info);


--# property-call-start TypeDecl.matching_type
Fld_2 := Liblktlang.Implementation.Type_Decl_P_Matching_Type (Node => Fld.Node, Other => Cast_Result, E_Info => Fld.Info);
--# end
--# expr-done 1487
   If_Result := Fld_2;
end if;



--# expr-done 1488

         Property_Result := If_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Function_Type_P_Returns_Bool;
--# end



   


      

   --
   --  Primitives for Bare_Generic_Param_Type_Decl
   --

   



      
      procedure Initialize_Fields_For_Generic_Param_Type_Decl
        (Self : Bare_Generic_Param_Type_Decl
         ; Generic_Param_Type_Decl_F_Has_Class : Bare_Class_Qualifier
         ; Generic_Param_Type_Decl_F_Syn_Name : Bare_Def_Id
         ; Generic_Param_Type_Decl_F_Traits : Bare_Type_Ref_List
        ) is
      begin

            Self.Generic_Param_Type_Decl_F_Has_Class := Generic_Param_Type_Decl_F_Has_Class;
            Self.Generic_Param_Type_Decl_F_Syn_Name := Generic_Param_Type_Decl_F_Syn_Name;
            Self.Generic_Param_Type_Decl_F_Traits := Generic_Param_Type_Decl_F_Traits;
         

      end Initialize_Fields_For_Generic_Param_Type_Decl;

      
   function Generic_Param_Type_Decl_F_Has_Class
     (Node : Bare_Generic_Param_Type_Decl) return Bare_Class_Qualifier
   is
      

   begin
         
         return Node.Generic_Param_Type_Decl_F_Has_Class;
      
   end;


   







--# property-start GenericParamTypeDecl.decl_type_name nodes.lkt:2468
pragma Warnings (Off, "is not referenced");

function Generic_Param_Type_Decl_P_Decl_Type_Name
  
  (Node : Bare_Generic_Param_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Generic_Param_Type_Decl :=
     Bare_Generic_Param_Type_Decl (Node);
     Ent : Internal_Entity_Generic_Param_Type_Decl :=
       Internal_Entity_Generic_Param_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_234 with Inline_Always;

      Str : String_Type;
Fld : Bare_Class_Qualifier;
Fld_1 : Boolean;
Str_1 : String_Type;
If_Result : String_Type;

            procedure Finalizer_Scope_234 is
            begin
                     Dec_Ref (Str);
                     Dec_Ref (Str_1);
                     Dec_Ref (If_Result);
            end Finalizer_Scope_234;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1493 If If_Result nodes.lkt:2469



--# expr-start 1490 ClassQualifier.as_bool Fld_1 nodes.lkt:2469



--# expr-start 1489 GenericParamTypeDecl.has_class Fld nodes.lkt:2469







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Self.Generic_Param_Type_Decl_F_Has_Class;
--# expr-done 1489



   if Fld = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]ClassQualifier.as_bool'
Fld_1 := Liblktlang.Implementation.Dispatcher_Class_Qualifier_P_As_Bool (Node => Fld);
--# end
--# expr-done 1490
if Fld_1 then
   --# expr-start 1491 StringLiteral Str_1 nodes.lkt:2470
Str_1 := Create_String ("generic class parameter type declaration"); 
--# expr-done 1491
   If_Result := Str_1;
else
   --# expr-start 1492 StringLiteral Str nodes.lkt:2471
Str := Create_String ("generic parameter type declaration"); 
--# expr-done 1492
   If_Result := Str;
end if;

      Inc_Ref (If_Result);


--# expr-done 1493

         Property_Result := If_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_234;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_234;




            raise;
      end;



   return Property_Result;
end Generic_Param_Type_Decl_P_Decl_Type_Name;
--# end



   


      

   --
   --  Primitives for Bare_Named_Type_Decl
   --

   




      
   function Named_Type_Decl_F_Decls
     (Node : Bare_Named_Type_Decl) return Bare_Decl_Block
   is
      

         Kind : constant Lkt_Named_Type_Decl := Node.Kind;
   begin
         case Kind is
               when Lkt_Class_Decl =>
                     
         return Node.Class_Decl_F_Decls;
      
               when Lkt_Enum_Class_Decl =>
                     
         return Node.Enum_Class_Decl_F_Decls;
      
               when Lkt_Enum_Type_Decl =>
                     
         return Node.Enum_Type_Decl_F_Decls;
      
               when Lkt_Struct_Decl =>
                     
         return Node.Struct_Decl_F_Decls;
      
               when Lkt_Trait_Decl =>
                     
         return Node.Trait_Decl_F_Decls;
      
         end case;
   end;


   







--# property-start NamedTypeDecl.defined_scope nodes.lkt:2482
pragma Warnings (Off, "is not referenced");

function Named_Type_Decl_P_Defined_Scope
  
  (Node : Bare_Named_Type_Decl
      ; Origin : Internal_Entity
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Lexical_Env
is
   Self : Bare_Named_Type_Decl :=
     Bare_Named_Type_Decl (Node);
     Ent : Internal_Entity_Named_Type_Decl :=
       Internal_Entity_Named_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind origin Origin

   Property_Result : Lexical_Env;

      
            procedure Finalizer_Scope_235 with Inline_Always;
            procedure Finalizer_Scope_642 with Inline_Always;

      Fld : Internal_Entity_Decl_Block;
Fld_1 : Lexical_Env := Empty_Env;
Var_Expr : Lexical_Env := Empty_Env;
Cast_Result : Internal_Entity;
Is_Equiv : Boolean;
Fld_2 : Internal_Entity_Type_Decl;
Fld_3 : Lexical_Env := Empty_Env;
Array_Lit : Lexical_Env_Array_Access;
Group_Env : Lexical_Env := Empty_Env;
If_Result : Lexical_Env := Empty_Env;
Scope_Result : Lexical_Env := Empty_Env;
Result_Var : Lexical_Env := Empty_Env;

            procedure Finalizer_Scope_235 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Result_Var);
            end Finalizer_Scope_235;
            procedure Finalizer_Scope_642 is
            begin
                     Dec_Ref (Var_Expr);
                     Dec_Ref (Fld_3);
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Group_Env);
                     Dec_Ref (If_Result);
            end Finalizer_Scope_642;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1502 .do Result_Var nodes.lkt:2483



--# expr-start 1495 LktNode.children_env Fld_1 nodes.lkt:2483



--# expr-start 1494 NamedTypeDecl.decls Fld nodes.lkt:2483







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Decl_Block (Node => Implementation.Named_Type_Decl_F_Decls (Ent.Node), Info => Ent.Info);
--# expr-done 1494



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Liblktlang.Implementation.Children_Env (Node => Fld.Node, E_Info => Fld.Info);
--# expr-done 1495
Var_Expr := Fld_1;

      Inc_Ref (Var_Expr);




if Var_Expr /= Empty_Env then
   



   --# scope-start



--# expr-start 1501 If If_Result nodes.lkt:2485



--# expr-start 1496 Eq Is_Equiv nodes.lkt:2485









   
      Cast_Result := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);



Is_Equiv := Equivalent (Cast_Result, Origin); 
--# expr-done 1496
if Is_Equiv then
   --# expr-start 1500 .env_group Group_Env nodes.lkt:2486
--# expr-start 1499 ArrayLiteral Array_Lit nodes.lkt:2486

--# expr-start 1498 Decl.defined_scope Fld_3 nodes.lkt:2486



--# expr-start 1497 TypeDecl.basic_trait_from_self Fld_2 nodes.lkt:2486







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.basic_trait_from_self
Fld_2 := Liblktlang.Implementation.Type_Decl_P_Basic_Trait_From_Self (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1497



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_3 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Fld_2.Node, Origin => Origin, E_Info => Fld_2.Info);
--# end
--# expr-done 1498
Array_Lit := Create_Lexical_Env_Array (Internal_Lexical_Env_Array'(1 => Var_Expr, 2 => Fld_3)); 
--# expr-done 1499

Group_Env := Group (Array_Lit, No_Metadata); 
--# expr-done 1500
   If_Result := Group_Env;
else
   
   If_Result := Var_Expr;
end if;

      Inc_Ref (If_Result);


--# expr-done 1501
Scope_Result := If_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_642;


   Result_Var := Scope_Result;
else
   
   Result_Var := Empty_Env;
end if;

      Inc_Ref (Result_Var);


--# expr-done 1502

         Property_Result := Result_Var;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_235;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_235;
                     Finalizer_Scope_642;




            raise;
      end;



   return Property_Result;
end Named_Type_Decl_P_Defined_Scope;
--# end



   


      

   --
   --  Primitives for Bare_Basic_Class_Decl
   --

   



      
      procedure Initialize_Fields_For_Basic_Class_Decl
        (Self : Bare_Basic_Class_Decl
         ; Basic_Class_Decl_F_Syn_Name : Bare_Def_Id
         ; Basic_Class_Decl_F_Syn_Base_Type : Bare_Type_Ref
         ; Basic_Class_Decl_F_Traits : Bare_Type_Ref_List
        ) is
      begin

            Self.Basic_Class_Decl_F_Syn_Name := Basic_Class_Decl_F_Syn_Name;
            Self.Basic_Class_Decl_F_Syn_Base_Type := Basic_Class_Decl_F_Syn_Base_Type;
            Self.Basic_Class_Decl_F_Traits := Basic_Class_Decl_F_Traits;
         

      end Initialize_Fields_For_Basic_Class_Decl;


   







--# property-start BasicClassDecl.is_subtype nodes.lkt:2501
pragma Warnings (Off, "is not referenced");

function Basic_Class_Decl_P_Is_Subtype
  
  (Node : Bare_Basic_Class_Decl
      ; Other : Internal_Entity_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Basic_Class_Decl :=
     Bare_Basic_Class_Decl (Node);
     Ent : Internal_Entity_Basic_Class_Decl :=
       Internal_Entity_Basic_Class_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind other Other

   Property_Result : Boolean;

      
            procedure Finalizer_Scope_236 with Inline_Always;

      Fld : Internal_Entity_Type_Decl_Array_Access;
Cast_Result : Internal_Entity;
Cast_Result_1 : Internal_Entity;
Is_Equiv : Boolean;
Find_Result : Internal_Entity_Type_Decl;
Is_Null : Boolean;
Not_Val : Boolean;

            procedure Finalizer_Scope_236 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_236;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1507 Not Not_Val nodes.lkt:2502
--# expr-start 1506 .is_null Is_Null nodes.lkt:2502
--# expr-start 1505 .find Find_Result nodes.lkt:2502








   

   --# expr-start 1503 TypeDecl.base_types Fld nodes.lkt:2502







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]TypeDecl.base_types'
Fld := Liblktlang.Implementation.Dispatcher_Type_Decl_P_Base_Types (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1503

   
      Find_Result := No_Entity_Type_Decl;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Type_Decl_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind b Item

            
      --# expr-start 1504 Eq Is_Equiv nodes.lkt:2502









   
      Cast_Result := Create_Internal_Entity
        (Node => Item.Node,
         Info => Item.Info);











   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Other.Node,
         Info => Other.Info);


Is_Equiv := Equivalent (Cast_Result, Cast_Result_1); 
--# expr-done 1504
      if Is_Equiv then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Is_Equiv;

         end loop;
      end;
   

   
   



--# expr-done 1505
Is_Null := Find_Result.Node = null; 
--# expr-done 1506
Not_Val := not (Is_Null); 
--# expr-done 1507

         Property_Result := Not_Val;
         
   --# end
      Finalizer_Scope_236;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_236;




            raise;
      end;



   return Property_Result;
end Basic_Class_Decl_P_Is_Subtype;
--# end

   







--# property-start BasicClassDecl.defined_scope nodes.lkt:2507
pragma Warnings (Off, "is not referenced");

function Basic_Class_Decl_P_Defined_Scope
  
  (Node : Bare_Basic_Class_Decl
      ; Origin : Internal_Entity
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Lexical_Env
is
   Self : Bare_Basic_Class_Decl :=
     Bare_Basic_Class_Decl (Node);
     Ent : Internal_Entity_Basic_Class_Decl :=
       Internal_Entity_Basic_Class_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind origin Origin

   Property_Result : Lexical_Env;

      
            procedure Finalizer_Scope_237 with Inline_Always;
            procedure Finalizer_Scope_644 with Inline_Always;
            procedure Finalizer_Scope_645 with Inline_Always;

      Fld : Internal_Entity_Decl_Block;
Fld_1 : Lexical_Env := Empty_Env;
Fld_2 : Internal_Entity_Type_Ref;
Var_Expr : Internal_Entity_Type_Ref;
Fld_3 : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity_Named_Type_Decl;
Var_Expr_1 : Internal_Entity_Named_Type_Decl;
Fld_4 : Lexical_Env := Empty_Env;
Result_Var_1 : Lexical_Env := Empty_Env;
Array_Lit : Lexical_Env_Array_Access;
Fld_5 : Internal_Entity_Type_Ref_List;
Item : Internal_Entity_Type_Ref;
Fld_6 : Internal_Entity_Type_Decl;
Var_Expr_2 : Internal_Entity_Type_Decl;
Fld_7 : Lexical_Env := Empty_Env;
Result_Var_2 : Lexical_Env := Empty_Env;
Fld_8 : Bare_Type_Ref_List;
Fld_9 : Internal_Entity_Info;
Bare_Item : Bare_Type_Ref;
As_Entity : Internal_Entity_Type_Ref;
Is_Null : Boolean;
If_Result : Internal_Entity_Type_Ref;
Map_Result : Lexical_Env_Array_Access;
Concat_Result : Lexical_Env_Array_Access;
Group_Env : Lexical_Env := Empty_Env;
Var_Expr_3 : Lexical_Env := Empty_Env;
Cast_Result_1 : Internal_Entity;
Is_Equiv : Boolean;
Fld_10 : Internal_Entity_Type_Decl;
Fld_11 : Lexical_Env := Empty_Env;
Array_Lit_1 : Lexical_Env_Array_Access;
Group_Env_1 : Lexical_Env := Empty_Env;
If_Result_1 : Lexical_Env := Empty_Env;
Scope_Result : Lexical_Env := Empty_Env;
Result_Var_3 : Lexical_Env := Empty_Env;

            procedure Finalizer_Scope_237 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Fld_4);
                     Dec_Ref (Result_Var_1);
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Concat_Result);
                     Dec_Ref (Group_Env);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Result_Var_3);
            end Finalizer_Scope_237;
            procedure Finalizer_Scope_644 is
            begin
                     Dec_Ref (Fld_7);
                     Dec_Ref (Result_Var_2);
            end Finalizer_Scope_644;
            procedure Finalizer_Scope_645 is
            begin
                     Dec_Ref (Var_Expr_3);
                     Dec_Ref (Fld_11);
                     Dec_Ref (Array_Lit_1);
                     Dec_Ref (Group_Env_1);
                     Dec_Ref (If_Result_1);
            end Finalizer_Scope_645;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Basic_Class_Decl_Basic_Class_Decl_P_Defined_Scope,
            Items    => new Mmz_Key_Array (1 ..  3))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Basic_Class_Decl,
                                As_Bare_Basic_Class_Decl => Self);
               Mmz_K.Items (2) := (Kind => Mmz_Internal_Entity,
                                      As_Internal_Entity => Origin);
               Mmz_K.Items (3) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Lexical_Env;
                  Inc_Ref (Property_Result);

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 1527 .do Result_Var_3 nodes.lkt:2508



--# expr-start 1520 .env_group Group_Env nodes.lkt:2508
--# expr-start 1519 ArrayConcat Concat_Result nodes.lkt:2509
--# expr-start 1514 ArrayLiteral Array_Lit nodes.lkt:2509
--# expr-start 1509 LktNode.children_env Fld_1 nodes.lkt:2510



--# expr-start 1508 NamedTypeDecl.decls Fld nodes.lkt:2510







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Decl_Block (Node => Implementation.Named_Type_Decl_F_Decls (Ent.Node), Info => Ent.Info);
--# expr-done 1508



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Liblktlang.Implementation.Children_Env (Node => Fld.Node, E_Info => Fld.Info);
--# expr-done 1509



--# expr-start 1512 Cast Cast_Result nodes.lkt:2511








--# expr-start 1510 TypeDecl.base_type Fld_2 nodes.lkt:2511







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.base_type
Fld_2 := Liblktlang.Implementation.Type_Decl_P_Base_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1510
Var_Expr := Fld_2;





if Var_Expr /= No_Entity_Type_Ref then
   --# expr-start 1511 TypeRef.referenced_decl Fld_3 nodes.lkt:2511







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_3 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 1511
   Result_Var := Fld_3;
else
   
   Result_Var := No_Entity_Type_Decl;
end if;






   if Result_Var.Node = null
      or else Result_Var.Node.Kind in Lkt_Named_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Named_Type_Decl
        (Node => Result_Var.Node,
         Info => Result_Var.Info);

   else
         Cast_Result := No_Entity_Named_Type_Decl;
   end if;


--# expr-done 1512
Var_Expr_1 := Cast_Result;





if Var_Expr_1 /= No_Entity_Named_Type_Decl then
   --# expr-start 1513 NamedTypeDecl.defined_scope Fld_4 nodes.lkt:2511







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_4 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Var_Expr_1.Node, Origin => Origin, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 1513
   Result_Var_1 := Fld_4;
else
   
   Result_Var_1 := Empty_Env;
end if;

      Inc_Ref (Result_Var_1);


Array_Lit := Create_Lexical_Env_Array (Internal_Lexical_Env_Array'(1 => Fld_1, 2 => Result_Var_1)); 
--# expr-done 1514
--# expr-start 1518 .map Map_Result nodes.lkt:2515








   

   --# expr-start 1515 BasicClassDecl.traits Fld_5 nodes.lkt:2515







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Type_Ref_List (Node => Ent.Node.Basic_Class_Decl_F_Traits, Info => Ent.Info);
--# expr-done 1515









Fld_8 := Fld_5.Node;

   
      declare
         Map_Result_Vec : Lexical_Env_Vectors.Vector;
      begin
   

   

      if Fld_8 = null then
         
      Map_Result := Create_Lexical_Env_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Type_Ref_List := Fld_8;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Type_Ref;
else
   








Fld_9 := Fld_5.Info;

As_Entity := (Info => Fld_9, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind t Item

            
         
         
      


--# expr-start 1516 TypeRef.referenced_decl Fld_6 nodes.lkt:2515







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_6 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 1516
Var_Expr_2 := Fld_6;





if Var_Expr_2 /= No_Entity_Type_Decl then
   --# expr-start 1517 Decl.defined_scope Fld_7 nodes.lkt:2515







   if Var_Expr_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_7 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Var_Expr_2.Node, Origin => Origin, E_Info => Var_Expr_2.Info);
--# end
--# expr-done 1517
   Result_Var_2 := Fld_7;
else
   
   Result_Var_2 := Empty_Env;
end if;

      Inc_Ref (Result_Var_2);


      

         declare
            Item_To_Append : constant Lexical_Env := Result_Var_2;
         begin
               Inc_Ref (Item_To_Append);
            Lexical_Env_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_644;



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Lexical_Env_Array
           (Items_Count => Natural (Lexical_Env_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Lexical_Env_Vectors.Get
              (Map_Result_Vec,
               I + Lexical_Env_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Lexical_Env_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1518
Concat_Result := Concat (Array_Lit, Map_Result); 
--# expr-done 1519

Group_Env := Group (Concat_Result, No_Metadata); 
--# expr-done 1520
Var_Expr_3 := Group_Env;

      Inc_Ref (Var_Expr_3);




if Var_Expr_3 /= Empty_Env then
   



   --# scope-start



--# expr-start 1526 If If_Result_1 nodes.lkt:2520



--# expr-start 1521 Eq Is_Equiv nodes.lkt:2520









   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);



Is_Equiv := Equivalent (Cast_Result_1, Origin); 
--# expr-done 1521
if Is_Equiv then
   --# expr-start 1525 .env_group Group_Env_1 nodes.lkt:2521
--# expr-start 1524 ArrayLiteral Array_Lit_1 nodes.lkt:2521

--# expr-start 1523 Decl.defined_scope Fld_11 nodes.lkt:2521



--# expr-start 1522 TypeDecl.basic_trait_from_self Fld_10 nodes.lkt:2521







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.basic_trait_from_self
Fld_10 := Liblktlang.Implementation.Type_Decl_P_Basic_Trait_From_Self (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1522



   if Fld_10.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_11 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Fld_10.Node, Origin => Origin, E_Info => Fld_10.Info);
--# end
--# expr-done 1523
Array_Lit_1 := Create_Lexical_Env_Array (Internal_Lexical_Env_Array'(1 => Var_Expr_3, 2 => Fld_11)); 
--# expr-done 1524

Group_Env_1 := Group (Array_Lit_1, No_Metadata); 
--# expr-done 1525
   If_Result_1 := Group_Env_1;
else
   
   If_Result_1 := Var_Expr_3;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 1526
Scope_Result := If_Result_1;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_645;


   Result_Var_3 := Scope_Result;
else
   
   Result_Var_3 := Empty_Env;
end if;

      Inc_Ref (Result_Var_3);


--# expr-done 1527

         Property_Result := Result_Var_3;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_237;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_237;
                     Finalizer_Scope_644;
                     Finalizer_Scope_645;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Lexical_Env,
                     As_Lexical_Env => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
            if Mmz_Stored then
               Inc_Ref (Property_Result);
            end if;
      end if;



   return Property_Result;
end Basic_Class_Decl_P_Defined_Scope;
--# end

   







--# property-start BasicClassDecl.defined_scope_as_entity nodes.lkt:2526
pragma Warnings (Off, "is not referenced");

function Basic_Class_Decl_P_Defined_Scope_As_Entity
  
  (Node : Bare_Basic_Class_Decl
      ; Origin : Internal_Entity
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Lexical_Env
is
   Self : Bare_Basic_Class_Decl :=
     Bare_Basic_Class_Decl (Node);
     Ent : Internal_Entity_Basic_Class_Decl :=
       Internal_Entity_Basic_Class_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind origin Origin

   Property_Result : Lexical_Env;

      
            procedure Finalizer_Scope_238 with Inline_Always;
            procedure Finalizer_Scope_646 with Inline_Always;
            procedure Finalizer_Scope_647 with Inline_Always;
            procedure Finalizer_Scope_648 with Inline_Always;

      Fld : Internal_Entity_Named_Type_Decl;
Fld_1 : Bare_Named_Type_Decl;
Cast_Result : Bare_Named_Type_Decl;
Is_Equal : Boolean;
Fld_2 : Internal_Entity_Decl;
Fld_3 : Internal_Entity_Named_Type_Decl;
Fld_4 : Internal_Entity_Decl;
Fld_5 : Lexical_Env := Empty_Env;
Sym : Symbol_Type;
Env_Get_Result : Internal_Entity;
Cast_Result_1 : Internal_Entity_Type_Decl;
Array_Lit : Internal_Entity_Type_Decl_Array_Access;
Fld_6 : Internal_Entity_Decl;
Cast_Result_2 : Internal_Entity_Type_Decl;
Array_Lit_1 : Internal_Entity_Type_Decl_Array_Access;
Fld_7 : Internal_Entity_Decl;
Cast_Result_3 : Internal_Entity_Basic_Class_Decl;
If_Result : Internal_Entity_Basic_Class_Decl;
Local_Entity : Internal_Entity_Basic_Class_Decl;
Fld_8 : Internal_Entity_Decl_Block;
Fld_9 : Lexical_Env := Empty_Env;
Fld_10 : Internal_Entity_Type_Ref;
Var_Expr : Internal_Entity_Type_Ref;
Fld_11 : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;
Cast_Result_4 : Internal_Entity_Named_Type_Decl;
Var_Expr_1 : Internal_Entity_Named_Type_Decl;
Fld_12 : Lexical_Env := Empty_Env;
Result_Var_1 : Lexical_Env := Empty_Env;
Array_Lit_2 : Lexical_Env_Array_Access;
Fld_13 : Internal_Entity_Type_Ref_List;
Item : Internal_Entity_Type_Ref;
Fld_14 : Internal_Entity_Type_Decl;
Var_Expr_2 : Internal_Entity_Type_Decl;
Fld_15 : Lexical_Env := Empty_Env;
Result_Var_2 : Lexical_Env := Empty_Env;
Fld_16 : Bare_Type_Ref_List;
Fld_17 : Internal_Entity_Info;
Bare_Item : Bare_Type_Ref;
As_Entity : Internal_Entity_Type_Ref;
Is_Null : Boolean;
If_Result_1 : Internal_Entity_Type_Ref;
Map_Result : Lexical_Env_Array_Access;
Concat_Result : Lexical_Env_Array_Access;
Group_Env : Lexical_Env := Empty_Env;
Var_Expr_3 : Lexical_Env := Empty_Env;
Cast_Result_5 : Internal_Entity;
Is_Equiv : Boolean;
Fld_18 : Internal_Entity_Type_Decl;
Fld_19 : Lexical_Env := Empty_Env;
Array_Lit_3 : Lexical_Env_Array_Access;
Group_Env_1 : Lexical_Env := Empty_Env;
If_Result_2 : Lexical_Env := Empty_Env;
Scope_Result : Lexical_Env := Empty_Env;
Result_Var_3 : Lexical_Env := Empty_Env;
Let_Result : Lexical_Env := Empty_Env;
Scope_Result_1 : Lexical_Env := Empty_Env;

            procedure Finalizer_Scope_238 is
            begin
                     Dec_Ref (Scope_Result_1);
            end Finalizer_Scope_238;
            procedure Finalizer_Scope_646 is
            begin
                     Dec_Ref (Fld_5);
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Array_Lit_1);
                     Dec_Ref (Fld_9);
                     Dec_Ref (Fld_12);
                     Dec_Ref (Result_Var_1);
                     Dec_Ref (Array_Lit_2);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Concat_Result);
                     Dec_Ref (Group_Env);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Result_Var_3);
                     Dec_Ref (Let_Result);
            end Finalizer_Scope_646;
            procedure Finalizer_Scope_647 is
            begin
                     Dec_Ref (Fld_15);
                     Dec_Ref (Result_Var_2);
            end Finalizer_Scope_647;
            procedure Finalizer_Scope_648 is
            begin
                     Dec_Ref (Var_Expr_3);
                     Dec_Ref (Fld_19);
                     Dec_Ref (Array_Lit_3);
                     Dec_Ref (Group_Env_1);
                     Dec_Ref (If_Result_2);
            end Finalizer_Scope_648;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 1565 ValDecl Let_Result nodes.lkt:2527
--# scope-start
--# expr-start 1544 If If_Result nodes.lkt:2528



--# expr-start 1530 Eq Is_Equal nodes.lkt:2528









   
      Cast_Result := Self;


--# expr-start 1529 'Entity[NamedTypeDecl].node' Fld_1 nodes.lkt:2528



--# expr-start 1528 LktNode.astlist_type Fld nodes.lkt:2528







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.astlist_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Astlist_Type (Node => Self);
--# end
--# expr-done 1528





Fld_1 := Fld.Node;
--# expr-done 1529
Is_Equal := Cast_Result = Fld_1; 
--# expr-done 1530
if Is_Equal then
   --# expr-start 1543 Cast Cast_Result_3 nodes.lkt:2530





--# expr-start 1542 Decl.instantiate_generic_decl Fld_7 nodes.lkt:2530



--# expr-start 1531 Decl.as_bare_decl Fld_2 nodes.lkt:2530







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.as_bare_decl
Fld_2 := Liblktlang.Implementation.Decl_P_As_Bare_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1531



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1541 ArrayLiteral Array_Lit_1 nodes.lkt:2531
--# expr-start 1540 Cast Cast_Result_2 nodes.lkt:2532





--# expr-start 1539 Decl.instantiate_generic_decl Fld_6 nodes.lkt:2532



--# expr-start 1533 Decl.as_bare_decl Fld_4 nodes.lkt:2532



--# expr-start 1532 LktNode.entity_type Fld_3 nodes.lkt:2532







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_3 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Ent.Node);
--# end
--# expr-done 1532



   if Fld_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.as_bare_decl
Fld_4 := Liblktlang.Implementation.Decl_P_As_Bare_Decl (Node => Fld_3.Node, E_Info => Fld_3.Info);
--# end
--# expr-done 1533



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1538 ArrayLiteral Array_Lit nodes.lkt:2534
--# expr-start 1537 Cast Cast_Result_1 nodes.lkt:2534





--# expr-start 1536 .get_first Env_Get_Result nodes.lkt:2534
--# expr-start 1534 LktNode.node_env Fld_5 nodes.lkt:2534







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Liblktlang.Implementation.Node_Env (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 1534
--# expr-start 1535 SymbolLiteral Sym nodes.lkt:2534
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_T); 
--# expr-done 1535


Env_Get_Result := AST_Envs.Get_First (Self => Fld_5, Key => Thin (Sym), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 1536



   if Env_Get_Result.Node = null
      or else Env_Get_Result.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_1 := Create_Internal_Entity_Type_Decl
        (Node => Env_Get_Result.Node,
         Info => Env_Get_Result.Info);

   else
         Cast_Result_1 := No_Entity_Type_Decl;
   end if;


--# expr-done 1537
Array_Lit := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Cast_Result_1)); 
--# expr-done 1538
--# property-call-start Decl.instantiate_generic_decl
Fld_6 := Liblktlang.Implementation.Decl_P_Instantiate_Generic_Decl (Node => Fld_4.Node, Param_Types => Array_Lit, E_Info => Fld_4.Info);
--# end
--# expr-done 1539



   if Fld_6.Node = null
      or else Fld_6.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_2 := Create_Internal_Entity_Type_Decl
        (Node => Fld_6.Node,
         Info => Fld_6.Info);

   else
         Cast_Result_2 := No_Entity_Type_Decl;
   end if;


--# expr-done 1540
Array_Lit_1 := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Cast_Result_2)); 
--# expr-done 1541
--# property-call-start Decl.instantiate_generic_decl
Fld_7 := Liblktlang.Implementation.Decl_P_Instantiate_Generic_Decl (Node => Fld_2.Node, Param_Types => Array_Lit_1, E_Info => Fld_2.Info);
--# end
--# expr-done 1542



   if Fld_7.Node = null
      or else Fld_7.Node.Kind in Lkt_Basic_Class_Decl
   then
      
      Cast_Result_3 := Create_Internal_Entity_Basic_Class_Decl
        (Node => Fld_7.Node,
         Info => Fld_7.Info);

   else
         Cast_Result_3 := No_Entity_Basic_Class_Decl;
   end if;


--# expr-done 1543
   If_Result := Cast_Result_3;
else
   
   If_Result := Ent;
end if;



--# expr-done 1544
Local_Entity := If_Result; 
--# bind entity Local_Entity
--# expr-start 1564 .do Result_Var_3 nodes.lkt:2542



--# expr-start 1557 .env_group Group_Env nodes.lkt:2542
--# expr-start 1556 ArrayConcat Concat_Result nodes.lkt:2543
--# expr-start 1551 ArrayLiteral Array_Lit_2 nodes.lkt:2543
--# expr-start 1546 LktNode.children_env Fld_9 nodes.lkt:2544



--# expr-start 1545 NamedTypeDecl.decls Fld_8 nodes.lkt:2544







   if Local_Entity.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Create_Internal_Entity_Decl_Block (Node => Implementation.Named_Type_Decl_F_Decls (Local_Entity.Node), Info => Local_Entity.Info);
--# expr-done 1545



   if Fld_8.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Liblktlang.Implementation.Children_Env (Node => Fld_8.Node, E_Info => Fld_8.Info);
--# expr-done 1546



--# expr-start 1549 Cast Cast_Result_4 nodes.lkt:2545








--# expr-start 1547 TypeDecl.base_type Fld_10 nodes.lkt:2545







   if Local_Entity.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.base_type
Fld_10 := Liblktlang.Implementation.Type_Decl_P_Base_Type (Node => Local_Entity.Node, E_Info => Local_Entity.Info);
--# end
--# expr-done 1547
Var_Expr := Fld_10;





if Var_Expr /= No_Entity_Type_Ref then
   --# expr-start 1548 TypeRef.referenced_decl Fld_11 nodes.lkt:2545







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_11 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 1548
   Result_Var := Fld_11;
else
   
   Result_Var := No_Entity_Type_Decl;
end if;






   if Result_Var.Node = null
      or else Result_Var.Node.Kind in Lkt_Named_Type_Decl
   then
      
      Cast_Result_4 := Create_Internal_Entity_Named_Type_Decl
        (Node => Result_Var.Node,
         Info => Result_Var.Info);

   else
         Cast_Result_4 := No_Entity_Named_Type_Decl;
   end if;


--# expr-done 1549
Var_Expr_1 := Cast_Result_4;





if Var_Expr_1 /= No_Entity_Named_Type_Decl then
   --# expr-start 1550 Decl.defined_scope_as_entity Fld_12 nodes.lkt:2545







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope_as_entity'
Fld_12 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope_As_Entity (Node => Var_Expr_1.Node, Origin => Origin, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 1550
   Result_Var_1 := Fld_12;
else
   
   Result_Var_1 := Empty_Env;
end if;

      Inc_Ref (Result_Var_1);


Array_Lit_2 := Create_Lexical_Env_Array (Internal_Lexical_Env_Array'(1 => Fld_9, 2 => Result_Var_1)); 
--# expr-done 1551
--# expr-start 1555 .map Map_Result nodes.lkt:2549








   

   --# expr-start 1552 BasicClassDecl.traits Fld_13 nodes.lkt:2549







   if Local_Entity.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_13 := Create_Internal_Entity_Type_Ref_List (Node => Local_Entity.Node.Basic_Class_Decl_F_Traits, Info => Local_Entity.Info);
--# expr-done 1552









Fld_16 := Fld_13.Node;

   
      declare
         Map_Result_Vec : Lexical_Env_Vectors.Vector;
      begin
   

   

      if Fld_16 = null then
         
      Map_Result := Create_Lexical_Env_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Type_Ref_List := Fld_16;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result_1 := No_Entity_Type_Ref;
else
   








Fld_17 := Fld_13.Info;

As_Entity := (Info => Fld_17, Node => Bare_Item); 
   If_Result_1 := As_Entity;
end if;



                  Item := If_Result_1; 

            
   --# scope-start


               --# bind t Item

            
         
         
      


--# expr-start 1553 TypeRef.referenced_decl Fld_14 nodes.lkt:2550







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_14 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 1553
Var_Expr_2 := Fld_14;





if Var_Expr_2 /= No_Entity_Type_Decl then
   --# expr-start 1554 Decl.defined_scope_as_entity Fld_15 nodes.lkt:2550







   if Var_Expr_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope_as_entity'
Fld_15 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope_As_Entity (Node => Var_Expr_2.Node, Origin => Origin, E_Info => Var_Expr_2.Info);
--# end
--# expr-done 1554
   Result_Var_2 := Fld_15;
else
   
   Result_Var_2 := Empty_Env;
end if;

      Inc_Ref (Result_Var_2);


      

         declare
            Item_To_Append : constant Lexical_Env := Result_Var_2;
         begin
               Inc_Ref (Item_To_Append);
            Lexical_Env_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_647;



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Lexical_Env_Array
           (Items_Count => Natural (Lexical_Env_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Lexical_Env_Vectors.Get
              (Map_Result_Vec,
               I + Lexical_Env_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Lexical_Env_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1555
Concat_Result := Concat (Array_Lit_2, Map_Result); 
--# expr-done 1556

Group_Env := Group (Concat_Result, No_Metadata); 
--# expr-done 1557
Var_Expr_3 := Group_Env;

      Inc_Ref (Var_Expr_3);




if Var_Expr_3 /= Empty_Env then
   



   --# scope-start



--# expr-start 1563 If If_Result_2 nodes.lkt:2556



--# expr-start 1558 Eq Is_Equiv nodes.lkt:2556









   
      Cast_Result_5 := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);



Is_Equiv := Equivalent (Cast_Result_5, Origin); 
--# expr-done 1558
if Is_Equiv then
   --# expr-start 1562 .env_group Group_Env_1 nodes.lkt:2558
--# expr-start 1561 ArrayLiteral Array_Lit_3 nodes.lkt:2558

--# expr-start 1560 Decl.defined_scope Fld_19 nodes.lkt:2558



--# expr-start 1559 TypeDecl.basic_trait_from_self Fld_18 nodes.lkt:2558







   if Local_Entity.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.basic_trait_from_self
Fld_18 := Liblktlang.Implementation.Type_Decl_P_Basic_Trait_From_Self (Node => Local_Entity.Node, E_Info => Local_Entity.Info);
--# end
--# expr-done 1559



   if Fld_18.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_19 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Fld_18.Node, Origin => Origin, E_Info => Fld_18.Info);
--# end
--# expr-done 1560
Array_Lit_3 := Create_Lexical_Env_Array (Internal_Lexical_Env_Array'(1 => Var_Expr_3, 2 => Fld_19)); 
--# expr-done 1561

Group_Env_1 := Group (Array_Lit_3, No_Metadata); 
--# expr-done 1562
   If_Result_2 := Group_Env_1;
else
   
   If_Result_2 := Var_Expr_3;
end if;

      Inc_Ref (If_Result_2);


--# expr-done 1563
Scope_Result := If_Result_2;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_648;


   Result_Var_3 := Scope_Result;
else
   
   Result_Var_3 := Empty_Env;
end if;

      Inc_Ref (Result_Var_3);


--# expr-done 1564
Let_Result := Result_Var_3; Inc_Ref (Let_Result);
--# end
--# expr-done 1565
Scope_Result_1 := Let_Result;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_646;



         Property_Result := Scope_Result_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_238;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_238;
                     Finalizer_Scope_646;
                     Finalizer_Scope_647;
                     Finalizer_Scope_648;




            raise;
      end;



   return Property_Result;
end Basic_Class_Decl_P_Defined_Scope_As_Entity;
--# end

   







--# property-start BasicClassDecl.common_ancestor nodes.lkt:2564
pragma Warnings (Off, "is not referenced");

function Basic_Class_Decl_P_Common_Ancestor
  
  (Node : Bare_Basic_Class_Decl
      ; Other : Internal_Entity_Type_Decl
      ; Imprecise : Boolean
         := False
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Basic_Class_Decl :=
     Bare_Basic_Class_Decl (Node);
     Ent : Internal_Entity_Basic_Class_Decl :=
       Internal_Entity_Basic_Class_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind other Other
   --# bind imprecise Imprecise

   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_649 with Inline_Always;

      Var_Expr : Internal_Entity_Type_Decl;
Fld : Internal_Entity_Type_Decl_Array_Access;
Result_Var : Internal_Entity_Type_Decl_Array_Access;
Local_Other_Bases : Internal_Entity_Type_Decl_Array_Access;
Var_Expr_1 : Internal_Entity_Basic_Class_Decl;
Fld_1 : Internal_Entity_Type_Decl_Array_Access;
Cast_Result : Internal_Entity;
Cast_Result_1 : Internal_Entity;
Is_Equiv : Boolean;
Quantifier_Result : Boolean;
Find_Result : Internal_Entity_Type_Decl;
Result_Var_1 : Internal_Entity_Type_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Type_Decl;
Var_Expr_2 : Internal_Entity_Type_Decl;
Scope_Result : Internal_Entity_Type_Decl;
Is_Null_1 : Boolean;
Cast_Result_2 : Internal_Entity_Type_Decl;
If_Result_1 : Internal_Entity_Type_Decl;
If_Result_2 : Internal_Entity_Type_Decl;
Result_Var_2 : Internal_Entity_Type_Decl;
Let_Result : Internal_Entity_Type_Decl;
Scope_Result_1 : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_649 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Result_Var);
                     Dec_Ref (Local_Other_Bases);
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_649;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 1576 ValDecl Let_Result nodes.lkt:2568
--# scope-start




Var_Expr := Other;





if Var_Expr /= No_Entity_Type_Decl then
   --# expr-start 1566 TypeDecl.base_types Fld nodes.lkt:2568







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start '[dispatcher]TypeDecl.base_types'
Fld := Liblktlang.Implementation.Dispatcher_Type_Decl_P_Base_Types (Node => Var_Expr.Node, Include_Self => True, E_Info => Var_Expr.Info);
--# end
--# expr-done 1566
   Result_Var := Fld;
else
   
   Result_Var := No_Internal_Entity_Type_Decl_Array_Type;
end if;

      Inc_Ref (Result_Var);


Local_Other_Bases := Result_Var; Inc_Ref (Local_Other_Bases);
--# bind other_bases Local_Other_Bases
--# expr-start 1575 .do Result_Var_2 nodes.lkt:2570



--# expr-start 1571 If If_Result nodes.lkt:2571



--# expr-start 1567 .is_null Is_Null nodes.lkt:2571

Is_Null := Other.Node = null; 
--# expr-done 1567
if Is_Null then
   
   If_Result := No_Entity_Type_Decl;
else
   



Var_Expr_1 := Ent;





if Var_Expr_1 /= No_Entity_Basic_Class_Decl then
   --# expr-start 1570 .find Find_Result nodes.lkt:2572








   

   --# expr-start 1568 TypeDecl.base_types Fld_1 nodes.lkt:2572







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start '[dispatcher]TypeDecl.base_types'
Fld_1 := Liblktlang.Implementation.Dispatcher_Type_Decl_P_Base_Types (Node => Var_Expr_1.Node, Include_Self => True, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 1568

   
      Find_Result := No_Entity_Type_Decl;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Type_Decl_Array_Access := Fld_1;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind b Item

            
      --# expr-start 1569 .contains Quantifier_Result nodes.lkt:2572








   

   

   
      Quantifier_Result := False;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Type_Decl_Array_Access := Local_Other_Bases;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start



            
      








   
      Cast_Result := Create_Internal_Entity
        (Node => Item_1.Node,
         Info => Item_1.Info);











   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Item.Node,
         Info => Item.Info);


Is_Equiv := Equivalent (Cast_Result, Cast_Result_1); 
      Quantifier_Result := Is_Equiv;
   

            
   --# end


               exit when Quantifier_Result;

         end loop;
      end;
   

   
   



--# expr-done 1569
      if Quantifier_Result then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Quantifier_Result;

         end loop;
      end;
   

   
   



--# expr-done 1570
   Result_Var_1 := Find_Result;
else
   
   Result_Var_1 := No_Entity_Type_Decl;
end if;



   If_Result := Result_Var_1;
end if;



--# expr-done 1571
Var_Expr_2 := If_Result;





if Var_Expr_2 /= No_Entity_Type_Decl then
   



   --# scope-start




Scope_Result := Var_Expr_2;


   --# end


   Result_Var_2 := Scope_Result;
else
   --# expr-start 1574 If If_Result_2 nodes.lkt:2576




if Imprecise then
   --# expr-start 1573 If If_Result_1 nodes.lkt:2576



--# expr-start 1572 .is_null Is_Null_1 nodes.lkt:2576

Is_Null_1 := Ent.Node = null; 
--# expr-done 1572
if Is_Null_1 then
   
   If_Result_1 := Other;
else
   








   
      Cast_Result_2 := Create_Internal_Entity_Type_Decl
        (Node => Ent.Node,
         Info => Ent.Info);


   If_Result_1 := Cast_Result_2;
end if;



--# expr-done 1573
   If_Result_2 := If_Result_1;
else
   
   If_Result_2 := No_Entity_Type_Decl;
end if;



--# expr-done 1574
   Result_Var_2 := If_Result_2;
end if;



--# expr-done 1575
Let_Result := Result_Var_2; 
--# end
--# expr-done 1576
Scope_Result_1 := Let_Result;


   --# end
      Finalizer_Scope_649;



         Property_Result := Scope_Result_1;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_649;




            raise;
      end;



   return Property_Result;
end Basic_Class_Decl_P_Common_Ancestor;
--# end



   


      

   --
   --  Primitives for Bare_Class_Decl
   --

   



      
      procedure Initialize_Fields_For_Class_Decl
        (Self : Bare_Class_Decl
         ; Basic_Class_Decl_F_Syn_Name : Bare_Def_Id
         ; Basic_Class_Decl_F_Syn_Base_Type : Bare_Type_Ref
         ; Basic_Class_Decl_F_Traits : Bare_Type_Ref_List
         ; Class_Decl_F_Decls : Bare_Decl_Block
        ) is
      begin
            Initialize_Fields_For_Basic_Class_Decl
              (Self, Basic_Class_Decl_F_Syn_Name, Basic_Class_Decl_F_Syn_Base_Type, Basic_Class_Decl_F_Traits);

            Self.Class_Decl_F_Decls := Class_Decl_F_Decls;
         

      end Initialize_Fields_For_Class_Decl;


   







--# property-start ClassDecl.decl_type_name nodes.lkt:2588
pragma Warnings (Off, "is not referenced");

function Class_Decl_P_Decl_Type_Name
  
  (Node : Bare_Class_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Class_Decl :=
     Bare_Class_Decl (Node);
     Ent : Internal_Entity_Class_Decl :=
       Internal_Entity_Class_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_240 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_240 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_240;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1577 StringLiteral Str nodes.lkt:2588
Str := Create_String ("class declaration"); 
--# expr-done 1577

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_240;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_240;




            raise;
      end;



   return Property_Result;
end Class_Decl_P_Decl_Type_Name;
--# end

   







--# property-start ClassDecl.constructor_fields nodes.lkt:2592
pragma Warnings (Off, "is not referenced");

function Class_Decl_P_Constructor_Fields
  
  (Node : Bare_Class_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Field_Decl_Array_Access
is
   Self : Bare_Class_Decl :=
     Bare_Class_Decl (Node);
     Ent : Internal_Entity_Class_Decl :=
       Internal_Entity_Class_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Field_Decl_Array_Access;

      
            procedure Finalizer_Scope_242 with Inline_Always;
            procedure Finalizer_Scope_653 with Inline_Always;

      Fld : Internal_Entity_Type_Decl_Array_Access;
Cast_Result : Internal_Entity_Class_Decl;
Fld_1 : Internal_Entity_Decl_Block;
Item_1 : Internal_Entity_Full_Decl;
Fld_2 : Internal_Entity_Decl;
Cast_Result_1 : Internal_Entity_Field_Decl;
Fld_3 : Internal_Entity_Decl;
Is_A : Boolean;
Sym : Symbol_Type;
Fld_4 : Boolean;
Sym_1 : Symbol_Type;
Fld_5 : Boolean;
Not_Val : Boolean;
Sym_2 : Symbol_Type;
Fld_6 : Boolean;
Not_Val_1 : Boolean;
If_Result : Boolean;
If_Result_1 : Boolean;
If_Result_2 : Boolean;
Fld_7 : Bare_Decl_Block;
Fld_8 : Internal_Entity_Info;
Bare_Item_1 : Bare_Full_Decl;
As_Entity : Internal_Entity_Full_Decl;
Is_Null : Boolean;
If_Result_3 : Internal_Entity_Full_Decl;
Map_Result : Internal_Entity_Field_Decl_Array_Access;
Map_Result_1 : Internal_Entity_Field_Decl_Array_Access;

            procedure Finalizer_Scope_242 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Map_Result_1);
            end Finalizer_Scope_242;
            procedure Finalizer_Scope_653 is
            begin
                     Dec_Ref (Map_Result);
            end Finalizer_Scope_653;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1597 .mapcat Map_Result_1 nodes.lkt:2593








   

   --# expr-start 1578 TypeDecl.base_types Fld nodes.lkt:2593







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start '[dispatcher]TypeDecl.base_types'
Fld := Liblktlang.Implementation.Dispatcher_Type_Decl_P_Base_Types (Node => Ent.Node, Include_Self => True, E_Info => Ent.Info);
--# end
--# expr-done 1578

   
      declare
         Map_Result_1_Vec : Internal_Entity_Field_Decl_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Type_Decl_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind base Item

            
         
         
      --# expr-start 1596 .filtermap Map_Result nodes.lkt:2595








   

   --# expr-start 1580 ClassDecl.decls Fld_1 nodes.lkt:2595



--# expr-start 1579 Cast Cast_Result nodes.lkt:2595









   if Item.Node = null
      or else Item.Node.Kind in Lkt_Class_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Class_Decl
        (Node => Item.Node,
         Info => Item.Info);

   else
         Cast_Result := No_Entity_Class_Decl;
   end if;


--# expr-done 1579



   if Cast_Result.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Decl_Block (Node => Cast_Result.Node.Class_Decl_F_Decls, Info => Cast_Result.Info);
--# expr-done 1580









Fld_7 := Fld_1.Node;

   
      declare
         Map_Result_Vec : Internal_Entity_Field_Decl_Vectors.Vector;
      begin
   

   

      if Fld_7 = null then
         
      Map_Result := Create_Internal_Entity_Field_Decl_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Decl_Block := Fld_7;
      begin
         for Untyped_Item_1 of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item_1 := Untyped_Item_1; 
                  



Is_Null := Bare_Item_1 = null; 
if Is_Null then
   
   If_Result_3 := No_Entity_Full_Decl;
else
   








Fld_8 := Fld_1.Info;

As_Entity := (Info => Fld_8, Node => Bare_Item_1); 
   If_Result_3 := As_Entity;
end if;



                  Item_1 := If_Result_3; 

            
   --# scope-start


               --# bind d Item_1

            
         --# expr-start 1593 BooleanAnd If_Result_2 nodes.lkt:2598



--# expr-start 1582 IsA Is_A nodes.lkt:2598
--# expr-start 1581 FullDecl.decl Fld_3 nodes.lkt:2598







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Decl (Node => Item_1.Node.Full_Decl_F_Decl, Info => Item_1.Info);
--# expr-done 1581
Is_A := Fld_3.Node /= null 
and then Fld_3.Node.Kind in Lkt_Field_Decl_Range; 
--# expr-done 1582
if Is_A then
   --# expr-start 1592 If If_Result_1 nodes.lkt:2600



--# expr-start 1584 FullDecl.has_annotation Fld_4 nodes.lkt:2600







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1583 SymbolLiteral Sym nodes.lkt:2600
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Parse_Field); 
--# expr-done 1583
--# property-call-start FullDecl.has_annotation
Fld_4 := Liblktlang.Implementation.Full_Decl_P_Has_Annotation (Node => Item_1.Node, Name => Sym);
--# end
--# expr-done 1584
if Fld_4 then
   --# expr-start 1591 BooleanAnd If_Result nodes.lkt:2602



--# expr-start 1587 Not Not_Val nodes.lkt:2602
--# expr-start 1586 FullDecl.has_annotation Fld_5 nodes.lkt:2602







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1585 SymbolLiteral Sym_1 nodes.lkt:2602
Sym_1 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Abstract); 
--# expr-done 1585
--# property-call-start FullDecl.has_annotation
Fld_5 := Liblktlang.Implementation.Full_Decl_P_Has_Annotation (Node => Item_1.Node, Name => Sym_1);
--# end
--# expr-done 1586
Not_Val := not (Fld_5); 
--# expr-done 1587
if Not_Val then
   --# expr-start 1590 Not Not_Val_1 nodes.lkt:2603
--# expr-start 1589 FullDecl.has_annotation Fld_6 nodes.lkt:2603







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1588 SymbolLiteral Sym_2 nodes.lkt:2603
Sym_2 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Null_Field); 
--# expr-done 1588
--# property-call-start FullDecl.has_annotation
Fld_6 := Liblktlang.Implementation.Full_Decl_P_Has_Annotation (Node => Item_1.Node, Name => Sym_2);
--# end
--# expr-done 1589
Not_Val_1 := not (Fld_6); 
--# expr-done 1590
   If_Result := Not_Val_1;
else
   
   If_Result := False;
end if;



--# expr-done 1591
   If_Result_1 := If_Result;
else
   
   If_Result_1 := True;
end if;



--# expr-done 1592
   If_Result_2 := If_Result_1;
else
   
   If_Result_2 := False;
end if;



--# expr-done 1593
         if If_Result_2 then
            
         
      --# expr-start 1595 Cast Cast_Result_1 nodes.lkt:2596





--# expr-start 1594 FullDecl.decl Fld_2 nodes.lkt:2596







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Decl (Node => Item_1.Node.Full_Decl_F_Decl, Info => Item_1.Info);
--# expr-done 1594



   if Fld_2.Node = null
      or else Fld_2.Node.Kind in Lkt_Field_Decl_Range
   then
      
      Cast_Result_1 := Create_Internal_Entity_Field_Decl
        (Node => Fld_2.Node,
         Info => Fld_2.Info);

   else
         Cast_Result_1 := No_Entity_Field_Decl;
   end if;


--# expr-done 1595
      

         declare
            Item_To_Append : constant Internal_Entity_Field_Decl := Cast_Result_1;
         begin
            Internal_Entity_Field_Decl_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
         end if;
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Internal_Entity_Field_Decl_Array
           (Items_Count => Natural (Internal_Entity_Field_Decl_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Field_Decl_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Field_Decl_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Field_Decl_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1596
      

         for Item_To_Append of
               Map_Result.Items
         loop
            Internal_Entity_Field_Decl_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end loop;

   
   
   

            
   --# end
      Finalizer_Scope_653;



         end loop;
      end;
   

   

         Map_Result_1 := Create_Internal_Entity_Field_Decl_Array
           (Items_Count => Natural (Internal_Entity_Field_Decl_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Internal_Entity_Field_Decl_Vectors.Get
              (Map_Result_1_Vec,
               I + Internal_Entity_Field_Decl_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Internal_Entity_Field_Decl_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 1597

         Property_Result := Map_Result_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_242;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_242;
                     Finalizer_Scope_653;




            raise;
      end;



   return Property_Result;
end Class_Decl_P_Constructor_Fields;
--# end

   







--# property-start ClassDecl.function_type_aux nodes.lkt:2611
pragma Warnings (Off, "is not referenced");

function Class_Decl_P_Function_Type_Aux
  
  (Node : Bare_Class_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Function_Type
is
   Self : Bare_Class_Decl :=
     Bare_Class_Decl (Node);
     Ent : Internal_Entity_Class_Decl :=
       Internal_Entity_Class_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Function_Type;

      
            procedure Finalizer_Scope_243 with Inline_Always;

      Fld : Internal_Entity_Field_Decl_Array_Access;
Fld_1 : Internal_Entity_Type_Ref;
Fld_2 : Internal_Entity_Type_Decl;
Map_Result : Internal_Entity_Type_Decl_Array_Access;
Cast_Result : Internal_Entity_Type_Decl;
Cast_Result_1 : Internal_Entity_Decl;
Fld_3 : Internal_Entity_Function_Type;

            procedure Finalizer_Scope_243 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Map_Result);
            end Finalizer_Scope_243;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1602 LktNode.function_type_helper Fld_3 nodes.lkt:2612







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1601 .map Map_Result nodes.lkt:2613








   

   --# expr-start 1598 ClassDecl.constructor_fields Fld nodes.lkt:2613







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start ClassDecl.constructor_fields
Fld := Liblktlang.Implementation.Class_Decl_P_Constructor_Fields (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1598

   
      declare
         Map_Result_Vec : Internal_Entity_Type_Decl_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Field_Decl_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind f Item

            
         
         
      --# expr-start 1600 TypeRef.referenced_decl Fld_2 nodes.lkt:2614



--# expr-start 1599 FieldDecl.decl_type Fld_1 nodes.lkt:2614







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Type_Ref (Node => Item.Node.Field_Decl_F_Decl_Type, Info => Item.Info);
--# expr-done 1599



   if Fld_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_2 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Fld_1.Node, E_Info => Fld_1.Info);
--# end
--# expr-done 1600
      

         declare
            Item_To_Append : constant Internal_Entity_Type_Decl := Fld_2;
         begin
            Internal_Entity_Type_Decl_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Entity_Type_Decl_Array
           (Items_Count => Natural (Internal_Entity_Type_Decl_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Type_Decl_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Type_Decl_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Type_Decl_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1601









   
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => Ent.Node,
         Info => Ent.Info);











   
      Cast_Result_1 := Create_Internal_Entity_Decl
        (Node => Ent.Node,
         Info => Ent.Info);


--# property-call-start LktNode.function_type_helper
Fld_3 := Liblktlang.Implementation.Lkt_Node_P_Function_Type_Helper (Node => Ent.Node, Param_Types => Map_Result, Return_Type => Cast_Result, Origin => Cast_Result_1, E_Info => Ent.Info);
--# end
--# expr-done 1602

         Property_Result := Fld_3;
         
   --# end
      Finalizer_Scope_243;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_243;




            raise;
      end;



   return Property_Result;
end Class_Decl_P_Function_Type_Aux;
--# end



   


      

   --
   --  Primitives for Bare_Enum_Class_Decl
   --

   



   

   

   

   

   

   

   


      procedure Enum_Class_Decl_Pre_Env_Actions
        (Self            : Bare_Enum_Class_Decl;
         State           : in out PLE_Node_State;
         Add_To_Env_Only : Boolean := False) is
      begin
            


   

      declare
         Resolver : constant Entity_Resolver :=
            null;

         

         Mapping : Internal_Env_Assoc :=
            Liblktlang.Implementation.Internal_Env_Mappings_11 (Node => 
Self);
      begin

         Add_To_Env
           (Self,
            State,
            Mapping.Key,
            Mapping.Value,
            Mapping.Metadata,
            Resolver,
            Mapping.Dest_Env,
            DSL_Location => "nodes.lkt:2635:9");
         Dec_Ref (Mapping.Dest_Env);

      end;
   
   
      end;

      procedure Enum_Class_Decl_Post_Env_Actions
        (Self : Bare_Enum_Class_Decl; State : in out PLE_Node_State) is
      begin
            


   

      declare
         Resolver : constant Entity_Resolver :=
            null;

         

         Mappings : Internal_Env_Assoc_Array_Access :=
            Liblktlang.Implementation.Internal_Env_Mappings_12 (Node => 
Self);
      begin
         for Mapping of Mappings.Items loop

         Add_To_Env
           (Self,
            State,
            Mapping.Key,
            Mapping.Value,
            Mapping.Metadata,
            Resolver,
            Mapping.Dest_Env,
            DSL_Location => "nodes.lkt:2637:9");

         end loop;
         Dec_Ref (Mappings);
      end;
   
   
      end;


      
      procedure Initialize_Fields_For_Enum_Class_Decl
        (Self : Bare_Enum_Class_Decl
         ; Basic_Class_Decl_F_Syn_Name : Bare_Def_Id
         ; Basic_Class_Decl_F_Syn_Base_Type : Bare_Type_Ref
         ; Basic_Class_Decl_F_Traits : Bare_Type_Ref_List
         ; Enum_Class_Decl_F_Branches : Bare_Enum_Class_Case_List
         ; Enum_Class_Decl_F_Decls : Bare_Decl_Block
        ) is
      begin
            Initialize_Fields_For_Basic_Class_Decl
              (Self, Basic_Class_Decl_F_Syn_Name, Basic_Class_Decl_F_Syn_Base_Type, Basic_Class_Decl_F_Traits);

            Self.Enum_Class_Decl_F_Branches := Enum_Class_Decl_F_Branches;
            Self.Enum_Class_Decl_F_Decls := Enum_Class_Decl_F_Decls;
         

      end Initialize_Fields_For_Enum_Class_Decl;

      
   function Enum_Class_Decl_F_Branches
     (Node : Bare_Enum_Class_Decl) return Bare_Enum_Class_Case_List
   is
      

   begin
         
         return Node.Enum_Class_Decl_F_Branches;
      
   end;


   







--# property-start EnumClassDecl.decl_type_name nodes.lkt:2629
pragma Warnings (Off, "is not referenced");

function Enum_Class_Decl_P_Decl_Type_Name
  
  (Node : Bare_Enum_Class_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Enum_Class_Decl :=
     Bare_Enum_Class_Decl (Node);
     Ent : Internal_Entity_Enum_Class_Decl :=
       Internal_Entity_Enum_Class_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_244 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_244 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_244;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1603 StringLiteral Str nodes.lkt:2629
Str := Create_String ("enum class declaration"); 
--# expr-done 1603

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_244;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_244;




            raise;
      end;



   return Property_Result;
end Enum_Class_Decl_P_Decl_Type_Name;
--# end

   







--# property-start EnumClassDecl.alts nodes.lkt:2631
pragma Warnings (Off, "is not referenced");

function Enum_Class_Decl_P_Alts
  
  (Node : Bare_Enum_Class_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Enum_Class_Alt_Decl_Array_Access
is
   Self : Bare_Enum_Class_Decl :=
     Bare_Enum_Class_Decl (Node);
     Ent : Internal_Entity_Enum_Class_Decl :=
       Internal_Entity_Enum_Class_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Enum_Class_Alt_Decl_Array_Access;

      
            procedure Finalizer_Scope_246 with Inline_Always;
            procedure Finalizer_Scope_656 with Inline_Always;

      Fld : Internal_Entity_Enum_Class_Case_List;
Item : Internal_Entity_Enum_Class_Case;
Fld_1 : Internal_Entity_Enum_Class_Alt_Decl_List;
Item_1 : Internal_Entity_Enum_Class_Alt_Decl;
Fld_2 : Bare_Enum_Class_Alt_Decl_List;
Fld_3 : Internal_Entity_Info;
Bare_Item_1 : Bare_Enum_Class_Alt_Decl;
As_Entity : Internal_Entity_Enum_Class_Alt_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Enum_Class_Alt_Decl;
Map_Result : Internal_Entity_Enum_Class_Alt_Decl_Array_Access;
Fld_4 : Bare_Enum_Class_Case_List;
Fld_5 : Internal_Entity_Info;
Bare_Item : Bare_Enum_Class_Case;
As_Entity_1 : Internal_Entity_Enum_Class_Case;
Is_Null_1 : Boolean;
If_Result_1 : Internal_Entity_Enum_Class_Case;
Map_Result_1 : Internal_Entity_Enum_Class_Alt_Decl_Array_Access;

            procedure Finalizer_Scope_246 is
            begin
                     Dec_Ref (Map_Result_1);
            end Finalizer_Scope_246;
            procedure Finalizer_Scope_656 is
            begin
                     Dec_Ref (Map_Result);
            end Finalizer_Scope_656;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1607 .mapcat Map_Result_1 nodes.lkt:2632








   

   --# expr-start 1604 EnumClassDecl.branches Fld nodes.lkt:2632







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Enum_Class_Case_List (Node => Ent.Node.Enum_Class_Decl_F_Branches, Info => Ent.Info);
--# expr-done 1604









Fld_4 := Fld.Node;

   
      declare
         Map_Result_1_Vec : Internal_Entity_Enum_Class_Alt_Decl_Vectors.Vector;
      begin
   

   

      if Fld_4 = null then
         
      Map_Result_1 := Create_Internal_Entity_Enum_Class_Alt_Decl_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Enum_Class_Case_List := Fld_4;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null_1 := Bare_Item = null; 
if Is_Null_1 then
   
   If_Result_1 := No_Entity_Enum_Class_Case;
else
   








Fld_5 := Fld.Info;

As_Entity_1 := (Info => Fld_5, Node => Bare_Item); 
   If_Result_1 := As_Entity_1;
end if;



                  Item := If_Result_1; 

            
   --# scope-start


               --# bind branch Item

            
         
         
      --# expr-start 1606 .map Map_Result nodes.lkt:2632








   

   --# expr-start 1605 EnumClassCase.decls Fld_1 nodes.lkt:2632







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Enum_Class_Alt_Decl_List (Node => Item.Node.Enum_Class_Case_F_Decls, Info => Item.Info);
--# expr-done 1605









Fld_2 := Fld_1.Node;

   
      declare
         Map_Result_Vec : Internal_Entity_Enum_Class_Alt_Decl_Vectors.Vector;
      begin
   

   

      if Fld_2 = null then
         
      Map_Result := Create_Internal_Entity_Enum_Class_Alt_Decl_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Enum_Class_Alt_Decl_List := Fld_2;
      begin
         for Untyped_Item_1 of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item_1 := Untyped_Item_1; 
                  



Is_Null := Bare_Item_1 = null; 
if Is_Null then
   
   If_Result := No_Entity_Enum_Class_Alt_Decl;
else
   








Fld_3 := Fld_1.Info;

As_Entity := (Info => Fld_3, Node => Bare_Item_1); 
   If_Result := As_Entity;
end if;



                  Item_1 := If_Result; 

            
   --# scope-start


               --# bind d Item_1

            
         
         
      
      

         declare
            Item_To_Append : constant Internal_Entity_Enum_Class_Alt_Decl := Item_1;
         begin
            Internal_Entity_Enum_Class_Alt_Decl_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Internal_Entity_Enum_Class_Alt_Decl_Array
           (Items_Count => Natural (Internal_Entity_Enum_Class_Alt_Decl_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Enum_Class_Alt_Decl_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Enum_Class_Alt_Decl_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Enum_Class_Alt_Decl_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1606
      

         for Item_To_Append of
               Map_Result.Items
         loop
            Internal_Entity_Enum_Class_Alt_Decl_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end loop;

   
   
   

            
   --# end
      Finalizer_Scope_656;



         end loop;
      end;
   
      end if;

   

         Map_Result_1 := Create_Internal_Entity_Enum_Class_Alt_Decl_Array
           (Items_Count => Natural (Internal_Entity_Enum_Class_Alt_Decl_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Internal_Entity_Enum_Class_Alt_Decl_Vectors.Get
              (Map_Result_1_Vec,
               I + Internal_Entity_Enum_Class_Alt_Decl_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Internal_Entity_Enum_Class_Alt_Decl_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 1607

         Property_Result := Map_Result_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_246;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_246;
                     Finalizer_Scope_656;




            raise;
      end;



   return Property_Result;
end Enum_Class_Decl_P_Alts;
--# end

   







--# property-start 'EnumClassDecl.[internal]internal_env_mappings_11' nodes.lkt:2635
pragma Warnings (Off, "is not referenced");

function Internal_Env_Mappings_11
  
  (Node : Bare_Enum_Class_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Env_Assoc
is
   Self : Bare_Enum_Class_Decl :=
     Bare_Enum_Class_Decl (Node);
     Ent : Internal_Entity_Enum_Class_Decl :=
       Internal_Entity_Enum_Class_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Env_Assoc;

      
            procedure Finalizer_Scope_435 with Inline_Always;

      Fld : Symbol_Type;
Cast_Result : Bare_Lkt_Node;
New_Struct : Internal_Designated_Env := No_Designated_Env;
New_Struct_1 : Internal_Env_Assoc := No_Env_Assoc;

            procedure Finalizer_Scope_435 is
            begin
                     Dec_Ref (New_Struct);
                     Dec_Ref (New_Struct_1);
            end Finalizer_Scope_435;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         


Inc_Ref (Empty_Env);
New_Struct := (Direct_Env => Empty_Env, Env_Name => No_Symbol, Kind => Current_Env); 
--# expr-start 1608 Decl.name Fld nodes.lkt:2635







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Ent.Node);
--# end
--# expr-done 1608










   
      Cast_Result := Self;


Inc_Ref (New_Struct);
New_Struct_1 := (Dest_Env => New_Struct, Key => Fld, Metadata => No_Metadata, Value => Cast_Result); 

         Property_Result := New_Struct_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_435;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_435;




            raise;
      end;



   return Property_Result;
end Internal_Env_Mappings_11;
--# end

   







--# property-start 'EnumClassDecl.[internal]internal_env_mappings_12' nodes.lkt:2638
pragma Warnings (Off, "is not referenced");

function Internal_Env_Mappings_12
  
  (Node : Bare_Enum_Class_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Env_Assoc_Array_Access
is
   Self : Bare_Enum_Class_Decl :=
     Bare_Enum_Class_Decl (Node);
     Ent : Internal_Entity_Enum_Class_Decl :=
       Internal_Entity_Enum_Class_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Env_Assoc_Array_Access;

      
            procedure Finalizer_Scope_436 with Inline_Always;
            procedure Finalizer_Scope_868 with Inline_Always;

      Fld : Internal_Entity_Enum_Class_Alt_Decl_Array_Access;
Fld_1 : Symbol_Type;
Fld_2 : Bare_Enum_Class_Alt_Decl;
Fld_3 : Bare_Decl_Block;
Fld_4 : Lexical_Env := Empty_Env;
New_Struct : Internal_Designated_Env := No_Designated_Env;
Cast_Result : Bare_Lkt_Node;
New_Struct_1 : Internal_Env_Assoc := No_Env_Assoc;
Map_Result : Internal_Env_Assoc_Array_Access;
Fld_5 : Internal_Entity_Full_Decl;
Sym : Symbol_Type;
Fld_6 : Boolean;
Sym_1 : Symbol_Type;
Array_Lit : Internal_Entity_Type_Decl_Array_Access;
Fld_7 : Internal_Entity_Named_Type_Decl;
Cast_Result_1 : Internal_Entity_Type_Decl;
Fld_8 : Internal_Entity_Function_Type;
Fld_9 : Bare_Function_Type;
Fld_10 : Bare_Decl_Block;
Fld_11 : Lexical_Env := Empty_Env;
New_Struct_2 : Internal_Designated_Env := No_Designated_Env;
Cast_Result_2 : Bare_Lkt_Node;
New_Struct_3 : Internal_Env_Assoc := No_Env_Assoc;
Array_Lit_1 : Internal_Env_Assoc_Array_Access;
If_Result : Internal_Env_Assoc_Array_Access;
Concat_Result : Internal_Env_Assoc_Array_Access;

            procedure Finalizer_Scope_436 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Fld_11);
                     Dec_Ref (New_Struct_2);
                     Dec_Ref (New_Struct_3);
                     Dec_Ref (Array_Lit_1);
                     Dec_Ref (If_Result);
                     Dec_Ref (Concat_Result);
            end Finalizer_Scope_436;
            procedure Finalizer_Scope_868 is
            begin
                     Dec_Ref (Fld_4);
                     Dec_Ref (New_Struct);
                     Dec_Ref (New_Struct_1);
            end Finalizer_Scope_868;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1631 ArrayConcat Concat_Result nodes.lkt:2638
--# expr-start 1616 .map Map_Result nodes.lkt:2638








   

   --# expr-start 1609 EnumClassDecl.alts Fld nodes.lkt:2638







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start EnumClassDecl.alts
Fld := Liblktlang.Implementation.Enum_Class_Decl_P_Alts (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1609

   
      declare
         Map_Result_Vec : Internal_Env_Assoc_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Enum_Class_Alt_Decl_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind alt Item

            
         
         
      --# expr-start 1615 'New[EnvAssoc]' New_Struct_1 nodes.lkt:2640
--# expr-start 1612 'New[DesignatedEnv]' New_Struct nodes.lkt:2643
--# expr-start 1611 LktNode.children_env Fld_4 nodes.lkt:2646



--# expr-start 1610 EnumClassDecl.decls Fld_3 nodes.lkt:2646







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Self.Enum_Class_Decl_F_Decls;
--# expr-done 1610



   if Fld_3 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Liblktlang.Implementation.Children_Env (Node => Fld_3);
--# expr-done 1611


Inc_Ref (Fld_4);
New_Struct := (Direct_Env => Fld_4, Env_Name => No_Symbol, Kind => Direct_Env); 
--# expr-done 1612
--# expr-start 1613 Decl.name Fld_1 nodes.lkt:2641







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_1 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Item.Node);
--# end
--# expr-done 1613






--# expr-start 1614 'Entity[EnumClassAltDecl].node' Fld_2 nodes.lkt:2642









Fld_2 := Item.Node;
--# expr-done 1614



   
      Cast_Result := Fld_2;


Inc_Ref (New_Struct);
New_Struct_1 := (Dest_Env => New_Struct, Key => Fld_1, Metadata => No_Metadata, Value => Cast_Result); 
--# expr-done 1615
      

         declare
            Item_To_Append : constant Internal_Env_Assoc := New_Struct_1;
         begin
               Inc_Ref (Item_To_Append);
            Internal_Env_Assoc_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_868;



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Env_Assoc_Array
           (Items_Count => Natural (Internal_Env_Assoc_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Env_Assoc_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Env_Assoc_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Env_Assoc_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1616
--# expr-start 1630 If If_Result nodes.lkt:2652



--# expr-start 1619 FullDecl.has_annotation Fld_6 nodes.lkt:2652



--# expr-start 1617 Decl.full_decl Fld_5 nodes.lkt:2652







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.full_decl
Fld_5 := Liblktlang.Implementation.Decl_P_Full_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1617



   if Fld_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1618 SymbolLiteral Sym nodes.lkt:2652
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Qualifier); 
--# expr-done 1618
--# property-call-start FullDecl.has_annotation
Fld_6 := Liblktlang.Implementation.Full_Decl_P_Has_Annotation (Node => Fld_5.Node, Name => Sym);
--# end
--# expr-done 1619
if Fld_6 then
   --# expr-start 1629 ArrayLiteral Array_Lit_1 nodes.lkt:2654
--# expr-start 1628 'New[EnvAssoc]' New_Struct_3 nodes.lkt:2655
--# expr-start 1622 'New[DesignatedEnv]' New_Struct_2 nodes.lkt:2663
--# expr-start 1621 LktNode.children_env Fld_11 nodes.lkt:2666



--# expr-start 1620 EnumClassDecl.decls Fld_10 nodes.lkt:2666







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Self.Enum_Class_Decl_F_Decls;
--# expr-done 1620



   if Fld_10 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Liblktlang.Implementation.Children_Env (Node => Fld_10);
--# expr-done 1621


Inc_Ref (Fld_11);
New_Struct_2 := (Direct_Env => Fld_11, Env_Name => No_Symbol, Kind => Direct_Env); 
--# expr-done 1622
--# expr-start 1623 SymbolLiteral Sym_1 nodes.lkt:2656
Sym_1 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_As_Bool); 
--# expr-done 1623






--# expr-start 1627 'Entity[FunctionType].node' Fld_9 nodes.lkt:2657



--# expr-start 1626 LktNode.function_type_helper Fld_8 nodes.lkt:2657







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1624 ArrayLiteral Array_Lit nodes.lkt:2658
Array_Lit := Create_Internal_Entity_Type_Decl_Array (Items_Count => 0); 
--# expr-done 1624





--# expr-start 1625 LktNode.bool_type Fld_7 nodes.lkt:2659







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.bool_type
Fld_7 := Liblktlang.Implementation.Lkt_Node_P_Bool_Type (Node => Self);
--# end
--# expr-done 1625



   
      Cast_Result_1 := Create_Internal_Entity_Type_Decl
        (Node => Fld_7.Node,
         Info => Fld_7.Info);



--# property-call-start LktNode.function_type_helper
Fld_8 := Liblktlang.Implementation.Lkt_Node_P_Function_Type_Helper (Node => Ent.Node, Param_Types => Array_Lit, Return_Type => Cast_Result_1, Origin => No_Entity_Decl, E_Info => Ent.Info);
--# end
--# expr-done 1626





Fld_9 := Fld_8.Node;
--# expr-done 1627



   
      Cast_Result_2 := Fld_9;


Inc_Ref (New_Struct_2);
New_Struct_3 := (Dest_Env => New_Struct_2, Key => Sym_1, Metadata => No_Metadata, Value => Cast_Result_2); 
--# expr-done 1628
Array_Lit_1 := Create_Internal_Env_Assoc_Array (Internal_Internal_Env_Assoc_Array'(1 => New_Struct_3)); 
--# expr-done 1629
   If_Result := Array_Lit_1;
else
   
   If_Result := No_Internal_Env_Assoc_Array_Type;
end if;

      Inc_Ref (If_Result);


--# expr-done 1630
Concat_Result := Concat (Map_Result, If_Result); 
--# expr-done 1631

         Property_Result := Concat_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_436;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_436;
                     Finalizer_Scope_868;




            raise;
      end;



   return Property_Result;
end Internal_Env_Mappings_12;
--# end



   


      

   --
   --  Primitives for Bare_Enum_Type_Decl
   --

   



   

   

   

   

   

   

   


      procedure Enum_Type_Decl_Pre_Env_Actions
        (Self            : Bare_Enum_Type_Decl;
         State           : in out PLE_Node_State;
         Add_To_Env_Only : Boolean := False) is
      begin
            


   

      declare
         Resolver : constant Entity_Resolver :=
            null;

         

         Mapping : Internal_Env_Assoc :=
            Liblktlang.Implementation.Internal_Env_Mappings_13 (Node => 
Self);
      begin

         Add_To_Env
           (Self,
            State,
            Mapping.Key,
            Mapping.Value,
            Mapping.Metadata,
            Resolver,
            Mapping.Dest_Env,
            DSL_Location => "nodes.lkt:2694:9");
         Dec_Ref (Mapping.Dest_Env);

      end;
   
   
      end;

      procedure Enum_Type_Decl_Post_Env_Actions
        (Self : Bare_Enum_Type_Decl; State : in out PLE_Node_State) is
      begin
            


   

      declare
         Resolver : constant Entity_Resolver :=
            null;

         

         Mappings : Internal_Env_Assoc_Array_Access :=
            Liblktlang.Implementation.Internal_Env_Mappings_14 (Node => 
Self);
      begin
         for Mapping of Mappings.Items loop

         Add_To_Env
           (Self,
            State,
            Mapping.Key,
            Mapping.Value,
            Mapping.Metadata,
            Resolver,
            Mapping.Dest_Env,
            DSL_Location => "nodes.lkt:2697:9");

         end loop;
         Dec_Ref (Mappings);
      end;
   
   
            


   

      declare
         Resolver : constant Entity_Resolver :=
            null;

         

         Mappings : Internal_Env_Assoc_Array_Access :=
            Liblktlang.Implementation.Internal_Env_Mappings_15 (Node => 
Self);
      begin
         for Mapping of Mappings.Items loop

         Add_To_Env
           (Self,
            State,
            Mapping.Key,
            Mapping.Value,
            Mapping.Metadata,
            Resolver,
            Mapping.Dest_Env,
            DSL_Location => "nodes.lkt:2714:9");

         end loop;
         Dec_Ref (Mappings);
      end;
   
   
      end;


      
      procedure Initialize_Fields_For_Enum_Type_Decl
        (Self : Bare_Enum_Type_Decl
         ; Enum_Type_Decl_F_Syn_Name : Bare_Def_Id
         ; Enum_Type_Decl_F_Traits : Bare_Type_Ref_List
         ; Enum_Type_Decl_F_Literals : Bare_Enum_Lit_Decl_List
         ; Enum_Type_Decl_F_Decls : Bare_Decl_Block
        ) is
      begin

            Self.Enum_Type_Decl_F_Syn_Name := Enum_Type_Decl_F_Syn_Name;
            Self.Enum_Type_Decl_F_Traits := Enum_Type_Decl_F_Traits;
            Self.Enum_Type_Decl_F_Literals := Enum_Type_Decl_F_Literals;
            Self.Enum_Type_Decl_F_Decls := Enum_Type_Decl_F_Decls;
         

      end Initialize_Fields_For_Enum_Type_Decl;

      
   function Enum_Type_Decl_F_Literals
     (Node : Bare_Enum_Type_Decl) return Bare_Enum_Lit_Decl_List
   is
      

   begin
         
         return Node.Enum_Type_Decl_F_Literals;
      
   end;


   







--# property-start EnumTypeDecl.decl_type_name nodes.lkt:2691
pragma Warnings (Off, "is not referenced");

function Enum_Type_Decl_P_Decl_Type_Name
  
  (Node : Bare_Enum_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Enum_Type_Decl :=
     Bare_Enum_Type_Decl (Node);
     Ent : Internal_Entity_Enum_Type_Decl :=
       Internal_Entity_Enum_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_247 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_247 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_247;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1632 StringLiteral Str nodes.lkt:2691
Str := Create_String ("enum declaration"); 
--# expr-done 1632

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_247;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_247;




            raise;
      end;



   return Property_Result;
end Enum_Type_Decl_P_Decl_Type_Name;
--# end

   







--# property-start 'EnumTypeDecl.[internal]internal_env_mappings_13' nodes.lkt:2694
pragma Warnings (Off, "is not referenced");

function Internal_Env_Mappings_13
  
  (Node : Bare_Enum_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Env_Assoc
is
   Self : Bare_Enum_Type_Decl :=
     Bare_Enum_Type_Decl (Node);
     Ent : Internal_Entity_Enum_Type_Decl :=
       Internal_Entity_Enum_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Env_Assoc;

      
            procedure Finalizer_Scope_438 with Inline_Always;

      Fld : Symbol_Type;
Cast_Result : Bare_Lkt_Node;
New_Struct : Internal_Designated_Env := No_Designated_Env;
New_Struct_1 : Internal_Env_Assoc := No_Env_Assoc;

            procedure Finalizer_Scope_438 is
            begin
                     Dec_Ref (New_Struct);
                     Dec_Ref (New_Struct_1);
            end Finalizer_Scope_438;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         


Inc_Ref (Empty_Env);
New_Struct := (Direct_Env => Empty_Env, Env_Name => No_Symbol, Kind => Current_Env); 
--# expr-start 1633 Decl.name Fld nodes.lkt:2694







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Ent.Node);
--# end
--# expr-done 1633










   
      Cast_Result := Self;


Inc_Ref (New_Struct);
New_Struct_1 := (Dest_Env => New_Struct, Key => Fld, Metadata => No_Metadata, Value => Cast_Result); 

         Property_Result := New_Struct_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_438;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_438;




            raise;
      end;



   return Property_Result;
end Internal_Env_Mappings_13;
--# end

   







--# property-start 'EnumTypeDecl.[internal]internal_env_mappings_14' nodes.lkt:2698
pragma Warnings (Off, "is not referenced");

function Internal_Env_Mappings_14
  
  (Node : Bare_Enum_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Env_Assoc_Array_Access
is
   Self : Bare_Enum_Type_Decl :=
     Bare_Enum_Type_Decl (Node);
     Ent : Internal_Entity_Enum_Type_Decl :=
       Internal_Entity_Enum_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Env_Assoc_Array_Access;

      
            procedure Finalizer_Scope_439 with Inline_Always;
            procedure Finalizer_Scope_869 with Inline_Always;

      Fld : Internal_Entity_Enum_Lit_Decl_List;
Item : Internal_Entity_Enum_Lit_Decl;
Fld_1 : Symbol_Type;
Fld_2 : Bare_Enum_Lit_Decl;
Fld_3 : Bare_Decl_Block;
Fld_4 : Lexical_Env := Empty_Env;
New_Struct : Internal_Designated_Env := No_Designated_Env;
Cast_Result : Bare_Lkt_Node;
New_Struct_1 : Internal_Env_Assoc := No_Env_Assoc;
Fld_5 : Bare_Enum_Lit_Decl_List;
Fld_6 : Internal_Entity_Info;
Bare_Item : Bare_Enum_Lit_Decl;
As_Entity : Internal_Entity_Enum_Lit_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Enum_Lit_Decl;
Map_Result : Internal_Env_Assoc_Array_Access;

            procedure Finalizer_Scope_439 is
            begin
                     Dec_Ref (Map_Result);
            end Finalizer_Scope_439;
            procedure Finalizer_Scope_869 is
            begin
                     Dec_Ref (Fld_4);
                     Dec_Ref (New_Struct);
                     Dec_Ref (New_Struct_1);
            end Finalizer_Scope_869;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1641 .map Map_Result nodes.lkt:2698








   

   --# expr-start 1634 EnumTypeDecl.literals Fld nodes.lkt:2698







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Enum_Lit_Decl_List (Node => Ent.Node.Enum_Type_Decl_F_Literals, Info => Ent.Info);
--# expr-done 1634









Fld_5 := Fld.Node;

   
      declare
         Map_Result_Vec : Internal_Env_Assoc_Vectors.Vector;
      begin
   

   

      if Fld_5 = null then
         
      Map_Result := Create_Internal_Env_Assoc_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Enum_Lit_Decl_List := Fld_5;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Enum_Lit_Decl;
else
   








Fld_6 := Fld.Info;

As_Entity := (Info => Fld_6, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind lit Item

            
         
         
      --# expr-start 1640 'New[EnvAssoc]' New_Struct_1 nodes.lkt:2700
--# expr-start 1637 'New[DesignatedEnv]' New_Struct nodes.lkt:2703
--# expr-start 1636 LktNode.children_env Fld_4 nodes.lkt:2706



--# expr-start 1635 EnumTypeDecl.decls Fld_3 nodes.lkt:2706







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Self.Enum_Type_Decl_F_Decls;
--# expr-done 1635



   if Fld_3 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Liblktlang.Implementation.Children_Env (Node => Fld_3);
--# expr-done 1636


Inc_Ref (Fld_4);
New_Struct := (Direct_Env => Fld_4, Env_Name => No_Symbol, Kind => Direct_Env); 
--# expr-done 1637
--# expr-start 1638 Decl.name Fld_1 nodes.lkt:2701







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_1 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Item.Node);
--# end
--# expr-done 1638






--# expr-start 1639 'Entity[EnumLitDecl].node' Fld_2 nodes.lkt:2702









Fld_2 := Item.Node;
--# expr-done 1639



   
      Cast_Result := Fld_2;


Inc_Ref (New_Struct);
New_Struct_1 := (Dest_Env => New_Struct, Key => Fld_1, Metadata => No_Metadata, Value => Cast_Result); 
--# expr-done 1640
      

         declare
            Item_To_Append : constant Internal_Env_Assoc := New_Struct_1;
         begin
               Inc_Ref (Item_To_Append);
            Internal_Env_Assoc_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_869;



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Internal_Env_Assoc_Array
           (Items_Count => Natural (Internal_Env_Assoc_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Env_Assoc_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Env_Assoc_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Env_Assoc_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1641

         Property_Result := Map_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_439;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_439;
                     Finalizer_Scope_869;




            raise;
      end;



   return Property_Result;
end Internal_Env_Mappings_14;
--# end

   







--# property-start 'EnumTypeDecl.[internal]internal_env_mappings_15' nodes.lkt:2715
pragma Warnings (Off, "is not referenced");

function Internal_Env_Mappings_15
  
  (Node : Bare_Enum_Type_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Env_Assoc_Array_Access
is
   Self : Bare_Enum_Type_Decl :=
     Bare_Enum_Type_Decl (Node);
     Ent : Internal_Entity_Enum_Type_Decl :=
       Internal_Entity_Enum_Type_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Env_Assoc_Array_Access;

      
            procedure Finalizer_Scope_440 with Inline_Always;
            procedure Finalizer_Scope_870 with Inline_Always;

      Fld : Internal_Entity_Full_Decl;
Sym : Symbol_Type;
Fld_1 : Boolean;
Fld_2 : Internal_Entity_Enum_Lit_Decl_List;
Item : Internal_Entity_Enum_Lit_Decl;
Fld_3 : Symbol_Type;
Fld_4 : Bare_Enum_Lit_Decl;
Fld_5 : Lexical_Env := Empty_Env;
New_Struct : Internal_Designated_Env := No_Designated_Env;
Cast_Result : Bare_Lkt_Node;
New_Struct_1 : Internal_Env_Assoc := No_Env_Assoc;
Fld_6 : Bare_Enum_Lit_Decl_List;
Fld_7 : Internal_Entity_Info;
Bare_Item : Bare_Enum_Lit_Decl;
As_Entity : Internal_Entity_Enum_Lit_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Enum_Lit_Decl;
Map_Result : Internal_Env_Assoc_Array_Access;
If_Result_1 : Internal_Env_Assoc_Array_Access;

            procedure Finalizer_Scope_440 is
            begin
                     Dec_Ref (Map_Result);
                     Dec_Ref (If_Result_1);
            end Finalizer_Scope_440;
            procedure Finalizer_Scope_870 is
            begin
                     Dec_Ref (Fld_5);
                     Dec_Ref (New_Struct);
                     Dec_Ref (New_Struct_1);
            end Finalizer_Scope_870;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1652 If If_Result_1 nodes.lkt:2715



--# expr-start 1644 FullDecl.has_annotation Fld_1 nodes.lkt:2715



--# expr-start 1642 Decl.full_decl Fld nodes.lkt:2715







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.full_decl
Fld := Liblktlang.Implementation.Decl_P_Full_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1642



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1643 SymbolLiteral Sym nodes.lkt:2715
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Open); 
--# expr-done 1643
--# property-call-start FullDecl.has_annotation
Fld_1 := Liblktlang.Implementation.Full_Decl_P_Has_Annotation (Node => Fld.Node, Name => Sym);
--# end
--# expr-done 1644
if Fld_1 then
   --# expr-start 1651 .map Map_Result nodes.lkt:2717








   

   --# expr-start 1645 EnumTypeDecl.literals Fld_2 nodes.lkt:2717







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Enum_Lit_Decl_List (Node => Ent.Node.Enum_Type_Decl_F_Literals, Info => Ent.Info);
--# expr-done 1645









Fld_6 := Fld_2.Node;

   
      declare
         Map_Result_Vec : Internal_Env_Assoc_Vectors.Vector;
      begin
   

   

      if Fld_6 = null then
         
      Map_Result := Create_Internal_Env_Assoc_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Enum_Lit_Decl_List := Fld_6;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Enum_Lit_Decl;
else
   








Fld_7 := Fld_2.Info;

As_Entity := (Info => Fld_7, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind lit Item

            
         
         
      --# expr-start 1650 'New[EnvAssoc]' New_Struct_1 nodes.lkt:2719
--# expr-start 1647 'New[DesignatedEnv]' New_Struct nodes.lkt:2722
--# expr-start 1646 LktNode.node_env Fld_5 nodes.lkt:2725







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Liblktlang.Implementation.Node_Env (Node => Self);
--# expr-done 1646


Inc_Ref (Fld_5);
New_Struct := (Direct_Env => Fld_5, Env_Name => No_Symbol, Kind => Direct_Env); 
--# expr-done 1647
--# expr-start 1648 Decl.name Fld_3 nodes.lkt:2720







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_3 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Item.Node);
--# end
--# expr-done 1648






--# expr-start 1649 'Entity[EnumLitDecl].node' Fld_4 nodes.lkt:2721









Fld_4 := Item.Node;
--# expr-done 1649



   
      Cast_Result := Fld_4;


Inc_Ref (New_Struct);
New_Struct_1 := (Dest_Env => New_Struct, Key => Fld_3, Metadata => No_Metadata, Value => Cast_Result); 
--# expr-done 1650
      

         declare
            Item_To_Append : constant Internal_Env_Assoc := New_Struct_1;
         begin
               Inc_Ref (Item_To_Append);
            Internal_Env_Assoc_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_870;



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Internal_Env_Assoc_Array
           (Items_Count => Natural (Internal_Env_Assoc_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Env_Assoc_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Env_Assoc_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Env_Assoc_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1651
   If_Result_1 := Map_Result;
else
   
   If_Result_1 := No_Internal_Env_Assoc_Array_Type;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 1652

         Property_Result := If_Result_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_440;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_440;
                     Finalizer_Scope_870;




            raise;
      end;



   return Property_Result;
end Internal_Env_Mappings_15;
--# end



   


      

   --
   --  Primitives for Bare_Struct_Decl
   --

   



      
      procedure Initialize_Fields_For_Struct_Decl
        (Self : Bare_Struct_Decl
         ; Struct_Decl_F_Syn_Name : Bare_Def_Id
         ; Struct_Decl_F_Traits : Bare_Type_Ref_List
         ; Struct_Decl_F_Decls : Bare_Decl_Block
        ) is
      begin

            Self.Struct_Decl_F_Syn_Name := Struct_Decl_F_Syn_Name;
            Self.Struct_Decl_F_Traits := Struct_Decl_F_Traits;
            Self.Struct_Decl_F_Decls := Struct_Decl_F_Decls;
         

      end Initialize_Fields_For_Struct_Decl;


   







--# property-start StructDecl.decl_type_name nodes.lkt:2747
pragma Warnings (Off, "is not referenced");

function Struct_Decl_P_Decl_Type_Name
  
  (Node : Bare_Struct_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Struct_Decl :=
     Bare_Struct_Decl (Node);
     Ent : Internal_Entity_Struct_Decl :=
       Internal_Entity_Struct_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_248 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_248 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_248;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1653 StringLiteral Str nodes.lkt:2747
Str := Create_String ("struct declaration"); 
--# expr-done 1653

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_248;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_248;




            raise;
      end;



   return Property_Result;
end Struct_Decl_P_Decl_Type_Name;
--# end

   







--# property-start StructDecl.function_type_aux nodes.lkt:2750
pragma Warnings (Off, "is not referenced");

function Struct_Decl_P_Function_Type_Aux
  
  (Node : Bare_Struct_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Function_Type
is
   Self : Bare_Struct_Decl :=
     Bare_Struct_Decl (Node);
     Ent : Internal_Entity_Struct_Decl :=
       Internal_Entity_Struct_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Function_Type;

      
            procedure Finalizer_Scope_249 with Inline_Always;

      Fld : Internal_Entity_Decl_Block;
Item : Internal_Entity_Full_Decl;
Fld_1 : Internal_Entity_Decl;
Is_A : Boolean;
Fld_2 : Bare_Decl_Block;
Fld_3 : Internal_Entity_Info;
Bare_Item : Bare_Full_Decl;
As_Entity : Internal_Entity_Full_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Full_Decl;
Map_Result : Internal_Entity_Full_Decl_Array_Access;
Fld_4 : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Field_Decl;
Fld_5 : Internal_Entity_Type_Ref;
Fld_6 : Internal_Entity_Type_Decl;
Map_Result_1 : Internal_Entity_Type_Decl_Array_Access;
Cast_Result_1 : Internal_Entity_Type_Decl;
Cast_Result_2 : Internal_Entity_Decl;
Fld_7 : Internal_Entity_Function_Type;

            procedure Finalizer_Scope_249 is
            begin
                     Dec_Ref (Map_Result);
                     Dec_Ref (Map_Result_1);
            end Finalizer_Scope_249;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1663 LktNode.function_type_helper Fld_7 nodes.lkt:2751







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1662 .map Map_Result_1 nodes.lkt:2752








   

   --# expr-start 1657 .filter Map_Result nodes.lkt:2752








   

   --# expr-start 1654 StructDecl.decls Fld nodes.lkt:2752







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Decl_Block (Node => Ent.Node.Struct_Decl_F_Decls, Info => Ent.Info);
--# expr-done 1654









Fld_2 := Fld.Node;

   
      declare
         Map_Result_Vec : Internal_Entity_Full_Decl_Vectors.Vector;
      begin
   

   

      if Fld_2 = null then
         
      Map_Result := Create_Internal_Entity_Full_Decl_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Decl_Block := Fld_2;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Full_Decl;
else
   








Fld_3 := Fld.Info;

As_Entity := (Info => Fld_3, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind d Item

            
         --# expr-start 1656 IsA Is_A nodes.lkt:2752
--# expr-start 1655 FullDecl.decl Fld_1 nodes.lkt:2752







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Decl (Node => Item.Node.Full_Decl_F_Decl, Info => Item.Info);
--# expr-done 1655
Is_A := Fld_1.Node /= null 
and then Fld_1.Node.Kind in Lkt_Field_Decl_Range; 
--# expr-done 1656
         if Is_A then
            
         
      
      

         declare
            Item_To_Append : constant Internal_Entity_Full_Decl := Item;
         begin
            Internal_Entity_Full_Decl_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
         end if;
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Internal_Entity_Full_Decl_Array
           (Items_Count => Natural (Internal_Entity_Full_Decl_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Full_Decl_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Full_Decl_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Full_Decl_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1657

   
      declare
         Map_Result_1_Vec : Internal_Entity_Type_Decl_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Full_Decl_Array_Access := Map_Result;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind a Item_1

            
         
         
      --# expr-start 1661 TypeRef.referenced_decl Fld_6 nodes.lkt:2753



--# expr-start 1660 FieldDecl.decl_type Fld_5 nodes.lkt:2753



--# expr-start 1659 Cast Cast_Result nodes.lkt:2753





--# expr-start 1658 FullDecl.decl Fld_4 nodes.lkt:2753







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Decl (Node => Item_1.Node.Full_Decl_F_Decl, Info => Item_1.Info);
--# expr-done 1658



   if Fld_4.Node = null
      or else Fld_4.Node.Kind in Lkt_Field_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Field_Decl
        (Node => Fld_4.Node,
         Info => Fld_4.Info);

   else
         Cast_Result := No_Entity_Field_Decl;
   end if;


--# expr-done 1659



   if Cast_Result.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Type_Ref (Node => Cast_Result.Node.Field_Decl_F_Decl_Type, Info => Cast_Result.Info);
--# expr-done 1660



   if Fld_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_6 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Fld_5.Node, E_Info => Fld_5.Info);
--# end
--# expr-done 1661
      

         declare
            Item_To_Append : constant Internal_Entity_Type_Decl := Fld_6;
         begin
            Internal_Entity_Type_Decl_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result_1 := Create_Internal_Entity_Type_Decl_Array
           (Items_Count => Natural (Internal_Entity_Type_Decl_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Internal_Entity_Type_Decl_Vectors.Get
              (Map_Result_1_Vec,
               I + Internal_Entity_Type_Decl_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Internal_Entity_Type_Decl_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 1662









   
      Cast_Result_1 := Create_Internal_Entity_Type_Decl
        (Node => Ent.Node,
         Info => Ent.Info);











   
      Cast_Result_2 := Create_Internal_Entity_Decl
        (Node => Ent.Node,
         Info => Ent.Info);


--# property-call-start LktNode.function_type_helper
Fld_7 := Liblktlang.Implementation.Lkt_Node_P_Function_Type_Helper (Node => Ent.Node, Param_Types => Map_Result_1, Return_Type => Cast_Result_1, Origin => Cast_Result_2, E_Info => Ent.Info);
--# end
--# expr-done 1663

         Property_Result := Fld_7;
         
   --# end
      Finalizer_Scope_249;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_249;




            raise;
      end;



   return Property_Result;
end Struct_Decl_P_Function_Type_Aux;
--# end

   







--# property-start StructDecl.entity_scope nodes.lkt:2761
pragma Warnings (Off, "is not referenced");

function Struct_Decl_P_Entity_Scope
  
  (Node : Bare_Struct_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Lexical_Env
is
   Self : Bare_Struct_Decl :=
     Bare_Struct_Decl (Node);
     Ent : Internal_Entity_Struct_Decl :=
       Internal_Entity_Struct_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Lexical_Env;

      
            procedure Finalizer_Scope_250 with Inline_Always;
            procedure Finalizer_Scope_660 with Inline_Always;
            procedure Finalizer_Scope_661 with Inline_Always;

      Fld : Internal_Entity_Named_Type_Decl;
Fld_1 : Bare_Named_Type_Decl;
Cast_Result : Bare_Named_Type_Decl;
Is_Equal : Boolean;
Fld_2 : Internal_Entity;
Cast_Result_1 : Internal_Entity_Generic_Decl;
Var_Expr : Internal_Entity_Generic_Decl;
Fld_3 : Lexical_Env := Empty_Env;
Fld_4 : Internal_Entity_Generic_Decl;
Fld_5 : Internal_Entity_Generic_Param_Decl_List;
Fld_6 : Bare_Generic_Param_Decl_List;
Fld_7 : Internal_Entity_Info;
Get_Result : Bare_Full_Decl;
As_Entity : Internal_Entity_Full_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Full_Decl;
Fld_8 : Internal_Entity_Decl;
Fld_9 : Symbol_Type;
Env_Get_Result : Internal_Entity;
Result_Var : Internal_Entity;
Cast_Result_2 : Internal_Entity_Type_Decl;
Var_Expr_1 : Internal_Entity_Type_Decl;
Origin : Internal_Entity;
Fld_10 : Lexical_Env := Empty_Env;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result_3 : Internal_Entity;
Dyn_Var_Bind_Result : Lexical_Env := Empty_Env;
Scope_Result : Lexical_Env := Empty_Env;
Scope_Result_1 : Lexical_Env := Empty_Env;
Result_Var_1 : Lexical_Env := Empty_Env;
If_Result_1 : Lexical_Env := Empty_Env;

            procedure Finalizer_Scope_250 is
            begin
                     Dec_Ref (Fld_3);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (Result_Var_1);
                     Dec_Ref (If_Result_1);
            end Finalizer_Scope_250;
            procedure Finalizer_Scope_660 is
            begin
                     Dec_Ref (Scope_Result);
            end Finalizer_Scope_660;
            procedure Finalizer_Scope_661 is
            begin
                     Dec_Ref (Fld_10);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_661;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1679 If If_Result_1 nodes.lkt:2762



--# expr-start 1666 Eq Is_Equal nodes.lkt:2762









   
      Cast_Result := Self;


--# expr-start 1665 'Entity[NamedTypeDecl].node' Fld_1 nodes.lkt:2762



--# expr-start 1664 LktNode.entity_type Fld nodes.lkt:2762







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Self);
--# end
--# expr-done 1664





Fld_1 := Fld.Node;
--# expr-done 1665
Is_Equal := Cast_Result = Fld_1; 
--# expr-done 1666
if Is_Equal then
   --# expr-start 1678 .do Result_Var_1 nodes.lkt:2764



--# expr-start 1675 Cast Cast_Result_2 nodes.lkt:2764








--# expr-start 1668 Cast Cast_Result_1 nodes.lkt:2764





--# expr-start 1667 .parent Fld_2 nodes.lkt:2764







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Liblktlang.Implementation.Parent (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 1667



   if Fld_2.Node = null
      or else Fld_2.Node.Kind in Lkt_Generic_Decl_Range
   then
      
      Cast_Result_1 := Create_Internal_Entity_Generic_Decl
        (Node => Fld_2.Node,
         Info => Fld_2.Info);

   else
         Cast_Result_1 := No_Entity_Generic_Decl;
   end if;


--# expr-done 1668
Var_Expr := Cast_Result_1;





if Var_Expr /= No_Entity_Generic_Decl then
   --# expr-start 1674 .get_first Env_Get_Result nodes.lkt:2764
--# expr-start 1669 LktNode.children_env Fld_3 nodes.lkt:2764







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Liblktlang.Implementation.Children_Env (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# expr-done 1669
--# expr-start 1673 Decl.name Fld_9 nodes.lkt:2765



--# expr-start 1672 FullDecl.decl Fld_8 nodes.lkt:2765



--# expr-start 1671 GenericDecl.generic_param_decls Fld_5 nodes.lkt:2765



--# expr-start 1670 LktNode.entity_gen_type Fld_4 nodes.lkt:2765







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_gen_type
Fld_4 := Liblktlang.Implementation.Lkt_Node_P_Entity_Gen_Type (Node => Ent.Node);
--# end
--# expr-done 1670



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Generic_Param_Decl_List (Node => Fld_4.Node.Generic_Decl_F_Generic_Param_Decls, Info => Fld_4.Info);
--# expr-done 1671
















Fld_6 := Fld_5.Node;



   if Fld_6 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;




Get_Result := Get (Self, Fld_6, 0, True); 
Is_Null := Get_Result = null; 
if Is_Null then
   
   If_Result := No_Entity_Full_Decl;
else
   








Fld_7 := Fld_5.Info;

As_Entity := (Info => Fld_7, Node => Get_Result); 
   If_Result := As_Entity;
end if;






   if If_Result.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Create_Internal_Entity_Decl (Node => If_Result.Node.Full_Decl_F_Decl, Info => If_Result.Info);
--# expr-done 1672



   if Fld_8.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_9 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Fld_8.Node);
--# end
--# expr-done 1673


Env_Get_Result := AST_Envs.Get_First (Self => Fld_3, Key => Thin (Fld_9), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 1674
   Result_Var := Env_Get_Result;
else
   
   Result_Var := No_Entity;
end if;






   if Result_Var.Node = null
      or else Result_Var.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_2 := Create_Internal_Entity_Type_Decl
        (Node => Result_Var.Node,
         Info => Result_Var.Info);

   else
         Cast_Result_2 := No_Entity_Type_Decl;
   end if;


--# expr-done 1675
Var_Expr_1 := Cast_Result_2;





if Var_Expr_1 /= No_Entity_Type_Decl then
   



   --# scope-start







   --# scope-start



--# expr-start 1677 bind Dyn_Var_Bind_Result nodes.lkt:2770






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result_3 := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Origin := Cast_Result_3; 
--# expr-start 1676 Decl.defined_scope_as_entity Fld_10 nodes.lkt:2772







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope_as_entity'
Fld_10 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope_As_Entity (Node => Var_Expr_1.Node, Origin => Origin, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 1676
Dyn_Var_Bind_Result := Fld_10; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 1677
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_661;


Scope_Result_1 := Scope_Result;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_660;


   Result_Var_1 := Scope_Result_1;
else
   
   Result_Var_1 := Empty_Env;
end if;

      Inc_Ref (Result_Var_1);


--# expr-done 1678
   If_Result_1 := Result_Var_1;
else
   
   If_Result_1 := Empty_Env;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 1679

         Property_Result := If_Result_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_250;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_250;
                     Finalizer_Scope_660;
                     Finalizer_Scope_661;




            raise;
      end;



   return Property_Result;
end Struct_Decl_P_Entity_Scope;
--# end

   







--# property-start StructDecl.update_func_env nodes.lkt:2780
pragma Warnings (Off, "is not referenced");

function Struct_Decl_P_Update_Func_Env
  
  (Node : Bare_Struct_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Lexical_Env
is
   Self : Bare_Struct_Decl :=
     Bare_Struct_Decl (Node);
     Ent : Internal_Entity_Struct_Decl :=
       Internal_Entity_Struct_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Lexical_Env;

      
            procedure Finalizer_Scope_251 with Inline_Always;
            procedure Finalizer_Scope_664 with Inline_Always;

      Sym : Symbol_Type;
Array_Lit : Symbol_Type_Array_Access;
Fld : Internal_Entity_Decl_Block;
Item : Internal_Entity_Full_Decl;
Fld_1 : Internal_Entity_Decl;
Is_A : Boolean;
Fld_2 : Bare_Decl_Block;
Fld_3 : Internal_Entity_Info;
Bare_Item : Bare_Full_Decl;
As_Entity : Internal_Entity_Full_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Full_Decl;
Map_Result : Internal_Entity_Full_Decl_Array_Access;
Fld_4 : Internal_Entity_Decl;
Fld_5 : Symbol_Type;
Fld_6 : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Field_Decl;
Fld_7 : Internal_Entity_Type_Decl;
New_Node : Bare_Synth_Param_Decl;
As_Entity_1 : Internal_Entity_Synth_Param_Decl;
Is_Null_1 : Boolean;
If_Result_1 : Internal_Entity_Synth_Param_Decl;
Cast_Result_1 : Internal_Entity_Decl;
New_Struct : Internal_Resolved_Param;
Map_Result_1 : Internal_Resolved_Param_Array_Access;
Cast_Result_2 : Internal_Entity_Type_Decl;
New_Node_1 : Bare_Synth_Fun_Decl;
As_Entity_2 : Internal_Entity_Synth_Fun_Decl;
Is_Null_2 : Boolean;
If_Result_2 : Internal_Entity_Synth_Fun_Decl;
Fld_8 : Internal_Entity_Function_Type;
Cast_Result_3 : Internal_Entity_Type_Decl;
Array_Lit_1 : Internal_Entity_Type_Decl_Array_Access;
New_Node_2 : Bare_Dyn_Env_Wrapper;
Var_Expr : Bare_Dyn_Env_Wrapper;
Fld_9 : Lexical_Env := Empty_Env;
Scope_Result : Lexical_Env := Empty_Env;
Result_Var : Lexical_Env := Empty_Env;

            procedure Finalizer_Scope_251 is
            begin
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (Array_Lit_1);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Result_Var);
            end Finalizer_Scope_251;
            procedure Finalizer_Scope_664 is
            begin
                     Dec_Ref (Fld_9);
            end Finalizer_Scope_664;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Struct_Decl_Struct_Decl_P_Update_Func_Env,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Struct_Decl,
                                As_Bare_Struct_Decl => Self);
               Mmz_K.Items (2) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Lexical_Env;
                  Inc_Ref (Property_Result);

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 1702 .do Result_Var nodes.lkt:2781



--# expr-start 1700 'New[DynEnvWrapper]' New_Node_2 nodes.lkt:2781
--# expr-start 1681 ArrayLiteral Array_Lit nodes.lkt:2782
--# expr-start 1680 SymbolLiteral Sym nodes.lkt:2782
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Update); 
--# expr-done 1680
Array_Lit := Create_Symbol_Type_Array (Internal_Symbol_Type_Array'(1 => Sym)); 
--# expr-done 1681
--# expr-start 1699 ArrayLiteral Array_Lit_1 nodes.lkt:2783
--# expr-start 1698 Cast Cast_Result_3 nodes.lkt:2784





--# expr-start 1697 SynthFunDecl.function_type_aux Fld_8 nodes.lkt:2784



--# expr-start 1696 .as_bare_entity If_Result_2 nodes.lkt:2784



--# expr-start 1695 'New[SynthFunDecl]' New_Node_1 nodes.lkt:2784
--# expr-start 1694 .map Map_Result_1 nodes.lkt:2785








   

   --# expr-start 1685 .filter Map_Result nodes.lkt:2785








   

   --# expr-start 1682 StructDecl.decls Fld nodes.lkt:2785







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Decl_Block (Node => Ent.Node.Struct_Decl_F_Decls, Info => Ent.Info);
--# expr-done 1682









Fld_2 := Fld.Node;

   
      declare
         Map_Result_Vec : Internal_Entity_Full_Decl_Vectors.Vector;
      begin
   

   

      if Fld_2 = null then
         
      Map_Result := Create_Internal_Entity_Full_Decl_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Decl_Block := Fld_2;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Full_Decl;
else
   








Fld_3 := Fld.Info;

As_Entity := (Info => Fld_3, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind d Item

            
         --# expr-start 1684 IsA Is_A nodes.lkt:2785
--# expr-start 1683 FullDecl.decl Fld_1 nodes.lkt:2785







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Decl (Node => Item.Node.Full_Decl_F_Decl, Info => Item.Info);
--# expr-done 1683
Is_A := Fld_1.Node /= null 
and then Fld_1.Node.Kind in Lkt_Field_Decl_Range; 
--# expr-done 1684
         if Is_A then
            
         
      
      

         declare
            Item_To_Append : constant Internal_Entity_Full_Decl := Item;
         begin
            Internal_Entity_Full_Decl_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
         end if;
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Internal_Entity_Full_Decl_Array
           (Items_Count => Natural (Internal_Entity_Full_Decl_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Full_Decl_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Full_Decl_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Full_Decl_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1685

   
      declare
         Map_Result_1_Vec : Internal_Resolved_Param_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Full_Decl_Array_Access := Map_Result;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind a Item_1

            
         
         
      --# expr-start 1693 'New[ResolvedParam]' New_Struct nodes.lkt:2787






--# expr-start 1687 .as_entity If_Result_1 nodes.lkt:2791



--# expr-start 1686 'New[SynthParamDecl]' New_Node nodes.lkt:2791



if Is_Foreign_Strict (Self.Self_Env, Self) then
   Raise_Property_Exception
     (Self,
      Property_Error'Identity,
      "synthetic nodes cannot have foreign lexical envs");
end if;


New_Node := new Root_Node_Record
  (Lkt_Synth_Param_Decl);
Initialize
  (Self => New_Node,
   Kind => Lkt_Synth_Param_Decl,
   Unit => Self.Unit,

   Token_Start_Index => No_Token_Index,
   Token_End_Index   => No_Token_Index,

   Parent => Self,

   Self_Env => Self.Self_Env);
Register_Destroyable (Self.Unit, New_Node);



--# expr-done 1686
Is_Null_1 := New_Node = null; 
if Is_Null_1 then
   
   If_Result_1 := No_Entity_Synth_Param_Decl;
else
   

As_Entity_1 := (Info => E_Info, Node => New_Node); 
   If_Result_1 := As_Entity_1;
end if;



--# expr-done 1687



   
      Cast_Result_1 := Create_Internal_Entity_Decl
        (Node => If_Result_1.Node,
         Info => If_Result_1.Info);



--# expr-start 1689 Decl.name Fld_5 nodes.lkt:2788



--# expr-start 1688 FullDecl.decl Fld_4 nodes.lkt:2788







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Decl (Node => Item_1.Node.Full_Decl_F_Decl, Info => Item_1.Info);
--# expr-done 1688



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.name'
Fld_5 := Liblktlang.Implementation.Dispatcher_Decl_P_Name (Node => Fld_4.Node);
--# end
--# expr-done 1689
--# expr-start 1692 Decl.get_type Fld_7 nodes.lkt:2789



--# expr-start 1691 Cast Cast_Result nodes.lkt:2789





--# expr-start 1690 FullDecl.decl Fld_6 nodes.lkt:2789







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Decl (Node => Item_1.Node.Full_Decl_F_Decl, Info => Item_1.Info);
--# expr-done 1690



   if Fld_6.Node = null
      or else Fld_6.Node.Kind in Lkt_Field_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Field_Decl
        (Node => Fld_6.Node,
         Info => Fld_6.Info);

   else
         Cast_Result := No_Entity_Field_Decl;
   end if;


--# expr-done 1691



   if Cast_Result.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.get_type
Fld_7 := Liblktlang.Implementation.Decl_P_Get_Type (Node => Cast_Result.Node, E_Info => Cast_Result.Info);
--# end
--# expr-done 1692
New_Struct := (Accept_Logical_Var => False, Decl => Cast_Result_1, Has_Default_Value => True, Name => Fld_5, Param_Type => Fld_7); 
--# expr-done 1693
      

         declare
            Item_To_Append : constant Internal_Resolved_Param := New_Struct;
         begin
            Internal_Resolved_Param_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result_1 := Create_Internal_Resolved_Param_Array
           (Items_Count => Natural (Internal_Resolved_Param_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Internal_Resolved_Param_Vectors.Get
              (Map_Result_1_Vec,
               I + Internal_Resolved_Param_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Internal_Resolved_Param_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 1694









   
      Cast_Result_2 := Create_Internal_Entity_Type_Decl
        (Node => Ent.Node,
         Info => Ent.Info);


Inc_Ref (Map_Result_1);


if Is_Foreign_Strict (Self.Self_Env, Self) then
   Raise_Property_Exception
     (Self,
      Property_Error'Identity,
      "synthetic nodes cannot have foreign lexical envs");
end if;


New_Node_1 := new Root_Node_Record
  (Lkt_Synth_Fun_Decl);
Initialize
  (Self => New_Node_1,
   Kind => Lkt_Synth_Fun_Decl,
   Unit => Self.Unit,

   Token_Start_Index => No_Token_Index,
   Token_End_Index   => No_Token_Index,

   Parent => Self,

   Self_Env => Self.Self_Env);
Register_Destroyable (Self.Unit, New_Node_1);


      New_Node_1.Synth_Fun_Decl_F_Params :=
         Map_Result_1;
      New_Node_1.Synth_Fun_Decl_F_Return_Type :=
         Cast_Result_2;

--# expr-done 1695
Is_Null_2 := New_Node_1 = null; 
if Is_Null_2 then
   
   If_Result_2 := No_Entity_Synth_Fun_Decl;
else
   

As_Entity_2 := (Info => No_Entity_Info, Node => New_Node_1); 
   If_Result_2 := As_Entity_2;
end if;



--# expr-done 1696



   if If_Result_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start SynthFunDecl.function_type_aux
Fld_8 := Liblktlang.Implementation.Synth_Fun_Decl_P_Function_Type_Aux (Node => If_Result_2.Node, E_Info => If_Result_2.Info);
--# end
--# expr-done 1697



   
      Cast_Result_3 := Create_Internal_Entity_Type_Decl
        (Node => Fld_8.Node,
         Info => Fld_8.Info);


--# expr-done 1698
Array_Lit_1 := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Cast_Result_3)); 
--# expr-done 1699
Inc_Ref (Array_Lit);
Inc_Ref (Array_Lit_1);


if Is_Foreign_Strict (Self.Self_Env, Self) then
   Raise_Property_Exception
     (Self,
      Property_Error'Identity,
      "synthetic nodes cannot have foreign lexical envs");
end if;


New_Node_2 := new Root_Node_Record
  (Lkt_Dyn_Env_Wrapper);
Initialize
  (Self => New_Node_2,
   Kind => Lkt_Dyn_Env_Wrapper,
   Unit => Self.Unit,

   Token_Start_Index => No_Token_Index,
   Token_End_Index   => No_Token_Index,

   Parent => Self,

   Self_Env => Self.Self_Env);
Register_Destroyable (Self.Unit, New_Node_2);


      New_Node_2.Dyn_Env_Wrapper_F_Names :=
         Array_Lit;
      New_Node_2.Dyn_Env_Wrapper_F_Types :=
         Array_Lit_1;

--# expr-done 1700
Var_Expr := New_Node_2;





if Var_Expr /= No_Bare_Lkt_Node then
   



   --# scope-start



--# expr-start 1701 DynEnvWrapper.dynenvwrapper_instantiation_env Fld_9 nodes.lkt:2801







   if Var_Expr = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DynEnvWrapper.dynenvwrapper_instantiation_env
Fld_9 := Liblktlang.Implementation.Dyn_Env_Wrapper_F_Dynenvwrapper_Instantiation_Env (Node => Var_Expr);
--# end
--# expr-done 1701
Scope_Result := Fld_9;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_664;


   Result_Var := Scope_Result;
else
   
   Result_Var := Empty_Env;
end if;

      Inc_Ref (Result_Var);


--# expr-done 1702

         Property_Result := Result_Var;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_251;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_251;
                     Finalizer_Scope_664;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Lexical_Env,
                     As_Lexical_Env => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
            if Mmz_Stored then
               Inc_Ref (Property_Result);
            end if;
      end if;



   return Property_Result;
end Struct_Decl_P_Update_Func_Env;
--# end

   







--# property-start StructDecl.defined_scope nodes.lkt:2804
pragma Warnings (Off, "is not referenced");

function Struct_Decl_P_Defined_Scope
  
  (Node : Bare_Struct_Decl
      ; Origin : Internal_Entity
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Lexical_Env
is
   Self : Bare_Struct_Decl :=
     Bare_Struct_Decl (Node);
     Ent : Internal_Entity_Struct_Decl :=
       Internal_Entity_Struct_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind origin Origin

   Property_Result : Lexical_Env;

      
            procedure Finalizer_Scope_252 with Inline_Always;
            procedure Finalizer_Scope_665 with Inline_Always;
            procedure Finalizer_Scope_666 with Inline_Always;

      Fld : Internal_Entity_Decl_Block;
Fld_1 : Lexical_Env := Empty_Env;
Array_Lit : Lexical_Env_Array_Access;
Fld_2 : Internal_Entity_Type_Ref_List;
Item : Internal_Entity_Type_Ref;
Fld_3 : Internal_Entity_Type_Decl;
Var_Expr : Internal_Entity_Type_Decl;
Fld_4 : Lexical_Env := Empty_Env;
Result_Var : Lexical_Env := Empty_Env;
Fld_5 : Bare_Type_Ref_List;
Fld_6 : Internal_Entity_Info;
Bare_Item : Bare_Type_Ref;
As_Entity : Internal_Entity_Type_Ref;
Is_Null : Boolean;
If_Result : Internal_Entity_Type_Ref;
Map_Result : Lexical_Env_Array_Access;
Concat_Result : Lexical_Env_Array_Access;
Fld_7 : Lexical_Env := Empty_Env;
Fld_8 : Lexical_Env := Empty_Env;
Array_Lit_1 : Lexical_Env_Array_Access;
Concat_Result_1 : Lexical_Env_Array_Access;
Group_Env : Lexical_Env := Empty_Env;
Var_Expr_1 : Lexical_Env := Empty_Env;
Cast_Result : Internal_Entity;
Is_Equiv : Boolean;
Fld_9 : Internal_Entity_Type_Decl;
Fld_10 : Lexical_Env := Empty_Env;
Array_Lit_2 : Lexical_Env_Array_Access;
Group_Env_1 : Lexical_Env := Empty_Env;
If_Result_1 : Lexical_Env := Empty_Env;
Scope_Result : Lexical_Env := Empty_Env;
Result_Var_1 : Lexical_Env := Empty_Env;

            procedure Finalizer_Scope_252 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Concat_Result);
                     Dec_Ref (Fld_7);
                     Dec_Ref (Fld_8);
                     Dec_Ref (Array_Lit_1);
                     Dec_Ref (Concat_Result_1);
                     Dec_Ref (Group_Env);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Result_Var_1);
            end Finalizer_Scope_252;
            procedure Finalizer_Scope_665 is
            begin
                     Dec_Ref (Fld_4);
                     Dec_Ref (Result_Var);
            end Finalizer_Scope_665;
            procedure Finalizer_Scope_666 is
            begin
                     Dec_Ref (Var_Expr_1);
                     Dec_Ref (Fld_10);
                     Dec_Ref (Array_Lit_2);
                     Dec_Ref (Group_Env_1);
                     Dec_Ref (If_Result_1);
            end Finalizer_Scope_666;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1722 .do Result_Var_1 nodes.lkt:2805



--# expr-start 1715 .env_group Group_Env nodes.lkt:2805
--# expr-start 1714 ArrayConcat Concat_Result_1 nodes.lkt:2806
--# expr-start 1710 ArrayConcat Concat_Result nodes.lkt:2806
--# expr-start 1705 ArrayLiteral Array_Lit nodes.lkt:2806
--# expr-start 1704 LktNode.children_env Fld_1 nodes.lkt:2806



--# expr-start 1703 StructDecl.decls Fld nodes.lkt:2806







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Decl_Block (Node => Ent.Node.Struct_Decl_F_Decls, Info => Ent.Info);
--# expr-done 1703



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Liblktlang.Implementation.Children_Env (Node => Fld.Node, E_Info => Fld.Info);
--# expr-done 1704
Array_Lit := Create_Lexical_Env_Array (Internal_Lexical_Env_Array'(1 => Fld_1)); 
--# expr-done 1705
--# expr-start 1709 .map Map_Result nodes.lkt:2807








   

   --# expr-start 1706 StructDecl.traits Fld_2 nodes.lkt:2807







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Type_Ref_List (Node => Ent.Node.Struct_Decl_F_Traits, Info => Ent.Info);
--# expr-done 1706









Fld_5 := Fld_2.Node;

   
      declare
         Map_Result_Vec : Lexical_Env_Vectors.Vector;
      begin
   

   

      if Fld_5 = null then
         
      Map_Result := Create_Lexical_Env_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Type_Ref_List := Fld_5;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Type_Ref;
else
   








Fld_6 := Fld_2.Info;

As_Entity := (Info => Fld_6, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind t Item

            
         
         
      


--# expr-start 1707 TypeRef.referenced_decl Fld_3 nodes.lkt:2807







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_3 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 1707
Var_Expr := Fld_3;





if Var_Expr /= No_Entity_Type_Decl then
   --# expr-start 1708 Decl.defined_scope Fld_4 nodes.lkt:2807







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_4 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Var_Expr.Node, Origin => Origin, E_Info => Var_Expr.Info);
--# end
--# expr-done 1708
   Result_Var := Fld_4;
else
   
   Result_Var := Empty_Env;
end if;

      Inc_Ref (Result_Var);


      

         declare
            Item_To_Append : constant Lexical_Env := Result_Var;
         begin
               Inc_Ref (Item_To_Append);
            Lexical_Env_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_665;



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Lexical_Env_Array
           (Items_Count => Natural (Lexical_Env_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Lexical_Env_Vectors.Get
              (Map_Result_Vec,
               I + Lexical_Env_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Lexical_Env_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1709
Concat_Result := Concat (Array_Lit, Map_Result); 
--# expr-done 1710
--# expr-start 1713 ArrayLiteral Array_Lit_1 nodes.lkt:2808
--# expr-start 1711 StructDecl.entity_scope Fld_7 nodes.lkt:2808







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start StructDecl.entity_scope
Fld_7 := Liblktlang.Implementation.Struct_Decl_P_Entity_Scope (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1711
--# expr-start 1712 StructDecl.update_func_env Fld_8 nodes.lkt:2808







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start StructDecl.update_func_env
Fld_8 := Liblktlang.Implementation.Struct_Decl_P_Update_Func_Env (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1712
Array_Lit_1 := Create_Lexical_Env_Array (Internal_Lexical_Env_Array'(1 => Fld_7, 2 => Fld_8)); 
--# expr-done 1713
Concat_Result_1 := Concat (Concat_Result, Array_Lit_1); 
--# expr-done 1714

Group_Env := Group (Concat_Result_1, No_Metadata); 
--# expr-done 1715
Var_Expr_1 := Group_Env;

      Inc_Ref (Var_Expr_1);




if Var_Expr_1 /= Empty_Env then
   



   --# scope-start



--# expr-start 1721 If If_Result_1 nodes.lkt:2813



--# expr-start 1716 Eq Is_Equiv nodes.lkt:2813









   
      Cast_Result := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);



Is_Equiv := Equivalent (Cast_Result, Origin); 
--# expr-done 1716
if Is_Equiv then
   --# expr-start 1720 .env_group Group_Env_1 nodes.lkt:2814
--# expr-start 1719 ArrayLiteral Array_Lit_2 nodes.lkt:2814

--# expr-start 1718 Decl.defined_scope Fld_10 nodes.lkt:2814



--# expr-start 1717 TypeDecl.basic_trait_from_self Fld_9 nodes.lkt:2814







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.basic_trait_from_self
Fld_9 := Liblktlang.Implementation.Type_Decl_P_Basic_Trait_From_Self (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1717



   if Fld_9.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_10 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Fld_9.Node, Origin => Origin, E_Info => Fld_9.Info);
--# end
--# expr-done 1718
Array_Lit_2 := Create_Lexical_Env_Array (Internal_Lexical_Env_Array'(1 => Var_Expr_1, 2 => Fld_10)); 
--# expr-done 1719

Group_Env_1 := Group (Array_Lit_2, No_Metadata); 
--# expr-done 1720
   If_Result_1 := Group_Env_1;
else
   
   If_Result_1 := Var_Expr_1;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 1721
Scope_Result := If_Result_1;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_666;


   Result_Var_1 := Scope_Result;
else
   
   Result_Var_1 := Empty_Env;
end if;

      Inc_Ref (Result_Var_1);


--# expr-done 1722

         Property_Result := Result_Var_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_252;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_252;
                     Finalizer_Scope_665;
                     Finalizer_Scope_666;




            raise;
      end;



   return Property_Result;
end Struct_Decl_P_Defined_Scope;
--# end



   


      

   --
   --  Primitives for Bare_Trait_Decl
   --

   



      
      procedure Initialize_Fields_For_Trait_Decl
        (Self : Bare_Trait_Decl
         ; Trait_Decl_F_Syn_Name : Bare_Def_Id
         ; Trait_Decl_F_Traits : Bare_Type_Ref_List
         ; Trait_Decl_F_Decls : Bare_Decl_Block
        ) is
      begin

            Self.Trait_Decl_F_Syn_Name := Trait_Decl_F_Syn_Name;
            Self.Trait_Decl_F_Traits := Trait_Decl_F_Traits;
            Self.Trait_Decl_F_Decls := Trait_Decl_F_Decls;
         

      end Initialize_Fields_For_Trait_Decl;


   







--# property-start TraitDecl.decl_type_name nodes.lkt:2840
pragma Warnings (Off, "is not referenced");

function Trait_Decl_P_Decl_Type_Name
  
  (Node : Bare_Trait_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Trait_Decl :=
     Bare_Trait_Decl (Node);
     Ent : Internal_Entity_Trait_Decl :=
       Internal_Entity_Trait_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_253 with Inline_Always;

      Str : String_Type;

            procedure Finalizer_Scope_253 is
            begin
                     Dec_Ref (Str);
            end Finalizer_Scope_253;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1723 StringLiteral Str nodes.lkt:2840
Str := Create_String ("trait declaration"); 
--# expr-done 1723

         Property_Result := Str;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_253;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_253;




            raise;
      end;



   return Property_Result;
end Trait_Decl_P_Decl_Type_Name;
--# end

   







--# property-start TraitDecl.defined_scope_as_entity nodes.lkt:2843
pragma Warnings (Off, "is not referenced");

function Trait_Decl_P_Defined_Scope_As_Entity
  
  (Node : Bare_Trait_Decl
      ; Origin : Internal_Entity
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Lexical_Env
is
   Self : Bare_Trait_Decl :=
     Bare_Trait_Decl (Node);
     Ent : Internal_Entity_Trait_Decl :=
       Internal_Entity_Trait_Decl'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind origin Origin

   Property_Result : Lexical_Env;

      
            procedure Finalizer_Scope_254 with Inline_Always;

      Fld : Lexical_Env := Empty_Env;
Fld_1 : Internal_Entity_Trait_Decl;
Fld_2 : Bare_Trait_Decl;
Cast_Result : Bare_Trait_Decl;
Is_Equal : Boolean;
Fld_3 : Internal_Entity_Decl;
Fld_4 : Internal_Entity_Named_Type_Decl;
Fld_5 : Internal_Entity_Decl;
Fld_6 : Lexical_Env := Empty_Env;
Sym : Symbol_Type;
Env_Get_Result : Internal_Entity;
Cast_Result_1 : Internal_Entity_Type_Decl;
Array_Lit : Internal_Entity_Type_Decl_Array_Access;
Fld_7 : Internal_Entity_Decl;
Cast_Result_2 : Internal_Entity_Type_Decl;
Array_Lit_1 : Internal_Entity_Type_Decl_Array_Access;
Fld_8 : Internal_Entity_Decl;
Fld_9 : Lexical_Env := Empty_Env;
If_Result : Lexical_Env := Empty_Env;

            procedure Finalizer_Scope_254 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Fld_6);
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Array_Lit_1);
                     Dec_Ref (Fld_9);
                     Dec_Ref (If_Result);
            end Finalizer_Scope_254;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1741 If If_Result nodes.lkt:2844



--# expr-start 1726 Eq Is_Equal nodes.lkt:2844









   
      Cast_Result := Self;


--# expr-start 1725 'Entity[TraitDecl].node' Fld_2 nodes.lkt:2844



--# expr-start 1724 LktNode.node_trait Fld_1 nodes.lkt:2844







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.node_trait
Fld_1 := Liblktlang.Implementation.Lkt_Node_P_Node_Trait (Node => Self);
--# end
--# expr-done 1724





Fld_2 := Fld_1.Node;
--# expr-done 1725
Is_Equal := Cast_Result = Fld_2; 
--# expr-done 1726
if Is_Equal then
   --# expr-start 1739 Decl.defined_scope Fld_9 nodes.lkt:2846



--# expr-start 1738 Decl.instantiate_generic_decl Fld_8 nodes.lkt:2846



--# expr-start 1727 Decl.as_bare_decl Fld_3 nodes.lkt:2846







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.as_bare_decl
Fld_3 := Liblktlang.Implementation.Decl_P_As_Bare_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1727



   if Fld_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1737 ArrayLiteral Array_Lit_1 nodes.lkt:2847
--# expr-start 1736 Cast Cast_Result_2 nodes.lkt:2848





--# expr-start 1735 Decl.instantiate_generic_decl Fld_7 nodes.lkt:2848



--# expr-start 1729 Decl.as_bare_decl Fld_5 nodes.lkt:2848



--# expr-start 1728 LktNode.entity_type Fld_4 nodes.lkt:2848







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_4 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Ent.Node);
--# end
--# expr-done 1728



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.as_bare_decl
Fld_5 := Liblktlang.Implementation.Decl_P_As_Bare_Decl (Node => Fld_4.Node, E_Info => Fld_4.Info);
--# end
--# expr-done 1729



   if Fld_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1734 ArrayLiteral Array_Lit nodes.lkt:2849
--# expr-start 1733 Cast Cast_Result_1 nodes.lkt:2849





--# expr-start 1732 .get_first Env_Get_Result nodes.lkt:2849
--# expr-start 1730 LktNode.node_env Fld_6 nodes.lkt:2849







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Liblktlang.Implementation.Node_Env (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 1730
--# expr-start 1731 SymbolLiteral Sym nodes.lkt:2849
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_T); 
--# expr-done 1731


Env_Get_Result := AST_Envs.Get_First (Self => Fld_6, Key => Thin (Sym), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 1732



   if Env_Get_Result.Node = null
      or else Env_Get_Result.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_1 := Create_Internal_Entity_Type_Decl
        (Node => Env_Get_Result.Node,
         Info => Env_Get_Result.Info);

   else
         Cast_Result_1 := No_Entity_Type_Decl;
   end if;


--# expr-done 1733
Array_Lit := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Cast_Result_1)); 
--# expr-done 1734
--# property-call-start Decl.instantiate_generic_decl
Fld_7 := Liblktlang.Implementation.Decl_P_Instantiate_Generic_Decl (Node => Fld_5.Node, Param_Types => Array_Lit, E_Info => Fld_5.Info);
--# end
--# expr-done 1735



   if Fld_7.Node = null
      or else Fld_7.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_2 := Create_Internal_Entity_Type_Decl
        (Node => Fld_7.Node,
         Info => Fld_7.Info);

   else
         Cast_Result_2 := No_Entity_Type_Decl;
   end if;


--# expr-done 1736
Array_Lit_1 := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Cast_Result_2)); 
--# expr-done 1737
--# property-call-start Decl.instantiate_generic_decl
Fld_8 := Liblktlang.Implementation.Decl_P_Instantiate_Generic_Decl (Node => Fld_3.Node, Param_Types => Array_Lit_1, E_Info => Fld_3.Info);
--# end
--# expr-done 1738



   if Fld_8.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_9 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Fld_8.Node, Origin => Origin, E_Info => Fld_8.Info);
--# end
--# expr-done 1739
   If_Result := Fld_9;
else
   --# expr-start 1740 Decl.defined_scope_as_entity Fld nodes.lkt:2855







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start 'Decl.[root-static]defined_scope_as_entity'
Fld := Liblktlang.Implementation.Decl_P_Defined_Scope_As_Entity (Node => Ent.Node, Origin => Origin, E_Info => Ent.Info);
--# end
--# expr-done 1740
   If_Result := Fld;
end if;

      Inc_Ref (If_Result);


--# expr-done 1741

         Property_Result := If_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_254;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_254;




            raise;
      end;



   return Property_Result;
end Trait_Decl_P_Defined_Scope_As_Entity;
--# end



   


      

   --
   --  Primitives for Bare_Decl_Annotation
   --

   



      
      procedure Initialize_Fields_For_Decl_Annotation
        (Self : Bare_Decl_Annotation
         ; Decl_Annotation_F_Name : Bare_Id
         ; Decl_Annotation_F_Args : Bare_Decl_Annotation_Args
        ) is
      begin

            Self.Decl_Annotation_F_Name := Decl_Annotation_F_Name;
            Self.Decl_Annotation_F_Args := Decl_Annotation_F_Args;
         

      end Initialize_Fields_For_Decl_Annotation;

      
   function Decl_Annotation_F_Name
     (Node : Bare_Decl_Annotation) return Bare_Id
   is
      

   begin
         
         return Node.Decl_Annotation_F_Name;
      
   end;

      
   function Decl_Annotation_F_Args
     (Node : Bare_Decl_Annotation) return Bare_Decl_Annotation_Args
   is
      

   begin
         
         return Node.Decl_Annotation_F_Args;
      
   end;


   







--# property-start DeclAnnotation.xref_entry_point nodes.lkt:2866
pragma Warnings (Off, "is not referenced");

function Decl_Annotation_P_Xref_Entry_Point
  
  (Node : Bare_Decl_Annotation
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Decl_Annotation :=
     Bare_Decl_Annotation (Node);
     Ent : Internal_Entity_Decl_Annotation :=
       Internal_Entity_Decl_Annotation'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Fld : Internal_Entity_Decl_Annotation_Args;
Var_Expr : Internal_Entity_Decl_Annotation_Args;
Fld_1 : Internal_Entity_Argument_List;
Fld_2 : Bare_Argument_List;
Len : Integer;
Is_Equal : Boolean;
Not_Val : Boolean;
Scope_Result : Boolean;
Result_Var : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1746 .do Result_Var nodes.lkt:2867



--# expr-start 1742 DeclAnnotation.args Fld nodes.lkt:2867







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Decl_Annotation_Args (Node => Ent.Node.Decl_Annotation_F_Args, Info => Ent.Info);
--# expr-done 1742
Var_Expr := Fld;





if Var_Expr /= No_Entity_Decl_Annotation_Args then
   



   --# scope-start



--# expr-start 1745 NotEqual Not_Val nodes.lkt:2867
--# expr-start 1744 .length Len nodes.lkt:2867



--# expr-start 1743 DeclAnnotationArgs.args Fld_1 nodes.lkt:2867







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Argument_List (Node => Var_Expr.Node.Decl_Annotation_Args_F_Args, Info => Var_Expr.Info);
--# expr-done 1743





Fld_2 := Fld_1.Node; 
Len := Length (Fld_2); 
--# expr-done 1744

Is_Equal := Len = 0; 
Not_Val := not (Is_Equal); 
--# expr-done 1745
Scope_Result := Not_Val;


   --# end


   Result_Var := Scope_Result;
else
   
   Result_Var := False;
end if;



--# expr-done 1746

         Property_Result := Result_Var;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Decl_Annotation_P_Xref_Entry_Point;
--# end

   







--# property-start DeclAnnotation.with_dynvars_equation nodes.lkt:2871
pragma Warnings (Off, "is not referenced");

function Decl_Annotation_P_With_Dynvars_Equation
  
  (Node : Bare_Decl_Annotation
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Decl_Annotation :=
     Bare_Decl_Annotation (Node);
     Ent : Internal_Entity_Decl_Annotation :=
       Internal_Entity_Decl_Annotation'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_256 with Inline_Always;
            procedure Finalizer_Scope_668 with Inline_Always;
            procedure Finalizer_Scope_669 with Inline_Always;
            procedure Finalizer_Scope_670 with Inline_Always;
            procedure Finalizer_Scope_671 with Inline_Always;

      Fld : Internal_Entity_Decl_Annotation_Args;
Var_Expr : Internal_Entity_Decl_Annotation_Args;
Fld_1 : Internal_Entity_Argument_List;
Item : Internal_Entity_Argument;
Fld_2 : Logic_Equation;
True_Rel : Logic_Equation;
Fld_3 : Internal_Entity_Expr;
Is_A : Boolean;
Error_Location : Bare_Lkt_Node;
Fld_4 : Bare_Argument;
Fld_5 : Internal_Entity_Expr;
Cast_Result : Internal_Entity_Ref_Id;
Fld_6 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
If_Result : Logic_Equation;
Fld_7 : Internal_Entity_Ref_Id;
Is_Null : Boolean;
Not_Val : Boolean;
Error_Location_1 : Bare_Lkt_Node;
Fld_8 : Bare_Argument;
Fld_9 : Internal_Entity_Ref_Id;
Fld_10 : Logic_Var;
Pred_1 : Logic_Equation;
Cast_Result_2 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_1 : Logic_Equation;
Scope_Result_1 : Logic_Equation;
If_Result_1 : Logic_Equation;
And_Pred : Logic_Equation;
Fld_11 : Bare_Argument_List;
Fld_12 : Internal_Entity_Info;
Bare_Item : Bare_Argument;
As_Entity : Internal_Entity_Argument;
Is_Null_1 : Boolean;
If_Result_2 : Internal_Entity_Argument;
Map_Result : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;
Scope_Result_2 : Logic_Equation;
True_Rel_1 : Logic_Equation;
Result_Var : Logic_Equation;

            procedure Finalizer_Scope_256 is
            begin
                     Dec_Ref (Scope_Result_2);
                     Dec_Ref (True_Rel_1);
                     Dec_Ref (Result_Var);
            end Finalizer_Scope_256;
            procedure Finalizer_Scope_668 is
            begin
                     Dec_Ref (Map_Result);
                     Dec_Ref (Logic_Boolean_Op);
            end Finalizer_Scope_668;
            procedure Finalizer_Scope_669 is
            begin
                     Dec_Ref (Fld_2);
                     Dec_Ref (True_Rel);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (If_Result);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (If_Result_1);
                     Dec_Ref (And_Pred);
            end Finalizer_Scope_669;
            procedure Finalizer_Scope_670 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_670;
            procedure Finalizer_Scope_671 is
            begin
                     Dec_Ref (Pred_1);
                     Dec_Ref (Dyn_Var_Bind_Result_1);
            end Finalizer_Scope_671;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1772 .do Result_Var nodes.lkt:2872



--# expr-start 1747 DeclAnnotation.args Fld nodes.lkt:2872







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Decl_Annotation_Args (Node => Ent.Node.Decl_Annotation_F_Args, Info => Ent.Info);
--# expr-done 1747
Var_Expr := Fld;





if Var_Expr /= No_Entity_Decl_Annotation_Args then
   



   --# scope-start



--# expr-start 1770 .logic_all Logic_Boolean_Op nodes.lkt:2873








   

   --# expr-start 1748 DeclAnnotationArgs.args Fld_1 nodes.lkt:2873







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Argument_List (Node => Var_Expr.Node.Decl_Annotation_Args_F_Args, Info => Var_Expr.Info);
--# expr-done 1748









Fld_11 := Fld_1.Node;

   
      declare
         Map_Result_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      if Fld_11 = null then
         
      Map_Result := Create_Logic_Equation_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Argument_List := Fld_11;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null_1 := Bare_Item = null; 
if Is_Null_1 then
   
   If_Result_2 := No_Entity_Argument;
else
   








Fld_12 := Fld_1.Info;

As_Entity := (Info => Fld_12, Node => Bare_Item); 
   If_Result_2 := As_Entity;
end if;



                  Item := If_Result_2; 

            
   --# scope-start


               --# bind p Item

            
         
         
      --# expr-start 1769 LogicAnd And_Pred nodes.lkt:2875
--# expr-start 1749 Argument.xref_equation Fld_2 nodes.lkt:2875







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_2 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 1749
--# expr-start 1768 If If_Result_1 nodes.lkt:2877



--# expr-start 1752 Not Not_Val nodes.lkt:2877
--# expr-start 1751 .is_null Is_Null nodes.lkt:2877
--# expr-start 1750 Argument.name Fld_7 nodes.lkt:2877







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Create_Internal_Entity_Ref_Id (Node => Item.Node.Argument_F_Name, Info => Item.Info);
--# expr-done 1750
Is_Null := Fld_7.Node = null; 
--# expr-done 1751
Not_Val := not (Is_Null); 
--# expr-done 1752
if Not_Val then
   



   --# scope-start



--# expr-start 1757 bind Dyn_Var_Bind_Result_1 nodes.lkt:2879





--# expr-start 1753 'Entity[Argument].node' Fld_8 nodes.lkt:2879









Fld_8 := Item.Node;
--# expr-done 1753



   
      Cast_Result_2 := Fld_8;


Error_Location_1 := Cast_Result_2; 
--# expr-start 1756 LogicPropagate Pred_1 nodes.lkt:2880
--# expr-start 1755 RefId.ref_var Fld_10 nodes.lkt:2880



--# expr-start 1754 Argument.name Fld_9 nodes.lkt:2880







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Create_Internal_Entity_Ref_Id (Node => Item.Node.Argument_F_Name, Info => Item.Info);
--# expr-done 1754



   if Fld_9.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Fld_9.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 1755
Fld_10.Value := No_Entity;
Entity_Vars.Reset (Fld_10);

Pred_1 := Solver.Create_Predicate (Fld_10, Create_Decl_P_Is_Dynvar_0_Predicate (Error_Location_1)); 
--# expr-done 1756
Dyn_Var_Bind_Result_1 := Pred_1; Inc_Ref (Dyn_Var_Bind_Result_1);
--# expr-done 1757
Scope_Result_1 := Dyn_Var_Bind_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_671;


   If_Result_1 := Scope_Result_1;
else
   --# expr-start 1767 If If_Result nodes.lkt:2877



--# expr-start 1759 IsA Is_A nodes.lkt:2882
--# expr-start 1758 Argument.value Fld_3 nodes.lkt:2882







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 1758
Is_A := Fld_3.Node /= null 
and then Fld_3.Node.Kind in Lkt_Ref_Id_Range; 
--# expr-done 1759
if Is_A then
   



   --# scope-start



--# expr-start 1765 bind Dyn_Var_Bind_Result nodes.lkt:2884





--# expr-start 1760 'Entity[Argument].node' Fld_4 nodes.lkt:2884









Fld_4 := Item.Node;
--# expr-done 1760



   
      Cast_Result_1 := Fld_4;


Error_Location := Cast_Result_1; 
--# expr-start 1764 LogicPropagate Pred nodes.lkt:2885
--# expr-start 1763 RefId.ref_var Fld_6 nodes.lkt:2885



--# expr-start 1762 Cast Cast_Result nodes.lkt:2885





--# expr-start 1761 Argument.value Fld_5 nodes.lkt:2885







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 1761



   if Fld_5.Node = null
      or else Fld_5.Node.Kind in Lkt_Ref_Id_Range
   then
      
      Cast_Result := Create_Internal_Entity_Ref_Id
        (Node => Fld_5.Node,
         Info => Fld_5.Info);

   else
         Cast_Result := No_Entity_Ref_Id;
   end if;


--# expr-done 1762



   if Cast_Result.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Cast_Result.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 1763
Fld_6.Value := No_Entity;
Entity_Vars.Reset (Fld_6);

Pred := Solver.Create_Predicate (Fld_6, Create_Decl_P_Is_Dynvar_0_Predicate (Error_Location)); 
--# expr-done 1764
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 1765
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_670;


   If_Result := Scope_Result;
else
   --# expr-start 1766 LogicTrue True_Rel nodes.lkt:2887
True_Rel := Solver.Create_True ((if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:2887:26") else null)); 
--# expr-done 1766
   If_Result := True_Rel;
end if;

      Inc_Ref (If_Result);


--# expr-done 1767
   If_Result_1 := If_Result;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 1768
And_Pred := Create_And (Fld_2, If_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:2875:17") else null)); 
--# expr-done 1769
      

         declare
            Item_To_Append : constant Logic_Equation := And_Pred;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_669;



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:2873:33") else null)); 
--# expr-done 1770
Scope_Result_2 := Logic_Boolean_Op;
   Inc_Ref (Scope_Result_2);


   --# end
      Finalizer_Scope_668;


   Result_Var := Scope_Result_2;
else
   --# expr-start 1771 LogicTrue True_Rel_1 nodes.lkt:2890
True_Rel_1 := Solver.Create_True ((if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:2890:25") else null)); 
--# expr-done 1771
   Result_Var := True_Rel_1;
end if;

      Inc_Ref (Result_Var);


--# expr-done 1772

         Property_Result := Result_Var;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_256;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_256;
                     Finalizer_Scope_668;
                     Finalizer_Scope_669;
                     Finalizer_Scope_670;
                     Finalizer_Scope_671;




            raise;
      end;



   return Property_Result;
end Decl_Annotation_P_With_Dynvars_Equation;
--# end

   







--# property-start DeclAnnotation.xref_equation nodes.lkt:2895
pragma Warnings (Off, "is not referenced");

function Decl_Annotation_P_Xref_Equation
  
  (Node : Bare_Decl_Annotation
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Decl_Annotation :=
     Bare_Decl_Annotation (Node);
     Ent : Internal_Entity_Decl_Annotation :=
       Internal_Entity_Decl_Annotation'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_257 with Inline_Always;

      True_Rel : Logic_Equation;
Fld : Internal_Entity_Id;
Fld_1 : Bare_Id;
Sym : Symbol_Type;
Sym_1 : Symbol_Type;
Is_Equal : Boolean;
Fld_2 : Logic_Equation;
If_Result : Logic_Equation;

            procedure Finalizer_Scope_257 is
            begin
                     Dec_Ref (True_Rel);
                     Dec_Ref (Fld_2);
                     Dec_Ref (If_Result);
            end Finalizer_Scope_257;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1779 If If_Result nodes.lkt:2896



--# expr-start 1776 Eq Is_Equal nodes.lkt:2896
--# expr-start 1774 .symbol Sym nodes.lkt:2896



--# expr-start 1773 DeclAnnotation.name Fld nodes.lkt:2896







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Id (Node => Ent.Node.Decl_Annotation_F_Name, Info => Ent.Info);
--# expr-done 1773





Fld_1 := Fld.Node; 
Sym := Get_Symbol (Fld_1); 
--# expr-done 1774
--# expr-start 1775 SymbolLiteral Sym_1 nodes.lkt:2896
Sym_1 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_With_Dynvars); 
--# expr-done 1775
Is_Equal := Sym = Sym_1; 
--# expr-done 1776
if Is_Equal then
   --# expr-start 1777 DeclAnnotation.with_dynvars_equation Fld_2 nodes.lkt:2897







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DeclAnnotation.with_dynvars_equation
Fld_2 := Liblktlang.Implementation.Decl_Annotation_P_With_Dynvars_Equation (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1777
   If_Result := Fld_2;
else
   --# expr-start 1778 LogicTrue True_Rel nodes.lkt:2898
True_Rel := Solver.Create_True ((if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:2898:14") else null)); 
--# expr-done 1778
   If_Result := True_Rel;
end if;

      Inc_Ref (If_Result);


--# expr-done 1779

         Property_Result := If_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_257;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_257;




            raise;
      end;



   return Property_Result;
end Decl_Annotation_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Decl_Annotation_Args
   --

   



      
      procedure Initialize_Fields_For_Decl_Annotation_Args
        (Self : Bare_Decl_Annotation_Args
         ; Decl_Annotation_Args_F_Args : Bare_Argument_List
        ) is
      begin

            Self.Decl_Annotation_Args_F_Args := Decl_Annotation_Args_F_Args;
         

      end Initialize_Fields_For_Decl_Annotation_Args;

      
   function Decl_Annotation_Args_F_Args
     (Node : Bare_Decl_Annotation_Args) return Bare_Argument_List
   is
      

   begin
         
         return Node.Decl_Annotation_Args_F_Args;
      
   end;




   


      

   --
   --  Primitives for Bare_Dyn_Env_Wrapper
   --

   



      
      procedure Initialize_Fields_For_Dyn_Env_Wrapper
        (Self : Bare_Dyn_Env_Wrapper
        ) is
      begin

         
      Self.Dyn_Env_Wrapper_F_Names := No_Symbol_Type_Array_Type;
      Self.Dyn_Env_Wrapper_F_Types := No_Internal_Entity_Type_Decl_Array_Type;
      Self.Internal_Bare_Dyn_Env_Wrapper_Lf_State_Dynenvwrapper_Instantiation_Env_20 := Uninitialized;
      Self.Internal_Bare_Dyn_Env_Wrapper_Lf_Stg_Dynenvwrapper_Instantiation_Env_21 := Empty_Env;

      end Initialize_Fields_For_Dyn_Env_Wrapper;


   







--# property-start DynEnvWrapper.dynenvwrapper_instantiation_env nodes.lkt:2918
pragma Warnings (Off, "is not referenced");

function Dyn_Env_Wrapper_F_Dynenvwrapper_Instantiation_Env
  
  (Node : Bare_Dyn_Env_Wrapper
  )

   return Lexical_Env
is
   Self : Bare_Dyn_Env_Wrapper :=
     Bare_Dyn_Env_Wrapper (Node);
      --# bind node Self

   


   Property_Result : Lexical_Env;

      
            procedure Finalizer_Scope_258 with Inline_Always;

      Dyn_Env : Lexical_Env := Empty_Env;

            procedure Finalizer_Scope_258 is
            begin
                     Dec_Ref (Dyn_Env);
            end Finalizer_Scope_258;


begin
   --# property-body-start

   pragma Assert (Self = Node);

      case Self.Internal_Bare_Dyn_Env_Wrapper_Lf_State_Dynenvwrapper_Instantiation_Env_20 is
         when Uninitialized =>
            null;

         when Initialized =>
            Property_Result :=
              Self.Internal_Bare_Dyn_Env_Wrapper_Lf_Stg_Dynenvwrapper_Instantiation_Env_21;
               Inc_Ref (Property_Result);
            return Property_Result;

         when Error_Initialization_State =>
            Reraise_Initialization_Error
              (Self,
               Self.Internal_Bare_Dyn_Env_Wrapper_Lf_State_Dynenvwrapper_Instantiation_Env_20,
               "lazy field memoization");
      end case;


      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1780 DynamicLexicalEnv Dyn_Env nodes.lkt:2919


Dyn_Env := Create_Dynamic_Lexical_Env (Self, Dyn_Env_Wrapper_P_Instantiation_Bindings'Access, Lkt_Node_P_Shed_Rebindings'Access, False, Self.Unit.Context.Symbols); 
--# expr-done 1780

         Property_Result := Dyn_Env;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_258;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_258;

               Self.Internal_Bare_Dyn_Env_Wrapper_Lf_State_Dynenvwrapper_Instantiation_Env_20 :=
                 Initialization_Error (Exc);



            raise;
      end;

      Self.Internal_Bare_Dyn_Env_Wrapper_Lf_State_Dynenvwrapper_Instantiation_Env_20 := Initialized;
      Self.Internal_Bare_Dyn_Env_Wrapper_Lf_Stg_Dynenvwrapper_Instantiation_Env_21 := Property_Result;
         Inc_Ref (Property_Result);


   return Property_Result;
end Dyn_Env_Wrapper_F_Dynenvwrapper_Instantiation_Env;
--# end

   







--# property-start DynEnvWrapper.instantiation_bindings nodes.lkt:2929
pragma Warnings (Off, "is not referenced");

function Dyn_Env_Wrapper_P_Instantiation_Bindings
  
  (Node : Bare_Dyn_Env_Wrapper
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Inner_Env_Assoc_Array_Access
is
   Self : Bare_Dyn_Env_Wrapper :=
     Bare_Dyn_Env_Wrapper (Node);
     Ent : Internal_Entity_Dyn_Env_Wrapper :=
       Internal_Entity_Dyn_Env_Wrapper'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Inner_Env_Assoc_Array_Access;

      
            procedure Finalizer_Scope_260 with Inline_Always;
            procedure Finalizer_Scope_672 with Inline_Always;

      Fld : Symbol_Type_Array_Access;
Index : Integer;
Fld_1 : Internal_Entity_Type_Decl_Array_Access;
Get_Result : Internal_Entity_Type_Decl;
Fld_2 : Bare_Type_Decl;
Fld_3 : Internal_Entity_Type_Decl_Array_Access;
Get_Result_1 : Internal_Entity_Type_Decl;
Fld_4 : Internal_Entity_Info;
Fld_5 : Env_Rebindings;
Cast_Result : Bare_Lkt_Node;
New_Struct : Internal_Inner_Env_Assoc;
Map_Result : Internal_Inner_Env_Assoc_Array_Access;

            procedure Finalizer_Scope_260 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Map_Result);
            end Finalizer_Scope_260;
            procedure Finalizer_Scope_672 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Fld_3);
            end Finalizer_Scope_672;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1790 .imap Map_Result nodes.lkt:2930








   

   --# expr-start 1781 DynEnvWrapper.names Fld nodes.lkt:2930







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Ent.Node.Dyn_Env_Wrapper_F_Names;
Inc_Ref (Fld);
--# expr-done 1781

   
      declare
         Map_Result_Vec : Internal_Inner_Env_Assoc_Vectors.Vector;
      begin
   

   

      
         Index := 0;

      declare
         
         Collection : constant Symbol_Type_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind name Item
               --# bind i Index

            
         
         
      --# expr-start 1789 'New[InnerEnvAssoc]' New_Struct nodes.lkt:2932


--# expr-start 1785 EntityInfo.rebindings Fld_5 nodes.lkt:2935



--# expr-start 1784 'Entity[TypeDecl].info' Fld_4 nodes.lkt:2935



--# expr-start 1783 .at Get_Result_1 nodes.lkt:2935

--# expr-start 1782 DynEnvWrapper.types Fld_3 nodes.lkt:2935







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Ent.Node.Dyn_Env_Wrapper_F_Types;
Inc_Ref (Fld_3);
--# expr-done 1782


Get_Result_1 := Get (Self, Fld_3, Index, True); 
--# expr-done 1783





Fld_4 := Get_Result_1.Info;
--# expr-done 1784





Fld_5 := Fld_4.Rebindings;
--# expr-done 1785





--# expr-start 1788 'Entity[TypeDecl].node' Fld_2 nodes.lkt:2934



--# expr-start 1787 .at Get_Result nodes.lkt:2934

--# expr-start 1786 DynEnvWrapper.types Fld_1 nodes.lkt:2934







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Ent.Node.Dyn_Env_Wrapper_F_Types;
Inc_Ref (Fld_1);
--# expr-done 1786


Get_Result := Get (Self, Fld_1, Index, True); 
--# expr-done 1787





Fld_2 := Get_Result.Node;
--# expr-done 1788



   
      Cast_Result := Fld_2;


New_Struct := (Key => Item, Metadata => No_Metadata, Rebindings => Fld_5, Value => Cast_Result); 
--# expr-done 1789
      

         declare
            Item_To_Append : constant Internal_Inner_Env_Assoc := New_Struct;
         begin
            Internal_Inner_Env_Assoc_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_672;



               Index := Index + 1;
         end loop;
      end;
   

   

         Map_Result := Create_Internal_Inner_Env_Assoc_Array
           (Items_Count => Natural (Internal_Inner_Env_Assoc_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Inner_Env_Assoc_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Inner_Env_Assoc_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Inner_Env_Assoc_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1790

         Property_Result := Map_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_260;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_260;
                     Finalizer_Scope_672;




            raise;
      end;



   return Property_Result;
end Dyn_Env_Wrapper_P_Instantiation_Bindings;
--# end


   
function Dyn_Env_Wrapper_P_Instantiation_Bindings
  (E : Entity
  ) return Internal_Inner_Env_Assoc_Array_Access
is
   

      E_Info : Internal_Entity_Info :=
         Shed_Rebindings (E.Info, Children_Env (E.Node));
      
begin
   
      if E.Node /= null
         and then E.Node.Kind not in Lkt_Dyn_Env_Wrapper_Range
      then
         Raise_Property_Exception
           (E.Node,
            Property_Error'Identity,
            "mismatching node type");
      end if;

   declare
      Result : constant Internal_Inner_Env_Assoc_Array_Access :=
         Dyn_Env_Wrapper_P_Instantiation_Bindings (E.Node, E_Info);
   begin
         return Result;
   end;
end;


   


      

   --
   --  Primitives for Bare_Elsif_Branch
   --

   



      
      procedure Initialize_Fields_For_Elsif_Branch
        (Self : Bare_Elsif_Branch
         ; Elsif_Branch_F_Cond_Expr : Bare_Expr
         ; Elsif_Branch_F_Then_Expr : Bare_Expr
        ) is
      begin

            Self.Elsif_Branch_F_Cond_Expr := Elsif_Branch_F_Cond_Expr;
            Self.Elsif_Branch_F_Then_Expr := Elsif_Branch_F_Then_Expr;
         

      end Initialize_Fields_For_Elsif_Branch;

      
   function Elsif_Branch_F_Cond_Expr
     (Node : Bare_Elsif_Branch) return Bare_Expr
   is
      

   begin
         
         return Node.Elsif_Branch_F_Cond_Expr;
      
   end;

      
   function Elsif_Branch_F_Then_Expr
     (Node : Bare_Elsif_Branch) return Bare_Expr
   is
      

   begin
         
         return Node.Elsif_Branch_F_Then_Expr;
      
   end;




   


      

   --
   --  Primitives for Bare_Enum_Class_Case
   --

   



      
      procedure Initialize_Fields_For_Enum_Class_Case
        (Self : Bare_Enum_Class_Case
         ; Enum_Class_Case_F_Decls : Bare_Enum_Class_Alt_Decl_List
        ) is
      begin

            Self.Enum_Class_Case_F_Decls := Enum_Class_Case_F_Decls;
         

      end Initialize_Fields_For_Enum_Class_Case;

      
   function Enum_Class_Case_F_Decls
     (Node : Bare_Enum_Class_Case) return Bare_Enum_Class_Alt_Decl_List
   is
      

   begin
         
         return Node.Enum_Class_Case_F_Decls;
      
   end;




   


      

   --
   --  Primitives for Bare_Excludes_Null
   --

   





   







--# property-start '[dispatcher]ExcludesNull.as_bool' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Excludes_Null_P_As_Bool
  
  (Node : Bare_Excludes_Null
  )

   return Boolean
is
   Self : Bare_Excludes_Null :=
     Bare_Excludes_Null (Node);
      --# bind node Self

   


   Property_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Excludes_Null (Self.Kind) is
               when Lkt_Excludes_Null_Absent =>
                  --# property-call-start ExcludesNull.Absent.as_bool
                  Property_Result := Excludes_Null_Absent_P_As_Bool
                    (Self
                    );
                  --# end
               when Lkt_Excludes_Null_Present =>
                  --# property-call-start ExcludesNull.Present.as_bool
                  Property_Result := Excludes_Null_Present_P_As_Bool
                    (Self
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Excludes_Null_P_As_Bool;
--# end



   


      

   --
   --  Primitives for Bare_Excludes_Null_Absent
   --

   





   







--# property-start ExcludesNull.Absent.as_bool nodes.lkt:2958
pragma Warnings (Off, "is not referenced");

function Excludes_Null_Absent_P_As_Bool
  
  (Node : Bare_Excludes_Null_Absent
  )

   return Boolean
is
   Self : Bare_Excludes_Null_Absent :=
     Bare_Excludes_Null_Absent (Node);
      --# bind node Self

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := False;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Excludes_Null_Absent_P_As_Bool;
--# end



   


      

   --
   --  Primitives for Bare_Excludes_Null_Present
   --

   





   







--# property-start ExcludesNull.Present.as_bool nodes.lkt:2958
pragma Warnings (Off, "is not referenced");

function Excludes_Null_Present_P_As_Bool
  
  (Node : Bare_Excludes_Null_Present
  )

   return Boolean
is
   Self : Bare_Excludes_Null_Present :=
     Bare_Excludes_Null_Present (Node);
      --# bind node Self

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := True;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Excludes_Null_Present_P_As_Bool;
--# end



   


      

   --
   --  Primitives for Bare_Expr
   --

   



      
      procedure Initialize_Fields_For_Expr
        (Self : Bare_Expr
        ) is
      begin

         
      Self.Expr_F_Expected_Type_Var := Null_Var_Record;
      Self.Expr_F_Actual_Type_Var := Null_Var_Record;
      Self.Expr_F_Generic_Func_Type_Var := Null_Var_Record;

      end Initialize_Fields_For_Expr;


   







--# property-start Expr.is_simple_call_expr nodes.lkt:3145
pragma Warnings (Off, "is not referenced");

function Expr_P_Is_Simple_Call_Expr
  
  (Node : Bare_Expr
  )

   return Boolean
is
   Self : Bare_Expr :=
     Bare_Expr (Node);
      --# bind node Self

   


   Property_Result : Boolean;

      

      Is_A : Boolean;
Cast_Result : Bare_Call_Expr;
Fld : Bare_Expr;
Is_A_1 : Boolean;
If_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1795 BooleanAnd If_Result nodes.lkt:3146



--# expr-start 1791 IsA Is_A nodes.lkt:3146

Is_A := Self /= null 
and then Self.Kind in Lkt_Call_Expr_Range; 
--# expr-done 1791
if Is_A then
   --# expr-start 1794 IsA Is_A_1 nodes.lkt:3146
--# expr-start 1793 BaseCallExpr.name Fld nodes.lkt:3146



--# expr-start 1792 Cast Cast_Result nodes.lkt:3146









   if Self = null
      or else Self.Kind in Lkt_Call_Expr_Range
   then
      
      Cast_Result := Self;

   else
         Cast_Result := No_Bare_Lkt_Node;
   end if;


--# expr-done 1792



   if Cast_Result = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Cast_Result.Base_Call_Expr_F_Name;
--# expr-done 1793
Is_A_1 := Fld /= null 
and then Fld.Kind in Lkt_Ref_Id_Range; 
--# expr-done 1794
   If_Result := Is_A_1;
else
   
   If_Result := False;
end if;



--# expr-done 1795

         Property_Result := If_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Expr_P_Is_Simple_Call_Expr;
--# end

   







--# property-start Expr.xref_entry_point nodes.lkt:3148
pragma Warnings (Off, "is not referenced");

function Expr_P_Xref_Entry_Point
  
  (Node : Bare_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Expr :=
     Bare_Expr (Node);
     Ent : Internal_Entity_Expr :=
       Internal_Entity_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Fld : Bare_Lkt_Node;
Ignored : Bare_Cast_Expr;
Ignored_1 : Bare_Isa;
Ignored_2 : Bare_Match_Expr;
Ignored_3 : Bare_Lambda_Expr;
Fld_1 : Boolean;
Local_P : Bare_Dot_Expr;
Fld_2 : Bare_Expr;
Cast_Result : Bare_Expr;
Is_Equal : Boolean;
Local_A : Bare_Argument;
Fld_3 : Bare_Expr;
Cast_Result_1 : Bare_Expr;
Is_Equal_1 : Boolean;
Fld_4 : Boolean;
If_Result : Boolean;
Fld_5 : Bare_Lkt_Node;
Fld_6 : Bare_Lkt_Node;
Fld_7 : Bare_Lkt_Node;
Is_A : Boolean;
Not_Val : Boolean;
If_Result_1 : Boolean;
Local_P_1 : Bare_Call_Expr;
Fld_8 : Bare_Expr;
Cast_Result_2 : Bare_Expr;
Is_Equal_2 : Boolean;
Fld_9 : Boolean;
If_Result_2 : Boolean;
Is_A_1 : Boolean;
Not_Val_1 : Boolean;
If_Result_3 : Boolean;
Ignored_4 : Bare_Lkt_Node;
Match_Prefix : Bare_Lkt_Node;
Cast_Result_3 : Bare_Cast_Expr;
Let_Result : Boolean;
Scope_Result : Boolean;
Cast_Result_4 : Bare_Isa;
Let_Result_1 : Boolean;
Scope_Result_1 : Boolean;
Cast_Result_5 : Bare_Match_Expr;
Let_Result_2 : Boolean;
Scope_Result_2 : Boolean;
Cast_Result_6 : Bare_Lambda_Expr;
Let_Result_3 : Boolean;
Scope_Result_3 : Boolean;
Cast_Result_7 : Bare_Dot_Expr;
Let_Result_4 : Boolean;
Scope_Result_4 : Boolean;
Cast_Result_8 : Bare_Argument;
Let_Result_5 : Boolean;
Scope_Result_5 : Boolean;
Cast_Result_9 : Bare_Call_Expr;
Let_Result_6 : Boolean;
Scope_Result_6 : Boolean;
Cast_Result_10 : Bare_Lkt_Node;
Let_Result_7 : Boolean;
Scope_Result_7 : Boolean;
Match_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1817 Match Match_Result nodes.lkt:3148






--# expr-start 1796 .parent Fld nodes.lkt:3148







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Self.Parent; 
--# expr-done 1796



   if Fld = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := Fld; 

case Lkt_Lkt_Node (Match_Prefix.Kind) is
         when Lkt_Cast_Expr =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_3 := Match_Prefix;


Ignored := Cast_Result_3; 
--# bind _ Ignored

Let_Result := True; 
--# end
Scope_Result := Let_Result;


   --# end


            Match_Result := Scope_Result; 
         when Lkt_Isa =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_4 := Match_Prefix;


Ignored_1 := Cast_Result_4; 
--# bind _ Ignored_1

Let_Result_1 := True; 
--# end
Scope_Result_1 := Let_Result_1;


   --# end


            Match_Result := Scope_Result_1; 
         when Lkt_Match_Expr =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_5 := Match_Prefix;


Ignored_2 := Cast_Result_5; 
--# bind _ Ignored_2

Let_Result_2 := True; 
--# end
Scope_Result_2 := Let_Result_2;


   --# end


            Match_Result := Scope_Result_2; 
         when Lkt_Lambda_Expr =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_6 := Match_Prefix;


Ignored_3 := Cast_Result_6; 
--# bind _ Ignored_3
--# expr-start 1797 Expr.has_context_free_type Fld_1 nodes.lkt:3152







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1797
Let_Result_3 := Fld_1; 
--# end
Scope_Result_3 := Let_Result_3;


   --# end


            Match_Result := Scope_Result_3; 
         when Lkt_Dot_Expr =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_7 := Match_Prefix;


Local_P := Cast_Result_7; 
--# bind p Local_P
--# expr-start 1799 Eq Is_Equal nodes.lkt:3153





--# expr-start 1798 DotExpr.prefix Fld_2 nodes.lkt:3153







   if Local_P = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Local_P.Dot_Expr_F_Prefix;
--# expr-done 1798



   
      Cast_Result := Fld_2;



Is_Equal := Cast_Result = Self; 
--# expr-done 1799
Let_Result_4 := Is_Equal; 
--# end
Scope_Result_4 := Let_Result_4;


   --# end


            Match_Result := Scope_Result_4; 
         when Lkt_Argument =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_8 := Match_Prefix;


Local_A := Cast_Result_8; 
--# bind a Local_A
--# expr-start 1809 BooleanAnd If_Result_1 nodes.lkt:3155



--# expr-start 1803 BooleanAnd If_Result nodes.lkt:3155



--# expr-start 1801 Eq Is_Equal_1 nodes.lkt:3155





--# expr-start 1800 Argument.value Fld_3 nodes.lkt:3155







   if Local_A = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Local_A.Argument_F_Value;
--# expr-done 1800



   
      Cast_Result_1 := Fld_3;



Is_Equal_1 := Cast_Result_1 = Self; 
--# expr-done 1801
if Is_Equal_1 then
   --# expr-start 1802 Expr.has_context_free_type Fld_4 nodes.lkt:3155







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_4 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1802
   If_Result := Fld_4;
else
   
   If_Result := False;
end if;



--# expr-done 1803
if If_Result then
   --# expr-start 1808 Not Not_Val nodes.lkt:3156
--# expr-start 1807 IsA Is_A nodes.lkt:3156
--# expr-start 1806 .parent Fld_7 nodes.lkt:3156



--# expr-start 1805 .parent Fld_6 nodes.lkt:3156



--# expr-start 1804 .parent Fld_5 nodes.lkt:3156







   if Local_A = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Local_A.Parent; 
--# expr-done 1804



   if Fld_5 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Fld_5.Parent; 
--# expr-done 1805



   if Fld_6 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Fld_6.Parent; 
--# expr-done 1806
Is_A := Fld_7 /= null 
and then Fld_7.Kind in Lkt_Decl_Annotation_Range; 
--# expr-done 1807
Not_Val := not (Is_A); 
--# expr-done 1808
   If_Result_1 := Not_Val;
else
   
   If_Result_1 := False;
end if;



--# expr-done 1809
Let_Result_5 := If_Result_1; 
--# end
Scope_Result_5 := Let_Result_5;


   --# end


            Match_Result := Scope_Result_5; 
         when Lkt_Call_Expr =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_9 := Match_Prefix;


Local_P_1 := Cast_Result_9; 
--# bind p Local_P_1
--# expr-start 1816 BooleanAnd If_Result_3 nodes.lkt:3158



--# expr-start 1813 BooleanAnd If_Result_2 nodes.lkt:3158



--# expr-start 1811 Eq Is_Equal_2 nodes.lkt:3158





--# expr-start 1810 BaseCallExpr.name Fld_8 nodes.lkt:3158







   if Local_P_1 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Local_P_1.Base_Call_Expr_F_Name;
--# expr-done 1810



   
      Cast_Result_2 := Fld_8;



Is_Equal_2 := Cast_Result_2 = Self; 
--# expr-done 1811
if Is_Equal_2 then
   --# expr-start 1812 Expr.has_context_free_type Fld_9 nodes.lkt:3158







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_9 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1812
   If_Result_2 := Fld_9;
else
   
   If_Result_2 := False;
end if;



--# expr-done 1813
if If_Result_2 then
   --# expr-start 1815 Not Not_Val_1 nodes.lkt:3159
--# expr-start 1814 IsA Is_A_1 nodes.lkt:3159

Is_A_1 := Ent.Node /= null 
and then Ent.Node.Kind in Lkt_Ref_Id_Range | Lkt_Dot_Expr_Range; 
--# expr-done 1814
Not_Val_1 := not (Is_A_1); 
--# expr-done 1815
   If_Result_3 := Not_Val_1;
else
   
   If_Result_3 := False;
end if;



--# expr-done 1816
Let_Result_6 := If_Result_3; 
--# end
Scope_Result_6 := Let_Result_6;


   --# end


            Match_Result := Scope_Result_6; 
         when Lkt_Error_Lexer_Case_Rule_Alt .. Lkt_Array_Literal | Lkt_Logic_Predicate .. Lkt_Block_Expr | Lkt_Error_On_Null .. Lkt_If_Expr | Lkt_Keep_Expr | Lkt_Big_Num_Lit .. Lkt_Logic_Unify | Lkt_Not_Expr .. Lkt_Var_Bind =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_10 := Match_Prefix;


Ignored_4 := Cast_Result_10; 
--# bind _ Ignored_4

Let_Result_7 := False; 
--# end
Scope_Result_7 := Let_Result_7;


   --# end


            Match_Result := Scope_Result_7; 
end case;

--# expr-done 1817

         Property_Result := Match_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Expr_P_Xref_Entry_Point;
--# end

   







--# property-start '[dispatcher]Expr.get_type' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Expr_P_Get_Type
  
  (Node : Bare_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Expr :=
     Bare_Expr (Node);
     Ent : Internal_Entity_Expr :=
       Internal_Entity_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Expr (Self.Kind) is
               when Lkt_Any_Of .. Lkt_Id | Lkt_Module_Ref_Id .. Lkt_Un_Op =>
                  --# property-call-start 'Expr.[root-static]get_type'
                  Property_Result := Expr_P_Get_Type
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Def_Id =>
                  --# property-call-start DefId.get_type
                  Property_Result := Def_Id_P_Get_Type
                    (Self
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Expr_P_Get_Type;
--# end

   







--# property-start Expr.get_generic_type nodes.lkt:3176
pragma Warnings (Off, "is not referenced");

function Expr_P_Get_Generic_Type
  
  (Node : Bare_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Expr :=
     Bare_Expr (Node);
     Ent : Internal_Entity_Expr :=
       Internal_Entity_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_267 with Inline_Always;

      Fld : Internal_Entity_Array_Access;
Fld_1 : Boolean;
Find_Result : Internal_Entity;
Var_Expr : Internal_Entity;
Fld_2 : Boolean;
Result_Var : Boolean;
Fld_3 : Logic_Var;
Is_Logic_Var_Defined : Boolean;
Eq_Solution : Internal_Entity;
If_Result : Internal_Entity;
Cast_Result : Internal_Entity_Type_Decl;
If_Result_1 : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_267 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_267;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Expr_Expr_P_Get_Generic_Type,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Expr,
                                As_Bare_Expr => Self);
               Mmz_K.Items (2) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Entity_Type_Decl;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 1825 If If_Result_1 nodes.lkt:3177






--# expr-start 1820 .find Find_Result nodes.lkt:3178








   

   --# expr-start 1818 LktNode.parents Fld nodes.lkt:3178







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



Fld := Liblktlang.Implementation.Parents (Node => Ent.Node, With_Self => True, E_Info => Ent.Info);
--# expr-done 1818

   
      Find_Result := No_Entity;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind p Item

            
      --# expr-start 1819 LktNode.generic_type_entry_point Fld_1 nodes.lkt:3178







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.generic_type_entry_point
Fld_1 := Liblktlang.Implementation.Lkt_Node_P_Generic_Type_Entry_Point (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 1819
      if Fld_1 then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Fld_1;

         end loop;
      end;
   

   
   



--# expr-done 1820
Var_Expr := Find_Result;





if Var_Expr /= No_Entity then
   --# expr-start 1821 LktNode.solve_generic_types Fld_2 nodes.lkt:3178







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.solve_generic_types
Fld_2 := Liblktlang.Implementation.Lkt_Node_P_Solve_Generic_Types (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 1821
   Result_Var := Fld_2;
else
   
   Result_Var := False;
end if;



if Result_Var then
   --# expr-start 1824 Cast Cast_Result nodes.lkt:3180





--# expr-start 1823 .get_value If_Result nodes.lkt:3180



--# expr-start 1822 Expr.generic_func_type_var Fld_3 nodes.lkt:3180







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Ent.Node.Expr_F_Generic_Func_Type_Var'Unrestricted_Access;
--# expr-done 1822
Is_Logic_Var_Defined := Entity_Vars.Is_Defined (Fld_3); 
if Is_Logic_Var_Defined then
   
Eq_Solution := Entity_Vars.Get_Value (Fld_3); 
   If_Result := Eq_Solution;
else
   
   If_Result := No_Entity;
end if;



--# expr-done 1823



   if If_Result.Node = null
      or else If_Result.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => If_Result.Node,
         Info => If_Result.Info);

   else
         Cast_Result := No_Entity_Type_Decl;
   end if;


--# expr-done 1824
   If_Result_1 := Cast_Result;
else
   
   If_Result_1 := No_Entity_Type_Decl;
end if;



--# expr-done 1825

         Property_Result := If_Result_1;
         
   --# end
      Finalizer_Scope_267;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_267;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Entity_Type_Decl,
                     As_Internal_Entity_Type_Decl => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Expr_P_Get_Generic_Type;
--# end

   







--# property-start Expr.get_expected_type nodes.lkt:3187
pragma Warnings (Off, "is not referenced");

function Expr_P_Get_Expected_Type
  
  (Node : Bare_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Expr :=
     Bare_Expr (Node);
     Ent : Internal_Entity_Expr :=
       Internal_Entity_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_268 with Inline_Always;

      Fld : Internal_Entity_Array_Access;
Fld_1 : Boolean;
Find_Result : Internal_Entity;
Var_Expr : Internal_Entity;
Fld_2 : Boolean;
Result_Var : Boolean;
Fld_3 : Logic_Var;
Is_Logic_Var_Defined : Boolean;
Eq_Solution : Internal_Entity;
If_Result : Internal_Entity;
Cast_Result : Internal_Entity_Type_Decl;
If_Result_1 : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_268 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_268;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Expr_Expr_P_Get_Expected_Type,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Expr,
                                As_Bare_Expr => Self);
               Mmz_K.Items (2) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Entity_Type_Decl;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 1833 If If_Result_1 nodes.lkt:3188






--# expr-start 1828 .find Find_Result nodes.lkt:3189








   

   --# expr-start 1826 LktNode.parents Fld nodes.lkt:3189







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



Fld := Liblktlang.Implementation.Parents (Node => Ent.Node, With_Self => False, E_Info => Ent.Info);
--# expr-done 1826

   
      Find_Result := No_Entity;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind p Item

            
      --# expr-start 1827 LktNode.expected_type_entry_point Fld_1 nodes.lkt:3190







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.expected_type_entry_point
Fld_1 := Liblktlang.Implementation.Lkt_Node_P_Expected_Type_Entry_Point (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 1827
      if Fld_1 then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Fld_1;

         end loop;
      end;
   

   
   



--# expr-done 1828
Var_Expr := Find_Result;





if Var_Expr /= No_Entity then
   --# expr-start 1829 LktNode.solve_expected_types Fld_2 nodes.lkt:3189







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.solve_expected_types
Fld_2 := Liblktlang.Implementation.Lkt_Node_P_Solve_Expected_Types (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 1829
   Result_Var := Fld_2;
else
   
   Result_Var := False;
end if;



if Result_Var then
   --# expr-start 1832 Cast Cast_Result nodes.lkt:3193





--# expr-start 1831 .get_value If_Result nodes.lkt:3193



--# expr-start 1830 Expr.expected_type_var Fld_3 nodes.lkt:3193







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Ent.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 1830
Is_Logic_Var_Defined := Entity_Vars.Is_Defined (Fld_3); 
if Is_Logic_Var_Defined then
   
Eq_Solution := Entity_Vars.Get_Value (Fld_3); 
   If_Result := Eq_Solution;
else
   
   If_Result := No_Entity;
end if;



--# expr-done 1831



   if If_Result.Node = null
      or else If_Result.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => If_Result.Node,
         Info => If_Result.Info);

   else
         Cast_Result := No_Entity_Type_Decl;
   end if;


--# expr-done 1832
   If_Result_1 := Cast_Result;
else
   
   If_Result_1 := No_Entity_Type_Decl;
end if;



--# expr-done 1833

         Property_Result := If_Result_1;
         
   --# end
      Finalizer_Scope_268;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_268;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Entity_Type_Decl,
                     As_Internal_Entity_Type_Decl => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Expr_P_Get_Expected_Type;
--# end

   







--# property-start Expr.get_rightmost_refid nodes.lkt:3198
pragma Warnings (Off, "is not referenced");

function Expr_P_Get_Rightmost_Refid
  
  (Node : Bare_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Ref_Id
is
   Self : Bare_Expr :=
     Bare_Expr (Node);
     Ent : Internal_Entity_Expr :=
       Internal_Entity_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Ref_Id;

      

      Local_Ri : Internal_Entity_Ref_Id;
Local_De : Internal_Entity_Dot_Expr;
Fld : Internal_Entity_Ref_Id;
Ignored : Internal_Entity_Expr;
Match_Prefix : Internal_Entity_Expr;
Cast_Result : Internal_Entity_Ref_Id;
Let_Result : Internal_Entity_Ref_Id;
Scope_Result : Internal_Entity_Ref_Id;
Cast_Result_1 : Internal_Entity_Dot_Expr;
Let_Result_1 : Internal_Entity_Ref_Id;
Scope_Result_1 : Internal_Entity_Ref_Id;
Cast_Result_2 : Internal_Entity_Expr;
Let_Result_2 : Internal_Entity_Ref_Id;
Scope_Result_2 : Internal_Entity_Ref_Id;
Match_Result : Internal_Entity_Ref_Id;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1835 Match Match_Result nodes.lkt:3198










   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := Ent; 

case Lkt_Expr (Match_Prefix.Node.Kind) is
         when Lkt_Ref_Id =>
            



   --# scope-start



--# scope-start









   
      Cast_Result := Create_Internal_Entity_Ref_Id
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Ri := Cast_Result; 
--# bind ri Local_Ri

Let_Result := Local_Ri; 
--# end
Scope_Result := Let_Result;


   --# end


            Match_Result := Scope_Result; 
         when Lkt_Dot_Expr =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_1 := Create_Internal_Entity_Dot_Expr
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_De := Cast_Result_1; 
--# bind de Local_De
--# expr-start 1834 DotExpr.suffix Fld nodes.lkt:3200







   if Local_De.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Ref_Id (Node => Local_De.Node.Dot_Expr_F_Suffix, Info => Local_De.Info);
--# expr-done 1834
Let_Result_1 := Fld; 
--# end
Scope_Result_1 := Let_Result_1;


   --# end


            Match_Result := Scope_Result_1; 
         when Lkt_Any_Of .. Lkt_Cast_Expr | Lkt_Error_On_Null .. Lkt_Module_Ref_Id | Lkt_If_Expr .. Lkt_Un_Op =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_2 := Create_Internal_Entity_Expr
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored := Cast_Result_2; 
--# bind _ Ignored

Let_Result_2 := No_Entity_Ref_Id; 
--# end
Scope_Result_2 := Let_Result_2;


   --# end


            Match_Result := Scope_Result_2; 
end case;

--# expr-done 1835

         Property_Result := Match_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Expr_P_Get_Rightmost_Refid;
--# end

   







--# property-start Expr.expected_type_equation nodes.lkt:3204
pragma Warnings (Off, "is not referenced");

function Expr_P_Expected_Type_Equation
  
  (Node : Bare_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Expr :=
     Bare_Expr (Node);
     Ent : Internal_Entity_Expr :=
       Internal_Entity_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := raise Property_Error with "Property Expr.expected_type_equation not implemented";
            Inc_Ref (Property_Result);
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Expr_P_Expected_Type_Equation;
--# end

   







--# property-start Expr.match_params nodes.lkt:3211
pragma Warnings (Off, "is not referenced");

function Expr_P_Match_Params
  
  (Node : Bare_Expr
      ; Params : Internal_Resolved_Param_Array_Access
      ; Args : Internal_Entity_Argument_List
  )

   return Internal_Param_Match_Array_Access
is
   Self : Bare_Expr :=
     Bare_Expr (Node);
      --# bind node Self

   

   --# bind params Params
   --# bind args Args

   Property_Result : Internal_Param_Match_Array_Access;

      
            procedure Finalizer_Scope_272 with Inline_Always;

      Index : Integer;
Var_Expr : Internal_Entity_Argument_List;
Item_1 : Internal_Entity_Argument;
Fld : Internal_Entity_Ref_Id;
Var_Expr_1 : Internal_Entity_Ref_Id;
Fld_1 : Bare_Ref_Id;
Sym : Symbol_Type;
Result_Var : Symbol_Type;
Fld_2 : Symbol_Type;
Is_Equal : Boolean;
Fld_3 : Bare_Argument_List;
Fld_4 : Internal_Entity_Info;
Bare_Item_1 : Bare_Argument;
As_Entity : Internal_Entity_Argument;
Is_Null : Boolean;
If_Result : Internal_Entity_Argument;
Find_Result : Internal_Entity_Argument;
Var_Expr_2 : Internal_Entity_Argument;
New_Struct : Internal_Param_Match;
Scope_Result : Internal_Param_Match;
Result_Var_1 : Internal_Param_Match;
Result_Var_2 : Internal_Param_Match;
Fld_5 : Boolean;
Not_Val : Boolean;
New_Struct_1 : Internal_Param_Match;
Left_Var : Internal_Param_Match;
Result_Var_3 : Internal_Param_Match;
Var_Expr_3 : Internal_Entity_Argument_List;
Fld_6 : Bare_Argument_List;
Fld_7 : Internal_Entity_Info;
Get_Result : Bare_Argument;
As_Entity_1 : Internal_Entity_Argument;
Is_Null_1 : Boolean;
If_Result_1 : Internal_Entity_Argument;
Var_Expr_4 : Internal_Entity_Argument;
Fld_8 : Internal_Entity_Ref_Id;
Is_Null_2 : Boolean;
Result_Var_4 : Boolean;
Result_Var_5 : Boolean;
Var_Expr_5 : Internal_Entity_Argument_List;
Fld_9 : Bare_Argument_List;
Fld_10 : Internal_Entity_Info;
Get_Result_1 : Bare_Argument;
As_Entity_2 : Internal_Entity_Argument;
Is_Null_3 : Boolean;
If_Result_2 : Internal_Entity_Argument;
Result_Var_6 : Internal_Entity_Argument;
New_Struct_2 : Internal_Param_Match;
If_Result_3 : Internal_Param_Match;
Map_Result : Internal_Param_Match_Array_Access;

            procedure Finalizer_Scope_272 is
            begin
                     Dec_Ref (Map_Result);
            end Finalizer_Scope_272;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Expr_Expr_P_Match_Params,
            Items    => new Mmz_Key_Array (1 ..  3))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Expr,
                                As_Bare_Expr => Self);
               Mmz_K.Items (2) := (Kind => Mmz_Internal_Resolved_Param_Array_Access,
                                      As_Internal_Resolved_Param_Array_Access => Params);
                  Inc_Ref (Mmz_K.Items (2).As_Internal_Resolved_Param_Array_Access);
               Mmz_K.Items (3) := (Kind => Mmz_Internal_Entity_Argument_List,
                                      As_Internal_Entity_Argument_List => Args);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);




      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Param_Match_Array_Access;
                  Inc_Ref (Property_Result);

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 1851 .imap Map_Result nodes.lkt:3215








   

   

   
      declare
         Map_Result_Vec : Internal_Param_Match_Vectors.Vector;
      begin
   

   

      
         Index := 0;

      declare
         
         Collection : constant Internal_Resolved_Param_Array_Access := Params;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind p Item
               --# bind i Index

            
         
         
      --# expr-start 1850 If If_Result_3 nodes.lkt:3218







Var_Expr_3 := Args;





if Var_Expr_3 /= No_Entity_Argument_List then
   



















Fld_6 := Var_Expr_3.Node;



   if Fld_6 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;




Get_Result := Get (Self, Fld_6, Index, True); 
Is_Null_1 := Get_Result = null; 
if Is_Null_1 then
   
   If_Result_1 := No_Entity_Argument;
else
   








Fld_7 := Var_Expr_3.Info;

As_Entity_1 := (Info => Fld_7, Node => Get_Result); 
   If_Result_1 := As_Entity_1;
end if;



Var_Expr_4 := If_Result_1;





if Var_Expr_4 /= No_Entity_Argument then
   --# expr-start 1837 .is_null Is_Null_2 nodes.lkt:3218
--# expr-start 1836 Argument.name Fld_8 nodes.lkt:3218







   if Var_Expr_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Create_Internal_Entity_Ref_Id (Node => Var_Expr_4.Node.Argument_F_Name, Info => Var_Expr_4.Info);
--# expr-done 1836
Is_Null_2 := Fld_8.Node = null; 
--# expr-done 1837
   Result_Var_4 := Is_Null_2;
else
   
   Result_Var_4 := False;
end if;



   Result_Var_5 := Result_Var_4;
else
   
   Result_Var_5 := False;
end if;



if Result_Var_5 then
   --# expr-start 1838 'New[ParamMatch]' New_Struct_2 nodes.lkt:3220




Var_Expr_5 := Args;





if Var_Expr_5 /= No_Entity_Argument_List then
   
















Fld_9 := Var_Expr_5.Node;



   if Fld_9 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;




Get_Result_1 := Get (Self, Fld_9, Index, True); 
Is_Null_3 := Get_Result_1 = null; 
if Is_Null_3 then
   
   If_Result_2 := No_Entity_Argument;
else
   








Fld_10 := Var_Expr_5.Info;

As_Entity_2 := (Info => Fld_10, Node => Get_Result_1); 
   If_Result_2 := As_Entity_2;
end if;



   Result_Var_6 := If_Result_2;
else
   
   Result_Var_6 := No_Entity_Argument;
end if;





New_Struct_2 := (Arg => Result_Var_6, Has_Matched => True, Param => Item); 
--# expr-done 1838
   If_Result_3 := New_Struct_2;
else
   --# expr-start 1849 'or?' Result_Var_3 nodes.lkt:3223







Var_Expr := Args;





if Var_Expr /= No_Entity_Argument_List then
   --# expr-start 1845 .do Result_Var_1 nodes.lkt:3223



--# expr-start 1843 .find Find_Result nodes.lkt:3223








   

   









Fld_3 := Var_Expr.Node;

   
      Find_Result := No_Entity_Argument;
   

   

      if Fld_3 = null then
         
      Find_Result := No_Entity_Argument;
   
      else
         

      declare
         
         Collection : constant Bare_Argument_List := Fld_3;
      begin
         for Untyped_Item_1 of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item_1 := Untyped_Item_1; 
                  



Is_Null := Bare_Item_1 = null; 
if Is_Null then
   
   If_Result := No_Entity_Argument;
else
   








Fld_4 := Var_Expr.Info;

As_Entity := (Info => Fld_4, Node => Bare_Item_1); 
   If_Result := As_Entity;
end if;



                  Item_1 := If_Result; 

            
   --# scope-start


               --# bind a Item_1

            
      --# expr-start 1842 Eq Is_Equal nodes.lkt:3223



--# expr-start 1839 Argument.name Fld nodes.lkt:3223







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Ref_Id (Node => Item_1.Node.Argument_F_Name, Info => Item_1.Info);
--# expr-done 1839
Var_Expr_1 := Fld;





if Var_Expr_1 /= No_Entity_Ref_Id then
   --# expr-start 1840 .symbol Sym nodes.lkt:3223









Fld_1 := Var_Expr_1.Node; 
Sym := Get_Symbol (Fld_1); 
--# expr-done 1840
   Result_Var := Sym;
else
   
   Result_Var := No_Symbol;
end if;



--# expr-start 1841 ResolvedParam.name Fld_2 nodes.lkt:3223









Fld_2 := Item.Name;
--# expr-done 1841
Is_Equal := Result_Var = Fld_2; 
--# expr-done 1842
      if Is_Equal then
         Find_Result := Item_1; 
      end if;
   

            
   --# end


               exit when Is_Equal;

         end loop;
      end;
   
      end if;

   
   



--# expr-done 1843
Var_Expr_2 := Find_Result;





if Var_Expr_2 /= No_Entity_Argument then
   



   --# scope-start



--# expr-start 1844 'New[ParamMatch]' New_Struct nodes.lkt:3224



New_Struct := (Arg => Var_Expr_2, Has_Matched => True, Param => Item); 
--# expr-done 1844
Scope_Result := New_Struct;


   --# end


   Result_Var_1 := Scope_Result;
else
   
   Result_Var_1 := No_Param_Match;
end if;



--# expr-done 1845
   Result_Var_2 := Result_Var_1;
else
   
   Result_Var_2 := No_Param_Match;
end if;



Left_Var := Result_Var_2;





if Left_Var /= No_Param_Match then
   
   Result_Var_3 := Left_Var;
else
   --# expr-start 1848 'New[ParamMatch]' New_Struct_1 nodes.lkt:3227

--# expr-start 1847 Not Not_Val nodes.lkt:3227
--# expr-start 1846 ResolvedParam.has_default_value Fld_5 nodes.lkt:3227









Fld_5 := Item.Has_Default_Value;
--# expr-done 1846
Not_Val := not (Fld_5); 
--# expr-done 1847

New_Struct_1 := (Arg => No_Entity_Argument, Has_Matched => Not_Val, Param => Item); 
--# expr-done 1848
   Result_Var_3 := New_Struct_1;
end if;



--# expr-done 1849
   If_Result_3 := Result_Var_3;
end if;



--# expr-done 1850
      

         declare
            Item_To_Append : constant Internal_Param_Match := If_Result_3;
         begin
            Internal_Param_Match_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



               Index := Index + 1;
         end loop;
      end;
   

   

         Map_Result := Create_Internal_Param_Match_Array
           (Items_Count => Natural (Internal_Param_Match_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Param_Match_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Param_Match_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Param_Match_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1851

         Property_Result := Map_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_272;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_272;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Param_Match_Array_Access,
                     As_Internal_Param_Match_Array_Access => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
            if Mmz_Stored then
               Inc_Ref (Property_Result);
            end if;
      end if;



   return Property_Result;
end Expr_P_Match_Params;
--# end

   







--# property-start '[dispatcher]Expr.xlogic_equation' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Expr_P_Xlogic_Equation
  
  (Node : Bare_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Expr :=
     Bare_Expr (Node);
     Ent : Internal_Entity_Expr :=
       Internal_Entity_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Expr (Self.Kind) is
               when Lkt_Any_Of .. Lkt_Array_Literal | Lkt_Bin_Op .. Lkt_Cast_Expr | Lkt_Error_On_Null .. Lkt_Module_Ref_Id | Lkt_If_Expr .. Lkt_Un_Op =>
                  --# property-call-start 'Expr.[root-static]xlogic_equation'
                  Property_Result := Expr_P_Xlogic_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Call_Expr .. Lkt_Logic_Propagate_Call =>
                  --# property-call-start BaseCallExpr.xlogic_equation
                  Property_Result := Base_Call_Expr_P_Xlogic_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Dot_Expr =>
                  --# property-call-start DotExpr.xlogic_equation
                  Property_Result := Dot_Expr_P_Xlogic_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Ref_Id =>
                  --# property-call-start RefId.xlogic_equation
                  Property_Result := Ref_Id_P_Xlogic_Equation
                    (Self
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Expr_P_Xlogic_Equation;
--# end

   







--# property-start '[dispatcher]Expr.xtype_equation' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Expr_P_Xtype_Equation
  
  (Node : Bare_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Expr :=
     Bare_Expr (Node);
     Ent : Internal_Entity_Expr :=
       Internal_Entity_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Expr (Self.Kind) is
               when Lkt_Any_Of .. Lkt_Cast_Expr | Lkt_Error_On_Null .. Lkt_Module_Ref_Id | Lkt_If_Expr .. Lkt_Un_Op =>
                  --# property-call-start 'Expr.[root-static]xtype_equation'
                  Property_Result := Expr_P_Xtype_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Dot_Expr =>
                  --# property-call-start DotExpr.xtype_equation
                  Property_Result := Dot_Expr_P_Xtype_Equation
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Ref_Id =>
                  --# property-call-start RefId.xtype_equation
                  Property_Result := Ref_Id_P_Xtype_Equation
                    (Self
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Expr_P_Xtype_Equation;
--# end

   







--# property-start '[dispatcher]Expr.referenced_decl' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Expr_P_Referenced_Decl
  
  (Node : Bare_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Decl
is
   Self : Bare_Expr :=
     Bare_Expr (Node);
     Ent : Internal_Entity_Expr :=
       Internal_Entity_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Expr (Self.Kind) is
               when Lkt_Any_Of .. Lkt_Cast_Expr | Lkt_Error_On_Null .. Lkt_Module_Ref_Id | Lkt_If_Expr .. Lkt_Un_Op =>
                  --# property-call-start 'Expr.[root-static]referenced_decl'
                  Property_Result := Expr_P_Referenced_Decl
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Dot_Expr =>
                  --# property-call-start DotExpr.referenced_decl
                  Property_Result := Dot_Expr_P_Referenced_Decl
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Ref_Id =>
                  --# property-call-start RefId.referenced_decl
                  Property_Result := Ref_Id_P_Referenced_Decl
                    (Self
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Expr_P_Referenced_Decl;
--# end

   







--# property-start '[dispatcher]Expr.has_context_free_type' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Expr_P_Has_Context_Free_Type
  
  (Node : Bare_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Expr :=
     Bare_Expr (Node);
     Ent : Internal_Entity_Expr :=
       Internal_Entity_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Expr (Self.Kind) is
               when Lkt_Call_Expr .. Lkt_Logic_Propagate_Call | Lkt_Cast_Expr | Lkt_Generic_Instantiation .. Lkt_Ref_Id | Lkt_Keep_Expr | Lkt_Big_Num_Lit .. Lkt_Char_Lit | Lkt_Num_Lit .. Lkt_Logic_Unify | Lkt_Not_Expr | Lkt_Query | Lkt_Un_Op =>
                  --# property-call-start 'Expr.[root-static]has_context_free_type'
                  Property_Result := Expr_P_Has_Context_Free_Type
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Any_Of =>
                  --# property-call-start AnyOf.has_context_free_type
                  Property_Result := Any_Of_P_Has_Context_Free_Type
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Array_Literal =>
                  --# property-call-start ArrayLiteral.has_context_free_type
                  Property_Result := Array_Literal_P_Has_Context_Free_Type
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Bin_Op =>
                  --# property-call-start BinOp.has_context_free_type
                  Property_Result := Bin_Op_P_Has_Context_Free_Type
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Block_Expr =>
                  --# property-call-start BlockExpr.has_context_free_type
                  Property_Result := Block_Expr_P_Has_Context_Free_Type
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Dot_Expr =>
                  --# property-call-start DotExpr.has_context_free_type
                  Property_Result := Dot_Expr_P_Has_Context_Free_Type
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Error_On_Null =>
                  --# property-call-start ErrorOnNull.has_context_free_type
                  Property_Result := Error_On_Null_P_Has_Context_Free_Type
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_If_Expr =>
                  --# property-call-start IfExpr.has_context_free_type
                  Property_Result := If_Expr_P_Has_Context_Free_Type
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Isa =>
                  --# property-call-start Isa.has_context_free_type
                  Property_Result := Isa_P_Has_Context_Free_Type
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Lambda_Expr =>
                  --# property-call-start LambdaExpr.has_context_free_type
                  Property_Result := Lambda_Expr_P_Has_Context_Free_Type
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Null_Lit =>
                  --# property-call-start NullLit.has_context_free_type
                  Property_Result := Null_Lit_P_Has_Context_Free_Type
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Match_Expr =>
                  --# property-call-start MatchExpr.has_context_free_type
                  Property_Result := Match_Expr_P_Has_Context_Free_Type
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Paren_Expr =>
                  --# property-call-start ParenExpr.has_context_free_type
                  Property_Result := Paren_Expr_P_Has_Context_Free_Type
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Raise_Expr =>
                  --# property-call-start RaiseExpr.has_context_free_type
                  Property_Result := Raise_Expr_P_Has_Context_Free_Type
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Subscript_Expr =>
                  --# property-call-start SubscriptExpr.has_context_free_type
                  Property_Result := Subscript_Expr_P_Has_Context_Free_Type
                    (Self
                        , E_Info
                    );
                  --# end
               when Lkt_Try_Expr =>
                  --# property-call-start TryExpr.has_context_free_type
                  Property_Result := Try_Expr_P_Has_Context_Free_Type
                    (Self
                        , E_Info
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Expr_P_Has_Context_Free_Type;
--# end

   







--# property-start 'Expr.[root-static]get_type' nodes.lkt:3167
pragma Warnings (Off, "is not referenced");

function Expr_P_Get_Type
  
  (Node : Bare_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Expr :=
     Bare_Expr (Node);
     Ent : Internal_Entity_Expr :=
       Internal_Entity_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_266 with Inline_Always;
            procedure Finalizer_Scope_681 with Inline_Always;

      Fld : Internal_Solver_Result := No_Solver_Result;
Var_Expr : Internal_Solver_Result := No_Solver_Result;
Fld_1 : Logic_Var;
Is_Logic_Var_Defined : Boolean;
Eq_Solution : Internal_Entity;
If_Result : Internal_Entity;
Cast_Result : Internal_Entity_Type_Decl;
Scope_Result : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_266 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_266;
            procedure Finalizer_Scope_681 is
            begin
                     Dec_Ref (Var_Expr);
            end Finalizer_Scope_681;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Expr_Expr_P_Get_Type,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Expr,
                                As_Bare_Expr => Self);
               Mmz_K.Items (2) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Entity_Type_Decl;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 1856 .do Result_Var nodes.lkt:3168



--# expr-start 1852 LktNode.solve_enclosing_context Fld nodes.lkt:3168







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.solve_enclosing_context
Fld := Liblktlang.Implementation.Lkt_Node_P_Solve_Enclosing_Context (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1852
Var_Expr := Fld;

      Inc_Ref (Var_Expr);




if Var_Expr /= No_Solver_Result then
   



   --# scope-start



--# expr-start 1855 Cast Cast_Result nodes.lkt:3169





--# expr-start 1854 .get_value If_Result nodes.lkt:3169



--# expr-start 1853 Expr.actual_type_var Fld_1 nodes.lkt:3169







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 1853
Is_Logic_Var_Defined := Entity_Vars.Is_Defined (Fld_1); 
if Is_Logic_Var_Defined then
   
Eq_Solution := Entity_Vars.Get_Value (Fld_1); 
   If_Result := Eq_Solution;
else
   
   If_Result := No_Entity;
end if;



--# expr-done 1854



   if If_Result.Node = null
      or else If_Result.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => If_Result.Node,
         Info => If_Result.Info);

   else
         Cast_Result := No_Entity_Type_Decl;
   end if;


--# expr-done 1855
Scope_Result := Cast_Result;


   --# end
      Finalizer_Scope_681;


   Result_Var := Scope_Result;
else
   
   Result_Var := No_Entity_Type_Decl;
end if;



--# expr-done 1856

         Property_Result := Result_Var;
         
   --# end
      Finalizer_Scope_266;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_266;
                     Finalizer_Scope_681;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Entity_Type_Decl,
                     As_Internal_Entity_Type_Decl => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Expr_P_Get_Type;
--# end

   







--# property-start 'Expr.[root-static]xlogic_equation' nodes.lkt:3232
pragma Warnings (Off, "is not referenced");

function Expr_P_Xlogic_Equation
  
  (Node : Bare_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Expr :=
     Bare_Expr (Node);
     Ent : Internal_Entity_Expr :=
       Internal_Entity_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := raise Property_Error with "Property Expr.xlogic_equation not implemented";
            Inc_Ref (Property_Result);
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Expr_P_Xlogic_Equation;
--# end

   







--# property-start 'Expr.[root-static]xtype_equation' nodes.lkt:3239
pragma Warnings (Off, "is not referenced");

function Expr_P_Xtype_Equation
  
  (Node : Bare_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Expr :=
     Bare_Expr (Node);
     Ent : Internal_Entity_Expr :=
       Internal_Entity_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := raise Property_Error with "Property Expr.xtype_equation not implemented";
            Inc_Ref (Property_Result);
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Expr_P_Xtype_Equation;
--# end

   







--# property-start 'Expr.[root-static]referenced_decl' nodes.lkt:3253
pragma Warnings (Off, "is not referenced");

function Expr_P_Referenced_Decl
  
  (Node : Bare_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Decl
is
   Self : Bare_Expr :=
     Bare_Expr (Node);
     Ent : Internal_Entity_Expr :=
       Internal_Entity_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Decl;

      

      


      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Expr_Expr_P_Referenced_Decl,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Expr,
                                As_Bare_Expr => Self);
               Mmz_K.Items (2) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);




      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Entity_Decl;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         

         Property_Result := No_Entity_Decl;
         
   --# end


      exception
         when Exc : Property_Error =>


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Entity_Decl,
                     As_Internal_Entity_Decl => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Expr_P_Referenced_Decl;
--# end

   







--# property-start 'Expr.[root-static]has_context_free_type' nodes.lkt:3257
pragma Warnings (Off, "is not referenced");

function Expr_P_Has_Context_Free_Type
  
  (Node : Bare_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Expr :=
     Bare_Expr (Node);
     Ent : Internal_Entity_Expr :=
       Internal_Entity_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := True;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Expr_P_Has_Context_Free_Type;
--# end



   


      

   --
   --  Primitives for Bare_Any_Of
   --

   



      
      procedure Initialize_Fields_For_Any_Of
        (Self : Bare_Any_Of
         ; Any_Of_F_Expr : Bare_Expr
         ; Any_Of_F_Values : Bare_Any_Of_List
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Any_Of_F_Expr := Any_Of_F_Expr;
            Self.Any_Of_F_Values := Any_Of_F_Values;
         

      end Initialize_Fields_For_Any_Of;

      
   function Any_Of_F_Expr
     (Node : Bare_Any_Of) return Bare_Expr
   is
      

   begin
         
         return Node.Any_Of_F_Expr;
      
   end;

      
   function Any_Of_F_Values
     (Node : Bare_Any_Of) return Bare_Any_Of_List
   is
      

   begin
         
         return Node.Any_Of_F_Values;
      
   end;


   







--# property-start AnyOf.xref_equation nodes.lkt:3267
pragma Warnings (Off, "is not referenced");

function Any_Of_P_Xref_Equation
  
  (Node : Bare_Any_Of
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Any_Of :=
     Bare_Any_Of (Node);
     Ent : Internal_Entity_Any_Of :=
       Internal_Entity_Any_Of'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_277 with Inline_Always;
            procedure Finalizer_Scope_692 with Inline_Always;
            procedure Finalizer_Scope_693 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Logic_Var;
Fld_3 : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
And_Pred : Logic_Equation;
Fld_4 : Internal_Entity_Expr;
Fld_5 : Logic_Var;
Fld_6 : Internal_Entity_Expr;
Array_Lit : Internal_Entity_Expr_Array_Access;
Fld_7 : Internal_Entity_Any_Of_List;
Item : Internal_Entity_Expr;
Fld_8 : Bare_Any_Of_List;
Fld_9 : Internal_Entity_Info;
Bare_Item : Bare_Expr;
As_Entity : Internal_Entity_Expr;
Is_Null : Boolean;
If_Result : Internal_Entity_Expr;
Map_Result : Internal_Entity_Expr_Array_Access;
Concat_Result : Internal_Entity_Expr_Array_Access;
Fld_10 : Logic_Var;
Fld_11 : Boolean;
Map_Result_1 : Logic_Var_Array_Access;
Logic_Vars : Logic_Var_Array_Access;
Bind_Result_1 : Logic_Equation;
And_Pred_1 : Logic_Equation;
Fld_12 : Internal_Entity_Any_Of_List;
Item_2 : Internal_Entity_Expr;
Fld_13 : Logic_Equation;
Fld_14 : Logic_Var;
Fld_15 : Internal_Entity_Expr;
Fld_16 : Logic_Var;
Bind_Result_2 : Logic_Equation;
And_Pred_2 : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_17 : Bare_Expr;
Fld_18 : Logic_Var;
Fld_19 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_3 : Logic_Equation;
Fld_20 : Bare_Any_Of_List;
Fld_21 : Internal_Entity_Info;
Bare_Item_2 : Bare_Expr;
As_Entity_1 : Internal_Entity_Expr;
Is_Null_1 : Boolean;
If_Result_1 : Internal_Entity_Expr;
Map_Result_2 : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;
And_Pred_4 : Logic_Equation;

            procedure Finalizer_Scope_277 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Concat_Result);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (Logic_Vars);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Map_Result_2);
                     Dec_Ref (Logic_Boolean_Op);
                     Dec_Ref (And_Pred_4);
            end Finalizer_Scope_277;
            procedure Finalizer_Scope_692 is
            begin
                     Dec_Ref (Fld_13);
                     Dec_Ref (Bind_Result_2);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_3);
            end Finalizer_Scope_692;
            procedure Finalizer_Scope_693 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_693;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1888 LogicAnd And_Pred_4 nodes.lkt:3268
--# expr-start 1873 LogicAnd And_Pred_1 nodes.lkt:3269
--# expr-start 1862 LogicAnd And_Pred nodes.lkt:3270
--# expr-start 1858 LktNode.xref_equation Fld_1 nodes.lkt:3270



--# expr-start 1857 AnyOf.expr Fld nodes.lkt:3270







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Any_Of_F_Expr, Info => Ent.Info);
--# expr-done 1857



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 1858
--# expr-start 1861 LogicAssign Bind_Result nodes.lkt:3271
--# expr-start 1859 Expr.actual_type_var Fld_2 nodes.lkt:3271







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 1859
Fld_2.Value := No_Entity;
Entity_Vars.Reset (Fld_2);





--# expr-start 1860 LktNode.bool_type Fld_3 nodes.lkt:3271







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.bool_type
Fld_3 := Liblktlang.Implementation.Lkt_Node_P_Bool_Type (Node => Ent.Node);
--# end
--# expr-done 1860



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_3.Node,
         Info => Fld_3.Info);


Bind_Result := Solver.Create_Assign (Fld_2, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3271:22") else null)); 
--# expr-done 1861
And_Pred := Create_And (Fld_1, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3270:17") else null)); 
--# expr-done 1862
--# expr-start 1870 .filtermap Map_Result_1 nodes.lkt:3275








   

   --# expr-start 1867 ArrayConcat Concat_Result nodes.lkt:3275
--# expr-start 1864 ArrayLiteral Array_Lit nodes.lkt:3275
--# expr-start 1863 AnyOf.expr Fld_6 nodes.lkt:3275







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Expr (Node => Ent.Node.Any_Of_F_Expr, Info => Ent.Info);
--# expr-done 1863
Array_Lit := Create_Internal_Entity_Expr_Array (Internal_Internal_Entity_Expr_Array'(1 => Fld_6)); 
--# expr-done 1864
--# expr-start 1866 .as_array Map_Result nodes.lkt:3275








   

   --# expr-start 1865 AnyOf.values Fld_7 nodes.lkt:3275







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Create_Internal_Entity_Any_Of_List (Node => Ent.Node.Any_Of_F_Values, Info => Ent.Info);
--# expr-done 1865









Fld_8 := Fld_7.Node;

   
      declare
         Map_Result_Vec : Internal_Entity_Expr_Vectors.Vector;
      begin
   

   

      if Fld_8 = null then
         
      Map_Result := Create_Internal_Entity_Expr_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Any_Of_List := Fld_8;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Expr;
else
   








Fld_9 := Fld_7.Info;

As_Entity := (Info => Fld_9, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start



            
         
         
      
      

         declare
            Item_To_Append : constant Internal_Entity_Expr := Item;
         begin
            Internal_Entity_Expr_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Internal_Entity_Expr_Array
           (Items_Count => Natural (Internal_Entity_Expr_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Expr_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Expr_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Expr_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1866
Concat_Result := Concat (Array_Lit, Map_Result); 
--# expr-done 1867

   
      declare
         Map_Result_1_Vec : Logic_Var_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Expr_Array_Access := Concat_Result;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind e Item_1

            
         --# expr-start 1868 Expr.has_context_free_type Fld_11 nodes.lkt:3277







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_11 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Item_1.Node, E_Info => Item_1.Info);
--# end
--# expr-done 1868
         if Fld_11 then
            
         
      --# expr-start 1869 Expr.actual_type_var Fld_10 nodes.lkt:3276







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Item_1.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 1869
      

         declare
            Item_To_Append : constant Logic_Var := Fld_10;
         begin
            Logic_Var_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
         end if;
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result_1 := Create_Logic_Var_Array
           (Items_Count => Natural (Logic_Var_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Logic_Var_Vectors.Get
              (Map_Result_1_Vec,
               I + Logic_Var_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Logic_Var_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 1870
for Var of Map_Result_1.Items loop
   Var.Value := No_Entity;
   Entity_Vars.Reset (Var);
end loop;
Logic_Vars := Map_Result_1; Inc_Ref (Logic_Vars);
--# expr-start 1872 Expr.expected_type_var Fld_5 nodes.lkt:3273



--# expr-start 1871 AnyOf.expr Fld_4 nodes.lkt:3273







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Expr (Node => Ent.Node.Any_Of_F_Expr, Info => Ent.Info);
--# expr-done 1871



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Fld_4.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 1872
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);


Bind_Result_1 := Solver.Create_N_Propagate (Fld_5, Create_Type_Decl_P_Imprecise_Common_Ancestor_List_0_Functor (Logic_Vars.N), Entity_Vars.Logic_Var_Array (Logic_Vars.Items)); 
And_Pred_1 := Create_And (And_Pred, Bind_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3269:13") else null)); 
--# expr-done 1873
--# expr-start 1887 .logic_all Logic_Boolean_Op nodes.lkt:3281








   

   --# expr-start 1874 AnyOf.values Fld_12 nodes.lkt:3281







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_12 := Create_Internal_Entity_Any_Of_List (Node => Ent.Node.Any_Of_F_Values, Info => Ent.Info);
--# expr-done 1874









Fld_20 := Fld_12.Node;

   
      declare
         Map_Result_2_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      if Fld_20 = null then
         
      Map_Result_2 := Create_Logic_Equation_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Any_Of_List := Fld_20;
      begin
         for Untyped_Item_2 of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item_2 := Untyped_Item_2; 
                  



Is_Null_1 := Bare_Item_2 = null; 
if Is_Null_1 then
   
   If_Result_1 := No_Entity_Expr;
else
   








Fld_21 := Fld_12.Info;

As_Entity_1 := (Info => Fld_21, Node => Bare_Item_2); 
   If_Result_1 := As_Entity_1;
end if;



                  Item_2 := If_Result_1; 

            
   --# scope-start


               --# bind v Item_2

            
         
         
      --# expr-start 1886 LogicAnd And_Pred_3 nodes.lkt:3283
--# expr-start 1880 LogicAnd And_Pred_2 nodes.lkt:3284
--# expr-start 1875 LktNode.xref_equation Fld_13 nodes.lkt:3284







   if Item_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_13 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Item_2.Node, E_Info => Item_2.Info);
--# end
--# expr-done 1875
--# expr-start 1879 LogicUnify Bind_Result_2 nodes.lkt:3285
--# expr-start 1876 Expr.expected_type_var Fld_14 nodes.lkt:3285







   if Item_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_14 := Item_2.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 1876
Fld_14.Value := No_Entity;
Entity_Vars.Reset (Fld_14);
--# expr-start 1878 Expr.actual_type_var Fld_16 nodes.lkt:3285



--# expr-start 1877 AnyOf.expr Fld_15 nodes.lkt:3285







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_15 := Create_Internal_Entity_Expr (Node => Ent.Node.Any_Of_F_Expr, Info => Ent.Info);
--# expr-done 1877



   if Fld_15.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_16 := Fld_15.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 1878
Bind_Result_2 := Solver.Create_Unify (Fld_14, Fld_16, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3285:22") else null)); 
--# expr-done 1879
And_Pred_2 := Create_And (Fld_13, Bind_Result_2, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3284:17") else null)); 
--# expr-done 1880




   --# scope-start



--# expr-start 1885 bind Dyn_Var_Bind_Result nodes.lkt:3288





--# expr-start 1881 'Entity[Expr].node' Fld_17 nodes.lkt:3288









Fld_17 := Item_2.Node;
--# expr-done 1881



   
      Cast_Result_1 := Fld_17;


Error_Location := Cast_Result_1; 
--# expr-start 1884 LogicPropagate Pred nodes.lkt:3289
--# expr-start 1882 Expr.expected_type_var Fld_18 nodes.lkt:3290







   if Item_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_18 := Item_2.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 1882
Fld_18.Value := No_Entity;
Entity_Vars.Reset (Fld_18);
--# expr-start 1883 Expr.actual_type_var Fld_19 nodes.lkt:3291







   if Item_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_19 := Item_2.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 1883
Fld_19.Value := No_Entity;
Entity_Vars.Reset (Fld_19);


Pred := Solver.Create_N_Predicate ((Fld_18, Fld_19), Create_Type_Decl_P_Commutative_Matching_Type_0_Predicate (2, Error_Location)); 
--# expr-done 1884
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 1885
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_693;


And_Pred_3 := Create_And (And_Pred_2, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3283:13") else null)); 
--# expr-done 1886
      

         declare
            Item_To_Append : constant Logic_Equation := And_Pred_3;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_2_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_692;



         end loop;
      end;
   
      end if;

   

         Map_Result_2 := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_2_Vec)));
         for I in Map_Result_2.Items'Range loop
            Map_Result_2.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_2_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result_2.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_2_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result_2.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3281:26") else null)); 
--# expr-done 1887
And_Pred_4 := Create_And (And_Pred_1, Logic_Boolean_Op, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3268:9") else null)); 
--# expr-done 1888

         Property_Result := And_Pred_4;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_277;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_277;
                     Finalizer_Scope_692;
                     Finalizer_Scope_693;




            raise;
      end;



   return Property_Result;
end Any_Of_P_Xref_Equation;
--# end

   







--# property-start AnyOf.has_context_free_type nodes.lkt:3296
pragma Warnings (Off, "is not referenced");

function Any_Of_P_Has_Context_Free_Type
  
  (Node : Bare_Any_Of
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Any_Of :=
     Bare_Any_Of (Node);
     Ent : Internal_Entity_Any_Of :=
       Internal_Entity_Any_Of'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := True;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Any_Of_P_Has_Context_Free_Type;
--# end



   


      

   --
   --  Primitives for Bare_Array_Literal
   --

   



      
      procedure Initialize_Fields_For_Array_Literal
        (Self : Bare_Array_Literal
         ; Array_Literal_F_Exprs : Bare_Expr_List
         ; Array_Literal_F_Element_Type : Bare_Type_Ref
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Array_Literal_F_Exprs := Array_Literal_F_Exprs;
            Self.Array_Literal_F_Element_Type := Array_Literal_F_Element_Type;
         
      Self.Array_Literal_F_Expected_Exprs_Type_Var := Null_Var_Record;
      Self.Array_Literal_F_Actual_Element_Type := Null_Var_Record;

      end Initialize_Fields_For_Array_Literal;

      
   function Array_Literal_F_Exprs
     (Node : Bare_Array_Literal) return Bare_Expr_List
   is
      

   begin
         
         return Node.Array_Literal_F_Exprs;
      
   end;

      
   function Array_Literal_F_Element_Type
     (Node : Bare_Array_Literal) return Bare_Type_Ref
   is
      

   begin
         
         return Node.Array_Literal_F_Element_Type;
      
   end;


   







--# property-start ArrayLiteral.has_context_free_type nodes.lkt:3309
pragma Warnings (Off, "is not referenced");

function Array_Literal_P_Has_Context_Free_Type
  
  (Node : Bare_Array_Literal
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Array_Literal :=
     Bare_Array_Literal (Node);
     Ent : Internal_Entity_Array_Literal :=
       Internal_Entity_Array_Literal'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Fld : Internal_Entity_Expr_List;
Item : Internal_Entity_Expr;
Fld_1 : Boolean;
Fld_2 : Bare_Expr_List;
Fld_3 : Internal_Entity_Info;
Bare_Item : Bare_Expr;
As_Entity : Internal_Entity_Expr;
Is_Null : Boolean;
If_Result : Internal_Entity_Expr;
Quantifier_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 1891 .any Quantifier_Result nodes.lkt:3310








   

   --# expr-start 1889 ArrayLiteral.exprs Fld nodes.lkt:3310







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr_List (Node => Ent.Node.Array_Literal_F_Exprs, Info => Ent.Info);
--# expr-done 1889









Fld_2 := Fld.Node;

   
      Quantifier_Result := False;
   

   

      if Fld_2 = null then
         
      null;
   
      else
         

      declare
         
         Collection : constant Bare_Expr_List := Fld_2;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Expr;
else
   








Fld_3 := Fld.Info;

As_Entity := (Info => Fld_3, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind e Item

            
      --# expr-start 1890 Expr.has_context_free_type Fld_1 nodes.lkt:3310







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 1890
      Quantifier_Result := Fld_1;
   

            
   --# end


               exit when Quantifier_Result;

         end loop;
      end;
   
      end if;

   
   



--# expr-done 1891

         Property_Result := Quantifier_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Array_Literal_P_Has_Context_Free_Type;
--# end

   







--# property-start ArrayLiteral.expected_exprs_type_equation nodes.lkt:3312
pragma Warnings (Off, "is not referenced");

function Array_Literal_P_Expected_Exprs_Type_Equation
  
  (Node : Bare_Array_Literal
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Array_Literal :=
     Bare_Array_Literal (Node);
     Ent : Internal_Entity_Array_Literal :=
       Internal_Entity_Array_Literal'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_280 with Inline_Always;
            procedure Finalizer_Scope_695 with Inline_Always;

      Fld : Internal_Entity_Expr_List;
Item : Internal_Entity_Expr;
Fld_1 : Boolean;
Fld_2 : Bare_Expr_List;
Fld_3 : Internal_Entity_Info;
Bare_Item : Bare_Expr;
As_Entity : Internal_Entity_Expr;
Is_Null : Boolean;
If_Result : Internal_Entity_Expr;
Map_Result : Internal_Entity_Expr_Array_Access;
Fld_4 : Logic_Var;
Map_Result_1 : Logic_Var_Array_Access;
Local_Logic_Vars : Logic_Var_Array_Access;
Fld_5 : Logic_Var;
Fld_6 : Logic_Var;
Bind_Result : Logic_Equation;
Fld_7 : Boolean;
Fld_8 : Logic_Var;
Fld_9 : Internal_Entity_Type_Decl;
Fld_10 : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result_1 : Logic_Equation;
If_Result_1 : Logic_Equation;
Len : Integer;
Is_Equal : Boolean;
Not_Val : Boolean;
Fld_11 : Logic_Var;
Logic_Vars : Logic_Var_Array_Access;
Bind_Result_2 : Logic_Equation;
If_Result_2 : Logic_Equation;
Let_Result : Logic_Equation;
Scope_Result : Logic_Equation;

            procedure Finalizer_Scope_280 is
            begin
                     Dec_Ref (Scope_Result);
            end Finalizer_Scope_280;
            procedure Finalizer_Scope_695 is
            begin
                     Dec_Ref (Map_Result);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (Local_Logic_Vars);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (If_Result_1);
                     Dec_Ref (Logic_Vars);
                     Dec_Ref (Bind_Result_2);
                     Dec_Ref (If_Result_2);
                     Dec_Ref (Let_Result);
            end Finalizer_Scope_695;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 1910 ValDecl Let_Result nodes.lkt:3313
--# scope-start
--# expr-start 1896 .map Map_Result_1 nodes.lkt:3314








   

   --# expr-start 1894 .filter Map_Result nodes.lkt:3314








   

   --# expr-start 1892 ArrayLiteral.exprs Fld nodes.lkt:3314







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr_List (Node => Ent.Node.Array_Literal_F_Exprs, Info => Ent.Info);
--# expr-done 1892









Fld_2 := Fld.Node;

   
      declare
         Map_Result_Vec : Internal_Entity_Expr_Vectors.Vector;
      begin
   

   

      if Fld_2 = null then
         
      Map_Result := Create_Internal_Entity_Expr_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Expr_List := Fld_2;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Expr;
else
   








Fld_3 := Fld.Info;

As_Entity := (Info => Fld_3, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind expr Item

            
         --# expr-start 1893 Expr.has_context_free_type Fld_1 nodes.lkt:3314







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 1893
         if Fld_1 then
            
         
      
      

         declare
            Item_To_Append : constant Internal_Entity_Expr := Item;
         begin
            Internal_Entity_Expr_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
         end if;
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Internal_Entity_Expr_Array
           (Items_Count => Natural (Internal_Entity_Expr_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Expr_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Expr_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Expr_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1894

   
      declare
         Map_Result_1_Vec : Logic_Var_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Expr_Array_Access := Map_Result;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind expr Item_1

            
         
         
      --# expr-start 1895 Expr.actual_type_var Fld_4 nodes.lkt:3315







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Item_1.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 1895
      

         declare
            Item_To_Append : constant Logic_Var := Fld_4;
         begin
            Logic_Var_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result_1 := Create_Logic_Var_Array
           (Items_Count => Natural (Logic_Var_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Logic_Var_Vectors.Get
              (Map_Result_1_Vec,
               I + Logic_Var_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Logic_Var_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 1896
Local_Logic_Vars := Map_Result_1; Inc_Ref (Local_Logic_Vars);
--# bind logic_vars Local_Logic_Vars
--# expr-start 1909 If If_Result_2 nodes.lkt:3321



--# expr-start 1898 NotEqual Not_Val nodes.lkt:3321
--# expr-start 1897 .length Len nodes.lkt:3321

Len := Length (Local_Logic_Vars); 
--# expr-done 1897

Is_Equal := Len = 0; 
Not_Val := not (Is_Equal); 
--# expr-done 1898
if Not_Val then
   
for Var of Local_Logic_Vars.Items loop
   Var.Value := No_Entity;
   Entity_Vars.Reset (Var);
end loop;
Logic_Vars := Local_Logic_Vars; Inc_Ref (Logic_Vars);
--# expr-start 1899 ArrayLiteral.expected_exprs_type_var Fld_11 nodes.lkt:3323







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Ent.Node.Array_Literal_F_Expected_Exprs_Type_Var'Unrestricted_Access;
--# expr-done 1899
Fld_11.Value := No_Entity;
Entity_Vars.Reset (Fld_11);


Bind_Result_2 := Solver.Create_N_Propagate (Fld_11, Create_Type_Decl_P_Imprecise_Common_Ancestor_List_0_Functor (Logic_Vars.N), Entity_Vars.Logic_Var_Array (Logic_Vars.Items)); 
   If_Result_2 := Bind_Result_2;
else
   --# expr-start 1908 If If_Result_1 nodes.lkt:3321



--# expr-start 1900 Expr.xref_entry_point Fld_7 nodes.lkt:3325







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_entry_point'
Fld_7 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Entry_Point (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1900
if Fld_7 then
   --# expr-start 1904 LogicAssign Bind_Result_1 nodes.lkt:3327
--# expr-start 1901 ArrayLiteral.expected_exprs_type_var Fld_8 nodes.lkt:3327







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Ent.Node.Array_Literal_F_Expected_Exprs_Type_Var'Unrestricted_Access;
--# expr-done 1901
Fld_8.Value := No_Entity;
Entity_Vars.Reset (Fld_8);





--# expr-start 1903 TypeDecl.get_array_content_type Fld_10 nodes.lkt:3328



--# expr-start 1902 Expr.get_expected_type Fld_9 nodes.lkt:3328







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_expected_type
Fld_9 := Liblktlang.Implementation.Expr_P_Get_Expected_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1902



   if Fld_9.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.get_array_content_type
Fld_10 := Liblktlang.Implementation.Type_Decl_P_Get_Array_Content_Type (Node => Fld_9.Node, E_Info => Fld_9.Info);
--# end
--# expr-done 1903



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_10.Node,
         Info => Fld_10.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_8, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3327:13") else null)); 
--# expr-done 1904
   If_Result_1 := Bind_Result_1;
else
   --# expr-start 1907 LogicPropagate Bind_Result nodes.lkt:3330
--# expr-start 1905 Expr.expected_type_var Fld_6 nodes.lkt:3331







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Ent.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 1905
Fld_6.Value := No_Entity;
Entity_Vars.Reset (Fld_6);
--# expr-start 1906 ArrayLiteral.expected_exprs_type_var Fld_5 nodes.lkt:3330







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Ent.Node.Array_Literal_F_Expected_Exprs_Type_Var'Unrestricted_Access;
--# expr-done 1906
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);

Bind_Result := Solver.Create_Propagate (Fld_6, Fld_5, Create_Type_Decl_P_Get_Array_Content_Type_0_Functor); 
--# expr-done 1907
   If_Result_1 := Bind_Result;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 1908
   If_Result_2 := If_Result_1;
end if;

      Inc_Ref (If_Result_2);


--# expr-done 1909
Let_Result := If_Result_2; Inc_Ref (Let_Result);
--# end
--# expr-done 1910
Scope_Result := Let_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_695;



         Property_Result := Scope_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_280;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_280;
                     Finalizer_Scope_695;




            raise;
      end;



   return Property_Result;
end Array_Literal_P_Expected_Exprs_Type_Equation;
--# end

   







--# property-start ArrayLiteral.xref_equation nodes.lkt:3334
pragma Warnings (Off, "is not referenced");

function Array_Literal_P_Xref_Equation
  
  (Node : Bare_Array_Literal
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Array_Literal :=
     Bare_Array_Literal (Node);
     Ent : Internal_Entity_Array_Literal :=
       Internal_Entity_Array_Literal'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_281 with Inline_Always;
            procedure Finalizer_Scope_699 with Inline_Always;
            procedure Finalizer_Scope_700 with Inline_Always;
            procedure Finalizer_Scope_701 with Inline_Always;

      Fld : Logic_Equation;
Fld_1 : Logic_Var;
Fld_2 : Internal_Entity_Type_Ref;
Fld_3 : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
Fld_4 : Internal_Entity_Type_Ref;
Is_Null : Boolean;
Fld_5 : Logic_Var;
Fld_6 : Internal_Entity_Expr_List;
Item : Internal_Entity_Expr;
Fld_7 : Logic_Var;
Fld_8 : Bare_Expr_List;
Fld_9 : Internal_Entity_Info;
Bare_Item : Bare_Expr;
As_Entity : Internal_Entity_Expr;
Is_Null_1 : Boolean;
If_Result : Internal_Entity_Expr;
Map_Result : Logic_Var_Array_Access;
Logic_Vars : Logic_Var_Array_Access;
Bind_Result_1 : Logic_Equation;
Fld_10 : Internal_Entity_Expr_List;
Fld_11 : Bare_Expr_List;
Len : Integer;
Is_Equal : Boolean;
Fld_12 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result_1 : Internal_Entity;
Bind_Result_2 : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_13 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_2 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred : Logic_Equation;
If_Result_1 : Logic_Equation;
If_Result_2 : Logic_Equation;
And_Pred_1 : Logic_Equation;
Fld_14 : Logic_Var;
Fld_15 : Logic_Var;
Bind_Result_3 : Logic_Equation;
And_Pred_2 : Logic_Equation;
Fld_16 : Internal_Entity_Expr_List;
Item_1 : Internal_Entity_Expr;
Fld_17 : Logic_Equation;
Fld_18 : Logic_Var;
Fld_19 : Logic_Var;
Bind_Result_4 : Logic_Equation;
And_Pred_3 : Logic_Equation;
Error_Location_1 : Bare_Lkt_Node;
Fld_20 : Bare_Expr;
Fld_21 : Logic_Var;
Fld_22 : Logic_Var;
Pred_1 : Logic_Equation;
Cast_Result_3 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_1 : Logic_Equation;
Scope_Result_1 : Logic_Equation;
And_Pred_4 : Logic_Equation;
Fld_23 : Bare_Expr_List;
Fld_24 : Internal_Entity_Info;
Bare_Item_1 : Bare_Expr;
As_Entity_1 : Internal_Entity_Expr;
Is_Null_2 : Boolean;
If_Result_3 : Internal_Entity_Expr;
Map_Result_1 : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;
And_Pred_5 : Logic_Equation;

            procedure Finalizer_Scope_281 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Logic_Vars);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (Bind_Result_2);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (If_Result_1);
                     Dec_Ref (If_Result_2);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Bind_Result_3);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (Logic_Boolean_Op);
                     Dec_Ref (And_Pred_5);
            end Finalizer_Scope_281;
            procedure Finalizer_Scope_699 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_699;
            procedure Finalizer_Scope_700 is
            begin
                     Dec_Ref (Fld_17);
                     Dec_Ref (Bind_Result_4);
                     Dec_Ref (And_Pred_3);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (And_Pred_4);
            end Finalizer_Scope_700;
            procedure Finalizer_Scope_701 is
            begin
                     Dec_Ref (Pred_1);
                     Dec_Ref (Dyn_Var_Bind_Result_1);
            end Finalizer_Scope_701;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1951 LogicAnd And_Pred_5 nodes.lkt:3335
--# expr-start 1937 LogicAnd And_Pred_2 nodes.lkt:3336
--# expr-start 1933 LogicAnd And_Pred_1 nodes.lkt:3337
--# expr-start 1911 ArrayLiteral.expected_exprs_type_equation Fld nodes.lkt:3337







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start ArrayLiteral.expected_exprs_type_equation
Fld := Liblktlang.Implementation.Array_Literal_P_Expected_Exprs_Type_Equation (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1911
--# expr-start 1932 If If_Result_2 nodes.lkt:3339



--# expr-start 1913 .is_null Is_Null nodes.lkt:3339
--# expr-start 1912 ArrayLiteral.element_type Fld_4 nodes.lkt:3339







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Array_Literal_F_Element_Type, Info => Ent.Info);
--# expr-done 1912
Is_Null := Fld_4.Node = null; 
--# expr-done 1913
if Is_Null then
   --# expr-start 1927 If If_Result_1 nodes.lkt:3341



--# expr-start 1916 Eq Is_Equal nodes.lkt:3341
--# expr-start 1915 .length Len nodes.lkt:3341



--# expr-start 1914 ArrayLiteral.exprs Fld_10 nodes.lkt:3341







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Create_Internal_Entity_Expr_List (Node => Ent.Node.Array_Literal_F_Exprs, Info => Ent.Info);
--# expr-done 1914





Fld_11 := Fld_10.Node; 
Len := Length (Fld_11); 
--# expr-done 1915

Is_Equal := Len = 0; 
--# expr-done 1916
if Is_Equal then
   --# expr-start 1922 LogicAnd And_Pred nodes.lkt:3343
--# expr-start 1918 LogicAssign Bind_Result_2 nodes.lkt:3343
--# expr-start 1917 ArrayLiteral.actual_element_type Fld_12 nodes.lkt:3343







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_12 := Ent.Node.Array_Literal_F_Actual_Element_Type'Unrestricted_Access;
--# expr-done 1917
Fld_12.Value := No_Entity;
Entity_Vars.Reset (Fld_12);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result_2 := Solver.Create_Assign (Fld_12, Cast_Result_1, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3343:29") else null)); 
--# expr-done 1918




   --# scope-start



--# expr-start 1921 bind Dyn_Var_Bind_Result nodes.lkt:3345









   
      Cast_Result_2 := Self;


Error_Location := Cast_Result_2; 
--# expr-start 1920 LogicPropagate Pred nodes.lkt:3346
--# expr-start 1919 ArrayLiteral.actual_element_type Fld_13 nodes.lkt:3347







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_13 := Ent.Node.Array_Literal_F_Actual_Element_Type'Unrestricted_Access;
--# expr-done 1919
Fld_13.Value := No_Entity;
Entity_Vars.Reset (Fld_13);

Pred := Solver.Create_Predicate (Fld_13, Create_Type_Decl_P_Could_Determine_Type_0_Predicate (Error_Location)); 
--# expr-done 1920
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 1921
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_699;


And_Pred := Create_And (Bind_Result_2, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3343:29") else null)); 
--# expr-done 1922
   If_Result_1 := And_Pred;
else
   --# expr-start 1925 .map Map_Result nodes.lkt:3353








   

   --# expr-start 1923 ArrayLiteral.exprs Fld_6 nodes.lkt:3353







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Expr_List (Node => Ent.Node.Array_Literal_F_Exprs, Info => Ent.Info);
--# expr-done 1923









Fld_8 := Fld_6.Node;

   
      declare
         Map_Result_Vec : Logic_Var_Vectors.Vector;
      begin
   

   

      if Fld_8 = null then
         
      Map_Result := Create_Logic_Var_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Expr_List := Fld_8;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null_1 := Bare_Item = null; 
if Is_Null_1 then
   
   If_Result := No_Entity_Expr;
else
   








Fld_9 := Fld_6.Info;

As_Entity := (Info => Fld_9, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind expr Item

            
         
         
      --# expr-start 1924 Expr.actual_type_var Fld_7 nodes.lkt:3353







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Item.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 1924
      

         declare
            Item_To_Append : constant Logic_Var := Fld_7;
         begin
            Logic_Var_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Logic_Var_Array
           (Items_Count => Natural (Logic_Var_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Logic_Var_Vectors.Get
              (Map_Result_Vec,
               I + Logic_Var_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Logic_Var_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1925
for Var of Map_Result.Items loop
   Var.Value := No_Entity;
   Entity_Vars.Reset (Var);
end loop;
Logic_Vars := Map_Result; Inc_Ref (Logic_Vars);
--# expr-start 1926 ArrayLiteral.actual_element_type Fld_5 nodes.lkt:3351







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Ent.Node.Array_Literal_F_Actual_Element_Type'Unrestricted_Access;
--# expr-done 1926
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);


Bind_Result_1 := Solver.Create_N_Propagate (Fld_5, Create_Type_Decl_P_Imprecise_Common_Ancestor_List_0_Functor (Logic_Vars.N), Entity_Vars.Logic_Var_Array (Logic_Vars.Items)); 
   If_Result_1 := Bind_Result_1;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 1927
   If_Result_2 := If_Result_1;
else
   --# expr-start 1931 LogicAssign Bind_Result nodes.lkt:3356
--# expr-start 1928 ArrayLiteral.actual_element_type Fld_1 nodes.lkt:3356







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Ent.Node.Array_Literal_F_Actual_Element_Type'Unrestricted_Access;
--# expr-done 1928
Fld_1.Value := No_Entity;
Entity_Vars.Reset (Fld_1);





--# expr-start 1930 TypeRef.referenced_decl Fld_3 nodes.lkt:3357



--# expr-start 1929 ArrayLiteral.element_type Fld_2 nodes.lkt:3357







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Array_Literal_F_Element_Type, Info => Ent.Info);
--# expr-done 1929



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_3 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Fld_2.Node, E_Info => Fld_2.Info);
--# end
--# expr-done 1930



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_3.Node,
         Info => Fld_3.Info);


Bind_Result := Solver.Create_Assign (Fld_1, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3356:25") else null)); 
--# expr-done 1931
   If_Result_2 := Bind_Result;
end if;

      Inc_Ref (If_Result_2);


--# expr-done 1932
And_Pred_1 := Create_And (Fld, If_Result_2, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3337:17") else null)); 
--# expr-done 1933
--# expr-start 1936 LogicPropagate Bind_Result_3 nodes.lkt:3362
--# expr-start 1934 ArrayLiteral.actual_element_type Fld_15 nodes.lkt:3363







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_15 := Ent.Node.Array_Literal_F_Actual_Element_Type'Unrestricted_Access;
--# expr-done 1934
Fld_15.Value := No_Entity;
Entity_Vars.Reset (Fld_15);
--# expr-start 1935 Expr.actual_type_var Fld_14 nodes.lkt:3362







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_14 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 1935
Fld_14.Value := No_Entity;
Entity_Vars.Reset (Fld_14);

Bind_Result_3 := Solver.Create_Propagate (Fld_15, Fld_14, Create_Type_Decl_P_Make_Array_Type_0_Functor); 
--# expr-done 1936
And_Pred_2 := Create_And (And_Pred_1, Bind_Result_3, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3336:13") else null)); 
--# expr-done 1937
--# expr-start 1950 .logic_all Logic_Boolean_Op nodes.lkt:3366








   

   --# expr-start 1938 ArrayLiteral.exprs Fld_16 nodes.lkt:3366







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_16 := Create_Internal_Entity_Expr_List (Node => Ent.Node.Array_Literal_F_Exprs, Info => Ent.Info);
--# expr-done 1938









Fld_23 := Fld_16.Node;

   
      declare
         Map_Result_1_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      if Fld_23 = null then
         
      Map_Result_1 := Create_Logic_Equation_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Expr_List := Fld_23;
      begin
         for Untyped_Item_1 of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item_1 := Untyped_Item_1; 
                  



Is_Null_2 := Bare_Item_1 = null; 
if Is_Null_2 then
   
   If_Result_3 := No_Entity_Expr;
else
   








Fld_24 := Fld_16.Info;

As_Entity_1 := (Info => Fld_24, Node => Bare_Item_1); 
   If_Result_3 := As_Entity_1;
end if;



                  Item_1 := If_Result_3; 

            
   --# scope-start


               --# bind expr Item_1

            
         
         
      --# expr-start 1949 LogicAnd And_Pred_4 nodes.lkt:3368
--# expr-start 1943 LogicAnd And_Pred_3 nodes.lkt:3370
--# expr-start 1939 LktNode.xref_equation Fld_17 nodes.lkt:3370







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_17 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Item_1.Node, E_Info => Item_1.Info);
--# end
--# expr-done 1939
--# expr-start 1942 LogicUnify Bind_Result_4 nodes.lkt:3373
--# expr-start 1940 Expr.expected_type_var Fld_18 nodes.lkt:3373







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_18 := Item_1.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 1940
Fld_18.Value := No_Entity;
Entity_Vars.Reset (Fld_18);
--# expr-start 1941 ArrayLiteral.expected_exprs_type_var Fld_19 nodes.lkt:3373







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_19 := Ent.Node.Array_Literal_F_Expected_Exprs_Type_Var'Unrestricted_Access;
--# expr-done 1941
Bind_Result_4 := Solver.Create_Unify (Fld_18, Fld_19, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3373:21") else null)); 
--# expr-done 1942
And_Pred_3 := Create_And (Fld_17, Bind_Result_4, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3370:17") else null)); 
--# expr-done 1943




   --# scope-start



--# expr-start 1948 bind Dyn_Var_Bind_Result_1 nodes.lkt:3379





--# expr-start 1944 'Entity[Expr].node' Fld_20 nodes.lkt:3379









Fld_20 := Item_1.Node;
--# expr-done 1944



   
      Cast_Result_3 := Fld_20;


Error_Location_1 := Cast_Result_3; 
--# expr-start 1947 LogicPropagate Pred_1 nodes.lkt:3380
--# expr-start 1945 Expr.expected_type_var Fld_21 nodes.lkt:3381







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_21 := Item_1.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 1945
Fld_21.Value := No_Entity;
Entity_Vars.Reset (Fld_21);
--# expr-start 1946 Expr.actual_type_var Fld_22 nodes.lkt:3382







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_22 := Item_1.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 1946
Fld_22.Value := No_Entity;
Entity_Vars.Reset (Fld_22);


Pred_1 := Solver.Create_N_Predicate ((Fld_21, Fld_22), Create_Type_Decl_P_Matching_Type_0_Predicate (2, Error_Location_1)); 
--# expr-done 1947
Dyn_Var_Bind_Result_1 := Pred_1; Inc_Ref (Dyn_Var_Bind_Result_1);
--# expr-done 1948
Scope_Result_1 := Dyn_Var_Bind_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_701;


And_Pred_4 := Create_And (And_Pred_3, Scope_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3368:13") else null)); 
--# expr-done 1949
      

         declare
            Item_To_Append : constant Logic_Equation := And_Pred_4;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_700;



         end loop;
      end;
   
      end if;

   

         Map_Result_1 := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_1_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result_1.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3366:25") else null)); 
--# expr-done 1950
And_Pred_5 := Create_And (And_Pred_2, Logic_Boolean_Op, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3335:9") else null)); 
--# expr-done 1951

         Property_Result := And_Pred_5;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_281;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_281;
                     Finalizer_Scope_699;
                     Finalizer_Scope_700;
                     Finalizer_Scope_701;




            raise;
      end;



   return Property_Result;
end Array_Literal_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Base_Call_Expr
   --

   



      
      procedure Initialize_Fields_For_Base_Call_Expr
        (Self : Bare_Base_Call_Expr
         ; Base_Call_Expr_F_Name : Bare_Expr
         ; Base_Call_Expr_F_Args : Bare_Argument_List
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Base_Call_Expr_F_Name := Base_Call_Expr_F_Name;
            Self.Base_Call_Expr_F_Args := Base_Call_Expr_F_Args;
         

      end Initialize_Fields_For_Base_Call_Expr;

      
   function Base_Call_Expr_F_Name
     (Node : Bare_Base_Call_Expr) return Bare_Expr
   is
      

   begin
         
         return Node.Base_Call_Expr_F_Name;
      
   end;

      
   function Base_Call_Expr_F_Args
     (Node : Bare_Base_Call_Expr) return Bare_Argument_List
   is
      

   begin
         
         return Node.Base_Call_Expr_F_Args;
      
   end;


   







--# property-start BaseCallExpr.generic_type_equation_helper nodes.lkt:3398
pragma Warnings (Off, "is not referenced");

function Base_Call_Expr_P_Generic_Type_Equation_Helper
  
  (Node : Bare_Base_Call_Expr
      ; In_Logic_Call : Boolean
         := False
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Base_Call_Expr :=
     Bare_Base_Call_Expr (Node);
     Ent : Internal_Entity_Base_Call_Expr :=
       Internal_Entity_Base_Call_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind in_logic_call In_Logic_Call

   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_282 with Inline_Always;
            procedure Finalizer_Scope_702 with Inline_Always;
            procedure Finalizer_Scope_703 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Internal_Entity_Expr;
Fld_3 : Boolean;
Fld_4 : Internal_Entity_Expr;
Fld_5 : Logic_Var;
Fld_6 : Internal_Entity_Expr;
Fld_7 : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
If_Result : Logic_Equation;
Fld_8 : Internal_Entity_Argument_List;
Item : Internal_Entity_Argument;
Current_Name : Internal_Entity_Argument;
True_Rel : Logic_Equation;
Fld_9 : Internal_Entity_Expr;
Is_A : Boolean;
Fld_10 : Internal_Entity_Expr;
Fld_11 : Logic_Var;
Fld_12 : Internal_Entity_Expr;
Fld_13 : Logic_Var;
Bind_Result_1 : Logic_Equation;
If_Result_1 : Logic_Equation;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
Fld_14 : Bare_Argument_List;
Fld_15 : Internal_Entity_Info;
Bare_Item : Bare_Argument;
As_Entity : Internal_Entity_Argument;
Is_Null : Boolean;
If_Result_2 : Internal_Entity_Argument;
Map_Result : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;
And_Pred : Logic_Equation;

            procedure Finalizer_Scope_282 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (If_Result);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Logic_Boolean_Op);
                     Dec_Ref (And_Pred);
            end Finalizer_Scope_282;
            procedure Finalizer_Scope_702 is
            begin
                     Dec_Ref (Scope_Result);
            end Finalizer_Scope_702;
            procedure Finalizer_Scope_703 is
            begin
                     Dec_Ref (True_Rel);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (If_Result_1);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_703;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1974 LogicAnd And_Pred nodes.lkt:3399
--# expr-start 1961 If If_Result nodes.lkt:3400



--# expr-start 1953 Expr.xref_entry_point Fld_3 nodes.lkt:3400



--# expr-start 1952 BaseCallExpr.name Fld_2 nodes.lkt:3400







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 1952



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_entry_point'
Fld_3 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Entry_Point (Node => Fld_2.Node, E_Info => Fld_2.Info);
--# end
--# expr-done 1953
if Fld_3 then
   --# expr-start 1958 LogicAssign Bind_Result nodes.lkt:3401
--# expr-start 1955 Expr.generic_func_type_var Fld_5 nodes.lkt:3401



--# expr-start 1954 BaseCallExpr.name Fld_4 nodes.lkt:3401







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 1954



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Fld_4.Node.Expr_F_Generic_Func_Type_Var'Unrestricted_Access;
--# expr-done 1955
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);





--# expr-start 1957 Expr.get_type Fld_7 nodes.lkt:3401



--# expr-start 1956 BaseCallExpr.name Fld_6 nodes.lkt:3401







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 1956



   if Fld_6.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.get_type'
Fld_7 := Liblktlang.Implementation.Dispatcher_Expr_P_Get_Type (Node => Fld_6.Node, E_Info => Fld_6.Info);
--# end
--# expr-done 1957



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_7.Node,
         Info => Fld_7.Info);


Bind_Result := Solver.Create_Assign (Fld_5, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3401:18") else null)); 
--# expr-done 1958
   If_Result := Bind_Result;
else
   --# expr-start 1960 LktNode.generic_type_equation Fld_1 nodes.lkt:3402



--# expr-start 1959 BaseCallExpr.name Fld nodes.lkt:3402







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 1959



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.generic_type_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Generic_Type_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 1960
   If_Result := Fld_1;
end if;

      Inc_Ref (If_Result);


--# expr-done 1961
--# expr-start 1973 .logic_all Logic_Boolean_Op nodes.lkt:3404








   

   --# expr-start 1962 BaseCallExpr.args Fld_8 nodes.lkt:3404







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Create_Internal_Entity_Argument_List (Node => Ent.Node.Base_Call_Expr_F_Args, Info => Ent.Info);
--# expr-done 1962









Fld_14 := Fld_8.Node;

   
      declare
         Map_Result_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      if Fld_14 = null then
         
      Map_Result := Create_Logic_Equation_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Argument_List := Fld_14;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result_2 := No_Entity_Argument;
else
   








Fld_15 := Fld_8.Info;

As_Entity := (Info => Fld_15, Node => Bare_Item); 
   If_Result_2 := As_Entity;
end if;



                  Item := If_Result_2; 

            
   --# scope-start


               --# bind arg Item

            
         
         
      



   --# scope-start



--# expr-start 1972 bind Dyn_Var_Bind_Result nodes.lkt:3406

Current_Name := Item; 
--# expr-start 1971 If If_Result_1 nodes.lkt:3410



--# expr-start 1964 IsA Is_A nodes.lkt:3410
--# expr-start 1963 BaseCallExpr.name Fld_9 nodes.lkt:3410







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 1963
Is_A := Fld_9.Node /= null 
and then Fld_9.Node.Kind in Lkt_Dot_Expr_Range | Lkt_Ref_Id_Range; 
--# expr-done 1964
if Is_A then
   --# expr-start 1969 LogicPropagate Bind_Result_1 nodes.lkt:3412
--# expr-start 1966 Expr.generic_func_type_var Fld_13 nodes.lkt:3414



--# expr-start 1965 BaseCallExpr.name Fld_12 nodes.lkt:3414







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_12 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 1965



   if Fld_12.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_13 := Fld_12.Node.Expr_F_Generic_Func_Type_Var'Unrestricted_Access;
--# expr-done 1966
Fld_13.Value := No_Entity;
Entity_Vars.Reset (Fld_13);
--# expr-start 1968 Expr.generic_func_type_var Fld_11 nodes.lkt:3412



--# expr-start 1967 Argument.value Fld_10 nodes.lkt:3412







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 1967



   if Fld_10.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Fld_10.Node.Expr_F_Generic_Func_Type_Var'Unrestricted_Access;
--# expr-done 1968
Fld_11.Value := No_Entity;
Entity_Vars.Reset (Fld_11);


Bind_Result_1 := Solver.Create_Propagate (Fld_13, Fld_11, Create_Type_Decl_P_Match_Param_Get_Type_0_Functor (Current_Name, In_Logic_Call)); 
--# expr-done 1969
   If_Result_1 := Bind_Result_1;
else
   --# expr-start 1970 LogicTrue True_Rel nodes.lkt:3416
True_Rel := Solver.Create_True ((if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3416:22") else null)); 
--# expr-done 1970
   If_Result_1 := True_Rel;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 1971
Dyn_Var_Bind_Result := If_Result_1; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 1972
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_703;


      

         declare
            Item_To_Append : constant Logic_Equation := Scope_Result;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_702;



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3404:24") else null)); 
--# expr-done 1973
And_Pred := Create_And (If_Result, Logic_Boolean_Op, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3399:9") else null)); 
--# expr-done 1974

         Property_Result := And_Pred;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_282;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_282;
                     Finalizer_Scope_702;
                     Finalizer_Scope_703;




            raise;
      end;



   return Property_Result;
end Base_Call_Expr_P_Generic_Type_Equation_Helper;
--# end

   







--# property-start BaseCallExpr.generic_type_equation nodes.lkt:3420
pragma Warnings (Off, "is not referenced");

function Base_Call_Expr_P_Generic_Type_Equation
  
  (Node : Bare_Base_Call_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Base_Call_Expr :=
     Bare_Base_Call_Expr (Node);
     Ent : Internal_Entity_Base_Call_Expr :=
       Internal_Entity_Base_Call_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_283 with Inline_Always;

      Fld : Logic_Equation;

            procedure Finalizer_Scope_283 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_283;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1975 BaseCallExpr.generic_type_equation_helper Fld nodes.lkt:3421







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start BaseCallExpr.generic_type_equation_helper
Fld := Liblktlang.Implementation.Base_Call_Expr_P_Generic_Type_Equation_Helper (Node => Ent.Node, In_Logic_Call => False, E_Info => Ent.Info);
--# end
--# expr-done 1975

         Property_Result := Fld;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_283;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_283;




            raise;
      end;



   return Property_Result;
end Base_Call_Expr_P_Generic_Type_Equation;
--# end

   







--# property-start BaseCallExpr.expected_type_equation nodes.lkt:3424
pragma Warnings (Off, "is not referenced");

function Base_Call_Expr_P_Expected_Type_Equation
  
  (Node : Bare_Base_Call_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Base_Call_Expr :=
     Bare_Base_Call_Expr (Node);
     Ent : Internal_Entity_Base_Call_Expr :=
       Internal_Entity_Base_Call_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_284 with Inline_Always;
            procedure Finalizer_Scope_707 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Var;
Fld_2 : Internal_Entity_Type_Decl;
Fld_3 : Internal_Entity_Argument_List;
Item : Internal_Entity_Argument;
Fld_4 : Internal_Entity_Type_Decl;
Fld_5 : Internal_Entity_Expr;
Fld_6 : Boolean;
Fld_7 : Internal_Entity_Expr;
Fld_8 : Internal_Entity_Type_Decl;
If_Result : Internal_Entity_Type_Decl;
Fld_9 : Bare_Argument_List;
Fld_10 : Internal_Entity_Info;
Bare_Item : Bare_Argument;
As_Entity : Internal_Entity_Argument;
Is_Null : Boolean;
If_Result_1 : Internal_Entity_Argument;
Map_Result : Internal_Entity_Type_Decl_Array_Access;
Fld_11 : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
Fld_12 : Internal_Entity_Argument_List;
Item_1 : Internal_Entity_Argument;
Fld_13 : Internal_Entity_Expr;
Fld_14 : Boolean;
Fld_15 : Bare_Argument_List;
Fld_16 : Internal_Entity_Info;
Bare_Item_1 : Bare_Argument;
As_Entity_1 : Internal_Entity_Argument;
Is_Null_1 : Boolean;
If_Result_2 : Internal_Entity_Argument;
Map_Result_1 : Internal_Entity_Argument_Array_Access;
Fld_17 : Internal_Entity_Expr;
Fld_18 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result_1 : Internal_Entity;
Bind_Result_1 : Logic_Equation;
Map_Result_2 : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;
And_Pred : Logic_Equation;

            procedure Finalizer_Scope_284 is
            begin
                     Dec_Ref (Map_Result);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (Map_Result_2);
                     Dec_Ref (Logic_Boolean_Op);
                     Dec_Ref (And_Pred);
            end Finalizer_Scope_284;
            procedure Finalizer_Scope_707 is
            begin
                     Dec_Ref (Bind_Result_1);
            end Finalizer_Scope_707;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 1997 LogicAnd And_Pred nodes.lkt:3430
--# expr-start 1988 LogicAssign Bind_Result nodes.lkt:3430
--# expr-start 1977 Expr.expected_type_var Fld_1 nodes.lkt:3430



--# expr-start 1976 BaseCallExpr.name Fld nodes.lkt:3430







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 1976



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Fld.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 1977
Fld_1.Value := No_Entity;
Entity_Vars.Reset (Fld_1);





--# expr-start 1987 TypeDecl.create_function_type Fld_11 nodes.lkt:3431



--# expr-start 1978 LktNode.any_type Fld_2 nodes.lkt:3431







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.any_type
Fld_2 := Liblktlang.Implementation.Lkt_Node_P_Any_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1978



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 1986 .map Map_Result nodes.lkt:3432








   

   --# expr-start 1979 BaseCallExpr.args Fld_3 nodes.lkt:3432







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Argument_List (Node => Ent.Node.Base_Call_Expr_F_Args, Info => Ent.Info);
--# expr-done 1979









Fld_9 := Fld_3.Node;

   
      declare
         Map_Result_Vec : Internal_Entity_Type_Decl_Vectors.Vector;
      begin
   

   

      if Fld_9 = null then
         
      Map_Result := Create_Internal_Entity_Type_Decl_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Argument_List := Fld_9;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result_1 := No_Entity_Argument;
else
   








Fld_10 := Fld_3.Info;

As_Entity := (Info => Fld_10, Node => Bare_Item); 
   If_Result_1 := As_Entity;
end if;



                  Item := If_Result_1; 

            
   --# scope-start


               --# bind a Item

            
         
         
      --# expr-start 1985 If If_Result nodes.lkt:3434



--# expr-start 1981 Expr.xref_entry_point Fld_6 nodes.lkt:3434



--# expr-start 1980 Argument.value Fld_5 nodes.lkt:3434







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 1980



   if Fld_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_entry_point'
Fld_6 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Entry_Point (Node => Fld_5.Node, E_Info => Fld_5.Info);
--# end
--# expr-done 1981
if Fld_6 then
   --# expr-start 1983 Expr.get_type Fld_8 nodes.lkt:3435



--# expr-start 1982 Argument.value Fld_7 nodes.lkt:3435







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 1982



   if Fld_7.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.get_type'
Fld_8 := Liblktlang.Implementation.Dispatcher_Expr_P_Get_Type (Node => Fld_7.Node, E_Info => Fld_7.Info);
--# end
--# expr-done 1983
   If_Result := Fld_8;
else
   --# expr-start 1984 LktNode.any_type Fld_4 nodes.lkt:3436







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.any_type
Fld_4 := Liblktlang.Implementation.Lkt_Node_P_Any_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 1984
   If_Result := Fld_4;
end if;



--# expr-done 1985
      

         declare
            Item_To_Append : constant Internal_Entity_Type_Decl := If_Result;
         begin
            Internal_Entity_Type_Decl_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Internal_Entity_Type_Decl_Array
           (Items_Count => Natural (Internal_Entity_Type_Decl_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Type_Decl_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Type_Decl_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Type_Decl_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 1986
--# property-call-start TypeDecl.create_function_type
Fld_11 := Liblktlang.Implementation.Type_Decl_P_Create_Function_Type (Node => Fld_2.Node, Params => Map_Result, E_Info => Fld_2.Info);
--# end
--# expr-done 1987



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_11.Node,
         Info => Fld_11.Info);


Bind_Result := Solver.Create_Assign (Fld_1, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3430:9") else null)); 
--# expr-done 1988
--# expr-start 1996 .logic_all Logic_Boolean_Op nodes.lkt:3439








   

   --# expr-start 1992 .filter Map_Result_1 nodes.lkt:3439








   

   --# expr-start 1989 BaseCallExpr.args Fld_12 nodes.lkt:3439







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_12 := Create_Internal_Entity_Argument_List (Node => Ent.Node.Base_Call_Expr_F_Args, Info => Ent.Info);
--# expr-done 1989









Fld_15 := Fld_12.Node;

   
      declare
         Map_Result_1_Vec : Internal_Entity_Argument_Vectors.Vector;
      begin
   

   

      if Fld_15 = null then
         
      Map_Result_1 := Create_Internal_Entity_Argument_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Argument_List := Fld_15;
      begin
         for Untyped_Item_1 of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item_1 := Untyped_Item_1; 
                  



Is_Null_1 := Bare_Item_1 = null; 
if Is_Null_1 then
   
   If_Result_2 := No_Entity_Argument;
else
   








Fld_16 := Fld_12.Info;

As_Entity_1 := (Info => Fld_16, Node => Bare_Item_1); 
   If_Result_2 := As_Entity_1;
end if;



                  Item_1 := If_Result_2; 

            
   --# scope-start


               --# bind p Item_1

            
         --# expr-start 1991 Expr.xref_entry_point Fld_14 nodes.lkt:3439



--# expr-start 1990 Argument.value Fld_13 nodes.lkt:3439







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_13 := Create_Internal_Entity_Expr (Node => Item_1.Node.Argument_F_Value, Info => Item_1.Info);
--# expr-done 1990



   if Fld_13.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_entry_point'
Fld_14 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Entry_Point (Node => Fld_13.Node, E_Info => Fld_13.Info);
--# end
--# expr-done 1991
         if Fld_14 then
            
         
      
      

         declare
            Item_To_Append : constant Internal_Entity_Argument := Item_1;
         begin
            Internal_Entity_Argument_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
         end if;
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result_1 := Create_Internal_Entity_Argument_Array
           (Items_Count => Natural (Internal_Entity_Argument_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Internal_Entity_Argument_Vectors.Get
              (Map_Result_1_Vec,
               I + Internal_Entity_Argument_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Internal_Entity_Argument_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 1992

   
      declare
         Map_Result_2_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Argument_Array_Access := Map_Result_1;
      begin
         for Item_2 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind p Item_2

            
         
         
      --# expr-start 1995 LogicAssign Bind_Result_1 nodes.lkt:3440
--# expr-start 1994 Expr.expected_type_var Fld_18 nodes.lkt:3440



--# expr-start 1993 Argument.value Fld_17 nodes.lkt:3440







   if Item_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_17 := Create_Internal_Entity_Expr (Node => Item_2.Node.Argument_F_Value, Info => Item_2.Info);
--# expr-done 1993



   if Fld_17.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_18 := Fld_17.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 1994
Fld_18.Value := No_Entity;
Entity_Vars.Reset (Fld_18);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_18, Cast_Result_1, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3440:20") else null)); 
--# expr-done 1995
      

         declare
            Item_To_Append : constant Logic_Equation := Bind_Result_1;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_2_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_707;



         end loop;
      end;
   

   

         Map_Result_2 := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_2_Vec)));
         for I in Map_Result_2.Items'Range loop
            Map_Result_2.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_2_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result_2.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_2_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result_2.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3439:66") else null)); 
--# expr-done 1996
And_Pred := Create_And (Bind_Result, Logic_Boolean_Op, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3430:9") else null)); 
--# expr-done 1997

         Property_Result := And_Pred;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_284;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_284;
                     Finalizer_Scope_707;




            raise;
      end;



   return Property_Result;
end Base_Call_Expr_P_Expected_Type_Equation;
--# end

   







--# property-start BaseCallExpr.xref_call_args_equation nodes.lkt:3446
pragma Warnings (Off, "is not referenced");

function Base_Call_Expr_P_Xref_Call_Args_Equation
  
  (Node : Bare_Base_Call_Expr
      ; In_Logic_Call : Boolean
         := False
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Base_Call_Expr :=
     Bare_Base_Call_Expr (Node);
     Ent : Internal_Entity_Base_Call_Expr :=
       Internal_Entity_Base_Call_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind in_logic_call In_Logic_Call

   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_285 with Inline_Always;
            procedure Finalizer_Scope_708 with Inline_Always;
            procedure Finalizer_Scope_709 with Inline_Always;
            procedure Finalizer_Scope_710 with Inline_Always;
            procedure Finalizer_Scope_711 with Inline_Always;

      Fld : Internal_Entity_Argument_List;
Item : Internal_Entity_Argument;
True_Rel : Logic_Equation;
Fld_1 : Internal_Entity_Expr;
Fld_2 : Boolean;
Not_Val : Boolean;
Fld_3 : Internal_Entity_Expr;
Fld_4 : Logic_Equation;
If_Result : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_5 : Internal_Entity_Ref_Id;
Fld_6 : Bare_Ref_Id;
Current_Name : Internal_Entity_Argument;
Fld_7 : Internal_Entity_Expr;
Fld_8 : Logic_Var;
Fld_9 : Internal_Entity_Expr;
Fld_10 : Logic_Var;
Bind_Result : Logic_Equation;
Fld_11 : Internal_Entity_Ref_Id;
Fld_12 : Logic_Var;
Fld_13 : Internal_Entity_Expr;
Fld_14 : Logic_Var;
Bind_Result_1 : Logic_Equation;
Fld_15 : Internal_Entity_Expr;
Fld_16 : Internal_Entity_Ref_Id;
Var_Expr : Internal_Entity_Ref_Id;
Fld_17 : Internal_Entity_Ref_Id;
Fld_18 : Logic_Var;
Fld_19 : Internal_Entity_Expr;
Fld_20 : Logic_Var;
Fld_21 : Logic_Var;
Pred : Logic_Equation;
Scope_Result : Logic_Equation;
Fld_22 : Internal_Entity_Ref_Id;
Fld_23 : Logic_Var;
Fld_24 : Internal_Entity_Expr;
Fld_25 : Logic_Var;
Pred_1 : Logic_Equation;
Result_Var : Logic_Equation;
And_Pred : Logic_Equation;
Fld_26 : Internal_Entity_Ref_Id;
Is_Null : Boolean;
True_Rel_1 : Logic_Equation;
If_Result_1 : Logic_Equation;
And_Pred_1 : Logic_Equation;
Dyn_Var_Bind_Result : Logic_Equation;
Cast_Result : Bare_Lkt_Node;
Dyn_Var_Bind_Result_1 : Logic_Equation;
Scope_Result_1 : Logic_Equation;
And_Pred_2 : Logic_Equation;
Error_Location_1 : Bare_Lkt_Node;
Fld_27 : Internal_Entity_Expr;
Fld_28 : Bare_Expr;
Fld_29 : Internal_Entity_Expr;
Fld_30 : Logic_Var;
Fld_31 : Internal_Entity_Expr;
Fld_32 : Logic_Var;
Pred_2 : Logic_Equation;
Fld_33 : Internal_Entity_Expr;
Fld_34 : Boolean;
Fld_35 : Internal_Entity_Expr;
Fld_36 : Logic_Var;
Fld_37 : Internal_Entity_Expr;
Fld_38 : Internal_Entity_Type_Decl;
Pred_3 : Logic_Equation;
If_Result_2 : Logic_Equation;
Fld_39 : Internal_Entity_Expr;
Fld_40 : Logic_Var;
Fld_41 : Internal_Entity_Expr;
Fld_42 : Logic_Var;
Pred_4 : Logic_Equation;
Fld_43 : Internal_Entity_Expr;
Fld_44 : Boolean;
Fld_45 : Internal_Entity_Expr;
Fld_46 : Logic_Var;
Fld_47 : Internal_Entity_Expr;
Fld_48 : Internal_Entity_Type_Decl;
Pred_5 : Logic_Equation;
If_Result_3 : Logic_Equation;
If_Result_4 : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_2 : Logic_Equation;
Scope_Result_2 : Logic_Equation;
And_Pred_3 : Logic_Equation;
Fld_49 : Bare_Argument_List;
Fld_50 : Internal_Entity_Info;
Bare_Item : Bare_Argument;
As_Entity : Internal_Entity_Argument;
Is_Null_1 : Boolean;
If_Result_5 : Internal_Entity_Argument;
Map_Result : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;

            procedure Finalizer_Scope_285 is
            begin
                     Dec_Ref (Map_Result);
                     Dec_Ref (Logic_Boolean_Op);
            end Finalizer_Scope_285;
            procedure Finalizer_Scope_708 is
            begin
                     Dec_Ref (True_Rel);
                     Dec_Ref (Fld_4);
                     Dec_Ref (If_Result);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Scope_Result_2);
                     Dec_Ref (And_Pred_3);
            end Finalizer_Scope_708;
            procedure Finalizer_Scope_709 is
            begin
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Pred_1);
                     Dec_Ref (Result_Var);
                     Dec_Ref (And_Pred);
                     Dec_Ref (True_Rel_1);
                     Dec_Ref (If_Result_1);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Dyn_Var_Bind_Result);
                     Dec_Ref (Dyn_Var_Bind_Result_1);
            end Finalizer_Scope_709;
            procedure Finalizer_Scope_710 is
            begin
                     Dec_Ref (Pred);
            end Finalizer_Scope_710;
            procedure Finalizer_Scope_711 is
            begin
                     Dec_Ref (Pred_2);
                     Dec_Ref (Pred_3);
                     Dec_Ref (If_Result_2);
                     Dec_Ref (Pred_4);
                     Dec_Ref (Pred_5);
                     Dec_Ref (If_Result_3);
                     Dec_Ref (If_Result_4);
                     Dec_Ref (Dyn_Var_Bind_Result_2);
            end Finalizer_Scope_711;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2072 .logic_all Logic_Boolean_Op nodes.lkt:3447








   

   --# expr-start 1998 BaseCallExpr.args Fld nodes.lkt:3447







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Argument_List (Node => Ent.Node.Base_Call_Expr_F_Args, Info => Ent.Info);
--# expr-done 1998









Fld_49 := Fld.Node;

   
      declare
         Map_Result_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      if Fld_49 = null then
         
      Map_Result := Create_Logic_Equation_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Argument_List := Fld_49;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null_1 := Bare_Item = null; 
if Is_Null_1 then
   
   If_Result_5 := No_Entity_Argument;
else
   








Fld_50 := Fld.Info;

As_Entity := (Info => Fld_50, Node => Bare_Item); 
   If_Result_5 := As_Entity;
end if;



                  Item := If_Result_5; 

            
   --# scope-start


               --# bind arg Item

            
         
         
      --# expr-start 2071 LogicAnd And_Pred_3 nodes.lkt:3449
--# expr-start 2040 LogicAnd And_Pred_2 nodes.lkt:3449
--# expr-start 2005 If If_Result nodes.lkt:3450



--# expr-start 2001 Not Not_Val nodes.lkt:3450
--# expr-start 2000 Expr.xref_entry_point Fld_2 nodes.lkt:3450



--# expr-start 1999 Argument.value Fld_1 nodes.lkt:3450







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 1999



   if Fld_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_entry_point'
Fld_2 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Entry_Point (Node => Fld_1.Node, E_Info => Fld_1.Info);
--# end
--# expr-done 2000
Not_Val := not (Fld_2); 
--# expr-done 2001
if Not_Val then
   --# expr-start 2003 LktNode.xref_equation Fld_4 nodes.lkt:3451



--# expr-start 2002 Argument.value Fld_3 nodes.lkt:3451







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 2002



   if Fld_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_4 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld_3.Node, E_Info => Fld_3.Info);
--# end
--# expr-done 2003
   If_Result := Fld_4;
else
   --# expr-start 2004 LogicTrue True_Rel nodes.lkt:3452
True_Rel := Solver.Create_True ((if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3452:22") else null)); 
--# expr-done 2004
   If_Result := True_Rel;
end if;

      Inc_Ref (If_Result);


--# expr-done 2005




   --# scope-start



--# expr-start 2039 bind Dyn_Var_Bind_Result_1 nodes.lkt:3455





--# expr-start 2007 'Entity[RefId].node' Fld_6 nodes.lkt:3455



--# expr-start 2006 Argument.name Fld_5 nodes.lkt:3455







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Ref_Id (Node => Item.Node.Argument_F_Name, Info => Item.Info);
--# expr-done 2006





Fld_6 := Fld_5.Node;
--# expr-done 2007



   
      Cast_Result := Fld_6;


Error_Location := Cast_Result; 
--# expr-start 2038 bind Dyn_Var_Bind_Result nodes.lkt:3456

Current_Name := Item; 
--# expr-start 2037 LogicAnd And_Pred_1 nodes.lkt:3458
--# expr-start 2012 LogicPropagate Bind_Result nodes.lkt:3458
--# expr-start 2009 Expr.actual_type_var Fld_10 nodes.lkt:3459



--# expr-start 2008 BaseCallExpr.name Fld_9 nodes.lkt:3459







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2008



   if Fld_9.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Fld_9.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2009
Fld_10.Value := No_Entity;
Entity_Vars.Reset (Fld_10);
--# expr-start 2011 Expr.expected_type_var Fld_8 nodes.lkt:3458



--# expr-start 2010 Argument.value Fld_7 nodes.lkt:3458







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 2010



   if Fld_7.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Fld_7.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2011
Fld_8.Value := No_Entity;
Entity_Vars.Reset (Fld_8);


Bind_Result := Solver.Create_Propagate (Fld_10, Fld_8, Create_Type_Decl_P_Match_Param_Get_Type_0_Functor (Current_Name, In_Logic_Call)); 
--# expr-done 2012
--# expr-start 2036 If If_Result_1 nodes.lkt:3461



--# expr-start 2014 .is_null Is_Null nodes.lkt:3461
--# expr-start 2013 Argument.name Fld_26 nodes.lkt:3461







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_26 := Create_Internal_Entity_Ref_Id (Node => Item.Node.Argument_F_Name, Info => Item.Info);
--# expr-done 2013
Is_Null := Fld_26.Node = null; 
--# expr-done 2014
if Is_Null then
   --# expr-start 2015 LogicTrue True_Rel_1 nodes.lkt:3462
True_Rel_1 := Solver.Create_True ((if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3462:26") else null)); 
--# expr-done 2015
   If_Result_1 := True_Rel_1;
else
   --# expr-start 2035 LogicAnd And_Pred nodes.lkt:3464
--# expr-start 2020 LogicPropagate Bind_Result_1 nodes.lkt:3464
--# expr-start 2017 Expr.actual_type_var Fld_14 nodes.lkt:3466



--# expr-start 2016 BaseCallExpr.name Fld_13 nodes.lkt:3466







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_13 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2016



   if Fld_13.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_14 := Fld_13.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2017
Fld_14.Value := No_Entity;
Entity_Vars.Reset (Fld_14);
--# expr-start 2019 RefId.ref_var Fld_12 nodes.lkt:3464



--# expr-start 2018 Argument.name Fld_11 nodes.lkt:3464







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Create_Internal_Entity_Ref_Id (Node => Item.Node.Argument_F_Name, Info => Item.Info);
--# expr-done 2018



   if Fld_11.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_12 := Fld_11.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2019
Fld_12.Value := No_Entity;
Entity_Vars.Reset (Fld_12);


Bind_Result_1 := Solver.Create_Propagate (Fld_14, Fld_12, Create_Type_Decl_P_Match_Param_Get_Decl_0_Functor (Current_Name, In_Logic_Call)); 
--# expr-done 2020
--# expr-start 2034 .do Result_Var nodes.lkt:3468



--# expr-start 2022 Expr.get_rightmost_refid Fld_16 nodes.lkt:3468



--# expr-start 2021 BaseCallExpr.name Fld_15 nodes.lkt:3468







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_15 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2021



   if Fld_15.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_rightmost_refid
Fld_16 := Liblktlang.Implementation.Expr_P_Get_Rightmost_Refid (Node => Fld_15.Node, E_Info => Fld_15.Info);
--# end
--# expr-done 2022
Var_Expr := Fld_16;





if Var_Expr /= No_Entity_Ref_Id then
   



   --# scope-start



--# expr-start 2028 LogicPropagate Pred nodes.lkt:3469
--# expr-start 2024 RefId.ref_var Fld_18 nodes.lkt:3470



--# expr-start 2023 Argument.name Fld_17 nodes.lkt:3470







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_17 := Create_Internal_Entity_Ref_Id (Node => Item.Node.Argument_F_Name, Info => Item.Info);
--# expr-done 2023



   if Fld_17.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_18 := Fld_17.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2024
Fld_18.Value := No_Entity;
Entity_Vars.Reset (Fld_18);
--# expr-start 2026 Expr.actual_type_var Fld_20 nodes.lkt:3471



--# expr-start 2025 BaseCallExpr.name Fld_19 nodes.lkt:3471







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_19 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2025



   if Fld_19.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_20 := Fld_19.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2026
Fld_20.Value := No_Entity;
Entity_Vars.Reset (Fld_20);
--# expr-start 2027 RefId.ref_var Fld_21 nodes.lkt:3472







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_21 := Var_Expr.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2027
Fld_21.Value := No_Entity;
Entity_Vars.Reset (Fld_21);


Pred := Solver.Create_N_Predicate ((Fld_18, Fld_20, Fld_21), Create_Decl_P_Extraneous_Parameter_0_Predicate (3, Error_Location)); 
--# expr-done 2028
Scope_Result := Pred;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_710;


   Result_Var := Scope_Result;
else
   --# expr-start 2033 LogicPropagate Pred_1 nodes.lkt:3476
--# expr-start 2030 RefId.ref_var Fld_23 nodes.lkt:3477



--# expr-start 2029 Argument.name Fld_22 nodes.lkt:3477







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_22 := Create_Internal_Entity_Ref_Id (Node => Item.Node.Argument_F_Name, Info => Item.Info);
--# expr-done 2029



   if Fld_22.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_23 := Fld_22.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2030
Fld_23.Value := No_Entity;
Entity_Vars.Reset (Fld_23);
--# expr-start 2032 Expr.actual_type_var Fld_25 nodes.lkt:3478



--# expr-start 2031 BaseCallExpr.name Fld_24 nodes.lkt:3478







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_24 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2031



   if Fld_24.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_25 := Fld_24.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2032
Fld_25.Value := No_Entity;
Entity_Vars.Reset (Fld_25);


Pred_1 := Solver.Create_N_Predicate ((Fld_23, Fld_25), Create_Decl_P_Unmatched_Argument_0_Predicate (2, Error_Location)); 
--# expr-done 2033
   Result_Var := Pred_1;
end if;

      Inc_Ref (Result_Var);


--# expr-done 2034
And_Pred := Create_And (Bind_Result_1, Result_Var, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3464:25") else null)); 
--# expr-done 2035
   If_Result_1 := And_Pred;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 2036
And_Pred_1 := Create_And (Bind_Result, If_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3458:17") else null)); 
--# expr-done 2037
Dyn_Var_Bind_Result := And_Pred_1; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2038
Dyn_Var_Bind_Result_1 := Dyn_Var_Bind_Result; Inc_Ref (Dyn_Var_Bind_Result_1);
--# expr-done 2039
Scope_Result_1 := Dyn_Var_Bind_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_709;


And_Pred_2 := Create_And (If_Result, Scope_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3449:13") else null)); 
--# expr-done 2040




   --# scope-start



--# expr-start 2070 bind Dyn_Var_Bind_Result_2 nodes.lkt:3485





--# expr-start 2042 'Entity[Expr].node' Fld_28 nodes.lkt:3485



--# expr-start 2041 Argument.value Fld_27 nodes.lkt:3485







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_27 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 2041





Fld_28 := Fld_27.Node;
--# expr-done 2042



   
      Cast_Result_1 := Fld_28;


Error_Location_1 := Cast_Result_1; 
--# expr-start 2069 If If_Result_4 nodes.lkt:3486




if In_Logic_Call then
   --# expr-start 2055 If If_Result_3 nodes.lkt:3488



--# expr-start 2044 Expr.xref_entry_point Fld_44 nodes.lkt:3488



--# expr-start 2043 Argument.value Fld_43 nodes.lkt:3488







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_43 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 2043



   if Fld_43.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_entry_point'
Fld_44 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Entry_Point (Node => Fld_43.Node, E_Info => Fld_43.Info);
--# end
--# expr-done 2044
if Fld_44 then
   --# expr-start 2049 LogicPropagate Pred_5 nodes.lkt:3489
--# expr-start 2046 Expr.expected_type_var Fld_46 nodes.lkt:3490



--# expr-start 2045 Argument.value Fld_45 nodes.lkt:3490







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_45 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 2045



   if Fld_45.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_46 := Fld_45.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2046
Fld_46.Value := No_Entity;
Entity_Vars.Reset (Fld_46);
--# expr-start 2048 Expr.get_type Fld_48 nodes.lkt:3491



--# expr-start 2047 Argument.value Fld_47 nodes.lkt:3491







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_47 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 2047



   if Fld_47.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.get_type'
Fld_48 := Liblktlang.Implementation.Dispatcher_Expr_P_Get_Type (Node => Fld_47.Node, E_Info => Fld_47.Info);
--# end
--# expr-done 2048

Pred_5 := Solver.Create_Predicate (Fld_46, Create_Type_Decl_P_Matching_Logic_Type_1_Predicate (Fld_48, Error_Location_1)); 
--# expr-done 2049
   If_Result_3 := Pred_5;
else
   --# expr-start 2054 LogicPropagate Pred_4 nodes.lkt:3494
--# expr-start 2051 Expr.expected_type_var Fld_40 nodes.lkt:3495



--# expr-start 2050 Argument.value Fld_39 nodes.lkt:3495







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_39 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 2050



   if Fld_39.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_40 := Fld_39.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2051
Fld_40.Value := No_Entity;
Entity_Vars.Reset (Fld_40);
--# expr-start 2053 Expr.actual_type_var Fld_42 nodes.lkt:3496



--# expr-start 2052 Argument.value Fld_41 nodes.lkt:3496







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_41 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 2052



   if Fld_41.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_42 := Fld_41.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2053
Fld_42.Value := No_Entity;
Entity_Vars.Reset (Fld_42);


Pred_4 := Solver.Create_N_Predicate ((Fld_40, Fld_42), Create_Type_Decl_P_Matching_Logic_Type_0_Predicate (2, Error_Location_1)); 
--# expr-done 2054
   If_Result_3 := Pred_4;
end if;

      Inc_Ref (If_Result_3);


--# expr-done 2055
   If_Result_4 := If_Result_3;
else
   --# expr-start 2068 If If_Result_2 nodes.lkt:3499



--# expr-start 2057 Expr.xref_entry_point Fld_34 nodes.lkt:3499



--# expr-start 2056 Argument.value Fld_33 nodes.lkt:3499







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_33 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 2056



   if Fld_33.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_entry_point'
Fld_34 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Entry_Point (Node => Fld_33.Node, E_Info => Fld_33.Info);
--# end
--# expr-done 2057
if Fld_34 then
   --# expr-start 2062 LogicPropagate Pred_3 nodes.lkt:3500
--# expr-start 2059 Expr.expected_type_var Fld_36 nodes.lkt:3501



--# expr-start 2058 Argument.value Fld_35 nodes.lkt:3501







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_35 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 2058



   if Fld_35.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_36 := Fld_35.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2059
Fld_36.Value := No_Entity;
Entity_Vars.Reset (Fld_36);
--# expr-start 2061 Expr.get_type Fld_38 nodes.lkt:3502



--# expr-start 2060 Argument.value Fld_37 nodes.lkt:3502







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_37 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 2060



   if Fld_37.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.get_type'
Fld_38 := Liblktlang.Implementation.Dispatcher_Expr_P_Get_Type (Node => Fld_37.Node, E_Info => Fld_37.Info);
--# end
--# expr-done 2061

Pred_3 := Solver.Create_Predicate (Fld_36, Create_Type_Decl_P_Matching_Type_1_Predicate (Fld_38, Error_Location_1)); 
--# expr-done 2062
   If_Result_2 := Pred_3;
else
   --# expr-start 2067 LogicPropagate Pred_2 nodes.lkt:3505
--# expr-start 2064 Expr.expected_type_var Fld_30 nodes.lkt:3506



--# expr-start 2063 Argument.value Fld_29 nodes.lkt:3506







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_29 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 2063



   if Fld_29.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_30 := Fld_29.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2064
Fld_30.Value := No_Entity;
Entity_Vars.Reset (Fld_30);
--# expr-start 2066 Expr.actual_type_var Fld_32 nodes.lkt:3507



--# expr-start 2065 Argument.value Fld_31 nodes.lkt:3507







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_31 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 2065



   if Fld_31.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_32 := Fld_31.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2066
Fld_32.Value := No_Entity;
Entity_Vars.Reset (Fld_32);


Pred_2 := Solver.Create_N_Predicate ((Fld_30, Fld_32), Create_Type_Decl_P_Matching_Type_0_Predicate (2, Error_Location_1)); 
--# expr-done 2067
   If_Result_2 := Pred_2;
end if;

      Inc_Ref (If_Result_2);


--# expr-done 2068
   If_Result_4 := If_Result_2;
end if;

      Inc_Ref (If_Result_4);


--# expr-done 2069
Dyn_Var_Bind_Result_2 := If_Result_4; Inc_Ref (Dyn_Var_Bind_Result_2);
--# expr-done 2070
Scope_Result_2 := Dyn_Var_Bind_Result_2;
   Inc_Ref (Scope_Result_2);


   --# end
      Finalizer_Scope_711;


And_Pred_3 := Create_And (And_Pred_2, Scope_Result_2, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3449:13") else null)); 
--# expr-done 2071
      

         declare
            Item_To_Append : constant Logic_Equation := And_Pred_3;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_708;



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3447:19") else null)); 
--# expr-done 2072

         Property_Result := Logic_Boolean_Op;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_285;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_285;
                     Finalizer_Scope_708;
                     Finalizer_Scope_709;
                     Finalizer_Scope_710;
                     Finalizer_Scope_711;




            raise;
      end;



   return Property_Result;
end Base_Call_Expr_P_Xref_Call_Args_Equation;
--# end

   







--# property-start BaseCallExpr.xref_call_equation nodes.lkt:3515
pragma Warnings (Off, "is not referenced");

function Base_Call_Expr_P_Xref_Call_Equation
  
  (Node : Bare_Base_Call_Expr
      ; In_Logic_Call : Boolean
         := False
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Base_Call_Expr :=
     Bare_Base_Call_Expr (Node);
     Ent : Internal_Entity_Base_Call_Expr :=
       Internal_Entity_Base_Call_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind in_logic_call In_Logic_Call

   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_286 with Inline_Always;
            procedure Finalizer_Scope_712 with Inline_Always;
            procedure Finalizer_Scope_713 with Inline_Always;

      Fld : Logic_Equation;
Fld_1 : Internal_Entity_Expr;
Fld_2 : Logic_Var;
Fld_3 : Internal_Entity_Expr;
Fld_4 : Logic_Var;
Bind_Result : Logic_Equation;
Fld_5 : Internal_Entity_Expr;
Is_A : Boolean;
True_Rel : Logic_Equation;
If_Result : Logic_Equation;
And_Pred : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_6 : Internal_Entity_Expr;
Fld_7 : Logic_Var;
Fld_8 : Internal_Entity_Argument_List;
Pred : Logic_Equation;
Cast_Result : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;
Error_Location_1 : Bare_Lkt_Node;
Fld_9 : Bare_Expr;
Fld_10 : Internal_Entity_Expr;
Fld_11 : Logic_Var;
Pred_1 : Logic_Equation;
Fld_12 : Internal_Entity_Expr;
Fld_13 : Logic_Var;
Fld_14 : Internal_Entity_Expr;
Fld_15 : Internal_Entity_Type_Decl;
Cast_Result_1 : Internal_Entity_Function_Type;
Pred_2 : Logic_Equation;
And_Pred_2 : Logic_Equation;
Cast_Result_2 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_1 : Logic_Equation;
Scope_Result_1 : Logic_Equation;
And_Pred_3 : Logic_Equation;

            procedure Finalizer_Scope_286 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (True_Rel);
                     Dec_Ref (If_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (And_Pred_3);
            end Finalizer_Scope_286;
            procedure Finalizer_Scope_712 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_712;
            procedure Finalizer_Scope_713 is
            begin
                     Dec_Ref (Pred_1);
                     Dec_Ref (Pred_2);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Dyn_Var_Bind_Result_1);
            end Finalizer_Scope_713;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2102 LogicAnd And_Pred_3 nodes.lkt:3516
--# expr-start 2089 LogicAnd And_Pred_1 nodes.lkt:3516
--# expr-start 2083 LogicAnd And_Pred nodes.lkt:3516
--# expr-start 2073 BaseCallExpr.xref_call_args_equation Fld nodes.lkt:3516







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start BaseCallExpr.xref_call_args_equation
Fld := Liblktlang.Implementation.Base_Call_Expr_P_Xref_Call_Args_Equation (Node => Ent.Node, In_Logic_Call => In_Logic_Call, E_Info => Ent.Info);
--# end
--# expr-done 2073
--# expr-start 2082 If If_Result nodes.lkt:3521



--# expr-start 2075 IsA Is_A nodes.lkt:3521
--# expr-start 2074 BaseCallExpr.name Fld_5 nodes.lkt:3521







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2074
Is_A := Fld_5.Node /= null 
and then Fld_5.Node.Kind in Lkt_Dot_Expr_Range | Lkt_Ref_Id_Range; 
--# expr-done 2075
if Is_A then
   --# expr-start 2076 LogicTrue True_Rel nodes.lkt:3521
True_Rel := Solver.Create_True ((if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3521:50") else null)); 
--# expr-done 2076
   If_Result := True_Rel;
else
   --# expr-start 2081 LogicUnify Bind_Result nodes.lkt:3523
--# expr-start 2078 Expr.generic_func_type_var Fld_2 nodes.lkt:3523



--# expr-start 2077 BaseCallExpr.name Fld_1 nodes.lkt:3523







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2077



   if Fld_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Fld_1.Node.Expr_F_Generic_Func_Type_Var'Unrestricted_Access;
--# expr-done 2078
Fld_2.Value := No_Entity;
Entity_Vars.Reset (Fld_2);
--# expr-start 2080 Expr.actual_type_var Fld_4 nodes.lkt:3523



--# expr-start 2079 BaseCallExpr.name Fld_3 nodes.lkt:3523







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2079



   if Fld_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Fld_3.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2080
Bind_Result := Solver.Create_Unify (Fld_2, Fld_4, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3523:17") else null)); 
--# expr-done 2081
   If_Result := Bind_Result;
end if;

      Inc_Ref (If_Result);


--# expr-done 2082
And_Pred := Create_And (Fld, If_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3516:9") else null)); 
--# expr-done 2083




   --# scope-start



--# expr-start 2088 bind Dyn_Var_Bind_Result nodes.lkt:3526









   
      Cast_Result := Self;


Error_Location := Cast_Result; 
--# expr-start 2087 LogicPropagate Pred nodes.lkt:3527
--# expr-start 2085 Expr.actual_type_var Fld_7 nodes.lkt:3527



--# expr-start 2084 BaseCallExpr.name Fld_6 nodes.lkt:3527







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2084



   if Fld_6.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Fld_6.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2085
Fld_7.Value := No_Entity;
Entity_Vars.Reset (Fld_7);
--# expr-start 2086 BaseCallExpr.args Fld_8 nodes.lkt:3527







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Create_Internal_Entity_Argument_List (Node => Ent.Node.Base_Call_Expr_F_Args, Info => Ent.Info);
--# expr-done 2086


Pred := Solver.Create_Predicate (Fld_7, Create_Type_Decl_P_Is_Valid_Call_0_Predicate (Fld_8, In_Logic_Call, Error_Location)); 
--# expr-done 2087
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2088
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_712;


And_Pred_1 := Create_And (And_Pred, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3516:9") else null)); 
--# expr-done 2089




   --# scope-start



--# expr-start 2101 bind Dyn_Var_Bind_Result_1 nodes.lkt:3531





--# expr-start 2090 BaseCallExpr.name Fld_9 nodes.lkt:3531







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Self.Base_Call_Expr_F_Name;
--# expr-done 2090



   
      Cast_Result_2 := Fld_9;


Error_Location_1 := Cast_Result_2; 
--# expr-start 2100 LogicAnd And_Pred_2 nodes.lkt:3532
--# expr-start 2093 LogicPropagate Pred_1 nodes.lkt:3532
--# expr-start 2092 Expr.actual_type_var Fld_11 nodes.lkt:3532



--# expr-start 2091 BaseCallExpr.name Fld_10 nodes.lkt:3532







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2091



   if Fld_10.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Fld_10.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2092
Fld_11.Value := No_Entity;
Entity_Vars.Reset (Fld_11);

Pred_1 := Solver.Create_Predicate (Fld_11, Create_Type_Decl_P_Is_Callable_0_Predicate (Error_Location_1)); 
--# expr-done 2093
--# expr-start 2099 LogicPropagate Pred_2 nodes.lkt:3533
--# expr-start 2095 Expr.actual_type_var Fld_13 nodes.lkt:3534



--# expr-start 2094 BaseCallExpr.name Fld_12 nodes.lkt:3534







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_12 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2094



   if Fld_12.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_13 := Fld_12.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2095
Fld_13.Value := No_Entity;
Entity_Vars.Reset (Fld_13);
--# expr-start 2098 Cast Cast_Result_1 nodes.lkt:3535





--# expr-start 2097 Expr.get_generic_type Fld_15 nodes.lkt:3535



--# expr-start 2096 BaseCallExpr.name Fld_14 nodes.lkt:3535







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_14 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2096



   if Fld_14.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_generic_type
Fld_15 := Liblktlang.Implementation.Expr_P_Get_Generic_Type (Node => Fld_14.Node, E_Info => Fld_14.Info);
--# end
--# expr-done 2097



   if Fld_15.Node = null
      or else Fld_15.Node.Kind in Lkt_Function_Type_Range
   then
      
      Cast_Result_1 := Create_Internal_Entity_Function_Type
        (Node => Fld_15.Node,
         Info => Fld_15.Info);

   else
         Cast_Result_1 := No_Entity_Function_Type;
   end if;


--# expr-done 2098

Pred_2 := Solver.Create_Predicate (Fld_13, Create_Decl_P_Could_Infer_0_Predicate (Cast_Result_1, Error_Location_1)); 
--# expr-done 2099
And_Pred_2 := Create_And (Pred_1, Pred_2, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3532:13") else null)); 
--# expr-done 2100
Dyn_Var_Bind_Result_1 := And_Pred_2; Inc_Ref (Dyn_Var_Bind_Result_1);
--# expr-done 2101
Scope_Result_1 := Dyn_Var_Bind_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_713;


And_Pred_3 := Create_And (And_Pred_1, Scope_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3516:9") else null)); 
--# expr-done 2102

         Property_Result := And_Pred_3;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_286;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_286;
                     Finalizer_Scope_712;
                     Finalizer_Scope_713;




            raise;
      end;



   return Property_Result;
end Base_Call_Expr_P_Xref_Call_Equation;
--# end

   







--# property-start BaseCallExpr.xref_equation nodes.lkt:3539
pragma Warnings (Off, "is not referenced");

function Base_Call_Expr_P_Xref_Equation
  
  (Node : Bare_Base_Call_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Base_Call_Expr :=
     Bare_Base_Call_Expr (Node);
     Ent : Internal_Entity_Base_Call_Expr :=
       Internal_Entity_Base_Call_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_287 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Logic_Equation;
And_Pred : Logic_Equation;
Fld_3 : Logic_Var;
Fld_4 : Internal_Entity_Expr;
Fld_5 : Logic_Var;
Bind_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;

            procedure Finalizer_Scope_287 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Fld_2);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred_1);
            end Finalizer_Scope_287;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2111 LogicAnd And_Pred_1 nodes.lkt:3540
--# expr-start 2106 LogicAnd And_Pred nodes.lkt:3540
--# expr-start 2104 LktNode.xref_equation Fld_1 nodes.lkt:3540



--# expr-start 2103 BaseCallExpr.name Fld nodes.lkt:3540







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2103



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2104
--# expr-start 2105 BaseCallExpr.xref_call_equation Fld_2 nodes.lkt:3542







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start BaseCallExpr.xref_call_equation
Fld_2 := Liblktlang.Implementation.Base_Call_Expr_P_Xref_Call_Equation (Node => Ent.Node, In_Logic_Call => False, E_Info => Ent.Info);
--# end
--# expr-done 2105
And_Pred := Create_And (Fld_1, Fld_2, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3540:9") else null)); 
--# expr-done 2106
--# expr-start 2110 LogicPropagate Bind_Result nodes.lkt:3543
--# expr-start 2108 Expr.actual_type_var Fld_5 nodes.lkt:3544



--# expr-start 2107 BaseCallExpr.name Fld_4 nodes.lkt:3544







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2107



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Fld_4.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2108
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);
--# expr-start 2109 Expr.actual_type_var Fld_3 nodes.lkt:3543







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2109
Fld_3.Value := No_Entity;
Entity_Vars.Reset (Fld_3);

Bind_Result := Solver.Create_Propagate (Fld_5, Fld_3, Create_Type_Decl_P_Get_Return_Type_0_Functor); 
--# expr-done 2110
And_Pred_1 := Create_And (And_Pred, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3540:9") else null)); 
--# expr-done 2111

         Property_Result := And_Pred_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_287;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_287;




            raise;
      end;



   return Property_Result;
end Base_Call_Expr_P_Xref_Equation;
--# end

   







--# property-start BaseCallExpr.xlogic_unknown nodes.lkt:3548
pragma Warnings (Off, "is not referenced");

function Base_Call_Expr_P_Xlogic_Unknown
  
  (Node : Bare_Base_Call_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Base_Call_Expr :=
     Bare_Base_Call_Expr (Node);
     Ent : Internal_Entity_Base_Call_Expr :=
       Internal_Entity_Base_Call_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_288 with Inline_Always;
            procedure Finalizer_Scope_714 with Inline_Always;
            procedure Finalizer_Scope_715 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_2 : Bare_Expr;
Fld_3 : Internal_Entity_Expr;
Fld_4 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred : Logic_Equation;
Fld_5 : Internal_Entity_Argument_List;
Item : Internal_Entity_Argument;
Fld_6 : Logic_Equation;
Fld_7 : Internal_Entity_Expr;
Fld_8 : Logic_Var;
Cast_Expr_1 : Internal_Entity_Type_Decl;
Cast_Result_2 : Internal_Entity;
Bind_Result_1 : Logic_Equation;
And_Pred_1 : Logic_Equation;
Fld_9 : Bare_Argument_List;
Fld_10 : Internal_Entity_Info;
Bare_Item : Bare_Argument;
As_Entity : Internal_Entity_Argument;
Is_Null : Boolean;
If_Result : Internal_Entity_Argument;
Map_Result : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;
And_Pred_2 : Logic_Equation;
Fld_11 : Internal_Entity_Expr;
Fld_12 : Logic_Var;
Cast_Expr_2 : Internal_Entity_Type_Decl;
Cast_Result_3 : Internal_Entity;
Bind_Result_2 : Logic_Equation;
And_Pred_3 : Logic_Equation;

            procedure Finalizer_Scope_288 is
            begin
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Logic_Boolean_Op);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Bind_Result_2);
                     Dec_Ref (And_Pred_3);
            end Finalizer_Scope_288;
            procedure Finalizer_Scope_714 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_714;
            procedure Finalizer_Scope_715 is
            begin
                     Dec_Ref (Fld_6);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (And_Pred_1);
            end Finalizer_Scope_715;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2132 LogicAnd And_Pred_3 nodes.lkt:3549
--# expr-start 2128 LogicAnd And_Pred_2 nodes.lkt:3549
--# expr-start 2120 LogicAnd And_Pred nodes.lkt:3549
--# expr-start 2114 LogicAssign Bind_Result nodes.lkt:3549
--# expr-start 2113 Expr.actual_type_var Fld_1 nodes.lkt:3549



--# expr-start 2112 BaseCallExpr.name Fld nodes.lkt:3549







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2112



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Fld.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2113
Fld_1.Value := No_Entity;
Entity_Vars.Reset (Fld_1);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result := Solver.Create_Assign (Fld_1, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3549:9") else null)); 
--# expr-done 2114




   --# scope-start



--# expr-start 2119 bind Dyn_Var_Bind_Result nodes.lkt:3551





--# expr-start 2115 BaseCallExpr.name Fld_2 nodes.lkt:3551







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Self.Base_Call_Expr_F_Name;
--# expr-done 2115



   
      Cast_Result_1 := Fld_2;


Error_Location := Cast_Result_1; 
--# expr-start 2118 LogicPropagate Pred nodes.lkt:3552
--# expr-start 2117 Expr.actual_type_var Fld_4 nodes.lkt:3552



--# expr-start 2116 BaseCallExpr.name Fld_3 nodes.lkt:3552







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2116



   if Fld_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Fld_3.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2117
Fld_4.Value := No_Entity;
Entity_Vars.Reset (Fld_4);

Pred := Solver.Create_Predicate (Fld_4, Create_Decl_P_Is_Defined_0_Predicate (Error_Location)); 
--# expr-done 2118
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2119
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_714;


And_Pred := Create_And (Bind_Result, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3549:9") else null)); 
--# expr-done 2120
--# expr-start 2127 .logic_all Logic_Boolean_Op nodes.lkt:3554








   

   --# expr-start 2121 BaseCallExpr.args Fld_5 nodes.lkt:3554







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Argument_List (Node => Ent.Node.Base_Call_Expr_F_Args, Info => Ent.Info);
--# expr-done 2121









Fld_9 := Fld_5.Node;

   
      declare
         Map_Result_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      if Fld_9 = null then
         
      Map_Result := Create_Logic_Equation_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Argument_List := Fld_9;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Argument;
else
   








Fld_10 := Fld_5.Info;

As_Entity := (Info => Fld_10, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind a Item

            
         
         
      --# expr-start 2126 LogicAnd And_Pred_1 nodes.lkt:3556
--# expr-start 2122 Argument.xref_equation Fld_6 nodes.lkt:3556







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_6 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 2122
--# expr-start 2125 LogicAssign Bind_Result_1 nodes.lkt:3557
--# expr-start 2124 Expr.expected_type_var Fld_8 nodes.lkt:3557



--# expr-start 2123 Argument.value Fld_7 nodes.lkt:3557







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 2123



   if Fld_7.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Fld_7.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2124
Fld_8.Value := No_Entity;
Entity_Vars.Reset (Fld_8);






Cast_Expr_1 := No_Entity_Type_Decl; 



   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Cast_Expr_1.Node,
         Info => Cast_Expr_1.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_8, Cast_Result_2, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3557:18") else null)); 
--# expr-done 2125
And_Pred_1 := Create_And (Fld_6, Bind_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3556:13") else null)); 
--# expr-done 2126
      

         declare
            Item_To_Append : constant Logic_Equation := And_Pred_1;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_715;



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3554:24") else null)); 
--# expr-done 2127
And_Pred_2 := Create_And (And_Pred, Logic_Boolean_Op, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3549:9") else null)); 
--# expr-done 2128
--# expr-start 2131 LogicAssign Bind_Result_2 nodes.lkt:3559
--# expr-start 2130 Expr.actual_type_var Fld_12 nodes.lkt:3559



--# expr-start 2129 BaseCallExpr.name Fld_11 nodes.lkt:3559







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2129



   if Fld_11.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_12 := Fld_11.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2130
Fld_12.Value := No_Entity;
Entity_Vars.Reset (Fld_12);






Cast_Expr_2 := No_Entity_Type_Decl; 



   
      Cast_Result_3 := Create_Internal_Entity
        (Node => Cast_Expr_2.Node,
         Info => Cast_Expr_2.Info);


Bind_Result_2 := Solver.Create_Assign (Fld_12, Cast_Result_3, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3559:14") else null)); 
--# expr-done 2131
And_Pred_3 := Create_And (And_Pred_2, Bind_Result_2, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3549:9") else null)); 
--# expr-done 2132

         Property_Result := And_Pred_3;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_288;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_288;
                     Finalizer_Scope_714;
                     Finalizer_Scope_715;




            raise;
      end;



   return Property_Result;
end Base_Call_Expr_P_Xlogic_Unknown;
--# end

   







--# property-start BaseCallExpr.xlogic_any_all nodes.lkt:3561
pragma Warnings (Off, "is not referenced");

function Base_Call_Expr_P_Xlogic_Any_All
  
  (Node : Bare_Base_Call_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Base_Call_Expr :=
     Bare_Base_Call_Expr (Node);
     Ent : Internal_Entity_Base_Call_Expr :=
       Internal_Entity_Base_Call_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_289 with Inline_Always;
            procedure Finalizer_Scope_716 with Inline_Always;
            procedure Finalizer_Scope_717 with Inline_Always;

      Fld : Logic_Var;
Fld_1 : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
Fld_2 : Internal_Entity_Expr;
Fld_3 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result_1 : Internal_Entity;
Bind_Result_1 : Logic_Equation;
And_Pred : Logic_Equation;
Fld_4 : Internal_Entity_Argument_List;
Item : Internal_Entity_Argument;
Fld_5 : Logic_Equation;
Fld_6 : Internal_Entity_Expr;
Fld_7 : Logic_Var;
Fld_8 : Internal_Entity_Named_Type_Decl;
Cast_Result_2 : Internal_Entity;
Bind_Result_2 : Logic_Equation;
And_Pred_1 : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_9 : Bare_Argument;
Fld_10 : Internal_Entity_Expr;
Fld_11 : Logic_Var;
Fld_12 : Internal_Entity_Expr;
Fld_13 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_3 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_2 : Logic_Equation;
Fld_14 : Bare_Argument_List;
Fld_15 : Internal_Entity_Info;
Bare_Item : Bare_Argument;
As_Entity : Internal_Entity_Argument;
Is_Null : Boolean;
If_Result : Internal_Entity_Argument;
Map_Result : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;
And_Pred_3 : Logic_Equation;

            procedure Finalizer_Scope_289 is
            begin
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Logic_Boolean_Op);
                     Dec_Ref (And_Pred_3);
            end Finalizer_Scope_289;
            procedure Finalizer_Scope_716 is
            begin
                     Dec_Ref (Fld_5);
                     Dec_Ref (Bind_Result_2);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_2);
            end Finalizer_Scope_716;
            procedure Finalizer_Scope_717 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_717;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2156 LogicAnd And_Pred_3 nodes.lkt:3562
--# expr-start 2139 LogicAnd And_Pred nodes.lkt:3563
--# expr-start 2135 LogicAssign Bind_Result nodes.lkt:3563
--# expr-start 2133 Expr.actual_type_var Fld nodes.lkt:3563







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2133
Fld.Value := No_Entity;
Entity_Vars.Reset (Fld);





--# expr-start 2134 LktNode.equation_type Fld_1 nodes.lkt:3563







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.equation_type
Fld_1 := Liblktlang.Implementation.Lkt_Node_P_Equation_Type (Node => Ent.Node);
--# end
--# expr-done 2134



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_1.Node,
         Info => Fld_1.Info);


Bind_Result := Solver.Create_Assign (Fld, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3563:13") else null)); 
--# expr-done 2135
--# expr-start 2138 LogicAssign Bind_Result_1 nodes.lkt:3564
--# expr-start 2137 Expr.actual_type_var Fld_3 nodes.lkt:3564



--# expr-start 2136 BaseCallExpr.name Fld_2 nodes.lkt:3564







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2136



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Fld_2.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2137
Fld_3.Value := No_Entity;
Entity_Vars.Reset (Fld_3);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_3, Cast_Result_1, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3564:18") else null)); 
--# expr-done 2138
And_Pred := Create_And (Bind_Result, Bind_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3563:13") else null)); 
--# expr-done 2139
--# expr-start 2155 .logic_all Logic_Boolean_Op nodes.lkt:3566








   

   --# expr-start 2140 BaseCallExpr.args Fld_4 nodes.lkt:3566







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Argument_List (Node => Ent.Node.Base_Call_Expr_F_Args, Info => Ent.Info);
--# expr-done 2140









Fld_14 := Fld_4.Node;

   
      declare
         Map_Result_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      if Fld_14 = null then
         
      Map_Result := Create_Logic_Equation_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Argument_List := Fld_14;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Argument;
else
   








Fld_15 := Fld_4.Info;

As_Entity := (Info => Fld_15, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind a Item

            
         
         
      --# expr-start 2154 LogicAnd And_Pred_2 nodes.lkt:3568
--# expr-start 2146 LogicAnd And_Pred_1 nodes.lkt:3569
--# expr-start 2141 Argument.xref_equation Fld_5 nodes.lkt:3569







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_5 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 2141
--# expr-start 2145 LogicAssign Bind_Result_2 nodes.lkt:3570
--# expr-start 2143 Expr.expected_type_var Fld_7 nodes.lkt:3570



--# expr-start 2142 Argument.value Fld_6 nodes.lkt:3570







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 2142



   if Fld_6.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Fld_6.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2143
Fld_7.Value := No_Entity;
Entity_Vars.Reset (Fld_7);





--# expr-start 2144 LktNode.equation_type Fld_8 nodes.lkt:3570







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.equation_type
Fld_8 := Liblktlang.Implementation.Lkt_Node_P_Equation_Type (Node => Ent.Node);
--# end
--# expr-done 2144



   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Fld_8.Node,
         Info => Fld_8.Info);


Bind_Result_2 := Solver.Create_Assign (Fld_7, Cast_Result_2, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3570:22") else null)); 
--# expr-done 2145
And_Pred_1 := Create_And (Fld_5, Bind_Result_2, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3569:17") else null)); 
--# expr-done 2146




   --# scope-start



--# expr-start 2153 bind Dyn_Var_Bind_Result nodes.lkt:3573





--# expr-start 2147 'Entity[Argument].node' Fld_9 nodes.lkt:3573









Fld_9 := Item.Node;
--# expr-done 2147



   
      Cast_Result_3 := Fld_9;


Error_Location := Cast_Result_3; 
--# expr-start 2152 LogicPropagate Pred nodes.lkt:3574
--# expr-start 2149 Expr.expected_type_var Fld_11 nodes.lkt:3575



--# expr-start 2148 Argument.value Fld_10 nodes.lkt:3575







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 2148



   if Fld_10.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Fld_10.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2149
Fld_11.Value := No_Entity;
Entity_Vars.Reset (Fld_11);
--# expr-start 2151 Expr.actual_type_var Fld_13 nodes.lkt:3576



--# expr-start 2150 Argument.value Fld_12 nodes.lkt:3576







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_12 := Create_Internal_Entity_Expr (Node => Item.Node.Argument_F_Value, Info => Item.Info);
--# expr-done 2150



   if Fld_12.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_13 := Fld_12.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2151
Fld_13.Value := No_Entity;
Entity_Vars.Reset (Fld_13);


Pred := Solver.Create_N_Predicate ((Fld_11, Fld_13), Create_Type_Decl_P_Matching_Type_0_Predicate (2, Error_Location)); 
--# expr-done 2152
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2153
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_717;


And_Pred_2 := Create_And (And_Pred_1, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3568:13") else null)); 
--# expr-done 2154
      

         declare
            Item_To_Append : constant Logic_Equation := And_Pred_2;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_716;



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3566:24") else null)); 
--# expr-done 2155
And_Pred_3 := Create_And (And_Pred, Logic_Boolean_Op, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3562:9") else null)); 
--# expr-done 2156

         Property_Result := And_Pred_3;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_289;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_289;
                     Finalizer_Scope_716;
                     Finalizer_Scope_717;




            raise;
      end;



   return Property_Result;
end Base_Call_Expr_P_Xlogic_Any_All;
--# end

   







--# property-start BaseCallExpr.xlogic_equation nodes.lkt:3582
pragma Warnings (Off, "is not referenced");

function Base_Call_Expr_P_Xlogic_Equation
  
  (Node : Bare_Base_Call_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Base_Call_Expr :=
     Bare_Base_Call_Expr (Node);
     Ent : Internal_Entity_Base_Call_Expr :=
       Internal_Entity_Base_Call_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_290 with Inline_Always;
            procedure Finalizer_Scope_718 with Inline_Always;

      Fld : Internal_Entity_Expr;
Cast_Result : Internal_Entity_Ref_Id;
Var_Expr : Internal_Entity_Ref_Id;
Fld_1 : Logic_Equation;
Fld_2 : Bare_Ref_Id;
Sym : Symbol_Type;
Sym_1 : Symbol_Type;
Is_Equal : Boolean;
Fld_3 : Logic_Equation;
If_Result : Logic_Equation;
Fld_4 : Bare_Ref_Id;
Sym_2 : Symbol_Type;
Sym_3 : Symbol_Type;
Is_Equal_1 : Boolean;
Fld_5 : Bare_Ref_Id;
Sym_4 : Symbol_Type;
Sym_5 : Symbol_Type;
Is_Equal_2 : Boolean;
If_Result_1 : Boolean;
Fld_6 : Logic_Equation;
If_Result_2 : Logic_Equation;
Scope_Result : Logic_Equation;
Fld_7 : Logic_Equation;
Result_Var : Logic_Equation;

            procedure Finalizer_Scope_290 is
            begin
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Fld_7);
                     Dec_Ref (Result_Var);
            end Finalizer_Scope_290;
            procedure Finalizer_Scope_718 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Fld_3);
                     Dec_Ref (If_Result);
                     Dec_Ref (Fld_6);
                     Dec_Ref (If_Result_2);
            end Finalizer_Scope_718;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2175 .do Result_Var nodes.lkt:3583



--# expr-start 2158 Cast Cast_Result nodes.lkt:3583





--# expr-start 2157 BaseCallExpr.name Fld nodes.lkt:3583







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2157



   if Fld.Node = null
      or else Fld.Node.Kind in Lkt_Ref_Id_Range
   then
      
      Cast_Result := Create_Internal_Entity_Ref_Id
        (Node => Fld.Node,
         Info => Fld.Info);

   else
         Cast_Result := No_Entity_Ref_Id;
   end if;


--# expr-done 2158
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Ref_Id then
   



   --# scope-start



--# expr-start 2173 If If_Result_2 nodes.lkt:3585



--# expr-start 2165 BooleanOr If_Result_1 nodes.lkt:3585



--# expr-start 2161 Eq Is_Equal_1 nodes.lkt:3585
--# expr-start 2159 .symbol Sym_2 nodes.lkt:3585









Fld_4 := Var_Expr.Node; 
Sym_2 := Get_Symbol (Fld_4); 
--# expr-done 2159
--# expr-start 2160 SymbolLiteral Sym_3 nodes.lkt:3585
Sym_3 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_All); 
--# expr-done 2160
Is_Equal_1 := Sym_2 = Sym_3; 
--# expr-done 2161
if Is_Equal_1 then
   
   If_Result_1 := True;
else
   --# expr-start 2164 Eq Is_Equal_2 nodes.lkt:3585
--# expr-start 2162 .symbol Sym_4 nodes.lkt:3585









Fld_5 := Var_Expr.Node; 
Sym_4 := Get_Symbol (Fld_5); 
--# expr-done 2162
--# expr-start 2163 SymbolLiteral Sym_5 nodes.lkt:3585
Sym_5 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Any); 
--# expr-done 2163
Is_Equal_2 := Sym_4 = Sym_5; 
--# expr-done 2164
   If_Result_1 := Is_Equal_2;
end if;



--# expr-done 2165
if If_Result_1 then
   --# expr-start 2166 BaseCallExpr.xlogic_any_all Fld_6 nodes.lkt:3586







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start BaseCallExpr.xlogic_any_all
Fld_6 := Liblktlang.Implementation.Base_Call_Expr_P_Xlogic_Any_All (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2166
   If_Result_2 := Fld_6;
else
   --# expr-start 2172 If If_Result nodes.lkt:3585



--# expr-start 2169 Eq Is_Equal nodes.lkt:3587
--# expr-start 2167 .symbol Sym nodes.lkt:3587









Fld_2 := Var_Expr.Node; 
Sym := Get_Symbol (Fld_2); 
--# expr-done 2167
--# expr-start 2168 SymbolLiteral Sym_1 nodes.lkt:3587
Sym_1 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Domain); 
--# expr-done 2168
Is_Equal := Sym = Sym_1; 
--# expr-done 2169
if Is_Equal then
   --# expr-start 2170 BaseCallExpr.xref_equation Fld_3 nodes.lkt:3587







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_3 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2170
   If_Result := Fld_3;
else
   --# expr-start 2171 BaseCallExpr.xlogic_unknown Fld_1 nodes.lkt:3588







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start BaseCallExpr.xlogic_unknown
Fld_1 := Liblktlang.Implementation.Base_Call_Expr_P_Xlogic_Unknown (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2171
   If_Result := Fld_1;
end if;

      Inc_Ref (If_Result);


--# expr-done 2172
   If_Result_2 := If_Result;
end if;

      Inc_Ref (If_Result_2);


--# expr-done 2173
Scope_Result := If_Result_2;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_718;


   Result_Var := Scope_Result;
else
   --# expr-start 2174 BaseCallExpr.xlogic_unknown Fld_7 nodes.lkt:3589







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start BaseCallExpr.xlogic_unknown
Fld_7 := Liblktlang.Implementation.Base_Call_Expr_P_Xlogic_Unknown (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2174
   Result_Var := Fld_7;
end if;

      Inc_Ref (Result_Var);


--# expr-done 2175

         Property_Result := Result_Var;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_290;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_290;
                     Finalizer_Scope_718;




            raise;
      end;



   return Property_Result;
end Base_Call_Expr_P_Xlogic_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Call_Expr
   --

   



      
      procedure Initialize_Fields_For_Call_Expr
        (Self : Bare_Call_Expr
         ; Base_Call_Expr_F_Name : Bare_Expr
         ; Base_Call_Expr_F_Args : Bare_Argument_List
        ) is
      begin
            Initialize_Fields_For_Base_Call_Expr
              (Self, Base_Call_Expr_F_Name, Base_Call_Expr_F_Args);

         

      end Initialize_Fields_For_Call_Expr;




   


      

   --
   --  Primitives for Bare_Logic_Call_Expr
   --

   



      
      procedure Initialize_Fields_For_Logic_Call_Expr
        (Self : Bare_Logic_Call_Expr
         ; Base_Call_Expr_F_Name : Bare_Expr
         ; Base_Call_Expr_F_Args : Bare_Argument_List
        ) is
      begin
            Initialize_Fields_For_Base_Call_Expr
              (Self, Base_Call_Expr_F_Name, Base_Call_Expr_F_Args);

         

      end Initialize_Fields_For_Logic_Call_Expr;




   


      

   --
   --  Primitives for Bare_Logic_Predicate
   --

   



      
      procedure Initialize_Fields_For_Logic_Predicate
        (Self : Bare_Logic_Predicate
         ; Base_Call_Expr_F_Name : Bare_Expr
         ; Base_Call_Expr_F_Args : Bare_Argument_List
        ) is
      begin
            Initialize_Fields_For_Logic_Call_Expr
              (Self, Base_Call_Expr_F_Name, Base_Call_Expr_F_Args);

         

      end Initialize_Fields_For_Logic_Predicate;


   







--# property-start LogicPredicate.generic_type_equation nodes.lkt:3607
pragma Warnings (Off, "is not referenced");

function Logic_Predicate_P_Generic_Type_Equation
  
  (Node : Bare_Logic_Predicate
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Logic_Predicate :=
     Bare_Logic_Predicate (Node);
     Ent : Internal_Entity_Logic_Predicate :=
       Internal_Entity_Logic_Predicate'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_291 with Inline_Always;
            procedure Finalizer_Scope_719 with Inline_Always;

      In_Logic_Call : Boolean;
Fld : Logic_Equation;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;

            procedure Finalizer_Scope_291 is
            begin
                     Dec_Ref (Scope_Result);
            end Finalizer_Scope_291;
            procedure Finalizer_Scope_719 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_719;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 2177 bind Dyn_Var_Bind_Result nodes.lkt:3608

In_Logic_Call := True; 
--# expr-start 2176 BaseCallExpr.generic_type_equation_helper Fld nodes.lkt:3609







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start BaseCallExpr.generic_type_equation_helper
Fld := Liblktlang.Implementation.Base_Call_Expr_P_Generic_Type_Equation_Helper (Node => Ent.Node, In_Logic_Call => In_Logic_Call, E_Info => Ent.Info);
--# end
--# expr-done 2176
Dyn_Var_Bind_Result := Fld; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2177
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_719;



         Property_Result := Scope_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_291;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_291;
                     Finalizer_Scope_719;




            raise;
      end;



   return Property_Result;
end Logic_Predicate_P_Generic_Type_Equation;
--# end

   







--# property-start LogicPredicate.xref_equation nodes.lkt:3612
pragma Warnings (Off, "is not referenced");

function Logic_Predicate_P_Xref_Equation
  
  (Node : Bare_Logic_Predicate
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Logic_Predicate :=
     Bare_Logic_Predicate (Node);
     Ent : Internal_Entity_Logic_Predicate :=
       Internal_Entity_Logic_Predicate'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_292 with Inline_Always;
            procedure Finalizer_Scope_720 with Inline_Always;

      Error_Location : Bare_Lkt_Node;
Fld : Bare_Expr;
In_Logic_Call : Boolean;
Fld_1 : Internal_Entity_Expr;
Fld_2 : Logic_Equation;
Fld_3 : Logic_Equation;
And_Pred : Logic_Equation;
Fld_4 : Internal_Entity_Expr;
Fld_5 : Logic_Var;
Pred : Logic_Equation;
And_Pred_1 : Logic_Equation;
Fld_6 : Logic_Var;
Fld_7 : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
And_Pred_2 : Logic_Equation;
Dyn_Var_Bind_Result : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_1 : Logic_Equation;
Scope_Result : Logic_Equation;

            procedure Finalizer_Scope_292 is
            begin
                     Dec_Ref (Scope_Result);
            end Finalizer_Scope_292;
            procedure Finalizer_Scope_720 is
            begin
                     Dec_Ref (Fld_2);
                     Dec_Ref (Fld_3);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Pred);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Dyn_Var_Bind_Result);
                     Dec_Ref (Dyn_Var_Bind_Result_1);
            end Finalizer_Scope_720;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 2192 bind Dyn_Var_Bind_Result_1 nodes.lkt:3613





--# expr-start 2178 BaseCallExpr.name Fld nodes.lkt:3613







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Self.Base_Call_Expr_F_Name;
--# expr-done 2178



   
      Cast_Result_1 := Fld;


Error_Location := Cast_Result_1; 
--# expr-start 2191 bind Dyn_Var_Bind_Result nodes.lkt:3614

In_Logic_Call := True; 
--# expr-start 2190 LogicAnd And_Pred_2 nodes.lkt:3615
--# expr-start 2186 LogicAnd And_Pred_1 nodes.lkt:3615
--# expr-start 2182 LogicAnd And_Pred nodes.lkt:3615
--# expr-start 2180 Expr.xlogic_equation Fld_2 nodes.lkt:3615



--# expr-start 2179 BaseCallExpr.name Fld_1 nodes.lkt:3615







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2179



   if Fld_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.xlogic_equation'
Fld_2 := Liblktlang.Implementation.Dispatcher_Expr_P_Xlogic_Equation (Node => Fld_1.Node, E_Info => Fld_1.Info);
--# end
--# expr-done 2180
--# expr-start 2181 BaseCallExpr.xref_call_equation Fld_3 nodes.lkt:3616







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start BaseCallExpr.xref_call_equation
Fld_3 := Liblktlang.Implementation.Base_Call_Expr_P_Xref_Call_Equation (Node => Ent.Node, In_Logic_Call => In_Logic_Call, E_Info => Ent.Info);
--# end
--# expr-done 2181
And_Pred := Create_And (Fld_2, Fld_3, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3615:9") else null)); 
--# expr-done 2182
--# expr-start 2185 LogicPropagate Pred nodes.lkt:3617
--# expr-start 2184 Expr.actual_type_var Fld_5 nodes.lkt:3617



--# expr-start 2183 BaseCallExpr.name Fld_4 nodes.lkt:3617







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Expr (Node => Ent.Node.Base_Call_Expr_F_Name, Info => Ent.Info);
--# expr-done 2183



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Fld_4.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2184
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);

Pred := Solver.Create_Predicate (Fld_5, Create_Function_Type_P_Returns_Bool_0_Predicate (Error_Location)); 
--# expr-done 2185
And_Pred_1 := Create_And (And_Pred, Pred, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3615:9") else null)); 
--# expr-done 2186
--# expr-start 2189 LogicAssign Bind_Result nodes.lkt:3618
--# expr-start 2187 Expr.actual_type_var Fld_6 nodes.lkt:3618







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2187
Fld_6.Value := No_Entity;
Entity_Vars.Reset (Fld_6);





--# expr-start 2188 LktNode.equation_type Fld_7 nodes.lkt:3618







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.equation_type
Fld_7 := Liblktlang.Implementation.Lkt_Node_P_Equation_Type (Node => Ent.Node);
--# end
--# expr-done 2188



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_7.Node,
         Info => Fld_7.Info);


Bind_Result := Solver.Create_Assign (Fld_6, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3618:14") else null)); 
--# expr-done 2189
And_Pred_2 := Create_And (And_Pred_1, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3615:9") else null)); 
--# expr-done 2190
Dyn_Var_Bind_Result := And_Pred_2; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2191
Dyn_Var_Bind_Result_1 := Dyn_Var_Bind_Result; Inc_Ref (Dyn_Var_Bind_Result_1);
--# expr-done 2192
Scope_Result := Dyn_Var_Bind_Result_1;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_720;



         Property_Result := Scope_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_292;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_292;
                     Finalizer_Scope_720;




            raise;
      end;



   return Property_Result;
end Logic_Predicate_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Logic_Propagate_Call
   --

   



      
      procedure Initialize_Fields_For_Logic_Propagate_Call
        (Self : Bare_Logic_Propagate_Call
         ; Base_Call_Expr_F_Name : Bare_Expr
         ; Base_Call_Expr_F_Args : Bare_Argument_List
        ) is
      begin
            Initialize_Fields_For_Logic_Call_Expr
              (Self, Base_Call_Expr_F_Name, Base_Call_Expr_F_Args);

         

      end Initialize_Fields_For_Logic_Propagate_Call;




   


      

   --
   --  Primitives for Bare_Bin_Op
   --

   



      
      procedure Initialize_Fields_For_Bin_Op
        (Self : Bare_Bin_Op
         ; Bin_Op_F_Left : Bare_Expr
         ; Bin_Op_F_Op : Bare_Op
         ; Bin_Op_F_Right : Bare_Expr
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Bin_Op_F_Left := Bin_Op_F_Left;
            Self.Bin_Op_F_Op := Bin_Op_F_Op;
            Self.Bin_Op_F_Right := Bin_Op_F_Right;
         

      end Initialize_Fields_For_Bin_Op;

      
   function Bin_Op_F_Left
     (Node : Bare_Bin_Op) return Bare_Expr
   is
      

   begin
         
         return Node.Bin_Op_F_Left;
      
   end;

      
   function Bin_Op_F_Op
     (Node : Bare_Bin_Op) return Bare_Op
   is
      

   begin
         
         return Node.Bin_Op_F_Op;
      
   end;

      
   function Bin_Op_F_Right
     (Node : Bare_Bin_Op) return Bare_Expr
   is
      

   begin
         
         return Node.Bin_Op_F_Right;
      
   end;


   







--# property-start BinOp.xref_equation nodes.lkt:3782
pragma Warnings (Off, "is not referenced");

function Bin_Op_P_Xref_Equation
  
  (Node : Bare_Bin_Op
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Bin_Op :=
     Bare_Bin_Op (Node);
     Ent : Internal_Entity_Bin_Op :=
       Internal_Entity_Bin_Op'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_304 with Inline_Always;
            procedure Finalizer_Scope_735 with Inline_Always;
            procedure Finalizer_Scope_736 with Inline_Always;
            procedure Finalizer_Scope_737 with Inline_Always;
            procedure Finalizer_Scope_738 with Inline_Always;
            procedure Finalizer_Scope_739 with Inline_Always;
            procedure Finalizer_Scope_740 with Inline_Always;
            procedure Finalizer_Scope_741 with Inline_Always;
            procedure Finalizer_Scope_742 with Inline_Always;
            procedure Finalizer_Scope_743 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Internal_Entity_Expr;
Fld_3 : Logic_Equation;
And_Pred : Logic_Equation;
Fld_4 : Internal_Entity_Expr;
Fld_5 : Logic_Var;
Fld_6 : Internal_Entity_Expr;
Fld_7 : Logic_Var;
Bind_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;
Fld_8 : Internal_Entity_Expr;
Fld_9 : Logic_Var;
Fld_10 : Internal_Entity_Expr;
Fld_11 : Logic_Var;
Bind_Result_1 : Logic_Equation;
And_Pred_2 : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_12 : Bare_Expr;
Fld_13 : Internal_Entity_Expr;
Fld_14 : Logic_Var;
Fld_15 : Internal_Entity_Expr;
Fld_16 : Logic_Var;
Fld_17 : Internal_Entity_Op;
Fld_18 : Boolean;
Fld_19 : Internal_Entity_Op;
Is_A : Boolean;
If_Result : Boolean;
Pred : Logic_Equation;
Cast_Result : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_3 : Logic_Equation;
Fld_20 : Logic_Var;
Fld_21 : Internal_Entity_Named_Type_Decl;
Cast_Result_1 : Internal_Entity;
Bind_Result_2 : Logic_Equation;
Fld_22 : Internal_Entity_Op;
Is_A_1 : Boolean;
Fld_23 : Logic_Var;
Fld_24 : Internal_Entity_Expr;
Fld_25 : Logic_Var;
Fld_26 : Internal_Entity_Expr;
Fld_27 : Logic_Var;
Array_Lit : Logic_Var_Array_Access;
Logic_Vars : Logic_Var_Array_Access;
Bind_Result_3 : Logic_Equation;
If_Result_1 : Logic_Equation;
Fld_28 : Internal_Entity_Op;
Is_A_2 : Boolean;
Fld_29 : Logic_Var;
Fld_30 : Internal_Entity_Expr;
Fld_31 : Logic_Var;
Bind_Result_4 : Logic_Equation;
Error_Location_1 : Bare_Lkt_Node;
Fld_32 : Bare_Expr;
Fld_33 : Internal_Entity_Expr;
Fld_34 : Logic_Var;
Pred_1 : Logic_Equation;
Cast_Result_2 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_1 : Logic_Equation;
Scope_Result_1 : Logic_Equation;
And_Pred_4 : Logic_Equation;
Error_Location_2 : Bare_Lkt_Node;
Fld_35 : Bare_Expr;
Fld_36 : Internal_Entity_Expr;
Fld_37 : Logic_Var;
Pred_2 : Logic_Equation;
Cast_Result_3 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_2 : Logic_Equation;
Scope_Result_2 : Logic_Equation;
And_Pred_5 : Logic_Equation;
If_Result_2 : Logic_Equation;
Fld_38 : Internal_Entity_Op;
Fld_39 : Boolean;
Fld_40 : Logic_Var;
Fld_41 : Internal_Entity_Expr;
Fld_42 : Logic_Var;
Bind_Result_5 : Logic_Equation;
Error_Location_3 : Bare_Lkt_Node;
Fld_43 : Bare_Expr;
Fld_44 : Internal_Entity_Expr;
Fld_45 : Logic_Var;
Pred_3 : Logic_Equation;
Cast_Result_4 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_3 : Logic_Equation;
Scope_Result_3 : Logic_Equation;
And_Pred_6 : Logic_Equation;
Error_Location_4 : Bare_Lkt_Node;
Fld_46 : Bare_Expr;
Fld_47 : Internal_Entity_Expr;
Fld_48 : Logic_Var;
Pred_4 : Logic_Equation;
Cast_Result_5 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_4 : Logic_Equation;
Scope_Result_4 : Logic_Equation;
And_Pred_7 : Logic_Equation;
If_Result_3 : Logic_Equation;
Fld_49 : Internal_Entity_Op;
Fld_50 : Boolean;
Fld_51 : Logic_Var;
Fld_52 : Internal_Entity_Named_Type_Decl;
Cast_Result_6 : Internal_Entity;
Bind_Result_6 : Logic_Equation;
Error_Location_5 : Bare_Lkt_Node;
Fld_53 : Bare_Expr;
Fld_54 : Internal_Entity_Expr;
Fld_55 : Logic_Var;
Pred_5 : Logic_Equation;
Cast_Result_7 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_5 : Logic_Equation;
Scope_Result_5 : Logic_Equation;
And_Pred_8 : Logic_Equation;
Error_Location_6 : Bare_Lkt_Node;
Fld_56 : Bare_Expr;
Fld_57 : Internal_Entity_Expr;
Fld_58 : Logic_Var;
Pred_6 : Logic_Equation;
Cast_Result_8 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_6 : Logic_Equation;
Scope_Result_6 : Logic_Equation;
And_Pred_9 : Logic_Equation;
If_Result_4 : Logic_Equation;
Fld_59 : Internal_Entity_Op;
Fld_60 : Boolean;
Fld_61 : Logic_Var;
Fld_62 : Internal_Entity_Named_Type_Decl;
Cast_Result_9 : Internal_Entity;
Bind_Result_7 : Logic_Equation;
Error_Location_7 : Bare_Lkt_Node;
Fld_63 : Bare_Expr;
Fld_64 : Internal_Entity_Expr;
Fld_65 : Logic_Var;
Pred_7 : Logic_Equation;
Cast_Result_10 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_7 : Logic_Equation;
Scope_Result_7 : Logic_Equation;
And_Pred_10 : Logic_Equation;
If_Result_5 : Logic_Equation;
Fld_66 : Internal_Entity_Op;
Fld_67 : Boolean;
Fld_68 : Logic_Var;
Fld_69 : Internal_Entity_Named_Type_Decl;
Cast_Result_11 : Internal_Entity;
Bind_Result_8 : Logic_Equation;
Error_Location_8 : Bare_Lkt_Node;
Fld_70 : Bare_Expr;
Fld_71 : Internal_Entity_Expr;
Fld_72 : Logic_Var;
Pred_8 : Logic_Equation;
Cast_Result_12 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_8 : Logic_Equation;
Scope_Result_8 : Logic_Equation;
And_Pred_11 : Logic_Equation;
If_Result_6 : Logic_Equation;
And_Pred_12 : Logic_Equation;

            procedure Finalizer_Scope_304 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Fld_3);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_3);
                     Dec_Ref (Bind_Result_2);
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Logic_Vars);
                     Dec_Ref (Bind_Result_3);
                     Dec_Ref (If_Result_1);
                     Dec_Ref (Bind_Result_4);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (And_Pred_4);
                     Dec_Ref (Scope_Result_2);
                     Dec_Ref (And_Pred_5);
                     Dec_Ref (If_Result_2);
                     Dec_Ref (Bind_Result_5);
                     Dec_Ref (Scope_Result_3);
                     Dec_Ref (And_Pred_6);
                     Dec_Ref (Scope_Result_4);
                     Dec_Ref (And_Pred_7);
                     Dec_Ref (If_Result_3);
                     Dec_Ref (Bind_Result_6);
                     Dec_Ref (Scope_Result_5);
                     Dec_Ref (And_Pred_8);
                     Dec_Ref (Scope_Result_6);
                     Dec_Ref (And_Pred_9);
                     Dec_Ref (If_Result_4);
                     Dec_Ref (Bind_Result_7);
                     Dec_Ref (Scope_Result_7);
                     Dec_Ref (And_Pred_10);
                     Dec_Ref (If_Result_5);
                     Dec_Ref (Bind_Result_8);
                     Dec_Ref (Scope_Result_8);
                     Dec_Ref (And_Pred_11);
                     Dec_Ref (If_Result_6);
                     Dec_Ref (And_Pred_12);
            end Finalizer_Scope_304;
            procedure Finalizer_Scope_735 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_735;
            procedure Finalizer_Scope_736 is
            begin
                     Dec_Ref (Pred_1);
                     Dec_Ref (Dyn_Var_Bind_Result_1);
            end Finalizer_Scope_736;
            procedure Finalizer_Scope_737 is
            begin
                     Dec_Ref (Pred_2);
                     Dec_Ref (Dyn_Var_Bind_Result_2);
            end Finalizer_Scope_737;
            procedure Finalizer_Scope_738 is
            begin
                     Dec_Ref (Pred_3);
                     Dec_Ref (Dyn_Var_Bind_Result_3);
            end Finalizer_Scope_738;
            procedure Finalizer_Scope_739 is
            begin
                     Dec_Ref (Pred_4);
                     Dec_Ref (Dyn_Var_Bind_Result_4);
            end Finalizer_Scope_739;
            procedure Finalizer_Scope_740 is
            begin
                     Dec_Ref (Pred_5);
                     Dec_Ref (Dyn_Var_Bind_Result_5);
            end Finalizer_Scope_740;
            procedure Finalizer_Scope_741 is
            begin
                     Dec_Ref (Pred_6);
                     Dec_Ref (Dyn_Var_Bind_Result_6);
            end Finalizer_Scope_741;
            procedure Finalizer_Scope_742 is
            begin
                     Dec_Ref (Pred_7);
                     Dec_Ref (Dyn_Var_Bind_Result_7);
            end Finalizer_Scope_742;
            procedure Finalizer_Scope_743 is
            begin
                     Dec_Ref (Pred_8);
                     Dec_Ref (Dyn_Var_Bind_Result_8);
            end Finalizer_Scope_743;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2315 LogicAnd And_Pred_12 nodes.lkt:3783
--# expr-start 2222 LogicAnd And_Pred_3 nodes.lkt:3784
--# expr-start 2209 LogicAnd And_Pred_2 nodes.lkt:3785
--# expr-start 2203 LogicAnd And_Pred_1 nodes.lkt:3786
--# expr-start 2197 LogicAnd And_Pred nodes.lkt:3786
--# expr-start 2194 LktNode.xref_equation Fld_1 nodes.lkt:3786



--# expr-start 2193 BinOp.left Fld nodes.lkt:3786







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Left, Info => Ent.Info);
--# expr-done 2193



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2194
--# expr-start 2196 LktNode.xref_equation Fld_3 nodes.lkt:3786



--# expr-start 2195 BinOp.right Fld_2 nodes.lkt:3786







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Right, Info => Ent.Info);
--# expr-done 2195



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_3 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld_2.Node, E_Info => Fld_2.Info);
--# end
--# expr-done 2196
And_Pred := Create_And (Fld_1, Fld_3, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3786:22") else null)); 
--# expr-done 2197
--# expr-start 2202 LogicUnify Bind_Result nodes.lkt:3787
--# expr-start 2199 Expr.expected_type_var Fld_5 nodes.lkt:3787



--# expr-start 2198 BinOp.left Fld_4 nodes.lkt:3787







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Left, Info => Ent.Info);
--# expr-done 2198



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Fld_4.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2199
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);
--# expr-start 2201 Expr.actual_type_var Fld_7 nodes.lkt:3788



--# expr-start 2200 BinOp.right Fld_6 nodes.lkt:3788







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Right, Info => Ent.Info);
--# expr-done 2200



   if Fld_6.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Fld_6.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2201
Bind_Result := Solver.Create_Unify (Fld_5, Fld_7, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3787:26") else null)); 
--# expr-done 2202
And_Pred_1 := Create_And (And_Pred, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3786:21") else null)); 
--# expr-done 2203
--# expr-start 2208 LogicUnify Bind_Result_1 nodes.lkt:3790
--# expr-start 2205 Expr.expected_type_var Fld_9 nodes.lkt:3790



--# expr-start 2204 BinOp.right Fld_8 nodes.lkt:3790







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Right, Info => Ent.Info);
--# expr-done 2204



   if Fld_8.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Fld_8.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2205
Fld_9.Value := No_Entity;
Entity_Vars.Reset (Fld_9);
--# expr-start 2207 Expr.actual_type_var Fld_11 nodes.lkt:3790



--# expr-start 2206 BinOp.left Fld_10 nodes.lkt:3790







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Left, Info => Ent.Info);
--# expr-done 2206



   if Fld_10.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Fld_10.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2207
Bind_Result_1 := Solver.Create_Unify (Fld_9, Fld_11, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3790:22") else null)); 
--# expr-done 2208
And_Pred_2 := Create_And (And_Pred_1, Bind_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3785:17") else null)); 
--# expr-done 2209




   --# scope-start



--# expr-start 2221 bind Dyn_Var_Bind_Result nodes.lkt:3793





--# expr-start 2210 BinOp.right Fld_12 nodes.lkt:3793







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_12 := Self.Bin_Op_F_Right;
--# expr-done 2210



   
      Cast_Result := Fld_12;


Error_Location := Cast_Result; 
--# expr-start 2220 LogicPropagate Pred nodes.lkt:3794
--# expr-start 2212 Expr.expected_type_var Fld_14 nodes.lkt:3795



--# expr-start 2211 BinOp.right Fld_13 nodes.lkt:3795







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_13 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Right, Info => Ent.Info);
--# expr-done 2211



   if Fld_13.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_14 := Fld_13.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2212
Fld_14.Value := No_Entity;
Entity_Vars.Reset (Fld_14);
--# expr-start 2214 Expr.actual_type_var Fld_16 nodes.lkt:3796



--# expr-start 2213 BinOp.right Fld_15 nodes.lkt:3796







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_15 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Right, Info => Ent.Info);
--# expr-done 2213



   if Fld_15.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_16 := Fld_15.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2214
Fld_16.Value := No_Entity;
Entity_Vars.Reset (Fld_16);

--# expr-start 2219 BooleanOr If_Result nodes.lkt:3797



--# expr-start 2216 Op.is_order_op Fld_18 nodes.lkt:3803



--# expr-start 2215 BinOp.op Fld_17 nodes.lkt:3803







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_17 := Create_Internal_Entity_Op (Node => Ent.Node.Bin_Op_F_Op, Info => Ent.Info);
--# expr-done 2215



   if Fld_17.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Op.is_order_op
Fld_18 := Liblktlang.Implementation.Op_P_Is_Order_Op (Node => Fld_17.Node);
--# end
--# expr-done 2216
if Fld_18 then
   
   If_Result := True;
else
   --# expr-start 2218 IsA Is_A nodes.lkt:3805
--# expr-start 2217 BinOp.op Fld_19 nodes.lkt:3805







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_19 := Create_Internal_Entity_Op (Node => Ent.Node.Bin_Op_F_Op, Info => Ent.Info);
--# expr-done 2217
Is_A := Fld_19.Node /= null 
and then Fld_19.Node.Kind in Lkt_Op_Or_Int_Range; 
--# expr-done 2218
   If_Result := Is_A;
end if;



--# expr-done 2219

Pred := Solver.Create_N_Predicate ((Fld_14, Fld_16), Create_Type_Decl_P_Commutative_Matching_Type_1_Predicate (2, If_Result, Error_Location)); 
--# expr-done 2220
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2221
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_735;


And_Pred_3 := Create_And (And_Pred_2, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3784:13") else null)); 
--# expr-done 2222
--# expr-start 2314 If If_Result_6 nodes.lkt:3811



--# expr-start 2224 Op.is_bool_op Fld_67 nodes.lkt:3811



--# expr-start 2223 BinOp.op Fld_66 nodes.lkt:3811







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_66 := Create_Internal_Entity_Op (Node => Ent.Node.Bin_Op_F_Op, Info => Ent.Info);
--# expr-done 2223



   if Fld_66.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Op.is_bool_op
Fld_67 := Liblktlang.Implementation.Op_P_Is_Bool_Op (Node => Fld_66.Node);
--# end
--# expr-done 2224
if Fld_67 then
   --# expr-start 2233 LogicAnd And_Pred_11 nodes.lkt:3813
--# expr-start 2227 LogicAssign Bind_Result_8 nodes.lkt:3813
--# expr-start 2225 Expr.actual_type_var Fld_68 nodes.lkt:3813







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_68 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2225
Fld_68.Value := No_Entity;
Entity_Vars.Reset (Fld_68);





--# expr-start 2226 LktNode.bool_type Fld_69 nodes.lkt:3813







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.bool_type
Fld_69 := Liblktlang.Implementation.Lkt_Node_P_Bool_Type (Node => Ent.Node);
--# end
--# expr-done 2226



   
      Cast_Result_11 := Create_Internal_Entity
        (Node => Fld_69.Node,
         Info => Fld_69.Info);


Bind_Result_8 := Solver.Create_Assign (Fld_68, Cast_Result_11, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3813:17") else null)); 
--# expr-done 2227




   --# scope-start



--# expr-start 2232 bind Dyn_Var_Bind_Result_8 nodes.lkt:3815





--# expr-start 2228 BinOp.left Fld_70 nodes.lkt:3815







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_70 := Self.Bin_Op_F_Left;
--# expr-done 2228



   
      Cast_Result_12 := Fld_70;


Error_Location_8 := Cast_Result_12; 
--# expr-start 2231 LogicPropagate Pred_8 nodes.lkt:3816
--# expr-start 2230 Expr.actual_type_var Fld_72 nodes.lkt:3816



--# expr-start 2229 BinOp.left Fld_71 nodes.lkt:3816







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_71 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Left, Info => Ent.Info);
--# expr-done 2229



   if Fld_71.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_72 := Fld_71.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2230
Fld_72.Value := No_Entity;
Entity_Vars.Reset (Fld_72);

Pred_8 := Solver.Create_Predicate (Fld_72, Create_Type_Decl_P_Is_Bool_0_Predicate (Error_Location_8)); 
--# expr-done 2231
Dyn_Var_Bind_Result_8 := Pred_8; Inc_Ref (Dyn_Var_Bind_Result_8);
--# expr-done 2232
Scope_Result_8 := Dyn_Var_Bind_Result_8;
   Inc_Ref (Scope_Result_8);


   --# end
      Finalizer_Scope_743;


And_Pred_11 := Create_And (Bind_Result_8, Scope_Result_8, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3813:17") else null)); 
--# expr-done 2233
   If_Result_6 := And_Pred_11;
else
   --# expr-start 2313 If If_Result_5 nodes.lkt:3811



--# expr-start 2235 Op.is_equation_op Fld_60 nodes.lkt:3819



--# expr-start 2234 BinOp.op Fld_59 nodes.lkt:3819







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_59 := Create_Internal_Entity_Op (Node => Ent.Node.Bin_Op_F_Op, Info => Ent.Info);
--# expr-done 2234



   if Fld_59.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Op.is_equation_op
Fld_60 := Liblktlang.Implementation.Op_P_Is_Equation_Op (Node => Fld_59.Node);
--# end
--# expr-done 2235
if Fld_60 then
   --# expr-start 2244 LogicAnd And_Pred_10 nodes.lkt:3821
--# expr-start 2238 LogicAssign Bind_Result_7 nodes.lkt:3821
--# expr-start 2236 Expr.actual_type_var Fld_61 nodes.lkt:3821







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_61 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2236
Fld_61.Value := No_Entity;
Entity_Vars.Reset (Fld_61);





--# expr-start 2237 LktNode.equation_type Fld_62 nodes.lkt:3821







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.equation_type
Fld_62 := Liblktlang.Implementation.Lkt_Node_P_Equation_Type (Node => Ent.Node);
--# end
--# expr-done 2237



   
      Cast_Result_9 := Create_Internal_Entity
        (Node => Fld_62.Node,
         Info => Fld_62.Info);


Bind_Result_7 := Solver.Create_Assign (Fld_61, Cast_Result_9, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3821:17") else null)); 
--# expr-done 2238




   --# scope-start



--# expr-start 2243 bind Dyn_Var_Bind_Result_7 nodes.lkt:3823





--# expr-start 2239 BinOp.left Fld_63 nodes.lkt:3823







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_63 := Self.Bin_Op_F_Left;
--# expr-done 2239



   
      Cast_Result_10 := Fld_63;


Error_Location_7 := Cast_Result_10; 
--# expr-start 2242 LogicPropagate Pred_7 nodes.lkt:3824
--# expr-start 2241 Expr.actual_type_var Fld_65 nodes.lkt:3824



--# expr-start 2240 BinOp.left Fld_64 nodes.lkt:3824







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_64 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Left, Info => Ent.Info);
--# expr-done 2240



   if Fld_64.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_65 := Fld_64.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2241
Fld_65.Value := No_Entity;
Entity_Vars.Reset (Fld_65);

Pred_7 := Solver.Create_Predicate (Fld_65, Create_Type_Decl_P_Is_Equation_0_Predicate (Error_Location_7)); 
--# expr-done 2242
Dyn_Var_Bind_Result_7 := Pred_7; Inc_Ref (Dyn_Var_Bind_Result_7);
--# expr-done 2243
Scope_Result_7 := Dyn_Var_Bind_Result_7;
   Inc_Ref (Scope_Result_7);


   --# end
      Finalizer_Scope_742;


And_Pred_10 := Create_And (Bind_Result_7, Scope_Result_7, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3821:17") else null)); 
--# expr-done 2244
   If_Result_5 := And_Pred_10;
else
   --# expr-start 2312 If If_Result_4 nodes.lkt:3811



--# expr-start 2246 Op.is_order_op Fld_50 nodes.lkt:3827



--# expr-start 2245 BinOp.op Fld_49 nodes.lkt:3827







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_49 := Create_Internal_Entity_Op (Node => Ent.Node.Bin_Op_F_Op, Info => Ent.Info);
--# expr-done 2245



   if Fld_49.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Op.is_order_op
Fld_50 := Liblktlang.Implementation.Op_P_Is_Order_Op (Node => Fld_49.Node);
--# end
--# expr-done 2246
if Fld_50 then
   --# expr-start 2261 LogicAnd And_Pred_9 nodes.lkt:3829
--# expr-start 2255 LogicAnd And_Pred_8 nodes.lkt:3830
--# expr-start 2249 LogicAssign Bind_Result_6 nodes.lkt:3830
--# expr-start 2247 Expr.actual_type_var Fld_51 nodes.lkt:3830







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_51 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2247
Fld_51.Value := No_Entity;
Entity_Vars.Reset (Fld_51);





--# expr-start 2248 LktNode.bool_type Fld_52 nodes.lkt:3830







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.bool_type
Fld_52 := Liblktlang.Implementation.Lkt_Node_P_Bool_Type (Node => Ent.Node);
--# end
--# expr-done 2248



   
      Cast_Result_6 := Create_Internal_Entity
        (Node => Fld_52.Node,
         Info => Fld_52.Info);


Bind_Result_6 := Solver.Create_Assign (Fld_51, Cast_Result_6, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3830:21") else null)); 
--# expr-done 2249




   --# scope-start



--# expr-start 2254 bind Dyn_Var_Bind_Result_5 nodes.lkt:3832





--# expr-start 2250 BinOp.left Fld_53 nodes.lkt:3832







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_53 := Self.Bin_Op_F_Left;
--# expr-done 2250



   
      Cast_Result_7 := Fld_53;


Error_Location_5 := Cast_Result_7; 
--# expr-start 2253 LogicPropagate Pred_5 nodes.lkt:3833
--# expr-start 2252 Expr.actual_type_var Fld_55 nodes.lkt:3833



--# expr-start 2251 BinOp.left Fld_54 nodes.lkt:3833







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_54 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Left, Info => Ent.Info);
--# expr-done 2251



   if Fld_54.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_55 := Fld_54.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2252
Fld_55.Value := No_Entity;
Entity_Vars.Reset (Fld_55);

Pred_5 := Solver.Create_Predicate (Fld_55, Create_Type_Decl_P_Is_Int_Or_Node_0_Predicate (Error_Location_5)); 
--# expr-done 2253
Dyn_Var_Bind_Result_5 := Pred_5; Inc_Ref (Dyn_Var_Bind_Result_5);
--# expr-done 2254
Scope_Result_5 := Dyn_Var_Bind_Result_5;
   Inc_Ref (Scope_Result_5);


   --# end
      Finalizer_Scope_740;


And_Pred_8 := Create_And (Bind_Result_6, Scope_Result_5, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3830:21") else null)); 
--# expr-done 2255




   --# scope-start



--# expr-start 2260 bind Dyn_Var_Bind_Result_6 nodes.lkt:3837





--# expr-start 2256 BinOp.right Fld_56 nodes.lkt:3837







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_56 := Self.Bin_Op_F_Right;
--# expr-done 2256



   
      Cast_Result_8 := Fld_56;


Error_Location_6 := Cast_Result_8; 
--# expr-start 2259 LogicPropagate Pred_6 nodes.lkt:3838
--# expr-start 2258 Expr.actual_type_var Fld_58 nodes.lkt:3838



--# expr-start 2257 BinOp.right Fld_57 nodes.lkt:3838







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_57 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Right, Info => Ent.Info);
--# expr-done 2257



   if Fld_57.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_58 := Fld_57.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2258
Fld_58.Value := No_Entity;
Entity_Vars.Reset (Fld_58);

Pred_6 := Solver.Create_Predicate (Fld_58, Create_Type_Decl_P_Is_Int_Or_Node_0_Predicate (Error_Location_6)); 
--# expr-done 2259
Dyn_Var_Bind_Result_6 := Pred_6; Inc_Ref (Dyn_Var_Bind_Result_6);
--# expr-done 2260
Scope_Result_6 := Dyn_Var_Bind_Result_6;
   Inc_Ref (Scope_Result_6);


   --# end
      Finalizer_Scope_741;


And_Pred_9 := Create_And (And_Pred_8, Scope_Result_6, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3829:17") else null)); 
--# expr-done 2261
   If_Result_4 := And_Pred_9;
else
   --# expr-start 2311 If If_Result_3 nodes.lkt:3811



--# expr-start 2263 Op.is_arith_op Fld_39 nodes.lkt:3841



--# expr-start 2262 BinOp.op Fld_38 nodes.lkt:3841







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_38 := Create_Internal_Entity_Op (Node => Ent.Node.Bin_Op_F_Op, Info => Ent.Info);
--# expr-done 2262



   if Fld_38.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Op.is_arith_op
Fld_39 := Liblktlang.Implementation.Op_P_Is_Arith_Op (Node => Fld_38.Node);
--# end
--# expr-done 2263
if Fld_39 then
   --# expr-start 2279 LogicAnd And_Pred_7 nodes.lkt:3843
--# expr-start 2273 LogicAnd And_Pred_6 nodes.lkt:3844
--# expr-start 2267 LogicUnify Bind_Result_5 nodes.lkt:3844
--# expr-start 2264 Expr.actual_type_var Fld_40 nodes.lkt:3844







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_40 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2264
Fld_40.Value := No_Entity;
Entity_Vars.Reset (Fld_40);
--# expr-start 2266 Expr.actual_type_var Fld_42 nodes.lkt:3844



--# expr-start 2265 BinOp.left Fld_41 nodes.lkt:3844







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_41 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Left, Info => Ent.Info);
--# expr-done 2265



   if Fld_41.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_42 := Fld_41.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2266
Bind_Result_5 := Solver.Create_Unify (Fld_40, Fld_42, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3844:21") else null)); 
--# expr-done 2267




   --# scope-start



--# expr-start 2272 bind Dyn_Var_Bind_Result_3 nodes.lkt:3846





--# expr-start 2268 BinOp.left Fld_43 nodes.lkt:3846







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_43 := Self.Bin_Op_F_Left;
--# expr-done 2268



   
      Cast_Result_4 := Fld_43;


Error_Location_3 := Cast_Result_4; 
--# expr-start 2271 LogicPropagate Pred_3 nodes.lkt:3847
--# expr-start 2270 Expr.actual_type_var Fld_45 nodes.lkt:3847



--# expr-start 2269 BinOp.left Fld_44 nodes.lkt:3847







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_44 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Left, Info => Ent.Info);
--# expr-done 2269



   if Fld_44.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_45 := Fld_44.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2270
Fld_45.Value := No_Entity;
Entity_Vars.Reset (Fld_45);

Pred_3 := Solver.Create_Predicate (Fld_45, Create_Type_Decl_P_Is_Int_Type_0_Predicate (Error_Location_3)); 
--# expr-done 2271
Dyn_Var_Bind_Result_3 := Pred_3; Inc_Ref (Dyn_Var_Bind_Result_3);
--# expr-done 2272
Scope_Result_3 := Dyn_Var_Bind_Result_3;
   Inc_Ref (Scope_Result_3);


   --# end
      Finalizer_Scope_738;


And_Pred_6 := Create_And (Bind_Result_5, Scope_Result_3, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3844:21") else null)); 
--# expr-done 2273




   --# scope-start



--# expr-start 2278 bind Dyn_Var_Bind_Result_4 nodes.lkt:3851





--# expr-start 2274 BinOp.right Fld_46 nodes.lkt:3851







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_46 := Self.Bin_Op_F_Right;
--# expr-done 2274



   
      Cast_Result_5 := Fld_46;


Error_Location_4 := Cast_Result_5; 
--# expr-start 2277 LogicPropagate Pred_4 nodes.lkt:3852
--# expr-start 2276 Expr.actual_type_var Fld_48 nodes.lkt:3852



--# expr-start 2275 BinOp.right Fld_47 nodes.lkt:3852







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_47 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Right, Info => Ent.Info);
--# expr-done 2275



   if Fld_47.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_48 := Fld_47.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2276
Fld_48.Value := No_Entity;
Entity_Vars.Reset (Fld_48);

Pred_4 := Solver.Create_Predicate (Fld_48, Create_Type_Decl_P_Is_Int_Type_0_Predicate (Error_Location_4)); 
--# expr-done 2277
Dyn_Var_Bind_Result_4 := Pred_4; Inc_Ref (Dyn_Var_Bind_Result_4);
--# expr-done 2278
Scope_Result_4 := Dyn_Var_Bind_Result_4;
   Inc_Ref (Scope_Result_4);


   --# end
      Finalizer_Scope_739;


And_Pred_7 := Create_And (And_Pred_6, Scope_Result_4, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3843:17") else null)); 
--# expr-done 2279
   If_Result_3 := And_Pred_7;
else
   --# expr-start 2310 If If_Result_2 nodes.lkt:3811



--# expr-start 2281 IsA Is_A_2 nodes.lkt:3855
--# expr-start 2280 BinOp.op Fld_28 nodes.lkt:3855







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_28 := Create_Internal_Entity_Op (Node => Ent.Node.Bin_Op_F_Op, Info => Ent.Info);
--# expr-done 2280
Is_A_2 := Fld_28.Node /= null 
and then Fld_28.Node.Kind in Lkt_Op_Amp_Range; 
--# expr-done 2281
if Is_A_2 then
   --# expr-start 2297 LogicAnd And_Pred_5 nodes.lkt:3857
--# expr-start 2291 LogicAnd And_Pred_4 nodes.lkt:3858
--# expr-start 2285 LogicUnify Bind_Result_4 nodes.lkt:3858
--# expr-start 2282 Expr.actual_type_var Fld_29 nodes.lkt:3858







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_29 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2282
Fld_29.Value := No_Entity;
Entity_Vars.Reset (Fld_29);
--# expr-start 2284 Expr.actual_type_var Fld_31 nodes.lkt:3858



--# expr-start 2283 BinOp.left Fld_30 nodes.lkt:3858







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_30 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Left, Info => Ent.Info);
--# expr-done 2283



   if Fld_30.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_31 := Fld_30.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2284
Bind_Result_4 := Solver.Create_Unify (Fld_29, Fld_31, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3858:21") else null)); 
--# expr-done 2285




   --# scope-start



--# expr-start 2290 bind Dyn_Var_Bind_Result_1 nodes.lkt:3860





--# expr-start 2286 BinOp.left Fld_32 nodes.lkt:3860







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_32 := Self.Bin_Op_F_Left;
--# expr-done 2286



   
      Cast_Result_2 := Fld_32;


Error_Location_1 := Cast_Result_2; 
--# expr-start 2289 LogicPropagate Pred_1 nodes.lkt:3861
--# expr-start 2288 Expr.actual_type_var Fld_34 nodes.lkt:3862



--# expr-start 2287 BinOp.left Fld_33 nodes.lkt:3862







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_33 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Left, Info => Ent.Info);
--# expr-done 2287



   if Fld_33.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_34 := Fld_33.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2288
Fld_34.Value := No_Entity;
Entity_Vars.Reset (Fld_34);

Pred_1 := Solver.Create_Predicate (Fld_34, Create_Type_Decl_P_Is_String_Or_Array_Type_0_Predicate (Error_Location_1)); 
--# expr-done 2289
Dyn_Var_Bind_Result_1 := Pred_1; Inc_Ref (Dyn_Var_Bind_Result_1);
--# expr-done 2290
Scope_Result_1 := Dyn_Var_Bind_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_736;


And_Pred_4 := Create_And (Bind_Result_4, Scope_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3858:21") else null)); 
--# expr-done 2291




   --# scope-start



--# expr-start 2296 bind Dyn_Var_Bind_Result_2 nodes.lkt:3867





--# expr-start 2292 BinOp.right Fld_35 nodes.lkt:3867







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_35 := Self.Bin_Op_F_Right;
--# expr-done 2292



   
      Cast_Result_3 := Fld_35;


Error_Location_2 := Cast_Result_3; 
--# expr-start 2295 LogicPropagate Pred_2 nodes.lkt:3868
--# expr-start 2294 Expr.actual_type_var Fld_37 nodes.lkt:3869



--# expr-start 2293 BinOp.right Fld_36 nodes.lkt:3869







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_36 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Right, Info => Ent.Info);
--# expr-done 2293



   if Fld_36.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_37 := Fld_36.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2294
Fld_37.Value := No_Entity;
Entity_Vars.Reset (Fld_37);

Pred_2 := Solver.Create_Predicate (Fld_37, Create_Type_Decl_P_Is_String_Or_Array_Type_0_Predicate (Error_Location_2)); 
--# expr-done 2295
Dyn_Var_Bind_Result_2 := Pred_2; Inc_Ref (Dyn_Var_Bind_Result_2);
--# expr-done 2296
Scope_Result_2 := Dyn_Var_Bind_Result_2;
   Inc_Ref (Scope_Result_2);


   --# end
      Finalizer_Scope_737;


And_Pred_5 := Create_And (And_Pred_4, Scope_Result_2, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3857:17") else null)); 
--# expr-done 2297
   If_Result_2 := And_Pred_5;
else
   --# expr-start 2309 If If_Result_1 nodes.lkt:3811



--# expr-start 2299 IsA Is_A_1 nodes.lkt:3873
--# expr-start 2298 BinOp.op Fld_22 nodes.lkt:3873







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_22 := Create_Internal_Entity_Op (Node => Ent.Node.Bin_Op_F_Op, Info => Ent.Info);
--# expr-done 2298
Is_A_1 := Fld_22.Node /= null 
and then Fld_22.Node.Kind in Lkt_Op_Or_Int_Range; 
--# expr-done 2299
if Is_A_1 then
   --# expr-start 2304 ArrayLiteral Array_Lit nodes.lkt:3877
--# expr-start 2301 Expr.actual_type_var Fld_25 nodes.lkt:3877



--# expr-start 2300 BinOp.left Fld_24 nodes.lkt:3877







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_24 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Left, Info => Ent.Info);
--# expr-done 2300



   if Fld_24.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_25 := Fld_24.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2301
--# expr-start 2303 Expr.actual_type_var Fld_27 nodes.lkt:3877



--# expr-start 2302 BinOp.right Fld_26 nodes.lkt:3877







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_26 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Right, Info => Ent.Info);
--# expr-done 2302



   if Fld_26.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_27 := Fld_26.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2303
Array_Lit := Create_Logic_Var_Array (Internal_Logic_Var_Array'(1 => Fld_25, 2 => Fld_27)); 
--# expr-done 2304
for Var of Array_Lit.Items loop
   Var.Value := No_Entity;
   Entity_Vars.Reset (Var);
end loop;
Logic_Vars := Array_Lit; Inc_Ref (Logic_Vars);
--# expr-start 2305 Expr.actual_type_var Fld_23 nodes.lkt:3875







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_23 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2305
Fld_23.Value := No_Entity;
Entity_Vars.Reset (Fld_23);


Bind_Result_3 := Solver.Create_N_Propagate (Fld_23, Create_Type_Decl_P_Imprecise_Common_Ancestor_List_0_Functor (Logic_Vars.N), Entity_Vars.Logic_Var_Array (Logic_Vars.Items)); 
   If_Result_1 := Bind_Result_3;
else
   --# expr-start 2308 LogicAssign Bind_Result_2 nodes.lkt:3880
--# expr-start 2306 Expr.actual_type_var Fld_20 nodes.lkt:3880







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_20 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2306
Fld_20.Value := No_Entity;
Entity_Vars.Reset (Fld_20);





--# expr-start 2307 LktNode.bool_type Fld_21 nodes.lkt:3880







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.bool_type
Fld_21 := Liblktlang.Implementation.Lkt_Node_P_Bool_Type (Node => Ent.Node);
--# end
--# expr-done 2307



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Fld_21.Node,
         Info => Fld_21.Info);


Bind_Result_2 := Solver.Create_Assign (Fld_20, Cast_Result_1, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3880:18") else null)); 
--# expr-done 2308
   If_Result_1 := Bind_Result_2;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 2309
   If_Result_2 := If_Result_1;
end if;

      Inc_Ref (If_Result_2);


--# expr-done 2310
   If_Result_3 := If_Result_2;
end if;

      Inc_Ref (If_Result_3);


--# expr-done 2311
   If_Result_4 := If_Result_3;
end if;

      Inc_Ref (If_Result_4);


--# expr-done 2312
   If_Result_5 := If_Result_4;
end if;

      Inc_Ref (If_Result_5);


--# expr-done 2313
   If_Result_6 := If_Result_5;
end if;

      Inc_Ref (If_Result_6);


--# expr-done 2314
And_Pred_12 := Create_And (And_Pred_3, If_Result_6, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3783:9") else null)); 
--# expr-done 2315

         Property_Result := And_Pred_12;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_304;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_304;
                     Finalizer_Scope_735;
                     Finalizer_Scope_736;
                     Finalizer_Scope_737;
                     Finalizer_Scope_738;
                     Finalizer_Scope_739;
                     Finalizer_Scope_740;
                     Finalizer_Scope_741;
                     Finalizer_Scope_742;
                     Finalizer_Scope_743;




            raise;
      end;



   return Property_Result;
end Bin_Op_P_Xref_Equation;
--# end

   







--# property-start BinOp.has_context_free_type nodes.lkt:3883
pragma Warnings (Off, "is not referenced");

function Bin_Op_P_Has_Context_Free_Type
  
  (Node : Bare_Bin_Op
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Bin_Op :=
     Bare_Bin_Op (Node);
     Ent : Internal_Entity_Bin_Op :=
       Internal_Entity_Bin_Op'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Fld : Internal_Entity_Expr;
Fld_1 : Boolean;
Fld_2 : Internal_Entity_Expr;
Fld_3 : Boolean;
If_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 2320 BooleanOr If_Result nodes.lkt:3884



--# expr-start 2317 Expr.has_context_free_type Fld_1 nodes.lkt:3884



--# expr-start 2316 BinOp.left Fld nodes.lkt:3884







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Left, Info => Ent.Info);
--# expr-done 2316



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2317
if Fld_1 then
   
   If_Result := True;
else
   --# expr-start 2319 Expr.has_context_free_type Fld_3 nodes.lkt:3884



--# expr-start 2318 BinOp.right Fld_2 nodes.lkt:3884







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Ent.Node.Bin_Op_F_Right, Info => Ent.Info);
--# expr-done 2318



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_3 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Fld_2.Node, E_Info => Fld_2.Info);
--# end
--# expr-done 2319
   If_Result := Fld_3;
end if;



--# expr-done 2320

         Property_Result := If_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Bin_Op_P_Has_Context_Free_Type;
--# end



   


      

   --
   --  Primitives for Bare_Block_Expr
   --

   



   

   

   

   

   

   

   


      procedure Block_Expr_Pre_Env_Actions
        (Self            : Bare_Block_Expr;
         State           : in out PLE_Node_State;
         Add_To_Env_Only : Boolean := False) is
      begin
            


   
      if Add_To_Env_Only then
         return;
      end if;

      declare
         No_Parent         : constant Boolean :=
            False;
         Transitive_Parent : constant Boolean :=
            False;
         Names             : Symbol_Type_Array_Access :=
            null;
      begin
         Add_Env (Self, State, No_Parent, Transitive_Parent, Names);
      end;
   
   
      end;



      
      procedure Initialize_Fields_For_Block_Expr
        (Self : Bare_Block_Expr
         ; Block_Expr_F_Clauses : Bare_Lkt_Node_List
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Block_Expr_F_Clauses := Block_Expr_F_Clauses;
         

      end Initialize_Fields_For_Block_Expr;

      
   function Block_Expr_F_Clauses
     (Node : Bare_Block_Expr) return Bare_Lkt_Node_List
   is
      

   begin
         
         return Node.Block_Expr_F_Clauses;
      
   end;


   







--# property-start BlockExpr.expr nodes.lkt:3900
pragma Warnings (Off, "is not referenced");

function Block_Expr_P_Expr
  
  (Node : Bare_Block_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Expr
is
   Self : Bare_Block_Expr :=
     Bare_Block_Expr (Node);
     Ent : Internal_Entity_Block_Expr :=
       Internal_Entity_Block_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Expr;

      

      Fld : Internal_Entity_Lkt_Node_List;
Fld_1 : Internal_Entity_Lkt_Node_List;
Fld_2 : Bare_Lkt_Node_List;
Len : Integer;
Arith_Result : Integer;
Fld_3 : Bare_Lkt_Node_List;
Fld_4 : Internal_Entity_Info;
Get_Result : Bare_Lkt_Node;
As_Entity : Internal_Entity;
Is_Null : Boolean;
If_Result : Internal_Entity;
Cast_Expr : Internal_Entity;
Cast_Result : Internal_Entity_Expr;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 2325 Cast Cast_Result nodes.lkt:3901





--# expr-start 2321 BlockExpr.clauses Fld nodes.lkt:3901







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Lkt_Node_List (Node => Ent.Node.Block_Expr_F_Clauses, Info => Ent.Info);
--# expr-done 2321
















Fld_3 := Fld.Node;



   if Fld_3 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 2324 'Arithmetic '"'"'-'"'"'' Arith_Result nodes.lkt:3901
--# expr-start 2323 .length Len nodes.lkt:3901



--# expr-start 2322 BlockExpr.clauses Fld_1 nodes.lkt:3901







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Lkt_Node_List (Node => Ent.Node.Block_Expr_F_Clauses, Info => Ent.Info);
--# expr-done 2322





Fld_2 := Fld_1.Node; 
Len := Length (Fld_2); 
--# expr-done 2323

Arith_Result := (Len - 1); 
--# expr-done 2324

Get_Result := Get (Self, Fld_3, Arith_Result, True); 
Is_Null := Get_Result = null; 
if Is_Null then
   
   If_Result := No_Entity;
else
   








Fld_4 := Fld.Info;

As_Entity := (Info => Fld_4, Node => Get_Result); 
   If_Result := As_Entity;
end if;



Cast_Expr := If_Result; 



   if Cast_Expr.Node = null
      or else Cast_Expr.Node.Kind in Lkt_Expr
   then
      
      Cast_Result := Create_Internal_Entity_Expr
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);

   else
         Cast_Result := No_Entity_Expr;
   end if;


--# expr-done 2325

         Property_Result := Cast_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Block_Expr_P_Expr;
--# end

   







--# property-start BlockExpr.xref_equation nodes.lkt:3903
pragma Warnings (Off, "is not referenced");

function Block_Expr_P_Xref_Equation
  
  (Node : Bare_Block_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Block_Expr :=
     Bare_Block_Expr (Node);
     Ent : Internal_Entity_Block_Expr :=
       Internal_Entity_Block_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_307 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Logic_Var;
Fld_3 : Internal_Entity_Expr;
Fld_4 : Logic_Var;
Bind_Result : Logic_Equation;
And_Pred : Logic_Equation;
Fld_5 : Logic_Var;
Fld_6 : Internal_Entity_Expr;
Fld_7 : Logic_Var;
Bind_Result_1 : Logic_Equation;
And_Pred_1 : Logic_Equation;

            procedure Finalizer_Scope_307 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (And_Pred_1);
            end Finalizer_Scope_307;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2337 LogicAnd And_Pred_1 nodes.lkt:3904
--# expr-start 2332 LogicAnd And_Pred nodes.lkt:3905
--# expr-start 2327 LktNode.xref_equation Fld_1 nodes.lkt:3905



--# expr-start 2326 BlockExpr.expr Fld nodes.lkt:3905







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start BlockExpr.expr
Fld := Liblktlang.Implementation.Block_Expr_P_Expr (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2326



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2327
--# expr-start 2331 LogicUnify Bind_Result nodes.lkt:3906
--# expr-start 2328 Expr.actual_type_var Fld_2 nodes.lkt:3906







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2328
Fld_2.Value := No_Entity;
Entity_Vars.Reset (Fld_2);
--# expr-start 2330 Expr.actual_type_var Fld_4 nodes.lkt:3906



--# expr-start 2329 BlockExpr.expr Fld_3 nodes.lkt:3906







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start BlockExpr.expr
Fld_3 := Liblktlang.Implementation.Block_Expr_P_Expr (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2329



   if Fld_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Fld_3.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2330
Bind_Result := Solver.Create_Unify (Fld_2, Fld_4, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3906:18") else null)); 
--# expr-done 2331
And_Pred := Create_And (Fld_1, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3905:13") else null)); 
--# expr-done 2332
--# expr-start 2336 LogicUnify Bind_Result_1 nodes.lkt:3908
--# expr-start 2333 Expr.expected_type_var Fld_5 nodes.lkt:3908







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Ent.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2333
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);
--# expr-start 2335 Expr.expected_type_var Fld_7 nodes.lkt:3908



--# expr-start 2334 BlockExpr.expr Fld_6 nodes.lkt:3908







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start BlockExpr.expr
Fld_6 := Liblktlang.Implementation.Block_Expr_P_Expr (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2334



   if Fld_6.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Fld_6.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2335
Bind_Result_1 := Solver.Create_Unify (Fld_5, Fld_7, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3908:14") else null)); 
--# expr-done 2336
And_Pred_1 := Create_And (And_Pred, Bind_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3904:9") else null)); 
--# expr-done 2337

         Property_Result := And_Pred_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_307;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_307;




            raise;
      end;



   return Property_Result;
end Block_Expr_P_Xref_Equation;
--# end

   







--# property-start BlockExpr.has_context_free_type nodes.lkt:3910
pragma Warnings (Off, "is not referenced");

function Block_Expr_P_Has_Context_Free_Type
  
  (Node : Bare_Block_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Block_Expr :=
     Bare_Block_Expr (Node);
     Ent : Internal_Entity_Block_Expr :=
       Internal_Entity_Block_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Fld : Internal_Entity_Expr;
Fld_1 : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 2339 Expr.has_context_free_type Fld_1 nodes.lkt:3910



--# expr-start 2338 BlockExpr.expr Fld nodes.lkt:3910







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start BlockExpr.expr
Fld := Liblktlang.Implementation.Block_Expr_P_Expr (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2338



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2339

         Property_Result := Fld_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Block_Expr_P_Has_Context_Free_Type;
--# end



   


      

   --
   --  Primitives for Bare_Cast_Expr
   --

   



      
      procedure Initialize_Fields_For_Cast_Expr
        (Self : Bare_Cast_Expr
         ; Cast_Expr_F_Expr : Bare_Expr
         ; Cast_Expr_F_Null_Cond : Bare_Null_Cond_Qualifier
         ; Cast_Expr_F_Excludes_Null : Bare_Excludes_Null
         ; Cast_Expr_F_Dest_Type : Bare_Type_Ref
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Cast_Expr_F_Expr := Cast_Expr_F_Expr;
            Self.Cast_Expr_F_Null_Cond := Cast_Expr_F_Null_Cond;
            Self.Cast_Expr_F_Excludes_Null := Cast_Expr_F_Excludes_Null;
            Self.Cast_Expr_F_Dest_Type := Cast_Expr_F_Dest_Type;
         

      end Initialize_Fields_For_Cast_Expr;

      
   function Cast_Expr_F_Expr
     (Node : Bare_Cast_Expr) return Bare_Expr
   is
      

   begin
         
         return Node.Cast_Expr_F_Expr;
      
   end;

      
   function Cast_Expr_F_Null_Cond
     (Node : Bare_Cast_Expr) return Bare_Null_Cond_Qualifier
   is
      

   begin
         
         return Node.Cast_Expr_F_Null_Cond;
      
   end;

      
   function Cast_Expr_F_Excludes_Null
     (Node : Bare_Cast_Expr) return Bare_Excludes_Null
   is
      

   begin
         
         return Node.Cast_Expr_F_Excludes_Null;
      
   end;

      
   function Cast_Expr_F_Dest_Type
     (Node : Bare_Cast_Expr) return Bare_Type_Ref
   is
      

   begin
         
         return Node.Cast_Expr_F_Dest_Type;
      
   end;


   







--# property-start CastExpr.expected_type_equation nodes.lkt:3928
pragma Warnings (Off, "is not referenced");

function Cast_Expr_P_Expected_Type_Equation
  
  (Node : Bare_Cast_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Cast_Expr :=
     Bare_Cast_Expr (Node);
     Ent : Internal_Entity_Cast_Expr :=
       Internal_Entity_Cast_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_309 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;

            procedure Finalizer_Scope_309 is
            begin
                     Dec_Ref (Bind_Result);
            end Finalizer_Scope_309;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 2342 LogicAssign Bind_Result nodes.lkt:3929
--# expr-start 2341 Expr.expected_type_var Fld_1 nodes.lkt:3929



--# expr-start 2340 CastExpr.expr Fld nodes.lkt:3929







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Cast_Expr_F_Expr, Info => Ent.Info);
--# expr-done 2340



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Fld.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2341
Fld_1.Value := No_Entity;
Entity_Vars.Reset (Fld_1);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result := Solver.Create_Assign (Fld_1, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3929:9") else null)); 
--# expr-done 2342

         Property_Result := Bind_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_309;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_309;




            raise;
      end;



   return Property_Result;
end Cast_Expr_P_Expected_Type_Equation;
--# end

   







--# property-start CastExpr.xref_equation nodes.lkt:3931
pragma Warnings (Off, "is not referenced");

function Cast_Expr_P_Xref_Equation
  
  (Node : Bare_Cast_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Cast_Expr :=
     Bare_Cast_Expr (Node);
     Ent : Internal_Entity_Cast_Expr :=
       Internal_Entity_Cast_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_310 with Inline_Always;

      Fld : Internal_Entity_Type_Ref;
Fld_1 : Logic_Equation;
Fld_2 : Logic_Var;
Fld_3 : Internal_Entity_Expr;
Fld_4 : Internal_Entity_Type_Decl;
Var_Expr : Internal_Entity_Type_Decl;
Fld_5 : Internal_Entity_Type_Ref;
Fld_6 : Internal_Entity_Type_Decl;
Fld_7 : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
And_Pred : Logic_Equation;

            procedure Finalizer_Scope_310 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred);
            end Finalizer_Scope_310;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2352 LogicAnd And_Pred nodes.lkt:3932
--# expr-start 2344 LktNode.xref_equation Fld_1 nodes.lkt:3932



--# expr-start 2343 CastExpr.dest_type Fld nodes.lkt:3932







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Cast_Expr_F_Dest_Type, Info => Ent.Info);
--# expr-done 2343



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2344
--# expr-start 2351 LogicAssign Bind_Result nodes.lkt:3933
--# expr-start 2345 Expr.actual_type_var Fld_2 nodes.lkt:3933







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2345
Fld_2.Value := No_Entity;
Entity_Vars.Reset (Fld_2);








--# expr-start 2347 Expr.get_type Fld_4 nodes.lkt:3934



--# expr-start 2346 CastExpr.expr Fld_3 nodes.lkt:3934







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Expr (Node => Ent.Node.Cast_Expr_F_Expr, Info => Ent.Info);
--# expr-done 2346



   if Fld_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.get_type'
Fld_4 := Liblktlang.Implementation.Dispatcher_Expr_P_Get_Type (Node => Fld_3.Node, E_Info => Fld_3.Info);
--# end
--# expr-done 2347
Var_Expr := Fld_4;





if Var_Expr /= No_Entity_Type_Decl then
   --# expr-start 2350 Decl.get_cast_type Fld_7 nodes.lkt:3934







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 2349 TypeRef.referenced_decl Fld_6 nodes.lkt:3935



--# expr-start 2348 CastExpr.dest_type Fld_5 nodes.lkt:3935







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Cast_Expr_F_Dest_Type, Info => Ent.Info);
--# expr-done 2348



   if Fld_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_6 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Fld_5.Node, E_Info => Fld_5.Info);
--# end
--# expr-done 2349
--# property-call-start Decl.get_cast_type
Fld_7 := Liblktlang.Implementation.Decl_P_Get_Cast_Type (Node => Var_Expr.Node, Cast_To => Fld_6, E_Info => Var_Expr.Info);
--# end
--# expr-done 2350
   Result_Var := Fld_7;
else
   
   Result_Var := No_Entity_Type_Decl;
end if;






   
      Cast_Result := Create_Internal_Entity
        (Node => Result_Var.Node,
         Info => Result_Var.Info);


Bind_Result := Solver.Create_Assign (Fld_2, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3933:14") else null)); 
--# expr-done 2351
And_Pred := Create_And (Fld_1, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3932:9") else null)); 
--# expr-done 2352

         Property_Result := And_Pred;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_310;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_310;




            raise;
      end;



   return Property_Result;
end Cast_Expr_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Dot_Expr
   --

   



      
      procedure Initialize_Fields_For_Dot_Expr
        (Self : Bare_Dot_Expr
         ; Dot_Expr_F_Prefix : Bare_Expr
         ; Dot_Expr_F_Null_Cond : Bare_Null_Cond_Qualifier
         ; Dot_Expr_F_Suffix : Bare_Ref_Id
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Dot_Expr_F_Prefix := Dot_Expr_F_Prefix;
            Self.Dot_Expr_F_Null_Cond := Dot_Expr_F_Null_Cond;
            Self.Dot_Expr_F_Suffix := Dot_Expr_F_Suffix;
         

      end Initialize_Fields_For_Dot_Expr;

      
   function Dot_Expr_F_Prefix
     (Node : Bare_Dot_Expr) return Bare_Expr
   is
      

   begin
         
         return Node.Dot_Expr_F_Prefix;
      
   end;

      
   function Dot_Expr_F_Null_Cond
     (Node : Bare_Dot_Expr) return Bare_Null_Cond_Qualifier
   is
      

   begin
         
         return Node.Dot_Expr_F_Null_Cond;
      
   end;

      
   function Dot_Expr_F_Suffix
     (Node : Bare_Dot_Expr) return Bare_Ref_Id
   is
      

   begin
         
         return Node.Dot_Expr_F_Suffix;
      
   end;


   







--# property-start DotExpr.referenced_decl nodes.lkt:3635
pragma Warnings (Off, "is not referenced");

function Dot_Expr_P_Referenced_Decl
  
  (Node : Bare_Dot_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Decl
is
   Self : Bare_Dot_Expr :=
     Bare_Dot_Expr (Node);
     Ent : Internal_Entity_Dot_Expr :=
       Internal_Entity_Dot_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Decl;

      

      Fld : Internal_Entity_Ref_Id;
Fld_1 : Internal_Entity_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2354 RefId.referenced_decl Fld_1 nodes.lkt:3635



--# expr-start 2353 DotExpr.suffix Fld nodes.lkt:3635







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Dot_Expr_F_Suffix, Info => Ent.Info);
--# expr-done 2353



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.referenced_decl'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Referenced_Decl (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2354

         Property_Result := Fld_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Dot_Expr_P_Referenced_Decl;
--# end

   







--# property-start DotExpr.has_context_free_type nodes.lkt:3637
pragma Warnings (Off, "is not referenced");

function Dot_Expr_P_Has_Context_Free_Type
  
  (Node : Bare_Dot_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Dot_Expr :=
     Bare_Dot_Expr (Node);
     Ent : Internal_Entity_Dot_Expr :=
       Internal_Entity_Dot_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Fld : Internal_Entity_Expr;
Fld_1 : Boolean;
Fld_2 : Internal_Entity_Ref_Id;
Fld_3 : Boolean;
Not_Val : Boolean;
If_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 2360 BooleanAnd If_Result nodes.lkt:3638



--# expr-start 2356 Expr.has_context_free_type Fld_1 nodes.lkt:3638



--# expr-start 2355 DotExpr.prefix Fld nodes.lkt:3638







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Dot_Expr_F_Prefix, Info => Ent.Info);
--# expr-done 2355



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2356
if Fld_1 then
   --# expr-start 2359 Not Not_Val nodes.lkt:3639
--# expr-start 2358 RefId.is_being_called Fld_3 nodes.lkt:3639



--# expr-start 2357 DotExpr.suffix Fld_2 nodes.lkt:3639







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Dot_Expr_F_Suffix, Info => Ent.Info);
--# expr-done 2357



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start RefId.is_being_called
Fld_3 := Liblktlang.Implementation.Ref_Id_P_Is_Being_Called (Node => Fld_2.Node, E_Info => Fld_2.Info);
--# end
--# expr-done 2358
Not_Val := not (Fld_3); 
--# expr-done 2359
   If_Result := Not_Val;
else
   
   If_Result := False;
end if;



--# expr-done 2360

         Property_Result := If_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Dot_Expr_P_Has_Context_Free_Type;
--# end

   







--# property-start DotExpr.first_var_in_prefix_env nodes.lkt:3644
pragma Warnings (Off, "is not referenced");

function Dot_Expr_P_First_Var_In_Prefix_Env
  
  (Node : Bare_Dot_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Decl
is
   Self : Bare_Dot_Expr :=
     Bare_Dot_Expr (Node);
     Ent : Internal_Entity_Dot_Expr :=
       Internal_Entity_Dot_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Decl;

      
            procedure Finalizer_Scope_722 with Inline_Always;

      Fld : Internal_Entity_Expr;
Local_Rid : Internal_Entity_Ref_Id;
Fld_1 : Internal_Entity_Decl;
Var_Expr : Internal_Entity_Decl;
Fld_2 : Internal_Entity_Type_Decl;
Fld_3 : Internal_Entity_Ref_Id;
Fld_4 : Internal_Entity_Decl;
Result_Var : Internal_Entity_Decl;
Fld_5 : Boolean;
Origin : Internal_Entity;
Fld_6 : Internal_Entity_Array_Access;
Is_A : Boolean;
Find_Result : Internal_Entity;
Fld_7 : Internal_Entity_Expr;
Fld_8 : Internal_Entity_Type_Decl;
Var_Expr_1 : Internal_Entity_Type_Decl;
Fld_9 : Internal_Entity_Decl;
Result_Var_1 : Internal_Entity_Decl;
Dyn_Var_Bind_Result : Internal_Entity_Decl;
Scope_Result : Internal_Entity_Decl;
If_Result : Internal_Entity_Decl;
Local_De : Internal_Entity_Dot_Expr;
Fld_10 : Internal_Entity_Decl;
Var_Expr_2 : Internal_Entity_Decl;
Fld_11 : Internal_Entity_Type_Decl;
Fld_12 : Internal_Entity_Ref_Id;
Fld_13 : Internal_Entity_Decl;
Result_Var_2 : Internal_Entity_Decl;
Local_Expr : Internal_Entity_Expr;
Fld_14 : Internal_Entity_Type_Decl;
Var_Expr_3 : Internal_Entity_Type_Decl;
Fld_15 : Internal_Entity_Ref_Id;
Fld_16 : Internal_Entity_Decl;
Result_Var_3 : Internal_Entity_Decl;
Match_Prefix : Internal_Entity_Expr;
Cast_Result : Internal_Entity_Ref_Id;
Let_Result : Internal_Entity_Decl;
Scope_Result_1 : Internal_Entity_Decl;
Cast_Result_1 : Internal_Entity_Dot_Expr;
Let_Result_1 : Internal_Entity_Decl;
Scope_Result_2 : Internal_Entity_Decl;
Cast_Result_2 : Internal_Entity_Expr;
Let_Result_2 : Internal_Entity_Decl;
Scope_Result_3 : Internal_Entity_Decl;
Match_Result : Internal_Entity_Decl;

            procedure Finalizer_Scope_722 is
            begin
                     Dec_Ref (Fld_6);
            end Finalizer_Scope_722;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Dot_Expr_Dot_Expr_P_First_Var_In_Prefix_Env,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Dot_Expr,
                                As_Bare_Dot_Expr => Self);
               Mmz_K.Items (2) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Entity_Decl;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 2382 Match Match_Result nodes.lkt:3644






--# expr-start 2361 DotExpr.prefix Fld nodes.lkt:3644







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Dot_Expr_F_Prefix, Info => Ent.Info);
--# expr-done 2361



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := Fld; 

case Lkt_Expr (Match_Prefix.Node.Kind) is
         when Lkt_Ref_Id =>
            



   --# scope-start



--# scope-start









   
      Cast_Result := Create_Internal_Entity_Ref_Id
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Rid := Cast_Result; 
--# bind rid Local_Rid
--# expr-start 2374 If If_Result nodes.lkt:3646



--# expr-start 2362 DotExpr.is_call_to_super Fld_5 nodes.lkt:3646







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DotExpr.is_call_to_super
Fld_5 := Liblktlang.Implementation.Dot_Expr_P_Is_Call_To_Super (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2362
if Fld_5 then
   



   --# scope-start



--# expr-start 2369 bind Dyn_Var_Bind_Result nodes.lkt:3652
--# expr-start 2365 .find Find_Result nodes.lkt:3652








   

   --# expr-start 2363 LktNode.parents Fld_6 nodes.lkt:3652







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



Fld_6 := Liblktlang.Implementation.Parents (Node => Ent.Node, With_Self => True, E_Info => Ent.Info);
--# expr-done 2363

   
      Find_Result := No_Entity;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Fld_6;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind p Item

            
      --# expr-start 2364 IsA Is_A nodes.lkt:3652

Is_A := Item.Node /= null 
and then Item.Node.Kind in Lkt_Fun_Decl_Range; 
--# expr-done 2364
      if Is_A then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Is_A;

         end loop;
      end;
   

   
   



--# expr-done 2365
Origin := Find_Result; 



--# expr-start 2367 Expr.get_type Fld_8 nodes.lkt:3654



--# expr-start 2366 DotExpr.prefix Fld_7 nodes.lkt:3654







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Create_Internal_Entity_Expr (Node => Ent.Node.Dot_Expr_F_Prefix, Info => Ent.Info);
--# expr-done 2366



   if Fld_7.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.get_type'
Fld_8 := Liblktlang.Implementation.Dispatcher_Expr_P_Get_Type (Node => Fld_7.Node, E_Info => Fld_7.Info);
--# end
--# expr-done 2367
Var_Expr_1 := Fld_8;





if Var_Expr_1 /= No_Entity_Type_Decl then
   --# expr-start 2368 TypeDecl.get_super_of_parent Fld_9 nodes.lkt:3654







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.get_super_of_parent
Fld_9 := Liblktlang.Implementation.Type_Decl_P_Get_Super_Of_Parent (Node => Var_Expr_1.Node, Origin => Origin, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 2368
   Result_Var_1 := Fld_9;
else
   
   Result_Var_1 := No_Entity_Decl;
end if;



Dyn_Var_Bind_Result := Result_Var_1; 
--# expr-done 2369
Scope_Result := Dyn_Var_Bind_Result;


   --# end
      Finalizer_Scope_722;


   If_Result := Scope_Result;
else
   


--# expr-start 2370 RefId.referenced_decl Fld_1 nodes.lkt:3658







   if Local_Rid.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.referenced_decl'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Referenced_Decl (Node => Local_Rid.Node, E_Info => Local_Rid.Info);
--# end
--# expr-done 2370
Var_Expr := Fld_1;





if Var_Expr /= No_Entity_Decl then
   --# expr-start 2373 Decl.ref_var_suffix_ref Fld_4 nodes.lkt:3658







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 2371 Expr.get_type Fld_2 nodes.lkt:3659







   if Local_Rid.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.get_type'
Fld_2 := Liblktlang.Implementation.Dispatcher_Expr_P_Get_Type (Node => Local_Rid.Node, E_Info => Local_Rid.Info);
--# end
--# expr-done 2371
--# expr-start 2372 DotExpr.suffix Fld_3 nodes.lkt:3660







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Dot_Expr_F_Suffix, Info => Ent.Info);
--# expr-done 2372
--# property-call-start Decl.ref_var_suffix_ref
Fld_4 := Liblktlang.Implementation.Decl_P_Ref_Var_Suffix_Ref (Node => Var_Expr.Node, Type_Var => Fld_2, Current_Name => Fld_3, E_Info => Var_Expr.Info);
--# end
--# expr-done 2373
   Result_Var := Fld_4;
else
   
   Result_Var := No_Entity_Decl;
end if;



   If_Result := Result_Var;
end if;



--# expr-done 2374
Let_Result := If_Result; 
--# end
Scope_Result_1 := Let_Result;


   --# end


            Match_Result := Scope_Result_1; 
         when Lkt_Dot_Expr =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_1 := Create_Internal_Entity_Dot_Expr
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_De := Cast_Result_1; 
--# bind de Local_De



--# expr-start 2375 DotExpr.referenced_decl Fld_10 nodes.lkt:3663







   if Local_De.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.referenced_decl'
Fld_10 := Liblktlang.Implementation.Dispatcher_Expr_P_Referenced_Decl (Node => Local_De.Node, E_Info => Local_De.Info);
--# end
--# expr-done 2375
Var_Expr_2 := Fld_10;





if Var_Expr_2 /= No_Entity_Decl then
   --# expr-start 2378 Decl.ref_var_suffix_ref Fld_13 nodes.lkt:3663







   if Var_Expr_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 2376 Expr.get_type Fld_11 nodes.lkt:3664







   if Local_De.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.get_type'
Fld_11 := Liblktlang.Implementation.Dispatcher_Expr_P_Get_Type (Node => Local_De.Node, E_Info => Local_De.Info);
--# end
--# expr-done 2376
--# expr-start 2377 DotExpr.suffix Fld_12 nodes.lkt:3665







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_12 := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Dot_Expr_F_Suffix, Info => Ent.Info);
--# expr-done 2377
--# property-call-start Decl.ref_var_suffix_ref
Fld_13 := Liblktlang.Implementation.Decl_P_Ref_Var_Suffix_Ref (Node => Var_Expr_2.Node, Type_Var => Fld_11, Current_Name => Fld_12, E_Info => Var_Expr_2.Info);
--# end
--# expr-done 2378
   Result_Var_2 := Fld_13;
else
   
   Result_Var_2 := No_Entity_Decl;
end if;



Let_Result_1 := Result_Var_2; 
--# end
Scope_Result_2 := Let_Result_1;


   --# end


            Match_Result := Scope_Result_2; 
         when Lkt_Any_Of .. Lkt_Cast_Expr | Lkt_Error_On_Null .. Lkt_Module_Ref_Id | Lkt_If_Expr .. Lkt_Un_Op =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_2 := Create_Internal_Entity_Expr
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Expr := Cast_Result_2; 
--# bind expr Local_Expr



--# expr-start 2379 Expr.get_type Fld_14 nodes.lkt:3667







   if Local_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.get_type'
Fld_14 := Liblktlang.Implementation.Dispatcher_Expr_P_Get_Type (Node => Local_Expr.Node, E_Info => Local_Expr.Info);
--# end
--# expr-done 2379
Var_Expr_3 := Fld_14;





if Var_Expr_3 /= No_Entity_Type_Decl then
   --# expr-start 2381 Decl.type_var_suffix_ref Fld_16 nodes.lkt:3667







   if Var_Expr_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 2380 DotExpr.suffix Fld_15 nodes.lkt:3667







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_15 := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Dot_Expr_F_Suffix, Info => Ent.Info);
--# expr-done 2380
--# property-call-start Decl.type_var_suffix_ref
Fld_16 := Liblktlang.Implementation.Decl_P_Type_Var_Suffix_Ref (Node => Var_Expr_3.Node, Current_Name => Fld_15, E_Info => Var_Expr_3.Info);
--# end
--# expr-done 2381
   Result_Var_3 := Fld_16;
else
   
   Result_Var_3 := No_Entity_Decl;
end if;



Let_Result_2 := Result_Var_3; 
--# end
Scope_Result_3 := Let_Result_2;


   --# end


            Match_Result := Scope_Result_3; 
end case;

--# expr-done 2382

         Property_Result := Match_Result;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_722;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Entity_Decl,
                     As_Internal_Entity_Decl => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Dot_Expr_P_First_Var_In_Prefix_Env;
--# end

   







--# property-start DotExpr.xtype_equation nodes.lkt:3670
pragma Warnings (Off, "is not referenced");

function Dot_Expr_P_Xtype_Equation
  
  (Node : Bare_Dot_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Dot_Expr :=
     Bare_Dot_Expr (Node);
     Ent : Internal_Entity_Dot_Expr :=
       Internal_Entity_Dot_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_296 with Inline_Always;
            procedure Finalizer_Scope_726 with Inline_Always;

      Fld : Internal_Entity_Ref_Id;
Fld_1 : Logic_Var;
Fld_2 : Internal_Entity_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_3 : Bare_Ref_Id;
Fld_4 : Internal_Entity_Ref_Id;
Fld_5 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred : Logic_Equation;

            procedure Finalizer_Scope_296 is
            begin
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred);
            end Finalizer_Scope_296;
            procedure Finalizer_Scope_726 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_726;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2392 LogicAnd And_Pred nodes.lkt:3671
--# expr-start 2386 LogicAssign Bind_Result nodes.lkt:3671
--# expr-start 2384 RefId.ref_var Fld_1 nodes.lkt:3671



--# expr-start 2383 DotExpr.suffix Fld nodes.lkt:3671







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Dot_Expr_F_Suffix, Info => Ent.Info);
--# expr-done 2383



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Fld.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2384
Fld_1.Value := No_Entity;
Entity_Vars.Reset (Fld_1);





--# expr-start 2385 DotExpr.first_var_in_prefix_env Fld_2 nodes.lkt:3671







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DotExpr.first_var_in_prefix_env
Fld_2 := Liblktlang.Implementation.Dot_Expr_P_First_Var_In_Prefix_Env (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2385



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_2.Node,
         Info => Fld_2.Info);


Bind_Result := Solver.Create_Assign (Fld_1, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3671:9") else null)); 
--# expr-done 2386




   --# scope-start



--# expr-start 2391 bind Dyn_Var_Bind_Result nodes.lkt:3673





--# expr-start 2387 DotExpr.suffix Fld_3 nodes.lkt:3673







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Self.Dot_Expr_F_Suffix;
--# expr-done 2387



   
      Cast_Result_1 := Fld_3;


Error_Location := Cast_Result_1; 
--# expr-start 2390 LogicPropagate Pred nodes.lkt:3674
--# expr-start 2389 RefId.ref_var Fld_5 nodes.lkt:3674



--# expr-start 2388 DotExpr.suffix Fld_4 nodes.lkt:3674







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Dot_Expr_F_Suffix, Info => Ent.Info);
--# expr-done 2388



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Fld_4.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2389
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);

Pred := Solver.Create_Predicate (Fld_5, Create_Decl_P_Is_Defined_0_Predicate (Error_Location)); 
--# expr-done 2390
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2391
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_726;


And_Pred := Create_And (Bind_Result, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3671:9") else null)); 
--# expr-done 2392

         Property_Result := And_Pred;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_296;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_296;
                     Finalizer_Scope_726;




            raise;
      end;



   return Property_Result;
end Dot_Expr_P_Xtype_Equation;
--# end

   







--# property-start DotExpr.is_call_to_super nodes.lkt:3679
pragma Warnings (Off, "is not referenced");

function Dot_Expr_P_Is_Call_To_Super
  
  (Node : Bare_Dot_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Dot_Expr :=
     Bare_Dot_Expr (Node);
     Ent : Internal_Entity_Dot_Expr :=
       Internal_Entity_Dot_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      
            procedure Finalizer_Scope_727 with Inline_Always;

      Fld : Lexical_Env := Empty_Env;
Sym : Symbol_Type;
Env_Get_Result : Internal_Entity;
Cast_Result : Internal_Entity_Self_Decl;
Local_Self_Decl : Internal_Entity_Self_Decl;
Fld_1 : Lexical_Env := Empty_Env;
Sym_1 : Symbol_Type;
Env_Get_Result_1 : Internal_Entity;
Cast_Result_1 : Internal_Entity_Node_Decl;
Local_Node_Decl : Internal_Entity_Node_Decl;
Is_Null : Boolean;
Is_Null_1 : Boolean;
If_Result : Boolean;
Not_Val : Boolean;
Fld_2 : Bare_Ref_Id;
Var_Expr : Bare_Ref_Id;
Sym_2 : Symbol_Type;
Result_Var : Symbol_Type;
Sym_3 : Symbol_Type;
Is_Equal : Boolean;
Fld_3 : Internal_Entity_Expr;
Cast_Result_2 : Internal_Entity_Ref_Id;
Fld_4 : Internal_Entity_Decl;
Var_Expr_1 : Internal_Entity_Decl;
Cast_Result_3 : Internal_Entity;
Cast_Result_4 : Internal_Entity;
Is_Equiv : Boolean;
Cast_Result_5 : Internal_Entity;
Cast_Result_6 : Internal_Entity;
Is_Equiv_1 : Boolean;
If_Result_1 : Boolean;
Scope_Result : Boolean;
Result_Var_1 : Boolean;
If_Result_2 : Boolean;
If_Result_3 : Boolean;
Let_Result : Boolean;
Let_Result_1 : Boolean;
Scope_Result_1 : Boolean;

            procedure Finalizer_Scope_727 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_727;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 2419 ValDecl Let_Result_1 nodes.lkt:3680
--# scope-start
--# expr-start 2396 Cast Cast_Result nodes.lkt:3680





--# expr-start 2395 .get_first Env_Get_Result nodes.lkt:3680
--# expr-start 2393 LktNode.node_env Fld nodes.lkt:3680







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Node_Env (Node => Self);
--# expr-done 2393
--# expr-start 2394 SymbolLiteral Sym nodes.lkt:3680
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Self); 
--# expr-done 2394


Env_Get_Result := AST_Envs.Get_First (Self => Fld, Key => Thin (Sym), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 2395



   if Env_Get_Result.Node = null
      or else Env_Get_Result.Node.Kind in Lkt_Self_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Self_Decl
        (Node => Env_Get_Result.Node,
         Info => Env_Get_Result.Info);

   else
         Cast_Result := No_Entity_Self_Decl;
   end if;


--# expr-done 2396
Local_Self_Decl := Cast_Result; 
--# bind self_decl Local_Self_Decl
--# expr-start 2418 ValDecl Let_Result nodes.lkt:3681
--# scope-start
--# expr-start 2400 Cast Cast_Result_1 nodes.lkt:3681





--# expr-start 2399 .get_first Env_Get_Result_1 nodes.lkt:3681
--# expr-start 2397 LktNode.node_env Fld_1 nodes.lkt:3681







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Liblktlang.Implementation.Node_Env (Node => Self);
--# expr-done 2397
--# expr-start 2398 SymbolLiteral Sym_1 nodes.lkt:3681
Sym_1 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Node_49); 
--# expr-done 2398


Env_Get_Result_1 := AST_Envs.Get_First (Self => Fld_1, Key => Thin (Sym_1), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 2399



   if Env_Get_Result_1.Node = null
      or else Env_Get_Result_1.Node.Kind in Lkt_Node_Decl_Range
   then
      
      Cast_Result_1 := Create_Internal_Entity_Node_Decl
        (Node => Env_Get_Result_1.Node,
         Info => Env_Get_Result_1.Info);

   else
         Cast_Result_1 := No_Entity_Node_Decl;
   end if;


--# expr-done 2400
Local_Node_Decl := Cast_Result_1; 
--# bind node_decl Local_Node_Decl
--# expr-start 2417 BooleanAnd If_Result_3 nodes.lkt:3683



--# expr-start 2404 Not Not_Val nodes.lkt:3683
--# expr-start 2403 BooleanOr If_Result nodes.lkt:3683



--# expr-start 2401 .is_null Is_Null nodes.lkt:3683

Is_Null := Local_Self_Decl.Node = null; 
--# expr-done 2401
if Is_Null then
   
   If_Result := True;
else
   --# expr-start 2402 .is_null Is_Null_1 nodes.lkt:3683

Is_Null_1 := Local_Node_Decl.Node = null; 
--# expr-done 2402
   If_Result := Is_Null_1;
end if;



--# expr-done 2403
Not_Val := not (If_Result); 
--# expr-done 2404
if Not_Val then
   --# expr-start 2416 BooleanAnd If_Result_2 nodes.lkt:3685



--# expr-start 2408 Eq Is_Equal nodes.lkt:3685



--# expr-start 2405 DotExpr.suffix Fld_2 nodes.lkt:3685







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Self.Dot_Expr_F_Suffix;
--# expr-done 2405
Var_Expr := Fld_2;





if Var_Expr /= No_Bare_Lkt_Node then
   --# expr-start 2406 .symbol Sym_2 nodes.lkt:3685

Sym_2 := Get_Symbol (Var_Expr); 
--# expr-done 2406
   Result_Var := Sym_2;
else
   
   Result_Var := No_Symbol;
end if;



--# expr-start 2407 SymbolLiteral Sym_3 nodes.lkt:3685
Sym_3 := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Super); 
--# expr-done 2407
Is_Equal := Result_Var = Sym_3; 
--# expr-done 2408
if Is_Equal then
   --# expr-start 2415 .do Result_Var_1 nodes.lkt:3686



--# expr-start 2411 RefId.first_var_in_env Fld_4 nodes.lkt:3686



--# expr-start 2410 Cast Cast_Result_2 nodes.lkt:3686





--# expr-start 2409 DotExpr.prefix Fld_3 nodes.lkt:3686







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Expr (Node => Ent.Node.Dot_Expr_F_Prefix, Info => Ent.Info);
--# expr-done 2409



   if Fld_3.Node = null
      or else Fld_3.Node.Kind in Lkt_Ref_Id_Range
   then
      
      Cast_Result_2 := Create_Internal_Entity_Ref_Id
        (Node => Fld_3.Node,
         Info => Fld_3.Info);

   else
         Cast_Result_2 := No_Entity_Ref_Id;
   end if;


--# expr-done 2410



   if Cast_Result_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start RefId.first_var_in_env
Fld_4 := Liblktlang.Implementation.Ref_Id_P_First_Var_In_Env (Node => Cast_Result_2.Node, E_Info => Cast_Result_2.Info);
--# end
--# expr-done 2411
Var_Expr_1 := Fld_4;





if Var_Expr_1 /= No_Entity_Decl then
   



   --# scope-start



--# expr-start 2414 BooleanOr If_Result_1 nodes.lkt:3687



--# expr-start 2412 Eq Is_Equiv nodes.lkt:3687









   
      Cast_Result_3 := Create_Internal_Entity
        (Node => Local_Self_Decl.Node,
         Info => Local_Self_Decl.Info);











   
      Cast_Result_4 := Create_Internal_Entity
        (Node => Var_Expr_1.Node,
         Info => Var_Expr_1.Info);


Is_Equiv := Equivalent (Cast_Result_3, Cast_Result_4); 
--# expr-done 2412
if Is_Equiv then
   
   If_Result_1 := True;
else
   --# expr-start 2413 Eq Is_Equiv_1 nodes.lkt:3687









   
      Cast_Result_5 := Create_Internal_Entity
        (Node => Local_Node_Decl.Node,
         Info => Local_Node_Decl.Info);











   
      Cast_Result_6 := Create_Internal_Entity
        (Node => Var_Expr_1.Node,
         Info => Var_Expr_1.Info);


Is_Equiv_1 := Equivalent (Cast_Result_5, Cast_Result_6); 
--# expr-done 2413
   If_Result_1 := Is_Equiv_1;
end if;



--# expr-done 2414
Scope_Result := If_Result_1;


   --# end


   Result_Var_1 := Scope_Result;
else
   
   Result_Var_1 := False;
end if;



--# expr-done 2415
   If_Result_2 := Result_Var_1;
else
   
   If_Result_2 := False;
end if;



--# expr-done 2416
   If_Result_3 := If_Result_2;
else
   
   If_Result_3 := False;
end if;



--# expr-done 2417
Let_Result := If_Result_3; 
--# end
--# expr-done 2418
Let_Result_1 := Let_Result; 
--# end
--# expr-done 2419
Scope_Result_1 := Let_Result_1;


   --# end
      Finalizer_Scope_727;



         Property_Result := Scope_Result_1;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_727;




            raise;
      end;



   return Property_Result;
end Dot_Expr_P_Is_Call_To_Super;
--# end

   







--# property-start DotExpr.generic_type_equation nodes.lkt:3692
pragma Warnings (Off, "is not referenced");

function Dot_Expr_P_Generic_Type_Equation
  
  (Node : Bare_Dot_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Dot_Expr :=
     Bare_Dot_Expr (Node);
     Ent : Internal_Entity_Dot_Expr :=
       Internal_Entity_Dot_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_298 with Inline_Always;

      Fld : Internal_Entity_Ref_Id;
Fld_1 : Logic_Var;
Fld_2 : Internal_Entity_Decl;
Var_Expr : Internal_Entity_Decl;
Fld_3 : Internal_Entity_Function_Type;
Result_Var : Internal_Entity_Function_Type;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
Fld_4 : Logic_Var;
Fld_5 : Internal_Entity_Ref_Id;
Fld_6 : Logic_Var;
Bind_Result_1 : Logic_Equation;
And_Pred : Logic_Equation;

            procedure Finalizer_Scope_298 is
            begin
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (And_Pred);
            end Finalizer_Scope_298;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2429 LogicAnd And_Pred nodes.lkt:3693
--# expr-start 2424 LogicAssign Bind_Result nodes.lkt:3695
--# expr-start 2421 Expr.generic_func_type_var Fld_1 nodes.lkt:3695



--# expr-start 2420 DotExpr.suffix Fld nodes.lkt:3695







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Dot_Expr_F_Suffix, Info => Ent.Info);
--# expr-done 2420



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Fld.Node.Expr_F_Generic_Func_Type_Var'Unrestricted_Access;
--# expr-done 2421
Fld_1.Value := No_Entity;
Entity_Vars.Reset (Fld_1);








--# expr-start 2422 DotExpr.first_var_in_prefix_env Fld_2 nodes.lkt:3696







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DotExpr.first_var_in_prefix_env
Fld_2 := Liblktlang.Implementation.Dot_Expr_P_First_Var_In_Prefix_Env (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2422
Var_Expr := Fld_2;





if Var_Expr /= No_Entity_Decl then
   --# expr-start 2423 Decl.function_type Fld_3 nodes.lkt:3696







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.function_type
Fld_3 := Liblktlang.Implementation.Decl_P_Function_Type (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 2423
   Result_Var := Fld_3;
else
   
   Result_Var := No_Entity_Function_Type;
end if;






   
      Cast_Result := Create_Internal_Entity
        (Node => Result_Var.Node,
         Info => Result_Var.Info);


Bind_Result := Solver.Create_Assign (Fld_1, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3695:13") else null)); 
--# expr-done 2424
--# expr-start 2428 LogicUnify Bind_Result_1 nodes.lkt:3698
--# expr-start 2425 Expr.generic_func_type_var Fld_4 nodes.lkt:3698







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Ent.Node.Expr_F_Generic_Func_Type_Var'Unrestricted_Access;
--# expr-done 2425
Fld_4.Value := No_Entity;
Entity_Vars.Reset (Fld_4);
--# expr-start 2427 Expr.generic_func_type_var Fld_6 nodes.lkt:3698



--# expr-start 2426 DotExpr.suffix Fld_5 nodes.lkt:3698







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Dot_Expr_F_Suffix, Info => Ent.Info);
--# expr-done 2426



   if Fld_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Fld_5.Node.Expr_F_Generic_Func_Type_Var'Unrestricted_Access;
--# expr-done 2427
Bind_Result_1 := Solver.Create_Unify (Fld_4, Fld_6, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3698:14") else null)); 
--# expr-done 2428
And_Pred := Create_And (Bind_Result, Bind_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3693:9") else null)); 
--# expr-done 2429

         Property_Result := And_Pred;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_298;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_298;




            raise;
      end;



   return Property_Result;
end Dot_Expr_P_Generic_Type_Equation;
--# end

   







--# property-start DotExpr.expected_type_equation nodes.lkt:3700
pragma Warnings (Off, "is not referenced");

function Dot_Expr_P_Expected_Type_Equation
  
  (Node : Bare_Dot_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Dot_Expr :=
     Bare_Dot_Expr (Node);
     Ent : Internal_Entity_Dot_Expr :=
       Internal_Entity_Dot_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_299 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;

            procedure Finalizer_Scope_299 is
            begin
                     Dec_Ref (Bind_Result);
            end Finalizer_Scope_299;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 2432 LogicAssign Bind_Result nodes.lkt:3701
--# expr-start 2431 Expr.expected_type_var Fld_1 nodes.lkt:3701



--# expr-start 2430 DotExpr.prefix Fld nodes.lkt:3701







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Dot_Expr_F_Prefix, Info => Ent.Info);
--# expr-done 2430



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Fld.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2431
Fld_1.Value := No_Entity;
Entity_Vars.Reset (Fld_1);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result := Solver.Create_Assign (Fld_1, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3701:9") else null)); 
--# expr-done 2432

         Property_Result := Bind_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_299;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_299;




            raise;
      end;



   return Property_Result;
end Dot_Expr_P_Expected_Type_Equation;
--# end

   







--# property-start DotExpr.xref_typing_equation nodes.lkt:3704
pragma Warnings (Off, "is not referenced");

function Dot_Expr_P_Xref_Typing_Equation
  
  (Node : Bare_Dot_Expr
      ; In_Logic_Call : Boolean
         := False
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Dot_Expr :=
     Bare_Dot_Expr (Node);
     Ent : Internal_Entity_Dot_Expr :=
       Internal_Entity_Dot_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind in_logic_call In_Logic_Call

   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_300 with Inline_Always;
            procedure Finalizer_Scope_729 with Inline_Always;

      Fld : Internal_Entity_Ref_Id;
Fld_1 : Logic_Var;
Fld_2 : Internal_Entity_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_3 : Bare_Ref_Id;
Fld_4 : Internal_Entity_Ref_Id;
Fld_5 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred : Logic_Equation;
Fld_6 : Internal_Entity_Ref_Id;
Fld_7 : Logic_Var;
Fld_8 : Internal_Entity_Decl;
Var_Expr : Internal_Entity_Decl;
Fld_9 : Internal_Entity_Expr;
Fld_10 : Internal_Entity_Type_Decl;
Fld_11 : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;
Cast_Result_2 : Internal_Entity;
Bind_Result_1 : Logic_Equation;
Fld_12 : Internal_Entity_Ref_Id;
Fld_13 : Boolean;
Fld_14 : Logic_Var;
Fld_15 : Internal_Entity_Ref_Id;
Fld_16 : Internal_Entity_Type_Decl;
Var_Expr_1 : Internal_Entity_Type_Decl;
Fld_17 : Internal_Entity_Type_Decl;
Cast_Result_3 : Internal_Entity_Function_Type;
Fld_18 : Internal_Entity_Function_Type;
Result_Var_1 : Internal_Entity_Function_Type;
Cast_Result_4 : Internal_Entity;
Bind_Result_2 : Logic_Equation;
If_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;
Fld_19 : Logic_Var;
Fld_20 : Internal_Entity_Ref_Id;
Fld_21 : Logic_Var;
Bind_Result_3 : Logic_Equation;
And_Pred_2 : Logic_Equation;
Fld_22 : Internal_Entity_Ref_Id;
Is_Null : Boolean;
Fld_23 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result_5 : Internal_Entity;
Bind_Result_4 : Logic_Equation;
If_Result_1 : Logic_Equation;

            procedure Finalizer_Scope_300 is
            begin
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (Bind_Result_2);
                     Dec_Ref (If_Result);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Bind_Result_3);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Bind_Result_4);
                     Dec_Ref (If_Result_1);
            end Finalizer_Scope_300;
            procedure Finalizer_Scope_729 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_729;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2470 If If_Result_1 nodes.lkt:3705



--# expr-start 2434 .is_null Is_Null nodes.lkt:3705
--# expr-start 2433 DotExpr.suffix Fld_22 nodes.lkt:3705







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_22 := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Dot_Expr_F_Suffix, Info => Ent.Info);
--# expr-done 2433
Is_Null := Fld_22.Node = null; 
--# expr-done 2434
if Is_Null then
   --# expr-start 2436 LogicAssign Bind_Result_4 nodes.lkt:3709
--# expr-start 2435 Expr.actual_type_var Fld_23 nodes.lkt:3709







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_23 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2435
Fld_23.Value := No_Entity;
Entity_Vars.Reset (Fld_23);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result_5 := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result_4 := Solver.Create_Assign (Fld_23, Cast_Result_5, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3709:13") else null)); 
--# expr-done 2436
   If_Result_1 := Bind_Result_4;
else
   --# expr-start 2469 LogicAnd And_Pred_2 nodes.lkt:3713
--# expr-start 2464 LogicAnd And_Pred_1 nodes.lkt:3714
--# expr-start 2446 LogicAnd And_Pred nodes.lkt:3715
--# expr-start 2440 LogicAssign Bind_Result nodes.lkt:3715
--# expr-start 2438 RefId.ref_var Fld_1 nodes.lkt:3715



--# expr-start 2437 DotExpr.suffix Fld nodes.lkt:3715







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Dot_Expr_F_Suffix, Info => Ent.Info);
--# expr-done 2437



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Fld.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2438
Fld_1.Value := No_Entity;
Entity_Vars.Reset (Fld_1);





--# expr-start 2439 DotExpr.first_var_in_prefix_env Fld_2 nodes.lkt:3715







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DotExpr.first_var_in_prefix_env
Fld_2 := Liblktlang.Implementation.Dot_Expr_P_First_Var_In_Prefix_Env (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2439



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_2.Node,
         Info => Fld_2.Info);


Bind_Result := Solver.Create_Assign (Fld_1, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3715:21") else null)); 
--# expr-done 2440




   --# scope-start



--# expr-start 2445 bind Dyn_Var_Bind_Result nodes.lkt:3717





--# expr-start 2441 DotExpr.suffix Fld_3 nodes.lkt:3717







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Self.Dot_Expr_F_Suffix;
--# expr-done 2441



   
      Cast_Result_1 := Fld_3;


Error_Location := Cast_Result_1; 
--# expr-start 2444 LogicPropagate Pred nodes.lkt:3718
--# expr-start 2443 RefId.ref_var Fld_5 nodes.lkt:3718



--# expr-start 2442 DotExpr.suffix Fld_4 nodes.lkt:3718







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Dot_Expr_F_Suffix, Info => Ent.Info);
--# expr-done 2442



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Fld_4.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2443
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);

Pred := Solver.Create_Predicate (Fld_5, Create_Decl_P_Is_Defined_0_Predicate (Error_Location)); 
--# expr-done 2444
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2445
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_729;


And_Pred := Create_And (Bind_Result, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3715:21") else null)); 
--# expr-done 2446
--# expr-start 2463 If If_Result nodes.lkt:3722



--# expr-start 2448 RefId.is_being_called Fld_13 nodes.lkt:3722



--# expr-start 2447 DotExpr.suffix Fld_12 nodes.lkt:3722







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_12 := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Dot_Expr_F_Suffix, Info => Ent.Info);
--# expr-done 2447



   if Fld_12.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start RefId.is_being_called
Fld_13 := Liblktlang.Implementation.Ref_Id_P_Is_Being_Called (Node => Fld_12.Node, E_Info => Fld_12.Info);
--# end
--# expr-done 2448
if Fld_13 then
   --# expr-start 2455 LogicAssign Bind_Result_2 nodes.lkt:3724
--# expr-start 2449 Expr.actual_type_var Fld_14 nodes.lkt:3724







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_14 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2449
Fld_14.Value := No_Entity;
Entity_Vars.Reset (Fld_14);








--# expr-start 2451 Expr.get_generic_type Fld_16 nodes.lkt:3725



--# expr-start 2450 DotExpr.suffix Fld_15 nodes.lkt:3725







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_15 := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Dot_Expr_F_Suffix, Info => Ent.Info);
--# expr-done 2450



   if Fld_15.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_generic_type
Fld_16 := Liblktlang.Implementation.Expr_P_Get_Generic_Type (Node => Fld_15.Node, E_Info => Fld_15.Info);
--# end
--# expr-done 2451
Var_Expr_1 := Fld_16;





if Var_Expr_1 /= No_Entity_Type_Decl then
   --# expr-start 2454 Decl.infer_function_type Fld_18 nodes.lkt:3725







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 2453 Cast Cast_Result_3 nodes.lkt:3726





--# expr-start 2452 Expr.get_expected_type Fld_17 nodes.lkt:3726







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_expected_type
Fld_17 := Liblktlang.Implementation.Expr_P_Get_Expected_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2452



   if Fld_17.Node = null
      or else Fld_17.Node.Kind in Lkt_Function_Type_Range
   then
      
      Cast_Result_3 := Create_Internal_Entity_Function_Type
        (Node => Fld_17.Node,
         Info => Fld_17.Info);

   else
         Cast_Result_3 := No_Entity_Function_Type;
   end if;


--# expr-done 2453
--# property-call-start Decl.infer_function_type
Fld_18 := Liblktlang.Implementation.Decl_P_Infer_Function_Type (Node => Var_Expr_1.Node, Expected_Call => Cast_Result_3, In_Logic_Call => In_Logic_Call, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 2454
   Result_Var_1 := Fld_18;
else
   
   Result_Var_1 := No_Entity_Function_Type;
end if;






   
      Cast_Result_4 := Create_Internal_Entity
        (Node => Result_Var_1.Node,
         Info => Result_Var_1.Info);


Bind_Result_2 := Solver.Create_Assign (Fld_14, Cast_Result_4, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3724:25") else null)); 
--# expr-done 2455
   If_Result := Bind_Result_2;
else
   --# expr-start 2462 LogicAssign Bind_Result_1 nodes.lkt:3732
--# expr-start 2457 Expr.actual_type_var Fld_7 nodes.lkt:3732



--# expr-start 2456 DotExpr.suffix Fld_6 nodes.lkt:3732







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Dot_Expr_F_Suffix, Info => Ent.Info);
--# expr-done 2456



   if Fld_6.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Fld_6.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2457
Fld_7.Value := No_Entity;
Entity_Vars.Reset (Fld_7);








--# expr-start 2458 DotExpr.first_var_in_prefix_env Fld_8 nodes.lkt:3733







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DotExpr.first_var_in_prefix_env
Fld_8 := Liblktlang.Implementation.Dot_Expr_P_First_Var_In_Prefix_Env (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2458
Var_Expr := Fld_8;





if Var_Expr /= No_Entity_Decl then
   --# expr-start 2461 Decl.get_suffix_type Fld_11 nodes.lkt:3733







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 2460 Expr.get_type Fld_10 nodes.lkt:3734



--# expr-start 2459 DotExpr.prefix Fld_9 nodes.lkt:3734







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Create_Internal_Entity_Expr (Node => Ent.Node.Dot_Expr_F_Prefix, Info => Ent.Info);
--# expr-done 2459



   if Fld_9.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.get_type'
Fld_10 := Liblktlang.Implementation.Dispatcher_Expr_P_Get_Type (Node => Fld_9.Node, E_Info => Fld_9.Info);
--# end
--# expr-done 2460
--# property-call-start Decl.get_suffix_type
Fld_11 := Liblktlang.Implementation.Decl_P_Get_Suffix_Type (Node => Var_Expr.Node, Prefix_Type => Fld_10, E_Info => Var_Expr.Info);
--# end
--# expr-done 2461
   Result_Var := Fld_11;
else
   
   Result_Var := No_Entity_Type_Decl;
end if;






   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Result_Var.Node,
         Info => Result_Var.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_7, Cast_Result_2, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3732:25") else null)); 
--# expr-done 2462
   If_Result := Bind_Result_1;
end if;

      Inc_Ref (If_Result);


--# expr-done 2463
And_Pred_1 := Create_And (And_Pred, If_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3714:17") else null)); 
--# expr-done 2464
--# expr-start 2468 LogicUnify Bind_Result_3 nodes.lkt:3741
--# expr-start 2465 Expr.actual_type_var Fld_19 nodes.lkt:3741







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_19 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2465
Fld_19.Value := No_Entity;
Entity_Vars.Reset (Fld_19);
--# expr-start 2467 Expr.actual_type_var Fld_21 nodes.lkt:3741



--# expr-start 2466 DotExpr.suffix Fld_20 nodes.lkt:3741







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_20 := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Dot_Expr_F_Suffix, Info => Ent.Info);
--# expr-done 2466



   if Fld_20.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_21 := Fld_20.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2467
Bind_Result_3 := Solver.Create_Unify (Fld_19, Fld_21, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3741:17") else null)); 
--# expr-done 2468
And_Pred_2 := Create_And (And_Pred_1, Bind_Result_3, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3713:13") else null)); 
--# expr-done 2469
   If_Result_1 := And_Pred_2;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 2470

         Property_Result := If_Result_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_300;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_300;
                     Finalizer_Scope_729;




            raise;
      end;



   return Property_Result;
end Dot_Expr_P_Xref_Typing_Equation;
--# end

   







--# property-start DotExpr.xref_equation nodes.lkt:3745
pragma Warnings (Off, "is not referenced");

function Dot_Expr_P_Xref_Equation
  
  (Node : Bare_Dot_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Dot_Expr :=
     Bare_Dot_Expr (Node);
     Ent : Internal_Entity_Dot_Expr :=
       Internal_Entity_Dot_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_301 with Inline_Always;

      Fld : Logic_Equation;

            procedure Finalizer_Scope_301 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_301;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2471 DotExpr.xref_typing_equation Fld nodes.lkt:3750







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DotExpr.xref_typing_equation
Fld := Liblktlang.Implementation.Dot_Expr_P_Xref_Typing_Equation (Node => Ent.Node, In_Logic_Call => False, E_Info => Ent.Info);
--# end
--# expr-done 2471

         Property_Result := Fld;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_301;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_301;




            raise;
      end;



   return Property_Result;
end Dot_Expr_P_Xref_Equation;
--# end

   







--# property-start DotExpr.xlogic_equation nodes.lkt:3752
pragma Warnings (Off, "is not referenced");

function Dot_Expr_P_Xlogic_Equation
  
  (Node : Bare_Dot_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Dot_Expr :=
     Bare_Dot_Expr (Node);
     Ent : Internal_Entity_Dot_Expr :=
       Internal_Entity_Dot_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_302 with Inline_Always;
            procedure Finalizer_Scope_730 with Inline_Always;

      In_Logic_Call : Boolean;
Fld : Logic_Equation;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;

            procedure Finalizer_Scope_302 is
            begin
                     Dec_Ref (Scope_Result);
            end Finalizer_Scope_302;
            procedure Finalizer_Scope_730 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_730;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 2473 bind Dyn_Var_Bind_Result nodes.lkt:3753

In_Logic_Call := True; 
--# expr-start 2472 DotExpr.xref_typing_equation Fld nodes.lkt:3755







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DotExpr.xref_typing_equation
Fld := Liblktlang.Implementation.Dot_Expr_P_Xref_Typing_Equation (Node => Ent.Node, In_Logic_Call => In_Logic_Call, E_Info => Ent.Info);
--# end
--# expr-done 2472
Dyn_Var_Bind_Result := Fld; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2473
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_730;



         Property_Result := Scope_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_302;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_302;
                     Finalizer_Scope_730;




            raise;
      end;



   return Property_Result;
end Dot_Expr_P_Xlogic_Equation;
--# end

   







--# property-start DotExpr.complete nodes.lkt:3758
pragma Warnings (Off, "is not referenced");

function Dot_Expr_P_Complete
  
  (Node : Bare_Dot_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Complete_Item_Array_Access
is
   Self : Bare_Dot_Expr :=
     Bare_Dot_Expr (Node);
     Ent : Internal_Entity_Dot_Expr :=
       Internal_Entity_Dot_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Complete_Item_Array_Access;

      
            procedure Finalizer_Scope_303 with Inline_Always;
            procedure Finalizer_Scope_731 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Internal_Entity_Type_Decl;
Fld_2 : Internal_Entity_Expr;
Fld_3 : Internal_Entity_Decl;
Left_Var : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity_Decl;
Result_Var : Internal_Entity_Decl;
Local_D : Internal_Entity_Decl;
Origin : Internal_Entity;
Fld_4 : Internal_Entity_Expr;
Fld_5 : Internal_Entity_Type_Decl;
Var_Expr : Internal_Entity_Decl;
Fld_6 : Lexical_Env := Empty_Env;
Env_Get_Result : Internal_Entity_Array_Access;
Result_Var_1 : Internal_Entity_Array_Access;
Local_Items : Internal_Entity_Array_Access;
Cast_Result_1 : Internal_Entity_Decl;
New_Struct : Internal_Complete_Item;
Map_Result : Internal_Complete_Item_Array_Access;
Fld_7 : Internal_Entity_Array_Access;
Is_A : Boolean;
Quantifier_Result : Boolean;
Cast_Result_2 : Internal_Entity_Decl;
New_Struct_1 : Internal_Complete_Item;
Is_A_1 : Boolean;
Map_Result_1 : Internal_Complete_Item_Array_Access;
If_Result : Internal_Complete_Item_Array_Access;
Let_Result : Internal_Complete_Item_Array_Access;
Cast_Result_3 : Internal_Entity;
Dyn_Var_Bind_Result : Internal_Complete_Item_Array_Access;
Let_Result_1 : Internal_Complete_Item_Array_Access;
Scope_Result : Internal_Complete_Item_Array_Access;

            procedure Finalizer_Scope_303 is
            begin
                     Dec_Ref (Scope_Result);
            end Finalizer_Scope_303;
            procedure Finalizer_Scope_731 is
            begin
                     Dec_Ref (Fld_6);
                     Dec_Ref (Env_Get_Result);
                     Dec_Ref (Result_Var_1);
                     Dec_Ref (Local_Items);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Fld_7);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (If_Result);
                     Dec_Ref (Let_Result);
                     Dec_Ref (Dyn_Var_Bind_Result);
                     Dec_Ref (Let_Result_1);
            end Finalizer_Scope_731;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 2496 ValDecl Let_Result_1 nodes.lkt:3759
--# scope-start
--# expr-start 2478 'or?' Result_Var nodes.lkt:3759



--# expr-start 2475 Expr.get_type Fld_1 nodes.lkt:3759



--# expr-start 2474 DotExpr.prefix Fld nodes.lkt:3759







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Dot_Expr_F_Prefix, Info => Ent.Info);
--# expr-done 2474



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.get_type'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Get_Type (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2475
Left_Var := Fld_1;





if Left_Var /= No_Entity_Type_Decl then
   








   
      Cast_Result := Create_Internal_Entity_Decl
        (Node => Left_Var.Node,
         Info => Left_Var.Info);


   Result_Var := Cast_Result;
else
   --# expr-start 2477 Expr.referenced_decl Fld_3 nodes.lkt:3759



--# expr-start 2476 DotExpr.prefix Fld_2 nodes.lkt:3759







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Ent.Node.Dot_Expr_F_Prefix, Info => Ent.Info);
--# expr-done 2476



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.referenced_decl'
Fld_3 := Liblktlang.Implementation.Dispatcher_Expr_P_Referenced_Decl (Node => Fld_2.Node, E_Info => Fld_2.Info);
--# end
--# expr-done 2477
   Result_Var := Fld_3;
end if;



--# expr-done 2478
Local_D := Result_Var; 
--# bind d Local_D
--# expr-start 2495 bind Dyn_Var_Bind_Result nodes.lkt:3760





--# expr-start 2480 Expr.get_type Fld_5 nodes.lkt:3760



--# expr-start 2479 DotExpr.prefix Fld_4 nodes.lkt:3760







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Expr (Node => Ent.Node.Dot_Expr_F_Prefix, Info => Ent.Info);
--# expr-done 2479



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.get_type'
Fld_5 := Liblktlang.Implementation.Dispatcher_Expr_P_Get_Type (Node => Fld_4.Node, E_Info => Fld_4.Info);
--# end
--# expr-done 2480



   
      Cast_Result_3 := Create_Internal_Entity
        (Node => Fld_5.Node,
         Info => Fld_5.Info);


Origin := Cast_Result_3; 
--# expr-start 2494 ValDecl Let_Result nodes.lkt:3761
--# scope-start




Var_Expr := Local_D;





if Var_Expr /= No_Entity_Decl then
   --# expr-start 2482 .get Env_Get_Result nodes.lkt:3761
--# expr-start 2481 Decl.defined_scope Fld_6 nodes.lkt:3761







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_6 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Var_Expr.Node, Origin => Origin, E_Info => Var_Expr.Info);
--# end
--# expr-done 2481



Env_Get_Result := Construct_Entity_Array (AST_Envs.Get (Self => Fld_6, Key => Thin (No_Symbol), Lookup_Kind => To_Lookup_Kind_Type (Flat), Categories => (Nocat => True))); 
--# expr-done 2482
   Result_Var_1 := Env_Get_Result;
else
   
   Result_Var_1 := No_Internal_Entity_Array_Type;
end if;

      Inc_Ref (Result_Var_1);


Local_Items := Result_Var_1; Inc_Ref (Local_Items);
--# bind items Local_Items
--# expr-start 2493 If If_Result nodes.lkt:3764



--# expr-start 2485 .any Quantifier_Result nodes.lkt:3764








   

   --# expr-start 2483 LktNode.parents Fld_7 nodes.lkt:3764







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



Fld_7 := Liblktlang.Implementation.Parents (Node => Ent.Node, With_Self => True, E_Info => Ent.Info);
--# expr-done 2483

   
      Quantifier_Result := False;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Fld_7;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind p Item_1

            
      --# expr-start 2484 IsA Is_A nodes.lkt:3764

Is_A := Item_1.Node /= null 
and then Item_1.Node.Kind in Lkt_Type_Ref; 
--# expr-done 2484
      Quantifier_Result := Is_A;
   

            
   --# end


               exit when Quantifier_Result;

         end loop;
      end;
   

   
   



--# expr-done 2485
if Quantifier_Result then
   --# expr-start 2489 .filtermap Map_Result_1 nodes.lkt:3765








   

   

   
      declare
         Map_Result_1_Vec : Internal_Complete_Item_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Local_Items;
      begin
         for Item_2 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind d Item_2

            
         --# expr-start 2486 IsA Is_A_1 nodes.lkt:3767

Is_A_1 := Item_2.Node /= null 
and then Item_2.Node.Kind in Lkt_Type_Decl; 
--# expr-done 2486
         if Is_A_1 then
            
         
      --# expr-start 2488 'New[CompleteItem]' New_Struct_1 nodes.lkt:3766
--# expr-start 2487 Cast Cast_Result_2 nodes.lkt:3766









   if Item_2.Node = null
      or else Item_2.Node.Kind in Lkt_Decl
   then
      
      Cast_Result_2 := Create_Internal_Entity_Decl
        (Node => Item_2.Node,
         Info => Item_2.Info);

   else
         Cast_Result_2 := No_Entity_Decl;
   end if;


--# expr-done 2487
New_Struct_1 := (Declaration => Cast_Result_2); 
--# expr-done 2488
      

         declare
            Item_To_Append : constant Internal_Complete_Item := New_Struct_1;
         begin
            Internal_Complete_Item_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
         end if;
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result_1 := Create_Internal_Complete_Item_Array
           (Items_Count => Natural (Internal_Complete_Item_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Internal_Complete_Item_Vectors.Get
              (Map_Result_1_Vec,
               I + Internal_Complete_Item_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Internal_Complete_Item_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 2489
   If_Result := Map_Result_1;
else
   --# expr-start 2492 .map Map_Result nodes.lkt:3769








   

   

   
      declare
         Map_Result_Vec : Internal_Complete_Item_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Local_Items;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind d Item

            
         
         
      --# expr-start 2491 'New[CompleteItem]' New_Struct nodes.lkt:3769
--# expr-start 2490 Cast Cast_Result_1 nodes.lkt:3769









   if Item.Node = null
      or else Item.Node.Kind in Lkt_Decl
   then
      
      Cast_Result_1 := Create_Internal_Entity_Decl
        (Node => Item.Node,
         Info => Item.Info);

   else
         Cast_Result_1 := No_Entity_Decl;
   end if;


--# expr-done 2490
New_Struct := (Declaration => Cast_Result_1); 
--# expr-done 2491
      

         declare
            Item_To_Append : constant Internal_Complete_Item := New_Struct;
         begin
            Internal_Complete_Item_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Complete_Item_Array
           (Items_Count => Natural (Internal_Complete_Item_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Complete_Item_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Complete_Item_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Complete_Item_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 2492
   If_Result := Map_Result;
end if;

      Inc_Ref (If_Result);


--# expr-done 2493
Let_Result := If_Result; Inc_Ref (Let_Result);
--# end
--# expr-done 2494
Dyn_Var_Bind_Result := Let_Result; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2495
Let_Result_1 := Dyn_Var_Bind_Result; Inc_Ref (Let_Result_1);
--# end
--# expr-done 2496
Scope_Result := Let_Result_1;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_731;



         Property_Result := Scope_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_303;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_303;
                     Finalizer_Scope_731;




            raise;
      end;



   return Property_Result;
end Dot_Expr_P_Complete;
--# end



   


      

   --
   --  Primitives for Bare_Error_On_Null
   --

   



      
      procedure Initialize_Fields_For_Error_On_Null
        (Self : Bare_Error_On_Null
         ; Error_On_Null_F_Expr : Bare_Expr
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Error_On_Null_F_Expr := Error_On_Null_F_Expr;
         

      end Initialize_Fields_For_Error_On_Null;

      
   function Error_On_Null_F_Expr
     (Node : Bare_Error_On_Null) return Bare_Expr
   is
      

   begin
         
         return Node.Error_On_Null_F_Expr;
      
   end;


   







--# property-start ErrorOnNull.xref_equation nodes.lkt:3943
pragma Warnings (Off, "is not referenced");

function Error_On_Null_P_Xref_Equation
  
  (Node : Bare_Error_On_Null
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Error_On_Null :=
     Bare_Error_On_Null (Node);
     Ent : Internal_Entity_Error_On_Null :=
       Internal_Entity_Error_On_Null'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_311 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Logic_Var;
Fld_3 : Internal_Entity_Expr;
Fld_4 : Logic_Var;
Bind_Result : Logic_Equation;
And_Pred : Logic_Equation;
Fld_5 : Internal_Entity_Expr;
Fld_6 : Logic_Var;
Fld_7 : Logic_Var;
Bind_Result_1 : Logic_Equation;
Fld_8 : Boolean;
Fld_9 : Internal_Entity_Expr;
Fld_10 : Logic_Var;
Fld_11 : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result_2 : Logic_Equation;
If_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;

            procedure Finalizer_Scope_311 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (Bind_Result_2);
                     Dec_Ref (If_Result);
                     Dec_Ref (And_Pred_1);
            end Finalizer_Scope_311;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2514 LogicAnd And_Pred_1 nodes.lkt:3944
--# expr-start 2503 LogicAnd And_Pred nodes.lkt:3945
--# expr-start 2498 LktNode.xref_equation Fld_1 nodes.lkt:3945



--# expr-start 2497 ErrorOnNull.expr Fld nodes.lkt:3945







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Error_On_Null_F_Expr, Info => Ent.Info);
--# expr-done 2497



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2498
--# expr-start 2502 LogicUnify Bind_Result nodes.lkt:3946
--# expr-start 2499 Expr.actual_type_var Fld_2 nodes.lkt:3946







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2499
Fld_2.Value := No_Entity;
Entity_Vars.Reset (Fld_2);
--# expr-start 2501 Expr.actual_type_var Fld_4 nodes.lkt:3946



--# expr-start 2500 ErrorOnNull.expr Fld_3 nodes.lkt:3946







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Expr (Node => Ent.Node.Error_On_Null_F_Expr, Info => Ent.Info);
--# expr-done 2500



   if Fld_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Fld_3.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2501
Bind_Result := Solver.Create_Unify (Fld_2, Fld_4, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3946:18") else null)); 
--# expr-done 2502
And_Pred := Create_And (Fld_1, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3945:13") else null)); 
--# expr-done 2503
--# expr-start 2513 If If_Result nodes.lkt:3949



--# expr-start 2504 Expr.xref_entry_point Fld_8 nodes.lkt:3949







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_entry_point'
Fld_8 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Entry_Point (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2504
if Fld_8 then
   --# expr-start 2508 LogicAssign Bind_Result_2 nodes.lkt:3950
--# expr-start 2506 Expr.expected_type_var Fld_10 nodes.lkt:3950



--# expr-start 2505 ErrorOnNull.expr Fld_9 nodes.lkt:3950







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Create_Internal_Entity_Expr (Node => Ent.Node.Error_On_Null_F_Expr, Info => Ent.Info);
--# expr-done 2505



   if Fld_9.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Fld_9.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2506
Fld_10.Value := No_Entity;
Entity_Vars.Reset (Fld_10);





--# expr-start 2507 Expr.get_expected_type Fld_11 nodes.lkt:3950







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_expected_type
Fld_11 := Liblktlang.Implementation.Expr_P_Get_Expected_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2507



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_11.Node,
         Info => Fld_11.Info);


Bind_Result_2 := Solver.Create_Assign (Fld_10, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3950:18") else null)); 
--# expr-done 2508
   If_Result := Bind_Result_2;
else
   --# expr-start 2512 LogicUnify Bind_Result_1 nodes.lkt:3951
--# expr-start 2510 Expr.expected_type_var Fld_6 nodes.lkt:3951



--# expr-start 2509 ErrorOnNull.expr Fld_5 nodes.lkt:3951







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Expr (Node => Ent.Node.Error_On_Null_F_Expr, Info => Ent.Info);
--# expr-done 2509



   if Fld_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Fld_5.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2510
Fld_6.Value := No_Entity;
Entity_Vars.Reset (Fld_6);
--# expr-start 2511 Expr.expected_type_var Fld_7 nodes.lkt:3951







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Ent.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2511
Bind_Result_1 := Solver.Create_Unify (Fld_6, Fld_7, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3951:18") else null)); 
--# expr-done 2512
   If_Result := Bind_Result_1;
end if;

      Inc_Ref (If_Result);


--# expr-done 2513
And_Pred_1 := Create_And (And_Pred, If_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3944:9") else null)); 
--# expr-done 2514

         Property_Result := And_Pred_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_311;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_311;




            raise;
      end;



   return Property_Result;
end Error_On_Null_P_Xref_Equation;
--# end

   







--# property-start ErrorOnNull.has_context_free_type nodes.lkt:3954
pragma Warnings (Off, "is not referenced");

function Error_On_Null_P_Has_Context_Free_Type
  
  (Node : Bare_Error_On_Null
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Error_On_Null :=
     Bare_Error_On_Null (Node);
     Ent : Internal_Entity_Error_On_Null :=
       Internal_Entity_Error_On_Null'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Fld : Internal_Entity_Expr;
Fld_1 : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 2516 Expr.has_context_free_type Fld_1 nodes.lkt:3954



--# expr-start 2515 ErrorOnNull.expr Fld nodes.lkt:3954







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Error_On_Null_F_Expr, Info => Ent.Info);
--# expr-done 2515



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2516

         Property_Result := Fld_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Error_On_Null_P_Has_Context_Free_Type;
--# end



   


      

   --
   --  Primitives for Bare_Generic_Instantiation
   --

   



      
      procedure Initialize_Fields_For_Generic_Instantiation
        (Self : Bare_Generic_Instantiation
         ; Generic_Instantiation_F_Name : Bare_Expr
         ; Generic_Instantiation_F_Args : Bare_Type_Ref_List
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Generic_Instantiation_F_Name := Generic_Instantiation_F_Name;
            Self.Generic_Instantiation_F_Args := Generic_Instantiation_F_Args;
         
      Self.Generic_Instantiation_F_Rebinded_Var := Null_Var_Record;

      end Initialize_Fields_For_Generic_Instantiation;

      
   function Generic_Instantiation_F_Name
     (Node : Bare_Generic_Instantiation) return Bare_Expr
   is
      

   begin
         
         return Node.Generic_Instantiation_F_Name;
      
   end;

      
   function Generic_Instantiation_F_Args
     (Node : Bare_Generic_Instantiation) return Bare_Type_Ref_List
   is
      

   begin
         
         return Node.Generic_Instantiation_F_Args;
      
   end;


   







--# property-start GenericInstantiation.xref_equation nodes.lkt:3965
pragma Warnings (Off, "is not referenced");

function Generic_Instantiation_P_Xref_Equation
  
  (Node : Bare_Generic_Instantiation
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Generic_Instantiation :=
     Bare_Generic_Instantiation (Node);
     Ent : Internal_Entity_Generic_Instantiation :=
       Internal_Entity_Generic_Instantiation'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_313 with Inline_Always;
            procedure Finalizer_Scope_744 with Inline_Always;
            procedure Finalizer_Scope_745 with Inline_Always;
            procedure Finalizer_Scope_747 with Inline_Always;
            procedure Finalizer_Scope_748 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Internal_Entity_Type_Ref_List;
Item : Internal_Entity_Type_Ref;
Fld_3 : Logic_Equation;
Fld_4 : Bare_Type_Ref_List;
Fld_5 : Internal_Entity_Info;
Bare_Item : Bare_Type_Ref;
As_Entity : Internal_Entity_Type_Ref;
Is_Null : Boolean;
If_Result : Internal_Entity_Type_Ref;
Map_Result : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;
And_Pred : Logic_Equation;
Fld_6 : Internal_Entity_Expr;
Fld_7 : Internal_Entity_Ref_Id;
Var_Expr : Internal_Entity_Ref_Id;
Fld_8 : Logic_Var;
Fld_9 : Logic_Var;
Array_Lit : Logic_Var_Array_Access;
Fld_10 : Internal_Entity_Type_Ref_List;
Item_1 : Internal_Entity_Type_Ref;
Fld_11 : Logic_Var;
Fld_12 : Bare_Type_Ref_List;
Fld_13 : Internal_Entity_Info;
Bare_Item_1 : Bare_Type_Ref;
As_Entity_1 : Internal_Entity_Type_Ref;
Is_Null_1 : Boolean;
If_Result_1 : Internal_Entity_Type_Ref;
Map_Result_1 : Logic_Var_Array_Access;
Concat_Result : Logic_Var_Array_Access;
Logic_Vars : Logic_Var_Array_Access;
Bind_Result : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_14 : Bare_Ref_Id;
Fld_15 : Logic_Var;
Pred : Logic_Equation;
Cast_Result : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;
Error_Location_1 : Bare_Lkt_Node;
Fld_16 : Bare_Type_Ref_List;
Fld_17 : Logic_Var;
Fld_18 : Internal_Entity_Type_Ref_List;
Fld_19 : Bare_Type_Ref_List;
Len : Integer;
Pred_1 : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_1 : Logic_Equation;
Scope_Result_1 : Logic_Equation;
And_Pred_2 : Logic_Equation;
Scope_Result_2 : Logic_Equation;
Fld_20 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result_2 : Internal_Entity;
Bind_Result_1 : Logic_Equation;
Result_Var : Logic_Equation;
And_Pred_3 : Logic_Equation;
Fld_21 : Logic_Var;
Fld_22 : Logic_Var;
Bind_Result_2 : Logic_Equation;
And_Pred_4 : Logic_Equation;

            procedure Finalizer_Scope_313 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Logic_Boolean_Op);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Scope_Result_2);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (Result_Var);
                     Dec_Ref (And_Pred_3);
                     Dec_Ref (Bind_Result_2);
                     Dec_Ref (And_Pred_4);
            end Finalizer_Scope_313;
            procedure Finalizer_Scope_744 is
            begin
                     Dec_Ref (Fld_3);
            end Finalizer_Scope_744;
            procedure Finalizer_Scope_745 is
            begin
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (Concat_Result);
                     Dec_Ref (Logic_Vars);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (And_Pred_2);
            end Finalizer_Scope_745;
            procedure Finalizer_Scope_747 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_747;
            procedure Finalizer_Scope_748 is
            begin
                     Dec_Ref (Pred_1);
                     Dec_Ref (Dyn_Var_Bind_Result_1);
            end Finalizer_Scope_748;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2551 LogicAnd And_Pred_4 nodes.lkt:3966
--# expr-start 2547 LogicAnd And_Pred_3 nodes.lkt:3969
--# expr-start 2522 LogicAnd And_Pred nodes.lkt:3970
--# expr-start 2518 LktNode.xref_equation Fld_1 nodes.lkt:3970



--# expr-start 2517 GenericInstantiation.name Fld nodes.lkt:3970







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Generic_Instantiation_F_Name, Info => Ent.Info);
--# expr-done 2517



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2518
--# expr-start 2521 .logic_all Logic_Boolean_Op nodes.lkt:3976








   

   --# expr-start 2519 GenericInstantiation.args Fld_2 nodes.lkt:3976







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Type_Ref_List (Node => Ent.Node.Generic_Instantiation_F_Args, Info => Ent.Info);
--# expr-done 2519









Fld_4 := Fld_2.Node;

   
      declare
         Map_Result_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      if Fld_4 = null then
         
      Map_Result := Create_Logic_Equation_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Type_Ref_List := Fld_4;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Type_Ref;
else
   








Fld_5 := Fld_2.Info;

As_Entity := (Info => Fld_5, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind a Item

            
         
         
      --# expr-start 2520 LktNode.xref_equation Fld_3 nodes.lkt:3976







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_3 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 2520
      

         declare
            Item_To_Append : constant Logic_Equation := Fld_3;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_744;



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3976:31") else null)); 
--# expr-done 2521
And_Pred := Create_And (Fld_1, Logic_Boolean_Op, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3970:17") else null)); 
--# expr-done 2522
--# expr-start 2546 .do Result_Var nodes.lkt:3979



--# expr-start 2524 Expr.get_rightmost_refid Fld_7 nodes.lkt:3979



--# expr-start 2523 GenericInstantiation.name Fld_6 nodes.lkt:3979







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Expr (Node => Ent.Node.Generic_Instantiation_F_Name, Info => Ent.Info);
--# expr-done 2523



   if Fld_6.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_rightmost_refid
Fld_7 := Liblktlang.Implementation.Expr_P_Get_Rightmost_Refid (Node => Fld_6.Node, E_Info => Fld_6.Info);
--# end
--# expr-done 2524
Var_Expr := Fld_7;





if Var_Expr /= No_Entity_Ref_Id then
   



   --# scope-start



--# expr-start 2543 LogicAnd And_Pred_2 nodes.lkt:3981
--# expr-start 2536 LogicAnd And_Pred_1 nodes.lkt:3982
--# expr-start 2530 ArrayConcat Concat_Result nodes.lkt:3984
--# expr-start 2526 ArrayLiteral Array_Lit nodes.lkt:3984
--# expr-start 2525 RefId.ref_var Fld_9 nodes.lkt:3984







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Var_Expr.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2525
Array_Lit := Create_Logic_Var_Array (Internal_Logic_Var_Array'(1 => Fld_9)); 
--# expr-done 2526
--# expr-start 2529 .map Map_Result_1 nodes.lkt:3984








   

   --# expr-start 2527 GenericInstantiation.args Fld_10 nodes.lkt:3984







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Create_Internal_Entity_Type_Ref_List (Node => Ent.Node.Generic_Instantiation_F_Args, Info => Ent.Info);
--# expr-done 2527









Fld_12 := Fld_10.Node;

   
      declare
         Map_Result_1_Vec : Logic_Var_Vectors.Vector;
      begin
   

   

      if Fld_12 = null then
         
      Map_Result_1 := Create_Logic_Var_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Type_Ref_List := Fld_12;
      begin
         for Untyped_Item_1 of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item_1 := Untyped_Item_1; 
                  



Is_Null_1 := Bare_Item_1 = null; 
if Is_Null_1 then
   
   If_Result_1 := No_Entity_Type_Ref;
else
   








Fld_13 := Fld_10.Info;

As_Entity_1 := (Info => Fld_13, Node => Bare_Item_1); 
   If_Result_1 := As_Entity_1;
end if;



                  Item_1 := If_Result_1; 

            
   --# scope-start


               --# bind a Item_1

            
         
         
      --# expr-start 2528 TypeRef.type_var Fld_11 nodes.lkt:3984







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Item_1.Node.Type_Ref_F_Type_Var'Unrestricted_Access;
--# expr-done 2528
      

         declare
            Item_To_Append : constant Logic_Var := Fld_11;
         begin
            Logic_Var_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result_1 := Create_Logic_Var_Array
           (Items_Count => Natural (Logic_Var_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Logic_Var_Vectors.Get
              (Map_Result_1_Vec,
               I + Logic_Var_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Logic_Var_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 2529
Concat_Result := Concat (Array_Lit, Map_Result_1); 
--# expr-done 2530
for Var of Concat_Result.Items loop
   Var.Value := No_Entity;
   Entity_Vars.Reset (Var);
end loop;
Logic_Vars := Concat_Result; Inc_Ref (Logic_Vars);
--# expr-start 2531 GenericInstantiation.rebinded_var Fld_8 nodes.lkt:3982







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Ent.Node.Generic_Instantiation_F_Rebinded_Var'Unrestricted_Access;
--# expr-done 2531
Fld_8.Value := No_Entity;
Entity_Vars.Reset (Fld_8);


Bind_Result := Solver.Create_N_Propagate (Fld_8, Create_Decl_P_Instantiate_Generic_Decl_0_Functor (Logic_Vars.N), Entity_Vars.Logic_Var_Array (Logic_Vars.Items)); 




   --# scope-start



--# expr-start 2535 bind Dyn_Var_Bind_Result nodes.lkt:3987





--# expr-start 2532 'Entity[RefId].node' Fld_14 nodes.lkt:3987









Fld_14 := Var_Expr.Node;
--# expr-done 2532



   
      Cast_Result := Fld_14;


Error_Location := Cast_Result; 
--# expr-start 2534 LogicPropagate Pred nodes.lkt:3988
--# expr-start 2533 RefId.ref_var Fld_15 nodes.lkt:3988







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_15 := Var_Expr.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2533
Fld_15.Value := No_Entity;
Entity_Vars.Reset (Fld_15);

Pred := Solver.Create_Predicate (Fld_15, Create_Decl_P_Is_Generic_0_Predicate (Error_Location)); 
--# expr-done 2534
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2535
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_747;


And_Pred_1 := Create_And (Bind_Result, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3982:21") else null)); 
--# expr-done 2536




   --# scope-start



--# expr-start 2542 bind Dyn_Var_Bind_Result_1 nodes.lkt:3992





--# expr-start 2537 GenericInstantiation.args Fld_16 nodes.lkt:3992







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_16 := Self.Generic_Instantiation_F_Args;
--# expr-done 2537



   
      Cast_Result_1 := Fld_16;


Error_Location_1 := Cast_Result_1; 
--# expr-start 2541 LogicPropagate Pred_1 nodes.lkt:3993
--# expr-start 2538 RefId.ref_var Fld_17 nodes.lkt:3994







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_17 := Var_Expr.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2538
Fld_17.Value := No_Entity;
Entity_Vars.Reset (Fld_17);
--# expr-start 2540 .length Len nodes.lkt:3995



--# expr-start 2539 GenericInstantiation.args Fld_18 nodes.lkt:3995







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_18 := Create_Internal_Entity_Type_Ref_List (Node => Ent.Node.Generic_Instantiation_F_Args, Info => Ent.Info);
--# expr-done 2539





Fld_19 := Fld_18.Node; 
Len := Length (Fld_19); 
--# expr-done 2540

Pred_1 := Solver.Create_Predicate (Fld_17, Create_Decl_P_Has_Correct_Type_Arg_Number_0_Predicate (Len, Error_Location_1)); 
--# expr-done 2541
Dyn_Var_Bind_Result_1 := Pred_1; Inc_Ref (Dyn_Var_Bind_Result_1);
--# expr-done 2542
Scope_Result_1 := Dyn_Var_Bind_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_748;


And_Pred_2 := Create_And (And_Pred_1, Scope_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3981:17") else null)); 
--# expr-done 2543
Scope_Result_2 := And_Pred_2;
   Inc_Ref (Scope_Result_2);


   --# end
      Finalizer_Scope_745;


   Result_Var := Scope_Result_2;
else
   --# expr-start 2545 LogicAssign Bind_Result_1 nodes.lkt:3998
--# expr-start 2544 GenericInstantiation.rebinded_var Fld_20 nodes.lkt:3998







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_20 := Ent.Node.Generic_Instantiation_F_Rebinded_Var'Unrestricted_Access;
--# expr-done 2544
Fld_20.Value := No_Entity;
Entity_Vars.Reset (Fld_20);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_20, Cast_Result_2, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3998:29") else null)); 
--# expr-done 2545
   Result_Var := Bind_Result_1;
end if;

      Inc_Ref (Result_Var);


--# expr-done 2546
And_Pred_3 := Create_And (And_Pred, Result_Var, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3969:13") else null)); 
--# expr-done 2547
--# expr-start 2550 LogicPropagate Bind_Result_2 nodes.lkt:4001
--# expr-start 2548 GenericInstantiation.rebinded_var Fld_22 nodes.lkt:4001







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_22 := Ent.Node.Generic_Instantiation_F_Rebinded_Var'Unrestricted_Access;
--# expr-done 2548
Fld_22.Value := No_Entity;
Entity_Vars.Reset (Fld_22);
--# expr-start 2549 Expr.actual_type_var Fld_21 nodes.lkt:4001







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_21 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2549
Fld_21.Value := No_Entity;
Entity_Vars.Reset (Fld_21);

Bind_Result_2 := Solver.Create_Propagate (Fld_22, Fld_21, Create_Decl_P_Function_Type_0_Functor); 
--# expr-done 2550
And_Pred_4 := Create_And (And_Pred_3, Bind_Result_2, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:3966:9") else null)); 
--# expr-done 2551

         Property_Result := And_Pred_4;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_313;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_313;
                     Finalizer_Scope_744;
                     Finalizer_Scope_745;
                     Finalizer_Scope_747;
                     Finalizer_Scope_748;




            raise;
      end;



   return Property_Result;
end Generic_Instantiation_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Grammar_Expr
   --

   



      
      procedure Initialize_Fields_For_Grammar_Expr
        (Self : Bare_Grammar_Expr
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

         

      end Initialize_Fields_For_Grammar_Expr;




   


      

   --
   --  Primitives for Bare_Error_Grammar_Expr
   --

   



      
      procedure Initialize_Fields_For_Error_Grammar_Expr
        (Self : Bare_Error_Grammar_Expr
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

         

      end Initialize_Fields_For_Error_Grammar_Expr;




   


      

   --
   --  Primitives for Bare_Grammar_Cut
   --

   



      
      procedure Initialize_Fields_For_Grammar_Cut
        (Self : Bare_Grammar_Cut
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

         

      end Initialize_Fields_For_Grammar_Cut;




   


      

   --
   --  Primitives for Bare_Grammar_Discard
   --

   



      
      procedure Initialize_Fields_For_Grammar_Discard
        (Self : Bare_Grammar_Discard
         ; Grammar_Discard_F_Expr : Bare_Grammar_Expr
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

            Self.Grammar_Discard_F_Expr := Grammar_Discard_F_Expr;
         

      end Initialize_Fields_For_Grammar_Discard;

      
   function Grammar_Discard_F_Expr
     (Node : Bare_Grammar_Discard) return Bare_Grammar_Expr
   is
      

   begin
         
         return Node.Grammar_Discard_F_Expr;
      
   end;




   


      

   --
   --  Primitives for Bare_Grammar_Dont_Skip
   --

   



      
      procedure Initialize_Fields_For_Grammar_Dont_Skip
        (Self : Bare_Grammar_Dont_Skip
         ; Grammar_Dont_Skip_F_Expr : Bare_Grammar_Expr
         ; Grammar_Dont_Skip_F_Dont_Skip : Bare_Grammar_Expr
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

            Self.Grammar_Dont_Skip_F_Expr := Grammar_Dont_Skip_F_Expr;
            Self.Grammar_Dont_Skip_F_Dont_Skip := Grammar_Dont_Skip_F_Dont_Skip;
         

      end Initialize_Fields_For_Grammar_Dont_Skip;

      
   function Grammar_Dont_Skip_F_Expr
     (Node : Bare_Grammar_Dont_Skip) return Bare_Grammar_Expr
   is
      

   begin
         
         return Node.Grammar_Dont_Skip_F_Expr;
      
   end;

      
   function Grammar_Dont_Skip_F_Dont_Skip
     (Node : Bare_Grammar_Dont_Skip) return Bare_Grammar_Expr
   is
      

   begin
         
         return Node.Grammar_Dont_Skip_F_Dont_Skip;
      
   end;




   


      

   --
   --  Primitives for Bare_Grammar_List
   --

   



      
      procedure Initialize_Fields_For_Grammar_List
        (Self : Bare_Grammar_List
         ; Grammar_List_F_List_Type : Bare_Type_Ref
         ; Grammar_List_F_Kind : Bare_List_Kind
         ; Grammar_List_F_Expr : Bare_Grammar_Expr
         ; Grammar_List_F_Sep : Bare_Grammar_List_Sep
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

            Self.Grammar_List_F_List_Type := Grammar_List_F_List_Type;
            Self.Grammar_List_F_Kind := Grammar_List_F_Kind;
            Self.Grammar_List_F_Expr := Grammar_List_F_Expr;
            Self.Grammar_List_F_Sep := Grammar_List_F_Sep;
         

      end Initialize_Fields_For_Grammar_List;

      
   function Grammar_List_F_List_Type
     (Node : Bare_Grammar_List) return Bare_Type_Ref
   is
      

   begin
         
         return Node.Grammar_List_F_List_Type;
      
   end;

      
   function Grammar_List_F_Kind
     (Node : Bare_Grammar_List) return Bare_List_Kind
   is
      

   begin
         
         return Node.Grammar_List_F_Kind;
      
   end;

      
   function Grammar_List_F_Expr
     (Node : Bare_Grammar_List) return Bare_Grammar_Expr
   is
      

   begin
         
         return Node.Grammar_List_F_Expr;
      
   end;

      
   function Grammar_List_F_Sep
     (Node : Bare_Grammar_List) return Bare_Grammar_List_Sep
   is
      

   begin
         
         return Node.Grammar_List_F_Sep;
      
   end;




   


      

   --
   --  Primitives for Bare_Grammar_Null
   --

   



      
      procedure Initialize_Fields_For_Grammar_Null
        (Self : Bare_Grammar_Null
         ; Grammar_Null_F_Name : Bare_Type_Ref
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

            Self.Grammar_Null_F_Name := Grammar_Null_F_Name;
         

      end Initialize_Fields_For_Grammar_Null;

      
   function Grammar_Null_F_Name
     (Node : Bare_Grammar_Null) return Bare_Type_Ref
   is
      

   begin
         
         return Node.Grammar_Null_F_Name;
      
   end;




   


      

   --
   --  Primitives for Bare_Grammar_Opt
   --

   



      
      procedure Initialize_Fields_For_Grammar_Opt
        (Self : Bare_Grammar_Opt
         ; Grammar_Opt_F_Expr : Bare_Grammar_Expr
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

            Self.Grammar_Opt_F_Expr := Grammar_Opt_F_Expr;
         

      end Initialize_Fields_For_Grammar_Opt;

      
   function Grammar_Opt_F_Expr
     (Node : Bare_Grammar_Opt) return Bare_Grammar_Expr
   is
      

   begin
         
         return Node.Grammar_Opt_F_Expr;
      
   end;




   


      

   --
   --  Primitives for Bare_Grammar_Opt_Error
   --

   



      
      procedure Initialize_Fields_For_Grammar_Opt_Error
        (Self : Bare_Grammar_Opt_Error
         ; Grammar_Opt_Error_F_Expr : Bare_Grammar_Expr
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

            Self.Grammar_Opt_Error_F_Expr := Grammar_Opt_Error_F_Expr;
         

      end Initialize_Fields_For_Grammar_Opt_Error;

      
   function Grammar_Opt_Error_F_Expr
     (Node : Bare_Grammar_Opt_Error) return Bare_Grammar_Expr
   is
      

   begin
         
         return Node.Grammar_Opt_Error_F_Expr;
      
   end;




   


      

   --
   --  Primitives for Bare_Grammar_Opt_Error_Group
   --

   



      
      procedure Initialize_Fields_For_Grammar_Opt_Error_Group
        (Self : Bare_Grammar_Opt_Error_Group
         ; Grammar_Opt_Error_Group_F_Expr : Bare_Grammar_Expr_List
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

            Self.Grammar_Opt_Error_Group_F_Expr := Grammar_Opt_Error_Group_F_Expr;
         

      end Initialize_Fields_For_Grammar_Opt_Error_Group;

      
   function Grammar_Opt_Error_Group_F_Expr
     (Node : Bare_Grammar_Opt_Error_Group) return Bare_Grammar_Expr_List
   is
      

   begin
         
         return Node.Grammar_Opt_Error_Group_F_Expr;
      
   end;




   


      

   --
   --  Primitives for Bare_Grammar_Opt_Group
   --

   



      
      procedure Initialize_Fields_For_Grammar_Opt_Group
        (Self : Bare_Grammar_Opt_Group
         ; Grammar_Opt_Group_F_Expr : Bare_Grammar_Expr_List
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

            Self.Grammar_Opt_Group_F_Expr := Grammar_Opt_Group_F_Expr;
         

      end Initialize_Fields_For_Grammar_Opt_Group;

      
   function Grammar_Opt_Group_F_Expr
     (Node : Bare_Grammar_Opt_Group) return Bare_Grammar_Expr_List
   is
      

   begin
         
         return Node.Grammar_Opt_Group_F_Expr;
      
   end;




   


      

   --
   --  Primitives for Bare_Grammar_Or_Expr
   --

   



      
      procedure Initialize_Fields_For_Grammar_Or_Expr
        (Self : Bare_Grammar_Or_Expr
         ; Grammar_Or_Expr_F_Sub_Exprs : Bare_Grammar_Expr_List_List
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

            Self.Grammar_Or_Expr_F_Sub_Exprs := Grammar_Or_Expr_F_Sub_Exprs;
         

      end Initialize_Fields_For_Grammar_Or_Expr;

      
   function Grammar_Or_Expr_F_Sub_Exprs
     (Node : Bare_Grammar_Or_Expr) return Bare_Grammar_Expr_List_List
   is
      

   begin
         
         return Node.Grammar_Or_Expr_F_Sub_Exprs;
      
   end;




   


      

   --
   --  Primitives for Bare_Grammar_Pick
   --

   



      
      procedure Initialize_Fields_For_Grammar_Pick
        (Self : Bare_Grammar_Pick
         ; Grammar_Pick_F_Exprs : Bare_Grammar_Expr_List
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

            Self.Grammar_Pick_F_Exprs := Grammar_Pick_F_Exprs;
         

      end Initialize_Fields_For_Grammar_Pick;

      
   function Grammar_Pick_F_Exprs
     (Node : Bare_Grammar_Pick) return Bare_Grammar_Expr_List
   is
      

   begin
         
         return Node.Grammar_Pick_F_Exprs;
      
   end;




   


      

   --
   --  Primitives for Bare_Grammar_Implicit_Pick
   --

   



      
      procedure Initialize_Fields_For_Grammar_Implicit_Pick
        (Self : Bare_Grammar_Implicit_Pick
         ; Grammar_Pick_F_Exprs : Bare_Grammar_Expr_List
        ) is
      begin
            Initialize_Fields_For_Grammar_Pick
              (Self, Grammar_Pick_F_Exprs);

         

      end Initialize_Fields_For_Grammar_Implicit_Pick;




   


      

   --
   --  Primitives for Bare_Grammar_Predicate
   --

   



      
      procedure Initialize_Fields_For_Grammar_Predicate
        (Self : Bare_Grammar_Predicate
         ; Grammar_Predicate_F_Expr : Bare_Grammar_Expr
         ; Grammar_Predicate_F_Prop_Ref : Bare_Expr
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

            Self.Grammar_Predicate_F_Expr := Grammar_Predicate_F_Expr;
            Self.Grammar_Predicate_F_Prop_Ref := Grammar_Predicate_F_Prop_Ref;
         

      end Initialize_Fields_For_Grammar_Predicate;

      
   function Grammar_Predicate_F_Expr
     (Node : Bare_Grammar_Predicate) return Bare_Grammar_Expr
   is
      

   begin
         
         return Node.Grammar_Predicate_F_Expr;
      
   end;

      
   function Grammar_Predicate_F_Prop_Ref
     (Node : Bare_Grammar_Predicate) return Bare_Expr
   is
      

   begin
         
         return Node.Grammar_Predicate_F_Prop_Ref;
      
   end;




   


      

   --
   --  Primitives for Bare_Grammar_Rule_Ref
   --

   



      
      procedure Initialize_Fields_For_Grammar_Rule_Ref
        (Self : Bare_Grammar_Rule_Ref
         ; Grammar_Rule_Ref_F_Node_Name : Bare_Ref_Id
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

            Self.Grammar_Rule_Ref_F_Node_Name := Grammar_Rule_Ref_F_Node_Name;
         

      end Initialize_Fields_For_Grammar_Rule_Ref;

      
   function Grammar_Rule_Ref_F_Node_Name
     (Node : Bare_Grammar_Rule_Ref) return Bare_Ref_Id
   is
      

   begin
         
         return Node.Grammar_Rule_Ref_F_Node_Name;
      
   end;




   


      

   --
   --  Primitives for Bare_Grammar_Skip
   --

   



      
      procedure Initialize_Fields_For_Grammar_Skip
        (Self : Bare_Grammar_Skip
         ; Grammar_Skip_F_Name : Bare_Type_Ref
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

            Self.Grammar_Skip_F_Name := Grammar_Skip_F_Name;
         

      end Initialize_Fields_For_Grammar_Skip;

      
   function Grammar_Skip_F_Name
     (Node : Bare_Grammar_Skip) return Bare_Type_Ref
   is
      

   begin
         
         return Node.Grammar_Skip_F_Name;
      
   end;




   


      

   --
   --  Primitives for Bare_Grammar_Stop_Cut
   --

   



      
      procedure Initialize_Fields_For_Grammar_Stop_Cut
        (Self : Bare_Grammar_Stop_Cut
         ; Grammar_Stop_Cut_F_Expr : Bare_Grammar_Expr
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

            Self.Grammar_Stop_Cut_F_Expr := Grammar_Stop_Cut_F_Expr;
         

      end Initialize_Fields_For_Grammar_Stop_Cut;

      
   function Grammar_Stop_Cut_F_Expr
     (Node : Bare_Grammar_Stop_Cut) return Bare_Grammar_Expr
   is
      

   begin
         
         return Node.Grammar_Stop_Cut_F_Expr;
      
   end;




   


      

   --
   --  Primitives for Bare_Parse_Node_Expr
   --

   



      
      procedure Initialize_Fields_For_Parse_Node_Expr
        (Self : Bare_Parse_Node_Expr
         ; Parse_Node_Expr_F_Node_Name : Bare_Type_Ref
         ; Parse_Node_Expr_F_Sub_Exprs : Bare_Grammar_Expr_List
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

            Self.Parse_Node_Expr_F_Node_Name := Parse_Node_Expr_F_Node_Name;
            Self.Parse_Node_Expr_F_Sub_Exprs := Parse_Node_Expr_F_Sub_Exprs;
         

      end Initialize_Fields_For_Parse_Node_Expr;

      
   function Parse_Node_Expr_F_Node_Name
     (Node : Bare_Parse_Node_Expr) return Bare_Type_Ref
   is
      

   begin
         
         return Node.Parse_Node_Expr_F_Node_Name;
      
   end;

      
   function Parse_Node_Expr_F_Sub_Exprs
     (Node : Bare_Parse_Node_Expr) return Bare_Grammar_Expr_List
   is
      

   begin
         
         return Node.Parse_Node_Expr_F_Sub_Exprs;
      
   end;




   


      

   --
   --  Primitives for Bare_Token_Lit
   --

   



      
      procedure Initialize_Fields_For_Token_Lit
        (Self : Bare_Token_Lit
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

         

      end Initialize_Fields_For_Token_Lit;




   


      

   --
   --  Primitives for Bare_Token_No_Case_Lit
   --

   



      
      procedure Initialize_Fields_For_Token_No_Case_Lit
        (Self : Bare_Token_No_Case_Lit
         ; Token_No_Case_Lit_F_Lit : Bare_Token_Lit
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

            Self.Token_No_Case_Lit_F_Lit := Token_No_Case_Lit_F_Lit;
         

      end Initialize_Fields_For_Token_No_Case_Lit;

      
   function Token_No_Case_Lit_F_Lit
     (Node : Bare_Token_No_Case_Lit) return Bare_Token_Lit
   is
      

   begin
         
         return Node.Token_No_Case_Lit_F_Lit;
      
   end;




   


      

   --
   --  Primitives for Bare_Token_Pattern_Concat
   --

   



      
      procedure Initialize_Fields_For_Token_Pattern_Concat
        (Self : Bare_Token_Pattern_Concat
         ; Token_Pattern_Concat_F_Left : Bare_Grammar_Expr
         ; Token_Pattern_Concat_F_Right : Bare_Token_Pattern_Lit
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

            Self.Token_Pattern_Concat_F_Left := Token_Pattern_Concat_F_Left;
            Self.Token_Pattern_Concat_F_Right := Token_Pattern_Concat_F_Right;
         

      end Initialize_Fields_For_Token_Pattern_Concat;

      
   function Token_Pattern_Concat_F_Left
     (Node : Bare_Token_Pattern_Concat) return Bare_Grammar_Expr
   is
      

   begin
         
         return Node.Token_Pattern_Concat_F_Left;
      
   end;

      
   function Token_Pattern_Concat_F_Right
     (Node : Bare_Token_Pattern_Concat) return Bare_Token_Pattern_Lit
   is
      

   begin
         
         return Node.Token_Pattern_Concat_F_Right;
      
   end;




   


      

   --
   --  Primitives for Bare_Token_Pattern_Lit
   --

   



      
      procedure Initialize_Fields_For_Token_Pattern_Lit
        (Self : Bare_Token_Pattern_Lit
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

         

      end Initialize_Fields_For_Token_Pattern_Lit;




   


      

   --
   --  Primitives for Bare_Token_Ref
   --

   



      
      procedure Initialize_Fields_For_Token_Ref
        (Self : Bare_Token_Ref
         ; Token_Ref_F_Token_Name : Bare_Ref_Id
         ; Token_Ref_F_Expr : Bare_Token_Lit
        ) is
      begin
            Initialize_Fields_For_Grammar_Expr
              (Self);

            Self.Token_Ref_F_Token_Name := Token_Ref_F_Token_Name;
            Self.Token_Ref_F_Expr := Token_Ref_F_Expr;
         

      end Initialize_Fields_For_Token_Ref;

      
   function Token_Ref_F_Token_Name
     (Node : Bare_Token_Ref) return Bare_Ref_Id
   is
      

   begin
         
         return Node.Token_Ref_F_Token_Name;
      
   end;

      
   function Token_Ref_F_Expr
     (Node : Bare_Token_Ref) return Bare_Token_Lit
   is
      

   begin
         
         return Node.Token_Ref_F_Expr;
      
   end;




   


      

   --
   --  Primitives for Bare_Id
   --

   



      
      procedure Initialize_Fields_For_Id
        (Self : Bare_Id
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

         

      end Initialize_Fields_For_Id;




   


      

   --
   --  Primitives for Bare_Def_Id
   --

   



      
      procedure Initialize_Fields_For_Def_Id
        (Self : Bare_Def_Id
        ) is
      begin
            Initialize_Fields_For_Id
              (Self);

         

      end Initialize_Fields_For_Def_Id;


   







--# property-start DefId.decl nodes.lkt:4188
pragma Warnings (Off, "is not referenced");

function Def_Id_P_Decl
  
  (Node : Bare_Def_Id
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Decl
is
   Self : Bare_Def_Id :=
     Bare_Def_Id (Node);
     Ent : Internal_Entity_Def_Id :=
       Internal_Entity_Def_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Decl;

      
            procedure Finalizer_Scope_318 with Inline_Always;

      Fld : Internal_Entity_Array_Access;
Is_A : Boolean;
Find_Result : Internal_Entity;
Cast_Result : Internal_Entity_Decl;

            procedure Finalizer_Scope_318 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_318;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 2555 Cast Cast_Result nodes.lkt:4188





--# expr-start 2554 .find Find_Result nodes.lkt:4188








   

   --# expr-start 2552 LktNode.parents Fld nodes.lkt:4188







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



Fld := Liblktlang.Implementation.Parents (Node => Ent.Node, With_Self => True, E_Info => Ent.Info);
--# expr-done 2552

   
      Find_Result := No_Entity;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind p Item

            
      --# expr-start 2553 IsA Is_A nodes.lkt:4188

Is_A := Item.Node /= null 
and then Item.Node.Kind in Lkt_Decl; 
--# expr-done 2553
      if Is_A then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Is_A;

         end loop;
      end;
   

   
   



--# expr-done 2554



   if Find_Result.Node = null
      or else Find_Result.Node.Kind in Lkt_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Decl
        (Node => Find_Result.Node,
         Info => Find_Result.Info);

   else
         Cast_Result := No_Entity_Decl;
   end if;


--# expr-done 2555

         Property_Result := Cast_Result;
         
   --# end
      Finalizer_Scope_318;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_318;




            raise;
      end;



   return Property_Result;
end Def_Id_P_Decl;
--# end

   







--# property-start DefId.name nodes.lkt:4192
pragma Warnings (Off, "is not referenced");

function Def_Id_P_Name
  
  (Node : Bare_Def_Id
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Def_Id :=
     Bare_Def_Id (Node);
     Ent : Internal_Entity_Def_Id :=
       Internal_Entity_Def_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_319 with Inline_Always;

      Fld : Internal_Entity_Decl;
Fld_1 : String_Type;

            procedure Finalizer_Scope_319 is
            begin
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_319;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 2557 Decl.full_name Fld_1 nodes.lkt:4193



--# expr-start 2556 DefId.decl Fld nodes.lkt:4193







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DefId.decl
Fld := Liblktlang.Implementation.Def_Id_P_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2556



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.full_name'
Fld_1 := Liblktlang.Implementation.Dispatcher_Decl_P_Full_Name (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2557

         Property_Result := Fld_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_319;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_319;




            raise;
      end;



   return Property_Result;
end Def_Id_P_Name;
--# end

   







--# property-start DefId.get_type nodes.lkt:4197
pragma Warnings (Off, "is not referenced");

function Def_Id_P_Get_Type
  
  (Node : Bare_Def_Id
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Def_Id :=
     Bare_Def_Id (Node);
     Ent : Internal_Entity_Def_Id :=
       Internal_Entity_Def_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;

      

      Fld : Internal_Entity_Decl;
Fld_1 : Internal_Entity_Type_Decl;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2559 Decl.get_type Fld_1 nodes.lkt:4199



--# expr-start 2558 DefId.decl Fld nodes.lkt:4199







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DefId.decl
Fld := Liblktlang.Implementation.Def_Id_P_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2558



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.get_type
Fld_1 := Liblktlang.Implementation.Decl_P_Get_Type (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2559

         Property_Result := Fld_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Def_Id_P_Get_Type;
--# end

   







--# property-start DefId.get_implementatinons nodes.lkt:4203
pragma Warnings (Off, "is not referenced");

function Def_Id_P_Get_Implementatinons
  
  (Node : Bare_Def_Id
      ; Units : Internal_Unit_Array_Access
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Def_Id_Array_Access
is
   Self : Bare_Def_Id :=
     Bare_Def_Id (Node);
     Ent : Internal_Entity_Def_Id :=
       Internal_Entity_Def_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind units Units

   Property_Result : Internal_Entity_Def_Id_Array_Access;

      
            procedure Finalizer_Scope_321 with Inline_Always;

      Fld : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Fun_Decl;
Var_Expr : Internal_Entity_Fun_Decl;
Fld_1 : Internal_Entity_Fun_Decl_Array_Access;
Fld_2 : Internal_Entity_Def_Id;
Map_Result : Internal_Entity_Def_Id_Array_Access;
Result_Var : Internal_Entity_Def_Id_Array_Access;

            procedure Finalizer_Scope_321 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Result_Var);
            end Finalizer_Scope_321;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         


--# expr-start 2561 Cast Cast_Result nodes.lkt:4205





--# expr-start 2560 DefId.decl Fld nodes.lkt:4205







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DefId.decl
Fld := Liblktlang.Implementation.Def_Id_P_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2560



   if Fld.Node = null
      or else Fld.Node.Kind in Lkt_Fun_Decl_Range
   then
      
      Cast_Result := Create_Internal_Entity_Fun_Decl
        (Node => Fld.Node,
         Info => Fld.Info);

   else
         Cast_Result := No_Entity_Fun_Decl;
   end if;


--# expr-done 2561
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Fun_Decl then
   --# expr-start 2564 .map Map_Result nodes.lkt:4205








   

   --# expr-start 2562 FunDecl.find_all_overrides Fld_1 nodes.lkt:4205







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start FunDecl.find_all_overrides
Fld_1 := Liblktlang.Implementation.Fun_Decl_P_Find_All_Overrides (Node => Var_Expr.Node, Units => Units, E_Info => Var_Expr.Info);
--# end
--# expr-done 2562

   
      declare
         Map_Result_Vec : Internal_Entity_Def_Id_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Fun_Decl_Array_Access := Fld_1;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind f Item

            
         
         
      --# expr-start 2563 FunDecl.syn_name Fld_2 nodes.lkt:4208







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Def_Id (Node => Item.Node.Fun_Decl_F_Syn_Name, Info => Item.Info);
--# expr-done 2563
      

         declare
            Item_To_Append : constant Internal_Entity_Def_Id := Fld_2;
         begin
            Internal_Entity_Def_Id_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Entity_Def_Id_Array
           (Items_Count => Natural (Internal_Entity_Def_Id_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Def_Id_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Def_Id_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Def_Id_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 2564
   Result_Var := Map_Result;
else
   
   Result_Var := No_Internal_Entity_Def_Id_Array_Type;
end if;

      Inc_Ref (Result_Var);



         Property_Result := Result_Var;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_321;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_321;




            raise;
      end;



   return Property_Result;
end Def_Id_P_Get_Implementatinons;
--# end

   







--# property-start DefId.decl_detail nodes.lkt:4213
pragma Warnings (Off, "is not referenced");

function Def_Id_P_Decl_Detail
  
  (Node : Bare_Def_Id
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Def_Id :=
     Bare_Def_Id (Node);
     Ent : Internal_Entity_Def_Id :=
       Internal_Entity_Def_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_322 with Inline_Always;
            procedure Finalizer_Scope_751 with Inline_Always;
            procedure Finalizer_Scope_752 with Inline_Always;
            procedure Finalizer_Scope_753 with Inline_Always;
            procedure Finalizer_Scope_754 with Inline_Always;

      Str : String_Type;
Fld : Internal_Entity_Decl;
Fld_1 : String_Type;
Concat_Result : String_Type;
Str_1 : String_Type;
Concat_Result_1 : String_Type;
Fld_2 : Internal_Entity_Decl;
Fld_3 : String_Type;
Concat_Result_2 : String_Type;
Fld_4 : Internal_Entity_Type_Decl;
Var_Expr : Internal_Entity_Type_Decl;
Fld_5 : Internal_Entity_Decl;
Ignored : Internal_Entity_Fun_Decl;
Fld_6 : String_Type;
Ignored_1 : Internal_Entity_Type_Decl;
Str_2 : String_Type;
Ignored_2 : Internal_Entity_Decl;
Str_3 : String_Type;
Fld_7 : String_Type;
Concat_Result_3 : String_Type;
Match_Prefix : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Fun_Decl;
Let_Result : String_Type;
Scope_Result : String_Type;
Cast_Result_1 : Internal_Entity_Type_Decl;
Let_Result_1 : String_Type;
Scope_Result_1 : String_Type;
Cast_Result_2 : Internal_Entity_Decl;
Let_Result_2 : String_Type;
Scope_Result_2 : String_Type;
Match_Result : String_Type;
Scope_Result_3 : String_Type;
Result_Var : String_Type;
Concat_Result_4 : String_Type;

            procedure Finalizer_Scope_322 is
            begin
                     Dec_Ref (Str);
                     Dec_Ref (Fld_1);
                     Dec_Ref (Concat_Result);
                     Dec_Ref (Str_1);
                     Dec_Ref (Concat_Result_1);
                     Dec_Ref (Fld_3);
                     Dec_Ref (Concat_Result_2);
                     Dec_Ref (Scope_Result_3);
                     Dec_Ref (Result_Var);
                     Dec_Ref (Concat_Result_4);
            end Finalizer_Scope_322;
            procedure Finalizer_Scope_751 is
            begin
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (Scope_Result_2);
                     Dec_Ref (Match_Result);
            end Finalizer_Scope_751;
            procedure Finalizer_Scope_752 is
            begin
                     Dec_Ref (Fld_6);
                     Dec_Ref (Let_Result);
            end Finalizer_Scope_752;
            procedure Finalizer_Scope_753 is
            begin
                     Dec_Ref (Str_2);
                     Dec_Ref (Let_Result_1);
            end Finalizer_Scope_753;
            procedure Finalizer_Scope_754 is
            begin
                     Dec_Ref (Str_3);
                     Dec_Ref (Fld_7);
                     Dec_Ref (Concat_Result_3);
                     Dec_Ref (Let_Result_2);
            end Finalizer_Scope_754;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 2583 StringConcat Concat_Result_4 nodes.lkt:4214
--# expr-start 2573 StringConcat Concat_Result_2 nodes.lkt:4214
--# expr-start 2570 StringConcat Concat_Result_1 nodes.lkt:4214
--# expr-start 2568 StringConcat Concat_Result nodes.lkt:4214
--# expr-start 2565 StringLiteral Str nodes.lkt:4214
Str := Create_String ("("); 
--# expr-done 2565
--# expr-start 2567 Decl.decl_type_name Fld_1 nodes.lkt:4214



--# expr-start 2566 DefId.decl Fld nodes.lkt:4214







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DefId.decl
Fld := Liblktlang.Implementation.Def_Id_P_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2566



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.decl_type_name'
Fld_1 := Liblktlang.Implementation.Dispatcher_Decl_P_Decl_Type_Name (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2567
Concat_Result := Concat_String (Str, Fld_1); 
--# expr-done 2568
--# expr-start 2569 StringLiteral Str_1 nodes.lkt:4214
Str_1 := Create_String (") "); 
--# expr-done 2569
Concat_Result_1 := Concat_String (Concat_Result, Str_1); 
--# expr-done 2570
--# expr-start 2572 Decl.full_name Fld_3 nodes.lkt:4214



--# expr-start 2571 DefId.decl Fld_2 nodes.lkt:4214







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DefId.decl
Fld_2 := Liblktlang.Implementation.Def_Id_P_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2571



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.full_name'
Fld_3 := Liblktlang.Implementation.Dispatcher_Decl_P_Full_Name (Node => Fld_2.Node, E_Info => Fld_2.Info);
--# end
--# expr-done 2572
Concat_Result_2 := Concat_String (Concat_Result_1, Fld_3); 
--# expr-done 2573
--# expr-start 2582 .do Result_Var nodes.lkt:4215



--# expr-start 2574 DefId.get_type Fld_4 nodes.lkt:4215







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.get_type'
Fld_4 := Liblktlang.Implementation.Dispatcher_Expr_P_Get_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2574
Var_Expr := Fld_4;





if Var_Expr /= No_Entity_Type_Decl then
   



   --# scope-start



--# expr-start 2581 Match Match_Result nodes.lkt:4216






--# expr-start 2575 DefId.decl Fld_5 nodes.lkt:4216







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DefId.decl
Fld_5 := Liblktlang.Implementation.Def_Id_P_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2575



   if Fld_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := Fld_5; 

case Lkt_Decl (Match_Prefix.Node.Kind) is
         when Lkt_Fun_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result := Create_Internal_Entity_Fun_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored := Cast_Result; 
--# bind _ Ignored
--# expr-start 2576 TypeDecl.full_name Fld_6 nodes.lkt:4217







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.full_name'
Fld_6 := Liblktlang.Implementation.Dispatcher_Decl_P_Full_Name (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 2576
Let_Result := Fld_6; Inc_Ref (Let_Result);
--# end
Scope_Result := Let_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_752;


            Match_Result := Scope_Result; Inc_Ref (Match_Result);
         when Lkt_Any_Type_Decl .. Lkt_Trait_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_1 := Create_Internal_Entity_Type_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_1 := Cast_Result_1; 
--# bind _ Ignored_1
--# expr-start 2577 StringLiteral Str_2 nodes.lkt:4218
Str_2 := Create_String (""); 
--# expr-done 2577
Let_Result_1 := Str_2; Inc_Ref (Let_Result_1);
--# end
Scope_Result_1 := Let_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_753;


            Match_Result := Scope_Result_1; Inc_Ref (Match_Result);
         when Lkt_Grammar_Rule_Decl .. Lkt_Val_Decl | Lkt_Env_Spec_Decl .. Lkt_Synth_Param_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_2 := Create_Internal_Entity_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_2 := Cast_Result_2; 
--# bind _ Ignored_2
--# expr-start 2580 StringConcat Concat_Result_3 nodes.lkt:4219
--# expr-start 2578 StringLiteral Str_3 nodes.lkt:4219
Str_3 := Create_String (": "); 
--# expr-done 2578
--# expr-start 2579 TypeDecl.full_name Fld_7 nodes.lkt:4219







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.full_name'
Fld_7 := Liblktlang.Implementation.Dispatcher_Decl_P_Full_Name (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 2579
Concat_Result_3 := Concat_String (Str_3, Fld_7); 
--# expr-done 2580
Let_Result_2 := Concat_Result_3; Inc_Ref (Let_Result_2);
--# end
Scope_Result_2 := Let_Result_2;
   Inc_Ref (Scope_Result_2);


   --# end
      Finalizer_Scope_754;


            Match_Result := Scope_Result_2; Inc_Ref (Match_Result);
end case;

--# expr-done 2581
Scope_Result_3 := Match_Result;
   Inc_Ref (Scope_Result_3);


   --# end
      Finalizer_Scope_751;


   Result_Var := Scope_Result_3;
else
   
   Result_Var := Empty_String;
end if;

      Inc_Ref (Result_Var);


--# expr-done 2582
Concat_Result_4 := Concat_String (Concat_Result_2, Result_Var); 
--# expr-done 2583

         Property_Result := Concat_Result_4;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_322;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_322;
                     Finalizer_Scope_751;
                     Finalizer_Scope_752;
                     Finalizer_Scope_753;
                     Finalizer_Scope_754;




            raise;
      end;



   return Property_Result;
end Def_Id_P_Decl_Detail;
--# end

   







--# property-start DefId.completion_item_kind nodes.lkt:4226
pragma Warnings (Off, "is not referenced");

function Def_Id_P_Completion_Item_Kind
  
  (Node : Bare_Def_Id
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Integer
is
   Self : Bare_Def_Id :=
     Bare_Def_Id (Node);
     Ent : Internal_Entity_Def_Id :=
       Internal_Entity_Def_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Integer;

      

      Fld : Internal_Entity_Decl;
Ignored : Internal_Entity_Fun_Decl;
Ignored_1 : Internal_Entity_Class_Decl;
Ignored_2 : Internal_Entity_Struct_Decl;
Ignored_3 : Internal_Entity_Val_Decl;
Ignored_4 : Internal_Entity_Field_Decl;
Ignored_5 : Internal_Entity_Enum_Type_Decl;
Ignored_6 : Internal_Entity_Enum_Class_Decl;
Ignored_7 : Internal_Entity_Enum_Lit_Decl;
Ignored_8 : Internal_Entity_Enum_Class_Alt_Decl;
Ignored_9 : Internal_Entity_Generic_Param_Type_Decl;
Ignored_10 : Internal_Entity_Trait_Decl;
Ignored_11 : Internal_Entity_Decl;
Match_Prefix : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Fun_Decl;
Let_Result : Completion_Item_Kind;
Scope_Result : Completion_Item_Kind;
Cast_Result_1 : Internal_Entity_Class_Decl;
Let_Result_1 : Completion_Item_Kind;
Scope_Result_1 : Completion_Item_Kind;
Cast_Result_2 : Internal_Entity_Struct_Decl;
Let_Result_2 : Completion_Item_Kind;
Scope_Result_2 : Completion_Item_Kind;
Cast_Result_3 : Internal_Entity_Val_Decl;
Let_Result_3 : Completion_Item_Kind;
Scope_Result_3 : Completion_Item_Kind;
Cast_Result_4 : Internal_Entity_Field_Decl;
Let_Result_4 : Completion_Item_Kind;
Scope_Result_4 : Completion_Item_Kind;
Cast_Result_5 : Internal_Entity_Enum_Type_Decl;
Let_Result_5 : Completion_Item_Kind;
Scope_Result_5 : Completion_Item_Kind;
Cast_Result_6 : Internal_Entity_Enum_Class_Decl;
Let_Result_6 : Completion_Item_Kind;
Scope_Result_6 : Completion_Item_Kind;
Cast_Result_7 : Internal_Entity_Enum_Lit_Decl;
Let_Result_7 : Completion_Item_Kind;
Scope_Result_7 : Completion_Item_Kind;
Cast_Result_8 : Internal_Entity_Enum_Class_Alt_Decl;
Let_Result_8 : Completion_Item_Kind;
Scope_Result_8 : Completion_Item_Kind;
Cast_Result_9 : Internal_Entity_Generic_Param_Type_Decl;
Let_Result_9 : Completion_Item_Kind;
Scope_Result_9 : Completion_Item_Kind;
Cast_Result_10 : Internal_Entity_Trait_Decl;
Let_Result_10 : Completion_Item_Kind;
Scope_Result_10 : Completion_Item_Kind;
Cast_Result_11 : Internal_Entity_Decl;
Let_Result_11 : Completion_Item_Kind;
Scope_Result_11 : Completion_Item_Kind;
Match_Result : Completion_Item_Kind;
Fld_1 : Integer;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 2586 LktNode.completion_item_kind_to_int Fld_1 nodes.lkt:4228







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 2585 Match Match_Result nodes.lkt:4229






--# expr-start 2584 DefId.decl Fld nodes.lkt:4229







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DefId.decl
Fld := Liblktlang.Implementation.Def_Id_P_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2584



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := Fld; 

case Lkt_Decl (Match_Prefix.Node.Kind) is
         when Lkt_Fun_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result := Create_Internal_Entity_Fun_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored := Cast_Result; 
--# bind _ Ignored

Let_Result := Function_Kind; 
--# end
Scope_Result := Let_Result;


   --# end


            Match_Result := Scope_Result; 
         when Lkt_Class_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_1 := Create_Internal_Entity_Class_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_1 := Cast_Result_1; 
--# bind _ Ignored_1

Let_Result_1 := Class_Kind; 
--# end
Scope_Result_1 := Let_Result_1;


   --# end


            Match_Result := Scope_Result_1; 
         when Lkt_Struct_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_2 := Create_Internal_Entity_Struct_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_2 := Cast_Result_2; 
--# bind _ Ignored_2

Let_Result_2 := Struct_Kind; 
--# end
Scope_Result_2 := Let_Result_2;


   --# end


            Match_Result := Scope_Result_2; 
         when Lkt_Val_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_3 := Create_Internal_Entity_Val_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_3 := Cast_Result_3; 
--# bind _ Ignored_3

Let_Result_3 := Variable_Kind; 
--# end
Scope_Result_3 := Let_Result_3;


   --# end


            Match_Result := Scope_Result_3; 
         when Lkt_Field_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_4 := Create_Internal_Entity_Field_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_4 := Cast_Result_4; 
--# bind _ Ignored_4

Let_Result_4 := Field_Kind; 
--# end
Scope_Result_4 := Let_Result_4;


   --# end


            Match_Result := Scope_Result_4; 
         when Lkt_Enum_Type_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_5 := Create_Internal_Entity_Enum_Type_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_5 := Cast_Result_5; 
--# bind _ Ignored_5

Let_Result_5 := Enum_Kind; 
--# end
Scope_Result_5 := Let_Result_5;


   --# end


            Match_Result := Scope_Result_5; 
         when Lkt_Enum_Class_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_6 := Create_Internal_Entity_Enum_Class_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_6 := Cast_Result_6; 
--# bind _ Ignored_6

Let_Result_6 := Enum_Kind; 
--# end
Scope_Result_6 := Let_Result_6;


   --# end


            Match_Result := Scope_Result_6; 
         when Lkt_Enum_Lit_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_7 := Create_Internal_Entity_Enum_Lit_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_7 := Cast_Result_7; 
--# bind _ Ignored_7

Let_Result_7 := Enum_Member_Kind; 
--# end
Scope_Result_7 := Let_Result_7;


   --# end


            Match_Result := Scope_Result_7; 
         when Lkt_Enum_Class_Alt_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_8 := Create_Internal_Entity_Enum_Class_Alt_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_8 := Cast_Result_8; 
--# bind _ Ignored_8

Let_Result_8 := Enum_Member_Kind; 
--# end
Scope_Result_8 := Let_Result_8;


   --# end


            Match_Result := Scope_Result_8; 
         when Lkt_Generic_Param_Type_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_9 := Create_Internal_Entity_Generic_Param_Type_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_9 := Cast_Result_9; 
--# bind _ Ignored_9

Let_Result_9 := Type_Parameter_Kind; 
--# end
Scope_Result_9 := Let_Result_9;


   --# end


            Match_Result := Scope_Result_9; 
         when Lkt_Trait_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_10 := Create_Internal_Entity_Trait_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_10 := Cast_Result_10; 
--# bind _ Ignored_10

Let_Result_10 := Interface_Kind; 
--# end
Scope_Result_10 := Let_Result_10;


   --# end


            Match_Result := Scope_Result_10; 
         when Lkt_Grammar_Rule_Decl .. Lkt_Binding_Val_Decl | Lkt_Fun_Param_Decl .. Lkt_Match_Val_Decl | Lkt_Env_Spec_Decl .. Lkt_Any_Type_Decl | Lkt_Function_Type =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_11 := Create_Internal_Entity_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_11 := Cast_Result_11; 
--# bind _ Ignored_11

Let_Result_11 := Text_Kind; 
--# end
Scope_Result_11 := Let_Result_11;


   --# end


            Match_Result := Scope_Result_11; 
end case;

--# expr-done 2585
Fld_1 := Liblktlang.Implementation.Completion_Item_Kind_To_Int (Node => Ent.Node, Kind => Match_Result);
--# expr-done 2586

         Property_Result := Fld_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Def_Id_P_Completion_Item_Kind;
--# end

   







--# property-start DefId.doc nodes.lkt:4248
pragma Warnings (Off, "is not referenced");

function Def_Id_P_Doc
  
  (Node : Bare_Def_Id
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return String_Type
is
   Self : Bare_Def_Id :=
     Bare_Def_Id (Node);
     Ent : Internal_Entity_Def_Id :=
       Internal_Entity_Def_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : String_Type;

      
            procedure Finalizer_Scope_324 with Inline_Always;
            procedure Finalizer_Scope_767 with Inline_Always;
            procedure Finalizer_Scope_769 with Inline_Always;

      Fld : Internal_Entity_Decl;
Local_F : Internal_Entity_Fun_Decl;
Fld_1 : Internal_Entity_Fun_Decl_Array_Access;
Fld_2 : Internal_Entity_Full_Decl;
Var_Expr : Internal_Entity_Full_Decl;
Fld_3 : Internal_Entity_String_Lit;
Is_Null : Boolean;
Result_Var : Boolean;
Not_Val : Boolean;
Find_Result : Internal_Entity_Fun_Decl;
Var_Expr_1 : Internal_Entity_Fun_Decl;
Fld_4 : Internal_Entity_Full_Decl;
Var_Expr_2 : Internal_Entity_Full_Decl;
Fld_5 : Internal_Entity_String_Lit;
Fld_6 : Internal_Decoded_String_Value := No_Decoded_String_Value;
Fld_7 : String_Type;
Result_Var_1 : String_Type;
Result_Var_2 : String_Type;
Local_D : Internal_Entity_Decl;
Var_Expr_3 : Internal_Entity_Decl;
Fld_8 : Internal_Entity_Full_Decl;
Var_Expr_4 : Internal_Entity_Full_Decl;
Fld_9 : Internal_Entity_String_Lit;
Var_Expr_5 : Internal_Entity_String_Lit;
Fld_10 : Internal_Decoded_String_Value := No_Decoded_String_Value;
Fld_11 : String_Type;
Result_Var_3 : String_Type;
Result_Var_4 : String_Type;
Result_Var_5 : String_Type;
Match_Prefix : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Fun_Decl;
Let_Result : String_Type;
Scope_Result : String_Type;
Cast_Result_1 : Internal_Entity_Decl;
Let_Result_1 : String_Type;
Scope_Result_1 : String_Type;
Match_Result : String_Type;

            procedure Finalizer_Scope_324 is
            begin
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (Match_Result);
            end Finalizer_Scope_324;
            procedure Finalizer_Scope_767 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Fld_6);
                     Dec_Ref (Fld_7);
                     Dec_Ref (Result_Var_1);
                     Dec_Ref (Result_Var_2);
                     Dec_Ref (Let_Result);
            end Finalizer_Scope_767;
            procedure Finalizer_Scope_769 is
            begin
                     Dec_Ref (Fld_10);
                     Dec_Ref (Fld_11);
                     Dec_Ref (Result_Var_3);
                     Dec_Ref (Result_Var_4);
                     Dec_Ref (Result_Var_5);
                     Dec_Ref (Let_Result_1);
            end Finalizer_Scope_769;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 2602 Match Match_Result nodes.lkt:4249






--# expr-start 2587 DefId.decl Fld nodes.lkt:4249







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DefId.decl
Fld := Liblktlang.Implementation.Def_Id_P_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2587



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := Fld; 

case Lkt_Decl (Match_Prefix.Node.Kind) is
         when Lkt_Fun_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result := Create_Internal_Entity_Fun_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_F := Cast_Result; 
--# bind f Local_F



--# expr-start 2593 .find Find_Result nodes.lkt:4250








   

   --# expr-start 2588 FunDecl.base_fun_decls Fld_1 nodes.lkt:4250







   if Local_F.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start FunDecl.base_fun_decls
Fld_1 := Liblktlang.Implementation.Fun_Decl_P_Base_Fun_Decls (Node => Local_F.Node, E_Info => Local_F.Info);
--# end
--# expr-done 2588

   
      Find_Result := No_Entity_Fun_Decl;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Fun_Decl_Array_Access := Fld_1;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind f Item

            
      --# expr-start 2592 Not Not_Val nodes.lkt:4251



--# expr-start 2589 Decl.full_decl Fld_2 nodes.lkt:4251







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.full_decl
Fld_2 := Liblktlang.Implementation.Decl_P_Full_Decl (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 2589
Var_Expr := Fld_2;





if Var_Expr /= No_Entity_Full_Decl then
   --# expr-start 2591 .is_null Is_Null nodes.lkt:4251
--# expr-start 2590 FullDecl.doc Fld_3 nodes.lkt:4251







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_String_Lit (Node => Var_Expr.Node.Full_Decl_F_Doc, Info => Var_Expr.Info);
--# expr-done 2590
Is_Null := Fld_3.Node = null; 
--# expr-done 2591
   Result_Var := Is_Null;
else
   
   Result_Var := False;
end if;



Not_Val := not (Result_Var); 
--# expr-done 2592
      if Not_Val then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Not_Val;

         end loop;
      end;
   

   
   



--# expr-done 2593
Var_Expr_1 := Find_Result;





if Var_Expr_1 /= No_Entity_Fun_Decl then
   


--# expr-start 2594 Decl.full_decl Fld_4 nodes.lkt:4250







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.full_decl
Fld_4 := Liblktlang.Implementation.Decl_P_Full_Decl (Node => Var_Expr_1.Node, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 2594
Var_Expr_2 := Fld_4;





if Var_Expr_2 /= No_Entity_Full_Decl then
   --# expr-start 2597 DecodedStringValue.value Fld_7 nodes.lkt:4250



--# expr-start 2596 StringLit.denoted_value Fld_6 nodes.lkt:4250



--# expr-start 2595 FullDecl.doc Fld_5 nodes.lkt:4250







   if Var_Expr_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_String_Lit (Node => Var_Expr_2.Node.Full_Decl_F_Doc, Info => Var_Expr_2.Info);
--# expr-done 2595



   if Fld_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]StringLit.denoted_value'
Fld_6 := Liblktlang.Implementation.Dispatcher_String_Lit_P_Denoted_Value (Node => Fld_5.Node);
--# end
--# expr-done 2596





Fld_7 := Fld_6.Value;
Inc_Ref (Fld_7);
--# expr-done 2597
   Result_Var_1 := Fld_7;
else
   
   Result_Var_1 := Empty_String;
end if;

      Inc_Ref (Result_Var_1);


   Result_Var_2 := Result_Var_1;
else
   
   Result_Var_2 := Empty_String;
end if;

      Inc_Ref (Result_Var_2);


Let_Result := Result_Var_2; Inc_Ref (Let_Result);
--# end
Scope_Result := Let_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_767;


            Match_Result := Scope_Result; Inc_Ref (Match_Result);
         when Lkt_Grammar_Rule_Decl .. Lkt_Val_Decl | Lkt_Env_Spec_Decl .. Lkt_Trait_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_1 := Create_Internal_Entity_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_D := Cast_Result_1; 
--# bind d Local_D




Var_Expr_3 := Local_D;





if Var_Expr_3 /= No_Entity_Decl then
   


--# expr-start 2598 Decl.full_decl Fld_8 nodes.lkt:4253







   if Var_Expr_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.full_decl
Fld_8 := Liblktlang.Implementation.Decl_P_Full_Decl (Node => Var_Expr_3.Node, E_Info => Var_Expr_3.Info);
--# end
--# expr-done 2598
Var_Expr_4 := Fld_8;





if Var_Expr_4 /= No_Entity_Full_Decl then
   


--# expr-start 2599 FullDecl.doc Fld_9 nodes.lkt:4253







   if Var_Expr_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Create_Internal_Entity_String_Lit (Node => Var_Expr_4.Node.Full_Decl_F_Doc, Info => Var_Expr_4.Info);
--# expr-done 2599
Var_Expr_5 := Fld_9;





if Var_Expr_5 /= No_Entity_String_Lit then
   --# expr-start 2601 DecodedStringValue.value Fld_11 nodes.lkt:4253



--# expr-start 2600 StringLit.denoted_value Fld_10 nodes.lkt:4253







   if Var_Expr_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]StringLit.denoted_value'
Fld_10 := Liblktlang.Implementation.Dispatcher_String_Lit_P_Denoted_Value (Node => Var_Expr_5.Node);
--# end
--# expr-done 2600





Fld_11 := Fld_10.Value;
Inc_Ref (Fld_11);
--# expr-done 2601
   Result_Var_3 := Fld_11;
else
   
   Result_Var_3 := Empty_String;
end if;

      Inc_Ref (Result_Var_3);


   Result_Var_4 := Result_Var_3;
else
   
   Result_Var_4 := Empty_String;
end if;

      Inc_Ref (Result_Var_4);


   Result_Var_5 := Result_Var_4;
else
   
   Result_Var_5 := Empty_String;
end if;

      Inc_Ref (Result_Var_5);


Let_Result_1 := Result_Var_5; Inc_Ref (Let_Result_1);
--# end
Scope_Result_1 := Let_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_769;


            Match_Result := Scope_Result_1; Inc_Ref (Match_Result);
end case;

--# expr-done 2602

         Property_Result := Match_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_324;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_324;
                     Finalizer_Scope_767;
                     Finalizer_Scope_769;




            raise;
      end;



   return Property_Result;
end Def_Id_P_Doc;
--# end

   







--# property-start DefId.find_all_references_helper nodes.lkt:4256
pragma Warnings (Off, "is not referenced");

function Def_Id_P_Find_All_References_Helper
  
  (Node : Bare_Def_Id
      ; Current_Node : Internal_Entity
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Ref_Id_Array_Access
is
   Self : Bare_Def_Id :=
     Bare_Def_Id (Node);
     Ent : Internal_Entity_Def_Id :=
       Internal_Entity_Def_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind current_node Current_Node

   Property_Result : Internal_Entity_Ref_Id_Array_Access;

      
            procedure Finalizer_Scope_326 with Inline_Always;
            procedure Finalizer_Scope_770 with Inline_Always;

      Fld : Internal_Entity_Array_Access;
Fld_1 : Internal_Entity_Ref_Id_Array_Access;
Is_Null : Boolean;
If_Result : Internal_Entity_Ref_Id_Array_Access;
Map_Result : Internal_Entity_Ref_Id_Array_Access;
Cast_Result : Internal_Entity_Ref_Id;
Var_Expr : Internal_Entity_Ref_Id;
Fld_2 : Internal_Entity_Decl;
Fld_3 : Bare_Decl;
Fld_4 : Internal_Entity_Decl;
Fld_5 : Bare_Decl;
Cast_Result_1 : Bare_Decl;
Is_Equal : Boolean;
Scope_Result : Boolean;
Result_Var : Boolean;
Cast_Result_2 : Internal_Entity_Ref_Id;
Singleton : Internal_Entity_Ref_Id_Array_Access;
If_Result_1 : Internal_Entity_Ref_Id_Array_Access;

            procedure Finalizer_Scope_326 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Singleton);
                     Dec_Ref (If_Result_1);
            end Finalizer_Scope_326;
            procedure Finalizer_Scope_770 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (If_Result);
            end Finalizer_Scope_770;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2617 If If_Result_1 nodes.lkt:4259



--# expr-start 2609 .do Result_Var nodes.lkt:4259



--# expr-start 2603 Cast Cast_Result nodes.lkt:4259









   if Current_Node.Node = null
      or else Current_Node.Node.Kind in Lkt_Ref_Id_Range
   then
      
      Cast_Result := Create_Internal_Entity_Ref_Id
        (Node => Current_Node.Node,
         Info => Current_Node.Info);

   else
         Cast_Result := No_Entity_Ref_Id;
   end if;


--# expr-done 2603
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Ref_Id then
   



   --# scope-start



--# expr-start 2608 Eq Is_Equal nodes.lkt:4260





--# expr-start 2605 'Entity[Decl].node' Fld_3 nodes.lkt:4260



--# expr-start 2604 RefId.referenced_decl Fld_2 nodes.lkt:4260







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.referenced_decl'
Fld_2 := Liblktlang.Implementation.Dispatcher_Expr_P_Referenced_Decl (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 2604





Fld_3 := Fld_2.Node;
--# expr-done 2605



   
      Cast_Result_1 := Fld_3;


--# expr-start 2607 'Entity[Decl].node' Fld_5 nodes.lkt:4260



--# expr-start 2606 DefId.decl Fld_4 nodes.lkt:4260







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start DefId.decl
Fld_4 := Liblktlang.Implementation.Def_Id_P_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2606





Fld_5 := Fld_4.Node;
--# expr-done 2607
Is_Equal := Cast_Result_1 = Fld_5; 
--# expr-done 2608
Scope_Result := Is_Equal;


   --# end


   Result_Var := Scope_Result;
else
   
   Result_Var := False;
end if;



--# expr-done 2609
if Result_Var then
   --# expr-start 2611 .singleton Singleton nodes.lkt:4262
--# expr-start 2610 Cast Cast_Result_2 nodes.lkt:4262









   if Current_Node.Node = null
      or else Current_Node.Node.Kind in Lkt_Ref_Id_Range
   then
      
      Cast_Result_2 := Create_Internal_Entity_Ref_Id
        (Node => Current_Node.Node,
         Info => Current_Node.Info);

   else
         Cast_Result_2 := No_Entity_Ref_Id;
   end if;


--# expr-done 2610
            Singleton := Create_Internal_Entity_Ref_Id_Array (Items_Count => 1);
            Singleton.Items (1) := Cast_Result_2;
            
        
--# expr-done 2611
   If_Result_1 := Singleton;
else
   --# expr-start 2616 .mapcat Map_Result nodes.lkt:4263








   

   --# expr-start 2612 .children Fld nodes.lkt:4263







   if Current_Node.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Children (Node => Current_Node.Node, E_Info => Current_Node.Info);
--# expr-done 2612

   
      declare
         Map_Result_Vec : Internal_Entity_Ref_Id_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind child Item

            
         
         
      --# expr-start 2615 If If_Result nodes.lkt:4265



--# expr-start 2613 .is_null Is_Null nodes.lkt:4265

Is_Null := Item.Node = null; 
--# expr-done 2613
if Is_Null then
   
   If_Result := No_Internal_Entity_Ref_Id_Array_Type;
else
   --# expr-start 2614 DefId.find_all_references_helper Fld_1 nodes.lkt:4267







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start DefId.find_all_references_helper
Fld_1 := Liblktlang.Implementation.Def_Id_P_Find_All_References_Helper (Node => Ent.Node, Current_Node => Item, E_Info => Ent.Info);
--# end
--# expr-done 2614
   If_Result := Fld_1;
end if;

      Inc_Ref (If_Result);


--# expr-done 2615
      

         for Item_To_Append of
               If_Result.Items
         loop
            Internal_Entity_Ref_Id_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end loop;

   
   
   

            
   --# end
      Finalizer_Scope_770;



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Entity_Ref_Id_Array
           (Items_Count => Natural (Internal_Entity_Ref_Id_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Ref_Id_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Ref_Id_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Ref_Id_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 2616
   If_Result_1 := Map_Result;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 2617

         Property_Result := If_Result_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_326;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_326;
                     Finalizer_Scope_770;




            raise;
      end;



   return Property_Result;
end Def_Id_P_Find_All_References_Helper;
--# end

   







--# property-start DefId.find_all_references nodes.lkt:4272
pragma Warnings (Off, "is not referenced");

function Def_Id_P_Find_All_References
  
  (Node : Bare_Def_Id
      ; Units : Internal_Unit_Array_Access
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Ref_Result_Array_Access
is
   Self : Bare_Def_Id :=
     Bare_Def_Id (Node);
     Ent : Internal_Entity_Def_Id :=
       Internal_Entity_Def_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind units Units

   Property_Result : Internal_Ref_Result_Array_Access;

      
            procedure Finalizer_Scope_328 with Inline_Always;
            procedure Finalizer_Scope_772 with Inline_Always;

      Fld : Bare_Lkt_Node;
As_Entity : Internal_Entity;
Is_Null : Boolean;
If_Result : Internal_Entity;
Fld_1 : Internal_Entity_Ref_Id_Array_Access;
Map_Result : Internal_Entity_Ref_Id_Array_Access;
New_Struct : Internal_Ref_Result;
Map_Result_1 : Internal_Ref_Result_Array_Access;

            procedure Finalizer_Scope_328 is
            begin
                     Dec_Ref (Map_Result);
                     Dec_Ref (Map_Result_1);
            end Finalizer_Scope_328;
            procedure Finalizer_Scope_772 is
            begin
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_772;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 2623 .map Map_Result_1 nodes.lkt:4274








   

   --# expr-start 2621 .mapcat Map_Result nodes.lkt:4274








   

   

   
      declare
         Map_Result_Vec : Internal_Entity_Ref_Id_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Unit_Array_Access := Units;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind unit Item

            
         
         
      --# expr-start 2620 DefId.find_all_references_helper Fld_1 nodes.lkt:4275







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 2619 .as_entity If_Result nodes.lkt:4275



--# expr-start 2618 AnalysisUnit.root Fld nodes.lkt:4275







   if Item = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Item.Ast_Root;
--# expr-done 2618
Is_Null := Fld = null; 
if Is_Null then
   
   If_Result := No_Entity;
else
   

As_Entity := (Info => E_Info, Node => Fld); 
   If_Result := As_Entity;
end if;



--# expr-done 2619
--# property-call-start DefId.find_all_references_helper
Fld_1 := Liblktlang.Implementation.Def_Id_P_Find_All_References_Helper (Node => Ent.Node, Current_Node => If_Result, E_Info => Ent.Info);
--# end
--# expr-done 2620
      

         for Item_To_Append of
               Fld_1.Items
         loop
            Internal_Entity_Ref_Id_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end loop;

   
   
   

            
   --# end
      Finalizer_Scope_772;



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Entity_Ref_Id_Array
           (Items_Count => Natural (Internal_Entity_Ref_Id_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Ref_Id_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Ref_Id_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Ref_Id_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 2621

   
      declare
         Map_Result_1_Vec : Internal_Ref_Result_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Ref_Id_Array_Access := Map_Result;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind r Item_1

            
         
         
      --# expr-start 2622 'New[RefResult]' New_Struct nodes.lkt:4276

New_Struct := (Ref => Item_1); 
--# expr-done 2622
      

         declare
            Item_To_Append : constant Internal_Ref_Result := New_Struct;
         begin
            Internal_Ref_Result_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result_1 := Create_Internal_Ref_Result_Array
           (Items_Count => Natural (Internal_Ref_Result_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Internal_Ref_Result_Vectors.Get
              (Map_Result_1_Vec,
               I + Internal_Ref_Result_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Internal_Ref_Result_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 2623

         Property_Result := Map_Result_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_328;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_328;
                     Finalizer_Scope_772;




            raise;
      end;



   return Property_Result;
end Def_Id_P_Find_All_References;
--# end



   


      

   --
   --  Primitives for Bare_Module_Ref_Id
   --

   



      
      procedure Initialize_Fields_For_Module_Ref_Id
        (Self : Bare_Module_Ref_Id
        ) is
      begin
            Initialize_Fields_For_Id
              (Self);

         

      end Initialize_Fields_For_Module_Ref_Id;




   


      

   --
   --  Primitives for Bare_Ref_Id
   --

   



      
      procedure Initialize_Fields_For_Ref_Id
        (Self : Bare_Ref_Id
        ) is
      begin
            Initialize_Fields_For_Id
              (Self);

         
      Self.Ref_Id_F_Ref_Var := Null_Var_Record;

      end Initialize_Fields_For_Ref_Id;


   







--# property-start RefId.from_node nodes.lkt:4292
pragma Warnings (Off, "is not referenced");

function Ref_Id_P_From_Node
  
  (Node : Bare_Ref_Id
  )

   return Bare_Lkt_Node
is
   Self : Bare_Ref_Id :=
     Bare_Ref_Id (Node);
      --# bind node Self

   


   Property_Result : Bare_Lkt_Node;

      
            procedure Finalizer_Scope_329 with Inline_Always;

      Node_Parents : Bare_Lkt_Node_Array_Access;
Fld : Bare_Lkt_Node;
Is_A : Boolean;
Fld_1 : Bare_Lkt_Node;
Var_Expr : Bare_Lkt_Node;
Fld_2 : Bare_Lkt_Node;
Is_A_1 : Boolean;
Scope_Result : Boolean;
Result_Var : Boolean;
If_Result : Boolean;
Find_Result : Bare_Lkt_Node;

            procedure Finalizer_Scope_329 is
            begin
                     Dec_Ref (Node_Parents);
            end Finalizer_Scope_329;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 2632 .find Find_Result nodes.lkt:4293








   

   --# expr-start 2624 LktNode.parents Node_Parents nodes.lkt:4293







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



Node_Parents := Parents (Self, True); 
--# expr-done 2624

   
      Find_Result := No_Bare_Lkt_Node;
   

   

      

      declare
         
         Collection : constant Bare_Lkt_Node_Array_Access := Node_Parents;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind p Item

            
      --# expr-start 2631 BooleanOr If_Result nodes.lkt:4295



--# expr-start 2626 IsA Is_A nodes.lkt:4295
--# expr-start 2625 .parent Fld nodes.lkt:4295







   if Item = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Item.Parent; 
--# expr-done 2625
Is_A := Fld /= null 
and then Fld.Kind in Lkt_Block_Expr_Range | Lkt_Base_Match_Branch | Lkt_Lambda_Expr_Range | Lkt_Fun_Decl_Range; 
--# expr-done 2626
if Is_A then
   
   If_Result := True;
else
   --# expr-start 2630 .do Result_Var nodes.lkt:4296



--# expr-start 2627 .parent Fld_1 nodes.lkt:4296







   if Item = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Item.Parent; 
--# expr-done 2627
Var_Expr := Fld_1;





if Var_Expr /= No_Bare_Lkt_Node then
   



   --# scope-start



--# expr-start 2629 IsA Is_A_1 nodes.lkt:4296
--# expr-start 2628 .parent Fld_2 nodes.lkt:4296







   if Var_Expr = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Var_Expr.Parent; 
--# expr-done 2628
Is_A_1 := Fld_2 /= null 
and then Fld_2.Kind in Lkt_Block_Expr_Range; 
--# expr-done 2629
Scope_Result := Is_A_1;


   --# end


   Result_Var := Scope_Result;
else
   
   Result_Var := False;
end if;



--# expr-done 2630
   If_Result := Result_Var;
end if;



--# expr-done 2631
      if If_Result then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when If_Result;

         end loop;
      end;
   

   
   



--# expr-done 2632

         Property_Result := Find_Result;
         
   --# end
      Finalizer_Scope_329;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_329;




            raise;
      end;



   return Property_Result;
end Ref_Id_P_From_Node;
--# end

   







--# property-start RefId.first_var_in_env nodes.lkt:4303
pragma Warnings (Off, "is not referenced");

function Ref_Id_P_First_Var_In_Env
  
  (Node : Bare_Ref_Id
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Decl
is
   Self : Bare_Ref_Id :=
     Bare_Ref_Id (Node);
     Ent : Internal_Entity_Ref_Id :=
       Internal_Entity_Ref_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Decl;

      
            procedure Finalizer_Scope_776 with Inline_Always;
            procedure Finalizer_Scope_777 with Inline_Always;

      Fld : Lexical_Env := Empty_Env;
Fld_1 : Bare_Ref_Id;
Sym : Symbol_Type;
Fld_2 : Bare_Lkt_Node;
Env_Get_Result : Internal_Entity_Array_Access;
Fld_3 : Internal_Entity_Array_Access;
Is_Equiv : Boolean;
Quantifier_Result : Boolean;
Not_Val : Boolean;
Map_Result : Internal_Entity_Array_Access;
Local_First_Decls : Internal_Entity_Array_Access;
Is_A : Boolean;
Not_Val_1 : Boolean;
Find_Result : Internal_Entity;
Cast_Result : Internal_Entity_Base_Val_Decl;
Fld_4 : Lexical_Env := Empty_Env;
Fld_5 : Bare_Ref_Id;
Sym_1 : Symbol_Type;
Env_Get_Result_1 : Internal_Entity;
Cast_Result_1 : Internal_Entity_Decl;
Var_Expr : Internal_Entity_Decl;
Fld_6 : Internal_Entity_Decl;
Var_Expr_1 : Internal_Entity_Decl;
Is_A_1 : Boolean;
Cast_Result_2 : Internal_Entity_Fun_Decl;
Var_Expr_2 : Internal_Entity_Fun_Decl;
Fld_7 : Bare_Type_Decl;
Is_Null : Boolean;
Result_Var : Boolean;
If_Result : Boolean;
If_Result_1 : Internal_Entity_Decl;
Scope_Result : Internal_Entity_Decl;
Result_Var_1 : Internal_Entity_Decl;
Result_Var_2 : Internal_Entity_Decl;
Left_Var : Internal_Entity_Base_Val_Decl;
Cast_Result_3 : Internal_Entity_Decl;
Result_Var_3 : Internal_Entity_Decl;
Get_Result : Internal_Entity;
Cast_Result_4 : Internal_Entity_Decl;
Left_Var_1 : Internal_Entity_Decl;
Result_Var_4 : Internal_Entity_Decl;
Let_Result : Internal_Entity_Decl;
Scope_Result_1 : Internal_Entity_Decl;

            procedure Finalizer_Scope_776 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Env_Get_Result);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Local_First_Decls);
                     Dec_Ref (Fld_4);
            end Finalizer_Scope_776;
            procedure Finalizer_Scope_777 is
            begin
                     Dec_Ref (Fld_3);
            end Finalizer_Scope_777;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Ref_Id_Ref_Id_P_First_Var_In_Env,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Ref_Id,
                                As_Bare_Ref_Id => Self);
               Mmz_K.Items (2) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Entity_Decl;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 2661 ValDecl Let_Result nodes.lkt:4304
--# scope-start
--# expr-start 2640 .filter Map_Result nodes.lkt:4305








   

   --# expr-start 2636 .get Env_Get_Result nodes.lkt:4305
--# expr-start 2633 LktNode.node_env Fld nodes.lkt:4305







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Node_Env (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 2633
--# expr-start 2634 .symbol Sym nodes.lkt:4305









Fld_1 := Ent.Node; 
Sym := Get_Symbol (Fld_1); 
--# expr-done 2634


--# expr-start 2635 RefId.from_node Fld_2 nodes.lkt:4305







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start RefId.from_node
Fld_2 := Liblktlang.Implementation.Ref_Id_P_From_Node (Node => Self);
--# end
--# expr-done 2635
Env_Get_Result := Construct_Entity_Array (AST_Envs.Get (Self => Fld, Key => Thin (Sym), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True), From => Fld_2)); 
--# expr-done 2636

   
      declare
         Map_Result_Vec : Internal_Entity_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Env_Get_Result;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind d Item

            
         --# expr-start 2639 Not Not_Val nodes.lkt:4306
--# expr-start 2638 .contains Quantifier_Result nodes.lkt:4306








   

   --# expr-start 2637 LktNode.parents Fld_3 nodes.lkt:4306







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



Fld_3 := Liblktlang.Implementation.Parents (Node => Ent.Node, With_Self => True, E_Info => Ent.Info);
--# expr-done 2637

   
      Quantifier_Result := False;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Fld_3;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start



            
      

Is_Equiv := Equivalent (Item_1, Item); 
      Quantifier_Result := Is_Equiv;
   

            
   --# end


               exit when Quantifier_Result;

         end loop;
      end;
   

   
   



--# expr-done 2638
Not_Val := not (Quantifier_Result); 
--# expr-done 2639
         if Not_Val then
            
         
      
      

         declare
            Item_To_Append : constant Internal_Entity := Item;
         begin
            Internal_Entity_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
         end if;
   

            
   --# end
      Finalizer_Scope_777;



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Entity_Array
           (Items_Count => Natural (Internal_Entity_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 2640
Local_First_Decls := Map_Result; Inc_Ref (Local_First_Decls);
--# bind first_decls Local_First_Decls
--# expr-start 2660 'or?' Result_Var_4 nodes.lkt:4307



--# expr-start 2657 'or?' Result_Var_3 nodes.lkt:4307



--# expr-start 2644 Cast Cast_Result nodes.lkt:4307





--# expr-start 2643 .find Find_Result nodes.lkt:4307








   

   

   
      Find_Result := No_Entity;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Array_Access := Local_First_Decls;
      begin
         for Item_2 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind d Item_2

            
      --# expr-start 2642 Not Not_Val_1 nodes.lkt:4307
--# expr-start 2641 IsA Is_A nodes.lkt:4307

Is_A := Item_2.Node /= null 
and then Item_2.Node.Kind in Lkt_Field_Decl_Range; 
--# expr-done 2641
Not_Val_1 := not (Is_A); 
--# expr-done 2642
      if Not_Val_1 then
         Find_Result := Item_2; 
      end if;
   

            
   --# end


               exit when Not_Val_1;

         end loop;
      end;
   

   
   



--# expr-done 2643



   if Find_Result.Node = null
      or else Find_Result.Node.Kind in Lkt_Base_Val_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Base_Val_Decl
        (Node => Find_Result.Node,
         Info => Find_Result.Info);

   else
         Cast_Result := No_Entity_Base_Val_Decl;
   end if;


--# expr-done 2644
Left_Var := Cast_Result;





if Left_Var /= No_Entity_Base_Val_Decl then
   








   
      Cast_Result_3 := Create_Internal_Entity_Decl
        (Node => Left_Var.Node,
         Info => Left_Var.Info);


   Result_Var_3 := Cast_Result_3;
else
   


--# expr-start 2648 Cast Cast_Result_1 nodes.lkt:4308





--# expr-start 2647 .get_first Env_Get_Result_1 nodes.lkt:4308
--# expr-start 2645 LktNode.node_env Fld_4 nodes.lkt:4308







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Liblktlang.Implementation.Node_Env (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 2645
--# expr-start 2646 .symbol Sym_1 nodes.lkt:4308









Fld_5 := Ent.Node; 
Sym_1 := Get_Symbol (Fld_5); 
--# expr-done 2646


Env_Get_Result_1 := AST_Envs.Get_First (Self => Fld_4, Key => Thin (Sym_1), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 2647



   if Env_Get_Result_1.Node = null
      or else Env_Get_Result_1.Node.Kind in Lkt_Decl
   then
      
      Cast_Result_1 := Create_Internal_Entity_Decl
        (Node => Env_Get_Result_1.Node,
         Info => Env_Get_Result_1.Info);

   else
         Cast_Result_1 := No_Entity_Decl;
   end if;


--# expr-done 2648
Var_Expr := Cast_Result_1;





if Var_Expr /= No_Entity_Decl then
   --# expr-start 2656 .do Result_Var_1 nodes.lkt:4308



--# expr-start 2649 Decl.subdecl_if_generic Fld_6 nodes.lkt:4308







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.subdecl_if_generic
Fld_6 := Liblktlang.Implementation.Decl_P_Subdecl_If_Generic (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 2649
Var_Expr_1 := Fld_6;





if Var_Expr_1 /= No_Entity_Decl then
   



   --# scope-start



--# expr-start 2655 If If_Result_1 nodes.lkt:4310



--# expr-start 2654 BooleanOr If_Result nodes.lkt:4310



--# expr-start 2650 IsA Is_A_1 nodes.lkt:4310

Is_A_1 := Var_Expr_1.Node /= null 
and then Var_Expr_1.Node.Kind in Lkt_Type_Decl; 
--# expr-done 2650
if Is_A_1 then
   
   If_Result := True;
else
   


--# expr-start 2651 Cast Cast_Result_2 nodes.lkt:4310









   if Var_Expr_1.Node = null
      or else Var_Expr_1.Node.Kind in Lkt_Fun_Decl_Range
   then
      
      Cast_Result_2 := Create_Internal_Entity_Fun_Decl
        (Node => Var_Expr_1.Node,
         Info => Var_Expr_1.Info);

   else
         Cast_Result_2 := No_Entity_Fun_Decl;
   end if;


--# expr-done 2651
Var_Expr_2 := Cast_Result_2;





if Var_Expr_2 /= No_Entity_Fun_Decl then
   --# expr-start 2653 .is_null Is_Null nodes.lkt:4310
--# expr-start 2652 FunDecl.owning_type Fld_7 nodes.lkt:4310







   if Var_Expr_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start FunDecl.owning_type
Fld_7 := Liblktlang.Implementation.Fun_Decl_P_Owning_Type (Node => Var_Expr_2.Node);
--# end
--# expr-done 2652
Is_Null := Fld_7 = null; 
--# expr-done 2653
   Result_Var := Is_Null;
else
   
   Result_Var := False;
end if;



   If_Result := Result_Var;
end if;



--# expr-done 2654
if If_Result then
   
   If_Result_1 := Var_Expr_1;
else
   
   If_Result_1 := No_Entity_Decl;
end if;



--# expr-done 2655
Scope_Result := If_Result_1;


   --# end


   Result_Var_1 := Scope_Result;
else
   
   Result_Var_1 := No_Entity_Decl;
end if;



--# expr-done 2656
   Result_Var_2 := Result_Var_1;
else
   
   Result_Var_2 := No_Entity_Decl;
end if;



   Result_Var_3 := Result_Var_2;
end if;



--# expr-done 2657
Left_Var_1 := Result_Var_3;





if Left_Var_1 /= No_Entity_Decl then
   
   Result_Var_4 := Left_Var_1;
else
   --# expr-start 2659 Cast Cast_Result_4 nodes.lkt:4316





--# expr-start 2658 .at Get_Result nodes.lkt:4316




Get_Result := Get (Self, Local_First_Decls, 0, True); 
--# expr-done 2658



   if Get_Result.Node = null
      or else Get_Result.Node.Kind in Lkt_Decl
   then
      
      Cast_Result_4 := Create_Internal_Entity_Decl
        (Node => Get_Result.Node,
         Info => Get_Result.Info);

   else
         Cast_Result_4 := No_Entity_Decl;
   end if;


--# expr-done 2659
   Result_Var_4 := Cast_Result_4;
end if;



--# expr-done 2660
Let_Result := Result_Var_4; 
--# end
--# expr-done 2661
Scope_Result_1 := Let_Result;


   --# end
      Finalizer_Scope_776;



         Property_Result := Scope_Result_1;
         
   --# end


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_776;
                     Finalizer_Scope_777;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Entity_Decl,
                     As_Internal_Entity_Decl => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Ref_Id_P_First_Var_In_Env;
--# end

   







--# property-start RefId.is_being_called nodes.lkt:4320
pragma Warnings (Off, "is not referenced");

function Ref_Id_P_Is_Being_Called
  
  (Node : Bare_Ref_Id
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Ref_Id :=
     Bare_Ref_Id (Node);
     Ent : Internal_Entity_Ref_Id :=
       Internal_Entity_Ref_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Fld : Internal_Entity;
Is_A : Boolean;
Fld_1 : Internal_Entity;
Cast_Result : Internal_Entity_Dot_Expr;
Var_Expr : Internal_Entity_Dot_Expr;
Fld_2 : Internal_Entity_Ref_Id;
Cast_Result_1 : Internal_Entity;
Cast_Result_2 : Internal_Entity;
Is_Equiv : Boolean;
Fld_3 : Internal_Entity;
Is_A_1 : Boolean;
If_Result : Boolean;
Scope_Result : Boolean;
Result_Var : Boolean;
If_Result_1 : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 2672 BooleanOr If_Result_1 nodes.lkt:4321



--# expr-start 2663 IsA Is_A nodes.lkt:4321
--# expr-start 2662 .parent Fld nodes.lkt:4321







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Parent (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 2662
Is_A := Fld.Node /= null 
and then Fld.Node.Kind in Lkt_Base_Call_Expr; 
--# expr-done 2663
if Is_A then
   
   If_Result_1 := True;
else
   --# expr-start 2671 .do Result_Var nodes.lkt:4322



--# expr-start 2665 Cast Cast_Result nodes.lkt:4322





--# expr-start 2664 .parent Fld_1 nodes.lkt:4322







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Liblktlang.Implementation.Parent (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 2664



   if Fld_1.Node = null
      or else Fld_1.Node.Kind in Lkt_Dot_Expr_Range
   then
      
      Cast_Result := Create_Internal_Entity_Dot_Expr
        (Node => Fld_1.Node,
         Info => Fld_1.Info);

   else
         Cast_Result := No_Entity_Dot_Expr;
   end if;


--# expr-done 2665
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Dot_Expr then
   



   --# scope-start



--# expr-start 2670 BooleanAnd If_Result nodes.lkt:4324



--# expr-start 2667 Eq Is_Equiv nodes.lkt:4324





--# expr-start 2666 DotExpr.suffix Fld_2 nodes.lkt:4324







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Ref_Id (Node => Var_Expr.Node.Dot_Expr_F_Suffix, Info => Var_Expr.Info);
--# expr-done 2666



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Fld_2.Node,
         Info => Fld_2.Info);











   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);


Is_Equiv := Equivalent (Cast_Result_1, Cast_Result_2); 
--# expr-done 2667
if Is_Equiv then
   --# expr-start 2669 IsA Is_A_1 nodes.lkt:4325
--# expr-start 2668 .parent Fld_3 nodes.lkt:4325







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Liblktlang.Implementation.Parent (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# expr-done 2668
Is_A_1 := Fld_3.Node /= null 
and then Fld_3.Node.Kind in Lkt_Base_Call_Expr; 
--# expr-done 2669
   If_Result := Is_A_1;
else
   
   If_Result := False;
end if;



--# expr-done 2670
Scope_Result := If_Result;


   --# end


   Result_Var := Scope_Result;
else
   
   Result_Var := False;
end if;



--# expr-done 2671
   If_Result_1 := Result_Var;
end if;



--# expr-done 2672

         Property_Result := If_Result_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Ref_Id_P_Is_Being_Called;
--# end

   







--# property-start RefId.referenced_decl nodes.lkt:4331
pragma Warnings (Off, "is not referenced");

function Ref_Id_P_Referenced_Decl
  
  (Node : Bare_Ref_Id
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Decl
is
   Self : Bare_Ref_Id :=
     Bare_Ref_Id (Node);
     Ent : Internal_Entity_Ref_Id :=
       Internal_Entity_Ref_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Decl;

      
            procedure Finalizer_Scope_332 with Inline_Always;

      Fld : Internal_Solver_Result := No_Solver_Result;
Fld_1 : Boolean;
Fld_2 : Logic_Var;
Is_Logic_Var_Defined : Boolean;
Eq_Solution : Internal_Entity;
If_Result : Internal_Entity;
Cast_Result : Internal_Entity_Decl;
If_Result_1 : Internal_Entity_Decl;

            procedure Finalizer_Scope_332 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_332;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Ref_Id_Ref_Id_P_Referenced_Decl,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Ref_Id,
                                As_Bare_Ref_Id => Self);
               Mmz_K.Items (2) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Entity_Decl;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 2678 If If_Result_1 nodes.lkt:4332



--# expr-start 2674 SolverResult.success Fld_1 nodes.lkt:4332



--# expr-start 2673 LktNode.solve_enclosing_context Fld nodes.lkt:4332







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.solve_enclosing_context
Fld := Liblktlang.Implementation.Lkt_Node_P_Solve_Enclosing_Context (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2673





Fld_1 := Fld.Success;
--# expr-done 2674
if Fld_1 then
   --# expr-start 2677 Cast Cast_Result nodes.lkt:4333





--# expr-start 2676 .get_value If_Result nodes.lkt:4333



--# expr-start 2675 RefId.ref_var Fld_2 nodes.lkt:4333







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Self.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2675
Is_Logic_Var_Defined := Entity_Vars.Is_Defined (Fld_2); 
if Is_Logic_Var_Defined then
   
Eq_Solution := Entity_Vars.Get_Value (Fld_2); 
   If_Result := Eq_Solution;
else
   
   If_Result := No_Entity;
end if;



--# expr-done 2676



   if If_Result.Node = null
      or else If_Result.Node.Kind in Lkt_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Decl
        (Node => If_Result.Node,
         Info => If_Result.Info);

   else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "invalid object cast");
   end if;


--# expr-done 2677
   If_Result_1 := Cast_Result;
else
   
   If_Result_1 := No_Entity_Decl;
end if;



--# expr-done 2678

         Property_Result := If_Result_1;
         
   --# end
      Finalizer_Scope_332;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_332;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Entity_Decl,
                     As_Internal_Entity_Decl => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Ref_Id_P_Referenced_Decl;
--# end

   







--# property-start RefId.xtype_equation nodes.lkt:4336
pragma Warnings (Off, "is not referenced");

function Ref_Id_P_Xtype_Equation
  
  (Node : Bare_Ref_Id
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Ref_Id :=
     Bare_Ref_Id (Node);
     Ent : Internal_Entity_Ref_Id :=
       Internal_Entity_Ref_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_333 with Inline_Always;
            procedure Finalizer_Scope_782 with Inline_Always;
            procedure Finalizer_Scope_783 with Inline_Always;
            procedure Finalizer_Scope_784 with Inline_Always;

      Fld : Lexical_Env := Empty_Env;
Fld_1 : Bare_Ref_Id;
Sym : Symbol_Type;
Env_Get_Result : Internal_Entity;
Cast_Result : Internal_Entity_Decl;
Var_Expr : Internal_Entity_Decl;
Fld_2 : Internal_Entity_Decl;
Result_Var : Internal_Entity_Decl;
Local_First_Var : Internal_Entity_Decl;
Fld_3 : Logic_Var;
Cast_Result_1 : Internal_Entity;
Bind_Result : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_4 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_2 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
Fld_5 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result_3 : Internal_Entity;
Bind_Result_1 : Logic_Equation;
And_Pred : Logic_Equation;
Is_Null : Boolean;
Error_Location_1 : Bare_Lkt_Node;
Fld_6 : Logic_Var;
Pred_1 : Logic_Equation;
Cast_Result_4 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_1 : Logic_Equation;
Scope_Result_1 : Logic_Equation;
If_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;
Let_Result : Logic_Equation;
Scope_Result_2 : Logic_Equation;

            procedure Finalizer_Scope_333 is
            begin
                     Dec_Ref (Scope_Result_2);
            end Finalizer_Scope_333;
            procedure Finalizer_Scope_782 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (If_Result);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Let_Result);
            end Finalizer_Scope_782;
            procedure Finalizer_Scope_783 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_783;
            procedure Finalizer_Scope_784 is
            begin
                     Dec_Ref (Pred_1);
                     Dec_Ref (Dyn_Var_Bind_Result_1);
            end Finalizer_Scope_784;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 2698 ValDecl Let_Result nodes.lkt:4337
--# scope-start



--# expr-start 2682 Cast Cast_Result nodes.lkt:4338





--# expr-start 2681 .get_first Env_Get_Result nodes.lkt:4338
--# expr-start 2679 LktNode.node_env Fld nodes.lkt:4338







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Node_Env (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 2679
--# expr-start 2680 .symbol Sym nodes.lkt:4338









Fld_1 := Ent.Node; 
Sym := Get_Symbol (Fld_1); 
--# expr-done 2680


Env_Get_Result := AST_Envs.Get_First (Self => Fld, Key => Thin (Sym), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 2681



   if Env_Get_Result.Node = null
      or else Env_Get_Result.Node.Kind in Lkt_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Decl
        (Node => Env_Get_Result.Node,
         Info => Env_Get_Result.Info);

   else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "invalid object cast");
   end if;


--# expr-done 2682
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Decl then
   --# expr-start 2683 Decl.subdecl_if_generic Fld_2 nodes.lkt:4338







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.subdecl_if_generic
Fld_2 := Liblktlang.Implementation.Decl_P_Subdecl_If_Generic (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 2683
   Result_Var := Fld_2;
else
   
   Result_Var := No_Entity_Decl;
end if;



Local_First_Var := Result_Var; 
--# bind first_var Local_First_Var
--# expr-start 2697 LogicAnd And_Pred_1 nodes.lkt:4342
--# expr-start 2685 LogicAssign Bind_Result nodes.lkt:4342
--# expr-start 2684 RefId.ref_var Fld_3 nodes.lkt:4342







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Ent.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2684
Fld_3.Value := No_Entity;
Entity_Vars.Reset (Fld_3);









   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Local_First_Var.Node,
         Info => Local_First_Var.Info);


Bind_Result := Solver.Create_Assign (Fld_3, Cast_Result_1, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4342:9") else null)); 
--# expr-done 2685
--# expr-start 2696 If If_Result nodes.lkt:4344



--# expr-start 2686 .is_null Is_Null nodes.lkt:4344

Is_Null := Local_First_Var.Node = null; 
--# expr-done 2686
if Is_Null then
   



   --# scope-start



--# expr-start 2689 bind Dyn_Var_Bind_Result_1 nodes.lkt:4346









   
      Cast_Result_4 := Self;


Error_Location_1 := Cast_Result_4; 
--# expr-start 2688 LogicPropagate Pred_1 nodes.lkt:4347
--# expr-start 2687 RefId.ref_var Fld_6 nodes.lkt:4347







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Ent.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2687
Fld_6.Value := No_Entity;
Entity_Vars.Reset (Fld_6);

Pred_1 := Solver.Create_Predicate (Fld_6, Create_Decl_P_Is_Defined_0_Predicate (Error_Location_1)); 
--# expr-done 2688
Dyn_Var_Bind_Result_1 := Pred_1; Inc_Ref (Dyn_Var_Bind_Result_1);
--# expr-done 2689
Scope_Result_1 := Dyn_Var_Bind_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_784;


   If_Result := Scope_Result_1;
else
   --# expr-start 2695 LogicAnd And_Pred nodes.lkt:4350




   --# scope-start



--# expr-start 2692 bind Dyn_Var_Bind_Result nodes.lkt:4351









   
      Cast_Result_2 := Self;


Error_Location := Cast_Result_2; 
--# expr-start 2691 LogicPropagate Pred nodes.lkt:4352
--# expr-start 2690 RefId.ref_var Fld_4 nodes.lkt:4352







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Ent.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2690
Fld_4.Value := No_Entity;
Entity_Vars.Reset (Fld_4);

Pred := Solver.Create_Predicate (Fld_4, Create_Decl_P_Is_Type_Decl_0_Predicate (Error_Location)); 
--# expr-done 2691
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2692
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_783;


--# expr-start 2694 LogicAssign Bind_Result_1 nodes.lkt:4354
--# expr-start 2693 Expr.actual_type_var Fld_5 nodes.lkt:4354







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2693
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result_3 := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_5, Cast_Result_3, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4354:22") else null)); 
--# expr-done 2694
And_Pred := Create_And (Scope_Result, Bind_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4350:17") else null)); 
--# expr-done 2695
   If_Result := And_Pred;
end if;

      Inc_Ref (If_Result);


--# expr-done 2696
And_Pred_1 := Create_And (Bind_Result, If_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4342:9") else null)); 
--# expr-done 2697
Let_Result := And_Pred_1; Inc_Ref (Let_Result);
--# end
--# expr-done 2698
Scope_Result_2 := Let_Result;
   Inc_Ref (Scope_Result_2);


   --# end
      Finalizer_Scope_782;



         Property_Result := Scope_Result_2;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_333;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_333;
                     Finalizer_Scope_782;
                     Finalizer_Scope_783;
                     Finalizer_Scope_784;




            raise;
      end;



   return Property_Result;
end Ref_Id_P_Xtype_Equation;
--# end

   







--# property-start RefId.referenced_defining_name nodes.lkt:4360
pragma Warnings (Off, "is not referenced");

function Ref_Id_P_Referenced_Defining_Name
  
  (Node : Bare_Ref_Id
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Def_Id
is
   Self : Bare_Ref_Id :=
     Bare_Ref_Id (Node);
     Ent : Internal_Entity_Ref_Id :=
       Internal_Entity_Ref_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Def_Id;

      

      Fld : Internal_Entity_Decl;
Fld_1 : Internal_Entity_Def_Id;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 2700 Decl.syn_name Fld_1 nodes.lkt:4362



--# expr-start 2699 RefId.referenced_decl Fld nodes.lkt:4362







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.referenced_decl'
Fld := Liblktlang.Implementation.Dispatcher_Expr_P_Referenced_Decl (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2699



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Def_Id (Node => Implementation.Decl_F_Syn_Name (Fld.Node), Info => Fld.Info);
--# expr-done 2700

         Property_Result := Fld_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Ref_Id_P_Referenced_Defining_Name;
--# end

   







--# property-start RefId.generic_type_equation nodes.lkt:4364
pragma Warnings (Off, "is not referenced");

function Ref_Id_P_Generic_Type_Equation
  
  (Node : Bare_Ref_Id
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Ref_Id :=
     Bare_Ref_Id (Node);
     Ent : Internal_Entity_Ref_Id :=
       Internal_Entity_Ref_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_335 with Inline_Always;

      Fld : Logic_Var;
Fld_1 : Internal_Entity_Decl;
Var_Expr : Internal_Entity_Decl;
Fld_2 : Internal_Entity_Function_Type;
Result_Var : Internal_Entity_Function_Type;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;

            procedure Finalizer_Scope_335 is
            begin
                     Dec_Ref (Bind_Result);
            end Finalizer_Scope_335;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2704 LogicAssign Bind_Result nodes.lkt:4366
--# expr-start 2701 Expr.generic_func_type_var Fld nodes.lkt:4366







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Ent.Node.Expr_F_Generic_Func_Type_Var'Unrestricted_Access;
--# expr-done 2701
Fld.Value := No_Entity;
Entity_Vars.Reset (Fld);








--# expr-start 2702 RefId.first_var_in_env Fld_1 nodes.lkt:4366







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start RefId.first_var_in_env
Fld_1 := Liblktlang.Implementation.Ref_Id_P_First_Var_In_Env (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2702
Var_Expr := Fld_1;





if Var_Expr /= No_Entity_Decl then
   --# expr-start 2703 Decl.function_type Fld_2 nodes.lkt:4366







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.function_type
Fld_2 := Liblktlang.Implementation.Decl_P_Function_Type (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 2703
   Result_Var := Fld_2;
else
   
   Result_Var := No_Entity_Function_Type;
end if;






   
      Cast_Result := Create_Internal_Entity
        (Node => Result_Var.Node,
         Info => Result_Var.Info);


Bind_Result := Solver.Create_Assign (Fld, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4366:9") else null)); 
--# expr-done 2704

         Property_Result := Bind_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_335;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_335;




            raise;
      end;



   return Property_Result;
end Ref_Id_P_Generic_Type_Equation;
--# end

   







--# property-start RefId.bind_actual_type_equation nodes.lkt:4369
pragma Warnings (Off, "is not referenced");

function Ref_Id_P_Bind_Actual_Type_Equation
  
  (Node : Bare_Ref_Id
      ; First_Var : Internal_Entity_Decl
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Ref_Id :=
     Bare_Ref_Id (Node);
     Ent : Internal_Entity_Ref_Id :=
       Internal_Entity_Ref_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   

   --# bind first_var First_Var

   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_336 with Inline_Always;
            procedure Finalizer_Scope_785 with Inline_Always;
            procedure Finalizer_Scope_790 with Inline_Always;
            procedure Finalizer_Scope_791 with Inline_Always;

      Ignored : Internal_Entity_Decl;
Fld : Logic_Var;
Ignored_1 : Internal_Entity_Type_Decl;
Local_Etd : Internal_Entity_Base_Val_Decl;
Fld_1 : Internal_Entity_Type_Decl;
Local_Gd : Internal_Entity_Generic_Decl;
Fld_2 : Internal_Entity_Decl;
Ignored_2 : Internal_Entity_Decl;
Match_Prefix : Internal_Entity_Decl;
Cast_Result : Internal_Entity_Type_Decl;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result_1 : Internal_Entity_Decl;
Let_Result : Internal_Entity_Decl;
Scope_Result : Internal_Entity_Decl;
Cast_Result_2 : Internal_Entity_Base_Val_Decl;
Cast_Result_3 : Internal_Entity_Decl;
Let_Result_1 : Internal_Entity_Decl;
Scope_Result_1 : Internal_Entity_Decl;
Cast_Result_4 : Internal_Entity_Generic_Decl;
Let_Result_2 : Internal_Entity_Decl;
Scope_Result_2 : Internal_Entity_Decl;
Cast_Result_5 : Internal_Entity_Decl;
Cast_Expr_1 : Internal_Entity_Type_Decl;
Cast_Result_6 : Internal_Entity_Decl;
Let_Result_3 : Internal_Entity_Decl;
Scope_Result_3 : Internal_Entity_Decl;
Match_Result : Internal_Entity_Decl;
Cast_Result_7 : Internal_Entity;
Bind_Result : Logic_Equation;
Match_Prefix_1 : Internal_Entity_Decl;
Cast_Result_8 : Internal_Entity_Decl;
Let_Result_4 : Logic_Equation;
Scope_Result_4 : Logic_Equation;
Match_Result_1 : Logic_Equation;
Fld_3 : Boolean;
Fld_4 : Internal_Entity_Function_Type;
Is_Null : Boolean;
Not_Val : Boolean;
If_Result : Boolean;
Var_Expr : Internal_Entity_Decl;
Fld_5 : Logic_Var;
Fld_6 : Internal_Entity_Function_Type;
Cast_Result_9 : Internal_Entity;
Bind_Result_1 : Logic_Equation;
Fld_7 : Logic_Var;
Fld_8 : Logic_Var;
Bind_Result_2 : Logic_Equation;
And_Pred : Logic_Equation;
Fld_9 : Boolean;
In_Logic_Call : Boolean;
Fld_10 : Logic_Var;
Fld_11 : Internal_Entity_Type_Decl;
Fld_12 : Internal_Entity_Type_Decl;
Cast_Result_10 : Internal_Entity_Function_Type;
Fld_13 : Internal_Entity_Function_Type;
Cast_Result_11 : Internal_Entity;
Bind_Result_3 : Logic_Equation;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result_5 : Logic_Equation;
Fld_14 : Logic_Var;
Fld_15 : Logic_Var;
Bind_Result_4 : Logic_Equation;
And_Pred_1 : Logic_Equation;
If_Result_1 : Logic_Equation;
Scope_Result_6 : Logic_Equation;
False_Rel : Logic_Equation;
Result_Var : Logic_Equation;
If_Result_2 : Logic_Equation;

            procedure Finalizer_Scope_336 is
            begin
                     Dec_Ref (Scope_Result_4);
                     Dec_Ref (Match_Result_1);
                     Dec_Ref (Scope_Result_6);
                     Dec_Ref (False_Rel);
                     Dec_Ref (Result_Var);
                     Dec_Ref (If_Result_2);
            end Finalizer_Scope_336;
            procedure Finalizer_Scope_785 is
            begin
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Let_Result_4);
            end Finalizer_Scope_785;
            procedure Finalizer_Scope_790 is
            begin
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (Bind_Result_2);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Scope_Result_5);
                     Dec_Ref (Bind_Result_4);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (If_Result_1);
            end Finalizer_Scope_790;
            procedure Finalizer_Scope_791 is
            begin
                     Dec_Ref (Bind_Result_3);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_791;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2738 If If_Result_2 nodes.lkt:4370



--# expr-start 2709 BooleanAnd If_Result nodes.lkt:4370



--# expr-start 2705 RefId.is_being_called Fld_3 nodes.lkt:4370







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start RefId.is_being_called
Fld_3 := Liblktlang.Implementation.Ref_Id_P_Is_Being_Called (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2705
if Fld_3 then
   --# expr-start 2708 Not Not_Val nodes.lkt:4370
--# expr-start 2707 .is_null Is_Null nodes.lkt:4370
--# expr-start 2706 Decl.function_type Fld_4 nodes.lkt:4370







   if First_Var.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.function_type
Fld_4 := Liblktlang.Implementation.Decl_P_Function_Type (Node => First_Var.Node, E_Info => First_Var.Info);
--# end
--# expr-done 2706
Is_Null := Fld_4.Node = null; 
--# expr-done 2707
Not_Val := not (Is_Null); 
--# expr-done 2708
   If_Result := Not_Val;
else
   
   If_Result := False;
end if;



--# expr-done 2709
if If_Result then
   --# expr-start 2731 .do Result_Var nodes.lkt:4373




Var_Expr := First_Var;





if Var_Expr /= No_Entity_Decl then
   



   --# scope-start



--# expr-start 2729 If If_Result_1 nodes.lkt:4375



--# expr-start 2710 Decl.is_generic Fld_9 nodes.lkt:4375







   if First_Var.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.is_generic
Fld_9 := Liblktlang.Implementation.Decl_P_Is_Generic (Node => First_Var.Node, E_Info => First_Var.Info);
--# end
--# expr-done 2710
if Fld_9 then
   --# expr-start 2721 LogicAnd And_Pred_1 nodes.lkt:4377




   --# scope-start



--# expr-start 2717 bind Dyn_Var_Bind_Result nodes.lkt:4378

In_Logic_Call := False; 
--# expr-start 2716 LogicAssign Bind_Result_3 nodes.lkt:4380
--# expr-start 2711 Expr.actual_type_var Fld_10 nodes.lkt:4380







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2711
Fld_10.Value := No_Entity;
Entity_Vars.Reset (Fld_10);





--# expr-start 2715 Decl.infer_function_type Fld_13 nodes.lkt:4381



--# expr-start 2712 Expr.get_generic_type Fld_11 nodes.lkt:4381







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_generic_type
Fld_11 := Liblktlang.Implementation.Expr_P_Get_Generic_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2712



   if Fld_11.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 2714 Cast Cast_Result_10 nodes.lkt:4382





--# expr-start 2713 Expr.get_expected_type Fld_12 nodes.lkt:4382







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_expected_type
Fld_12 := Liblktlang.Implementation.Expr_P_Get_Expected_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2713



   if Fld_12.Node = null
      or else Fld_12.Node.Kind in Lkt_Function_Type_Range
   then
      
      Cast_Result_10 := Create_Internal_Entity_Function_Type
        (Node => Fld_12.Node,
         Info => Fld_12.Info);

   else
         Cast_Result_10 := No_Entity_Function_Type;
   end if;


--# expr-done 2714
--# property-call-start Decl.infer_function_type
Fld_13 := Liblktlang.Implementation.Decl_P_Infer_Function_Type (Node => Fld_11.Node, Expected_Call => Cast_Result_10, In_Logic_Call => In_Logic_Call, E_Info => Fld_11.Info);
--# end
--# expr-done 2715



   
      Cast_Result_11 := Create_Internal_Entity
        (Node => Fld_13.Node,
         Info => Fld_13.Info);


Bind_Result_3 := Solver.Create_Assign (Fld_10, Cast_Result_11, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4380:25") else null)); 
--# expr-done 2716
Dyn_Var_Bind_Result := Bind_Result_3; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2717
Scope_Result_5 := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result_5);


   --# end
      Finalizer_Scope_791;


--# expr-start 2720 LogicPropagate Bind_Result_4 nodes.lkt:4385
--# expr-start 2718 RefId.ref_var Fld_15 nodes.lkt:4386







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_15 := Ent.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2718
Fld_15.Value := No_Entity;
Entity_Vars.Reset (Fld_15);
--# expr-start 2719 Expr.generic_func_type_var Fld_14 nodes.lkt:4385







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_14 := Ent.Node.Expr_F_Generic_Func_Type_Var'Unrestricted_Access;
--# expr-done 2719
Fld_14.Value := No_Entity;
Entity_Vars.Reset (Fld_14);

Bind_Result_4 := Solver.Create_Propagate (Fld_15, Fld_14, Create_Decl_P_Function_Type_0_Functor); 
--# expr-done 2720
And_Pred_1 := Create_And (Scope_Result_5, Bind_Result_4, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4377:21") else null)); 
--# expr-done 2721
   If_Result_1 := And_Pred_1;
else
   --# expr-start 2728 LogicAnd And_Pred nodes.lkt:4388
--# expr-start 2724 LogicAssign Bind_Result_1 nodes.lkt:4388
--# expr-start 2722 Expr.actual_type_var Fld_5 nodes.lkt:4388







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2722
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);





--# expr-start 2723 Decl.function_type Fld_6 nodes.lkt:4388







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.function_type
Fld_6 := Liblktlang.Implementation.Decl_P_Function_Type (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 2723



   
      Cast_Result_9 := Create_Internal_Entity
        (Node => Fld_6.Node,
         Info => Fld_6.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_5, Cast_Result_9, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4388:21") else null)); 
--# expr-done 2724
--# expr-start 2727 LogicUnify Bind_Result_2 nodes.lkt:4389
--# expr-start 2725 Expr.generic_func_type_var Fld_7 nodes.lkt:4389







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Ent.Node.Expr_F_Generic_Func_Type_Var'Unrestricted_Access;
--# expr-done 2725
Fld_7.Value := No_Entity;
Entity_Vars.Reset (Fld_7);
--# expr-start 2726 Expr.actual_type_var Fld_8 nodes.lkt:4389







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2726
Bind_Result_2 := Solver.Create_Unify (Fld_7, Fld_8, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4389:26") else null)); 
--# expr-done 2727
And_Pred := Create_And (Bind_Result_1, Bind_Result_2, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4388:21") else null)); 
--# expr-done 2728
   If_Result_1 := And_Pred;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 2729
Scope_Result_6 := If_Result_1;
   Inc_Ref (Scope_Result_6);


   --# end
      Finalizer_Scope_790;


   Result_Var := Scope_Result_6;
else
   --# expr-start 2730 LogicFalse False_Rel nodes.lkt:4390
False_Rel := Solver.Create_False ((if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4390:29") else null)); 
--# expr-done 2730
   Result_Var := False_Rel;
end if;

      Inc_Ref (Result_Var);


--# expr-done 2731
   If_Result_2 := Result_Var;
else
   --# expr-start 2737 Match Match_Result_1 nodes.lkt:4394










   if First_Var.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix_1 := First_Var; 

case Lkt_Decl (Match_Prefix_1.Node.Kind) is
         when Lkt_Grammar_Rule_Decl .. Lkt_Trait_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_8 := Create_Internal_Entity_Decl
        (Node => Match_Prefix_1.Node,
         Info => Match_Prefix_1.Info);


Ignored := Cast_Result_8; 
--# bind _ Ignored
--# expr-start 2736 LogicAssign Bind_Result nodes.lkt:4396
--# expr-start 2732 Expr.actual_type_var Fld nodes.lkt:4396







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2732
Fld.Value := No_Entity;
Entity_Vars.Reset (Fld);





--# expr-start 2735 Match Match_Result nodes.lkt:4397










   if First_Var.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := First_Var; 

case Lkt_Decl (Match_Prefix.Node.Kind) is
         when Lkt_Any_Type_Decl .. Lkt_Trait_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_1 := Cast_Result; 
--# bind _ Ignored_1






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result_1 := Create_Internal_Entity_Decl
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Let_Result := Cast_Result_1; 
--# end
Scope_Result := Let_Result;


   --# end


            Match_Result := Scope_Result; 
         when Lkt_Node_Decl .. Lkt_Fun_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_2 := Create_Internal_Entity_Base_Val_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Etd := Cast_Result_2; 
--# bind etd Local_Etd





--# expr-start 2733 Decl.get_type Fld_1 nodes.lkt:4399







   if Local_Etd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.get_type
Fld_1 := Liblktlang.Implementation.Decl_P_Get_Type (Node => Local_Etd.Node, E_Info => Local_Etd.Info);
--# end
--# expr-done 2733



   
      Cast_Result_3 := Create_Internal_Entity_Decl
        (Node => Fld_1.Node,
         Info => Fld_1.Info);


Let_Result_1 := Cast_Result_3; 
--# end
Scope_Result_1 := Let_Result_1;


   --# end


            Match_Result := Scope_Result_1; 
         when Lkt_Generic_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_4 := Create_Internal_Entity_Generic_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Gd := Cast_Result_4; 
--# bind gd Local_Gd
--# expr-start 2734 GenericDecl.decl Fld_2 nodes.lkt:4400







   if Local_Gd.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Decl (Node => Local_Gd.Node.Generic_Decl_F_Decl, Info => Local_Gd.Info);
--# expr-done 2734
Let_Result_2 := Fld_2; 
--# end
Scope_Result_2 := Let_Result_2;


   --# end


            Match_Result := Scope_Result_2; 
         when Lkt_Grammar_Rule_Decl .. Lkt_Synthetic_Lexer_Decl | Lkt_Env_Spec_Decl .. Lkt_Error_Decl | Lkt_Grammar_Decl .. Lkt_Synth_Param_Decl =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_5 := Create_Internal_Entity_Decl
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored_2 := Cast_Result_5; 
--# bind _ Ignored_2






Cast_Expr_1 := raise Property_Error with "Unreachable"; 



   
      Cast_Result_6 := Create_Internal_Entity_Decl
        (Node => Cast_Expr_1.Node,
         Info => Cast_Expr_1.Info);


Let_Result_3 := Cast_Result_6; 
--# end
Scope_Result_3 := Let_Result_3;


   --# end


            Match_Result := Scope_Result_3; 
end case;

--# expr-done 2735



   
      Cast_Result_7 := Create_Internal_Entity
        (Node => Match_Result.Node,
         Info => Match_Result.Info);


Bind_Result := Solver.Create_Assign (Fld, Cast_Result_7, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4396:21") else null)); 
--# expr-done 2736
Let_Result_4 := Bind_Result; Inc_Ref (Let_Result_4);
--# end
Scope_Result_4 := Let_Result_4;
   Inc_Ref (Scope_Result_4);


   --# end
      Finalizer_Scope_785;


            Match_Result_1 := Scope_Result_4; Inc_Ref (Match_Result_1);
end case;

--# expr-done 2737
   If_Result_2 := Match_Result_1;
end if;

      Inc_Ref (If_Result_2);


--# expr-done 2738

         Property_Result := If_Result_2;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_336;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_336;
                     Finalizer_Scope_785;
                     Finalizer_Scope_790;
                     Finalizer_Scope_791;




            raise;
      end;



   return Property_Result;
end Ref_Id_P_Bind_Actual_Type_Equation;
--# end

   







--# property-start RefId.xref_equation nodes.lkt:4408
pragma Warnings (Off, "is not referenced");

function Ref_Id_P_Xref_Equation
  
  (Node : Bare_Ref_Id
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Ref_Id :=
     Bare_Ref_Id (Node);
     Ent : Internal_Entity_Ref_Id :=
       Internal_Entity_Ref_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_337 with Inline_Always;
            procedure Finalizer_Scope_792 with Inline_Always;
            procedure Finalizer_Scope_793 with Inline_Always;
            procedure Finalizer_Scope_794 with Inline_Always;

      Fld : Internal_Entity_Decl;
Local_First_Var : Internal_Entity_Decl;
Fld_1 : Logic_Var;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
Fld_2 : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_3 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred : Logic_Equation;
Is_Null : Boolean;
Fld_4 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result_2 : Internal_Entity;
Bind_Result_1 : Logic_Equation;
Error_Location_1 : Bare_Lkt_Node;
Fld_5 : Logic_Var;
Pred_1 : Logic_Equation;
Cast_Result_3 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_1 : Logic_Equation;
Scope_Result_1 : Logic_Equation;
And_Pred_1 : Logic_Equation;
If_Result : Logic_Equation;
And_Pred_2 : Logic_Equation;
Let_Result : Logic_Equation;
Scope_Result_2 : Logic_Equation;

            procedure Finalizer_Scope_337 is
            begin
                     Dec_Ref (Scope_Result_2);
            end Finalizer_Scope_337;
            procedure Finalizer_Scope_792 is
            begin
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Fld_2);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (If_Result);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Let_Result);
            end Finalizer_Scope_792;
            procedure Finalizer_Scope_793 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_793;
            procedure Finalizer_Scope_794 is
            begin
                     Dec_Ref (Pred_1);
                     Dec_Ref (Dyn_Var_Bind_Result_1);
            end Finalizer_Scope_794;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 2756 ValDecl Let_Result nodes.lkt:4409
--# scope-start
--# expr-start 2739 RefId.first_var_in_env Fld nodes.lkt:4409







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start RefId.first_var_in_env
Fld := Liblktlang.Implementation.Ref_Id_P_First_Var_In_Env (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2739
Local_First_Var := Fld; 
--# bind first_var Local_First_Var
--# expr-start 2755 LogicAnd And_Pred_2 nodes.lkt:4411
--# expr-start 2741 LogicAssign Bind_Result nodes.lkt:4411
--# expr-start 2740 RefId.ref_var Fld_1 nodes.lkt:4411







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Ent.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2740
Fld_1.Value := No_Entity;
Entity_Vars.Reset (Fld_1);









   
      Cast_Result := Create_Internal_Entity
        (Node => Local_First_Var.Node,
         Info => Local_First_Var.Info);


Bind_Result := Solver.Create_Assign (Fld_1, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4411:9") else null)); 
--# expr-done 2741
--# expr-start 2754 If If_Result nodes.lkt:4413



--# expr-start 2742 .is_null Is_Null nodes.lkt:4413

Is_Null := Local_First_Var.Node = null; 
--# expr-done 2742
if Is_Null then
   --# expr-start 2748 LogicAnd And_Pred_1 nodes.lkt:4415
--# expr-start 2744 LogicAssign Bind_Result_1 nodes.lkt:4415
--# expr-start 2743 Expr.actual_type_var Fld_4 nodes.lkt:4415







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2743
Fld_4.Value := No_Entity;
Entity_Vars.Reset (Fld_4);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_4, Cast_Result_2, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4415:17") else null)); 
--# expr-done 2744




   --# scope-start



--# expr-start 2747 bind Dyn_Var_Bind_Result_1 nodes.lkt:4417









   
      Cast_Result_3 := Self;


Error_Location_1 := Cast_Result_3; 
--# expr-start 2746 LogicPropagate Pred_1 nodes.lkt:4418
--# expr-start 2745 RefId.ref_var Fld_5 nodes.lkt:4418







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Ent.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2745
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);

Pred_1 := Solver.Create_Predicate (Fld_5, Create_Decl_P_Is_Defined_0_Predicate (Error_Location_1)); 
--# expr-done 2746
Dyn_Var_Bind_Result_1 := Pred_1; Inc_Ref (Dyn_Var_Bind_Result_1);
--# expr-done 2747
Scope_Result_1 := Dyn_Var_Bind_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_794;


And_Pred_1 := Create_And (Bind_Result_1, Scope_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4415:17") else null)); 
--# expr-done 2748
   If_Result := And_Pred_1;
else
   --# expr-start 2753 LogicAnd And_Pred nodes.lkt:4420
--# expr-start 2749 RefId.bind_actual_type_equation Fld_2 nodes.lkt:4420







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start RefId.bind_actual_type_equation
Fld_2 := Liblktlang.Implementation.Ref_Id_P_Bind_Actual_Type_Equation (Node => Ent.Node, First_Var => Local_First_Var, E_Info => Ent.Info);
--# end
--# expr-done 2749




   --# scope-start



--# expr-start 2752 bind Dyn_Var_Bind_Result nodes.lkt:4422









   
      Cast_Result_1 := Self;


Error_Location := Cast_Result_1; 
--# expr-start 2751 LogicPropagate Pred nodes.lkt:4423
--# expr-start 2750 RefId.ref_var Fld_3 nodes.lkt:4423







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Ent.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2750
Fld_3.Value := No_Entity;
Entity_Vars.Reset (Fld_3);

Pred := Solver.Create_Predicate (Fld_3, Create_Decl_P_Is_Directly_Referenceable_0_Predicate (Error_Location)); 
--# expr-done 2751
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2752
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_793;


And_Pred := Create_And (Fld_2, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4420:18") else null)); 
--# expr-done 2753
   If_Result := And_Pred;
end if;

      Inc_Ref (If_Result);


--# expr-done 2754
And_Pred_2 := Create_And (Bind_Result, If_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4411:9") else null)); 
--# expr-done 2755
Let_Result := And_Pred_2; Inc_Ref (Let_Result);
--# end
--# expr-done 2756
Scope_Result_2 := Let_Result;
   Inc_Ref (Scope_Result_2);


   --# end
      Finalizer_Scope_792;



         Property_Result := Scope_Result_2;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_337;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_337;
                     Finalizer_Scope_792;
                     Finalizer_Scope_793;
                     Finalizer_Scope_794;




            raise;
      end;



   return Property_Result;
end Ref_Id_P_Xref_Equation;
--# end

   







--# property-start RefId.xlogic_equation nodes.lkt:4430
pragma Warnings (Off, "is not referenced");

function Ref_Id_P_Xlogic_Equation
  
  (Node : Bare_Ref_Id
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Ref_Id :=
     Bare_Ref_Id (Node);
     Ent : Internal_Entity_Ref_Id :=
       Internal_Entity_Ref_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_338 with Inline_Always;
            procedure Finalizer_Scope_795 with Inline_Always;

      Fld : Logic_Var;
Fld_1 : Internal_Entity_Named_Type_Decl;
Fld_2 : Lexical_Env := Empty_Env;
Fld_3 : Bare_Ref_Id;
Sym : Symbol_Type;
Env_Get_Result : Internal_Entity;
Bind_Result : Logic_Equation;
Fld_4 : Logic_Var;
Fld_5 : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result_1 : Logic_Equation;
And_Pred : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_6 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;

            procedure Finalizer_Scope_338 is
            begin
                     Dec_Ref (Fld_2);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_1);
            end Finalizer_Scope_338;
            procedure Finalizer_Scope_795 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_795;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2770 LogicAnd And_Pred_1 nodes.lkt:4431
--# expr-start 2766 LogicAnd And_Pred nodes.lkt:4435
--# expr-start 2762 LogicAssign Bind_Result nodes.lkt:4435
--# expr-start 2757 RefId.ref_var Fld nodes.lkt:4435







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Ent.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2757
Fld.Value := No_Entity;
Entity_Vars.Reset (Fld);
--# expr-start 2761 .get_first Env_Get_Result nodes.lkt:4436
--# expr-start 2759 LktNode.children_env Fld_2 nodes.lkt:4436



--# expr-start 2758 LktNode.bool_type Fld_1 nodes.lkt:4436







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.bool_type
Fld_1 := Liblktlang.Implementation.Lkt_Node_P_Bool_Type (Node => Ent.Node);
--# end
--# expr-done 2758



   if Fld_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Liblktlang.Implementation.Children_Env (Node => Fld_1.Node, E_Info => Fld_1.Info);
--# expr-done 2759
--# expr-start 2760 .symbol Sym nodes.lkt:4436









Fld_3 := Ent.Node; 
Sym := Get_Symbol (Fld_3); 
--# expr-done 2760


Env_Get_Result := AST_Envs.Get_First (Self => Fld_2, Key => Thin (Sym), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 2761
Bind_Result := Solver.Create_Assign (Fld, Env_Get_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4435:13") else null)); 
--# expr-done 2762
--# expr-start 2765 LogicAssign Bind_Result_1 nodes.lkt:4437
--# expr-start 2763 Expr.actual_type_var Fld_4 nodes.lkt:4437







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2763
Fld_4.Value := No_Entity;
Entity_Vars.Reset (Fld_4);





--# expr-start 2764 LktNode.bool_type Fld_5 nodes.lkt:4437







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.bool_type
Fld_5 := Liblktlang.Implementation.Lkt_Node_P_Bool_Type (Node => Ent.Node);
--# end
--# expr-done 2764



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_5.Node,
         Info => Fld_5.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_4, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4437:18") else null)); 
--# expr-done 2765
And_Pred := Create_And (Bind_Result, Bind_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4435:13") else null)); 
--# expr-done 2766




   --# scope-start



--# expr-start 2769 bind Dyn_Var_Bind_Result nodes.lkt:4440









   
      Cast_Result_1 := Self;


Error_Location := Cast_Result_1; 
--# expr-start 2768 LogicPropagate Pred nodes.lkt:4441
--# expr-start 2767 RefId.ref_var Fld_6 nodes.lkt:4441







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Ent.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 2767
Fld_6.Value := No_Entity;
Entity_Vars.Reset (Fld_6);

Pred := Solver.Create_Predicate (Fld_6, Create_Decl_P_Is_Defined_0_Predicate (Error_Location)); 
--# expr-done 2768
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2769
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_795;


And_Pred_1 := Create_And (And_Pred, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4431:9") else null)); 
--# expr-done 2770

         Property_Result := And_Pred_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_338;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_338;
                     Finalizer_Scope_795;




            raise;
      end;



   return Property_Result;
end Ref_Id_P_Xlogic_Equation;
--# end

   







--# property-start RefId.complete nodes.lkt:4444
pragma Warnings (Off, "is not referenced");

function Ref_Id_P_Complete
  
  (Node : Bare_Ref_Id
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Complete_Item_Array_Access
is
   Self : Bare_Ref_Id :=
     Bare_Ref_Id (Node);
     Ent : Internal_Entity_Ref_Id :=
       Internal_Entity_Ref_Id'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Complete_Item_Array_Access;

      
            procedure Finalizer_Scope_339 with Inline_Always;
            procedure Finalizer_Scope_796 with Inline_Always;
            procedure Finalizer_Scope_797 with Inline_Always;

      Fld : Internal_Entity;
Cast_Result : Internal_Entity_Dot_Expr;
Var_Expr : Internal_Entity_Dot_Expr;
Fld_1 : Internal_Complete_Item_Array_Access;
Fld_2 : Internal_Entity_Ref_Id;
Cast_Result_1 : Internal_Entity;
Cast_Result_2 : Internal_Entity;
Is_Equiv : Boolean;
Fld_3 : Internal_Complete_Item_Array_Access;
If_Result : Internal_Complete_Item_Array_Access;
Scope_Result : Internal_Complete_Item_Array_Access;
Fld_4 : Internal_Complete_Item_Array_Access;
Result_Var : Internal_Complete_Item_Array_Access;
Scope_Result_1 : Internal_Complete_Item_Array_Access;

            procedure Finalizer_Scope_339 is
            begin
                     Dec_Ref (Scope_Result_1);
            end Finalizer_Scope_339;
            procedure Finalizer_Scope_796 is
            begin
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Fld_4);
                     Dec_Ref (Result_Var);
            end Finalizer_Scope_796;
            procedure Finalizer_Scope_797 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Fld_3);
                     Dec_Ref (If_Result);
            end Finalizer_Scope_797;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 2779 .do Result_Var nodes.lkt:4445



--# expr-start 2772 Cast Cast_Result nodes.lkt:4445





--# expr-start 2771 .parent Fld nodes.lkt:4445







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Parent (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 2771



   if Fld.Node = null
      or else Fld.Node.Kind in Lkt_Dot_Expr_Range
   then
      
      Cast_Result := Create_Internal_Entity_Dot_Expr
        (Node => Fld.Node,
         Info => Fld.Info);

   else
         Cast_Result := No_Entity_Dot_Expr;
   end if;


--# expr-done 2772
Var_Expr := Cast_Result;





if Var_Expr /= No_Entity_Dot_Expr then
   



   --# scope-start



--# expr-start 2777 If If_Result nodes.lkt:4446



--# expr-start 2774 Eq Is_Equiv nodes.lkt:4446





--# expr-start 2773 DotExpr.suffix Fld_2 nodes.lkt:4446







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Ref_Id (Node => Var_Expr.Node.Dot_Expr_F_Suffix, Info => Var_Expr.Info);
--# expr-done 2773



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Fld_2.Node,
         Info => Fld_2.Info);











   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Ent.Node,
         Info => Ent.Info);


Is_Equiv := Equivalent (Cast_Result_1, Cast_Result_2); 
--# expr-done 2774
if Is_Equiv then
   --# expr-start 2775 DotExpr.complete Fld_3 nodes.lkt:4446







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.complete'
Fld_3 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Complete (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 2775
   If_Result := Fld_3;
else
   --# expr-start 2776 LktNode.complete Fld_1 nodes.lkt:4446







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start 'LktNode.[root-static]complete'
Fld_1 := Liblktlang.Implementation.Lkt_Node_P_Complete (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2776
   If_Result := Fld_1;
end if;

      Inc_Ref (If_Result);


--# expr-done 2777
Scope_Result := If_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_797;


   Result_Var := Scope_Result;
else
   --# expr-start 2778 LktNode.complete Fld_4 nodes.lkt:4447







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start 'LktNode.[root-static]complete'
Fld_4 := Liblktlang.Implementation.Lkt_Node_P_Complete (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2778
   Result_Var := Fld_4;
end if;

      Inc_Ref (Result_Var);


--# expr-done 2779
Scope_Result_1 := Result_Var;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_796;



         Property_Result := Scope_Result_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_339;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_339;
                     Finalizer_Scope_796;
                     Finalizer_Scope_797;




            raise;
      end;



   return Property_Result;
end Ref_Id_P_Complete;
--# end



   


      

   --
   --  Primitives for Bare_If_Expr
   --

   



      
      procedure Initialize_Fields_For_If_Expr
        (Self : Bare_If_Expr
         ; If_Expr_F_Cond_Expr : Bare_Expr
         ; If_Expr_F_Then_Expr : Bare_Expr
         ; If_Expr_F_Alternatives : Bare_Elsif_Branch_List
         ; If_Expr_F_Else_Expr : Bare_Expr
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.If_Expr_F_Cond_Expr := If_Expr_F_Cond_Expr;
            Self.If_Expr_F_Then_Expr := If_Expr_F_Then_Expr;
            Self.If_Expr_F_Alternatives := If_Expr_F_Alternatives;
            Self.If_Expr_F_Else_Expr := If_Expr_F_Else_Expr;
         
      Self.If_Expr_F_Expected_Branch_Type_Var := Null_Var_Record;

      end Initialize_Fields_For_If_Expr;

      
   function If_Expr_F_Cond_Expr
     (Node : Bare_If_Expr) return Bare_Expr
   is
      

   begin
         
         return Node.If_Expr_F_Cond_Expr;
      
   end;

      
   function If_Expr_F_Then_Expr
     (Node : Bare_If_Expr) return Bare_Expr
   is
      

   begin
         
         return Node.If_Expr_F_Then_Expr;
      
   end;

      
   function If_Expr_F_Alternatives
     (Node : Bare_If_Expr) return Bare_Elsif_Branch_List
   is
      

   begin
         
         return Node.If_Expr_F_Alternatives;
      
   end;

      
   function If_Expr_F_Else_Expr
     (Node : Bare_If_Expr) return Bare_Expr
   is
      

   begin
         
         return Node.If_Expr_F_Else_Expr;
      
   end;


   







--# property-start IfExpr.has_context_free_type nodes.lkt:4464
pragma Warnings (Off, "is not referenced");

function If_Expr_P_Has_Context_Free_Type
  
  (Node : Bare_If_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_If_Expr :=
     Bare_If_Expr (Node);
     Ent : Internal_Entity_If_Expr :=
       Internal_Entity_If_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      
            procedure Finalizer_Scope_340 with Inline_Always;

      Fld : Internal_Entity_Expr_Array_Access;
Fld_1 : Boolean;
Quantifier_Result : Boolean;

            procedure Finalizer_Scope_340 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_340;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 2782 .any Quantifier_Result nodes.lkt:4465








   

   --# expr-start 2780 IfExpr.branch_exprs Fld nodes.lkt:4465







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start IfExpr.branch_exprs
Fld := Liblktlang.Implementation.If_Expr_P_Branch_Exprs (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2780

   
      Quantifier_Result := False;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Expr_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind e Item

            
      --# expr-start 2781 Expr.has_context_free_type Fld_1 nodes.lkt:4465







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 2781
      Quantifier_Result := Fld_1;
   

            
   --# end


               exit when Quantifier_Result;

         end loop;
      end;
   

   
   



--# expr-done 2782

         Property_Result := Quantifier_Result;
         
   --# end
      Finalizer_Scope_340;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_340;




            raise;
      end;



   return Property_Result;
end If_Expr_P_Has_Context_Free_Type;
--# end

   







--# property-start IfExpr.branch_exprs nodes.lkt:4468
pragma Warnings (Off, "is not referenced");

function If_Expr_P_Branch_Exprs
  
  (Node : Bare_If_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Expr_Array_Access
is
   Self : Bare_If_Expr :=
     Bare_If_Expr (Node);
     Ent : Internal_Entity_If_Expr :=
       Internal_Entity_If_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Expr_Array_Access;

      
            procedure Finalizer_Scope_342 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Internal_Entity_Expr;
Array_Lit : Internal_Entity_Expr_Array_Access;
Fld_2 : Internal_Entity_Elsif_Branch_List;
Item : Internal_Entity_Elsif_Branch;
Fld_3 : Internal_Entity_Expr;
Fld_4 : Bare_Elsif_Branch_List;
Fld_5 : Internal_Entity_Info;
Bare_Item : Bare_Elsif_Branch;
As_Entity : Internal_Entity_Elsif_Branch;
Is_Null : Boolean;
If_Result : Internal_Entity_Elsif_Branch;
Map_Result : Internal_Entity_Expr_Array_Access;
Concat_Result : Internal_Entity_Expr_Array_Access;

            procedure Finalizer_Scope_342 is
            begin
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Concat_Result);
            end Finalizer_Scope_342;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 2789 ArrayConcat Concat_Result nodes.lkt:4469
--# expr-start 2785 ArrayLiteral Array_Lit nodes.lkt:4469
--# expr-start 2783 IfExpr.then_expr Fld nodes.lkt:4469







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.If_Expr_F_Then_Expr, Info => Ent.Info);
--# expr-done 2783
--# expr-start 2784 IfExpr.else_expr Fld_1 nodes.lkt:4469







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Expr (Node => Ent.Node.If_Expr_F_Else_Expr, Info => Ent.Info);
--# expr-done 2784
Array_Lit := Create_Internal_Entity_Expr_Array (Internal_Internal_Entity_Expr_Array'(1 => Fld, 2 => Fld_1)); 
--# expr-done 2785
--# expr-start 2788 .map Map_Result nodes.lkt:4470








   

   --# expr-start 2786 IfExpr.alternatives Fld_2 nodes.lkt:4470







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Elsif_Branch_List (Node => Ent.Node.If_Expr_F_Alternatives, Info => Ent.Info);
--# expr-done 2786









Fld_4 := Fld_2.Node;

   
      declare
         Map_Result_Vec : Internal_Entity_Expr_Vectors.Vector;
      begin
   

   

      if Fld_4 = null then
         
      Map_Result := Create_Internal_Entity_Expr_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Elsif_Branch_List := Fld_4;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Elsif_Branch;
else
   








Fld_5 := Fld_2.Info;

As_Entity := (Info => Fld_5, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind alt Item

            
         
         
      --# expr-start 2787 ElsifBranch.then_expr Fld_3 nodes.lkt:4470







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Expr (Node => Item.Node.Elsif_Branch_F_Then_Expr, Info => Item.Info);
--# expr-done 2787
      

         declare
            Item_To_Append : constant Internal_Entity_Expr := Fld_3;
         begin
            Internal_Entity_Expr_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Internal_Entity_Expr_Array
           (Items_Count => Natural (Internal_Entity_Expr_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Expr_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Expr_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Expr_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 2788
Concat_Result := Concat (Array_Lit, Map_Result); 
--# expr-done 2789

         Property_Result := Concat_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_342;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_342;




            raise;
      end;



   return Property_Result;
end If_Expr_P_Branch_Exprs;
--# end

   







--# property-start IfExpr.expected_branch_type_equation nodes.lkt:4475
pragma Warnings (Off, "is not referenced");

function If_Expr_P_Expected_Branch_Type_Equation
  
  (Node : Bare_If_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_If_Expr :=
     Bare_If_Expr (Node);
     Ent : Internal_Entity_If_Expr :=
       Internal_Entity_If_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_343 with Inline_Always;
            procedure Finalizer_Scope_800 with Inline_Always;
            procedure Finalizer_Scope_803 with Inline_Always;

      Fld : Internal_Entity_Expr_Array_Access;
Fld_1 : Boolean;
Map_Result : Internal_Entity_Expr_Array_Access;
Fld_2 : Logic_Var;
Map_Result_1 : Logic_Var_Array_Access;
Fld_3 : Logic_Var;
Array_Lit : Logic_Var_Array_Access;
Left_Var : Logic_Var_Array_Access;
Result_Var : Logic_Var_Array_Access;
Local_Logic_Vars : Logic_Var_Array_Access;
Fld_4 : Logic_Var;
Logic_Vars : Logic_Var_Array_Access;
Bind_Result : Logic_Equation;
Fld_5 : Internal_Entity_Expr_Array_Access;
Fld_6 : Logic_Var;
Fld_7 : Logic_Var;
Bind_Result_1 : Logic_Equation;
Map_Result_2 : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;
And_Pred : Logic_Equation;
Let_Result : Logic_Equation;
Scope_Result : Logic_Equation;

            procedure Finalizer_Scope_343 is
            begin
                     Dec_Ref (Scope_Result);
            end Finalizer_Scope_343;
            procedure Finalizer_Scope_800 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Left_Var);
                     Dec_Ref (Result_Var);
                     Dec_Ref (Local_Logic_Vars);
                     Dec_Ref (Logic_Vars);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Fld_5);
                     Dec_Ref (Map_Result_2);
                     Dec_Ref (Logic_Boolean_Op);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Let_Result);
            end Finalizer_Scope_800;
            procedure Finalizer_Scope_803 is
            begin
                     Dec_Ref (Bind_Result_1);
            end Finalizer_Scope_803;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 2805 ValDecl Let_Result nodes.lkt:4476
--# scope-start
--# expr-start 2797 'or?' Result_Var nodes.lkt:4477



--# expr-start 2794 .map Map_Result_1 nodes.lkt:4477








   

   --# expr-start 2792 .filter Map_Result nodes.lkt:4477








   

   --# expr-start 2790 IfExpr.branch_exprs Fld nodes.lkt:4477







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start IfExpr.branch_exprs
Fld := Liblktlang.Implementation.If_Expr_P_Branch_Exprs (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2790

   
      declare
         Map_Result_Vec : Internal_Entity_Expr_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Expr_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind expr Item

            
         --# expr-start 2791 Expr.has_context_free_type Fld_1 nodes.lkt:4477







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 2791
         if Fld_1 then
            
         
      
      

         declare
            Item_To_Append : constant Internal_Entity_Expr := Item;
         begin
            Internal_Entity_Expr_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
         end if;
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Entity_Expr_Array
           (Items_Count => Natural (Internal_Entity_Expr_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Expr_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Expr_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Expr_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 2792

   
      declare
         Map_Result_1_Vec : Logic_Var_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Expr_Array_Access := Map_Result;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind expr Item_1

            
         
         
      --# expr-start 2793 Expr.actual_type_var Fld_2 nodes.lkt:4478







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Item_1.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2793
      

         declare
            Item_To_Append : constant Logic_Var := Fld_2;
         begin
            Logic_Var_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result_1 := Create_Logic_Var_Array
           (Items_Count => Natural (Logic_Var_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Logic_Var_Vectors.Get
              (Map_Result_1_Vec,
               I + Logic_Var_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Logic_Var_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 2794
Left_Var := Map_Result_1;

      Inc_Ref (Left_Var);




if Left_Var /= No_Logic_Var_Array_Type then
   
   Result_Var := Left_Var;
else
   --# expr-start 2796 ArrayLiteral Array_Lit nodes.lkt:4479
--# expr-start 2795 Expr.expected_type_var Fld_3 nodes.lkt:4479







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Ent.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2795
Array_Lit := Create_Logic_Var_Array (Internal_Logic_Var_Array'(1 => Fld_3)); 
--# expr-done 2796
   Result_Var := Array_Lit;
end if;

      Inc_Ref (Result_Var);


--# expr-done 2797
Local_Logic_Vars := Result_Var; Inc_Ref (Local_Logic_Vars);
--# bind logic_vars Local_Logic_Vars
--# expr-start 2804 LogicAnd And_Pred nodes.lkt:4481

for Var of Local_Logic_Vars.Items loop
   Var.Value := No_Entity;
   Entity_Vars.Reset (Var);
end loop;
Logic_Vars := Local_Logic_Vars; Inc_Ref (Logic_Vars);
--# expr-start 2798 IfExpr.expected_branch_type_var Fld_4 nodes.lkt:4481







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Ent.Node.If_Expr_F_Expected_Branch_Type_Var'Unrestricted_Access;
--# expr-done 2798
Fld_4.Value := No_Entity;
Entity_Vars.Reset (Fld_4);


Bind_Result := Solver.Create_N_Propagate (Fld_4, Create_Type_Decl_P_Imprecise_Common_Ancestor_List_0_Functor (Logic_Vars.N), Entity_Vars.Logic_Var_Array (Logic_Vars.Items)); 
--# expr-start 2803 .logic_all Logic_Boolean_Op nodes.lkt:4483








   

   --# expr-start 2799 IfExpr.branch_exprs Fld_5 nodes.lkt:4483







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start IfExpr.branch_exprs
Fld_5 := Liblktlang.Implementation.If_Expr_P_Branch_Exprs (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2799

   
      declare
         Map_Result_2_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Expr_Array_Access := Fld_5;
      begin
         for Item_2 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind e Item_2

            
         
         
      --# expr-start 2802 LogicUnify Bind_Result_1 nodes.lkt:4484
--# expr-start 2800 Expr.expected_type_var Fld_6 nodes.lkt:4484







   if Item_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Item_2.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2800
Fld_6.Value := No_Entity;
Entity_Vars.Reset (Fld_6);
--# expr-start 2801 IfExpr.expected_branch_type_var Fld_7 nodes.lkt:4484







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Ent.Node.If_Expr_F_Expected_Branch_Type_Var'Unrestricted_Access;
--# expr-done 2801
Bind_Result_1 := Solver.Create_Unify (Fld_6, Fld_7, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4484:20") else null)); 
--# expr-done 2802
      

         declare
            Item_To_Append : constant Logic_Equation := Bind_Result_1;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_2_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_803;



         end loop;
      end;
   

   

         Map_Result_2 := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_2_Vec)));
         for I in Map_Result_2.Items'Range loop
            Map_Result_2.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_2_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result_2.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_2_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result_2.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4483:34") else null)); 
--# expr-done 2803
And_Pred := Create_And (Bind_Result, Logic_Boolean_Op, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4481:9") else null)); 
--# expr-done 2804
Let_Result := And_Pred; Inc_Ref (Let_Result);
--# end
--# expr-done 2805
Scope_Result := Let_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_800;



         Property_Result := Scope_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_343;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_343;
                     Finalizer_Scope_800;
                     Finalizer_Scope_803;




            raise;
      end;



   return Property_Result;
end If_Expr_P_Expected_Branch_Type_Equation;
--# end

   







--# property-start IfExpr.xref_equation nodes.lkt:4488
pragma Warnings (Off, "is not referenced");

function If_Expr_P_Xref_Equation
  
  (Node : Bare_If_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_If_Expr :=
     Bare_If_Expr (Node);
     Ent : Internal_Entity_If_Expr :=
       Internal_Entity_If_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_344 with Inline_Always;
            procedure Finalizer_Scope_804 with Inline_Always;
            procedure Finalizer_Scope_805 with Inline_Always;

      Fld : Logic_Equation;
Fld_1 : Logic_Equation;
And_Pred : Logic_Equation;
Fld_2 : Internal_Entity_Expr_Array_Access;
Fld_3 : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_4 : Bare_Expr;
Fld_5 : Logic_Var;
Fld_6 : Logic_Var;
Pred : Logic_Equation;
Cast_Result : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;
Map_Result : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;
And_Pred_2 : Logic_Equation;
Fld_7 : Logic_Var;
Fld_8 : Internal_Entity_Expr_Array_Access;
Fld_9 : Logic_Var;
Map_Result_1 : Logic_Var_Array_Access;
Logic_Vars : Logic_Var_Array_Access;
Bind_Result : Logic_Equation;
And_Pred_3 : Logic_Equation;

            procedure Finalizer_Scope_344 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Fld_1);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Fld_2);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Logic_Boolean_Op);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Fld_8);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (Logic_Vars);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred_3);
            end Finalizer_Scope_344;
            procedure Finalizer_Scope_804 is
            begin
                     Dec_Ref (Fld_3);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_1);
            end Finalizer_Scope_804;
            procedure Finalizer_Scope_805 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_805;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2823 LogicAnd And_Pred_3 nodes.lkt:4489
--# expr-start 2818 LogicAnd And_Pred_2 nodes.lkt:4490
--# expr-start 2808 LogicAnd And_Pred nodes.lkt:4491
--# expr-start 2806 IfExpr.cond_branches_equation Fld nodes.lkt:4491







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start IfExpr.cond_branches_equation
Fld := Liblktlang.Implementation.If_Expr_P_Cond_Branches_Equation (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2806
--# expr-start 2807 IfExpr.expected_branch_type_equation Fld_1 nodes.lkt:4492







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start IfExpr.expected_branch_type_equation
Fld_1 := Liblktlang.Implementation.If_Expr_P_Expected_Branch_Type_Equation (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2807
And_Pred := Create_And (Fld, Fld_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4491:17") else null)); 
--# expr-done 2808
--# expr-start 2817 .logic_all Logic_Boolean_Op nodes.lkt:4496








   

   --# expr-start 2809 IfExpr.branch_exprs Fld_2 nodes.lkt:4496







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start IfExpr.branch_exprs
Fld_2 := Liblktlang.Implementation.If_Expr_P_Branch_Exprs (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2809

   
      declare
         Map_Result_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Expr_Array_Access := Fld_2;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind e Item

            
         
         
      --# expr-start 2816 LogicAnd And_Pred_1 nodes.lkt:4498
--# expr-start 2810 LktNode.xref_equation Fld_3 nodes.lkt:4498







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_3 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 2810




   --# scope-start



--# expr-start 2815 bind Dyn_Var_Bind_Result nodes.lkt:4500





--# expr-start 2811 'Entity[Expr].node' Fld_4 nodes.lkt:4500









Fld_4 := Item.Node;
--# expr-done 2811



   
      Cast_Result := Fld_4;


Error_Location := Cast_Result; 
--# expr-start 2814 LogicPropagate Pred nodes.lkt:4501
--# expr-start 2812 Expr.expected_type_var Fld_5 nodes.lkt:4502







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Item.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2812
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);
--# expr-start 2813 Expr.actual_type_var Fld_6 nodes.lkt:4503







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Item.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2813
Fld_6.Value := No_Entity;
Entity_Vars.Reset (Fld_6);


Pred := Solver.Create_N_Predicate ((Fld_5, Fld_6), Create_Type_Decl_P_Matching_Type_0_Predicate (2, Error_Location)); 
--# expr-done 2814
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2815
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_805;


And_Pred_1 := Create_And (Fld_3, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4498:21") else null)); 
--# expr-done 2816
      

         declare
            Item_To_Append : constant Logic_Equation := And_Pred_1;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_804;



         end loop;
      end;
   

   

         Map_Result := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4496:37") else null)); 
--# expr-done 2817
And_Pred_2 := Create_And (And_Pred, Logic_Boolean_Op, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4490:13") else null)); 
--# expr-done 2818
--# expr-start 2821 .map Map_Result_1 nodes.lkt:4513








   

   --# expr-start 2819 IfExpr.branch_exprs Fld_8 nodes.lkt:4513







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start IfExpr.branch_exprs
Fld_8 := Liblktlang.Implementation.If_Expr_P_Branch_Exprs (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2819

   
      declare
         Map_Result_1_Vec : Logic_Var_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Expr_Array_Access := Fld_8;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind e Item_1

            
         
         
      --# expr-start 2820 Expr.actual_type_var Fld_9 nodes.lkt:4513







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Item_1.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2820
      

         declare
            Item_To_Append : constant Logic_Var := Fld_9;
         begin
            Logic_Var_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result_1 := Create_Logic_Var_Array
           (Items_Count => Natural (Logic_Var_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Logic_Var_Vectors.Get
              (Map_Result_1_Vec,
               I + Logic_Var_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Logic_Var_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 2821
for Var of Map_Result_1.Items loop
   Var.Value := No_Entity;
   Entity_Vars.Reset (Var);
end loop;
Logic_Vars := Map_Result_1; Inc_Ref (Logic_Vars);
--# expr-start 2822 Expr.actual_type_var Fld_7 nodes.lkt:4511







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2822
Fld_7.Value := No_Entity;
Entity_Vars.Reset (Fld_7);


Bind_Result := Solver.Create_N_Propagate (Fld_7, Create_Type_Decl_P_Imprecise_Common_Ancestor_List_0_Functor (Logic_Vars.N), Entity_Vars.Logic_Var_Array (Logic_Vars.Items)); 
And_Pred_3 := Create_And (And_Pred_2, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4489:9") else null)); 
--# expr-done 2823

         Property_Result := And_Pred_3;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_344;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_344;
                     Finalizer_Scope_804;
                     Finalizer_Scope_805;




            raise;
      end;



   return Property_Result;
end If_Expr_P_Xref_Equation;
--# end

   







--# property-start IfExpr.cond_branches_equation nodes.lkt:4518
pragma Warnings (Off, "is not referenced");

function If_Expr_P_Cond_Branches_Equation
  
  (Node : Bare_If_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_If_Expr :=
     Bare_If_Expr (Node);
     Ent : Internal_Entity_If_Expr :=
       Internal_Entity_If_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_345 with Inline_Always;
            procedure Finalizer_Scope_807 with Inline_Always;
            procedure Finalizer_Scope_808 with Inline_Always;
            procedure Finalizer_Scope_809 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Internal_Entity_Expr;
Fld_3 : Logic_Var;
Fld_4 : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
And_Pred : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_5 : Bare_Expr;
Fld_6 : Internal_Entity_Expr;
Fld_7 : Logic_Var;
Fld_8 : Internal_Entity_Expr;
Fld_9 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;
Fld_10 : Internal_Entity_Elsif_Branch_List;
Item : Internal_Entity_Elsif_Branch;
Fld_11 : Internal_Entity_Expr;
Fld_12 : Logic_Equation;
Fld_13 : Internal_Entity_Expr;
Fld_14 : Logic_Var;
Fld_15 : Internal_Entity_Named_Type_Decl;
Cast_Result_2 : Internal_Entity;
Bind_Result_1 : Logic_Equation;
And_Pred_2 : Logic_Equation;
Error_Location_1 : Bare_Lkt_Node;
Fld_16 : Internal_Entity_Expr;
Fld_17 : Bare_Expr;
Fld_18 : Internal_Entity_Expr;
Fld_19 : Logic_Var;
Fld_20 : Internal_Entity_Expr;
Fld_21 : Logic_Var;
Pred_1 : Logic_Equation;
Cast_Result_3 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_1 : Logic_Equation;
Scope_Result_1 : Logic_Equation;
And_Pred_3 : Logic_Equation;
Fld_22 : Bare_Elsif_Branch_List;
Fld_23 : Internal_Entity_Info;
Bare_Item : Bare_Elsif_Branch;
As_Entity : Internal_Entity_Elsif_Branch;
Is_Null : Boolean;
If_Result : Internal_Entity_Elsif_Branch;
Map_Result : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;
And_Pred_4 : Logic_Equation;

            procedure Finalizer_Scope_345 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Logic_Boolean_Op);
                     Dec_Ref (And_Pred_4);
            end Finalizer_Scope_345;
            procedure Finalizer_Scope_807 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_807;
            procedure Finalizer_Scope_808 is
            begin
                     Dec_Ref (Fld_12);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (And_Pred_3);
            end Finalizer_Scope_808;
            procedure Finalizer_Scope_809 is
            begin
                     Dec_Ref (Pred_1);
                     Dec_Ref (Dyn_Var_Bind_Result_1);
            end Finalizer_Scope_809;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2857 LogicAnd And_Pred_4 nodes.lkt:4519
--# expr-start 2838 LogicAnd And_Pred_1 nodes.lkt:4520
--# expr-start 2830 LogicAnd And_Pred nodes.lkt:4521
--# expr-start 2825 LktNode.xref_equation Fld_1 nodes.lkt:4521



--# expr-start 2824 IfExpr.cond_expr Fld nodes.lkt:4521







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.If_Expr_F_Cond_Expr, Info => Ent.Info);
--# expr-done 2824



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2825
--# expr-start 2829 LogicAssign Bind_Result nodes.lkt:4522
--# expr-start 2827 Expr.expected_type_var Fld_3 nodes.lkt:4522



--# expr-start 2826 IfExpr.cond_expr Fld_2 nodes.lkt:4522







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Ent.Node.If_Expr_F_Cond_Expr, Info => Ent.Info);
--# expr-done 2826



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Fld_2.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2827
Fld_3.Value := No_Entity;
Entity_Vars.Reset (Fld_3);





--# expr-start 2828 LktNode.bool_type Fld_4 nodes.lkt:4522







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.bool_type
Fld_4 := Liblktlang.Implementation.Lkt_Node_P_Bool_Type (Node => Ent.Node);
--# end
--# expr-done 2828



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_4.Node,
         Info => Fld_4.Info);


Bind_Result := Solver.Create_Assign (Fld_3, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4522:22") else null)); 
--# expr-done 2829
And_Pred := Create_And (Fld_1, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4521:17") else null)); 
--# expr-done 2830




   --# scope-start



--# expr-start 2837 bind Dyn_Var_Bind_Result nodes.lkt:4525





--# expr-start 2831 IfExpr.cond_expr Fld_5 nodes.lkt:4525







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Self.If_Expr_F_Cond_Expr;
--# expr-done 2831



   
      Cast_Result_1 := Fld_5;


Error_Location := Cast_Result_1; 
--# expr-start 2836 LogicPropagate Pred nodes.lkt:4526
--# expr-start 2833 Expr.expected_type_var Fld_7 nodes.lkt:4527



--# expr-start 2832 IfExpr.cond_expr Fld_6 nodes.lkt:4527







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Expr (Node => Ent.Node.If_Expr_F_Cond_Expr, Info => Ent.Info);
--# expr-done 2832



   if Fld_6.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Fld_6.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2833
Fld_7.Value := No_Entity;
Entity_Vars.Reset (Fld_7);
--# expr-start 2835 Expr.actual_type_var Fld_9 nodes.lkt:4528



--# expr-start 2834 IfExpr.cond_expr Fld_8 nodes.lkt:4528







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Create_Internal_Entity_Expr (Node => Ent.Node.If_Expr_F_Cond_Expr, Info => Ent.Info);
--# expr-done 2834



   if Fld_8.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Fld_8.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2835
Fld_9.Value := No_Entity;
Entity_Vars.Reset (Fld_9);


Pred := Solver.Create_N_Predicate ((Fld_7, Fld_9), Create_Type_Decl_P_Matching_Type_0_Predicate (2, Error_Location)); 
--# expr-done 2836
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2837
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_807;


And_Pred_1 := Create_And (And_Pred, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4520:13") else null)); 
--# expr-done 2838
--# expr-start 2856 .logic_all Logic_Boolean_Op nodes.lkt:4532








   

   --# expr-start 2839 IfExpr.alternatives Fld_10 nodes.lkt:4532







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Create_Internal_Entity_Elsif_Branch_List (Node => Ent.Node.If_Expr_F_Alternatives, Info => Ent.Info);
--# expr-done 2839









Fld_22 := Fld_10.Node;

   
      declare
         Map_Result_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      if Fld_22 = null then
         
      Map_Result := Create_Logic_Equation_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Elsif_Branch_List := Fld_22;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Elsif_Branch;
else
   








Fld_23 := Fld_10.Info;

As_Entity := (Info => Fld_23, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind alt Item

            
         
         
      --# expr-start 2855 LogicAnd And_Pred_3 nodes.lkt:4534
--# expr-start 2846 LogicAnd And_Pred_2 nodes.lkt:4535
--# expr-start 2841 LktNode.xref_equation Fld_12 nodes.lkt:4535



--# expr-start 2840 ElsifBranch.cond_expr Fld_11 nodes.lkt:4535







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Create_Internal_Entity_Expr (Node => Item.Node.Elsif_Branch_F_Cond_Expr, Info => Item.Info);
--# expr-done 2840



   if Fld_11.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_12 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld_11.Node, E_Info => Fld_11.Info);
--# end
--# expr-done 2841
--# expr-start 2845 LogicAssign Bind_Result_1 nodes.lkt:4536
--# expr-start 2843 Expr.expected_type_var Fld_14 nodes.lkt:4536



--# expr-start 2842 ElsifBranch.cond_expr Fld_13 nodes.lkt:4536







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_13 := Create_Internal_Entity_Expr (Node => Item.Node.Elsif_Branch_F_Cond_Expr, Info => Item.Info);
--# expr-done 2842



   if Fld_13.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_14 := Fld_13.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2843
Fld_14.Value := No_Entity;
Entity_Vars.Reset (Fld_14);





--# expr-start 2844 LktNode.bool_type Fld_15 nodes.lkt:4536







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.bool_type
Fld_15 := Liblktlang.Implementation.Lkt_Node_P_Bool_Type (Node => Ent.Node);
--# end
--# expr-done 2844



   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Fld_15.Node,
         Info => Fld_15.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_14, Cast_Result_2, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4536:22") else null)); 
--# expr-done 2845
And_Pred_2 := Create_And (Fld_12, Bind_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4535:17") else null)); 
--# expr-done 2846




   --# scope-start



--# expr-start 2854 bind Dyn_Var_Bind_Result_1 nodes.lkt:4539





--# expr-start 2848 'Entity[Expr].node' Fld_17 nodes.lkt:4539



--# expr-start 2847 ElsifBranch.cond_expr Fld_16 nodes.lkt:4539







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_16 := Create_Internal_Entity_Expr (Node => Item.Node.Elsif_Branch_F_Cond_Expr, Info => Item.Info);
--# expr-done 2847





Fld_17 := Fld_16.Node;
--# expr-done 2848



   
      Cast_Result_3 := Fld_17;


Error_Location_1 := Cast_Result_3; 
--# expr-start 2853 LogicPropagate Pred_1 nodes.lkt:4540
--# expr-start 2850 Expr.expected_type_var Fld_19 nodes.lkt:4541



--# expr-start 2849 ElsifBranch.cond_expr Fld_18 nodes.lkt:4541







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_18 := Create_Internal_Entity_Expr (Node => Item.Node.Elsif_Branch_F_Cond_Expr, Info => Item.Info);
--# expr-done 2849



   if Fld_18.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_19 := Fld_18.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2850
Fld_19.Value := No_Entity;
Entity_Vars.Reset (Fld_19);
--# expr-start 2852 Expr.actual_type_var Fld_21 nodes.lkt:4542



--# expr-start 2851 ElsifBranch.cond_expr Fld_20 nodes.lkt:4542







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_20 := Create_Internal_Entity_Expr (Node => Item.Node.Elsif_Branch_F_Cond_Expr, Info => Item.Info);
--# expr-done 2851



   if Fld_20.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_21 := Fld_20.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2852
Fld_21.Value := No_Entity;
Entity_Vars.Reset (Fld_21);


Pred_1 := Solver.Create_N_Predicate ((Fld_19, Fld_21), Create_Type_Decl_P_Commutative_Matching_Type_0_Predicate (2, Error_Location_1)); 
--# expr-done 2853
Dyn_Var_Bind_Result_1 := Pred_1; Inc_Ref (Dyn_Var_Bind_Result_1);
--# expr-done 2854
Scope_Result_1 := Dyn_Var_Bind_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_809;


And_Pred_3 := Create_And (And_Pred_2, Scope_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4534:13") else null)); 
--# expr-done 2855
      

         declare
            Item_To_Append : constant Logic_Equation := And_Pred_3;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_808;



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4532:32") else null)); 
--# expr-done 2856
And_Pred_4 := Create_And (And_Pred_1, Logic_Boolean_Op, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4519:9") else null)); 
--# expr-done 2857

         Property_Result := And_Pred_4;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_345;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_345;
                     Finalizer_Scope_807;
                     Finalizer_Scope_808;
                     Finalizer_Scope_809;




            raise;
      end;



   return Property_Result;
end If_Expr_P_Cond_Branches_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Isa
   --

   



      
      procedure Initialize_Fields_For_Isa
        (Self : Bare_Isa
         ; Isa_F_Expr : Bare_Expr
         ; Isa_F_Pattern : Bare_Pattern
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Isa_F_Expr := Isa_F_Expr;
            Self.Isa_F_Pattern := Isa_F_Pattern;
         

      end Initialize_Fields_For_Isa;

      
   function Isa_F_Expr
     (Node : Bare_Isa) return Bare_Expr
   is
      

   begin
         
         return Node.Isa_F_Expr;
      
   end;

      
   function Isa_F_Pattern
     (Node : Bare_Isa) return Bare_Pattern
   is
      

   begin
         
         return Node.Isa_F_Pattern;
      
   end;


   







--# property-start Isa.expected_type_equation nodes.lkt:4555
pragma Warnings (Off, "is not referenced");

function Isa_P_Expected_Type_Equation
  
  (Node : Bare_Isa
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Isa :=
     Bare_Isa (Node);
     Ent : Internal_Entity_Isa :=
       Internal_Entity_Isa'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_346 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;

            procedure Finalizer_Scope_346 is
            begin
                     Dec_Ref (Bind_Result);
            end Finalizer_Scope_346;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 2860 LogicAssign Bind_Result nodes.lkt:4556
--# expr-start 2859 Expr.expected_type_var Fld_1 nodes.lkt:4556



--# expr-start 2858 Isa.expr Fld nodes.lkt:4556







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Isa_F_Expr, Info => Ent.Info);
--# expr-done 2858



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Fld.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2859
Fld_1.Value := No_Entity;
Entity_Vars.Reset (Fld_1);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result := Solver.Create_Assign (Fld_1, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4556:9") else null)); 
--# expr-done 2860

         Property_Result := Bind_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_346;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_346;




            raise;
      end;



   return Property_Result;
end Isa_P_Expected_Type_Equation;
--# end

   







--# property-start Isa.xref_equation nodes.lkt:4558
pragma Warnings (Off, "is not referenced");

function Isa_P_Xref_Equation
  
  (Node : Bare_Isa
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Isa :=
     Bare_Isa (Node);
     Ent : Internal_Entity_Isa :=
       Internal_Entity_Isa'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_347 with Inline_Always;

      Fld : Logic_Var;
Fld_1 : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;

            procedure Finalizer_Scope_347 is
            begin
                     Dec_Ref (Bind_Result);
            end Finalizer_Scope_347;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2863 LogicAssign Bind_Result nodes.lkt:4558
--# expr-start 2861 Expr.actual_type_var Fld nodes.lkt:4558







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2861
Fld.Value := No_Entity;
Entity_Vars.Reset (Fld);





--# expr-start 2862 LktNode.bool_type Fld_1 nodes.lkt:4558







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.bool_type
Fld_1 := Liblktlang.Implementation.Lkt_Node_P_Bool_Type (Node => Ent.Node);
--# end
--# expr-done 2862



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_1.Node,
         Info => Fld_1.Info);


Bind_Result := Solver.Create_Assign (Fld, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4558:37") else null)); 
--# expr-done 2863

         Property_Result := Bind_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_347;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_347;




            raise;
      end;



   return Property_Result;
end Isa_P_Xref_Equation;
--# end

   







--# property-start Isa.has_context_free_type nodes.lkt:4560
pragma Warnings (Off, "is not referenced");

function Isa_P_Has_Context_Free_Type
  
  (Node : Bare_Isa
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Isa :=
     Bare_Isa (Node);
     Ent : Internal_Entity_Isa :=
       Internal_Entity_Isa'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := True;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Isa_P_Has_Context_Free_Type;
--# end



   


      

   --
   --  Primitives for Bare_Keep_Expr
   --

   



      
      procedure Initialize_Fields_For_Keep_Expr
        (Self : Bare_Keep_Expr
         ; Keep_Expr_F_Expr : Bare_Expr
         ; Keep_Expr_F_Null_Cond : Bare_Null_Cond_Qualifier
         ; Keep_Expr_F_Keep_Type : Bare_Type_Ref
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Keep_Expr_F_Expr := Keep_Expr_F_Expr;
            Self.Keep_Expr_F_Null_Cond := Keep_Expr_F_Null_Cond;
            Self.Keep_Expr_F_Keep_Type := Keep_Expr_F_Keep_Type;
         
      Self.Keep_Expr_F_Array_Element_Type := Null_Var_Record;

      end Initialize_Fields_For_Keep_Expr;

      
   function Keep_Expr_F_Expr
     (Node : Bare_Keep_Expr) return Bare_Expr
   is
      

   begin
         
         return Node.Keep_Expr_F_Expr;
      
   end;

      
   function Keep_Expr_F_Null_Cond
     (Node : Bare_Keep_Expr) return Bare_Null_Cond_Qualifier
   is
      

   begin
         
         return Node.Keep_Expr_F_Null_Cond;
      
   end;

      
   function Keep_Expr_F_Keep_Type
     (Node : Bare_Keep_Expr) return Bare_Type_Ref
   is
      

   begin
         
         return Node.Keep_Expr_F_Keep_Type;
      
   end;


   







--# property-start KeepExpr.xref_equation nodes.lkt:4573
pragma Warnings (Off, "is not referenced");

function Keep_Expr_P_Xref_Equation
  
  (Node : Bare_Keep_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Keep_Expr :=
     Bare_Keep_Expr (Node);
     Ent : Internal_Entity_Keep_Expr :=
       Internal_Entity_Keep_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_349 with Inline_Always;
            procedure Finalizer_Scope_810 with Inline_Always;
            procedure Finalizer_Scope_811 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Internal_Entity_Type_Ref;
Fld_3 : Logic_Equation;
And_Pred : Logic_Equation;
Fld_4 : Logic_Var;
Fld_5 : Internal_Entity_Expr;
Fld_6 : Logic_Var;
Fld_7 : Internal_Entity_Type_Ref;
Fld_8 : Logic_Var;
Bind_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;
Fld_9 : Internal_Entity_Expr;
Fld_10 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result_1 : Logic_Equation;
And_Pred_2 : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_11 : Bare_Expr;
Fld_12 : Internal_Entity_Expr;
Fld_13 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_3 : Logic_Equation;
Fld_14 : Logic_Var;
Fld_15 : Internal_Entity_Expr;
Fld_16 : Logic_Var;
Bind_Result_2 : Logic_Equation;
And_Pred_4 : Logic_Equation;
Error_Location_1 : Bare_Lkt_Node;
Fld_17 : Bare_Type_Ref;
Fld_18 : Logic_Var;
Fld_19 : Internal_Entity_Type_Ref;
Fld_20 : Logic_Var;
Pred_1 : Logic_Equation;
Cast_Result_2 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_1 : Logic_Equation;
Scope_Result_1 : Logic_Equation;
And_Pred_5 : Logic_Equation;

            procedure Finalizer_Scope_349 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Fld_3);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_3);
                     Dec_Ref (Bind_Result_2);
                     Dec_Ref (And_Pred_4);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (And_Pred_5);
            end Finalizer_Scope_349;
            procedure Finalizer_Scope_810 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_810;
            procedure Finalizer_Scope_811 is
            begin
                     Dec_Ref (Pred_1);
                     Dec_Ref (Dyn_Var_Bind_Result_1);
            end Finalizer_Scope_811;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2897 LogicAnd And_Pred_5 nodes.lkt:4574
--# expr-start 2890 LogicAnd And_Pred_4 nodes.lkt:4575
--# expr-start 2885 LogicAnd And_Pred_3 nodes.lkt:4576
--# expr-start 2879 LogicAnd And_Pred_2 nodes.lkt:4577
--# expr-start 2875 LogicAnd And_Pred_1 nodes.lkt:4578
--# expr-start 2868 LogicAnd And_Pred nodes.lkt:4579
--# expr-start 2865 LktNode.xref_equation Fld_1 nodes.lkt:4579



--# expr-start 2864 KeepExpr.expr Fld nodes.lkt:4579







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Keep_Expr_F_Expr, Info => Ent.Info);
--# expr-done 2864



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2865
--# expr-start 2867 LktNode.xref_equation Fld_3 nodes.lkt:4580



--# expr-start 2866 KeepExpr.keep_type Fld_2 nodes.lkt:4580







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Keep_Expr_F_Keep_Type, Info => Ent.Info);
--# expr-done 2866



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_3 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld_2.Node, E_Info => Fld_2.Info);
--# end
--# expr-done 2867
And_Pred := Create_And (Fld_1, Fld_3, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4579:29") else null)); 
--# expr-done 2868
--# expr-start 2874 LogicPropagate Bind_Result nodes.lkt:4582
--# expr-start 2869 Expr.actual_type_var Fld_4 nodes.lkt:4582







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2869
Fld_4.Value := No_Entity;
Entity_Vars.Reset (Fld_4);

--# expr-start 2871 Expr.actual_type_var Fld_6 nodes.lkt:4584



--# expr-start 2870 KeepExpr.expr Fld_5 nodes.lkt:4584







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Expr (Node => Ent.Node.Keep_Expr_F_Expr, Info => Ent.Info);
--# expr-done 2870



   if Fld_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Fld_5.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2871
Fld_6.Value := No_Entity;
Entity_Vars.Reset (Fld_6);
--# expr-start 2873 TypeRef.type_var Fld_8 nodes.lkt:4585



--# expr-start 2872 KeepExpr.keep_type Fld_7 nodes.lkt:4585







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Keep_Expr_F_Keep_Type, Info => Ent.Info);
--# expr-done 2872



   if Fld_7.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Fld_7.Node.Type_Ref_F_Type_Var'Unrestricted_Access;
--# expr-done 2873
Fld_8.Value := No_Entity;
Entity_Vars.Reset (Fld_8);
Bind_Result := Solver.Create_N_Propagate (Fld_4, Create_Decl_P_Get_Keep_Type_0_Functor (2), (1 => Fld_6, 2 => Fld_8)); 
--# expr-done 2874
And_Pred_1 := Create_And (And_Pred, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4578:25") else null)); 
--# expr-done 2875
--# expr-start 2878 LogicAssign Bind_Result_1 nodes.lkt:4588
--# expr-start 2877 Expr.expected_type_var Fld_10 nodes.lkt:4588



--# expr-start 2876 KeepExpr.expr Fld_9 nodes.lkt:4588







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Create_Internal_Entity_Expr (Node => Ent.Node.Keep_Expr_F_Expr, Info => Ent.Info);
--# expr-done 2876



   if Fld_9.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Fld_9.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2877
Fld_10.Value := No_Entity;
Entity_Vars.Reset (Fld_10);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_10, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4588:26") else null)); 
--# expr-done 2878
And_Pred_2 := Create_And (And_Pred_1, Bind_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4577:21") else null)); 
--# expr-done 2879




   --# scope-start



--# expr-start 2884 bind Dyn_Var_Bind_Result nodes.lkt:4591





--# expr-start 2880 KeepExpr.expr Fld_11 nodes.lkt:4591







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Self.Keep_Expr_F_Expr;
--# expr-done 2880



   
      Cast_Result_1 := Fld_11;


Error_Location := Cast_Result_1; 
--# expr-start 2883 LogicPropagate Pred nodes.lkt:4592
--# expr-start 2882 Expr.actual_type_var Fld_13 nodes.lkt:4592



--# expr-start 2881 KeepExpr.expr Fld_12 nodes.lkt:4592







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_12 := Create_Internal_Entity_Expr (Node => Ent.Node.Keep_Expr_F_Expr, Info => Ent.Info);
--# expr-done 2881



   if Fld_12.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_13 := Fld_12.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2882
Fld_13.Value := No_Entity;
Entity_Vars.Reset (Fld_13);

Pred := Solver.Create_Predicate (Fld_13, Create_Type_Decl_P_Is_Of_Array_Type_0_Predicate (Error_Location)); 
--# expr-done 2883
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2884
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_810;


And_Pred_3 := Create_And (And_Pred_2, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4576:17") else null)); 
--# expr-done 2885
--# expr-start 2889 LogicPropagate Bind_Result_2 nodes.lkt:4595
--# expr-start 2887 Expr.actual_type_var Fld_16 nodes.lkt:4596



--# expr-start 2886 KeepExpr.expr Fld_15 nodes.lkt:4596







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_15 := Create_Internal_Entity_Expr (Node => Ent.Node.Keep_Expr_F_Expr, Info => Ent.Info);
--# expr-done 2886



   if Fld_15.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_16 := Fld_15.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2887
Fld_16.Value := No_Entity;
Entity_Vars.Reset (Fld_16);
--# expr-start 2888 KeepExpr.array_element_type Fld_14 nodes.lkt:4595







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_14 := Ent.Node.Keep_Expr_F_Array_Element_Type'Unrestricted_Access;
--# expr-done 2888
Fld_14.Value := No_Entity;
Entity_Vars.Reset (Fld_14);

Bind_Result_2 := Solver.Create_Propagate (Fld_16, Fld_14, Create_Type_Decl_P_Get_Array_Content_Type_0_Functor); 
--# expr-done 2889
And_Pred_4 := Create_And (And_Pred_3, Bind_Result_2, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4575:13") else null)); 
--# expr-done 2890




   --# scope-start



--# expr-start 2896 bind Dyn_Var_Bind_Result_1 nodes.lkt:4599





--# expr-start 2891 KeepExpr.keep_type Fld_17 nodes.lkt:4599







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_17 := Self.Keep_Expr_F_Keep_Type;
--# expr-done 2891



   
      Cast_Result_2 := Fld_17;


Error_Location_1 := Cast_Result_2; 
--# expr-start 2895 LogicPropagate Pred_1 nodes.lkt:4600
--# expr-start 2892 KeepExpr.array_element_type Fld_18 nodes.lkt:4601







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_18 := Ent.Node.Keep_Expr_F_Array_Element_Type'Unrestricted_Access;
--# expr-done 2892
Fld_18.Value := No_Entity;
Entity_Vars.Reset (Fld_18);
--# expr-start 2894 TypeRef.type_var Fld_20 nodes.lkt:4602



--# expr-start 2893 KeepExpr.keep_type Fld_19 nodes.lkt:4602







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_19 := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Keep_Expr_F_Keep_Type, Info => Ent.Info);
--# expr-done 2893



   if Fld_19.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_20 := Fld_19.Node.Type_Ref_F_Type_Var'Unrestricted_Access;
--# expr-done 2894
Fld_20.Value := No_Entity;
Entity_Vars.Reset (Fld_20);



Pred_1 := Solver.Create_N_Predicate ((Fld_18, Fld_20), Create_Type_Decl_P_Is_Subtype_Or_Eq_0_Predicate (2, True, Error_Location_1)); 
--# expr-done 2895
Dyn_Var_Bind_Result_1 := Pred_1; Inc_Ref (Dyn_Var_Bind_Result_1);
--# expr-done 2896
Scope_Result_1 := Dyn_Var_Bind_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_811;


And_Pred_5 := Create_And (And_Pred_4, Scope_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4574:9") else null)); 
--# expr-done 2897

         Property_Result := And_Pred_5;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_349;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_349;
                     Finalizer_Scope_810;
                     Finalizer_Scope_811;




            raise;
      end;



   return Property_Result;
end Keep_Expr_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Lambda_Expr
   --

   



   

   

   

   

   

   

   


      procedure Lambda_Expr_Pre_Env_Actions
        (Self            : Bare_Lambda_Expr;
         State           : in out PLE_Node_State;
         Add_To_Env_Only : Boolean := False) is
      begin
            


   
      if Add_To_Env_Only then
         return;
      end if;

      declare
         No_Parent         : constant Boolean :=
            False;
         Transitive_Parent : constant Boolean :=
            False;
         Names             : Symbol_Type_Array_Access :=
            null;
      begin
         Add_Env (Self, State, No_Parent, Transitive_Parent, Names);
      end;
   
   
      end;



      
      procedure Initialize_Fields_For_Lambda_Expr
        (Self : Bare_Lambda_Expr
         ; Lambda_Expr_F_Params : Bare_Lambda_Param_Decl_List
         ; Lambda_Expr_F_Return_Type : Bare_Type_Ref
         ; Lambda_Expr_F_Body : Bare_Expr
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Lambda_Expr_F_Params := Lambda_Expr_F_Params;
            Self.Lambda_Expr_F_Return_Type := Lambda_Expr_F_Return_Type;
            Self.Lambda_Expr_F_Body := Lambda_Expr_F_Body;
         

      end Initialize_Fields_For_Lambda_Expr;

      
   function Lambda_Expr_F_Params
     (Node : Bare_Lambda_Expr) return Bare_Lambda_Param_Decl_List
   is
      

   begin
         
         return Node.Lambda_Expr_F_Params;
      
   end;

      
   function Lambda_Expr_F_Return_Type
     (Node : Bare_Lambda_Expr) return Bare_Type_Ref
   is
      

   begin
         
         return Node.Lambda_Expr_F_Return_Type;
      
   end;

      
   function Lambda_Expr_F_Body
     (Node : Bare_Lambda_Expr) return Bare_Expr
   is
      

   begin
         
         return Node.Lambda_Expr_F_Body;
      
   end;


   







--# property-start LambdaExpr.has_context_free_type nodes.lkt:4618
pragma Warnings (Off, "is not referenced");

function Lambda_Expr_P_Has_Context_Free_Type
  
  (Node : Bare_Lambda_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Lambda_Expr :=
     Bare_Lambda_Expr (Node);
     Ent : Internal_Entity_Lambda_Expr :=
       Internal_Entity_Lambda_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Fld : Internal_Entity_Expr;
Fld_1 : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 2899 Expr.has_context_free_type Fld_1 nodes.lkt:4618



--# expr-start 2898 LambdaExpr.body Fld nodes.lkt:4618







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Lambda_Expr_F_Body, Info => Ent.Info);
--# expr-done 2898



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2899

         Property_Result := Fld_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Lambda_Expr_P_Has_Context_Free_Type;
--# end

   







--# property-start LambdaExpr.expected_type_equation nodes.lkt:4620
pragma Warnings (Off, "is not referenced");

function Lambda_Expr_P_Expected_Type_Equation
  
  (Node : Bare_Lambda_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Lambda_Expr :=
     Bare_Lambda_Expr (Node);
     Ent : Internal_Entity_Lambda_Expr :=
       Internal_Entity_Lambda_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_351 with Inline_Always;

      False_Rel : Logic_Equation;
Fld : Internal_Entity_Expr;
Fld_1 : Boolean;
Fld_2 : Internal_Entity_Expr;
Fld_3 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
If_Result : Logic_Equation;

            procedure Finalizer_Scope_351 is
            begin
                     Dec_Ref (False_Rel);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (If_Result);
            end Finalizer_Scope_351;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 2906 If If_Result nodes.lkt:4621



--# expr-start 2901 Expr.xref_entry_point Fld_1 nodes.lkt:4621



--# expr-start 2900 LambdaExpr.body Fld nodes.lkt:4621







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Lambda_Expr_F_Body, Info => Ent.Info);
--# expr-done 2900



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_entry_point'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Entry_Point (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 2901
if Fld_1 then
   --# expr-start 2904 LogicAssign Bind_Result nodes.lkt:4622
--# expr-start 2903 Expr.expected_type_var Fld_3 nodes.lkt:4622



--# expr-start 2902 LambdaExpr.body Fld_2 nodes.lkt:4622







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Ent.Node.Lambda_Expr_F_Body, Info => Ent.Info);
--# expr-done 2902



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Fld_2.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2903
Fld_3.Value := No_Entity;
Entity_Vars.Reset (Fld_3);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result := Solver.Create_Assign (Fld_3, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4622:14") else null)); 
--# expr-done 2904
   If_Result := Bind_Result;
else
   --# expr-start 2905 LogicFalse False_Rel nodes.lkt:4623
False_Rel := Solver.Create_False ((if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4623:14") else null)); 
--# expr-done 2905
   If_Result := False_Rel;
end if;

      Inc_Ref (If_Result);


--# expr-done 2906

         Property_Result := If_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_351;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_351;




            raise;
      end;



   return Property_Result;
end Lambda_Expr_P_Expected_Type_Equation;
--# end

   







--# property-start LambdaExpr.generic_type_equation nodes.lkt:4625
pragma Warnings (Off, "is not referenced");

function Lambda_Expr_P_Generic_Type_Equation
  
  (Node : Bare_Lambda_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Lambda_Expr :=
     Bare_Lambda_Expr (Node);
     Ent : Internal_Entity_Lambda_Expr :=
       Internal_Entity_Lambda_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_352 with Inline_Always;
            procedure Finalizer_Scope_812 with Inline_Always;
            procedure Finalizer_Scope_816 with Inline_Always;

      Node_Parents : Bare_Lkt_Node_Array_Access;
Is_A : Boolean;
Find_Result : Bare_Lkt_Node;
Var_Expr : Bare_Lkt_Node;
Fld : Internal_Entity_Type_Decl;
Cast_Result : Bare_Call_Expr;
Fld_1 : Bare_Argument_List;
Get_Result : Bare_Argument;
Var_Expr_1 : Bare_Argument;
Node_Comp : Boolean;
Scope_Result : Boolean;
Result_Var : Boolean;
Fld_2 : Internal_Entity_Type_Decl;
If_Result : Internal_Entity_Type_Decl;
Scope_Result_1 : Internal_Entity_Type_Decl;
Fld_3 : Internal_Entity_Type_Decl;
Result_Var_1 : Internal_Entity_Type_Decl;
Local_Lambda_Type : Internal_Entity_Type_Decl;
Fld_4 : Internal_Entity_Lambda_Param_Decl_List;
Item_1 : Internal_Entity_Lambda_Param_Decl;
True_Rel : Logic_Equation;
Fld_5 : Internal_Entity_Type_Ref;
Is_Null : Boolean;
Is_Null_1 : Boolean;
Not_Val : Boolean;
If_Result_1 : Boolean;
Fld_6 : Logic_Var;
Fld_7 : Internal_Entity_Type_Decl;
Cast_Result_1 : Internal_Entity;
Bind_Result : Logic_Equation;
If_Result_2 : Logic_Equation;
Fld_8 : Bare_Lambda_Param_Decl_List;
Fld_9 : Internal_Entity_Info;
Bare_Item_1 : Bare_Lambda_Param_Decl;
As_Entity : Internal_Entity_Lambda_Param_Decl;
Is_Null_2 : Boolean;
If_Result_3 : Internal_Entity_Lambda_Param_Decl;
Map_Result : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;
Let_Result : Logic_Equation;
Scope_Result_2 : Logic_Equation;

            procedure Finalizer_Scope_352 is
            begin
                     Dec_Ref (Scope_Result_2);
            end Finalizer_Scope_352;
            procedure Finalizer_Scope_812 is
            begin
                     Dec_Ref (Node_Parents);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Logic_Boolean_Op);
                     Dec_Ref (Let_Result);
            end Finalizer_Scope_812;
            procedure Finalizer_Scope_816 is
            begin
                     Dec_Ref (True_Rel);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (If_Result_2);
            end Finalizer_Scope_816;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 2932 ValDecl Let_Result nodes.lkt:4626
--# scope-start
--# expr-start 2919 .do Result_Var_1 nodes.lkt:4627



--# expr-start 2909 .find Find_Result nodes.lkt:4627








   

   --# expr-start 2907 LktNode.parents Node_Parents nodes.lkt:4627







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



Node_Parents := Parents (Self, True); 
--# expr-done 2907

   
      Find_Result := No_Bare_Lkt_Node;
   

   

      

      declare
         
         Collection : constant Bare_Lkt_Node_Array_Access := Node_Parents;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind p Item

            
      --# expr-start 2908 IsA Is_A nodes.lkt:4627

Is_A := Item /= null 
and then Item.Kind in Lkt_Call_Expr_Range; 
--# expr-done 2908
      if Is_A then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Is_A;

         end loop;
      end;
   

   
   



--# expr-done 2909
Var_Expr := Find_Result;





if Var_Expr /= No_Bare_Lkt_Node then
   



   --# scope-start



--# expr-start 2917 If If_Result nodes.lkt:4629



--# expr-start 2914 .do Result_Var nodes.lkt:4629



--# expr-start 2912 .at Get_Result nodes.lkt:4629




--# expr-start 2911 BaseCallExpr.args Fld_1 nodes.lkt:4629



--# expr-start 2910 Cast Cast_Result nodes.lkt:4629









   if Var_Expr = null
      or else Var_Expr.Kind in Lkt_Call_Expr_Range
   then
      
      Cast_Result := Var_Expr;

   else
         Cast_Result := No_Bare_Lkt_Node;
   end if;


--# expr-done 2910



   if Cast_Result = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Cast_Result.Base_Call_Expr_F_Args;
--# expr-done 2911



   if Fld_1 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;




Get_Result := Get (Self, Fld_1, 0, True); 
--# expr-done 2912
Var_Expr_1 := Get_Result;





if Var_Expr_1 /= No_Bare_Lkt_Node then
   



   --# scope-start



--# expr-start 2913 'OrderingTest <OrderingTestKind.greater_or_equal: 4>' Node_Comp nodes.lkt:4629



Node_Comp := Compare (Self, Self, Var_Expr_1, Greater_Or_Equal); 
--# expr-done 2913
Scope_Result := Node_Comp;


   --# end


   Result_Var := Scope_Result;
else
   
   Result_Var := False;
end if;



--# expr-done 2914
if Result_Var then
   --# expr-start 2915 Expr.get_generic_type Fld_2 nodes.lkt:4632







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_generic_type
Fld_2 := Liblktlang.Implementation.Expr_P_Get_Generic_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2915
   If_Result := Fld_2;
else
   --# expr-start 2916 Expr.get_expected_type Fld nodes.lkt:4636







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_expected_type
Fld := Liblktlang.Implementation.Expr_P_Get_Expected_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2916
   If_Result := Fld;
end if;



--# expr-done 2917
Scope_Result_1 := If_Result;


   --# end


   Result_Var_1 := Scope_Result_1;
else
   --# expr-start 2918 Expr.get_generic_type Fld_3 nodes.lkt:4638







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_generic_type
Fld_3 := Liblktlang.Implementation.Expr_P_Get_Generic_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2918
   Result_Var_1 := Fld_3;
end if;



--# expr-done 2919
Local_Lambda_Type := Result_Var_1; 
--# bind lambda_type Local_Lambda_Type
--# expr-start 2931 .logic_all Logic_Boolean_Op nodes.lkt:4643








   

   --# expr-start 2920 LambdaExpr.params Fld_4 nodes.lkt:4643







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Lambda_Param_Decl_List (Node => Ent.Node.Lambda_Expr_F_Params, Info => Ent.Info);
--# expr-done 2920









Fld_8 := Fld_4.Node;

   
      declare
         Map_Result_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      if Fld_8 = null then
         
      Map_Result := Create_Logic_Equation_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Lambda_Param_Decl_List := Fld_8;
      begin
         for Untyped_Item_1 of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item_1 := Untyped_Item_1; 
                  



Is_Null_2 := Bare_Item_1 = null; 
if Is_Null_2 then
   
   If_Result_3 := No_Entity_Lambda_Param_Decl;
else
   








Fld_9 := Fld_4.Info;

As_Entity := (Info => Fld_9, Node => Bare_Item_1); 
   If_Result_3 := As_Entity;
end if;



                  Item_1 := If_Result_3; 

            
   --# scope-start


               --# bind p Item_1

            
         
         
      --# expr-start 2930 If If_Result_2 nodes.lkt:4645



--# expr-start 2925 BooleanAnd If_Result_1 nodes.lkt:4645



--# expr-start 2922 .is_null Is_Null nodes.lkt:4645
--# expr-start 2921 LambdaParamDecl.decl_type Fld_5 nodes.lkt:4645







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Type_Ref (Node => Item_1.Node.Lambda_Param_Decl_F_Decl_Type, Info => Item_1.Info);
--# expr-done 2921
Is_Null := Fld_5.Node = null; 
--# expr-done 2922
if Is_Null then
   --# expr-start 2924 Not Not_Val nodes.lkt:4645
--# expr-start 2923 .is_null Is_Null_1 nodes.lkt:4645

Is_Null_1 := Local_Lambda_Type.Node = null; 
--# expr-done 2923
Not_Val := not (Is_Null_1); 
--# expr-done 2924
   If_Result_1 := Not_Val;
else
   
   If_Result_1 := False;
end if;



--# expr-done 2925
if If_Result_1 then
   --# expr-start 2928 LogicAssign Bind_Result nodes.lkt:4646
--# expr-start 2926 LambdaParamDecl.type_var Fld_6 nodes.lkt:4646







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Item_1.Node.Lambda_Param_Decl_F_Type_Var'Unrestricted_Access;
--# expr-done 2926
Fld_6.Value := No_Entity;
Entity_Vars.Reset (Fld_6);





--# expr-start 2927 TypeDecl.lambda_param_get_type Fld_7 nodes.lkt:4646







   if Local_Lambda_Type.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start TypeDecl.lambda_param_get_type
Fld_7 := Liblktlang.Implementation.Type_Decl_P_Lambda_Param_Get_Type (Node => Local_Lambda_Type.Node, Param_Decl => Item_1, E_Info => Local_Lambda_Type.Info);
--# end
--# expr-done 2927



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Fld_7.Node,
         Info => Fld_7.Info);


Bind_Result := Solver.Create_Assign (Fld_6, Cast_Result_1, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4646:18") else null)); 
--# expr-done 2928
   If_Result_2 := Bind_Result;
else
   --# expr-start 2929 LogicTrue True_Rel nodes.lkt:4647
True_Rel := Solver.Create_True ((if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4647:18") else null)); 
--# expr-done 2929
   If_Result_2 := True_Rel;
end if;

      Inc_Ref (If_Result_2);


--# expr-done 2930
      

         declare
            Item_To_Append : constant Logic_Equation := If_Result_2;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_816;



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4643:21") else null)); 
--# expr-done 2931
Let_Result := Logic_Boolean_Op; Inc_Ref (Let_Result);
--# end
--# expr-done 2932
Scope_Result_2 := Let_Result;
   Inc_Ref (Scope_Result_2);


   --# end
      Finalizer_Scope_812;



         Property_Result := Scope_Result_2;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_352;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_352;
                     Finalizer_Scope_812;
                     Finalizer_Scope_816;




            raise;
      end;



   return Property_Result;
end Lambda_Expr_P_Generic_Type_Equation;
--# end

   







--# property-start LambdaExpr.xref_equation nodes.lkt:4651
pragma Warnings (Off, "is not referenced");

function Lambda_Expr_P_Xref_Equation
  
  (Node : Bare_Lambda_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Lambda_Expr :=
     Bare_Lambda_Expr (Node);
     Ent : Internal_Entity_Lambda_Expr :=
       Internal_Entity_Lambda_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_353 with Inline_Always;
            procedure Finalizer_Scope_817 with Inline_Always;

      Fld : Internal_Entity_Lambda_Param_Decl_List;
Item : Internal_Entity_Lambda_Param_Decl;
Fld_1 : Logic_Var;
Fld_2 : Bare_Lambda_Param_Decl_List;
Fld_3 : Internal_Entity_Info;
Bare_Item : Bare_Lambda_Param_Decl;
As_Entity : Internal_Entity_Lambda_Param_Decl;
Is_Null : Boolean;
If_Result : Internal_Entity_Lambda_Param_Decl;
Map_Result : Logic_Var_Array_Access;
Local_Param_Type_Vars : Logic_Var_Array_Access;
Fld_4 : Internal_Entity_Expr;
Fld_5 : Logic_Equation;
Fld_6 : Logic_Var;
Fld_7 : Internal_Entity_Expr;
Fld_8 : Logic_Var;
Array_Lit : Logic_Var_Array_Access;
Concat_Result : Logic_Var_Array_Access;
Logic_Vars : Logic_Var_Array_Access;
Bind_Result : Logic_Equation;
And_Pred : Logic_Equation;
Fld_9 : Boolean;
Fld_10 : Logic_Var;
Fld_11 : Internal_Entity_Expr;
Fld_12 : Internal_Entity_Type_Decl;
Var_Expr : Internal_Entity_Type_Decl;
Fld_13 : Internal_Entity_Lambda_Param_Decl_List;
Item_1 : Internal_Entity_Lambda_Param_Decl;
Fld_14 : Internal_Entity_Type_Decl;
Fld_15 : Bare_Lambda_Param_Decl_List;
Fld_16 : Internal_Entity_Info;
Bare_Item_1 : Bare_Lambda_Param_Decl;
As_Entity_1 : Internal_Entity_Lambda_Param_Decl;
Is_Null_1 : Boolean;
If_Result_1 : Internal_Entity_Lambda_Param_Decl;
Map_Result_1 : Internal_Entity_Type_Decl_Array_Access;
Fld_17 : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result_1 : Logic_Equation;
If_Result_2 : Logic_Equation;
Fld_18 : Internal_Entity_Type_Ref;
Is_Null_2 : Boolean;
Not_Val : Boolean;
True_Rel : Logic_Equation;
If_Result_3 : Logic_Equation;
Fld_19 : Internal_Entity_Expr;
Fld_20 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result_1 : Internal_Entity;
Bind_Result_2 : Logic_Equation;
Fld_21 : Internal_Entity_Expr;
Fld_22 : Logic_Var;
Fld_23 : Internal_Entity_Type_Decl;
Var_Expr_1 : Internal_Entity_Type_Decl;
Fld_24 : Internal_Entity_Type_Decl;
Result_Var_1 : Internal_Entity_Type_Decl;
Cast_Result_2 : Internal_Entity;
Bind_Result_3 : Logic_Equation;
Fld_25 : Logic_Var;
Pred : Logic_Equation;
And_Pred_1 : Logic_Equation;
Or_Pred : Logic_Equation;
Fld_26 : Boolean;
True_Rel_1 : Logic_Equation;
If_Result_4 : Logic_Equation;
And_Pred_2 : Logic_Equation;
Let_Result : Logic_Equation;
Scope_Result : Logic_Equation;

            procedure Finalizer_Scope_353 is
            begin
                     Dec_Ref (Scope_Result);
            end Finalizer_Scope_353;
            procedure Finalizer_Scope_817 is
            begin
                     Dec_Ref (Map_Result);
                     Dec_Ref (Local_Param_Type_Vars);
                     Dec_Ref (Fld_5);
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Concat_Result);
                     Dec_Ref (Logic_Vars);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (If_Result_2);
                     Dec_Ref (True_Rel);
                     Dec_Ref (If_Result_3);
                     Dec_Ref (Bind_Result_2);
                     Dec_Ref (Bind_Result_3);
                     Dec_Ref (Pred);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Or_Pred);
                     Dec_Ref (True_Rel_1);
                     Dec_Ref (If_Result_4);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Let_Result);
            end Finalizer_Scope_817;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 2975 ValDecl Let_Result nodes.lkt:4652
--# scope-start
--# expr-start 2935 .map Map_Result nodes.lkt:4652








   

   --# expr-start 2933 LambdaExpr.params Fld nodes.lkt:4652







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Lambda_Param_Decl_List (Node => Ent.Node.Lambda_Expr_F_Params, Info => Ent.Info);
--# expr-done 2933









Fld_2 := Fld.Node;

   
      declare
         Map_Result_Vec : Logic_Var_Vectors.Vector;
      begin
   

   

      if Fld_2 = null then
         
      Map_Result := Create_Logic_Var_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Lambda_Param_Decl_List := Fld_2;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Lambda_Param_Decl;
else
   








Fld_3 := Fld.Info;

As_Entity := (Info => Fld_3, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind p Item

            
         
         
      --# expr-start 2934 LambdaParamDecl.type_var Fld_1 nodes.lkt:4652







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Item.Node.Lambda_Param_Decl_F_Type_Var'Unrestricted_Access;
--# expr-done 2934
      

         declare
            Item_To_Append : constant Logic_Var := Fld_1;
         begin
            Logic_Var_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Logic_Var_Array
           (Items_Count => Natural (Logic_Var_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Logic_Var_Vectors.Get
              (Map_Result_Vec,
               I + Logic_Var_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Logic_Var_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 2935
Local_Param_Type_Vars := Map_Result; Inc_Ref (Local_Param_Type_Vars);
--# bind param_type_vars Local_Param_Type_Vars
--# expr-start 2974 LogicAnd And_Pred_2 nodes.lkt:4654
--# expr-start 2958 If If_Result_3 nodes.lkt:4655



--# expr-start 2938 Not Not_Val nodes.lkt:4655
--# expr-start 2937 .is_null Is_Null_2 nodes.lkt:4655
--# expr-start 2936 LambdaExpr.return_type Fld_18 nodes.lkt:4655







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_18 := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Lambda_Expr_F_Return_Type, Info => Ent.Info);
--# expr-done 2936
Is_Null_2 := Fld_18.Node = null; 
--# expr-done 2937
Not_Val := not (Is_Null_2); 
--# expr-done 2938
if Not_Val then
   --# expr-start 2939 LogicTrue True_Rel nodes.lkt:4659
True_Rel := Solver.Create_True ((if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4659:17") else null)); 
--# expr-done 2939
   If_Result_3 := True_Rel;
else
   --# expr-start 2957 If If_Result_2 nodes.lkt:4655



--# expr-start 2940 LambdaExpr.has_context_free_type Fld_9 nodes.lkt:4663







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_9 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2940
if Fld_9 then
   --# expr-start 2948 LogicAssign Bind_Result_1 nodes.lkt:4665
--# expr-start 2941 Expr.actual_type_var Fld_10 nodes.lkt:4665







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2941
Fld_10.Value := No_Entity;
Entity_Vars.Reset (Fld_10);








--# expr-start 2943 Expr.get_type Fld_12 nodes.lkt:4666



--# expr-start 2942 LambdaExpr.body Fld_11 nodes.lkt:4666







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Create_Internal_Entity_Expr (Node => Ent.Node.Lambda_Expr_F_Body, Info => Ent.Info);
--# expr-done 2942



   if Fld_11.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.get_type'
Fld_12 := Liblktlang.Implementation.Dispatcher_Expr_P_Get_Type (Node => Fld_11.Node, E_Info => Fld_11.Info);
--# end
--# expr-done 2943
Var_Expr := Fld_12;





if Var_Expr /= No_Entity_Type_Decl then
   --# expr-start 2947 TypeDecl.create_function_type Fld_17 nodes.lkt:4666







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 2946 .map Map_Result_1 nodes.lkt:4667








   

   --# expr-start 2944 LambdaExpr.params Fld_13 nodes.lkt:4667







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_13 := Create_Internal_Entity_Lambda_Param_Decl_List (Node => Ent.Node.Lambda_Expr_F_Params, Info => Ent.Info);
--# expr-done 2944









Fld_15 := Fld_13.Node;

   
      declare
         Map_Result_1_Vec : Internal_Entity_Type_Decl_Vectors.Vector;
      begin
   

   

      if Fld_15 = null then
         
      Map_Result_1 := Create_Internal_Entity_Type_Decl_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Lambda_Param_Decl_List := Fld_15;
      begin
         for Untyped_Item_1 of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item_1 := Untyped_Item_1; 
                  



Is_Null_1 := Bare_Item_1 = null; 
if Is_Null_1 then
   
   If_Result_1 := No_Entity_Lambda_Param_Decl;
else
   








Fld_16 := Fld_13.Info;

As_Entity_1 := (Info => Fld_16, Node => Bare_Item_1); 
   If_Result_1 := As_Entity_1;
end if;



                  Item_1 := If_Result_1; 

            
   --# scope-start


               --# bind a Item_1

            
         
         
      --# expr-start 2945 Decl.get_type Fld_14 nodes.lkt:4667







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Decl.get_type
Fld_14 := Liblktlang.Implementation.Decl_P_Get_Type (Node => Item_1.Node, E_Info => Item_1.Info);
--# end
--# expr-done 2945
      

         declare
            Item_To_Append : constant Internal_Entity_Type_Decl := Fld_14;
         begin
            Internal_Entity_Type_Decl_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result_1 := Create_Internal_Entity_Type_Decl_Array
           (Items_Count => Natural (Internal_Entity_Type_Decl_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Internal_Entity_Type_Decl_Vectors.Get
              (Map_Result_1_Vec,
               I + Internal_Entity_Type_Decl_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Internal_Entity_Type_Decl_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 2946
--# property-call-start TypeDecl.create_function_type
Fld_17 := Liblktlang.Implementation.Type_Decl_P_Create_Function_Type (Node => Var_Expr.Node, Params => Map_Result_1, E_Info => Var_Expr.Info);
--# end
--# expr-done 2947
   Result_Var := Fld_17;
else
   
   Result_Var := No_Entity_Type_Decl;
end if;






   
      Cast_Result := Create_Internal_Entity
        (Node => Result_Var.Node,
         Info => Result_Var.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_10, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4665:17") else null)); 
--# expr-done 2948
   If_Result_2 := Bind_Result_1;
else
   --# expr-start 2956 LogicAnd And_Pred nodes.lkt:4670
--# expr-start 2950 LktNode.xref_equation Fld_5 nodes.lkt:4670



--# expr-start 2949 LambdaExpr.body Fld_4 nodes.lkt:4670







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Expr (Node => Ent.Node.Lambda_Expr_F_Body, Info => Ent.Info);
--# expr-done 2949



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_5 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld_4.Node, E_Info => Fld_4.Info);
--# end
--# expr-done 2950
--# expr-start 2954 ArrayConcat Concat_Result nodes.lkt:4673
--# expr-start 2953 ArrayLiteral Array_Lit nodes.lkt:4673
--# expr-start 2952 Expr.actual_type_var Fld_8 nodes.lkt:4673



--# expr-start 2951 LambdaExpr.body Fld_7 nodes.lkt:4673







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Create_Internal_Entity_Expr (Node => Ent.Node.Lambda_Expr_F_Body, Info => Ent.Info);
--# expr-done 2951



   if Fld_7.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Fld_7.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2952
Array_Lit := Create_Logic_Var_Array (Internal_Logic_Var_Array'(1 => Fld_8)); 
--# expr-done 2953

Concat_Result := Concat (Array_Lit, Local_Param_Type_Vars); 
--# expr-done 2954
for Var of Concat_Result.Items loop
   Var.Value := No_Entity;
   Entity_Vars.Reset (Var);
end loop;
Logic_Vars := Concat_Result; Inc_Ref (Logic_Vars);
--# expr-start 2955 Expr.actual_type_var Fld_6 nodes.lkt:4671







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2955
Fld_6.Value := No_Entity;
Entity_Vars.Reset (Fld_6);


Bind_Result := Solver.Create_N_Propagate (Fld_6, Create_Type_Decl_P_Create_Function_Type_0_Functor (Logic_Vars.N), Entity_Vars.Logic_Var_Array (Logic_Vars.Items)); 
And_Pred := Create_And (Fld_5, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4670:17") else null)); 
--# expr-done 2956
   If_Result_2 := And_Pred;
end if;

      Inc_Ref (If_Result_2);


--# expr-done 2957
   If_Result_3 := If_Result_2;
end if;

      Inc_Ref (If_Result_3);


--# expr-done 2958
--# expr-start 2973 If If_Result_4 nodes.lkt:4677



--# expr-start 2959 LambdaExpr.has_context_free_type Fld_26 nodes.lkt:4677







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_26 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2959
if Fld_26 then
   --# expr-start 2960 LogicTrue True_Rel_1 nodes.lkt:4677
True_Rel_1 := Solver.Create_True ((if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4677:50") else null)); 
--# expr-done 2960
   If_Result_4 := True_Rel_1;
else
   --# expr-start 2972 LogicOr Or_Pred nodes.lkt:4686
--# expr-start 2963 LogicAssign Bind_Result_2 nodes.lkt:4686
--# expr-start 2962 Expr.expected_type_var Fld_20 nodes.lkt:4686



--# expr-start 2961 LambdaExpr.body Fld_19 nodes.lkt:4686







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_19 := Create_Internal_Entity_Expr (Node => Ent.Node.Lambda_Expr_F_Body, Info => Ent.Info);
--# expr-done 2961



   if Fld_19.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_20 := Fld_19.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2962
Fld_20.Value := No_Entity;
Entity_Vars.Reset (Fld_20);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result_2 := Solver.Create_Assign (Fld_20, Cast_Result_1, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4686:17") else null)); 
--# expr-done 2963
--# expr-start 2971 LogicAnd And_Pred_1 nodes.lkt:4688
--# expr-start 2968 LogicAssign Bind_Result_3 nodes.lkt:4688
--# expr-start 2965 Expr.expected_type_var Fld_22 nodes.lkt:4688



--# expr-start 2964 LambdaExpr.body Fld_21 nodes.lkt:4688







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_21 := Create_Internal_Entity_Expr (Node => Ent.Node.Lambda_Expr_F_Body, Info => Ent.Info);
--# expr-done 2964



   if Fld_21.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_22 := Fld_21.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2965
Fld_22.Value := No_Entity;
Entity_Vars.Reset (Fld_22);








--# expr-start 2966 Expr.get_expected_type Fld_23 nodes.lkt:4689







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_expected_type
Fld_23 := Liblktlang.Implementation.Expr_P_Get_Expected_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2966
Var_Expr_1 := Fld_23;





if Var_Expr_1 /= No_Entity_Type_Decl then
   --# expr-start 2967 TypeDecl.get_return_type Fld_24 nodes.lkt:4689







   if Var_Expr_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.get_return_type
Fld_24 := Liblktlang.Implementation.Type_Decl_P_Get_Return_Type (Node => Var_Expr_1.Node, E_Info => Var_Expr_1.Info);
--# end
--# expr-done 2967
   Result_Var_1 := Fld_24;
else
   
   Result_Var_1 := No_Entity_Type_Decl;
end if;






   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Result_Var_1.Node,
         Info => Result_Var_1.Info);


Bind_Result_3 := Solver.Create_Assign (Fld_22, Cast_Result_2, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4688:21") else null)); 
--# expr-done 2968
--# expr-start 2970 LogicPropagate Pred nodes.lkt:4690
--# expr-start 2969 Expr.generic_func_type_var Fld_25 nodes.lkt:4691







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_25 := Ent.Node.Expr_F_Generic_Func_Type_Var'Unrestricted_Access;
--# expr-done 2969
Fld_25.Value := No_Entity;
Entity_Vars.Reset (Fld_25);

Pred := Solver.Create_Predicate (Fld_25, Create_Decl_P_Return_Type_Is_Instantiated_0_Predicate); 
--# expr-done 2970
And_Pred_1 := Create_And (Bind_Result_3, Pred, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4688:21") else null)); 
--# expr-done 2971
Or_Pred := Create_Or (Bind_Result_2, And_Pred_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4686:17") else null)); 
--# expr-done 2972
   If_Result_4 := Or_Pred;
end if;

      Inc_Ref (If_Result_4);


--# expr-done 2973
And_Pred_2 := Create_And (If_Result_3, If_Result_4, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4654:9") else null)); 
--# expr-done 2974
Let_Result := And_Pred_2; Inc_Ref (Let_Result);
--# end
--# expr-done 2975
Scope_Result := Let_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_817;



         Property_Result := Scope_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_353;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_353;
                     Finalizer_Scope_817;




            raise;
      end;



   return Property_Result;
end Lambda_Expr_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Lit
   --

   



      
      procedure Initialize_Fields_For_Lit
        (Self : Bare_Lit
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

         

      end Initialize_Fields_For_Lit;




   


      

   --
   --  Primitives for Bare_Big_Num_Lit
   --

   



      
      procedure Initialize_Fields_For_Big_Num_Lit
        (Self : Bare_Big_Num_Lit
        ) is
      begin
            Initialize_Fields_For_Lit
              (Self);

         

      end Initialize_Fields_For_Big_Num_Lit;


   







--# property-start BigNumLit.xref_equation nodes.lkt:4710
pragma Warnings (Off, "is not referenced");

function Big_Num_Lit_P_Xref_Equation
  
  (Node : Bare_Big_Num_Lit
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Big_Num_Lit :=
     Bare_Big_Num_Lit (Node);
     Ent : Internal_Entity_Big_Num_Lit :=
       Internal_Entity_Big_Num_Lit'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_354 with Inline_Always;

      Fld : Logic_Var;
Fld_1 : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;

            procedure Finalizer_Scope_354 is
            begin
                     Dec_Ref (Bind_Result);
            end Finalizer_Scope_354;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2978 LogicAssign Bind_Result nodes.lkt:4710
--# expr-start 2976 Expr.actual_type_var Fld nodes.lkt:4710







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2976
Fld.Value := No_Entity;
Entity_Vars.Reset (Fld);





--# expr-start 2977 LktNode.bigint_type Fld_1 nodes.lkt:4710







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.bigint_type
Fld_1 := Liblktlang.Implementation.Lkt_Node_P_Bigint_Type (Node => Self);
--# end
--# expr-done 2977



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_1.Node,
         Info => Fld_1.Info);


Bind_Result := Solver.Create_Assign (Fld, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4710:37") else null)); 
--# expr-done 2978

         Property_Result := Bind_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_354;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_354;




            raise;
      end;



   return Property_Result;
end Big_Num_Lit_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Char_Lit
   --

   



      
      procedure Initialize_Fields_For_Char_Lit
        (Self : Bare_Char_Lit
        ) is
      begin
            Initialize_Fields_For_Lit
              (Self);

         

      end Initialize_Fields_For_Char_Lit;


   







--# property-start CharLit.xref_equation nodes.lkt:4720
pragma Warnings (Off, "is not referenced");

function Char_Lit_P_Xref_Equation
  
  (Node : Bare_Char_Lit
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Char_Lit :=
     Bare_Char_Lit (Node);
     Ent : Internal_Entity_Char_Lit :=
       Internal_Entity_Char_Lit'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_356 with Inline_Always;

      Fld : Logic_Var;
Fld_1 : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;

            procedure Finalizer_Scope_356 is
            begin
                     Dec_Ref (Bind_Result);
            end Finalizer_Scope_356;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 2981 LogicAssign Bind_Result nodes.lkt:4720
--# expr-start 2979 Expr.actual_type_var Fld nodes.lkt:4720







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2979
Fld.Value := No_Entity;
Entity_Vars.Reset (Fld);





--# expr-start 2980 LktNode.char_type Fld_1 nodes.lkt:4720







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.char_type
Fld_1 := Liblktlang.Implementation.Lkt_Node_P_Char_Type (Node => Self);
--# end
--# expr-done 2980



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_1.Node,
         Info => Fld_1.Info);


Bind_Result := Solver.Create_Assign (Fld, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4720:37") else null)); 
--# expr-done 2981

         Property_Result := Bind_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_356;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_356;




            raise;
      end;



   return Property_Result;
end Char_Lit_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Null_Lit
   --

   



      
      procedure Initialize_Fields_For_Null_Lit
        (Self : Bare_Null_Lit
         ; Null_Lit_F_Dest_Type : Bare_Type_Ref
        ) is
      begin
            Initialize_Fields_For_Lit
              (Self);

            Self.Null_Lit_F_Dest_Type := Null_Lit_F_Dest_Type;
         

      end Initialize_Fields_For_Null_Lit;

      
   function Null_Lit_F_Dest_Type
     (Node : Bare_Null_Lit) return Bare_Type_Ref
   is
      

   begin
         
         return Node.Null_Lit_F_Dest_Type;
      
   end;


   







--# property-start NullLit.xref_equation nodes.lkt:4729
pragma Warnings (Off, "is not referenced");

function Null_Lit_P_Xref_Equation
  
  (Node : Bare_Null_Lit
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Null_Lit :=
     Bare_Null_Lit (Node);
     Ent : Internal_Entity_Null_Lit :=
       Internal_Entity_Null_Lit'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_357 with Inline_Always;
            procedure Finalizer_Scope_820 with Inline_Always;

      Fld : Logic_Var;
Fld_1 : Internal_Entity_Type_Ref;
Fld_2 : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
Fld_3 : Internal_Entity_Type_Ref;
Is_Null : Boolean;
Fld_4 : Logic_Var;
Fld_5 : Logic_Var;
Bind_Result_1 : Logic_Equation;
Fld_6 : Boolean;
Fld_7 : Logic_Var;
Fld_8 : Internal_Entity_Type_Decl;
Cast_Result_1 : Internal_Entity;
Bind_Result_2 : Logic_Equation;
If_Result : Logic_Equation;
Fld_9 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result_2 : Internal_Entity;
Bind_Result_3 : Logic_Equation;
Or_Pred : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_10 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_3 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred : Logic_Equation;
If_Result_1 : Logic_Equation;

            procedure Finalizer_Scope_357 is
            begin
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (Bind_Result_2);
                     Dec_Ref (If_Result);
                     Dec_Ref (Bind_Result_3);
                     Dec_Ref (Or_Pred);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (If_Result_1);
            end Finalizer_Scope_357;
            procedure Finalizer_Scope_820 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_820;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3003 If If_Result_1 nodes.lkt:4730



--# expr-start 2983 .is_null Is_Null nodes.lkt:4730
--# expr-start 2982 NullLit.dest_type Fld_3 nodes.lkt:4730







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Null_Lit_F_Dest_Type, Info => Ent.Info);
--# expr-done 2982
Is_Null := Fld_3.Node = null; 
--# expr-done 2983
if Is_Null then
   --# expr-start 2998 LogicAnd And_Pred nodes.lkt:4732
--# expr-start 2994 LogicOr Or_Pred nodes.lkt:4733
--# expr-start 2991 If If_Result nodes.lkt:4734



--# expr-start 2984 Expr.xref_entry_point Fld_6 nodes.lkt:4734







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_entry_point'
Fld_6 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Entry_Point (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2984
if Fld_6 then
   --# expr-start 2987 LogicAssign Bind_Result_2 nodes.lkt:4735
--# expr-start 2985 Expr.actual_type_var Fld_7 nodes.lkt:4735







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2985
Fld_7.Value := No_Entity;
Entity_Vars.Reset (Fld_7);





--# expr-start 2986 Expr.get_expected_type Fld_8 nodes.lkt:4735







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_expected_type
Fld_8 := Liblktlang.Implementation.Expr_P_Get_Expected_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 2986



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Fld_8.Node,
         Info => Fld_8.Info);


Bind_Result_2 := Solver.Create_Assign (Fld_7, Cast_Result_1, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4735:26") else null)); 
--# expr-done 2987
   If_Result := Bind_Result_2;
else
   --# expr-start 2990 LogicUnify Bind_Result_1 nodes.lkt:4736
--# expr-start 2988 Expr.actual_type_var Fld_4 nodes.lkt:4736







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2988
Fld_4.Value := No_Entity;
Entity_Vars.Reset (Fld_4);
--# expr-start 2989 Expr.expected_type_var Fld_5 nodes.lkt:4736







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Ent.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 2989
Bind_Result_1 := Solver.Create_Unify (Fld_4, Fld_5, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4736:26") else null)); 
--# expr-done 2990
   If_Result := Bind_Result_1;
end if;

      Inc_Ref (If_Result);


--# expr-done 2991
--# expr-start 2993 LogicAssign Bind_Result_3 nodes.lkt:4745
--# expr-start 2992 Expr.actual_type_var Fld_9 nodes.lkt:4745







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2992
Fld_9.Value := No_Entity;
Entity_Vars.Reset (Fld_9);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result_3 := Solver.Create_Assign (Fld_9, Cast_Result_2, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4745:21") else null)); 
--# expr-done 2993
Or_Pred := Create_Or (If_Result, Bind_Result_3, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4733:17") else null)); 
--# expr-done 2994




   --# scope-start



--# expr-start 2997 bind Dyn_Var_Bind_Result nodes.lkt:4749









   
      Cast_Result_3 := Self;


Error_Location := Cast_Result_3; 
--# expr-start 2996 LogicPropagate Pred nodes.lkt:4750
--# expr-start 2995 Expr.actual_type_var Fld_10 nodes.lkt:4750







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2995
Fld_10.Value := No_Entity;
Entity_Vars.Reset (Fld_10);

Pred := Solver.Create_Predicate (Fld_10, Create_Type_Decl_P_Could_Determine_Type_0_Predicate (Error_Location)); 
--# expr-done 2996
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 2997
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_820;


And_Pred := Create_And (Or_Pred, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4732:13") else null)); 
--# expr-done 2998
   If_Result_1 := And_Pred;
else
   --# expr-start 3002 LogicAssign Bind_Result nodes.lkt:4752
--# expr-start 2999 Expr.actual_type_var Fld nodes.lkt:4752







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 2999
Fld.Value := No_Entity;
Entity_Vars.Reset (Fld);





--# expr-start 3001 TypeRef.referenced_decl Fld_2 nodes.lkt:4752



--# expr-start 3000 NullLit.dest_type Fld_1 nodes.lkt:4752







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Null_Lit_F_Dest_Type, Info => Ent.Info);
--# expr-done 3000



   if Fld_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_2 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Fld_1.Node, E_Info => Fld_1.Info);
--# end
--# expr-done 3001



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_2.Node,
         Info => Fld_2.Info);


Bind_Result := Solver.Create_Assign (Fld, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4752:14") else null)); 
--# expr-done 3002
   If_Result_1 := Bind_Result;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 3003

         Property_Result := If_Result_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_357;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_357;
                     Finalizer_Scope_820;




            raise;
      end;



   return Property_Result;
end Null_Lit_P_Xref_Equation;
--# end

   







--# property-start NullLit.has_context_free_type nodes.lkt:4754
pragma Warnings (Off, "is not referenced");

function Null_Lit_P_Has_Context_Free_Type
  
  (Node : Bare_Null_Lit
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Null_Lit :=
     Bare_Null_Lit (Node);
     Ent : Internal_Entity_Null_Lit :=
       Internal_Entity_Null_Lit'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Fld : Internal_Entity_Type_Ref;
Is_Null : Boolean;
Not_Val : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 3006 Not Not_Val nodes.lkt:4754
--# expr-start 3005 .is_null Is_Null nodes.lkt:4754
--# expr-start 3004 NullLit.dest_type Fld nodes.lkt:4754







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Null_Lit_F_Dest_Type, Info => Ent.Info);
--# expr-done 3004
Is_Null := Fld.Node = null; 
--# expr-done 3005
Not_Val := not (Is_Null); 
--# expr-done 3006

         Property_Result := Not_Val;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Null_Lit_P_Has_Context_Free_Type;
--# end



   


      

   --
   --  Primitives for Bare_Num_Lit
   --

   



      
      procedure Initialize_Fields_For_Num_Lit
        (Self : Bare_Num_Lit
        ) is
      begin
            Initialize_Fields_For_Lit
              (Self);

         

      end Initialize_Fields_For_Num_Lit;


   







--# property-start NumLit.xref_equation nodes.lkt:4759
pragma Warnings (Off, "is not referenced");

function Num_Lit_P_Xref_Equation
  
  (Node : Bare_Num_Lit
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Num_Lit :=
     Bare_Num_Lit (Node);
     Ent : Internal_Entity_Num_Lit :=
       Internal_Entity_Num_Lit'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_359 with Inline_Always;

      Fld : Logic_Var;
Fld_1 : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;

            procedure Finalizer_Scope_359 is
            begin
                     Dec_Ref (Bind_Result);
            end Finalizer_Scope_359;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3009 LogicAssign Bind_Result nodes.lkt:4759
--# expr-start 3007 Expr.actual_type_var Fld nodes.lkt:4759







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3007
Fld.Value := No_Entity;
Entity_Vars.Reset (Fld);





--# expr-start 3008 LktNode.int_type Fld_1 nodes.lkt:4759







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.int_type
Fld_1 := Liblktlang.Implementation.Lkt_Node_P_Int_Type (Node => Self);
--# end
--# expr-done 3008



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_1.Node,
         Info => Fld_1.Info);


Bind_Result := Solver.Create_Assign (Fld, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4759:37") else null)); 
--# expr-done 3009

         Property_Result := Bind_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_359;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_359;




            raise;
      end;



   return Property_Result;
end Num_Lit_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_String_Lit
   --

   



      
      procedure Initialize_Fields_For_String_Lit
        (Self : Bare_String_Lit
        ) is
      begin
            Initialize_Fields_For_Lit
              (Self);

         

      end Initialize_Fields_For_String_Lit;


   







--# property-start '[dispatcher]StringLit.denoted_value' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_String_Lit_P_Denoted_Value
  
  (Node : Bare_String_Lit
  )

   return Internal_Decoded_String_Value
is
   Self : Bare_String_Lit :=
     Bare_String_Lit (Node);
      --# bind node Self

   


   Property_Result : Internal_Decoded_String_Value;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_String_Lit (Self.Kind) is
               when Lkt_Block_String_Lit =>
                  --# property-call-start BlockStringLit.denoted_value
                  Property_Result := Block_String_Lit_P_Denoted_Value
                    (Self
                    );
                  --# end
               when Lkt_Module_Doc_String_Lit =>
                  --# property-call-start ModuleDocStringLit.denoted_value
                  Property_Result := Module_Doc_String_Lit_P_Denoted_Value
                    (Self
                    );
                  --# end
               when Lkt_Single_Line_String_Lit .. Lkt_Pattern_Single_Line_String_Lit =>
                  --# property-call-start SingleLineStringLit.denoted_value
                  Property_Result := Single_Line_String_Lit_P_Denoted_Value
                    (Self
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_String_Lit_P_Denoted_Value;
--# end

   







--# property-start '[dispatcher]StringLit.is_prefixed_string' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_String_Lit_P_Is_Prefixed_String
  
  (Node : Bare_String_Lit
  )

   return Boolean
is
   Self : Bare_String_Lit :=
     Bare_String_Lit (Node);
      --# bind node Self

   


   Property_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_String_Lit (Self.Kind) is
               when Lkt_Block_String_Lit =>
                  --# property-call-start BlockStringLit.is_prefixed_string
                  Property_Result := Block_String_Lit_P_Is_Prefixed_String
                    (Self
                    );
                  --# end
               when Lkt_Module_Doc_String_Lit =>
                  --# property-call-start ModuleDocStringLit.is_prefixed_string
                  Property_Result := Module_Doc_String_Lit_P_Is_Prefixed_String
                    (Self
                    );
                  --# end
               when Lkt_Single_Line_String_Lit .. Lkt_Pattern_Single_Line_String_Lit =>
                  --# property-call-start SingleLineStringLit.is_prefixed_string
                  Property_Result := Single_Line_String_Lit_P_Is_Prefixed_String
                    (Self
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_String_Lit_P_Is_Prefixed_String;
--# end

   







--# property-start '[dispatcher]StringLit.prefix' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_String_Lit_P_Prefix
  
  (Node : Bare_String_Lit
  )

   return Character_Type
is
   Self : Bare_String_Lit :=
     Bare_String_Lit (Node);
      --# bind node Self

   


   Property_Result : Character_Type;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_String_Lit (Self.Kind) is
               when Lkt_Block_String_Lit =>
                  --# property-call-start BlockStringLit.prefix
                  Property_Result := Block_String_Lit_P_Prefix
                    (Self
                    );
                  --# end
               when Lkt_Module_Doc_String_Lit =>
                  --# property-call-start ModuleDocStringLit.prefix
                  Property_Result := Module_Doc_String_Lit_P_Prefix
                    (Self
                    );
                  --# end
               when Lkt_Single_Line_String_Lit .. Lkt_Pattern_Single_Line_String_Lit =>
                  --# property-call-start SingleLineStringLit.prefix
                  Property_Result := Single_Line_String_Lit_P_Prefix
                    (Self
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_String_Lit_P_Prefix;
--# end

   







--# property-start StringLit.is_regexp_literal nodes.lkt:4784
pragma Warnings (Off, "is not referenced");

function String_Lit_P_Is_Regexp_Literal
  
  (Node : Bare_String_Lit
  )

   return Boolean
is
   Self : Bare_String_Lit :=
     Bare_String_Lit (Node);
      --# bind node Self

   


   Property_Result : Boolean;

      

      Fld : Character_Type;
Is_Equal : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 3011 Eq Is_Equal nodes.lkt:4784
--# expr-start 3010 StringLit.prefix Fld nodes.lkt:4784







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]StringLit.prefix'
Fld := Liblktlang.Implementation.Dispatcher_String_Lit_P_Prefix (Node => Self);
--# end
--# expr-done 3010

Is_Equal := Fld = Character_Type'Val (112); 
--# expr-done 3011

         Property_Result := Is_Equal;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end String_Lit_P_Is_Regexp_Literal;
--# end

   







--# property-start StringLit.xref_equation nodes.lkt:4786
pragma Warnings (Off, "is not referenced");

function String_Lit_P_Xref_Equation
  
  (Node : Bare_String_Lit
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_String_Lit :=
     Bare_String_Lit (Node);
     Ent : Internal_Entity_String_Lit :=
       Internal_Entity_String_Lit'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_364 with Inline_Always;

      Fld : Logic_Var;
Fld_1 : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
Fld_2 : Boolean;
Fld_3 : Character_Type;
Is_Equal : Boolean;
If_Result : Boolean;
Fld_4 : Logic_Var;
Fld_5 : Internal_Entity_Named_Type_Decl;
Cast_Result_1 : Internal_Entity;
Bind_Result_1 : Logic_Equation;
If_Result_1 : Logic_Equation;

            procedure Finalizer_Scope_364 is
            begin
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (If_Result_1);
            end Finalizer_Scope_364;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3022 If If_Result_1 nodes.lkt:4787



--# expr-start 3015 BooleanAnd If_Result nodes.lkt:4787



--# expr-start 3012 StringLit.is_prefixed_string Fld_2 nodes.lkt:4787







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]StringLit.is_prefixed_string'
Fld_2 := Liblktlang.Implementation.Dispatcher_String_Lit_P_Is_Prefixed_String (Node => Ent.Node);
--# end
--# expr-done 3012
if Fld_2 then
   --# expr-start 3014 Eq Is_Equal nodes.lkt:4787
--# expr-start 3013 StringLit.prefix Fld_3 nodes.lkt:4787







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]StringLit.prefix'
Fld_3 := Liblktlang.Implementation.Dispatcher_String_Lit_P_Prefix (Node => Ent.Node);
--# end
--# expr-done 3013

Is_Equal := Fld_3 = Character_Type'Val (115); 
--# expr-done 3014
   If_Result := Is_Equal;
else
   
   If_Result := False;
end if;



--# expr-done 3015
if If_Result then
   --# expr-start 3018 LogicAssign Bind_Result_1 nodes.lkt:4788
--# expr-start 3016 Expr.actual_type_var Fld_4 nodes.lkt:4788







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3016
Fld_4.Value := No_Entity;
Entity_Vars.Reset (Fld_4);





--# expr-start 3017 LktNode.symbol_type Fld_5 nodes.lkt:4788







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.symbol_type
Fld_5 := Liblktlang.Implementation.Lkt_Node_P_Symbol_Type (Node => Self);
--# end
--# expr-done 3017



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Fld_5.Node,
         Info => Fld_5.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_4, Cast_Result_1, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4788:14") else null)); 
--# expr-done 3018
   If_Result_1 := Bind_Result_1;
else
   --# expr-start 3021 LogicAssign Bind_Result nodes.lkt:4789
--# expr-start 3019 Expr.actual_type_var Fld nodes.lkt:4789







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3019
Fld.Value := No_Entity;
Entity_Vars.Reset (Fld);





--# expr-start 3020 LktNode.string_type Fld_1 nodes.lkt:4789







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.string_type
Fld_1 := Liblktlang.Implementation.Lkt_Node_P_String_Type (Node => Self);
--# end
--# expr-done 3020



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_1.Node,
         Info => Fld_1.Info);


Bind_Result := Solver.Create_Assign (Fld, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4789:14") else null)); 
--# expr-done 3021
   If_Result_1 := Bind_Result;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 3022

         Property_Result := If_Result_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_364;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_364;




            raise;
      end;



   return Property_Result;
end String_Lit_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Block_String_Lit
   --

   



      
      procedure Initialize_Fields_For_Block_String_Lit
        (Self : Bare_Block_String_Lit
         ; Block_String_Lit_F_Lines : Bare_Block_String_Line_List
        ) is
      begin
            Initialize_Fields_For_String_Lit
              (Self);

            Self.Block_String_Lit_F_Lines := Block_String_Lit_F_Lines;
         

      end Initialize_Fields_For_Block_String_Lit;

      
   function Block_String_Lit_F_Lines
     (Node : Bare_Block_String_Lit) return Bare_Block_String_Line_List
   is
      

   begin
         
         return Node.Block_String_Lit_F_Lines;
      
   end;


   







--# property-start BlockStringLit.is_prefixed_string nodes.lkt:4810
pragma Warnings (Off, "is not referenced");

function Block_String_Lit_P_Is_Prefixed_String
  
  (Node : Bare_Block_String_Lit
  )

   return Boolean
is
   Self : Bare_Block_String_Lit :=
     Bare_Block_String_Lit (Node);
      --# bind node Self

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := False;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Block_String_Lit_P_Is_Prefixed_String;
--# end

   







--# property-start BlockStringLit.prefix nodes.lkt:4812
pragma Warnings (Off, "is not referenced");

function Block_String_Lit_P_Prefix
  
  (Node : Bare_Block_String_Lit
  )

   return Character_Type
is
   Self : Bare_Block_String_Lit :=
     Bare_Block_String_Lit (Node);
      --# bind node Self

   


   Property_Result : Character_Type;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := Character_Type'Val (0);
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Block_String_Lit_P_Prefix;
--# end



   


      

   --
   --  Primitives for Bare_Module_Doc_String_Lit
   --

   



      
      procedure Initialize_Fields_For_Module_Doc_String_Lit
        (Self : Bare_Module_Doc_String_Lit
         ; Module_Doc_String_Lit_F_Lines : Bare_Module_Doc_String_Line_List
        ) is
      begin
            Initialize_Fields_For_String_Lit
              (Self);

            Self.Module_Doc_String_Lit_F_Lines := Module_Doc_String_Lit_F_Lines;
         

      end Initialize_Fields_For_Module_Doc_String_Lit;

      
   function Module_Doc_String_Lit_F_Lines
     (Node : Bare_Module_Doc_String_Lit) return Bare_Module_Doc_String_Line_List
   is
      

   begin
         
         return Node.Module_Doc_String_Lit_F_Lines;
      
   end;


   







--# property-start ModuleDocStringLit.is_prefixed_string nodes.lkt:4841
pragma Warnings (Off, "is not referenced");

function Module_Doc_String_Lit_P_Is_Prefixed_String
  
  (Node : Bare_Module_Doc_String_Lit
  )

   return Boolean
is
   Self : Bare_Module_Doc_String_Lit :=
     Bare_Module_Doc_String_Lit (Node);
      --# bind node Self

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := False;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Module_Doc_String_Lit_P_Is_Prefixed_String;
--# end

   







--# property-start ModuleDocStringLit.prefix nodes.lkt:4843
pragma Warnings (Off, "is not referenced");

function Module_Doc_String_Lit_P_Prefix
  
  (Node : Bare_Module_Doc_String_Lit
  )

   return Character_Type
is
   Self : Bare_Module_Doc_String_Lit :=
     Bare_Module_Doc_String_Lit (Node);
      --# bind node Self

   


   Property_Result : Character_Type;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := Character_Type'Val (0);
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Module_Doc_String_Lit_P_Prefix;
--# end



   


      

   --
   --  Primitives for Bare_Single_Line_String_Lit
   --

   



      
      procedure Initialize_Fields_For_Single_Line_String_Lit
        (Self : Bare_Single_Line_String_Lit
        ) is
      begin
            Initialize_Fields_For_String_Lit
              (Self);

         

      end Initialize_Fields_For_Single_Line_String_Lit;




   


      

   --
   --  Primitives for Bare_Pattern_Single_Line_String_Lit
   --

   



      
      procedure Initialize_Fields_For_Pattern_Single_Line_String_Lit
        (Self : Bare_Pattern_Single_Line_String_Lit
        ) is
      begin
            Initialize_Fields_For_Single_Line_String_Lit
              (Self);

         

      end Initialize_Fields_For_Pattern_Single_Line_String_Lit;




   


      

   --
   --  Primitives for Bare_Logic_Assign
   --

   



      
      procedure Initialize_Fields_For_Logic_Assign
        (Self : Bare_Logic_Assign
         ; Logic_Assign_F_Dest_Var : Bare_Expr
         ; Logic_Assign_F_Value : Bare_Expr
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Logic_Assign_F_Dest_Var := Logic_Assign_F_Dest_Var;
            Self.Logic_Assign_F_Value := Logic_Assign_F_Value;
         

      end Initialize_Fields_For_Logic_Assign;

      
   function Logic_Assign_F_Dest_Var
     (Node : Bare_Logic_Assign) return Bare_Expr
   is
      

   begin
         
         return Node.Logic_Assign_F_Dest_Var;
      
   end;

      
   function Logic_Assign_F_Value
     (Node : Bare_Logic_Assign) return Bare_Expr
   is
      

   begin
         
         return Node.Logic_Assign_F_Value;
      
   end;


   







--# property-start LogicAssign.xref_equation nodes.lkt:4857
pragma Warnings (Off, "is not referenced");

function Logic_Assign_P_Xref_Equation
  
  (Node : Bare_Logic_Assign
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Logic_Assign :=
     Bare_Logic_Assign (Node);
     Ent : Internal_Entity_Logic_Assign :=
       Internal_Entity_Logic_Assign'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_374 with Inline_Always;
            procedure Finalizer_Scope_821 with Inline_Always;
            procedure Finalizer_Scope_822 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Internal_Entity_Expr;
Fld_3 : Logic_Var;
Fld_4 : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
And_Pred : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_5 : Bare_Expr;
Fld_6 : Internal_Entity_Expr;
Fld_7 : Logic_Var;
Fld_8 : Internal_Entity_Expr;
Fld_9 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;
Fld_10 : Internal_Entity_Expr;
Fld_11 : Logic_Equation;
And_Pred_2 : Logic_Equation;
Fld_12 : Internal_Entity_Expr;
Fld_13 : Logic_Var;
Fld_14 : Internal_Entity_Named_Type_Decl;
Fld_15 : Lexical_Env := Empty_Env;
Sym : Symbol_Type;
Env_Get_Result : Internal_Entity;
Cast_Result_2 : Internal_Entity_Type_Decl;
Array_Lit : Internal_Entity_Type_Decl_Array_Access;
Fld_16 : Internal_Entity_Decl;
Cast_Result_3 : Internal_Entity;
Bind_Result_1 : Logic_Equation;
And_Pred_3 : Logic_Equation;
Error_Location_1 : Bare_Lkt_Node;
Fld_17 : Bare_Expr;
Fld_18 : Internal_Entity_Expr;
Fld_19 : Logic_Var;
Fld_20 : Internal_Entity_Expr;
Fld_21 : Logic_Var;
Pred_1 : Logic_Equation;
Cast_Result_4 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_1 : Logic_Equation;
Scope_Result_1 : Logic_Equation;
And_Pred_4 : Logic_Equation;
Fld_22 : Logic_Var;
Fld_23 : Internal_Entity_Named_Type_Decl;
Cast_Result_5 : Internal_Entity;
Bind_Result_2 : Logic_Equation;
And_Pred_5 : Logic_Equation;

            procedure Finalizer_Scope_374 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Fld_11);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Fld_15);
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (And_Pred_3);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (And_Pred_4);
                     Dec_Ref (Bind_Result_2);
                     Dec_Ref (And_Pred_5);
            end Finalizer_Scope_374;
            procedure Finalizer_Scope_821 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_821;
            procedure Finalizer_Scope_822 is
            begin
                     Dec_Ref (Pred_1);
                     Dec_Ref (Dyn_Var_Bind_Result_1);
            end Finalizer_Scope_822;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3063 LogicAnd And_Pred_5 nodes.lkt:4858
--# expr-start 3059 LogicAnd And_Pred_4 nodes.lkt:4859
--# expr-start 3051 LogicAnd And_Pred_3 nodes.lkt:4860
--# expr-start 3040 LogicAnd And_Pred_2 nodes.lkt:4861
--# expr-start 3037 LogicAnd And_Pred_1 nodes.lkt:4862
--# expr-start 3029 LogicAnd And_Pred nodes.lkt:4863
--# expr-start 3024 LktNode.xref_equation Fld_1 nodes.lkt:4863



--# expr-start 3023 LogicAssign.dest_var Fld nodes.lkt:4863







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Assign_F_Dest_Var, Info => Ent.Info);
--# expr-done 3023



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 3024
--# expr-start 3028 LogicAssign Bind_Result nodes.lkt:4864
--# expr-start 3026 Expr.expected_type_var Fld_3 nodes.lkt:4864



--# expr-start 3025 LogicAssign.dest_var Fld_2 nodes.lkt:4864







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Assign_F_Dest_Var, Info => Ent.Info);
--# expr-done 3025



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Fld_2.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3026
Fld_3.Value := No_Entity;
Entity_Vars.Reset (Fld_3);





--# expr-start 3027 LktNode.logicvar_type Fld_4 nodes.lkt:4865







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.logicvar_type
Fld_4 := Liblktlang.Implementation.Lkt_Node_P_Logicvar_Type (Node => Ent.Node);
--# end
--# expr-done 3027



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_4.Node,
         Info => Fld_4.Info);


Bind_Result := Solver.Create_Assign (Fld_3, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4864:34") else null)); 
--# expr-done 3028
And_Pred := Create_And (Fld_1, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4863:29") else null)); 
--# expr-done 3029




   --# scope-start



--# expr-start 3036 bind Dyn_Var_Bind_Result nodes.lkt:4868





--# expr-start 3030 LogicAssign.dest_var Fld_5 nodes.lkt:4868







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Self.Logic_Assign_F_Dest_Var;
--# expr-done 3030



   
      Cast_Result_1 := Fld_5;


Error_Location := Cast_Result_1; 
--# expr-start 3035 LogicPropagate Pred nodes.lkt:4869
--# expr-start 3032 Expr.expected_type_var Fld_7 nodes.lkt:4870



--# expr-start 3031 LogicAssign.dest_var Fld_6 nodes.lkt:4870







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Assign_F_Dest_Var, Info => Ent.Info);
--# expr-done 3031



   if Fld_6.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Fld_6.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3032
Fld_7.Value := No_Entity;
Entity_Vars.Reset (Fld_7);
--# expr-start 3034 Expr.actual_type_var Fld_9 nodes.lkt:4871



--# expr-start 3033 LogicAssign.dest_var Fld_8 nodes.lkt:4871







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Assign_F_Dest_Var, Info => Ent.Info);
--# expr-done 3033



   if Fld_8.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Fld_8.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3034
Fld_9.Value := No_Entity;
Entity_Vars.Reset (Fld_9);


Pred := Solver.Create_N_Predicate ((Fld_7, Fld_9), Create_Type_Decl_P_Matching_Type_0_Predicate (2, Error_Location)); 
--# expr-done 3035
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 3036
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_821;


And_Pred_1 := Create_And (And_Pred, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4862:25") else null)); 
--# expr-done 3037
--# expr-start 3039 LktNode.xref_equation Fld_11 nodes.lkt:4875



--# expr-start 3038 LogicAssign.value Fld_10 nodes.lkt:4875







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Assign_F_Value, Info => Ent.Info);
--# expr-done 3038



   if Fld_10.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_11 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld_10.Node, E_Info => Fld_10.Info);
--# end
--# expr-done 3039
And_Pred_2 := Create_And (And_Pred_1, Fld_11, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4861:21") else null)); 
--# expr-done 3040
--# expr-start 3050 LogicAssign Bind_Result_1 nodes.lkt:4877
--# expr-start 3042 Expr.expected_type_var Fld_13 nodes.lkt:4877



--# expr-start 3041 LogicAssign.value Fld_12 nodes.lkt:4877







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_12 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Assign_F_Value, Info => Ent.Info);
--# expr-done 3041



   if Fld_12.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_13 := Fld_12.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3042
Fld_13.Value := No_Entity;
Entity_Vars.Reset (Fld_13);





--# expr-start 3049 Decl.instantiate_generic_decl Fld_16 nodes.lkt:4878



--# expr-start 3043 LktNode.entity_type Fld_14 nodes.lkt:4878







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.entity_type
Fld_14 := Liblktlang.Implementation.Lkt_Node_P_Entity_Type (Node => Ent.Node);
--# end
--# expr-done 3043



   if Fld_14.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 3048 ArrayLiteral Array_Lit nodes.lkt:4879
--# expr-start 3047 Cast Cast_Result_2 nodes.lkt:4879





--# expr-start 3046 .get_first Env_Get_Result nodes.lkt:4879
--# expr-start 3044 LktNode.node_env Fld_15 nodes.lkt:4879







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_15 := Liblktlang.Implementation.Node_Env (Node => Ent.Node, E_Info => Ent.Info);
--# expr-done 3044
--# expr-start 3045 SymbolLiteral Sym nodes.lkt:4879
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Rootnode); 
--# expr-done 3045


Env_Get_Result := AST_Envs.Get_First (Self => Fld_15, Key => Thin (Sym), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 3046



   if Env_Get_Result.Node = null
      or else Env_Get_Result.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result_2 := Create_Internal_Entity_Type_Decl
        (Node => Env_Get_Result.Node,
         Info => Env_Get_Result.Info);

   else
         Cast_Result_2 := No_Entity_Type_Decl;
   end if;


--# expr-done 3047
Array_Lit := Create_Internal_Entity_Type_Decl_Array (Internal_Internal_Entity_Type_Decl_Array'(1 => Cast_Result_2)); 
--# expr-done 3048
--# property-call-start Decl.instantiate_generic_decl
Fld_16 := Liblktlang.Implementation.Decl_P_Instantiate_Generic_Decl (Node => Fld_14.Node, Param_Types => Array_Lit, E_Info => Fld_14.Info);
--# end
--# expr-done 3049



   
      Cast_Result_3 := Create_Internal_Entity
        (Node => Fld_16.Node,
         Info => Fld_16.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_13, Cast_Result_3, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4877:22") else null)); 
--# expr-done 3050
And_Pred_3 := Create_And (And_Pred_2, Bind_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4860:17") else null)); 
--# expr-done 3051




   --# scope-start



--# expr-start 3058 bind Dyn_Var_Bind_Result_1 nodes.lkt:4883





--# expr-start 3052 LogicAssign.value Fld_17 nodes.lkt:4883







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_17 := Self.Logic_Assign_F_Value;
--# expr-done 3052



   
      Cast_Result_4 := Fld_17;


Error_Location_1 := Cast_Result_4; 
--# expr-start 3057 LogicPropagate Pred_1 nodes.lkt:4884
--# expr-start 3054 Expr.expected_type_var Fld_19 nodes.lkt:4885



--# expr-start 3053 LogicAssign.value Fld_18 nodes.lkt:4885







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_18 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Assign_F_Value, Info => Ent.Info);
--# expr-done 3053



   if Fld_18.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_19 := Fld_18.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3054
Fld_19.Value := No_Entity;
Entity_Vars.Reset (Fld_19);
--# expr-start 3056 Expr.actual_type_var Fld_21 nodes.lkt:4886



--# expr-start 3055 LogicAssign.value Fld_20 nodes.lkt:4886







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_20 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Assign_F_Value, Info => Ent.Info);
--# expr-done 3055



   if Fld_20.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_21 := Fld_20.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3056
Fld_21.Value := No_Entity;
Entity_Vars.Reset (Fld_21);


Pred_1 := Solver.Create_N_Predicate ((Fld_19, Fld_21), Create_Type_Decl_P_Matching_Type_0_Predicate (2, Error_Location_1)); 
--# expr-done 3057
Dyn_Var_Bind_Result_1 := Pred_1; Inc_Ref (Dyn_Var_Bind_Result_1);
--# expr-done 3058
Scope_Result_1 := Dyn_Var_Bind_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_822;


And_Pred_4 := Create_And (And_Pred_3, Scope_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4859:13") else null)); 
--# expr-done 3059
--# expr-start 3062 LogicAssign Bind_Result_2 nodes.lkt:4890
--# expr-start 3060 Expr.actual_type_var Fld_22 nodes.lkt:4890







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_22 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3060
Fld_22.Value := No_Entity;
Entity_Vars.Reset (Fld_22);





--# expr-start 3061 LktNode.equation_type Fld_23 nodes.lkt:4890







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.equation_type
Fld_23 := Liblktlang.Implementation.Lkt_Node_P_Equation_Type (Node => Ent.Node);
--# end
--# expr-done 3061



   
      Cast_Result_5 := Create_Internal_Entity
        (Node => Fld_23.Node,
         Info => Fld_23.Info);


Bind_Result_2 := Solver.Create_Assign (Fld_22, Cast_Result_5, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4890:14") else null)); 
--# expr-done 3062
And_Pred_5 := Create_And (And_Pred_4, Bind_Result_2, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4858:9") else null)); 
--# expr-done 3063

         Property_Result := And_Pred_5;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_374;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_374;
                     Finalizer_Scope_821;
                     Finalizer_Scope_822;




            raise;
      end;



   return Property_Result;
end Logic_Assign_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Logic_Expr
   --

   



      
      procedure Initialize_Fields_For_Logic_Expr
        (Self : Bare_Logic_Expr
         ; Logic_Expr_F_Expr : Bare_Expr
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Logic_Expr_F_Expr := Logic_Expr_F_Expr;
         

      end Initialize_Fields_For_Logic_Expr;

      
   function Logic_Expr_F_Expr
     (Node : Bare_Logic_Expr) return Bare_Expr
   is
      

   begin
         
         return Node.Logic_Expr_F_Expr;
      
   end;


   







--# property-start LogicExpr.xref_equation nodes.lkt:4898
pragma Warnings (Off, "is not referenced");

function Logic_Expr_P_Xref_Equation
  
  (Node : Bare_Logic_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Logic_Expr :=
     Bare_Logic_Expr (Node);
     Ent : Internal_Entity_Logic_Expr :=
       Internal_Entity_Logic_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_375 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Internal_Entity_Expr;
Fld_3 : Logic_Var;
Fld_4 : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
And_Pred : Logic_Equation;
Fld_5 : Logic_Var;
Fld_6 : Internal_Entity_Named_Type_Decl;
Cast_Result_1 : Internal_Entity;
Bind_Result_1 : Logic_Equation;
And_Pred_1 : Logic_Equation;

            procedure Finalizer_Scope_375 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (And_Pred_1);
            end Finalizer_Scope_375;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3074 LogicAnd And_Pred_1 nodes.lkt:4899
--# expr-start 3070 LogicAnd And_Pred nodes.lkt:4900
--# expr-start 3065 Expr.xlogic_equation Fld_1 nodes.lkt:4900



--# expr-start 3064 LogicExpr.expr Fld nodes.lkt:4900







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Expr_F_Expr, Info => Ent.Info);
--# expr-done 3064



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.xlogic_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Xlogic_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 3065
--# expr-start 3069 LogicAssign Bind_Result nodes.lkt:4901
--# expr-start 3067 Expr.expected_type_var Fld_3 nodes.lkt:4901



--# expr-start 3066 LogicExpr.expr Fld_2 nodes.lkt:4901







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Expr_F_Expr, Info => Ent.Info);
--# expr-done 3066



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Fld_2.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3067
Fld_3.Value := No_Entity;
Entity_Vars.Reset (Fld_3);





--# expr-start 3068 LktNode.bool_type Fld_4 nodes.lkt:4901







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.bool_type
Fld_4 := Liblktlang.Implementation.Lkt_Node_P_Bool_Type (Node => Ent.Node);
--# end
--# expr-done 3068



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_4.Node,
         Info => Fld_4.Info);


Bind_Result := Solver.Create_Assign (Fld_3, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4901:18") else null)); 
--# expr-done 3069
And_Pred := Create_And (Fld_1, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4900:13") else null)); 
--# expr-done 3070
--# expr-start 3073 LogicAssign Bind_Result_1 nodes.lkt:4903
--# expr-start 3071 Expr.actual_type_var Fld_5 nodes.lkt:4903







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3071
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);





--# expr-start 3072 LktNode.equation_type Fld_6 nodes.lkt:4903







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.equation_type
Fld_6 := Liblktlang.Implementation.Lkt_Node_P_Equation_Type (Node => Ent.Node);
--# end
--# expr-done 3072



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Fld_6.Node,
         Info => Fld_6.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_5, Cast_Result_1, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4903:14") else null)); 
--# expr-done 3073
And_Pred_1 := Create_And (And_Pred, Bind_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4899:9") else null)); 
--# expr-done 3074

         Property_Result := And_Pred_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_375;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_375;




            raise;
      end;



   return Property_Result;
end Logic_Expr_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Logic_Propagate
   --

   



      
      procedure Initialize_Fields_For_Logic_Propagate
        (Self : Bare_Logic_Propagate
         ; Logic_Propagate_F_Dest_Var : Bare_Expr
         ; Logic_Propagate_F_Call : Bare_Logic_Propagate_Call
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Logic_Propagate_F_Dest_Var := Logic_Propagate_F_Dest_Var;
            Self.Logic_Propagate_F_Call := Logic_Propagate_F_Call;
         

      end Initialize_Fields_For_Logic_Propagate;

      
   function Logic_Propagate_F_Dest_Var
     (Node : Bare_Logic_Propagate) return Bare_Expr
   is
      

   begin
         
         return Node.Logic_Propagate_F_Dest_Var;
      
   end;

      
   function Logic_Propagate_F_Call
     (Node : Bare_Logic_Propagate) return Bare_Logic_Propagate_Call
   is
      

   begin
         
         return Node.Logic_Propagate_F_Call;
      
   end;


   







--# property-start LogicPropagate.generic_type_equation nodes.lkt:4913
pragma Warnings (Off, "is not referenced");

function Logic_Propagate_P_Generic_Type_Equation
  
  (Node : Bare_Logic_Propagate
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Logic_Propagate :=
     Bare_Logic_Propagate (Node);
     Ent : Internal_Entity_Logic_Propagate :=
       Internal_Entity_Logic_Propagate'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_376 with Inline_Always;
            procedure Finalizer_Scope_823 with Inline_Always;

      In_Logic_Call : Boolean;
Fld : Internal_Entity_Logic_Propagate_Call;
Fld_1 : Logic_Equation;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;

            procedure Finalizer_Scope_376 is
            begin
                     Dec_Ref (Scope_Result);
            end Finalizer_Scope_376;
            procedure Finalizer_Scope_823 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_823;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 3077 bind Dyn_Var_Bind_Result nodes.lkt:4914

In_Logic_Call := True; 
--# expr-start 3076 BaseCallExpr.generic_type_equation_helper Fld_1 nodes.lkt:4915



--# expr-start 3075 LogicPropagate.call Fld nodes.lkt:4915







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Logic_Propagate_Call (Node => Ent.Node.Logic_Propagate_F_Call, Info => Ent.Info);
--# expr-done 3075



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start BaseCallExpr.generic_type_equation_helper
Fld_1 := Liblktlang.Implementation.Base_Call_Expr_P_Generic_Type_Equation_Helper (Node => Fld.Node, In_Logic_Call => In_Logic_Call, E_Info => Fld.Info);
--# end
--# expr-done 3076
Dyn_Var_Bind_Result := Fld_1; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 3077
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_823;



         Property_Result := Scope_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_376;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_376;
                     Finalizer_Scope_823;




            raise;
      end;



   return Property_Result;
end Logic_Propagate_P_Generic_Type_Equation;
--# end

   







--# property-start LogicPropagate.xref_equation nodes.lkt:4918
pragma Warnings (Off, "is not referenced");

function Logic_Propagate_P_Xref_Equation
  
  (Node : Bare_Logic_Propagate
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Logic_Propagate :=
     Bare_Logic_Propagate (Node);
     Ent : Internal_Entity_Logic_Propagate :=
       Internal_Entity_Logic_Propagate'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_377 with Inline_Always;
            procedure Finalizer_Scope_824 with Inline_Always;
            procedure Finalizer_Scope_825 with Inline_Always;

      Error_Location : Bare_Lkt_Node;
Fld : Bare_Expr;
Fld_1 : Internal_Entity_Expr;
Fld_2 : Logic_Equation;
Fld_3 : Internal_Entity_Expr;
Fld_4 : Logic_Var;
Fld_5 : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
And_Pred : Logic_Equation;
Fld_6 : Internal_Entity_Expr;
Fld_7 : Logic_Var;
Fld_8 : Internal_Entity_Expr;
Fld_9 : Logic_Var;
Pred : Logic_Equation;
And_Pred_1 : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
In_Logic_Call : Boolean;
Error_Location_1 : Bare_Lkt_Node;
Fld_10 : Bare_Logic_Propagate_Call;
Fld_11 : Bare_Expr;
Fld_12 : Internal_Entity_Logic_Propagate_Call;
Fld_13 : Logic_Equation;
Fld_14 : Internal_Entity_Logic_Propagate_Call;
Fld_15 : Internal_Entity_Expr;
Fld_16 : Logic_Equation;
And_Pred_2 : Logic_Equation;
Fld_17 : Internal_Entity_Logic_Propagate_Call;
Fld_18 : Internal_Entity_Expr;
Fld_19 : Logic_Var;
Pred_1 : Logic_Equation;
And_Pred_3 : Logic_Equation;
Fld_20 : Logic_Var;
Fld_21 : Internal_Entity_Named_Type_Decl;
Cast_Result_2 : Internal_Entity;
Bind_Result_1 : Logic_Equation;
And_Pred_4 : Logic_Equation;
Cast_Result_3 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_1 : Logic_Equation;
Dyn_Var_Bind_Result_2 : Logic_Equation;
Scope_Result_1 : Logic_Equation;
And_Pred_5 : Logic_Equation;

            procedure Finalizer_Scope_377 is
            begin
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (And_Pred_5);
            end Finalizer_Scope_377;
            procedure Finalizer_Scope_824 is
            begin
                     Dec_Ref (Fld_2);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Pred);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_824;
            procedure Finalizer_Scope_825 is
            begin
                     Dec_Ref (Fld_13);
                     Dec_Ref (Fld_16);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Pred_1);
                     Dec_Ref (And_Pred_3);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (And_Pred_4);
                     Dec_Ref (Dyn_Var_Bind_Result_1);
                     Dec_Ref (Dyn_Var_Bind_Result_2);
            end Finalizer_Scope_825;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3112 LogicAnd And_Pred_5 nodes.lkt:4919




   --# scope-start



--# expr-start 3092 bind Dyn_Var_Bind_Result nodes.lkt:4921





--# expr-start 3078 LogicPropagate.dest_var Fld nodes.lkt:4921







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Self.Logic_Propagate_F_Dest_Var;
--# expr-done 3078



   
      Cast_Result_1 := Fld;


Error_Location := Cast_Result_1; 
--# expr-start 3091 LogicAnd And_Pred_1 nodes.lkt:4922
--# expr-start 3085 LogicAnd And_Pred nodes.lkt:4922
--# expr-start 3080 LktNode.xref_equation Fld_2 nodes.lkt:4922



--# expr-start 3079 LogicPropagate.dest_var Fld_1 nodes.lkt:4922







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Propagate_F_Dest_Var, Info => Ent.Info);
--# expr-done 3079



   if Fld_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_2 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld_1.Node, E_Info => Fld_1.Info);
--# end
--# expr-done 3080
--# expr-start 3084 LogicAssign Bind_Result nodes.lkt:4923
--# expr-start 3082 Expr.expected_type_var Fld_4 nodes.lkt:4923



--# expr-start 3081 LogicPropagate.dest_var Fld_3 nodes.lkt:4923







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Propagate_F_Dest_Var, Info => Ent.Info);
--# expr-done 3081



   if Fld_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Fld_3.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3082
Fld_4.Value := No_Entity;
Entity_Vars.Reset (Fld_4);





--# expr-start 3083 LktNode.logicvar_type Fld_5 nodes.lkt:4923







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.logicvar_type
Fld_5 := Liblktlang.Implementation.Lkt_Node_P_Logicvar_Type (Node => Ent.Node);
--# end
--# expr-done 3083



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_5.Node,
         Info => Fld_5.Info);


Bind_Result := Solver.Create_Assign (Fld_4, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4923:18") else null)); 
--# expr-done 3084
And_Pred := Create_And (Fld_2, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4922:13") else null)); 
--# expr-done 3085
--# expr-start 3090 LogicPropagate Pred nodes.lkt:4924
--# expr-start 3087 Expr.expected_type_var Fld_7 nodes.lkt:4925



--# expr-start 3086 LogicPropagate.dest_var Fld_6 nodes.lkt:4925







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Propagate_F_Dest_Var, Info => Ent.Info);
--# expr-done 3086



   if Fld_6.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Fld_6.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3087
Fld_7.Value := No_Entity;
Entity_Vars.Reset (Fld_7);
--# expr-start 3089 Expr.actual_type_var Fld_9 nodes.lkt:4926



--# expr-start 3088 LogicPropagate.dest_var Fld_8 nodes.lkt:4926







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Propagate_F_Dest_Var, Info => Ent.Info);
--# expr-done 3088



   if Fld_8.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Fld_8.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3089
Fld_9.Value := No_Entity;
Entity_Vars.Reset (Fld_9);


Pred := Solver.Create_N_Predicate ((Fld_7, Fld_9), Create_Type_Decl_P_Matching_Type_0_Predicate (2, Error_Location)); 
--# expr-done 3090
And_Pred_1 := Create_And (And_Pred, Pred, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4922:13") else null)); 
--# expr-done 3091
Dyn_Var_Bind_Result := And_Pred_1; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 3092
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_824;






   --# scope-start



--# expr-start 3111 bind Dyn_Var_Bind_Result_2 nodes.lkt:4930

In_Logic_Call := True; 
--# expr-start 3110 bind Dyn_Var_Bind_Result_1 nodes.lkt:4931





--# expr-start 3094 BaseCallExpr.name Fld_11 nodes.lkt:4931



--# expr-start 3093 LogicPropagate.call Fld_10 nodes.lkt:4931







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Self.Logic_Propagate_F_Call;
--# expr-done 3093



   if Fld_10 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Fld_10.Base_Call_Expr_F_Name;
--# expr-done 3094



   
      Cast_Result_3 := Fld_11;


Error_Location_1 := Cast_Result_3; 
--# expr-start 3109 LogicAnd And_Pred_4 nodes.lkt:4933
--# expr-start 3105 LogicAnd And_Pred_3 nodes.lkt:4933
--# expr-start 3100 LogicAnd And_Pred_2 nodes.lkt:4933
--# expr-start 3096 BaseCallExpr.xref_call_equation Fld_13 nodes.lkt:4933



--# expr-start 3095 LogicPropagate.call Fld_12 nodes.lkt:4933







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_12 := Create_Internal_Entity_Logic_Propagate_Call (Node => Ent.Node.Logic_Propagate_F_Call, Info => Ent.Info);
--# expr-done 3095



   if Fld_12.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start BaseCallExpr.xref_call_equation
Fld_13 := Liblktlang.Implementation.Base_Call_Expr_P_Xref_Call_Equation (Node => Fld_12.Node, In_Logic_Call => In_Logic_Call, E_Info => Fld_12.Info);
--# end
--# expr-done 3096
--# expr-start 3099 Expr.xlogic_equation Fld_16 nodes.lkt:4934



--# expr-start 3098 BaseCallExpr.name Fld_15 nodes.lkt:4934



--# expr-start 3097 LogicPropagate.call Fld_14 nodes.lkt:4934







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_14 := Create_Internal_Entity_Logic_Propagate_Call (Node => Ent.Node.Logic_Propagate_F_Call, Info => Ent.Info);
--# expr-done 3097



   if Fld_14.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_15 := Create_Internal_Entity_Expr (Node => Fld_14.Node.Base_Call_Expr_F_Name, Info => Fld_14.Info);
--# expr-done 3098



   if Fld_15.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.xlogic_equation'
Fld_16 := Liblktlang.Implementation.Dispatcher_Expr_P_Xlogic_Equation (Node => Fld_15.Node, E_Info => Fld_15.Info);
--# end
--# expr-done 3099
And_Pred_2 := Create_And (Fld_13, Fld_16, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4933:13") else null)); 
--# expr-done 3100
--# expr-start 3104 LogicPropagate Pred_1 nodes.lkt:4936
--# expr-start 3103 Expr.actual_type_var Fld_19 nodes.lkt:4936



--# expr-start 3102 BaseCallExpr.name Fld_18 nodes.lkt:4936



--# expr-start 3101 LogicPropagate.call Fld_17 nodes.lkt:4936







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_17 := Create_Internal_Entity_Logic_Propagate_Call (Node => Ent.Node.Logic_Propagate_F_Call, Info => Ent.Info);
--# expr-done 3101



   if Fld_17.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_18 := Create_Internal_Entity_Expr (Node => Fld_17.Node.Base_Call_Expr_F_Name, Info => Fld_17.Info);
--# expr-done 3102



   if Fld_18.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_19 := Fld_18.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3103
Fld_19.Value := No_Entity;
Entity_Vars.Reset (Fld_19);

Pred_1 := Solver.Create_Predicate (Fld_19, Create_Function_Type_P_Returns_Entity_0_Predicate (Error_Location_1)); 
--# expr-done 3104
And_Pred_3 := Create_And (And_Pred_2, Pred_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4933:13") else null)); 
--# expr-done 3105
--# expr-start 3108 LogicAssign Bind_Result_1 nodes.lkt:4937
--# expr-start 3106 Expr.actual_type_var Fld_20 nodes.lkt:4937







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_20 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3106
Fld_20.Value := No_Entity;
Entity_Vars.Reset (Fld_20);





--# expr-start 3107 LktNode.equation_type Fld_21 nodes.lkt:4937







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.equation_type
Fld_21 := Liblktlang.Implementation.Lkt_Node_P_Equation_Type (Node => Ent.Node);
--# end
--# expr-done 3107



   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Fld_21.Node,
         Info => Fld_21.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_20, Cast_Result_2, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4937:18") else null)); 
--# expr-done 3108
And_Pred_4 := Create_And (And_Pred_3, Bind_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4933:13") else null)); 
--# expr-done 3109
Dyn_Var_Bind_Result_1 := And_Pred_4; Inc_Ref (Dyn_Var_Bind_Result_1);
--# expr-done 3110
Dyn_Var_Bind_Result_2 := Dyn_Var_Bind_Result_1; Inc_Ref (Dyn_Var_Bind_Result_2);
--# expr-done 3111
Scope_Result_1 := Dyn_Var_Bind_Result_2;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_825;


And_Pred_5 := Create_And (Scope_Result, Scope_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4919:9") else null)); 
--# expr-done 3112

         Property_Result := And_Pred_5;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_377;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_377;
                     Finalizer_Scope_824;
                     Finalizer_Scope_825;




            raise;
      end;



   return Property_Result;
end Logic_Propagate_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Logic_Unify
   --

   



      
      procedure Initialize_Fields_For_Logic_Unify
        (Self : Bare_Logic_Unify
         ; Logic_Unify_F_Lhs : Bare_Expr
         ; Logic_Unify_F_Rhs : Bare_Expr
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Logic_Unify_F_Lhs := Logic_Unify_F_Lhs;
            Self.Logic_Unify_F_Rhs := Logic_Unify_F_Rhs;
         

      end Initialize_Fields_For_Logic_Unify;

      
   function Logic_Unify_F_Lhs
     (Node : Bare_Logic_Unify) return Bare_Expr
   is
      

   begin
         
         return Node.Logic_Unify_F_Lhs;
      
   end;

      
   function Logic_Unify_F_Rhs
     (Node : Bare_Logic_Unify) return Bare_Expr
   is
      

   begin
         
         return Node.Logic_Unify_F_Rhs;
      
   end;


   







--# property-start LogicUnify.xref_equation nodes.lkt:4948
pragma Warnings (Off, "is not referenced");

function Logic_Unify_P_Xref_Equation
  
  (Node : Bare_Logic_Unify
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Logic_Unify :=
     Bare_Logic_Unify (Node);
     Ent : Internal_Entity_Logic_Unify :=
       Internal_Entity_Logic_Unify'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_378 with Inline_Always;
            procedure Finalizer_Scope_826 with Inline_Always;
            procedure Finalizer_Scope_827 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Internal_Entity_Expr;
Fld_3 : Logic_Var;
Fld_4 : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
And_Pred : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_5 : Bare_Expr;
Fld_6 : Internal_Entity_Expr;
Fld_7 : Logic_Var;
Fld_8 : Internal_Entity_Expr;
Fld_9 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;
Fld_10 : Internal_Entity_Expr;
Fld_11 : Logic_Equation;
And_Pred_2 : Logic_Equation;
Fld_12 : Internal_Entity_Expr;
Fld_13 : Logic_Var;
Fld_14 : Internal_Entity_Named_Type_Decl;
Cast_Result_2 : Internal_Entity;
Bind_Result_1 : Logic_Equation;
And_Pred_3 : Logic_Equation;
Error_Location_1 : Bare_Lkt_Node;
Fld_15 : Bare_Expr;
Fld_16 : Internal_Entity_Expr;
Fld_17 : Logic_Var;
Fld_18 : Internal_Entity_Expr;
Fld_19 : Logic_Var;
Pred_1 : Logic_Equation;
Cast_Result_3 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_1 : Logic_Equation;
Scope_Result_1 : Logic_Equation;
And_Pred_4 : Logic_Equation;
Fld_20 : Logic_Var;
Fld_21 : Internal_Entity_Named_Type_Decl;
Cast_Result_4 : Internal_Entity;
Bind_Result_2 : Logic_Equation;
And_Pred_5 : Logic_Equation;

            procedure Finalizer_Scope_378 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Fld_11);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (And_Pred_3);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (And_Pred_4);
                     Dec_Ref (Bind_Result_2);
                     Dec_Ref (And_Pred_5);
            end Finalizer_Scope_378;
            procedure Finalizer_Scope_826 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_826;
            procedure Finalizer_Scope_827 is
            begin
                     Dec_Ref (Pred_1);
                     Dec_Ref (Dyn_Var_Bind_Result_1);
            end Finalizer_Scope_827;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3147 LogicAnd And_Pred_5 nodes.lkt:4949
--# expr-start 3143 LogicAnd And_Pred_4 nodes.lkt:4950
--# expr-start 3135 LogicAnd And_Pred_3 nodes.lkt:4951
--# expr-start 3130 LogicAnd And_Pred_2 nodes.lkt:4952
--# expr-start 3127 LogicAnd And_Pred_1 nodes.lkt:4953
--# expr-start 3119 LogicAnd And_Pred nodes.lkt:4954
--# expr-start 3114 LktNode.xref_equation Fld_1 nodes.lkt:4954



--# expr-start 3113 LogicUnify.lhs Fld nodes.lkt:4954







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Unify_F_Lhs, Info => Ent.Info);
--# expr-done 3113



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 3114
--# expr-start 3118 LogicAssign Bind_Result nodes.lkt:4955
--# expr-start 3116 Expr.expected_type_var Fld_3 nodes.lkt:4955



--# expr-start 3115 LogicUnify.lhs Fld_2 nodes.lkt:4955







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Unify_F_Lhs, Info => Ent.Info);
--# expr-done 3115



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Fld_2.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3116
Fld_3.Value := No_Entity;
Entity_Vars.Reset (Fld_3);





--# expr-start 3117 LktNode.logicvar_type Fld_4 nodes.lkt:4956







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.logicvar_type
Fld_4 := Liblktlang.Implementation.Lkt_Node_P_Logicvar_Type (Node => Ent.Node);
--# end
--# expr-done 3117



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_4.Node,
         Info => Fld_4.Info);


Bind_Result := Solver.Create_Assign (Fld_3, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4955:34") else null)); 
--# expr-done 3118
And_Pred := Create_And (Fld_1, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4954:29") else null)); 
--# expr-done 3119




   --# scope-start



--# expr-start 3126 bind Dyn_Var_Bind_Result nodes.lkt:4959





--# expr-start 3120 LogicUnify.lhs Fld_5 nodes.lkt:4959







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Self.Logic_Unify_F_Lhs;
--# expr-done 3120



   
      Cast_Result_1 := Fld_5;


Error_Location := Cast_Result_1; 
--# expr-start 3125 LogicPropagate Pred nodes.lkt:4960
--# expr-start 3122 Expr.expected_type_var Fld_7 nodes.lkt:4961



--# expr-start 3121 LogicUnify.lhs Fld_6 nodes.lkt:4961







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Unify_F_Lhs, Info => Ent.Info);
--# expr-done 3121



   if Fld_6.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Fld_6.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3122
Fld_7.Value := No_Entity;
Entity_Vars.Reset (Fld_7);
--# expr-start 3124 Expr.actual_type_var Fld_9 nodes.lkt:4962



--# expr-start 3123 LogicUnify.lhs Fld_8 nodes.lkt:4962







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Unify_F_Lhs, Info => Ent.Info);
--# expr-done 3123



   if Fld_8.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Fld_8.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3124
Fld_9.Value := No_Entity;
Entity_Vars.Reset (Fld_9);


Pred := Solver.Create_N_Predicate ((Fld_7, Fld_9), Create_Type_Decl_P_Matching_Type_0_Predicate (2, Error_Location)); 
--# expr-done 3125
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 3126
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_826;


And_Pred_1 := Create_And (And_Pred, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4953:25") else null)); 
--# expr-done 3127
--# expr-start 3129 LktNode.xref_equation Fld_11 nodes.lkt:4966



--# expr-start 3128 LogicUnify.rhs Fld_10 nodes.lkt:4966







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Unify_F_Rhs, Info => Ent.Info);
--# expr-done 3128



   if Fld_10.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_11 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld_10.Node, E_Info => Fld_10.Info);
--# end
--# expr-done 3129
And_Pred_2 := Create_And (And_Pred_1, Fld_11, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4952:21") else null)); 
--# expr-done 3130
--# expr-start 3134 LogicAssign Bind_Result_1 nodes.lkt:4968
--# expr-start 3132 Expr.expected_type_var Fld_13 nodes.lkt:4968



--# expr-start 3131 LogicUnify.rhs Fld_12 nodes.lkt:4968







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_12 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Unify_F_Rhs, Info => Ent.Info);
--# expr-done 3131



   if Fld_12.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_13 := Fld_12.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3132
Fld_13.Value := No_Entity;
Entity_Vars.Reset (Fld_13);





--# expr-start 3133 LktNode.logicvar_type Fld_14 nodes.lkt:4968







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.logicvar_type
Fld_14 := Liblktlang.Implementation.Lkt_Node_P_Logicvar_Type (Node => Ent.Node);
--# end
--# expr-done 3133



   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Fld_14.Node,
         Info => Fld_14.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_13, Cast_Result_2, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4968:22") else null)); 
--# expr-done 3134
And_Pred_3 := Create_And (And_Pred_2, Bind_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4951:17") else null)); 
--# expr-done 3135




   --# scope-start



--# expr-start 3142 bind Dyn_Var_Bind_Result_1 nodes.lkt:4971





--# expr-start 3136 LogicUnify.rhs Fld_15 nodes.lkt:4971







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_15 := Self.Logic_Unify_F_Rhs;
--# expr-done 3136



   
      Cast_Result_3 := Fld_15;


Error_Location_1 := Cast_Result_3; 
--# expr-start 3141 LogicPropagate Pred_1 nodes.lkt:4972
--# expr-start 3138 Expr.expected_type_var Fld_17 nodes.lkt:4973



--# expr-start 3137 LogicUnify.rhs Fld_16 nodes.lkt:4973







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_16 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Unify_F_Rhs, Info => Ent.Info);
--# expr-done 3137



   if Fld_16.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_17 := Fld_16.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3138
Fld_17.Value := No_Entity;
Entity_Vars.Reset (Fld_17);
--# expr-start 3140 Expr.actual_type_var Fld_19 nodes.lkt:4974



--# expr-start 3139 LogicUnify.rhs Fld_18 nodes.lkt:4974







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_18 := Create_Internal_Entity_Expr (Node => Ent.Node.Logic_Unify_F_Rhs, Info => Ent.Info);
--# expr-done 3139



   if Fld_18.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_19 := Fld_18.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3140
Fld_19.Value := No_Entity;
Entity_Vars.Reset (Fld_19);


Pred_1 := Solver.Create_N_Predicate ((Fld_17, Fld_19), Create_Type_Decl_P_Matching_Type_0_Predicate (2, Error_Location_1)); 
--# expr-done 3141
Dyn_Var_Bind_Result_1 := Pred_1; Inc_Ref (Dyn_Var_Bind_Result_1);
--# expr-done 3142
Scope_Result_1 := Dyn_Var_Bind_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_827;


And_Pred_4 := Create_And (And_Pred_3, Scope_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4950:13") else null)); 
--# expr-done 3143
--# expr-start 3146 LogicAssign Bind_Result_2 nodes.lkt:4978
--# expr-start 3144 Expr.actual_type_var Fld_20 nodes.lkt:4978







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_20 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3144
Fld_20.Value := No_Entity;
Entity_Vars.Reset (Fld_20);





--# expr-start 3145 LktNode.equation_type Fld_21 nodes.lkt:4978







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.equation_type
Fld_21 := Liblktlang.Implementation.Lkt_Node_P_Equation_Type (Node => Ent.Node);
--# end
--# expr-done 3145



   
      Cast_Result_4 := Create_Internal_Entity
        (Node => Fld_21.Node,
         Info => Fld_21.Info);


Bind_Result_2 := Solver.Create_Assign (Fld_20, Cast_Result_4, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4978:14") else null)); 
--# expr-done 3146
And_Pred_5 := Create_And (And_Pred_4, Bind_Result_2, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:4949:9") else null)); 
--# expr-done 3147

         Property_Result := And_Pred_5;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_378;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_378;
                     Finalizer_Scope_826;
                     Finalizer_Scope_827;




            raise;
      end;



   return Property_Result;
end Logic_Unify_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Match_Expr
   --

   



      
      procedure Initialize_Fields_For_Match_Expr
        (Self : Bare_Match_Expr
         ; Match_Expr_F_Match_Expr : Bare_Expr
         ; Match_Expr_F_Branches : Bare_Base_Match_Branch_List
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Match_Expr_F_Match_Expr := Match_Expr_F_Match_Expr;
            Self.Match_Expr_F_Branches := Match_Expr_F_Branches;
         
      Self.Match_Expr_F_Expected_Branch_Type_Var := Null_Var_Record;

      end Initialize_Fields_For_Match_Expr;

      
   function Match_Expr_F_Match_Expr
     (Node : Bare_Match_Expr) return Bare_Expr
   is
      

   begin
         
         return Node.Match_Expr_F_Match_Expr;
      
   end;

      
   function Match_Expr_F_Branches
     (Node : Bare_Match_Expr) return Bare_Base_Match_Branch_List
   is
      

   begin
         
         return Node.Match_Expr_F_Branches;
      
   end;


   







--# property-start MatchExpr.has_context_free_type nodes.lkt:4989
pragma Warnings (Off, "is not referenced");

function Match_Expr_P_Has_Context_Free_Type
  
  (Node : Bare_Match_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Match_Expr :=
     Bare_Match_Expr (Node);
     Ent : Internal_Entity_Match_Expr :=
       Internal_Entity_Match_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      
            procedure Finalizer_Scope_379 with Inline_Always;

      Fld : Internal_Entity_Expr_Array_Access;
Fld_1 : Boolean;
Quantifier_Result : Boolean;

            procedure Finalizer_Scope_379 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_379;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 3150 .any Quantifier_Result nodes.lkt:4990








   

   --# expr-start 3148 MatchExpr.branch_exprs Fld nodes.lkt:4990







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start MatchExpr.branch_exprs
Fld := Liblktlang.Implementation.Match_Expr_P_Branch_Exprs (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 3148

   
      Quantifier_Result := False;
   

   

      

      declare
         
         Collection : constant Internal_Entity_Expr_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind e Item

            
      --# expr-start 3149 Expr.has_context_free_type Fld_1 nodes.lkt:4990







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 3149
      Quantifier_Result := Fld_1;
   

            
   --# end


               exit when Quantifier_Result;

         end loop;
      end;
   

   
   



--# expr-done 3150

         Property_Result := Quantifier_Result;
         
   --# end
      Finalizer_Scope_379;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_379;




            raise;
      end;



   return Property_Result;
end Match_Expr_P_Has_Context_Free_Type;
--# end

   







--# property-start MatchExpr.branch_exprs nodes.lkt:4993
pragma Warnings (Off, "is not referenced");

function Match_Expr_P_Branch_Exprs
  
  (Node : Bare_Match_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Expr_Array_Access
is
   Self : Bare_Match_Expr :=
     Bare_Match_Expr (Node);
     Ent : Internal_Entity_Match_Expr :=
       Internal_Entity_Match_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Expr_Array_Access;

      
            procedure Finalizer_Scope_380 with Inline_Always;

      Fld : Internal_Entity_Base_Match_Branch_List;
Item : Internal_Entity_Base_Match_Branch;
Fld_1 : Internal_Entity_Expr;
Fld_2 : Bare_Base_Match_Branch_List;
Fld_3 : Internal_Entity_Info;
Bare_Item : Bare_Base_Match_Branch;
As_Entity : Internal_Entity_Base_Match_Branch;
Is_Null : Boolean;
If_Result : Internal_Entity_Base_Match_Branch;
Map_Result : Internal_Entity_Expr_Array_Access;

            procedure Finalizer_Scope_380 is
            begin
                     Dec_Ref (Map_Result);
            end Finalizer_Scope_380;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 3153 .map Map_Result nodes.lkt:4993








   

   --# expr-start 3151 MatchExpr.branches Fld nodes.lkt:4993







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Base_Match_Branch_List (Node => Ent.Node.Match_Expr_F_Branches, Info => Ent.Info);
--# expr-done 3151









Fld_2 := Fld.Node;

   
      declare
         Map_Result_Vec : Internal_Entity_Expr_Vectors.Vector;
      begin
   

   

      if Fld_2 = null then
         
      Map_Result := Create_Internal_Entity_Expr_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Base_Match_Branch_List := Fld_2;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Base_Match_Branch;
else
   








Fld_3 := Fld.Info;

As_Entity := (Info => Fld_3, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind b Item

            
         
         
      --# expr-start 3152 BaseMatchBranch.expr Fld_1 nodes.lkt:4993







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Expr (Node => Implementation.Base_Match_Branch_F_Expr (Item.Node), Info => Item.Info);
--# expr-done 3152
      

         declare
            Item_To_Append : constant Internal_Entity_Expr := Fld_1;
         begin
            Internal_Entity_Expr_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Internal_Entity_Expr_Array
           (Items_Count => Natural (Internal_Entity_Expr_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Expr_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Expr_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Expr_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 3153

         Property_Result := Map_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_380;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_380;




            raise;
      end;



   return Property_Result;
end Match_Expr_P_Branch_Exprs;
--# end

   







--# property-start MatchExpr.expected_branch_type_equation nodes.lkt:4998
pragma Warnings (Off, "is not referenced");

function Match_Expr_P_Expected_Branch_Type_Equation
  
  (Node : Bare_Match_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Match_Expr :=
     Bare_Match_Expr (Node);
     Ent : Internal_Entity_Match_Expr :=
       Internal_Entity_Match_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_381 with Inline_Always;
            procedure Finalizer_Scope_830 with Inline_Always;
            procedure Finalizer_Scope_833 with Inline_Always;

      Fld : Internal_Entity_Expr_Array_Access;
Fld_1 : Boolean;
Map_Result : Internal_Entity_Expr_Array_Access;
Fld_2 : Logic_Var;
Map_Result_1 : Logic_Var_Array_Access;
Fld_3 : Logic_Var;
Array_Lit : Logic_Var_Array_Access;
Left_Var : Logic_Var_Array_Access;
Result_Var : Logic_Var_Array_Access;
Local_Logic_Vars : Logic_Var_Array_Access;
Fld_4 : Logic_Var;
Logic_Vars : Logic_Var_Array_Access;
Bind_Result : Logic_Equation;
Fld_5 : Internal_Entity_Base_Match_Branch_List;
Item_2 : Internal_Entity_Base_Match_Branch;
Fld_6 : Internal_Entity_Expr;
Fld_7 : Logic_Var;
Fld_8 : Logic_Var;
Bind_Result_1 : Logic_Equation;
Fld_9 : Bare_Base_Match_Branch_List;
Fld_10 : Internal_Entity_Info;
Bare_Item_2 : Bare_Base_Match_Branch;
As_Entity : Internal_Entity_Base_Match_Branch;
Is_Null : Boolean;
If_Result : Internal_Entity_Base_Match_Branch;
Map_Result_2 : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;
And_Pred : Logic_Equation;
Let_Result : Logic_Equation;
Scope_Result : Logic_Equation;

            procedure Finalizer_Scope_381 is
            begin
                     Dec_Ref (Scope_Result);
            end Finalizer_Scope_381;
            procedure Finalizer_Scope_830 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Left_Var);
                     Dec_Ref (Result_Var);
                     Dec_Ref (Local_Logic_Vars);
                     Dec_Ref (Logic_Vars);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Map_Result_2);
                     Dec_Ref (Logic_Boolean_Op);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Let_Result);
            end Finalizer_Scope_830;
            procedure Finalizer_Scope_833 is
            begin
                     Dec_Ref (Bind_Result_1);
            end Finalizer_Scope_833;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 3170 ValDecl Let_Result nodes.lkt:4999
--# scope-start
--# expr-start 3161 'or?' Result_Var nodes.lkt:5000



--# expr-start 3158 .map Map_Result_1 nodes.lkt:5000








   

   --# expr-start 3156 .filter Map_Result nodes.lkt:5000








   

   --# expr-start 3154 MatchExpr.branch_exprs Fld nodes.lkt:5000







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start MatchExpr.branch_exprs
Fld := Liblktlang.Implementation.Match_Expr_P_Branch_Exprs (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 3154

   
      declare
         Map_Result_Vec : Internal_Entity_Expr_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Expr_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind expr Item

            
         --# expr-start 3155 Expr.has_context_free_type Fld_1 nodes.lkt:5000







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 3155
         if Fld_1 then
            
         
      
      

         declare
            Item_To_Append : constant Internal_Entity_Expr := Item;
         begin
            Internal_Entity_Expr_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
         end if;
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Entity_Expr_Array
           (Items_Count => Natural (Internal_Entity_Expr_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Expr_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Expr_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Expr_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 3156

   
      declare
         Map_Result_1_Vec : Logic_Var_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Expr_Array_Access := Map_Result;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind expr Item_1

            
         
         
      --# expr-start 3157 Expr.actual_type_var Fld_2 nodes.lkt:5001







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Item_1.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3157
      

         declare
            Item_To_Append : constant Logic_Var := Fld_2;
         begin
            Logic_Var_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result_1 := Create_Logic_Var_Array
           (Items_Count => Natural (Logic_Var_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Logic_Var_Vectors.Get
              (Map_Result_1_Vec,
               I + Logic_Var_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Logic_Var_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 3158
Left_Var := Map_Result_1;

      Inc_Ref (Left_Var);




if Left_Var /= No_Logic_Var_Array_Type then
   
   Result_Var := Left_Var;
else
   --# expr-start 3160 ArrayLiteral Array_Lit nodes.lkt:5002
--# expr-start 3159 Expr.expected_type_var Fld_3 nodes.lkt:5002







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Ent.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3159
Array_Lit := Create_Logic_Var_Array (Internal_Logic_Var_Array'(1 => Fld_3)); 
--# expr-done 3160
   Result_Var := Array_Lit;
end if;

      Inc_Ref (Result_Var);


--# expr-done 3161
Local_Logic_Vars := Result_Var; Inc_Ref (Local_Logic_Vars);
--# bind logic_vars Local_Logic_Vars
--# expr-start 3169 LogicAnd And_Pred nodes.lkt:5004

for Var of Local_Logic_Vars.Items loop
   Var.Value := No_Entity;
   Entity_Vars.Reset (Var);
end loop;
Logic_Vars := Local_Logic_Vars; Inc_Ref (Logic_Vars);
--# expr-start 3162 MatchExpr.expected_branch_type_var Fld_4 nodes.lkt:5004







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Ent.Node.Match_Expr_F_Expected_Branch_Type_Var'Unrestricted_Access;
--# expr-done 3162
Fld_4.Value := No_Entity;
Entity_Vars.Reset (Fld_4);


Bind_Result := Solver.Create_N_Propagate (Fld_4, Create_Type_Decl_P_Imprecise_Common_Ancestor_List_0_Functor (Logic_Vars.N), Entity_Vars.Logic_Var_Array (Logic_Vars.Items)); 
--# expr-start 3168 .logic_all Logic_Boolean_Op nodes.lkt:5006








   

   --# expr-start 3163 MatchExpr.branches Fld_5 nodes.lkt:5006







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Base_Match_Branch_List (Node => Ent.Node.Match_Expr_F_Branches, Info => Ent.Info);
--# expr-done 3163









Fld_9 := Fld_5.Node;

   
      declare
         Map_Result_2_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      if Fld_9 = null then
         
      Map_Result_2 := Create_Logic_Equation_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Base_Match_Branch_List := Fld_9;
      begin
         for Untyped_Item_2 of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item_2 := Untyped_Item_2; 
                  



Is_Null := Bare_Item_2 = null; 
if Is_Null then
   
   If_Result := No_Entity_Base_Match_Branch;
else
   








Fld_10 := Fld_5.Info;

As_Entity := (Info => Fld_10, Node => Bare_Item_2); 
   If_Result := As_Entity;
end if;



                  Item_2 := If_Result; 

            
   --# scope-start


               --# bind b Item_2

            
         
         
      --# expr-start 3167 LogicUnify Bind_Result_1 nodes.lkt:5007
--# expr-start 3165 Expr.expected_type_var Fld_7 nodes.lkt:5007



--# expr-start 3164 BaseMatchBranch.expr Fld_6 nodes.lkt:5007







   if Item_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Expr (Node => Implementation.Base_Match_Branch_F_Expr (Item_2.Node), Info => Item_2.Info);
--# expr-done 3164



   if Fld_6.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Fld_6.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3165
Fld_7.Value := No_Entity;
Entity_Vars.Reset (Fld_7);
--# expr-start 3166 MatchExpr.expected_branch_type_var Fld_8 nodes.lkt:5007







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Ent.Node.Match_Expr_F_Expected_Branch_Type_Var'Unrestricted_Access;
--# expr-done 3166
Bind_Result_1 := Solver.Create_Unify (Fld_7, Fld_8, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5007:20") else null)); 
--# expr-done 3167
      

         declare
            Item_To_Append : constant Logic_Equation := Bind_Result_1;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_2_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_833;



         end loop;
      end;
   
      end if;

   

         Map_Result_2 := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_2_Vec)));
         for I in Map_Result_2.Items'Range loop
            Map_Result_2.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_2_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result_2.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_2_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result_2.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5006:28") else null)); 
--# expr-done 3168
And_Pred := Create_And (Bind_Result, Logic_Boolean_Op, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5004:9") else null)); 
--# expr-done 3169
Let_Result := And_Pred; Inc_Ref (Let_Result);
--# end
--# expr-done 3170
Scope_Result := Let_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_830;



         Property_Result := Scope_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_381;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_381;
                     Finalizer_Scope_830;
                     Finalizer_Scope_833;




            raise;
      end;



   return Property_Result;
end Match_Expr_P_Expected_Branch_Type_Equation;
--# end

   







--# property-start MatchExpr.xref_equation nodes.lkt:5011
pragma Warnings (Off, "is not referenced");

function Match_Expr_P_Xref_Equation
  
  (Node : Bare_Match_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Match_Expr :=
     Bare_Match_Expr (Node);
     Ent : Internal_Entity_Match_Expr :=
       Internal_Entity_Match_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_382 with Inline_Always;
            procedure Finalizer_Scope_834 with Inline_Always;
            procedure Finalizer_Scope_835 with Inline_Always;

      Fld : Logic_Equation;
Fld_1 : Internal_Entity_Base_Match_Branch_List;
Item : Internal_Entity_Base_Match_Branch;
Fld_2 : Internal_Entity_Expr;
Fld_3 : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_4 : Internal_Entity_Expr;
Fld_5 : Bare_Expr;
Fld_6 : Internal_Entity_Expr;
Fld_7 : Logic_Var;
Fld_8 : Internal_Entity_Expr;
Fld_9 : Logic_Var;
Pred : Logic_Equation;
Cast_Result : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred : Logic_Equation;
Fld_10 : Bare_Base_Match_Branch_List;
Fld_11 : Internal_Entity_Info;
Bare_Item : Bare_Base_Match_Branch;
As_Entity : Internal_Entity_Base_Match_Branch;
Is_Null : Boolean;
If_Result : Internal_Entity_Base_Match_Branch;
Map_Result : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;
And_Pred_1 : Logic_Equation;
Fld_12 : Logic_Var;
Fld_13 : Internal_Entity_Expr_Array_Access;
Fld_14 : Logic_Var;
Map_Result_1 : Logic_Var_Array_Access;
Logic_Vars : Logic_Var_Array_Access;
Bind_Result : Logic_Equation;
And_Pred_2 : Logic_Equation;

            procedure Finalizer_Scope_382 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Logic_Boolean_Op);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Fld_13);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (Logic_Vars);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred_2);
            end Finalizer_Scope_382;
            procedure Finalizer_Scope_834 is
            begin
                     Dec_Ref (Fld_3);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred);
            end Finalizer_Scope_834;
            procedure Finalizer_Scope_835 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_835;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3190 LogicAnd And_Pred_2 nodes.lkt:5012
--# expr-start 3185 LogicAnd And_Pred_1 nodes.lkt:5013
--# expr-start 3171 MatchExpr.expected_branch_type_equation Fld nodes.lkt:5013







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start MatchExpr.expected_branch_type_equation
Fld := Liblktlang.Implementation.Match_Expr_P_Expected_Branch_Type_Equation (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 3171
--# expr-start 3184 .logic_all Logic_Boolean_Op nodes.lkt:5014








   

   --# expr-start 3172 MatchExpr.branches Fld_1 nodes.lkt:5014







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Base_Match_Branch_List (Node => Ent.Node.Match_Expr_F_Branches, Info => Ent.Info);
--# expr-done 3172









Fld_10 := Fld_1.Node;

   
      declare
         Map_Result_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      if Fld_10 = null then
         
      Map_Result := Create_Logic_Equation_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Base_Match_Branch_List := Fld_10;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Base_Match_Branch;
else
   








Fld_11 := Fld_1.Info;

As_Entity := (Info => Fld_11, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind mb Item

            
         
         
      --# expr-start 3183 LogicAnd And_Pred nodes.lkt:5016
--# expr-start 3174 LktNode.xref_equation Fld_3 nodes.lkt:5016



--# expr-start 3173 BaseMatchBranch.expr Fld_2 nodes.lkt:5016







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Implementation.Base_Match_Branch_F_Expr (Item.Node), Info => Item.Info);
--# expr-done 3173



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_3 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld_2.Node, E_Info => Fld_2.Info);
--# end
--# expr-done 3174




   --# scope-start



--# expr-start 3182 bind Dyn_Var_Bind_Result nodes.lkt:5018





--# expr-start 3176 'Entity[Expr].node' Fld_5 nodes.lkt:5018



--# expr-start 3175 BaseMatchBranch.expr Fld_4 nodes.lkt:5018







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Expr (Node => Implementation.Base_Match_Branch_F_Expr (Item.Node), Info => Item.Info);
--# expr-done 3175





Fld_5 := Fld_4.Node;
--# expr-done 3176



   
      Cast_Result := Fld_5;


Error_Location := Cast_Result; 
--# expr-start 3181 LogicPropagate Pred nodes.lkt:5019
--# expr-start 3178 Expr.expected_type_var Fld_7 nodes.lkt:5020



--# expr-start 3177 BaseMatchBranch.expr Fld_6 nodes.lkt:5020







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Expr (Node => Implementation.Base_Match_Branch_F_Expr (Item.Node), Info => Item.Info);
--# expr-done 3177



   if Fld_6.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Fld_6.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3178
Fld_7.Value := No_Entity;
Entity_Vars.Reset (Fld_7);
--# expr-start 3180 Expr.actual_type_var Fld_9 nodes.lkt:5021



--# expr-start 3179 BaseMatchBranch.expr Fld_8 nodes.lkt:5021







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Create_Internal_Entity_Expr (Node => Implementation.Base_Match_Branch_F_Expr (Item.Node), Info => Item.Info);
--# expr-done 3179



   if Fld_8.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Fld_8.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3180
Fld_9.Value := No_Entity;
Entity_Vars.Reset (Fld_9);


Pred := Solver.Create_N_Predicate ((Fld_7, Fld_9), Create_Type_Decl_P_Matching_Type_0_Predicate (2, Error_Location)); 
--# expr-done 3181
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 3182
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_835;


And_Pred := Create_And (Fld_3, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5016:17") else null)); 
--# expr-done 3183
      

         declare
            Item_To_Append : constant Logic_Equation := And_Pred;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_834;



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5014:32") else null)); 
--# expr-done 3184
And_Pred_1 := Create_And (Fld, Logic_Boolean_Op, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5013:13") else null)); 
--# expr-done 3185
--# expr-start 3188 .map Map_Result_1 nodes.lkt:5027








   

   --# expr-start 3186 MatchExpr.branch_exprs Fld_13 nodes.lkt:5027







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start MatchExpr.branch_exprs
Fld_13 := Liblktlang.Implementation.Match_Expr_P_Branch_Exprs (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 3186

   
      declare
         Map_Result_1_Vec : Logic_Var_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Expr_Array_Access := Fld_13;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind e Item_1

            
         
         
      --# expr-start 3187 Expr.actual_type_var Fld_14 nodes.lkt:5027







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_14 := Item_1.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3187
      

         declare
            Item_To_Append : constant Logic_Var := Fld_14;
         begin
            Logic_Var_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result_1 := Create_Logic_Var_Array
           (Items_Count => Natural (Logic_Var_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Logic_Var_Vectors.Get
              (Map_Result_1_Vec,
               I + Logic_Var_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Logic_Var_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 3188
for Var of Map_Result_1.Items loop
   Var.Value := No_Entity;
   Entity_Vars.Reset (Var);
end loop;
Logic_Vars := Map_Result_1; Inc_Ref (Logic_Vars);
--# expr-start 3189 Expr.actual_type_var Fld_12 nodes.lkt:5026







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_12 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3189
Fld_12.Value := No_Entity;
Entity_Vars.Reset (Fld_12);


Bind_Result := Solver.Create_N_Propagate (Fld_12, Create_Type_Decl_P_Imprecise_Common_Ancestor_List_0_Functor (Logic_Vars.N), Entity_Vars.Logic_Var_Array (Logic_Vars.Items)); 
And_Pred_2 := Create_And (And_Pred_1, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5012:9") else null)); 
--# expr-done 3190

         Property_Result := And_Pred_2;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_382;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_382;
                     Finalizer_Scope_834;
                     Finalizer_Scope_835;




            raise;
      end;



   return Property_Result;
end Match_Expr_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Not_Expr
   --

   



      
      procedure Initialize_Fields_For_Not_Expr
        (Self : Bare_Not_Expr
         ; Not_Expr_F_Expr : Bare_Expr
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Not_Expr_F_Expr := Not_Expr_F_Expr;
         

      end Initialize_Fields_For_Not_Expr;

      
   function Not_Expr_F_Expr
     (Node : Bare_Not_Expr) return Bare_Expr
   is
      

   begin
         
         return Node.Not_Expr_F_Expr;
      
   end;


   







--# property-start NotExpr.xref_equation nodes.lkt:5036
pragma Warnings (Off, "is not referenced");

function Not_Expr_P_Xref_Equation
  
  (Node : Bare_Not_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Not_Expr :=
     Bare_Not_Expr (Node);
     Ent : Internal_Entity_Not_Expr :=
       Internal_Entity_Not_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_383 with Inline_Always;
            procedure Finalizer_Scope_837 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Logic_Var;
Fld_3 : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
And_Pred : Logic_Equation;
Fld_4 : Internal_Entity_Expr;
Fld_5 : Logic_Var;
Fld_6 : Internal_Entity_Named_Type_Decl;
Cast_Result_1 : Internal_Entity;
Bind_Result_1 : Logic_Equation;
And_Pred_1 : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_7 : Internal_Entity_Expr;
Fld_8 : Logic_Var;
Fld_9 : Internal_Entity_Expr;
Fld_10 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_2 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_2 : Logic_Equation;

            procedure Finalizer_Scope_383 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_2);
            end Finalizer_Scope_383;
            procedure Finalizer_Scope_837 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_837;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3208 LogicAnd And_Pred_2 nodes.lkt:5037
--# expr-start 3201 LogicAnd And_Pred_1 nodes.lkt:5038
--# expr-start 3196 LogicAnd And_Pred nodes.lkt:5039
--# expr-start 3192 LktNode.xref_equation Fld_1 nodes.lkt:5039



--# expr-start 3191 NotExpr.expr Fld nodes.lkt:5039







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Not_Expr_F_Expr, Info => Ent.Info);
--# expr-done 3191



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 3192
--# expr-start 3195 LogicAssign Bind_Result nodes.lkt:5040
--# expr-start 3193 Expr.actual_type_var Fld_2 nodes.lkt:5040







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3193
Fld_2.Value := No_Entity;
Entity_Vars.Reset (Fld_2);





--# expr-start 3194 LktNode.bool_type Fld_3 nodes.lkt:5040







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.bool_type
Fld_3 := Liblktlang.Implementation.Lkt_Node_P_Bool_Type (Node => Ent.Node);
--# end
--# expr-done 3194



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_3.Node,
         Info => Fld_3.Info);


Bind_Result := Solver.Create_Assign (Fld_2, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5040:22") else null)); 
--# expr-done 3195
And_Pred := Create_And (Fld_1, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5039:17") else null)); 
--# expr-done 3196
--# expr-start 3200 LogicAssign Bind_Result_1 nodes.lkt:5042
--# expr-start 3198 Expr.expected_type_var Fld_5 nodes.lkt:5042



--# expr-start 3197 NotExpr.expr Fld_4 nodes.lkt:5042







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Expr (Node => Ent.Node.Not_Expr_F_Expr, Info => Ent.Info);
--# expr-done 3197



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Fld_4.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3198
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);





--# expr-start 3199 LktNode.bool_type Fld_6 nodes.lkt:5042







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.bool_type
Fld_6 := Liblktlang.Implementation.Lkt_Node_P_Bool_Type (Node => Ent.Node);
--# end
--# expr-done 3199



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Fld_6.Node,
         Info => Fld_6.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_5, Cast_Result_1, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5042:18") else null)); 
--# expr-done 3200
And_Pred_1 := Create_And (And_Pred, Bind_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5038:13") else null)); 
--# expr-done 3201




   --# scope-start



--# expr-start 3207 bind Dyn_Var_Bind_Result nodes.lkt:5045









   
      Cast_Result_2 := Self;


Error_Location := Cast_Result_2; 
--# expr-start 3206 LogicPropagate Pred nodes.lkt:5046
--# expr-start 3203 Expr.expected_type_var Fld_8 nodes.lkt:5047



--# expr-start 3202 NotExpr.expr Fld_7 nodes.lkt:5047







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Create_Internal_Entity_Expr (Node => Ent.Node.Not_Expr_F_Expr, Info => Ent.Info);
--# expr-done 3202



   if Fld_7.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Fld_7.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3203
Fld_8.Value := No_Entity;
Entity_Vars.Reset (Fld_8);
--# expr-start 3205 Expr.actual_type_var Fld_10 nodes.lkt:5048



--# expr-start 3204 NotExpr.expr Fld_9 nodes.lkt:5048







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Create_Internal_Entity_Expr (Node => Ent.Node.Not_Expr_F_Expr, Info => Ent.Info);
--# expr-done 3204



   if Fld_9.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Fld_9.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3205
Fld_10.Value := No_Entity;
Entity_Vars.Reset (Fld_10);


Pred := Solver.Create_N_Predicate ((Fld_8, Fld_10), Create_Type_Decl_P_Matching_Type_0_Predicate (2, Error_Location)); 
--# expr-done 3206
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 3207
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_837;


And_Pred_2 := Create_And (And_Pred_1, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5037:9") else null)); 
--# expr-done 3208

         Property_Result := And_Pred_2;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_383;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_383;
                     Finalizer_Scope_837;




            raise;
      end;



   return Property_Result;
end Not_Expr_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Paren_Expr
   --

   



      
      procedure Initialize_Fields_For_Paren_Expr
        (Self : Bare_Paren_Expr
         ; Paren_Expr_F_Expr : Bare_Expr
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Paren_Expr_F_Expr := Paren_Expr_F_Expr;
         

      end Initialize_Fields_For_Paren_Expr;

      
   function Paren_Expr_F_Expr
     (Node : Bare_Paren_Expr) return Bare_Expr
   is
      

   begin
         
         return Node.Paren_Expr_F_Expr;
      
   end;


   







--# property-start ParenExpr.expected_type_equation nodes.lkt:5058
pragma Warnings (Off, "is not referenced");

function Paren_Expr_P_Expected_Type_Equation
  
  (Node : Bare_Paren_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Paren_Expr :=
     Bare_Paren_Expr (Node);
     Ent : Internal_Entity_Paren_Expr :=
       Internal_Entity_Paren_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_384 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Var;
Fld_2 : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;

            procedure Finalizer_Scope_384 is
            begin
                     Dec_Ref (Bind_Result);
            end Finalizer_Scope_384;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3212 LogicAssign Bind_Result nodes.lkt:5059
--# expr-start 3210 Expr.expected_type_var Fld_1 nodes.lkt:5059



--# expr-start 3209 ParenExpr.expr Fld nodes.lkt:5059







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Paren_Expr_F_Expr, Info => Ent.Info);
--# expr-done 3209



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Fld.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3210
Fld_1.Value := No_Entity;
Entity_Vars.Reset (Fld_1);





--# expr-start 3211 Expr.get_expected_type Fld_2 nodes.lkt:5059







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_expected_type
Fld_2 := Liblktlang.Implementation.Expr_P_Get_Expected_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 3211



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_2.Node,
         Info => Fld_2.Info);


Bind_Result := Solver.Create_Assign (Fld_1, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5059:9") else null)); 
--# expr-done 3212

         Property_Result := Bind_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_384;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_384;




            raise;
      end;



   return Property_Result;
end Paren_Expr_P_Expected_Type_Equation;
--# end

   







--# property-start ParenExpr.xref_equation nodes.lkt:5061
pragma Warnings (Off, "is not referenced");

function Paren_Expr_P_Xref_Equation
  
  (Node : Bare_Paren_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Paren_Expr :=
     Bare_Paren_Expr (Node);
     Ent : Internal_Entity_Paren_Expr :=
       Internal_Entity_Paren_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_385 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Logic_Var;
Fld_3 : Internal_Entity_Expr;
Fld_4 : Logic_Var;
Bind_Result : Logic_Equation;
And_Pred : Logic_Equation;
Fld_5 : Internal_Entity_Expr;
Fld_6 : Logic_Var;
Fld_7 : Logic_Var;
Bind_Result_1 : Logic_Equation;
Fld_8 : Boolean;
Fld_9 : Internal_Entity_Expr;
Fld_10 : Logic_Var;
Fld_11 : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result_2 : Logic_Equation;
If_Result : Logic_Equation;
Fld_12 : Boolean;
Fld_13 : Internal_Entity_Expr;
Fld_14 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result_1 : Internal_Entity;
Bind_Result_3 : Logic_Equation;
If_Result_1 : Logic_Equation;
And_Pred_1 : Logic_Equation;

            procedure Finalizer_Scope_385 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (Bind_Result_2);
                     Dec_Ref (If_Result);
                     Dec_Ref (Bind_Result_3);
                     Dec_Ref (If_Result_1);
                     Dec_Ref (And_Pred_1);
            end Finalizer_Scope_385;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3235 LogicAnd And_Pred_1 nodes.lkt:5062
--# expr-start 3219 LogicAnd And_Pred nodes.lkt:5063
--# expr-start 3214 LktNode.xref_equation Fld_1 nodes.lkt:5063



--# expr-start 3213 ParenExpr.expr Fld nodes.lkt:5063







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Paren_Expr_F_Expr, Info => Ent.Info);
--# expr-done 3213



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 3214
--# expr-start 3218 LogicUnify Bind_Result nodes.lkt:5064
--# expr-start 3215 Expr.actual_type_var Fld_2 nodes.lkt:5064







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3215
Fld_2.Value := No_Entity;
Entity_Vars.Reset (Fld_2);
--# expr-start 3217 Expr.actual_type_var Fld_4 nodes.lkt:5064



--# expr-start 3216 ParenExpr.expr Fld_3 nodes.lkt:5064







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Expr (Node => Ent.Node.Paren_Expr_F_Expr, Info => Ent.Info);
--# expr-done 3216



   if Fld_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Fld_3.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3217
Bind_Result := Solver.Create_Unify (Fld_2, Fld_4, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5064:18") else null)); 
--# expr-done 3218
And_Pred := Create_And (Fld_1, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5063:13") else null)); 
--# expr-done 3219
--# expr-start 3234 If If_Result_1 nodes.lkt:5067



--# expr-start 3220 ParenExpr.has_context_free_type Fld_12 nodes.lkt:5067







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_12 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 3220
if Fld_12 then
   --# expr-start 3223 LogicAssign Bind_Result_3 nodes.lkt:5068
--# expr-start 3222 Expr.expected_type_var Fld_14 nodes.lkt:5068



--# expr-start 3221 ParenExpr.expr Fld_13 nodes.lkt:5068







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_13 := Create_Internal_Entity_Expr (Node => Ent.Node.Paren_Expr_F_Expr, Info => Ent.Info);
--# expr-done 3221



   if Fld_13.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_14 := Fld_13.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3222
Fld_14.Value := No_Entity;
Entity_Vars.Reset (Fld_14);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result_3 := Solver.Create_Assign (Fld_14, Cast_Result_1, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5068:18") else null)); 
--# expr-done 3223
   If_Result_1 := Bind_Result_3;
else
   --# expr-start 3233 If If_Result nodes.lkt:5067



--# expr-start 3224 Expr.xref_entry_point Fld_8 nodes.lkt:5069







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_entry_point'
Fld_8 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Entry_Point (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 3224
if Fld_8 then
   --# expr-start 3228 LogicAssign Bind_Result_2 nodes.lkt:5070
--# expr-start 3226 Expr.expected_type_var Fld_10 nodes.lkt:5070



--# expr-start 3225 ParenExpr.expr Fld_9 nodes.lkt:5070







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Create_Internal_Entity_Expr (Node => Ent.Node.Paren_Expr_F_Expr, Info => Ent.Info);
--# expr-done 3225



   if Fld_9.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Fld_9.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3226
Fld_10.Value := No_Entity;
Entity_Vars.Reset (Fld_10);





--# expr-start 3227 Expr.get_expected_type Fld_11 nodes.lkt:5070







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_expected_type
Fld_11 := Liblktlang.Implementation.Expr_P_Get_Expected_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 3227



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_11.Node,
         Info => Fld_11.Info);


Bind_Result_2 := Solver.Create_Assign (Fld_10, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5070:18") else null)); 
--# expr-done 3228
   If_Result := Bind_Result_2;
else
   --# expr-start 3232 LogicUnify Bind_Result_1 nodes.lkt:5071
--# expr-start 3230 Expr.expected_type_var Fld_6 nodes.lkt:5071



--# expr-start 3229 ParenExpr.expr Fld_5 nodes.lkt:5071







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Expr (Node => Ent.Node.Paren_Expr_F_Expr, Info => Ent.Info);
--# expr-done 3229



   if Fld_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Fld_5.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3230
Fld_6.Value := No_Entity;
Entity_Vars.Reset (Fld_6);
--# expr-start 3231 Expr.expected_type_var Fld_7 nodes.lkt:5071







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Ent.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3231
Bind_Result_1 := Solver.Create_Unify (Fld_6, Fld_7, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5071:18") else null)); 
--# expr-done 3232
   If_Result := Bind_Result_1;
end if;

      Inc_Ref (If_Result);


--# expr-done 3233
   If_Result_1 := If_Result;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 3234
And_Pred_1 := Create_And (And_Pred, If_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5062:9") else null)); 
--# expr-done 3235

         Property_Result := And_Pred_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_385;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_385;




            raise;
      end;



   return Property_Result;
end Paren_Expr_P_Xref_Equation;
--# end

   







--# property-start ParenExpr.has_context_free_type nodes.lkt:5074
pragma Warnings (Off, "is not referenced");

function Paren_Expr_P_Has_Context_Free_Type
  
  (Node : Bare_Paren_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Paren_Expr :=
     Bare_Paren_Expr (Node);
     Ent : Internal_Entity_Paren_Expr :=
       Internal_Entity_Paren_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Fld : Internal_Entity_Expr;
Fld_1 : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 3237 Expr.has_context_free_type Fld_1 nodes.lkt:5074



--# expr-start 3236 ParenExpr.expr Fld nodes.lkt:5074







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Paren_Expr_F_Expr, Info => Ent.Info);
--# expr-done 3236



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 3237

         Property_Result := Fld_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Paren_Expr_P_Has_Context_Free_Type;
--# end



   


      

   --
   --  Primitives for Bare_Query
   --

   



      
      procedure Initialize_Fields_For_Query
        (Self : Bare_Query
         ; Query_F_Source : Bare_Expr
         ; Query_F_Pattern : Bare_Pattern
         ; Query_F_Mapping : Bare_Expr
         ; Query_F_Guard : Bare_Expr
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Query_F_Source := Query_F_Source;
            Self.Query_F_Pattern := Query_F_Pattern;
            Self.Query_F_Mapping := Query_F_Mapping;
            Self.Query_F_Guard := Query_F_Guard;
         

      end Initialize_Fields_For_Query;

      
   function Query_F_Source
     (Node : Bare_Query) return Bare_Expr
   is
      

   begin
         
         return Node.Query_F_Source;
      
   end;

      
   function Query_F_Pattern
     (Node : Bare_Query) return Bare_Pattern
   is
      

   begin
         
         return Node.Query_F_Pattern;
      
   end;

      
   function Query_F_Mapping
     (Node : Bare_Query) return Bare_Expr
   is
      

   begin
         
         return Node.Query_F_Mapping;
      
   end;

      
   function Query_F_Guard
     (Node : Bare_Query) return Bare_Expr
   is
      

   begin
         
         return Node.Query_F_Guard;
      
   end;




   


      

   --
   --  Primitives for Bare_Raise_Expr
   --

   



      
      procedure Initialize_Fields_For_Raise_Expr
        (Self : Bare_Raise_Expr
         ; Raise_Expr_F_Dest_Type : Bare_Type_Ref
         ; Raise_Expr_F_Except_Expr : Bare_Expr
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Raise_Expr_F_Dest_Type := Raise_Expr_F_Dest_Type;
            Self.Raise_Expr_F_Except_Expr := Raise_Expr_F_Except_Expr;
         

      end Initialize_Fields_For_Raise_Expr;

      
   function Raise_Expr_F_Dest_Type
     (Node : Bare_Raise_Expr) return Bare_Type_Ref
   is
      

   begin
         
         return Node.Raise_Expr_F_Dest_Type;
      
   end;

      
   function Raise_Expr_F_Except_Expr
     (Node : Bare_Raise_Expr) return Bare_Expr
   is
      

   begin
         
         return Node.Raise_Expr_F_Except_Expr;
      
   end;


   







--# property-start RaiseExpr.xref_equation nodes.lkt:5085
pragma Warnings (Off, "is not referenced");

function Raise_Expr_P_Xref_Equation
  
  (Node : Bare_Raise_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Raise_Expr :=
     Bare_Raise_Expr (Node);
     Ent : Internal_Entity_Raise_Expr :=
       Internal_Entity_Raise_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_387 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Logic_Var;
Fld_3 : Internal_Entity_Type_Ref;
Fld_4 : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result : Logic_Equation;
Fld_5 : Internal_Entity_Type_Ref;
Is_Null : Boolean;
Fld_6 : Logic_Var;
Fld_7 : Internal_Entity_Type_Decl;
Cast_Result_1 : Internal_Entity;
Bind_Result_1 : Logic_Equation;
If_Result : Logic_Equation;
And_Pred : Logic_Equation;
Fld_8 : Internal_Entity_Expr;
Fld_9 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result_2 : Internal_Entity;
Bind_Result_2 : Logic_Equation;
And_Pred_1 : Logic_Equation;

            procedure Finalizer_Scope_387 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (If_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Bind_Result_2);
                     Dec_Ref (And_Pred_1);
            end Finalizer_Scope_387;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3254 LogicAnd And_Pred_1 nodes.lkt:5086
--# expr-start 3250 LogicAnd And_Pred nodes.lkt:5087
--# expr-start 3239 LktNode.xref_equation Fld_1 nodes.lkt:5087



--# expr-start 3238 RaiseExpr.except_expr Fld nodes.lkt:5087







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Raise_Expr_F_Except_Expr, Info => Ent.Info);
--# expr-done 3238



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 3239
--# expr-start 3249 If If_Result nodes.lkt:5089



--# expr-start 3241 .is_null Is_Null nodes.lkt:5089
--# expr-start 3240 RaiseExpr.dest_type Fld_5 nodes.lkt:5089







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Raise_Expr_F_Dest_Type, Info => Ent.Info);
--# expr-done 3240
Is_Null := Fld_5.Node = null; 
--# expr-done 3241
if Is_Null then
   --# expr-start 3244 LogicAssign Bind_Result_1 nodes.lkt:5090
--# expr-start 3242 Expr.actual_type_var Fld_6 nodes.lkt:5090







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3242
Fld_6.Value := No_Entity;
Entity_Vars.Reset (Fld_6);





--# expr-start 3243 Expr.get_expected_type Fld_7 nodes.lkt:5090







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_expected_type
Fld_7 := Liblktlang.Implementation.Expr_P_Get_Expected_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 3243



   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Fld_7.Node,
         Info => Fld_7.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_6, Cast_Result_1, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5090:22") else null)); 
--# expr-done 3244
   If_Result := Bind_Result_1;
else
   --# expr-start 3248 LogicAssign Bind_Result nodes.lkt:5091
--# expr-start 3245 Expr.actual_type_var Fld_2 nodes.lkt:5091







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3245
Fld_2.Value := No_Entity;
Entity_Vars.Reset (Fld_2);





--# expr-start 3247 TypeRef.referenced_decl Fld_4 nodes.lkt:5091



--# expr-start 3246 RaiseExpr.dest_type Fld_3 nodes.lkt:5091







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Raise_Expr_F_Dest_Type, Info => Ent.Info);
--# expr-done 3246



   if Fld_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeRef.referenced_decl
Fld_4 := Liblktlang.Implementation.Type_Ref_P_Referenced_Decl (Node => Fld_3.Node, E_Info => Fld_3.Info);
--# end
--# expr-done 3247



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_4.Node,
         Info => Fld_4.Info);


Bind_Result := Solver.Create_Assign (Fld_2, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5091:22") else null)); 
--# expr-done 3248
   If_Result := Bind_Result;
end if;

      Inc_Ref (If_Result);


--# expr-done 3249
And_Pred := Create_And (Fld_1, If_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5087:13") else null)); 
--# expr-done 3250
--# expr-start 3253 LogicAssign Bind_Result_2 nodes.lkt:5094
--# expr-start 3252 Expr.expected_type_var Fld_9 nodes.lkt:5094



--# expr-start 3251 RaiseExpr.except_expr Fld_8 nodes.lkt:5094







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Create_Internal_Entity_Expr (Node => Ent.Node.Raise_Expr_F_Except_Expr, Info => Ent.Info);
--# expr-done 3251



   if Fld_8.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Fld_8.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3252
Fld_9.Value := No_Entity;
Entity_Vars.Reset (Fld_9);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result_2 := Solver.Create_Assign (Fld_9, Cast_Result_2, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5094:14") else null)); 
--# expr-done 3253
And_Pred_1 := Create_And (And_Pred, Bind_Result_2, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5086:9") else null)); 
--# expr-done 3254

         Property_Result := And_Pred_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_387;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_387;




            raise;
      end;



   return Property_Result;
end Raise_Expr_P_Xref_Equation;
--# end

   







--# property-start RaiseExpr.has_context_free_type nodes.lkt:5096
pragma Warnings (Off, "is not referenced");

function Raise_Expr_P_Has_Context_Free_Type
  
  (Node : Bare_Raise_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Raise_Expr :=
     Bare_Raise_Expr (Node);
     Ent : Internal_Entity_Raise_Expr :=
       Internal_Entity_Raise_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Fld : Internal_Entity_Type_Ref;
Is_Null : Boolean;
Not_Val : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 3257 Not Not_Val nodes.lkt:5096
--# expr-start 3256 .is_null Is_Null nodes.lkt:5096
--# expr-start 3255 RaiseExpr.dest_type Fld nodes.lkt:5096







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Raise_Expr_F_Dest_Type, Info => Ent.Info);
--# expr-done 3255
Is_Null := Fld.Node = null; 
--# expr-done 3256
Not_Val := not (Is_Null); 
--# expr-done 3257

         Property_Result := Not_Val;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Raise_Expr_P_Has_Context_Free_Type;
--# end



   


      

   --
   --  Primitives for Bare_Subscript_Expr
   --

   



      
      procedure Initialize_Fields_For_Subscript_Expr
        (Self : Bare_Subscript_Expr
         ; Subscript_Expr_F_Prefix : Bare_Expr
         ; Subscript_Expr_F_Null_Cond : Bare_Null_Cond_Qualifier
         ; Subscript_Expr_F_Index : Bare_Expr
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Subscript_Expr_F_Prefix := Subscript_Expr_F_Prefix;
            Self.Subscript_Expr_F_Null_Cond := Subscript_Expr_F_Null_Cond;
            Self.Subscript_Expr_F_Index := Subscript_Expr_F_Index;
         

      end Initialize_Fields_For_Subscript_Expr;

      
   function Subscript_Expr_F_Prefix
     (Node : Bare_Subscript_Expr) return Bare_Expr
   is
      

   begin
         
         return Node.Subscript_Expr_F_Prefix;
      
   end;

      
   function Subscript_Expr_F_Null_Cond
     (Node : Bare_Subscript_Expr) return Bare_Null_Cond_Qualifier
   is
      

   begin
         
         return Node.Subscript_Expr_F_Null_Cond;
      
   end;

      
   function Subscript_Expr_F_Index
     (Node : Bare_Subscript_Expr) return Bare_Expr
   is
      

   begin
         
         return Node.Subscript_Expr_F_Index;
      
   end;


   







--# property-start SubscriptExpr.has_context_free_type nodes.lkt:5108
pragma Warnings (Off, "is not referenced");

function Subscript_Expr_P_Has_Context_Free_Type
  
  (Node : Bare_Subscript_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Subscript_Expr :=
     Bare_Subscript_Expr (Node);
     Ent : Internal_Entity_Subscript_Expr :=
       Internal_Entity_Subscript_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Fld : Internal_Entity_Expr;
Fld_1 : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 3259 Expr.has_context_free_type Fld_1 nodes.lkt:5108



--# expr-start 3258 SubscriptExpr.prefix Fld nodes.lkt:5108







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Subscript_Expr_F_Prefix, Info => Ent.Info);
--# expr-done 3258



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 3259

         Property_Result := Fld_1;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Subscript_Expr_P_Has_Context_Free_Type;
--# end

   







--# property-start SubscriptExpr.xref_equation nodes.lkt:5110
pragma Warnings (Off, "is not referenced");

function Subscript_Expr_P_Xref_Equation
  
  (Node : Bare_Subscript_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Subscript_Expr :=
     Bare_Subscript_Expr (Node);
     Ent : Internal_Entity_Subscript_Expr :=
       Internal_Entity_Subscript_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_390 with Inline_Always;
            procedure Finalizer_Scope_838 with Inline_Always;
            procedure Finalizer_Scope_839 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Internal_Entity_Expr;
Fld_3 : Logic_Equation;
And_Pred : Logic_Equation;
Fld_4 : Logic_Var;
Fld_5 : Internal_Entity_Expr;
Fld_6 : Logic_Var;
Bind_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;
Fld_7 : Internal_Entity_Expr;
Fld_8 : Logic_Var;
Fld_9 : Internal_Entity_Named_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result_1 : Logic_Equation;
And_Pred_2 : Logic_Equation;
Fld_10 : Internal_Entity_Expr;
Fld_11 : Logic_Var;
Fld_12 : Internal_Entity_Type_Decl;
Var_Expr : Internal_Entity_Type_Decl;
Fld_13 : Internal_Entity_Type_Decl;
Result_Var : Internal_Entity_Type_Decl;
Cast_Result_1 : Internal_Entity;
Bind_Result_2 : Logic_Equation;
Fld_14 : Internal_Entity_Expr;
Fld_15 : Boolean;
Fld_16 : Internal_Entity_Expr;
Fld_17 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result_2 : Internal_Entity;
Bind_Result_3 : Logic_Equation;
If_Result : Logic_Equation;
Fld_18 : Boolean;
Not_Val : Boolean;
Fld_19 : Internal_Entity_Expr;
Fld_20 : Logic_Var;
Fld_21 : Logic_Var;
Bind_Result_4 : Logic_Equation;
If_Result_1 : Logic_Equation;
And_Pred_3 : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_22 : Bare_Expr;
Fld_23 : Internal_Entity_Expr;
Fld_24 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_3 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_4 : Logic_Equation;
Error_Location_1 : Bare_Lkt_Node;
Fld_25 : Bare_Expr;
Fld_26 : Internal_Entity_Expr;
Fld_27 : Logic_Var;
Pred_1 : Logic_Equation;
Cast_Result_4 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_1 : Logic_Equation;
Scope_Result_1 : Logic_Equation;
And_Pred_5 : Logic_Equation;

            procedure Finalizer_Scope_390 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Fld_3);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Bind_Result_2);
                     Dec_Ref (Bind_Result_3);
                     Dec_Ref (If_Result);
                     Dec_Ref (Bind_Result_4);
                     Dec_Ref (If_Result_1);
                     Dec_Ref (And_Pred_3);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_4);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (And_Pred_5);
            end Finalizer_Scope_390;
            procedure Finalizer_Scope_838 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_838;
            procedure Finalizer_Scope_839 is
            begin
                     Dec_Ref (Pred_1);
                     Dec_Ref (Dyn_Var_Bind_Result_1);
            end Finalizer_Scope_839;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3305 LogicAnd And_Pred_5 nodes.lkt:5111
--# expr-start 3299 LogicAnd And_Pred_4 nodes.lkt:5112
--# expr-start 3293 LogicAnd And_Pred_3 nodes.lkt:5113
--# expr-start 3274 LogicAnd And_Pred_2 nodes.lkt:5114
--# expr-start 3269 LogicAnd And_Pred_1 nodes.lkt:5115
--# expr-start 3264 LogicAnd And_Pred nodes.lkt:5116
--# expr-start 3261 LktNode.xref_equation Fld_1 nodes.lkt:5116



--# expr-start 3260 SubscriptExpr.prefix Fld nodes.lkt:5116







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Subscript_Expr_F_Prefix, Info => Ent.Info);
--# expr-done 3260



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 3261
--# expr-start 3263 LktNode.xref_equation Fld_3 nodes.lkt:5117



--# expr-start 3262 SubscriptExpr.index Fld_2 nodes.lkt:5117







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Ent.Node.Subscript_Expr_F_Index, Info => Ent.Info);
--# expr-done 3262



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_3 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld_2.Node, E_Info => Fld_2.Info);
--# end
--# expr-done 3263
And_Pred := Create_And (Fld_1, Fld_3, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5116:29") else null)); 
--# expr-done 3264
--# expr-start 3268 LogicPropagate Bind_Result nodes.lkt:5119
--# expr-start 3266 Expr.actual_type_var Fld_6 nodes.lkt:5121



--# expr-start 3265 SubscriptExpr.prefix Fld_5 nodes.lkt:5121







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Create_Internal_Entity_Expr (Node => Ent.Node.Subscript_Expr_F_Prefix, Info => Ent.Info);
--# expr-done 3265



   if Fld_5.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Fld_5.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3266
Fld_6.Value := No_Entity;
Entity_Vars.Reset (Fld_6);
--# expr-start 3267 Expr.actual_type_var Fld_4 nodes.lkt:5119







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3267
Fld_4.Value := No_Entity;
Entity_Vars.Reset (Fld_4);

Bind_Result := Solver.Create_Propagate (Fld_6, Fld_4, Create_Type_Decl_P_Get_Array_Content_Type_0_Functor); 
--# expr-done 3268
And_Pred_1 := Create_And (And_Pred, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5115:25") else null)); 
--# expr-done 3269
--# expr-start 3273 LogicAssign Bind_Result_1 nodes.lkt:5126
--# expr-start 3271 Expr.expected_type_var Fld_8 nodes.lkt:5126



--# expr-start 3270 SubscriptExpr.index Fld_7 nodes.lkt:5126







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Create_Internal_Entity_Expr (Node => Ent.Node.Subscript_Expr_F_Index, Info => Ent.Info);
--# expr-done 3270



   if Fld_7.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Fld_7.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3271
Fld_8.Value := No_Entity;
Entity_Vars.Reset (Fld_8);





--# expr-start 3272 LktNode.int_type Fld_9 nodes.lkt:5126







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.int_type
Fld_9 := Liblktlang.Implementation.Lkt_Node_P_Int_Type (Node => Ent.Node);
--# end
--# expr-done 3272



   
      Cast_Result := Create_Internal_Entity
        (Node => Fld_9.Node,
         Info => Fld_9.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_8, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5126:25") else null)); 
--# expr-done 3273
And_Pred_2 := Create_And (And_Pred_1, Bind_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5114:21") else null)); 
--# expr-done 3274
--# expr-start 3292 If If_Result_1 nodes.lkt:5130



--# expr-start 3276 Not Not_Val nodes.lkt:5130
--# expr-start 3275 Expr.xref_entry_point Fld_18 nodes.lkt:5130







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_entry_point'
Fld_18 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Entry_Point (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 3275
Not_Val := not (Fld_18); 
--# expr-done 3276
if Not_Val then
   --# expr-start 3280 LogicPropagate Bind_Result_4 nodes.lkt:5132
--# expr-start 3277 Expr.expected_type_var Fld_21 nodes.lkt:5133







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_21 := Ent.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3277
Fld_21.Value := No_Entity;
Entity_Vars.Reset (Fld_21);
--# expr-start 3279 Expr.expected_type_var Fld_20 nodes.lkt:5132



--# expr-start 3278 SubscriptExpr.prefix Fld_19 nodes.lkt:5132







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_19 := Create_Internal_Entity_Expr (Node => Ent.Node.Subscript_Expr_F_Prefix, Info => Ent.Info);
--# expr-done 3278



   if Fld_19.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_20 := Fld_19.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3279
Fld_20.Value := No_Entity;
Entity_Vars.Reset (Fld_20);

Bind_Result_4 := Solver.Create_Propagate (Fld_21, Fld_20, Create_Type_Decl_P_Make_Array_Type_0_Functor); 
--# expr-done 3280
   If_Result_1 := Bind_Result_4;
else
   --# expr-start 3291 If If_Result nodes.lkt:5130



--# expr-start 3282 Expr.has_context_free_type Fld_15 nodes.lkt:5134



--# expr-start 3281 SubscriptExpr.prefix Fld_14 nodes.lkt:5134







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_14 := Create_Internal_Entity_Expr (Node => Ent.Node.Subscript_Expr_F_Prefix, Info => Ent.Info);
--# expr-done 3281



   if Fld_14.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_15 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Fld_14.Node, E_Info => Fld_14.Info);
--# end
--# expr-done 3282
if Fld_15 then
   --# expr-start 3285 LogicAssign Bind_Result_3 nodes.lkt:5136
--# expr-start 3284 Expr.expected_type_var Fld_17 nodes.lkt:5136



--# expr-start 3283 SubscriptExpr.prefix Fld_16 nodes.lkt:5136







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_16 := Create_Internal_Entity_Expr (Node => Ent.Node.Subscript_Expr_F_Prefix, Info => Ent.Info);
--# expr-done 3283



   if Fld_16.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_17 := Fld_16.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3284
Fld_17.Value := No_Entity;
Entity_Vars.Reset (Fld_17);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result_2 := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result_3 := Solver.Create_Assign (Fld_17, Cast_Result_2, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5136:25") else null)); 
--# expr-done 3285
   If_Result := Bind_Result_3;
else
   --# expr-start 3290 LogicAssign Bind_Result_2 nodes.lkt:5138
--# expr-start 3287 Expr.expected_type_var Fld_11 nodes.lkt:5138



--# expr-start 3286 SubscriptExpr.prefix Fld_10 nodes.lkt:5138







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Create_Internal_Entity_Expr (Node => Ent.Node.Subscript_Expr_F_Prefix, Info => Ent.Info);
--# expr-done 3286



   if Fld_10.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Fld_10.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3287
Fld_11.Value := No_Entity;
Entity_Vars.Reset (Fld_11);








--# expr-start 3288 Expr.get_expected_type Fld_12 nodes.lkt:5139







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_expected_type
Fld_12 := Liblktlang.Implementation.Expr_P_Get_Expected_Type (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 3288
Var_Expr := Fld_12;





if Var_Expr /= No_Entity_Type_Decl then
   --# expr-start 3289 TypeDecl.make_array_type Fld_13 nodes.lkt:5139







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TypeDecl.make_array_type
Fld_13 := Liblktlang.Implementation.Type_Decl_P_Make_Array_Type (Node => Var_Expr.Node, E_Info => Var_Expr.Info);
--# end
--# expr-done 3289
   Result_Var := Fld_13;
else
   
   Result_Var := No_Entity_Type_Decl;
end if;






   
      Cast_Result_1 := Create_Internal_Entity
        (Node => Result_Var.Node,
         Info => Result_Var.Info);


Bind_Result_2 := Solver.Create_Assign (Fld_11, Cast_Result_1, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5138:25") else null)); 
--# expr-done 3290
   If_Result := Bind_Result_2;
end if;

      Inc_Ref (If_Result);


--# expr-done 3291
   If_Result_1 := If_Result;
end if;

      Inc_Ref (If_Result_1);


--# expr-done 3292
And_Pred_3 := Create_And (And_Pred_2, If_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5113:17") else null)); 
--# expr-done 3293




   --# scope-start



--# expr-start 3298 bind Dyn_Var_Bind_Result nodes.lkt:5143





--# expr-start 3294 SubscriptExpr.index Fld_22 nodes.lkt:5143







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_22 := Self.Subscript_Expr_F_Index;
--# expr-done 3294



   
      Cast_Result_3 := Fld_22;


Error_Location := Cast_Result_3; 
--# expr-start 3297 LogicPropagate Pred nodes.lkt:5144
--# expr-start 3296 Expr.actual_type_var Fld_24 nodes.lkt:5144



--# expr-start 3295 SubscriptExpr.index Fld_23 nodes.lkt:5144







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_23 := Create_Internal_Entity_Expr (Node => Ent.Node.Subscript_Expr_F_Index, Info => Ent.Info);
--# expr-done 3295



   if Fld_23.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_24 := Fld_23.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3296
Fld_24.Value := No_Entity;
Entity_Vars.Reset (Fld_24);

Pred := Solver.Create_Predicate (Fld_24, Create_Type_Decl_P_Is_Int_Type_0_Predicate (Error_Location)); 
--# expr-done 3297
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 3298
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_838;


And_Pred_4 := Create_And (And_Pred_3, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5112:13") else null)); 
--# expr-done 3299




   --# scope-start



--# expr-start 3304 bind Dyn_Var_Bind_Result_1 nodes.lkt:5148





--# expr-start 3300 SubscriptExpr.prefix Fld_25 nodes.lkt:5148







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_25 := Self.Subscript_Expr_F_Prefix;
--# expr-done 3300



   
      Cast_Result_4 := Fld_25;


Error_Location_1 := Cast_Result_4; 
--# expr-start 3303 LogicPropagate Pred_1 nodes.lkt:5149
--# expr-start 3302 Expr.actual_type_var Fld_27 nodes.lkt:5149



--# expr-start 3301 SubscriptExpr.prefix Fld_26 nodes.lkt:5149







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_26 := Create_Internal_Entity_Expr (Node => Ent.Node.Subscript_Expr_F_Prefix, Info => Ent.Info);
--# expr-done 3301



   if Fld_26.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_27 := Fld_26.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3302
Fld_27.Value := No_Entity;
Entity_Vars.Reset (Fld_27);

Pred_1 := Solver.Create_Predicate (Fld_27, Create_Type_Decl_P_Is_Of_Array_Type_0_Predicate (Error_Location_1)); 
--# expr-done 3303
Dyn_Var_Bind_Result_1 := Pred_1; Inc_Ref (Dyn_Var_Bind_Result_1);
--# expr-done 3304
Scope_Result_1 := Dyn_Var_Bind_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_839;


And_Pred_5 := Create_And (And_Pred_4, Scope_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5111:9") else null)); 
--# expr-done 3305

         Property_Result := And_Pred_5;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_390;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_390;
                     Finalizer_Scope_838;
                     Finalizer_Scope_839;




            raise;
      end;



   return Property_Result;
end Subscript_Expr_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Try_Expr
   --

   



      
      procedure Initialize_Fields_For_Try_Expr
        (Self : Bare_Try_Expr
         ; Try_Expr_F_Try_Expr : Bare_Expr
         ; Try_Expr_F_Or_Expr : Bare_Expr
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Try_Expr_F_Try_Expr := Try_Expr_F_Try_Expr;
            Self.Try_Expr_F_Or_Expr := Try_Expr_F_Or_Expr;
         
      Self.Try_Expr_F_Expected_Expr_Type_Var := Null_Var_Record;

      end Initialize_Fields_For_Try_Expr;

      
   function Try_Expr_F_Try_Expr
     (Node : Bare_Try_Expr) return Bare_Expr
   is
      

   begin
         
         return Node.Try_Expr_F_Try_Expr;
      
   end;

      
   function Try_Expr_F_Or_Expr
     (Node : Bare_Try_Expr) return Bare_Expr
   is
      

   begin
         
         return Node.Try_Expr_F_Or_Expr;
      
   end;


   







--# property-start TryExpr.exprs nodes.lkt:5163
pragma Warnings (Off, "is not referenced");

function Try_Expr_P_Exprs
  
  (Node : Bare_Try_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Expr_Array_Access
is
   Self : Bare_Try_Expr :=
     Bare_Try_Expr (Node);
     Ent : Internal_Entity_Try_Expr :=
       Internal_Entity_Try_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Expr_Array_Access;

      
            procedure Finalizer_Scope_391 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Internal_Entity_Expr;
Array_Lit : Internal_Entity_Expr_Array_Access;
Fld_2 : Internal_Entity_Expr;
Is_Null : Boolean;
Fld_3 : Internal_Entity_Expr;
Array_Lit_1 : Internal_Entity_Expr_Array_Access;
If_Result : Internal_Entity_Expr_Array_Access;

            procedure Finalizer_Scope_391 is
            begin
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Array_Lit_1);
                     Dec_Ref (If_Result);
            end Finalizer_Scope_391;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 3313 If If_Result nodes.lkt:5164



--# expr-start 3307 .is_null Is_Null nodes.lkt:5164
--# expr-start 3306 TryExpr.or_expr Fld_2 nodes.lkt:5164







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Ent.Node.Try_Expr_F_Or_Expr, Info => Ent.Info);
--# expr-done 3306
Is_Null := Fld_2.Node = null; 
--# expr-done 3307
if Is_Null then
   --# expr-start 3309 ArrayLiteral Array_Lit_1 nodes.lkt:5164
--# expr-start 3308 TryExpr.try_expr Fld_3 nodes.lkt:5164







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Expr (Node => Ent.Node.Try_Expr_F_Try_Expr, Info => Ent.Info);
--# expr-done 3308
Array_Lit_1 := Create_Internal_Entity_Expr_Array (Internal_Internal_Entity_Expr_Array'(1 => Fld_3)); 
--# expr-done 3309
   If_Result := Array_Lit_1;
else
   --# expr-start 3312 ArrayLiteral Array_Lit nodes.lkt:5165
--# expr-start 3310 TryExpr.try_expr Fld nodes.lkt:5165







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Try_Expr_F_Try_Expr, Info => Ent.Info);
--# expr-done 3310
--# expr-start 3311 TryExpr.or_expr Fld_1 nodes.lkt:5165







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Create_Internal_Entity_Expr (Node => Ent.Node.Try_Expr_F_Or_Expr, Info => Ent.Info);
--# expr-done 3311
Array_Lit := Create_Internal_Entity_Expr_Array (Internal_Internal_Entity_Expr_Array'(1 => Fld, 2 => Fld_1)); 
--# expr-done 3312
   If_Result := Array_Lit;
end if;

      Inc_Ref (If_Result);


--# expr-done 3313

         Property_Result := If_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_391;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_391;




            raise;
      end;



   return Property_Result;
end Try_Expr_P_Exprs;
--# end

   







--# property-start TryExpr.expected_exprs_type_equation nodes.lkt:5170
pragma Warnings (Off, "is not referenced");

function Try_Expr_P_Expected_Exprs_Type_Equation
  
  (Node : Bare_Try_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Try_Expr :=
     Bare_Try_Expr (Node);
     Ent : Internal_Entity_Try_Expr :=
       Internal_Entity_Try_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_392 with Inline_Always;
            procedure Finalizer_Scope_840 with Inline_Always;
            procedure Finalizer_Scope_843 with Inline_Always;

      Fld : Internal_Entity_Expr_Array_Access;
Fld_1 : Boolean;
Map_Result : Internal_Entity_Expr_Array_Access;
Fld_2 : Logic_Var;
Map_Result_1 : Logic_Var_Array_Access;
Fld_3 : Logic_Var;
Array_Lit : Logic_Var_Array_Access;
Concat_Result : Logic_Var_Array_Access;
Fld_4 : Logic_Var;
Array_Lit_1 : Logic_Var_Array_Access;
Left_Var : Logic_Var_Array_Access;
Result_Var : Logic_Var_Array_Access;
Local_Logic_Vars : Logic_Var_Array_Access;
Fld_5 : Logic_Var;
Logic_Vars : Logic_Var_Array_Access;
Bind_Result : Logic_Equation;
Fld_6 : Internal_Entity_Expr_Array_Access;
Fld_7 : Logic_Var;
Fld_8 : Logic_Var;
Bind_Result_1 : Logic_Equation;
Map_Result_2 : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;
And_Pred : Logic_Equation;
Let_Result : Logic_Equation;
Scope_Result : Logic_Equation;

            procedure Finalizer_Scope_392 is
            begin
                     Dec_Ref (Scope_Result);
            end Finalizer_Scope_392;
            procedure Finalizer_Scope_840 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Concat_Result);
                     Dec_Ref (Array_Lit_1);
                     Dec_Ref (Left_Var);
                     Dec_Ref (Result_Var);
                     Dec_Ref (Local_Logic_Vars);
                     Dec_Ref (Logic_Vars);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Fld_6);
                     Dec_Ref (Map_Result_2);
                     Dec_Ref (Logic_Boolean_Op);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Let_Result);
            end Finalizer_Scope_840;
            procedure Finalizer_Scope_843 is
            begin
                     Dec_Ref (Bind_Result_1);
            end Finalizer_Scope_843;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 3332 ValDecl Let_Result nodes.lkt:5171
--# scope-start
--# expr-start 3324 'or?' Result_Var nodes.lkt:5172



--# expr-start 3321 ArrayConcat Concat_Result nodes.lkt:5172
--# expr-start 3318 .map Map_Result_1 nodes.lkt:5172








   

   --# expr-start 3316 .filter Map_Result nodes.lkt:5172








   

   --# expr-start 3314 TryExpr.exprs Fld nodes.lkt:5172







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TryExpr.exprs
Fld := Liblktlang.Implementation.Try_Expr_P_Exprs (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 3314

   
      declare
         Map_Result_Vec : Internal_Entity_Expr_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Expr_Array_Access := Fld;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind e Item

            
         --# expr-start 3315 Expr.has_context_free_type Fld_1 nodes.lkt:5172







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.has_context_free_type'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Has_Context_Free_Type (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 3315
         if Fld_1 then
            
         
      
      

         declare
            Item_To_Append : constant Internal_Entity_Expr := Item;
         begin
            Internal_Entity_Expr_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
         end if;
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result := Create_Internal_Entity_Expr_Array
           (Items_Count => Natural (Internal_Entity_Expr_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Internal_Entity_Expr_Vectors.Get
              (Map_Result_Vec,
               I + Internal_Entity_Expr_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Internal_Entity_Expr_Vectors.Destroy (Map_Result_Vec);

      end;
   



--# expr-done 3316

   
      declare
         Map_Result_1_Vec : Logic_Var_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Expr_Array_Access := Map_Result;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind e Item_1

            
         
         
      --# expr-start 3317 Expr.actual_type_var Fld_2 nodes.lkt:5173







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Item_1.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3317
      

         declare
            Item_To_Append : constant Logic_Var := Fld_2;
         begin
            Logic_Var_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result_1 := Create_Logic_Var_Array
           (Items_Count => Natural (Logic_Var_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Logic_Var_Vectors.Get
              (Map_Result_1_Vec,
               I + Logic_Var_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Logic_Var_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 3318
--# expr-start 3320 ArrayLiteral Array_Lit nodes.lkt:5175
--# expr-start 3319 Expr.expected_type_var Fld_3 nodes.lkt:5175







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Ent.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3319
Array_Lit := Create_Logic_Var_Array (Internal_Logic_Var_Array'(1 => Fld_3)); 
--# expr-done 3320
Concat_Result := Concat (Map_Result_1, Array_Lit); 
--# expr-done 3321
Left_Var := Concat_Result;

      Inc_Ref (Left_Var);




if Left_Var /= No_Logic_Var_Array_Type then
   
   Result_Var := Left_Var;
else
   --# expr-start 3323 ArrayLiteral Array_Lit_1 nodes.lkt:5176
--# expr-start 3322 Expr.expected_type_var Fld_4 nodes.lkt:5176







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Ent.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3322
Array_Lit_1 := Create_Logic_Var_Array (Internal_Logic_Var_Array'(1 => Fld_4)); 
--# expr-done 3323
   Result_Var := Array_Lit_1;
end if;

      Inc_Ref (Result_Var);


--# expr-done 3324
Local_Logic_Vars := Result_Var; Inc_Ref (Local_Logic_Vars);
--# bind logic_vars Local_Logic_Vars
--# expr-start 3331 LogicAnd And_Pred nodes.lkt:5178

for Var of Local_Logic_Vars.Items loop
   Var.Value := No_Entity;
   Entity_Vars.Reset (Var);
end loop;
Logic_Vars := Local_Logic_Vars; Inc_Ref (Logic_Vars);
--# expr-start 3325 TryExpr.expected_expr_type_var Fld_5 nodes.lkt:5178







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Ent.Node.Try_Expr_F_Expected_Expr_Type_Var'Unrestricted_Access;
--# expr-done 3325
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);


Bind_Result := Solver.Create_N_Propagate (Fld_5, Create_Type_Decl_P_Imprecise_Common_Ancestor_List_0_Functor (Logic_Vars.N), Entity_Vars.Logic_Var_Array (Logic_Vars.Items)); 
--# expr-start 3330 .logic_all Logic_Boolean_Op nodes.lkt:5180








   

   --# expr-start 3326 TryExpr.exprs Fld_6 nodes.lkt:5180







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TryExpr.exprs
Fld_6 := Liblktlang.Implementation.Try_Expr_P_Exprs (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 3326

   
      declare
         Map_Result_2_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Expr_Array_Access := Fld_6;
      begin
         for Item_2 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind e Item_2

            
         
         
      --# expr-start 3329 LogicUnify Bind_Result_1 nodes.lkt:5181
--# expr-start 3327 Expr.expected_type_var Fld_7 nodes.lkt:5181







   if Item_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Item_2.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3327
Fld_7.Value := No_Entity;
Entity_Vars.Reset (Fld_7);
--# expr-start 3328 TryExpr.expected_expr_type_var Fld_8 nodes.lkt:5181







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Ent.Node.Try_Expr_F_Expected_Expr_Type_Var'Unrestricted_Access;
--# expr-done 3328
Bind_Result_1 := Solver.Create_Unify (Fld_7, Fld_8, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5181:20") else null)); 
--# expr-done 3329
      

         declare
            Item_To_Append : constant Logic_Equation := Bind_Result_1;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_2_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_843;



         end loop;
      end;
   

   

         Map_Result_2 := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_2_Vec)));
         for I in Map_Result_2.Items'Range loop
            Map_Result_2.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_2_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result_2.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_2_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result_2.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5180:27") else null)); 
--# expr-done 3330
And_Pred := Create_And (Bind_Result, Logic_Boolean_Op, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5178:9") else null)); 
--# expr-done 3331
Let_Result := And_Pred; Inc_Ref (Let_Result);
--# end
--# expr-done 3332
Scope_Result := Let_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_840;



         Property_Result := Scope_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_392;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_392;
                     Finalizer_Scope_840;
                     Finalizer_Scope_843;




            raise;
      end;



   return Property_Result;
end Try_Expr_P_Expected_Exprs_Type_Equation;
--# end

   







--# property-start TryExpr.xref_equation nodes.lkt:5185
pragma Warnings (Off, "is not referenced");

function Try_Expr_P_Xref_Equation
  
  (Node : Bare_Try_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Try_Expr :=
     Bare_Try_Expr (Node);
     Ent : Internal_Entity_Try_Expr :=
       Internal_Entity_Try_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_393 with Inline_Always;
            procedure Finalizer_Scope_844 with Inline_Always;
            procedure Finalizer_Scope_845 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Logic_Equation;
And_Pred : Logic_Equation;
Fld_3 : Internal_Entity_Expr_Array_Access;
Fld_4 : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_5 : Bare_Expr;
Fld_6 : Logic_Var;
Fld_7 : Logic_Var;
Pred : Logic_Equation;
Cast_Result : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;
Map_Result : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;
And_Pred_2 : Logic_Equation;
Fld_8 : Logic_Var;
Fld_9 : Internal_Entity_Expr_Array_Access;
Fld_10 : Logic_Var;
Map_Result_1 : Logic_Var_Array_Access;
Logic_Vars : Logic_Var_Array_Access;
Bind_Result : Logic_Equation;
And_Pred_3 : Logic_Equation;

            procedure Finalizer_Scope_393 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Fld_2);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Fld_3);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Logic_Boolean_Op);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Fld_9);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (Logic_Vars);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred_3);
            end Finalizer_Scope_393;
            procedure Finalizer_Scope_844 is
            begin
                     Dec_Ref (Fld_4);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_1);
            end Finalizer_Scope_844;
            procedure Finalizer_Scope_845 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_845;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3351 LogicAnd And_Pred_3 nodes.lkt:5186
--# expr-start 3346 LogicAnd And_Pred_2 nodes.lkt:5187
--# expr-start 3336 LogicAnd And_Pred nodes.lkt:5188
--# expr-start 3334 LktNode.xref_equation Fld_1 nodes.lkt:5188



--# expr-start 3333 TryExpr.try_expr Fld nodes.lkt:5188







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Try_Expr_F_Try_Expr, Info => Ent.Info);
--# expr-done 3333



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 3334
--# expr-start 3335 TryExpr.expected_exprs_type_equation Fld_2 nodes.lkt:5189







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TryExpr.expected_exprs_type_equation
Fld_2 := Liblktlang.Implementation.Try_Expr_P_Expected_Exprs_Type_Equation (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 3335
And_Pred := Create_And (Fld_1, Fld_2, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5188:17") else null)); 
--# expr-done 3336
--# expr-start 3345 .logic_all Logic_Boolean_Op nodes.lkt:5191








   

   --# expr-start 3337 TryExpr.exprs Fld_3 nodes.lkt:5191







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TryExpr.exprs
Fld_3 := Liblktlang.Implementation.Try_Expr_P_Exprs (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 3337

   
      declare
         Map_Result_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Expr_Array_Access := Fld_3;
      begin
         for Item of
               Collection.Items
         loop

            
   --# scope-start


               --# bind e Item

            
         
         
      --# expr-start 3344 LogicAnd And_Pred_1 nodes.lkt:5193
--# expr-start 3338 LktNode.xref_equation Fld_4 nodes.lkt:5193







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_4 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 3338




   --# scope-start



--# expr-start 3343 bind Dyn_Var_Bind_Result nodes.lkt:5195





--# expr-start 3339 'Entity[Expr].node' Fld_5 nodes.lkt:5195









Fld_5 := Item.Node;
--# expr-done 3339



   
      Cast_Result := Fld_5;


Error_Location := Cast_Result; 
--# expr-start 3342 LogicPropagate Pred nodes.lkt:5196
--# expr-start 3340 Expr.expected_type_var Fld_6 nodes.lkt:5197







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Item.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3340
Fld_6.Value := No_Entity;
Entity_Vars.Reset (Fld_6);
--# expr-start 3341 Expr.actual_type_var Fld_7 nodes.lkt:5198







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Item.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3341
Fld_7.Value := No_Entity;
Entity_Vars.Reset (Fld_7);


Pred := Solver.Create_N_Predicate ((Fld_6, Fld_7), Create_Type_Decl_P_Commutative_Matching_Type_0_Predicate (2, Error_Location)); 
--# expr-done 3342
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 3343
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_845;


And_Pred_1 := Create_And (Fld_4, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5193:17") else null)); 
--# expr-done 3344
      

         declare
            Item_To_Append : constant Logic_Equation := And_Pred_1;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_844;



         end loop;
      end;
   

   

         Map_Result := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5191:31") else null)); 
--# expr-done 3345
And_Pred_2 := Create_And (And_Pred, Logic_Boolean_Op, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5187:13") else null)); 
--# expr-done 3346
--# expr-start 3349 .map Map_Result_1 nodes.lkt:5205








   

   --# expr-start 3347 TryExpr.exprs Fld_9 nodes.lkt:5205







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start TryExpr.exprs
Fld_9 := Liblktlang.Implementation.Try_Expr_P_Exprs (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 3347

   
      declare
         Map_Result_1_Vec : Logic_Var_Vectors.Vector;
      begin
   

   

      

      declare
         
         Collection : constant Internal_Entity_Expr_Array_Access := Fld_9;
      begin
         for Item_1 of
               Collection.Items
         loop

            
   --# scope-start


               --# bind e Item_1

            
         
         
      --# expr-start 3348 Expr.actual_type_var Fld_10 nodes.lkt:5205







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Item_1.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3348
      

         declare
            Item_To_Append : constant Logic_Var := Fld_10;
         begin
            Logic_Var_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   

   

         Map_Result_1 := Create_Logic_Var_Array
           (Items_Count => Natural (Logic_Var_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Logic_Var_Vectors.Get
              (Map_Result_1_Vec,
               I + Logic_Var_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Logic_Var_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 3349
for Var of Map_Result_1.Items loop
   Var.Value := No_Entity;
   Entity_Vars.Reset (Var);
end loop;
Logic_Vars := Map_Result_1; Inc_Ref (Logic_Vars);
--# expr-start 3350 Expr.actual_type_var Fld_8 nodes.lkt:5203







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3350
Fld_8.Value := No_Entity;
Entity_Vars.Reset (Fld_8);


Bind_Result := Solver.Create_N_Propagate (Fld_8, Create_Type_Decl_P_Imprecise_Common_Ancestor_List_0_Functor (Logic_Vars.N), Entity_Vars.Logic_Var_Array (Logic_Vars.Items)); 
And_Pred_3 := Create_And (And_Pred_2, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5186:9") else null)); 
--# expr-done 3351

         Property_Result := And_Pred_3;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_393;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_393;
                     Finalizer_Scope_844;
                     Finalizer_Scope_845;




            raise;
      end;



   return Property_Result;
end Try_Expr_P_Xref_Equation;
--# end

   







--# property-start TryExpr.has_context_free_type nodes.lkt:5208
pragma Warnings (Off, "is not referenced");

function Try_Expr_P_Has_Context_Free_Type
  
  (Node : Bare_Try_Expr
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Try_Expr :=
     Bare_Try_Expr (Node);
     Ent : Internal_Entity_Try_Expr :=
       Internal_Entity_Try_Expr'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := False;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Try_Expr_P_Has_Context_Free_Type;
--# end



   


      

   --
   --  Primitives for Bare_Un_Op
   --

   



      
      procedure Initialize_Fields_For_Un_Op
        (Self : Bare_Un_Op
         ; Un_Op_F_Op : Bare_Op
         ; Un_Op_F_Expr : Bare_Expr
        ) is
      begin
            Initialize_Fields_For_Expr
              (Self);

            Self.Un_Op_F_Op := Un_Op_F_Op;
            Self.Un_Op_F_Expr := Un_Op_F_Expr;
         

      end Initialize_Fields_For_Un_Op;

      
   function Un_Op_F_Op
     (Node : Bare_Un_Op) return Bare_Op
   is
      

   begin
         
         return Node.Un_Op_F_Op;
      
   end;

      
   function Un_Op_F_Expr
     (Node : Bare_Un_Op) return Bare_Expr
   is
      

   begin
         
         return Node.Un_Op_F_Expr;
      
   end;


   







--# property-start UnOp.xref_equation nodes.lkt:5218
pragma Warnings (Off, "is not referenced");

function Un_Op_P_Xref_Equation
  
  (Node : Bare_Un_Op
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Un_Op :=
     Bare_Un_Op (Node);
     Ent : Internal_Entity_Un_Op :=
       Internal_Entity_Un_Op'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_395 with Inline_Always;
            procedure Finalizer_Scope_847 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Logic_Var;
Fld_3 : Internal_Entity_Expr;
Fld_4 : Logic_Var;
Bind_Result : Logic_Equation;
And_Pred : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_5 : Bare_Expr;
Fld_6 : Logic_Var;
Pred : Logic_Equation;
Cast_Result : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;

            procedure Finalizer_Scope_395 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_1);
            end Finalizer_Scope_395;
            procedure Finalizer_Scope_847 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_847;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3363 LogicAnd And_Pred_1 nodes.lkt:5219
--# expr-start 3358 LogicAnd And_Pred nodes.lkt:5220
--# expr-start 3353 LktNode.xref_equation Fld_1 nodes.lkt:5220



--# expr-start 3352 UnOp.expr Fld nodes.lkt:5220







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Un_Op_F_Expr, Info => Ent.Info);
--# expr-done 3352



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 3353
--# expr-start 3357 LogicUnify Bind_Result nodes.lkt:5221
--# expr-start 3354 Expr.actual_type_var Fld_2 nodes.lkt:5221







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3354
Fld_2.Value := No_Entity;
Entity_Vars.Reset (Fld_2);
--# expr-start 3356 Expr.actual_type_var Fld_4 nodes.lkt:5221



--# expr-start 3355 UnOp.expr Fld_3 nodes.lkt:5221







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Create_Internal_Entity_Expr (Node => Ent.Node.Un_Op_F_Expr, Info => Ent.Info);
--# expr-done 3355



   if Fld_3.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Fld_3.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3356
Bind_Result := Solver.Create_Unify (Fld_2, Fld_4, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5221:18") else null)); 
--# expr-done 3357
And_Pred := Create_And (Fld_1, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5220:13") else null)); 
--# expr-done 3358




   --# scope-start



--# expr-start 3362 bind Dyn_Var_Bind_Result nodes.lkt:5224





--# expr-start 3359 UnOp.expr Fld_5 nodes.lkt:5224







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Self.Un_Op_F_Expr;
--# expr-done 3359



   
      Cast_Result := Fld_5;


Error_Location := Cast_Result; 
--# expr-start 3361 LogicPropagate Pred nodes.lkt:5225
--# expr-start 3360 Expr.actual_type_var Fld_6 nodes.lkt:5225







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Ent.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3360
Fld_6.Value := No_Entity;
Entity_Vars.Reset (Fld_6);

Pred := Solver.Create_Predicate (Fld_6, Create_Type_Decl_P_Is_Int_Type_0_Predicate (Error_Location)); 
--# expr-done 3361
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 3362
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_847;


And_Pred_1 := Create_And (And_Pred, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5219:9") else null)); 
--# expr-done 3363

         Property_Result := And_Pred_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_395;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_395;
                     Finalizer_Scope_847;




            raise;
      end;



   return Property_Result;
end Un_Op_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Full_Decl
   --

   



      
      procedure Initialize_Fields_For_Full_Decl
        (Self : Bare_Full_Decl
         ; Full_Decl_F_Doc : Bare_String_Lit
         ; Full_Decl_F_Decl_Annotations : Bare_Decl_Annotation_List
         ; Full_Decl_F_Decl : Bare_Decl
        ) is
      begin

            Self.Full_Decl_F_Doc := Full_Decl_F_Doc;
            Self.Full_Decl_F_Decl_Annotations := Full_Decl_F_Decl_Annotations;
            Self.Full_Decl_F_Decl := Full_Decl_F_Decl;
         

      end Initialize_Fields_For_Full_Decl;

      
   function Full_Decl_F_Doc
     (Node : Bare_Full_Decl) return Bare_String_Lit
   is
      

   begin
         
         return Node.Full_Decl_F_Doc;
      
   end;

      
   function Full_Decl_F_Decl_Annotations
     (Node : Bare_Full_Decl) return Bare_Decl_Annotation_List
   is
      

   begin
         
         return Node.Full_Decl_F_Decl_Annotations;
      
   end;

      
   function Full_Decl_F_Decl
     (Node : Bare_Full_Decl) return Bare_Decl
   is
      

   begin
         
         return Node.Full_Decl_F_Decl;
      
   end;


   







--# property-start FullDecl.has_annotation nodes.lkt:5242
pragma Warnings (Off, "is not referenced");

function Full_Decl_P_Has_Annotation
  
  (Node : Bare_Full_Decl
      ; Name : Symbol_Type
  )

   return Boolean
is
   Self : Bare_Full_Decl :=
     Bare_Full_Decl (Node);
      --# bind node Self

   

   --# bind name Name

   Property_Result : Boolean;

      

      Fld : Bare_Decl_Annotation;
Is_Null : Boolean;
Not_Val : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 3366 Not Not_Val nodes.lkt:5243
--# expr-start 3365 .is_null Is_Null nodes.lkt:5243
--# expr-start 3364 FullDecl.get_annotation Fld nodes.lkt:5243







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;



--# property-call-start FullDecl.get_annotation
Fld := Liblktlang.Implementation.Full_Decl_P_Get_Annotation (Node => Self, Name => Name);
--# end
--# expr-done 3364
Is_Null := Fld = null; 
--# expr-done 3365
Not_Val := not (Is_Null); 
--# expr-done 3366

         Property_Result := Not_Val;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Full_Decl_P_Has_Annotation;
--# end

   







--# property-start FullDecl.get_annotation nodes.lkt:5246
pragma Warnings (Off, "is not referenced");

function Full_Decl_P_Get_Annotation
  
  (Node : Bare_Full_Decl
      ; Name : Symbol_Type
  )

   return Bare_Decl_Annotation
is
   Self : Bare_Full_Decl :=
     Bare_Full_Decl (Node);
      --# bind node Self

   

   --# bind name Name

   Property_Result : Bare_Decl_Annotation;

      

      Fld : Bare_Decl_Annotation_List;
Item : Bare_Decl_Annotation;
Fld_1 : Bare_Id;
Sym : Symbol_Type;
Is_Equal : Boolean;
Find_Result : Bare_Decl_Annotation;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 3371 .find Find_Result nodes.lkt:5247








   

   --# expr-start 3367 FullDecl.decl_annotations Fld nodes.lkt:5247







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Self.Full_Decl_F_Decl_Annotations;
--# expr-done 3367

   
      Find_Result := No_Bare_Lkt_Node;
   

   

      if Fld = null then
         
      Find_Result := No_Bare_Lkt_Node;
   
      else
         

      declare
         
         Collection : constant Bare_Decl_Annotation_List := Fld;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Item := Untyped_Item; 

            
   --# scope-start


               --# bind ann Item

            
      --# expr-start 3370 Eq Is_Equal nodes.lkt:5247
--# expr-start 3369 .symbol Sym nodes.lkt:5247
--# expr-start 3368 DeclAnnotation.name Fld_1 nodes.lkt:5247







   if Item = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Item.Decl_Annotation_F_Name;
--# expr-done 3368
Sym := Get_Symbol (Fld_1); 
--# expr-done 3369

Is_Equal := Sym = Name; 
--# expr-done 3370
      if Is_Equal then
         Find_Result := Item; 
      end if;
   

            
   --# end


               exit when Is_Equal;

         end loop;
      end;
   
      end if;

   
   



--# expr-done 3371

         Property_Result := Find_Result;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Full_Decl_P_Get_Annotation;
--# end



   


      

   --
   --  Primitives for Bare_Grammar_List_Sep
   --

   



      
      procedure Initialize_Fields_For_Grammar_List_Sep
        (Self : Bare_Grammar_List_Sep
         ; Grammar_List_Sep_F_Token : Bare_Grammar_Expr
         ; Grammar_List_Sep_F_Extra : Bare_Id
        ) is
      begin

            Self.Grammar_List_Sep_F_Token := Grammar_List_Sep_F_Token;
            Self.Grammar_List_Sep_F_Extra := Grammar_List_Sep_F_Extra;
         

      end Initialize_Fields_For_Grammar_List_Sep;

      
   function Grammar_List_Sep_F_Token
     (Node : Bare_Grammar_List_Sep) return Bare_Grammar_Expr
   is
      

   begin
         
         return Node.Grammar_List_Sep_F_Token;
      
   end;

      
   function Grammar_List_Sep_F_Extra
     (Node : Bare_Grammar_List_Sep) return Bare_Id
   is
      

   begin
         
         return Node.Grammar_List_Sep_F_Extra;
      
   end;




   


      

   --
   --  Primitives for Bare_Import
   --

   



   

   

   

   

   

   

   


      procedure Import_Pre_Env_Actions
        (Self            : Bare_Import;
         State           : in out PLE_Node_State;
         Add_To_Env_Only : Boolean := False) is
      begin
            


   
      declare
         Dummy : Internal_Unit;
      begin
         Dummy := Liblktlang.Implementation.Internal_Env_Do_16 (Node => 
Self);
      end;
   
   
      end;



      
      procedure Initialize_Fields_For_Import
        (Self : Bare_Import
         ; Import_F_Name : Bare_Module_Ref_Id
        ) is
      begin

            Self.Import_F_Name := Import_F_Name;
         

      end Initialize_Fields_For_Import;

      
   function Import_F_Name
     (Node : Bare_Import) return Bare_Module_Ref_Id
   is
      

   begin
         
         return Node.Import_F_Name;
      
   end;


   







--# property-start Import.referenced_unit nodes.lkt:5267
pragma Warnings (Off, "is not referenced");

function Import_P_Referenced_Unit
  
  (Node : Bare_Import
  )

   return Internal_Unit
is
   Self : Bare_Import :=
     Bare_Import (Node);
      --# bind node Self

   


   Property_Result : Internal_Unit;

      
            procedure Finalizer_Scope_398 with Inline_Always;

      Fld : Bare_Module_Ref_Id;
Fld_1 : String_Type;
Fld_2 : Internal_Unit;

            procedure Finalizer_Scope_398 is
            begin
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_398;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;


      begin
         
   --# scope-start

         --# expr-start 3374 LktNode.internal_fetch_referenced_unit Fld_2 nodes.lkt:5268







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# expr-start 3373 LktNode.text Fld_1 nodes.lkt:5268



--# expr-start 3372 Import.name Fld nodes.lkt:5268







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Self.Import_F_Name;
--# expr-done 3372



   if Fld = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Liblktlang.Implementation.Text (Node => Fld);
--# expr-done 3373
Fld_2 := Liblktlang.Implementation.Extensions.Lkt_Node_P_Internal_Fetch_Referenced_Unit (Node => Self, Name => Fld_1);
--# expr-done 3374

         Property_Result := Fld_2;
         
   --# end
      Finalizer_Scope_398;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_398;




            raise;
      end;



   return Property_Result;
end Import_P_Referenced_Unit;
--# end

   







--# property-start 'Import.[internal]internal_env_do_16' nodes.lkt:5271
pragma Warnings (Off, "is not referenced");

function Internal_Env_Do_16
  
  (Node : Bare_Import
  )

   return Internal_Unit
is
   Self : Bare_Import :=
     Bare_Import (Node);
      --# bind node Self

   


   Property_Result : Internal_Unit;

      

      Fld : Internal_Unit;



begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3375 Import.referenced_unit Fld nodes.lkt:5271







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Import.referenced_unit
Fld := Liblktlang.Implementation.Import_P_Referenced_Unit (Node => Self);
--# end
--# expr-done 3375

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Internal_Env_Do_16;
--# end



   


      

   --
   --  Primitives for Bare_Langkit_Root
   --

   



   

   

   

   

   

   

   


      procedure Langkit_Root_Pre_Env_Actions
        (Self            : Bare_Langkit_Root;
         State           : in out PLE_Node_State;
         Add_To_Env_Only : Boolean := False) is
      begin
            


   
      declare
         Dummy : Internal_Unit;
      begin
         Dummy := Liblktlang.Implementation.Internal_Env_Do_17 (Node => 
Self);
      end;
   
   
      end;

      procedure Langkit_Root_Post_Env_Actions
        (Self : Bare_Langkit_Root; State : in out PLE_Node_State) is
      begin
            


   
      if Liblktlang.Implementation.Internal_Ref_Cond_19 (Node => 
Self) then

         declare
            Ref_Env_Nodes : Bare_Lkt_Node_Array_Access :=
               Liblktlang.Implementation.Internal_Ref_Env_Nodes_18 (Node => 
Self);

            Env : Lexical_Env :=
              Self.Self_Env;
         begin

            Ref_Env
              (Self,
               Env,
               Ref_Env_Nodes,
               Langkit_Root_P_Internal_Env'Access,
               Normal,
               All_Cats,
               False);
            Dec_Ref (Ref_Env_Nodes);
         end;

      end if;
   
   
      end;


      
      procedure Initialize_Fields_For_Langkit_Root
        (Self : Bare_Langkit_Root
         ; Langkit_Root_F_Doc : Bare_Module_Doc_String_Lit
         ; Langkit_Root_F_Imports : Bare_Import_List
         ; Langkit_Root_F_Decls : Bare_Full_Decl_List
        ) is
      begin

            Self.Langkit_Root_F_Doc := Langkit_Root_F_Doc;
            Self.Langkit_Root_F_Imports := Langkit_Root_F_Imports;
            Self.Langkit_Root_F_Decls := Langkit_Root_F_Decls;
         
      Self.Internal_Bare_Langkit_Root_Lf_State_Empty_Type_Ref_List_22 := Uninitialized;
      Self.Internal_Bare_Langkit_Root_Lf_Stg_Empty_Type_Ref_List_23 := No_Bare_Lkt_Node;

      end Initialize_Fields_For_Langkit_Root;

      
   function Langkit_Root_F_Doc
     (Node : Bare_Langkit_Root) return Bare_Module_Doc_String_Lit
   is
      

   begin
         
         return Node.Langkit_Root_F_Doc;
      
   end;

      
   function Langkit_Root_F_Imports
     (Node : Bare_Langkit_Root) return Bare_Import_List
   is
      

   begin
         
         return Node.Langkit_Root_F_Imports;
      
   end;

      
   function Langkit_Root_F_Decls
     (Node : Bare_Langkit_Root) return Bare_Full_Decl_List
   is
      

   begin
         
         return Node.Langkit_Root_F_Decls;
      
   end;


   







--# property-start LangkitRoot.internal_env nodes.lkt:5294
pragma Warnings (Off, "is not referenced");

function Langkit_Root_P_Internal_Env
  
  (Node : Bare_Langkit_Root
  )

   return Lexical_Env
is
   Self : Bare_Langkit_Root :=
     Bare_Langkit_Root (Node);
      --# bind node Self

   


   Property_Result : Lexical_Env;

      
            procedure Finalizer_Scope_400 with Inline_Always;
            procedure Finalizer_Scope_849 with Inline_Always;

      Origin : Internal_Entity;
Fld : Lexical_Env := Empty_Env;
Sym : Symbol_Type;
Env_Get_Result : Internal_Entity;
Cast_Result : Internal_Entity_Decl;
Fld_1 : Lexical_Env := Empty_Env;
Dyn_Var_Bind_Result : Lexical_Env := Empty_Env;
Scope_Result : Lexical_Env := Empty_Env;

            procedure Finalizer_Scope_400 is
            begin
                     Dec_Ref (Scope_Result);
            end Finalizer_Scope_400;
            procedure Finalizer_Scope_849 is
            begin
                     Dec_Ref (Fld);
                     Dec_Ref (Fld_1);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_849;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         



   --# scope-start



--# expr-start 3381 bind Dyn_Var_Bind_Result nodes.lkt:5295

Origin := No_Entity; 
--# expr-start 3380 Decl.defined_scope Fld_1 nodes.lkt:5297



--# expr-start 3379 Cast Cast_Result nodes.lkt:5297





--# expr-start 3378 .get_first Env_Get_Result nodes.lkt:5297
--# expr-start 3376 LktNode.children_env Fld nodes.lkt:5297







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Children_Env (Node => Self);
--# expr-done 3376
--# expr-start 3377 SymbolLiteral Sym nodes.lkt:5297
Sym := Precomputed_Symbol (Precomputed_Symbol_Table (Self.Unit.Context.Symbols), Precomputed_Sym_Internal); 
--# expr-done 3377


Env_Get_Result := AST_Envs.Get_First (Self => Fld, Key => Thin (Sym), Lookup_Kind => To_Lookup_Kind_Type (Recursive), Categories => (Nocat => True)); 
--# expr-done 3378



   if Env_Get_Result.Node = null
      or else Env_Get_Result.Node.Kind in Lkt_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Decl
        (Node => Env_Get_Result.Node,
         Info => Env_Get_Result.Info);

   else
         Cast_Result := No_Entity_Decl;
   end if;


--# expr-done 3379



   if Cast_Result.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Decl.defined_scope'
Fld_1 := Liblktlang.Implementation.Dispatcher_Decl_P_Defined_Scope (Node => Cast_Result.Node, Origin => Origin, E_Info => Cast_Result.Info);
--# end
--# expr-done 3380
Dyn_Var_Bind_Result := Fld_1; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 3381
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_849;



         Property_Result := Scope_Result;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_400;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_400;
                     Finalizer_Scope_849;




            raise;
      end;



   return Property_Result;
end Langkit_Root_P_Internal_Env;
--# end

   







--# property-start LangkitRoot.empty_type_ref_list nodes.lkt:5307
pragma Warnings (Off, "is not referenced");

function Langkit_Root_F_Empty_Type_Ref_List
  
  (Node : Bare_Langkit_Root
  )

   return Bare_Synthetic_Type_Ref_List
is
   Self : Bare_Langkit_Root :=
     Bare_Langkit_Root (Node);
      --# bind node Self

   


   Property_Result : Bare_Synthetic_Type_Ref_List;

      
            procedure Finalizer_Scope_401 with Inline_Always;

      Array_Lit : Bare_Type_Ref_Node_Builder_Array_Access;
Builder : Bare_Synthetic_Type_Ref_List_Node_Builder;

            procedure Finalizer_Scope_401 is
            begin
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Builder);
            end Finalizer_Scope_401;


begin
   --# property-body-start

   pragma Assert (Self = Node);

      case Self.Internal_Bare_Langkit_Root_Lf_State_Empty_Type_Ref_List_22 is
         when Uninitialized =>
            null;

         when Initialized =>
            Property_Result :=
              Self.Internal_Bare_Langkit_Root_Lf_Stg_Empty_Type_Ref_List_23;
            return Property_Result;

         when Error_Initialization_State =>
            Reraise_Initialization_Error
              (Self,
               Self.Internal_Bare_Langkit_Root_Lf_State_Empty_Type_Ref_List_22,
               "lazy field memoization");
      end case;




      begin
         
   --# scope-start

         --# expr-start 3383 .builder Builder nodes.lkt:5308
--# expr-start 3382 ArrayLiteral Array_Lit nodes.lkt:5308
Array_Lit := Create_Bare_Type_Ref_Node_Builder_Array (Items_Count => 0); 
--# expr-done 3382
Builder := Create_Bare_Synthetic_Type_Ref_List_Node_Builder (Array_Lit); 
--# expr-done 3383


         Property_Result := Node_Builder_Type'(Builder).all.Build (Parent => No_Bare_Lkt_Node, Self_Node => Self);
         
   --# end
      Finalizer_Scope_401;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_401;

               Self.Internal_Bare_Langkit_Root_Lf_State_Empty_Type_Ref_List_22 :=
                 Initialization_Error (Exc);



            raise;
      end;

      Self.Internal_Bare_Langkit_Root_Lf_State_Empty_Type_Ref_List_22 := Initialized;
      Self.Internal_Bare_Langkit_Root_Lf_Stg_Empty_Type_Ref_List_23 := Property_Result;


   return Property_Result;
end Langkit_Root_F_Empty_Type_Ref_List;
--# end

   







--# property-start 'LangkitRoot.[internal]internal_env_do_17' nodes.lkt:5311
pragma Warnings (Off, "is not referenced");

function Internal_Env_Do_17
  
  (Node : Bare_Langkit_Root
  )

   return Internal_Unit
is
   Self : Bare_Langkit_Root :=
     Bare_Langkit_Root (Node);
      --# bind node Self

   


   Property_Result : Internal_Unit;

      

      Fld : Internal_Unit;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 3384 LangkitRoot.fetch_prelude Fld nodes.lkt:5311







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Extensions.Langkit_Root_P_Fetch_Prelude (Node => Self);
--# expr-done 3384

         Property_Result := Fld;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Internal_Env_Do_17;
--# end

   







--# property-start 'LangkitRoot.[internal]internal_ref_env_nodes_18' nodes.lkt:5314
pragma Warnings (Off, "is not referenced");

function Internal_Ref_Env_Nodes_18
  
  (Node : Bare_Langkit_Root
  )

   return Bare_Lkt_Node_Array_Access
is
   Self : Bare_Langkit_Root :=
     Bare_Langkit_Root (Node);
      --# bind node Self

   


   Property_Result : Bare_Lkt_Node_Array_Access;

      
            procedure Finalizer_Scope_448 with Inline_Always;

      Cast_Result : Bare_Lkt_Node;
Array_Lit : Bare_Lkt_Node_Array_Access;

            procedure Finalizer_Scope_448 is
            begin
                     Dec_Ref (Array_Lit);
            end Finalizer_Scope_448;


begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 3386 ArrayLiteral Array_Lit nodes.lkt:5314
--# expr-start 3385 Cast Cast_Result nodes.lkt:5314









   
      Cast_Result := Self;


--# expr-done 3385
Array_Lit := Create_Bare_Lkt_Node_Array (Internal_Bare_Lkt_Node_Array'(1 => Cast_Result)); 
--# expr-done 3386

         Property_Result := Array_Lit;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_448;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_448;




            raise;
      end;



   return Property_Result;
end Internal_Ref_Env_Nodes_18;
--# end

   







--# property-start 'LangkitRoot.[internal]internal_ref_cond_19' nodes.lkt:5316
pragma Warnings (Off, "is not referenced");

function Internal_Ref_Cond_19
  
  (Node : Bare_Langkit_Root
  )

   return Boolean
is
   Self : Bare_Langkit_Root :=
     Bare_Langkit_Root (Node);
      --# bind node Self

   


   Property_Result : Boolean;

      

      Fld : Internal_Unit;
Fld_1 : Internal_Unit;
Is_Equal : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 3389 Eq Is_Equal nodes.lkt:5316
--# expr-start 3387 LktNode.unit Fld nodes.lkt:5316







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Liblktlang.Implementation.Unit (Node => Self);
--# expr-done 3387
--# expr-start 3388 LangkitRoot.fetch_prelude Fld_1 nodes.lkt:5316







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Liblktlang.Implementation.Extensions.Langkit_Root_P_Fetch_Prelude (Node => Self);
--# expr-done 3388
Is_Equal := Fld = Fld_1; 
--# expr-done 3389

         Property_Result := Is_Equal;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Internal_Ref_Cond_19;
--# end


   
function Langkit_Root_P_Internal_Env
  (E : Entity
  ) return Lexical_Env
is
   

begin
   
      if E.Node /= null
         and then E.Node.Kind not in Lkt_Langkit_Root_Range
      then
         Raise_Property_Exception
           (E.Node,
            Property_Error'Identity,
            "mismatching node type");
      end if;

   declare
      Result : constant Lexical_Env :=
         Langkit_Root_P_Internal_Env (E.Node);
   begin
         return Result;
   end;
end;


   


      

   --
   --  Primitives for Bare_Lexer_Case_Rule
   --

   



      
      procedure Initialize_Fields_For_Lexer_Case_Rule
        (Self : Bare_Lexer_Case_Rule
         ; Lexer_Case_Rule_F_Expr : Bare_Grammar_Expr
         ; Lexer_Case_Rule_F_Alts : Bare_Base_Lexer_Case_Rule_Alt_List
        ) is
      begin

            Self.Lexer_Case_Rule_F_Expr := Lexer_Case_Rule_F_Expr;
            Self.Lexer_Case_Rule_F_Alts := Lexer_Case_Rule_F_Alts;
         

      end Initialize_Fields_For_Lexer_Case_Rule;

      
   function Lexer_Case_Rule_F_Expr
     (Node : Bare_Lexer_Case_Rule) return Bare_Grammar_Expr
   is
      

   begin
         
         return Node.Lexer_Case_Rule_F_Expr;
      
   end;

      
   function Lexer_Case_Rule_F_Alts
     (Node : Bare_Lexer_Case_Rule) return Bare_Base_Lexer_Case_Rule_Alt_List
   is
      

   begin
         
         return Node.Lexer_Case_Rule_F_Alts;
      
   end;




   


      

   --
   --  Primitives for Bare_Lexer_Case_Rule_Send
   --

   



      
      procedure Initialize_Fields_For_Lexer_Case_Rule_Send
        (Self : Bare_Lexer_Case_Rule_Send
         ; Lexer_Case_Rule_Send_F_Sent : Bare_Ref_Id
         ; Lexer_Case_Rule_Send_F_Match_Size : Bare_Num_Lit
        ) is
      begin

            Self.Lexer_Case_Rule_Send_F_Sent := Lexer_Case_Rule_Send_F_Sent;
            Self.Lexer_Case_Rule_Send_F_Match_Size := Lexer_Case_Rule_Send_F_Match_Size;
         

      end Initialize_Fields_For_Lexer_Case_Rule_Send;

      
   function Lexer_Case_Rule_Send_F_Sent
     (Node : Bare_Lexer_Case_Rule_Send) return Bare_Ref_Id
   is
      

   begin
         
         return Node.Lexer_Case_Rule_Send_F_Sent;
      
   end;

      
   function Lexer_Case_Rule_Send_F_Match_Size
     (Node : Bare_Lexer_Case_Rule_Send) return Bare_Num_Lit
   is
      

   begin
         
         return Node.Lexer_Case_Rule_Send_F_Match_Size;
      
   end;




   


      

   --
   --  Primitives for Bare_List_Kind
   --

   







   


      

   --
   --  Primitives for Bare_List_Kind_One
   --

   







   


      

   --
   --  Primitives for Bare_List_Kind_Zero
   --

   







   


      

   --
   --  Primitives for Bare_Lkt_Node_Base_List
   --

   







   


      

   --
   --  Primitives for Bare_Argument_List
   --

   







   


      

   --
   --  Primitives for Bare_Base_Lexer_Case_Rule_Alt_List
   --

   







   


      

   --
   --  Primitives for Bare_Base_Match_Branch_List
   --

   







   


      

   --
   --  Primitives for Bare_Block_String_Line_List
   --

   







   


      

   --
   --  Primitives for Bare_Call_Expr_List
   --

   







   


      

   --
   --  Primitives for Bare_Decl_Annotation_List
   --

   







   


      

   --
   --  Primitives for Bare_Elsif_Branch_List
   --

   







   


      

   --
   --  Primitives for Bare_Enum_Class_Alt_Decl_List
   --

   







   


      

   --
   --  Primitives for Bare_Enum_Class_Case_List
   --

   







   


      

   --
   --  Primitives for Bare_Enum_Lit_Decl_List
   --

   







   


      

   --
   --  Primitives for Bare_Expr_List
   --

   







   


      

   --
   --  Primitives for Bare_Any_Of_List
   --

   







   


      

   --
   --  Primitives for Bare_Full_Decl_List
   --

   







   


      

   --
   --  Primitives for Bare_Decl_Block
   --

   



   

   

   

   

   

   

   


      procedure Decl_Block_Pre_Env_Actions
        (Self            : Bare_Decl_Block;
         State           : in out PLE_Node_State;
         Add_To_Env_Only : Boolean := False) is
      begin
            


   
      if Add_To_Env_Only then
         return;
      end if;

      declare
         No_Parent         : constant Boolean :=
            False;
         Transitive_Parent : constant Boolean :=
            False;
         Names             : Symbol_Type_Array_Access :=
            null;
      begin
         Add_Env (Self, State, No_Parent, Transitive_Parent, Names);
      end;
   
   
      end;







   


      

   --
   --  Primitives for Bare_Generic_Param_Decl_List
   --

   







   


      

   --
   --  Primitives for Bare_Fun_Param_Decl_List
   --

   







   


      

   --
   --  Primitives for Bare_Grammar_Expr_List
   --

   







   


      

   --
   --  Primitives for Bare_Grammar_Expr_List_List
   --

   







   


      

   --
   --  Primitives for Bare_Import_List
   --

   







   


      

   --
   --  Primitives for Bare_Lambda_Param_Decl_List
   --

   







   


      

   --
   --  Primitives for Bare_Lkt_Node_List
   --

   







   


      

   --
   --  Primitives for Bare_Module_Doc_String_Line_List
   --

   







   


      

   --
   --  Primitives for Bare_Pattern_Detail_List
   --

   







   


      

   --
   --  Primitives for Bare_Pattern_List
   --

   







   


      

   --
   --  Primitives for Bare_Ref_Id_List
   --

   







   


      

   --
   --  Primitives for Bare_Type_Ref_List
   --

   







   


      

   --
   --  Primitives for Bare_Synthetic_Type_Ref_List
   --

   







   


      

   --
   --  Primitives for Bare_Module_Doc_String_Line
   --

   







   


      

   --
   --  Primitives for Bare_Null_Cond_Qualifier
   --

   





   







--# property-start '[dispatcher]NullCondQualifier.as_bool' dispatcher
pragma Warnings (Off, "is not referenced");

function Dispatcher_Null_Cond_Qualifier_P_As_Bool
  
  (Node : Bare_Null_Cond_Qualifier
  )

   return Boolean
is
   Self : Bare_Null_Cond_Qualifier :=
     Bare_Null_Cond_Qualifier (Node);
      --# bind node Self

   


   Property_Result : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      if Self = null then
         Raise_Property_Exception
           (Self, Property_Error'Identity, "dispatching on null node");
      end if;

      case Lkt_Null_Cond_Qualifier (Self.Kind) is
               when Lkt_Null_Cond_Qualifier_Absent =>
                  --# property-call-start NullCondQualifier.Absent.as_bool
                  Property_Result := Null_Cond_Qualifier_Absent_P_As_Bool
                    (Self
                    );
                  --# end
               when Lkt_Null_Cond_Qualifier_Present =>
                  --# property-call-start NullCondQualifier.Present.as_bool
                  Property_Result := Null_Cond_Qualifier_Present_P_As_Bool
                    (Self
                    );
                  --# end
      end case;




   return Property_Result;
end Dispatcher_Null_Cond_Qualifier_P_As_Bool;
--# end



   


      

   --
   --  Primitives for Bare_Null_Cond_Qualifier_Absent
   --

   





   







--# property-start NullCondQualifier.Absent.as_bool nodes.lkt:397
pragma Warnings (Off, "is not referenced");

function Null_Cond_Qualifier_Absent_P_As_Bool
  
  (Node : Bare_Null_Cond_Qualifier_Absent
  )

   return Boolean
is
   Self : Bare_Null_Cond_Qualifier_Absent :=
     Bare_Null_Cond_Qualifier_Absent (Node);
      --# bind node Self

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := False;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Null_Cond_Qualifier_Absent_P_As_Bool;
--# end



   


      

   --
   --  Primitives for Bare_Null_Cond_Qualifier_Present
   --

   





   







--# property-start NullCondQualifier.Present.as_bool nodes.lkt:397
pragma Warnings (Off, "is not referenced");

function Null_Cond_Qualifier_Present_P_As_Bool
  
  (Node : Bare_Null_Cond_Qualifier_Present
  )

   return Boolean
is
   Self : Bare_Null_Cond_Qualifier_Present :=
     Bare_Null_Cond_Qualifier_Present (Node);
      --# bind node Self

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := True;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Null_Cond_Qualifier_Present_P_As_Bool;
--# end



   


      

   --
   --  Primitives for Bare_Op
   --

   





   







--# property-start Op.is_equation_op nodes.lkt:5444
pragma Warnings (Off, "is not referenced");

function Op_P_Is_Equation_Op
  
  (Node : Bare_Op
  )

   return Boolean
is
   Self : Bare_Op :=
     Bare_Op (Node);
      --# bind node Self

   


   Property_Result : Boolean;

      

      Is_A : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 3390 IsA Is_A nodes.lkt:5444

Is_A := Self /= null 
and then Self.Kind in Lkt_Op_Logic_And_Range | Lkt_Op_Logic_Or_Range; 
--# expr-done 3390

         Property_Result := Is_A;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Op_P_Is_Equation_Op;
--# end

   







--# property-start Op.is_bool_op nodes.lkt:5446
pragma Warnings (Off, "is not referenced");

function Op_P_Is_Bool_Op
  
  (Node : Bare_Op
  )

   return Boolean
is
   Self : Bare_Op :=
     Bare_Op (Node);
      --# bind node Self

   


   Property_Result : Boolean;

      

      Is_A : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 3391 IsA Is_A nodes.lkt:5446

Is_A := Self /= null 
and then Self.Kind in Lkt_Op_And_Range | Lkt_Op_Or_Range; 
--# expr-done 3391

         Property_Result := Is_A;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Op_P_Is_Bool_Op;
--# end

   







--# property-start Op.is_arith_op nodes.lkt:5448
pragma Warnings (Off, "is not referenced");

function Op_P_Is_Arith_Op
  
  (Node : Bare_Op
  )

   return Boolean
is
   Self : Bare_Op :=
     Bare_Op (Node);
      --# bind node Self

   


   Property_Result : Boolean;

      

      Is_A : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 3392 IsA Is_A nodes.lkt:5448

Is_A := Self /= null 
and then Self.Kind in Lkt_Op_Plus_Range | Lkt_Op_Minus_Range | Lkt_Op_Mult_Range | Lkt_Op_Div_Range; 
--# expr-done 3392

         Property_Result := Is_A;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Op_P_Is_Arith_Op;
--# end

   







--# property-start Op.is_order_op nodes.lkt:5450
pragma Warnings (Off, "is not referenced");

function Op_P_Is_Order_Op
  
  (Node : Bare_Op
  )

   return Boolean
is
   Self : Bare_Op :=
     Bare_Op (Node);
      --# bind node Self

   


   Property_Result : Boolean;

      

      Is_A : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 3393 IsA Is_A nodes.lkt:5450

Is_A := Self /= null 
and then Self.Kind in Lkt_Op_Lt_Range | Lkt_Op_Lte_Range | Lkt_Op_Gt_Range | Lkt_Op_Gte_Range; 
--# expr-done 3393

         Property_Result := Is_A;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Op_P_Is_Order_Op;
--# end



   


      

   --
   --  Primitives for Bare_Op_Amp
   --

   







   


      

   --
   --  Primitives for Bare_Op_And
   --

   







   


      

   --
   --  Primitives for Bare_Op_Div
   --

   







   


      

   --
   --  Primitives for Bare_Op_Eq
   --

   







   


      

   --
   --  Primitives for Bare_Op_Gt
   --

   







   


      

   --
   --  Primitives for Bare_Op_Gte
   --

   







   


      

   --
   --  Primitives for Bare_Op_Logic_And
   --

   







   


      

   --
   --  Primitives for Bare_Op_Logic_Or
   --

   







   


      

   --
   --  Primitives for Bare_Op_Lt
   --

   







   


      

   --
   --  Primitives for Bare_Op_Lte
   --

   







   


      

   --
   --  Primitives for Bare_Op_Minus
   --

   







   


      

   --
   --  Primitives for Bare_Op_Mult
   --

   







   


      

   --
   --  Primitives for Bare_Op_Ne
   --

   







   


      

   --
   --  Primitives for Bare_Op_Or
   --

   







   


      

   --
   --  Primitives for Bare_Op_Or_Int
   --

   







   


      

   --
   --  Primitives for Bare_Op_Plus
   --

   







   


      

   --
   --  Primitives for Bare_Op_Stream_Concat
   --

   







   


      

   --
   --  Primitives for Bare_Op_Stream_Cons
   --

   







   


      

   --
   --  Primitives for Bare_Pattern
   --

   







   


      

   --
   --  Primitives for Bare_Any_Type_Pattern
   --

   







   


      

   --
   --  Primitives for Bare_Binding_Pattern
   --

   



      
      procedure Initialize_Fields_For_Binding_Pattern
        (Self : Bare_Binding_Pattern
         ; Binding_Pattern_F_Decl : Bare_Binding_Val_Decl
         ; Binding_Pattern_F_Sub_Pattern : Bare_Pattern
        ) is
      begin

            Self.Binding_Pattern_F_Decl := Binding_Pattern_F_Decl;
            Self.Binding_Pattern_F_Sub_Pattern := Binding_Pattern_F_Sub_Pattern;
         

      end Initialize_Fields_For_Binding_Pattern;

      
   function Binding_Pattern_F_Decl
     (Node : Bare_Binding_Pattern) return Bare_Binding_Val_Decl
   is
      

   begin
         
         return Node.Binding_Pattern_F_Decl;
      
   end;

      
   function Binding_Pattern_F_Sub_Pattern
     (Node : Bare_Binding_Pattern) return Bare_Pattern
   is
      

   begin
         
         return Node.Binding_Pattern_F_Sub_Pattern;
      
   end;




   


      

   --
   --  Primitives for Bare_Bool_Pattern
   --

   







   


      

   --
   --  Primitives for Bare_Bool_Pattern_False
   --

   







   


      

   --
   --  Primitives for Bare_Bool_Pattern_True
   --

   







   


      

   --
   --  Primitives for Bare_Ellipsis_Pattern
   --

   



      
      procedure Initialize_Fields_For_Ellipsis_Pattern
        (Self : Bare_Ellipsis_Pattern
         ; Ellipsis_Pattern_F_Binding : Bare_Id
        ) is
      begin

            Self.Ellipsis_Pattern_F_Binding := Ellipsis_Pattern_F_Binding;
         

      end Initialize_Fields_For_Ellipsis_Pattern;

      
   function Ellipsis_Pattern_F_Binding
     (Node : Bare_Ellipsis_Pattern) return Bare_Id
   is
      

   begin
         
         return Node.Ellipsis_Pattern_F_Binding;
      
   end;




   


      

   --
   --  Primitives for Bare_Extended_Pattern
   --

   



      
      procedure Initialize_Fields_For_Extended_Pattern
        (Self : Bare_Extended_Pattern
         ; Extended_Pattern_F_Sub_Pattern : Bare_Pattern
         ; Extended_Pattern_F_Details : Bare_Pattern_Detail_List
        ) is
      begin

            Self.Extended_Pattern_F_Sub_Pattern := Extended_Pattern_F_Sub_Pattern;
            Self.Extended_Pattern_F_Details := Extended_Pattern_F_Details;
         

      end Initialize_Fields_For_Extended_Pattern;

      
   function Extended_Pattern_F_Sub_Pattern
     (Node : Bare_Extended_Pattern) return Bare_Pattern
   is
      

   begin
         
         return Node.Extended_Pattern_F_Sub_Pattern;
      
   end;

      
   function Extended_Pattern_F_Details
     (Node : Bare_Extended_Pattern) return Bare_Pattern_Detail_List
   is
      

   begin
         
         return Node.Extended_Pattern_F_Details;
      
   end;




   


      

   --
   --  Primitives for Bare_Filtered_Pattern
   --

   



      
      procedure Initialize_Fields_For_Filtered_Pattern
        (Self : Bare_Filtered_Pattern
         ; Filtered_Pattern_F_Sub_Pattern : Bare_Pattern
         ; Filtered_Pattern_F_Predicate : Bare_Expr
        ) is
      begin

            Self.Filtered_Pattern_F_Sub_Pattern := Filtered_Pattern_F_Sub_Pattern;
            Self.Filtered_Pattern_F_Predicate := Filtered_Pattern_F_Predicate;
         

      end Initialize_Fields_For_Filtered_Pattern;

      
   function Filtered_Pattern_F_Sub_Pattern
     (Node : Bare_Filtered_Pattern) return Bare_Pattern
   is
      

   begin
         
         return Node.Filtered_Pattern_F_Sub_Pattern;
      
   end;

      
   function Filtered_Pattern_F_Predicate
     (Node : Bare_Filtered_Pattern) return Bare_Expr
   is
      

   begin
         
         return Node.Filtered_Pattern_F_Predicate;
      
   end;




   


      

   --
   --  Primitives for Bare_Integer_Pattern
   --

   







   


      

   --
   --  Primitives for Bare_List_Pattern
   --

   



      
      procedure Initialize_Fields_For_List_Pattern
        (Self : Bare_List_Pattern
         ; List_Pattern_F_Sub_Patterns : Bare_Pattern_List
        ) is
      begin

            Self.List_Pattern_F_Sub_Patterns := List_Pattern_F_Sub_Patterns;
         

      end Initialize_Fields_For_List_Pattern;

      
   function List_Pattern_F_Sub_Patterns
     (Node : Bare_List_Pattern) return Bare_Pattern_List
   is
      

   begin
         
         return Node.List_Pattern_F_Sub_Patterns;
      
   end;




   


      

   --
   --  Primitives for Bare_Not_Pattern
   --

   



      
      procedure Initialize_Fields_For_Not_Pattern
        (Self : Bare_Not_Pattern
         ; Not_Pattern_F_Sub_Pattern : Bare_Pattern
        ) is
      begin

            Self.Not_Pattern_F_Sub_Pattern := Not_Pattern_F_Sub_Pattern;
         

      end Initialize_Fields_For_Not_Pattern;

      
   function Not_Pattern_F_Sub_Pattern
     (Node : Bare_Not_Pattern) return Bare_Pattern
   is
      

   begin
         
         return Node.Not_Pattern_F_Sub_Pattern;
      
   end;




   


      

   --
   --  Primitives for Bare_Null_Pattern
   --

   







   


      

   --
   --  Primitives for Bare_Or_Pattern
   --

   



      
      procedure Initialize_Fields_For_Or_Pattern
        (Self : Bare_Or_Pattern
         ; Or_Pattern_F_Left_Sub_Pattern : Bare_Pattern
         ; Or_Pattern_F_Right_Sub_Pattern : Bare_Pattern
        ) is
      begin

            Self.Or_Pattern_F_Left_Sub_Pattern := Or_Pattern_F_Left_Sub_Pattern;
            Self.Or_Pattern_F_Right_Sub_Pattern := Or_Pattern_F_Right_Sub_Pattern;
         

      end Initialize_Fields_For_Or_Pattern;

      
   function Or_Pattern_F_Left_Sub_Pattern
     (Node : Bare_Or_Pattern) return Bare_Pattern
   is
      

   begin
         
         return Node.Or_Pattern_F_Left_Sub_Pattern;
      
   end;

      
   function Or_Pattern_F_Right_Sub_Pattern
     (Node : Bare_Or_Pattern) return Bare_Pattern
   is
      

   begin
         
         return Node.Or_Pattern_F_Right_Sub_Pattern;
      
   end;




   


      

   --
   --  Primitives for Bare_Paren_Pattern
   --

   



      
      procedure Initialize_Fields_For_Paren_Pattern
        (Self : Bare_Paren_Pattern
         ; Paren_Pattern_F_Sub_Pattern : Bare_Pattern
        ) is
      begin

            Self.Paren_Pattern_F_Sub_Pattern := Paren_Pattern_F_Sub_Pattern;
         

      end Initialize_Fields_For_Paren_Pattern;

      
   function Paren_Pattern_F_Sub_Pattern
     (Node : Bare_Paren_Pattern) return Bare_Pattern
   is
      

   begin
         
         return Node.Paren_Pattern_F_Sub_Pattern;
      
   end;




   


      

   --
   --  Primitives for Bare_Regex_Pattern
   --

   







   


      

   --
   --  Primitives for Bare_Tuple_Pattern
   --

   



      
      procedure Initialize_Fields_For_Tuple_Pattern
        (Self : Bare_Tuple_Pattern
         ; Tuple_Pattern_F_Sub_Patterns : Bare_Pattern_List
        ) is
      begin

            Self.Tuple_Pattern_F_Sub_Patterns := Tuple_Pattern_F_Sub_Patterns;
         

      end Initialize_Fields_For_Tuple_Pattern;

      
   function Tuple_Pattern_F_Sub_Patterns
     (Node : Bare_Tuple_Pattern) return Bare_Pattern_List
   is
      

   begin
         
         return Node.Tuple_Pattern_F_Sub_Patterns;
      
   end;




   


      

   --
   --  Primitives for Bare_Type_Pattern
   --

   



      
      procedure Initialize_Fields_For_Type_Pattern
        (Self : Bare_Type_Pattern
         ; Type_Pattern_F_Type_Name : Bare_Type_Ref
        ) is
      begin

            Self.Type_Pattern_F_Type_Name := Type_Pattern_F_Type_Name;
         

      end Initialize_Fields_For_Type_Pattern;

      
   function Type_Pattern_F_Type_Name
     (Node : Bare_Type_Pattern) return Bare_Type_Ref
   is
      

   begin
         
         return Node.Type_Pattern_F_Type_Name;
      
   end;




   


      

   --
   --  Primitives for Bare_Pattern_Detail
   --

   







   


      

   --
   --  Primitives for Bare_Field_Pattern_Detail
   --

   



      
      procedure Initialize_Fields_For_Field_Pattern_Detail
        (Self : Bare_Field_Pattern_Detail
         ; Field_Pattern_Detail_F_Id : Bare_Id
         ; Field_Pattern_Detail_F_Expected_Value : Bare_Pattern
        ) is
      begin

            Self.Field_Pattern_Detail_F_Id := Field_Pattern_Detail_F_Id;
            Self.Field_Pattern_Detail_F_Expected_Value := Field_Pattern_Detail_F_Expected_Value;
         

      end Initialize_Fields_For_Field_Pattern_Detail;

      
   function Field_Pattern_Detail_F_Id
     (Node : Bare_Field_Pattern_Detail) return Bare_Id
   is
      

   begin
         
         return Node.Field_Pattern_Detail_F_Id;
      
   end;

      
   function Field_Pattern_Detail_F_Expected_Value
     (Node : Bare_Field_Pattern_Detail) return Bare_Pattern
   is
      

   begin
         
         return Node.Field_Pattern_Detail_F_Expected_Value;
      
   end;




   


      

   --
   --  Primitives for Bare_Property_Pattern_Detail
   --

   



      
      procedure Initialize_Fields_For_Property_Pattern_Detail
        (Self : Bare_Property_Pattern_Detail
         ; Property_Pattern_Detail_F_Call : Bare_Expr
         ; Property_Pattern_Detail_F_Expected_Value : Bare_Pattern
        ) is
      begin

            Self.Property_Pattern_Detail_F_Call := Property_Pattern_Detail_F_Call;
            Self.Property_Pattern_Detail_F_Expected_Value := Property_Pattern_Detail_F_Expected_Value;
         

      end Initialize_Fields_For_Property_Pattern_Detail;

      
   function Property_Pattern_Detail_F_Call
     (Node : Bare_Property_Pattern_Detail) return Bare_Expr
   is
      

   begin
         
         return Node.Property_Pattern_Detail_F_Call;
      
   end;

      
   function Property_Pattern_Detail_F_Expected_Value
     (Node : Bare_Property_Pattern_Detail) return Bare_Pattern
   is
      

   begin
         
         return Node.Property_Pattern_Detail_F_Expected_Value;
      
   end;




   


      

   --
   --  Primitives for Bare_Selector_Pattern_Detail
   --

   



      
      procedure Initialize_Fields_For_Selector_Pattern_Detail
        (Self : Bare_Selector_Pattern_Detail
         ; Selector_Pattern_Detail_F_Call : Bare_Selector_Call
         ; Selector_Pattern_Detail_F_Sub_Pattern : Bare_Pattern
        ) is
      begin

            Self.Selector_Pattern_Detail_F_Call := Selector_Pattern_Detail_F_Call;
            Self.Selector_Pattern_Detail_F_Sub_Pattern := Selector_Pattern_Detail_F_Sub_Pattern;
         

      end Initialize_Fields_For_Selector_Pattern_Detail;

      
   function Selector_Pattern_Detail_F_Call
     (Node : Bare_Selector_Pattern_Detail) return Bare_Selector_Call
   is
      

   begin
         
         return Node.Selector_Pattern_Detail_F_Call;
      
   end;

      
   function Selector_Pattern_Detail_F_Sub_Pattern
     (Node : Bare_Selector_Pattern_Detail) return Bare_Pattern
   is
      

   begin
         
         return Node.Selector_Pattern_Detail_F_Sub_Pattern;
      
   end;




   


      

   --
   --  Primitives for Bare_Selector_Call
   --

   



      
      procedure Initialize_Fields_For_Selector_Call
        (Self : Bare_Selector_Call
         ; Selector_Call_F_Quantifier : Bare_Id
         ; Selector_Call_F_Binding : Bare_Id
         ; Selector_Call_F_Selector_Call : Bare_Expr
        ) is
      begin

            Self.Selector_Call_F_Quantifier := Selector_Call_F_Quantifier;
            Self.Selector_Call_F_Binding := Selector_Call_F_Binding;
            Self.Selector_Call_F_Selector_Call := Selector_Call_F_Selector_Call;
         

      end Initialize_Fields_For_Selector_Call;

      
   function Selector_Call_F_Quantifier
     (Node : Bare_Selector_Call) return Bare_Id
   is
      

   begin
         
         return Node.Selector_Call_F_Quantifier;
      
   end;

      
   function Selector_Call_F_Binding
     (Node : Bare_Selector_Call) return Bare_Id
   is
      

   begin
         
         return Node.Selector_Call_F_Binding;
      
   end;

      
   function Selector_Call_F_Selector_Call
     (Node : Bare_Selector_Call) return Bare_Expr
   is
      

   begin
         
         return Node.Selector_Call_F_Selector_Call;
      
   end;




   


      

   --
   --  Primitives for Bare_Type_Ref
   --

   



      
      procedure Initialize_Fields_For_Type_Ref
        (Self : Bare_Type_Ref
        ) is
      begin

         
      Self.Type_Ref_F_Type_Var := Null_Var_Record;

      end Initialize_Fields_For_Type_Ref;


   







--# property-start TypeRef.xref_entry_point nodes.lkt:5482
pragma Warnings (Off, "is not referenced");

function Type_Ref_P_Xref_Entry_Point
  
  (Node : Bare_Type_Ref
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Type_Ref :=
     Bare_Type_Ref (Node);
     Ent : Internal_Entity_Type_Ref :=
       Internal_Entity_Type_Ref'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      Fld : Bare_Lkt_Node;
Is_A : Boolean;
Fld_1 : Bare_Lkt_Node;
Fld_2 : Bare_Lkt_Node;
Is_A_1 : Boolean;
If_Result : Boolean;
Fld_3 : Bare_Lkt_Node;
Fld_4 : Bare_Lkt_Node;
Is_A_2 : Boolean;
If_Result_1 : Boolean;
Not_Val : Boolean;



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         --# expr-start 3404 Not Not_Val nodes.lkt:5483
--# expr-start 3403 BooleanOr If_Result_1 nodes.lkt:5484



--# expr-start 3399 BooleanOr If_Result nodes.lkt:5484



--# expr-start 3395 IsA Is_A nodes.lkt:5484
--# expr-start 3394 .parent Fld nodes.lkt:5484







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Self.Parent; 
--# expr-done 3394
Is_A := Fld /= null 
and then Fld.Kind in Lkt_Type_Ref; 
--# expr-done 3395
if Is_A then
   
   If_Result := True;
else
   --# expr-start 3398 IsA Is_A_1 nodes.lkt:5484
--# expr-start 3397 .parent Fld_2 nodes.lkt:5484



--# expr-start 3396 .parent Fld_1 nodes.lkt:5484







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_1 := Self.Parent; 
--# expr-done 3396



   if Fld_1 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Fld_1.Parent; 
--# expr-done 3397
Is_A_1 := Fld_2 /= null 
and then Fld_2.Kind in Lkt_Type_Ref; 
--# expr-done 3398
   If_Result := Is_A_1;
end if;



--# expr-done 3399
if If_Result then
   
   If_Result_1 := True;
else
   --# expr-start 3402 IsA Is_A_2 nodes.lkt:5485
--# expr-start 3401 .parent Fld_4 nodes.lkt:5485



--# expr-start 3400 .parent Fld_3 nodes.lkt:5485







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Self.Parent; 
--# expr-done 3400



   if Fld_3 = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Fld_3.Parent; 
--# expr-done 3401
Is_A_2 := Fld_4 /= null 
and then Fld_4.Kind in Lkt_Generic_Instantiation_Range; 
--# expr-done 3402
   If_Result_1 := Is_A_2;
end if;



--# expr-done 3403
Not_Val := not (If_Result_1); 
--# expr-done 3404

         Property_Result := Not_Val;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Type_Ref_P_Xref_Entry_Point;
--# end

   







--# property-start TypeRef.referenced_decl nodes.lkt:5492
pragma Warnings (Off, "is not referenced");

function Type_Ref_P_Referenced_Decl
  
  (Node : Bare_Type_Ref
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Internal_Entity_Type_Decl
is
   Self : Bare_Type_Ref :=
     Bare_Type_Ref (Node);
     Ent : Internal_Entity_Type_Ref :=
       Internal_Entity_Type_Ref'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Internal_Entity_Type_Decl;

      
            procedure Finalizer_Scope_220 with Inline_Always;

      Fld : Internal_Solver_Result := No_Solver_Result;
Fld_1 : Boolean;
Fld_2 : Logic_Var;
Is_Logic_Var_Defined : Boolean;
Eq_Solution : Internal_Entity;
If_Result : Internal_Entity;
Cast_Result : Internal_Entity_Type_Decl;
If_Result_1 : Internal_Entity_Type_Decl;

            procedure Finalizer_Scope_220 is
            begin
                     Dec_Ref (Fld);
            end Finalizer_Scope_220;

      
      Mmz_Handle : Memoization_Handle;
      Mmz_Val    : Mmz_Value;

      Mmz_Stored : Boolean;
      --  Whether the memoization couple was actually stored. Used to determine
      --  whether to inc-ref the memoized value.

      function Create_Mmz_Key return Mmz_Key;
      --  Create a memoization key for this property call and return it

      --------------------
      -- Create_Mmz_Key --
      --------------------

      function Create_Mmz_Key return Mmz_Key is
      begin
         return Mmz_K : Mmz_Key :=
           (Property => Mmz_Bare_Type_Ref_Type_Ref_P_Referenced_Decl,
            Items    => new Mmz_Key_Array (1 ..  2))
         do
            Mmz_K.Items (1) := (Kind => Mmz_Bare_Type_Ref,
                                As_Bare_Type_Ref => Self);
               Mmz_K.Items (2) :=
                 (Kind => Mmz_Internal_Entity_Info,
                  As_Internal_Entity_Info => E_Info);
         end return;
      end Create_Mmz_Key;

begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

            Populate_Lexical_Env_For_Unit (Self);
      end if;

      if Self /= null then

         if not Self.Unit.Context.In_Populate_Lexical_Env
            and then Find_Memoized_Value
                       (Self.Unit, Mmz_Handle, Mmz_Val, Create_Mmz_Key'Access)
         then
            --# memoization-lookup

            if Mmz_Val.Kind = Mmz_Evaluating then
               --# memoization-return
               Raise_Property_Exception
                 (Self,
                  Property_Error'Identity,
                  "Infinite recursion detected");

            elsif Mmz_Val.Kind = Mmz_Error then
               --# memoization-return
               Reraise_Memoized_Error (Mmz_Val);

            else
               Property_Result := Mmz_Val.As_Internal_Entity_Type_Decl;

               --# memoization-return
               return Property_Result;
            end if;
            --# end
         end if;
      end if;

      begin
         
   --# scope-start

         --# expr-start 3410 If If_Result_1 nodes.lkt:5493



--# expr-start 3406 SolverResult.success Fld_1 nodes.lkt:5493



--# expr-start 3405 LktNode.solve_enclosing_context Fld nodes.lkt:5493







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start LktNode.solve_enclosing_context
Fld := Liblktlang.Implementation.Lkt_Node_P_Solve_Enclosing_Context (Node => Ent.Node, E_Info => Ent.Info);
--# end
--# expr-done 3405





Fld_1 := Fld.Success;
--# expr-done 3406
if Fld_1 then
   --# expr-start 3409 Cast Cast_Result nodes.lkt:5494





--# expr-start 3408 .get_value If_Result nodes.lkt:5494



--# expr-start 3407 TypeRef.type_var Fld_2 nodes.lkt:5494







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Self.Type_Ref_F_Type_Var'Unrestricted_Access;
--# expr-done 3407
Is_Logic_Var_Defined := Entity_Vars.Is_Defined (Fld_2); 
if Is_Logic_Var_Defined then
   
Eq_Solution := Entity_Vars.Get_Value (Fld_2); 
   If_Result := Eq_Solution;
else
   
   If_Result := No_Entity;
end if;



--# expr-done 3408



   if If_Result.Node = null
      or else If_Result.Node.Kind in Lkt_Type_Decl
   then
      
      Cast_Result := Create_Internal_Entity_Type_Decl
        (Node => If_Result.Node,
         Info => If_Result.Info);

   else
         Raise_Property_Exception
           (Self, Property_Error'Identity, "invalid object cast");
   end if;


--# expr-done 3409
   If_Result_1 := Cast_Result;
else
   
   If_Result_1 := No_Entity_Type_Decl;
end if;



--# expr-done 3410

         Property_Result := If_Result_1;
         
   --# end
      Finalizer_Scope_220;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_220;


               if Self /= null
                  and then not Self.Unit.Context.In_Populate_Lexical_Env
               then
                     Add_Memoized_Error
                       (Self.Unit, Mmz_Handle, Exc, Mmz_Stored);
               end if;


            raise;
      end;

      if Self /= null
         and then not Self.Unit.Context.In_Populate_Lexical_Env
      then
         Mmz_Val := (Kind => Mmz_Internal_Entity_Type_Decl,
                     As_Internal_Entity_Type_Decl => Property_Result);
         Add_Memoized_Value (Self.Unit, Mmz_Handle, Mmz_Val, Mmz_Stored);
      end if;



   return Property_Result;
end Type_Ref_P_Referenced_Decl;
--# end



   


      

   --
   --  Primitives for Bare_Default_List_Type_Ref
   --

   



      
      procedure Initialize_Fields_For_Default_List_Type_Ref
        (Self : Bare_Default_List_Type_Ref
        ) is
      begin
            Initialize_Fields_For_Type_Ref
              (Self);

         

      end Initialize_Fields_For_Default_List_Type_Ref;




   


      

   --
   --  Primitives for Bare_Function_Type_Ref
   --

   



      
      procedure Initialize_Fields_For_Function_Type_Ref
        (Self : Bare_Function_Type_Ref
         ; Function_Type_Ref_F_Param_Types : Bare_Type_Ref_List
         ; Function_Type_Ref_F_Return_Type : Bare_Type_Ref
        ) is
      begin
            Initialize_Fields_For_Type_Ref
              (Self);

            Self.Function_Type_Ref_F_Param_Types := Function_Type_Ref_F_Param_Types;
            Self.Function_Type_Ref_F_Return_Type := Function_Type_Ref_F_Return_Type;
         

      end Initialize_Fields_For_Function_Type_Ref;

      
   function Function_Type_Ref_F_Param_Types
     (Node : Bare_Function_Type_Ref) return Bare_Type_Ref_List
   is
      

   begin
         
         return Node.Function_Type_Ref_F_Param_Types;
      
   end;

      
   function Function_Type_Ref_F_Return_Type
     (Node : Bare_Function_Type_Ref) return Bare_Type_Ref
   is
      

   begin
         
         return Node.Function_Type_Ref_F_Return_Type;
      
   end;


   







--# property-start FunctionTypeRef.xref_equation nodes.lkt:5509
pragma Warnings (Off, "is not referenced");

function Function_Type_Ref_P_Xref_Equation
  
  (Node : Bare_Function_Type_Ref
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Function_Type_Ref :=
     Bare_Function_Type_Ref (Node);
     Ent : Internal_Entity_Function_Type_Ref :=
       Internal_Entity_Function_Type_Ref'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_411 with Inline_Always;
            procedure Finalizer_Scope_854 with Inline_Always;

      Fld : Internal_Entity_Type_Ref_List;
Item : Internal_Entity_Type_Ref;
Fld_1 : Logic_Equation;
Fld_2 : Bare_Type_Ref_List;
Fld_3 : Internal_Entity_Info;
Bare_Item : Bare_Type_Ref;
As_Entity : Internal_Entity_Type_Ref;
Is_Null : Boolean;
If_Result : Internal_Entity_Type_Ref;
Map_Result : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;
Fld_4 : Internal_Entity_Type_Ref;
Fld_5 : Logic_Equation;
And_Pred : Logic_Equation;
Fld_6 : Logic_Var;
Fld_7 : Internal_Entity_Type_Ref;
Fld_8 : Logic_Var;
Array_Lit : Logic_Var_Array_Access;
Fld_9 : Internal_Entity_Type_Ref_List;
Item_1 : Internal_Entity_Type_Ref;
Fld_10 : Logic_Var;
Fld_11 : Bare_Type_Ref_List;
Fld_12 : Internal_Entity_Info;
Bare_Item_1 : Bare_Type_Ref;
As_Entity_1 : Internal_Entity_Type_Ref;
Is_Null_1 : Boolean;
If_Result_1 : Internal_Entity_Type_Ref;
Map_Result_1 : Logic_Var_Array_Access;
Concat_Result : Logic_Var_Array_Access;
Logic_Vars : Logic_Var_Array_Access;
Bind_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;

            procedure Finalizer_Scope_411 is
            begin
                     Dec_Ref (Map_Result);
                     Dec_Ref (Logic_Boolean_Op);
                     Dec_Ref (Fld_5);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (Concat_Result);
                     Dec_Ref (Logic_Vars);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred_1);
            end Finalizer_Scope_411;
            procedure Finalizer_Scope_854 is
            begin
                     Dec_Ref (Fld_1);
            end Finalizer_Scope_854;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3425 LogicAnd And_Pred_1 nodes.lkt:5510
--# expr-start 3416 LogicAnd And_Pred nodes.lkt:5511
--# expr-start 3413 .logic_all Logic_Boolean_Op nodes.lkt:5511








   

   --# expr-start 3411 FunctionTypeRef.param_types Fld nodes.lkt:5511







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Type_Ref_List (Node => Ent.Node.Function_Type_Ref_F_Param_Types, Info => Ent.Info);
--# expr-done 3411









Fld_2 := Fld.Node;

   
      declare
         Map_Result_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      if Fld_2 = null then
         
      Map_Result := Create_Logic_Equation_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Type_Ref_List := Fld_2;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Type_Ref;
else
   








Fld_3 := Fld.Info;

As_Entity := (Info => Fld_3, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind a Item

            
         
         
      --# expr-start 3412 LktNode.xref_equation Fld_1 nodes.lkt:5511







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 3412
      

         declare
            Item_To_Append : constant Logic_Equation := Fld_1;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_854;



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5511:30") else null)); 
--# expr-done 3413
--# expr-start 3415 LktNode.xref_equation Fld_5 nodes.lkt:5512



--# expr-start 3414 FunctionTypeRef.return_type Fld_4 nodes.lkt:5512







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Function_Type_Ref_F_Return_Type, Info => Ent.Info);
--# expr-done 3414



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_5 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld_4.Node, E_Info => Fld_4.Info);
--# end
--# expr-done 3415
And_Pred := Create_And (Logic_Boolean_Op, Fld_5, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5511:13") else null)); 
--# expr-done 3416
--# expr-start 3423 ArrayConcat Concat_Result nodes.lkt:5516
--# expr-start 3419 ArrayLiteral Array_Lit nodes.lkt:5516
--# expr-start 3418 TypeRef.type_var Fld_8 nodes.lkt:5516



--# expr-start 3417 FunctionTypeRef.return_type Fld_7 nodes.lkt:5516







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Create_Internal_Entity_Type_Ref (Node => Ent.Node.Function_Type_Ref_F_Return_Type, Info => Ent.Info);
--# expr-done 3417



   if Fld_7.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Fld_7.Node.Type_Ref_F_Type_Var'Unrestricted_Access;
--# expr-done 3418
Array_Lit := Create_Logic_Var_Array (Internal_Logic_Var_Array'(1 => Fld_8)); 
--# expr-done 3419
--# expr-start 3422 .map Map_Result_1 nodes.lkt:5517








   

   --# expr-start 3420 FunctionTypeRef.param_types Fld_9 nodes.lkt:5517







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Create_Internal_Entity_Type_Ref_List (Node => Ent.Node.Function_Type_Ref_F_Param_Types, Info => Ent.Info);
--# expr-done 3420









Fld_11 := Fld_9.Node;

   
      declare
         Map_Result_1_Vec : Logic_Var_Vectors.Vector;
      begin
   

   

      if Fld_11 = null then
         
      Map_Result_1 := Create_Logic_Var_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Type_Ref_List := Fld_11;
      begin
         for Untyped_Item_1 of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item_1 := Untyped_Item_1; 
                  



Is_Null_1 := Bare_Item_1 = null; 
if Is_Null_1 then
   
   If_Result_1 := No_Entity_Type_Ref;
else
   








Fld_12 := Fld_9.Info;

As_Entity_1 := (Info => Fld_12, Node => Bare_Item_1); 
   If_Result_1 := As_Entity_1;
end if;



                  Item_1 := If_Result_1; 

            
   --# scope-start


               --# bind tr Item_1

            
         
         
      --# expr-start 3421 TypeRef.type_var Fld_10 nodes.lkt:5517







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Item_1.Node.Type_Ref_F_Type_Var'Unrestricted_Access;
--# expr-done 3421
      

         declare
            Item_To_Append : constant Logic_Var := Fld_10;
         begin
            Logic_Var_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result_1 := Create_Logic_Var_Array
           (Items_Count => Natural (Logic_Var_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Logic_Var_Vectors.Get
              (Map_Result_1_Vec,
               I + Logic_Var_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Logic_Var_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 3422
Concat_Result := Concat (Array_Lit, Map_Result_1); 
--# expr-done 3423
for Var of Concat_Result.Items loop
   Var.Value := No_Entity;
   Entity_Vars.Reset (Var);
end loop;
Logic_Vars := Concat_Result; Inc_Ref (Logic_Vars);
--# expr-start 3424 TypeRef.type_var Fld_6 nodes.lkt:5514







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Ent.Node.Type_Ref_F_Type_Var'Unrestricted_Access;
--# expr-done 3424
Fld_6.Value := No_Entity;
Entity_Vars.Reset (Fld_6);


Bind_Result := Solver.Create_N_Propagate (Fld_6, Create_Type_Decl_P_Create_Function_Type_0_Functor (Logic_Vars.N), Entity_Vars.Logic_Var_Array (Logic_Vars.Items)); 
And_Pred_1 := Create_And (And_Pred, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5510:9") else null)); 
--# expr-done 3425

         Property_Result := And_Pred_1;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_411;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_411;
                     Finalizer_Scope_854;




            raise;
      end;



   return Property_Result;
end Function_Type_Ref_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Generic_Type_Ref
   --

   



      
      procedure Initialize_Fields_For_Generic_Type_Ref
        (Self : Bare_Generic_Type_Ref
         ; Generic_Type_Ref_F_Type_Name : Bare_Expr
         ; Generic_Type_Ref_F_Args : Bare_Type_Ref_List
        ) is
      begin
            Initialize_Fields_For_Type_Ref
              (Self);

            Self.Generic_Type_Ref_F_Type_Name := Generic_Type_Ref_F_Type_Name;
            Self.Generic_Type_Ref_F_Args := Generic_Type_Ref_F_Args;
         

      end Initialize_Fields_For_Generic_Type_Ref;

      
   function Generic_Type_Ref_F_Type_Name
     (Node : Bare_Generic_Type_Ref) return Bare_Expr
   is
      

   begin
         
         return Node.Generic_Type_Ref_F_Type_Name;
      
   end;

      
   function Generic_Type_Ref_F_Args
     (Node : Bare_Generic_Type_Ref) return Bare_Type_Ref_List
   is
      

   begin
         
         return Node.Generic_Type_Ref_F_Args;
      
   end;


   







--# property-start GenericTypeRef.xref_equation nodes.lkt:5528
pragma Warnings (Off, "is not referenced");

function Generic_Type_Ref_P_Xref_Equation
  
  (Node : Bare_Generic_Type_Ref
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Generic_Type_Ref :=
     Bare_Generic_Type_Ref (Node);
     Ent : Internal_Entity_Generic_Type_Ref :=
       Internal_Entity_Generic_Type_Ref'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_412 with Inline_Always;
            procedure Finalizer_Scope_856 with Inline_Always;
            procedure Finalizer_Scope_857 with Inline_Always;
            procedure Finalizer_Scope_859 with Inline_Always;
            procedure Finalizer_Scope_860 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Internal_Entity_Type_Ref_List;
Item : Internal_Entity_Type_Ref;
Fld_3 : Logic_Equation;
Fld_4 : Bare_Type_Ref_List;
Fld_5 : Internal_Entity_Info;
Bare_Item : Bare_Type_Ref;
As_Entity : Internal_Entity_Type_Ref;
Is_Null : Boolean;
If_Result : Internal_Entity_Type_Ref;
Map_Result : Logic_Equation_Array_Access;
Logic_Boolean_Op : Logic_Equation;
And_Pred : Logic_Equation;
Fld_6 : Internal_Entity_Expr;
Fld_7 : Internal_Entity_Ref_Id;
Var_Expr : Internal_Entity_Ref_Id;
Fld_8 : Logic_Var;
Fld_9 : Logic_Var;
Array_Lit : Logic_Var_Array_Access;
Fld_10 : Internal_Entity_Type_Ref_List;
Item_1 : Internal_Entity_Type_Ref;
Fld_11 : Logic_Var;
Fld_12 : Bare_Type_Ref_List;
Fld_13 : Internal_Entity_Info;
Bare_Item_1 : Bare_Type_Ref;
As_Entity_1 : Internal_Entity_Type_Ref;
Is_Null_1 : Boolean;
If_Result_1 : Internal_Entity_Type_Ref;
Map_Result_1 : Logic_Var_Array_Access;
Concat_Result : Logic_Var_Array_Access;
Logic_Vars : Logic_Var_Array_Access;
Bind_Result : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_14 : Bare_Ref_Id;
Fld_15 : Logic_Var;
Pred : Logic_Equation;
Cast_Result : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;
Error_Location_1 : Bare_Lkt_Node;
Fld_16 : Bare_Type_Ref_List;
Fld_17 : Logic_Var;
Fld_18 : Internal_Entity_Type_Ref_List;
Fld_19 : Bare_Type_Ref_List;
Len : Integer;
Pred_1 : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result_1 : Logic_Equation;
Scope_Result_1 : Logic_Equation;
And_Pred_2 : Logic_Equation;
Scope_Result_2 : Logic_Equation;
False_Rel : Logic_Equation;
Result_Var : Logic_Equation;
And_Pred_3 : Logic_Equation;

            procedure Finalizer_Scope_412 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Map_Result);
                     Dec_Ref (Logic_Boolean_Op);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Scope_Result_2);
                     Dec_Ref (False_Rel);
                     Dec_Ref (Result_Var);
                     Dec_Ref (And_Pred_3);
            end Finalizer_Scope_412;
            procedure Finalizer_Scope_856 is
            begin
                     Dec_Ref (Fld_3);
            end Finalizer_Scope_856;
            procedure Finalizer_Scope_857 is
            begin
                     Dec_Ref (Array_Lit);
                     Dec_Ref (Map_Result_1);
                     Dec_Ref (Concat_Result);
                     Dec_Ref (Logic_Vars);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (And_Pred_2);
            end Finalizer_Scope_857;
            procedure Finalizer_Scope_859 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_859;
            procedure Finalizer_Scope_860 is
            begin
                     Dec_Ref (Pred_1);
                     Dec_Ref (Dyn_Var_Bind_Result_1);
            end Finalizer_Scope_860;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3455 LogicAnd And_Pred_3 nodes.lkt:5529
--# expr-start 3431 LogicAnd And_Pred nodes.lkt:5530
--# expr-start 3427 Expr.xtype_equation Fld_1 nodes.lkt:5530



--# expr-start 3426 GenericTypeRef.type_name Fld nodes.lkt:5530







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Generic_Type_Ref_F_Type_Name, Info => Ent.Info);
--# expr-done 3426



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.xtype_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Xtype_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 3427
--# expr-start 3430 .logic_all Logic_Boolean_Op nodes.lkt:5531








   

   --# expr-start 3428 GenericTypeRef.args Fld_2 nodes.lkt:5531







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Type_Ref_List (Node => Ent.Node.Generic_Type_Ref_F_Args, Info => Ent.Info);
--# expr-done 3428









Fld_4 := Fld_2.Node;

   
      declare
         Map_Result_Vec : Logic_Equation_Vectors.Vector;
      begin
   

   

      if Fld_4 = null then
         
      Map_Result := Create_Logic_Equation_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Type_Ref_List := Fld_4;
      begin
         for Untyped_Item of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item := Untyped_Item; 
                  



Is_Null := Bare_Item = null; 
if Is_Null then
   
   If_Result := No_Entity_Type_Ref;
else
   








Fld_5 := Fld_2.Info;

As_Entity := (Info => Fld_5, Node => Bare_Item); 
   If_Result := As_Entity;
end if;



                  Item := If_Result; 

            
   --# scope-start


               --# bind p Item

            
         
         
      --# expr-start 3429 LktNode.xref_equation Fld_3 nodes.lkt:5531







   if Item.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_3 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Item.Node, E_Info => Item.Info);
--# end
--# expr-done 3429
      

         declare
            Item_To_Append : constant Logic_Equation := Fld_3;
         begin
               Inc_Ref (Item_To_Append);
            Logic_Equation_Vectors.Append (Map_Result_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end
      Finalizer_Scope_856;



         end loop;
      end;
   
      end if;

   

         Map_Result := Create_Logic_Equation_Array
           (Items_Count => Natural (Logic_Equation_Vectors.Length (Map_Result_Vec)));
         for I in Map_Result.Items'Range loop
            Map_Result.Items (I) := Logic_Equation_Vectors.Get
              (Map_Result_Vec,
               I + Logic_Equation_Vectors.Index_Type'First - Map_Result.Items'First);
         end loop;
         Logic_Equation_Vectors.Destroy (Map_Result_Vec);

      end;
   



Logic_Boolean_Op := Solver.Create_All (Relation_Array (Map_Result.Items), (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5531:28") else null)); 
--# expr-done 3430
And_Pred := Create_And (Fld_1, Logic_Boolean_Op, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5530:13") else null)); 
--# expr-done 3431
--# expr-start 3454 .do Result_Var nodes.lkt:5533



--# expr-start 3433 Expr.get_rightmost_refid Fld_7 nodes.lkt:5533



--# expr-start 3432 GenericTypeRef.type_name Fld_6 nodes.lkt:5533







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Expr (Node => Ent.Node.Generic_Type_Ref_F_Type_Name, Info => Ent.Info);
--# expr-done 3432



   if Fld_6.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start Expr.get_rightmost_refid
Fld_7 := Liblktlang.Implementation.Expr_P_Get_Rightmost_Refid (Node => Fld_6.Node, E_Info => Fld_6.Info);
--# end
--# expr-done 3433
Var_Expr := Fld_7;





if Var_Expr /= No_Entity_Ref_Id then
   



   --# scope-start



--# expr-start 3452 LogicAnd And_Pred_2 nodes.lkt:5535
--# expr-start 3445 LogicAnd And_Pred_1 nodes.lkt:5536
--# expr-start 3439 ArrayConcat Concat_Result nodes.lkt:5538
--# expr-start 3435 ArrayLiteral Array_Lit nodes.lkt:5538
--# expr-start 3434 RefId.ref_var Fld_9 nodes.lkt:5538







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Var_Expr.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 3434
Array_Lit := Create_Logic_Var_Array (Internal_Logic_Var_Array'(1 => Fld_9)); 
--# expr-done 3435
--# expr-start 3438 .map Map_Result_1 nodes.lkt:5538








   

   --# expr-start 3436 GenericTypeRef.args Fld_10 nodes.lkt:5538







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Create_Internal_Entity_Type_Ref_List (Node => Ent.Node.Generic_Type_Ref_F_Args, Info => Ent.Info);
--# expr-done 3436









Fld_12 := Fld_10.Node;

   
      declare
         Map_Result_1_Vec : Logic_Var_Vectors.Vector;
      begin
   

   

      if Fld_12 = null then
         
      Map_Result_1 := Create_Logic_Var_Array (0);
   
      else
         

      declare
         
         Collection : constant Bare_Type_Ref_List := Fld_12;
      begin
         for Untyped_Item_1 of
               Collection.Nodes (1 .. Children_Count (Collection))
         loop
                  
                  Bare_Item_1 := Untyped_Item_1; 
                  



Is_Null_1 := Bare_Item_1 = null; 
if Is_Null_1 then
   
   If_Result_1 := No_Entity_Type_Ref;
else
   








Fld_13 := Fld_10.Info;

As_Entity_1 := (Info => Fld_13, Node => Bare_Item_1); 
   If_Result_1 := As_Entity_1;
end if;



                  Item_1 := If_Result_1; 

            
   --# scope-start


               --# bind p Item_1

            
         
         
      --# expr-start 3437 TypeRef.type_var Fld_11 nodes.lkt:5538







   if Item_1.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Item_1.Node.Type_Ref_F_Type_Var'Unrestricted_Access;
--# expr-done 3437
      

         declare
            Item_To_Append : constant Logic_Var := Fld_11;
         begin
            Logic_Var_Vectors.Append (Map_Result_1_Vec, Item_To_Append);
         end;
   
   
   

            
   --# end



         end loop;
      end;
   
      end if;

   

         Map_Result_1 := Create_Logic_Var_Array
           (Items_Count => Natural (Logic_Var_Vectors.Length (Map_Result_1_Vec)));
         for I in Map_Result_1.Items'Range loop
            Map_Result_1.Items (I) := Logic_Var_Vectors.Get
              (Map_Result_1_Vec,
               I + Logic_Var_Vectors.Index_Type'First - Map_Result_1.Items'First);
         end loop;
         Logic_Var_Vectors.Destroy (Map_Result_1_Vec);

      end;
   



--# expr-done 3438
Concat_Result := Concat (Array_Lit, Map_Result_1); 
--# expr-done 3439
for Var of Concat_Result.Items loop
   Var.Value := No_Entity;
   Entity_Vars.Reset (Var);
end loop;
Logic_Vars := Concat_Result; Inc_Ref (Logic_Vars);
--# expr-start 3440 TypeRef.type_var Fld_8 nodes.lkt:5536







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Ent.Node.Type_Ref_F_Type_Var'Unrestricted_Access;
--# expr-done 3440
Fld_8.Value := No_Entity;
Entity_Vars.Reset (Fld_8);


Bind_Result := Solver.Create_N_Propagate (Fld_8, Create_Decl_P_Instantiate_Generic_Decl_0_Functor (Logic_Vars.N), Entity_Vars.Logic_Var_Array (Logic_Vars.Items)); 




   --# scope-start



--# expr-start 3444 bind Dyn_Var_Bind_Result nodes.lkt:5541





--# expr-start 3441 'Entity[RefId].node' Fld_14 nodes.lkt:5541









Fld_14 := Var_Expr.Node;
--# expr-done 3441



   
      Cast_Result := Fld_14;


Error_Location := Cast_Result; 
--# expr-start 3443 LogicPropagate Pred nodes.lkt:5542
--# expr-start 3442 RefId.ref_var Fld_15 nodes.lkt:5542







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_15 := Var_Expr.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 3442
Fld_15.Value := No_Entity;
Entity_Vars.Reset (Fld_15);

Pred := Solver.Create_Predicate (Fld_15, Create_Decl_P_Is_Generic_0_Predicate (Error_Location)); 
--# expr-done 3443
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 3444
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_859;


And_Pred_1 := Create_And (Bind_Result, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5536:17") else null)); 
--# expr-done 3445




   --# scope-start



--# expr-start 3451 bind Dyn_Var_Bind_Result_1 nodes.lkt:5546





--# expr-start 3446 GenericTypeRef.args Fld_16 nodes.lkt:5546







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_16 := Self.Generic_Type_Ref_F_Args;
--# expr-done 3446



   
      Cast_Result_1 := Fld_16;


Error_Location_1 := Cast_Result_1; 
--# expr-start 3450 LogicPropagate Pred_1 nodes.lkt:5547
--# expr-start 3447 RefId.ref_var Fld_17 nodes.lkt:5548







   if Var_Expr.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_17 := Var_Expr.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 3447
Fld_17.Value := No_Entity;
Entity_Vars.Reset (Fld_17);
--# expr-start 3449 .length Len nodes.lkt:5549



--# expr-start 3448 GenericTypeRef.args Fld_18 nodes.lkt:5549







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_18 := Create_Internal_Entity_Type_Ref_List (Node => Ent.Node.Generic_Type_Ref_F_Args, Info => Ent.Info);
--# expr-done 3448





Fld_19 := Fld_18.Node; 
Len := Length (Fld_19); 
--# expr-done 3449

Pred_1 := Solver.Create_Predicate (Fld_17, Create_Decl_P_Has_Correct_Type_Arg_Number_0_Predicate (Len, Error_Location_1)); 
--# expr-done 3450
Dyn_Var_Bind_Result_1 := Pred_1; Inc_Ref (Dyn_Var_Bind_Result_1);
--# expr-done 3451
Scope_Result_1 := Dyn_Var_Bind_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_860;


And_Pred_2 := Create_And (And_Pred_1, Scope_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5535:13") else null)); 
--# expr-done 3452
Scope_Result_2 := And_Pred_2;
   Inc_Ref (Scope_Result_2);


   --# end
      Finalizer_Scope_857;


   Result_Var := Scope_Result_2;
else
   --# expr-start 3453 LogicFalse False_Rel nodes.lkt:5552
False_Rel := Solver.Create_False ((if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5552:25") else null)); 
--# expr-done 3453
   Result_Var := False_Rel;
end if;

      Inc_Ref (Result_Var);


--# expr-done 3454
And_Pred_3 := Create_And (And_Pred, Result_Var, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5529:9") else null)); 
--# expr-done 3455

         Property_Result := And_Pred_3;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_412;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_412;
                     Finalizer_Scope_856;
                     Finalizer_Scope_857;
                     Finalizer_Scope_859;
                     Finalizer_Scope_860;




            raise;
      end;



   return Property_Result;
end Generic_Type_Ref_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Simple_Type_Ref
   --

   



      
      procedure Initialize_Fields_For_Simple_Type_Ref
        (Self : Bare_Simple_Type_Ref
         ; Simple_Type_Ref_F_Type_Name : Bare_Expr
        ) is
      begin
            Initialize_Fields_For_Type_Ref
              (Self);

            Self.Simple_Type_Ref_F_Type_Name := Simple_Type_Ref_F_Type_Name;
         

      end Initialize_Fields_For_Simple_Type_Ref;

      
   function Simple_Type_Ref_F_Type_Name
     (Node : Bare_Simple_Type_Ref) return Bare_Expr
   is
      

   begin
         
         return Node.Simple_Type_Ref_F_Type_Name;
      
   end;


   







--# property-start SimpleTypeRef.xref_equation nodes.lkt:5561
pragma Warnings (Off, "is not referenced");

function Simple_Type_Ref_P_Xref_Equation
  
  (Node : Bare_Simple_Type_Ref
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Simple_Type_Ref :=
     Bare_Simple_Type_Ref (Node);
     Ent : Internal_Entity_Simple_Type_Ref :=
       Internal_Entity_Simple_Type_Ref'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_413 with Inline_Always;
            procedure Finalizer_Scope_861 with Inline_Always;
            procedure Finalizer_Scope_862 with Inline_Always;
            procedure Finalizer_Scope_863 with Inline_Always;

      Fld : Internal_Entity_Expr;
Fld_1 : Logic_Equation;
Fld_2 : Internal_Entity_Expr;
Local_Ri : Internal_Entity_Ref_Id;
Fld_3 : Logic_Var;
Fld_4 : Logic_Var;
Bind_Result : Logic_Equation;
Local_De : Internal_Entity_Dot_Expr;
Fld_5 : Logic_Var;
Fld_6 : Internal_Entity_Ref_Id;
Fld_7 : Logic_Var;
Bind_Result_1 : Logic_Equation;
Ignored : Internal_Entity_Expr;
Match_Prefix : Internal_Entity_Expr;
Cast_Result : Internal_Entity_Ref_Id;
Let_Result : Logic_Equation;
Scope_Result : Logic_Equation;
Cast_Result_1 : Internal_Entity_Dot_Expr;
Let_Result_1 : Logic_Equation;
Scope_Result_1 : Logic_Equation;
Cast_Result_2 : Internal_Entity_Expr;
Let_Result_2 : Logic_Equation;
Scope_Result_2 : Logic_Equation;
Match_Result : Logic_Equation;
And_Pred : Logic_Equation;

            procedure Finalizer_Scope_413 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (Scope_Result_1);
                     Dec_Ref (Scope_Result_2);
                     Dec_Ref (Match_Result);
                     Dec_Ref (And_Pred);
            end Finalizer_Scope_413;
            procedure Finalizer_Scope_861 is
            begin
                     Dec_Ref (Bind_Result);
                     Dec_Ref (Let_Result);
            end Finalizer_Scope_861;
            procedure Finalizer_Scope_862 is
            begin
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (Let_Result_1);
            end Finalizer_Scope_862;
            procedure Finalizer_Scope_863 is
            begin
                     Dec_Ref (Let_Result_2);
            end Finalizer_Scope_863;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3467 LogicAnd And_Pred nodes.lkt:5562
--# expr-start 3457 Expr.xtype_equation Fld_1 nodes.lkt:5562



--# expr-start 3456 SimpleTypeRef.type_name Fld nodes.lkt:5562







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Expr (Node => Ent.Node.Simple_Type_Ref_F_Type_Name, Info => Ent.Info);
--# expr-done 3456



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]Expr.xtype_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Expr_P_Xtype_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 3457
--# expr-start 3466 Match Match_Result nodes.lkt:5563






--# expr-start 3458 SimpleTypeRef.type_name Fld_2 nodes.lkt:5563







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Ent.Node.Simple_Type_Ref_F_Type_Name, Info => Ent.Info);
--# expr-done 3458



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Match_Prefix := Fld_2; 

case Lkt_Expr (Match_Prefix.Node.Kind) is
         when Lkt_Ref_Id =>
            



   --# scope-start



--# scope-start









   
      Cast_Result := Create_Internal_Entity_Ref_Id
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_Ri := Cast_Result; 
--# bind ri Local_Ri
--# expr-start 3461 LogicUnify Bind_Result nodes.lkt:5564
--# expr-start 3459 TypeRef.type_var Fld_3 nodes.lkt:5564







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_3 := Ent.Node.Type_Ref_F_Type_Var'Unrestricted_Access;
--# expr-done 3459
Fld_3.Value := No_Entity;
Entity_Vars.Reset (Fld_3);
--# expr-start 3460 RefId.ref_var Fld_4 nodes.lkt:5564







   if Local_Ri.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Local_Ri.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 3460
Bind_Result := Solver.Create_Unify (Fld_3, Fld_4, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5564:31") else null)); 
--# expr-done 3461
Let_Result := Bind_Result; Inc_Ref (Let_Result);
--# end
Scope_Result := Let_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_861;


            Match_Result := Scope_Result; Inc_Ref (Match_Result);
         when Lkt_Dot_Expr =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_1 := Create_Internal_Entity_Dot_Expr
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Local_De := Cast_Result_1; 
--# bind de Local_De
--# expr-start 3465 LogicUnify Bind_Result_1 nodes.lkt:5565
--# expr-start 3462 TypeRef.type_var Fld_5 nodes.lkt:5565







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Ent.Node.Type_Ref_F_Type_Var'Unrestricted_Access;
--# expr-done 3462
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);
--# expr-start 3464 RefId.ref_var Fld_7 nodes.lkt:5565



--# expr-start 3463 DotExpr.suffix Fld_6 nodes.lkt:5565







   if Local_De.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Ref_Id (Node => Local_De.Node.Dot_Expr_F_Suffix, Info => Local_De.Info);
--# expr-done 3463



   if Fld_6.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Fld_6.Node.Ref_Id_F_Ref_Var'Unrestricted_Access;
--# expr-done 3464
Bind_Result_1 := Solver.Create_Unify (Fld_5, Fld_7, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5565:33") else null)); 
--# expr-done 3465
Let_Result_1 := Bind_Result_1; Inc_Ref (Let_Result_1);
--# end
Scope_Result_1 := Let_Result_1;
   Inc_Ref (Scope_Result_1);


   --# end
      Finalizer_Scope_862;


            Match_Result := Scope_Result_1; Inc_Ref (Match_Result);
         when Lkt_Any_Of .. Lkt_Cast_Expr | Lkt_Error_On_Null .. Lkt_Module_Ref_Id | Lkt_If_Expr .. Lkt_Un_Op =>
            



   --# scope-start



--# scope-start









   
      Cast_Result_2 := Create_Internal_Entity_Expr
        (Node => Match_Prefix.Node,
         Info => Match_Prefix.Info);


Ignored := Cast_Result_2; 
--# bind _ Ignored

Let_Result_2 := raise Property_Error with "Unreachable"; Inc_Ref (Let_Result_2);
--# end
Scope_Result_2 := Let_Result_2;
   Inc_Ref (Scope_Result_2);


   --# end
      Finalizer_Scope_863;


            Match_Result := Scope_Result_2; Inc_Ref (Match_Result);
end case;

--# expr-done 3466
And_Pred := Create_And (Fld_1, Match_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5562:9") else null)); 
--# expr-done 3467

         Property_Result := And_Pred;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_413;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_413;
                     Finalizer_Scope_861;
                     Finalizer_Scope_862;
                     Finalizer_Scope_863;




            raise;
      end;



   return Property_Result;
end Simple_Type_Ref_P_Xref_Equation;
--# end



   


      

   --
   --  Primitives for Bare_Var_Bind
   --

   



      
      procedure Initialize_Fields_For_Var_Bind
        (Self : Bare_Var_Bind
         ; Var_Bind_F_Name : Bare_Ref_Id
         ; Var_Bind_F_Expr : Bare_Expr
        ) is
      begin

            Self.Var_Bind_F_Name := Var_Bind_F_Name;
            Self.Var_Bind_F_Expr := Var_Bind_F_Expr;
         

      end Initialize_Fields_For_Var_Bind;

      
   function Var_Bind_F_Name
     (Node : Bare_Var_Bind) return Bare_Ref_Id
   is
      

   begin
         
         return Node.Var_Bind_F_Name;
      
   end;

      
   function Var_Bind_F_Expr
     (Node : Bare_Var_Bind) return Bare_Expr
   is
      

   begin
         
         return Node.Var_Bind_F_Expr;
      
   end;


   







--# property-start VarBind.xref_entry_point nodes.lkt:5577
pragma Warnings (Off, "is not referenced");

function Var_Bind_P_Xref_Entry_Point
  
  (Node : Bare_Var_Bind
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Boolean
is
   Self : Bare_Var_Bind :=
     Bare_Var_Bind (Node);
     Ent : Internal_Entity_Var_Bind :=
       Internal_Entity_Var_Bind'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Boolean;

      

      



begin
   --# property-body-start

   pragma Assert (Self = Node);





      begin
         
   --# scope-start

         

         Property_Result := True;
         
   --# end


      exception
         when Exc : Property_Error =>




            raise;
      end;



   return Property_Result;
end Var_Bind_P_Xref_Entry_Point;
--# end

   







--# property-start VarBind.xref_equation nodes.lkt:5579
pragma Warnings (Off, "is not referenced");

function Var_Bind_P_Xref_Equation
  
  (Node : Bare_Var_Bind
   ; E_Info : Internal_Entity_Info :=
      No_Entity_Info
  )

   return Logic_Equation
is
   Self : Bare_Var_Bind :=
     Bare_Var_Bind (Node);
     Ent : Internal_Entity_Var_Bind :=
       Internal_Entity_Var_Bind'(Node => Self, Info => E_Info);
      --# bind self Ent

   


   Property_Result : Logic_Equation;

      
            procedure Finalizer_Scope_415 with Inline_Always;
            procedure Finalizer_Scope_864 with Inline_Always;

      Fld : Internal_Entity_Ref_Id;
Fld_1 : Logic_Equation;
Fld_2 : Internal_Entity_Expr;
Fld_3 : Logic_Equation;
And_Pred : Logic_Equation;
Fld_4 : Internal_Entity_Expr;
Fld_5 : Logic_Var;
Fld_6 : Internal_Entity_Ref_Id;
Fld_7 : Logic_Var;
Bind_Result : Logic_Equation;
And_Pred_1 : Logic_Equation;
Fld_8 : Internal_Entity_Ref_Id;
Fld_9 : Logic_Var;
Cast_Expr : Internal_Entity_Type_Decl;
Cast_Result : Internal_Entity;
Bind_Result_1 : Logic_Equation;
And_Pred_2 : Logic_Equation;
Error_Location : Bare_Lkt_Node;
Fld_10 : Bare_Expr;
Fld_11 : Internal_Entity_Expr;
Fld_12 : Logic_Var;
Fld_13 : Internal_Entity_Expr;
Fld_14 : Logic_Var;
Pred : Logic_Equation;
Cast_Result_1 : Bare_Lkt_Node;
Dyn_Var_Bind_Result : Logic_Equation;
Scope_Result : Logic_Equation;
And_Pred_3 : Logic_Equation;

            procedure Finalizer_Scope_415 is
            begin
                     Dec_Ref (Fld_1);
                     Dec_Ref (Fld_3);
                     Dec_Ref (And_Pred);
                     Dec_Ref (Bind_Result);
                     Dec_Ref (And_Pred_1);
                     Dec_Ref (Bind_Result_1);
                     Dec_Ref (And_Pred_2);
                     Dec_Ref (Scope_Result);
                     Dec_Ref (And_Pred_3);
            end Finalizer_Scope_415;
            procedure Finalizer_Scope_864 is
            begin
                     Dec_Ref (Pred);
                     Dec_Ref (Dyn_Var_Bind_Result);
            end Finalizer_Scope_864;


begin
   --# property-body-start

   pragma Assert (Self = Node);



      if Self /= null then
         Reset_Caches (Self.Unit);

      end if;


      begin
         
   --# scope-start

         --# expr-start 3490 LogicAnd And_Pred_3 nodes.lkt:5580
--# expr-start 3482 LogicAnd And_Pred_2 nodes.lkt:5581
--# expr-start 3478 LogicAnd And_Pred_1 nodes.lkt:5582
--# expr-start 3472 LogicAnd And_Pred nodes.lkt:5582
--# expr-start 3469 RefId.xref_equation Fld_1 nodes.lkt:5582



--# expr-start 3468 VarBind.name Fld nodes.lkt:5582







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Var_Bind_F_Name, Info => Ent.Info);
--# expr-done 3468



   if Fld.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_1 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld.Node, E_Info => Fld.Info);
--# end
--# expr-done 3469
--# expr-start 3471 LktNode.xref_equation Fld_3 nodes.lkt:5582



--# expr-start 3470 VarBind.expr Fld_2 nodes.lkt:5582







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_2 := Create_Internal_Entity_Expr (Node => Ent.Node.Var_Bind_F_Expr, Info => Ent.Info);
--# expr-done 3470



   if Fld_2.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


--# property-call-start '[dispatcher]LktNode.xref_equation'
Fld_3 := Liblktlang.Implementation.Dispatcher_Lkt_Node_P_Xref_Equation (Node => Fld_2.Node, E_Info => Fld_2.Info);
--# end
--# expr-done 3471
And_Pred := Create_And (Fld_1, Fld_3, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5582:18") else null)); 
--# expr-done 3472
--# expr-start 3477 LogicUnify Bind_Result nodes.lkt:5583
--# expr-start 3474 Expr.expected_type_var Fld_5 nodes.lkt:5583



--# expr-start 3473 VarBind.expr Fld_4 nodes.lkt:5583







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_4 := Create_Internal_Entity_Expr (Node => Ent.Node.Var_Bind_F_Expr, Info => Ent.Info);
--# expr-done 3473



   if Fld_4.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_5 := Fld_4.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3474
Fld_5.Value := No_Entity;
Entity_Vars.Reset (Fld_5);
--# expr-start 3476 Expr.actual_type_var Fld_7 nodes.lkt:5583



--# expr-start 3475 VarBind.name Fld_6 nodes.lkt:5583







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_6 := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Var_Bind_F_Name, Info => Ent.Info);
--# expr-done 3475



   if Fld_6.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_7 := Fld_6.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3476
Bind_Result := Solver.Create_Unify (Fld_5, Fld_7, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5583:22") else null)); 
--# expr-done 3477
And_Pred_1 := Create_And (And_Pred, Bind_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5582:17") else null)); 
--# expr-done 3478
--# expr-start 3481 LogicAssign Bind_Result_1 nodes.lkt:5585
--# expr-start 3480 Expr.expected_type_var Fld_9 nodes.lkt:5585



--# expr-start 3479 VarBind.name Fld_8 nodes.lkt:5585







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_8 := Create_Internal_Entity_Ref_Id (Node => Ent.Node.Var_Bind_F_Name, Info => Ent.Info);
--# expr-done 3479



   if Fld_8.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_9 := Fld_8.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3480
Fld_9.Value := No_Entity;
Entity_Vars.Reset (Fld_9);






Cast_Expr := No_Entity_Type_Decl; 



   
      Cast_Result := Create_Internal_Entity
        (Node => Cast_Expr.Node,
         Info => Cast_Expr.Info);


Bind_Result_1 := Solver.Create_Assign (Fld_9, Cast_Result, Solver_Ifc.No_Converter, Debug_String => (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5585:18") else null)); 
--# expr-done 3481
And_Pred_2 := Create_And (And_Pred_1, Bind_Result_1, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5581:13") else null)); 
--# expr-done 3482




   --# scope-start



--# expr-start 3489 bind Dyn_Var_Bind_Result nodes.lkt:5588





--# expr-start 3483 VarBind.expr Fld_10 nodes.lkt:5588







   if Self = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_10 := Self.Var_Bind_F_Expr;
--# expr-done 3483



   
      Cast_Result_1 := Fld_10;


Error_Location := Cast_Result_1; 
--# expr-start 3488 LogicPropagate Pred nodes.lkt:5589
--# expr-start 3485 Expr.expected_type_var Fld_12 nodes.lkt:5590



--# expr-start 3484 VarBind.expr Fld_11 nodes.lkt:5590







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_11 := Create_Internal_Entity_Expr (Node => Ent.Node.Var_Bind_F_Expr, Info => Ent.Info);
--# expr-done 3484



   if Fld_11.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_12 := Fld_11.Node.Expr_F_Expected_Type_Var'Unrestricted_Access;
--# expr-done 3485
Fld_12.Value := No_Entity;
Entity_Vars.Reset (Fld_12);
--# expr-start 3487 Expr.actual_type_var Fld_14 nodes.lkt:5591



--# expr-start 3486 VarBind.expr Fld_13 nodes.lkt:5591







   if Ent.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_13 := Create_Internal_Entity_Expr (Node => Ent.Node.Var_Bind_F_Expr, Info => Ent.Info);
--# expr-done 3486



   if Fld_13.Node = null then
      Raise_Property_Exception
        (Self, Property_Error'Identity, "dereferencing a null access");
   end if;


Fld_14 := Fld_13.Node.Expr_F_Actual_Type_Var'Unrestricted_Access;
--# expr-done 3487
Fld_14.Value := No_Entity;
Entity_Vars.Reset (Fld_14);


Pred := Solver.Create_N_Predicate ((Fld_12, Fld_14), Create_Type_Decl_P_Matching_Type_0_Predicate (2, Error_Location)); 
--# expr-done 3488
Dyn_Var_Bind_Result := Pred; Inc_Ref (Dyn_Var_Bind_Result);
--# expr-done 3489
Scope_Result := Dyn_Var_Bind_Result;
   Inc_Ref (Scope_Result);


   --# end
      Finalizer_Scope_864;


And_Pred_3 := Create_And (And_Pred_2, Scope_Result, (if Liblktlang_Support.Adalog.Debug.Debug then New_Unit_String (Node.Unit, "nodes.lkt:5580:9") else null)); 
--# expr-done 3490

         Property_Result := And_Pred_3;
            Inc_Ref (Property_Result);
         
   --# end
      Finalizer_Scope_415;


      exception
         when Exc : Property_Error =>
                     Finalizer_Scope_415;
                     Finalizer_Scope_864;




            raise;
      end;



   return Property_Result;
end Var_Bind_P_Xref_Equation;
--# end



   



   ----------------------------
   -- Destroy_Synthetic_Node --
   ----------------------------

   procedure Destroy_Synthetic_Node (Node : in out Bare_Lkt_Node) is
      procedure Free is new Ada.Unchecked_Deallocation
        (Root_Node_Record, Bare_Lkt_Node);
   begin
      --  Don't call Node.Destroy, as Node's children may be gone already: they
      --  have their own destructor and there is no specified order for the
      --  call of these destructors.
      Free_User_Fields (Node);

      --  Synthetic list have their array of children dynamically allocated:
      --  the children themselves are gone, but not the array: free it now.
      if Is_List_Node (Node.Kind) then
         Free_Synthetic_List_Children (Node);
      end if;

      Free (Node);
   end Destroy_Synthetic_Node;

   -----------
   -- Image --
   -----------

   function Image (Value : Boolean) return String
   is (if Value then "True" else "False");

      -----------------
      -- Trace_Image --
      -----------------

      function Trace_Image
        (Node       : Bare_Lkt_Node;
         Decoration : Boolean := True) return String is
      begin
         if Node = null then
            return "None";
         else
            declare
               Result : constant String :=
                 (Kind_Name (Node) & " "
                  & Basename (Node.Unit) & ":"
                  & Image (Sloc_Range (Node)));
            begin
               return (if Decoration then "<" & Result & ">" else Result);
            end;
         end if;
      end Trace_Image;

   Kind_Names : array (Lkt_Node_Kind_Type) of Unbounded_String :=
     (Lkt_Argument => To_Unbounded_String ("Argument"), 
Lkt_Error_Lexer_Case_Rule_Alt => To_Unbounded_String ("ErrorLexerCaseRuleAlt"), 
Lkt_Lexer_Case_Rule_Cond_Alt => To_Unbounded_String ("LexerCaseRuleCondAlt"), 
Lkt_Lexer_Case_Rule_Default_Alt => To_Unbounded_String ("LexerCaseRuleDefaultAlt"), 
Lkt_Match_Branch => To_Unbounded_String ("MatchBranch"), 
Lkt_Pattern_Match_Branch => To_Unbounded_String ("PatternMatchBranch"), 
Lkt_Block_Expr_Clause => To_Unbounded_String ("BlockExprClause"), 
Lkt_Block_String_Line => To_Unbounded_String ("BlockStringLine"), 
Lkt_Class_Qualifier_Absent => To_Unbounded_String ("ClassQualifierAbsent"), 
Lkt_Class_Qualifier_Present => To_Unbounded_String ("ClassQualifierPresent"), 
Lkt_Grammar_Rule_Decl => To_Unbounded_String ("GrammarRuleDecl"), 
Lkt_Synthetic_Lexer_Decl => To_Unbounded_String ("SyntheticLexerDecl"), 
Lkt_Node_Decl => To_Unbounded_String ("NodeDecl"), 
Lkt_Self_Decl => To_Unbounded_String ("SelfDecl"), 
Lkt_Binding_Val_Decl => To_Unbounded_String ("BindingValDecl"), 
Lkt_Enum_Lit_Decl => To_Unbounded_String ("EnumLitDecl"), 
Lkt_Field_Decl => To_Unbounded_String ("FieldDecl"), 
Lkt_Fun_Param_Decl => To_Unbounded_String ("FunParamDecl"), 
Lkt_Lambda_Param_Decl => To_Unbounded_String ("LambdaParamDecl"), 
Lkt_Dyn_Var_Decl => To_Unbounded_String ("DynVarDecl"), 
Lkt_Match_Val_Decl => To_Unbounded_String ("MatchValDecl"), 
Lkt_Val_Decl => To_Unbounded_String ("ValDecl"), 
Lkt_Fun_Decl => To_Unbounded_String ("FunDecl"), 
Lkt_Env_Spec_Decl => To_Unbounded_String ("EnvSpecDecl"), 
Lkt_Error_Decl => To_Unbounded_String ("ErrorDecl"), 
Lkt_Generic_Decl => To_Unbounded_String ("GenericDecl"), 
Lkt_Grammar_Decl => To_Unbounded_String ("GrammarDecl"), 
Lkt_Lexer_Decl => To_Unbounded_String ("LexerDecl"), 
Lkt_Lexer_Family_Decl => To_Unbounded_String ("LexerFamilyDecl"), 
Lkt_Synth_Fun_Decl => To_Unbounded_String ("SynthFunDecl"), 
Lkt_Synth_Param_Decl => To_Unbounded_String ("SynthParamDecl"), 
Lkt_Any_Type_Decl => To_Unbounded_String ("AnyTypeDecl"), 
Lkt_Enum_Class_Alt_Decl => To_Unbounded_String ("EnumClassAltDecl"), 
Lkt_Function_Type => To_Unbounded_String ("FunctionType"), 
Lkt_Generic_Param_Type_Decl => To_Unbounded_String ("GenericParamTypeDecl"), 
Lkt_Class_Decl => To_Unbounded_String ("ClassDecl"), 
Lkt_Enum_Class_Decl => To_Unbounded_String ("EnumClassDecl"), 
Lkt_Enum_Type_Decl => To_Unbounded_String ("EnumTypeDecl"), 
Lkt_Struct_Decl => To_Unbounded_String ("StructDecl"), 
Lkt_Trait_Decl => To_Unbounded_String ("TraitDecl"), 
Lkt_Decl_Annotation => To_Unbounded_String ("DeclAnnotation"), 
Lkt_Decl_Annotation_Args => To_Unbounded_String ("DeclAnnotationArgs"), 
Lkt_Dyn_Env_Wrapper => To_Unbounded_String ("DynEnvWrapper"), 
Lkt_Elsif_Branch => To_Unbounded_String ("ElsifBranch"), 
Lkt_Enum_Class_Case => To_Unbounded_String ("EnumClassCase"), 
Lkt_Excludes_Null_Absent => To_Unbounded_String ("ExcludesNullAbsent"), 
Lkt_Excludes_Null_Present => To_Unbounded_String ("ExcludesNullPresent"), 
Lkt_Any_Of => To_Unbounded_String ("AnyOf"), 
Lkt_Array_Literal => To_Unbounded_String ("ArrayLiteral"), 
Lkt_Call_Expr => To_Unbounded_String ("CallExpr"), 
Lkt_Logic_Predicate => To_Unbounded_String ("LogicPredicate"), 
Lkt_Logic_Propagate_Call => To_Unbounded_String ("LogicPropagateCall"), 
Lkt_Bin_Op => To_Unbounded_String ("BinOp"), 
Lkt_Block_Expr => To_Unbounded_String ("BlockExpr"), 
Lkt_Cast_Expr => To_Unbounded_String ("CastExpr"), 
Lkt_Dot_Expr => To_Unbounded_String ("DotExpr"), 
Lkt_Error_On_Null => To_Unbounded_String ("ErrorOnNull"), 
Lkt_Generic_Instantiation => To_Unbounded_String ("GenericInstantiation"), 
Lkt_Error_Grammar_Expr => To_Unbounded_String ("ErrorGrammarExpr"), 
Lkt_Grammar_Cut => To_Unbounded_String ("GrammarCut"), 
Lkt_Grammar_Discard => To_Unbounded_String ("GrammarDiscard"), 
Lkt_Grammar_Dont_Skip => To_Unbounded_String ("GrammarDontSkip"), 
Lkt_Grammar_List => To_Unbounded_String ("GrammarList"), 
Lkt_Grammar_Null => To_Unbounded_String ("GrammarNull"), 
Lkt_Grammar_Opt => To_Unbounded_String ("GrammarOpt"), 
Lkt_Grammar_Opt_Error => To_Unbounded_String ("GrammarOptError"), 
Lkt_Grammar_Opt_Error_Group => To_Unbounded_String ("GrammarOptErrorGroup"), 
Lkt_Grammar_Opt_Group => To_Unbounded_String ("GrammarOptGroup"), 
Lkt_Grammar_Or_Expr => To_Unbounded_String ("GrammarOrExpr"), 
Lkt_Grammar_Pick => To_Unbounded_String ("GrammarPick"), 
Lkt_Grammar_Implicit_Pick => To_Unbounded_String ("GrammarImplicitPick"), 
Lkt_Grammar_Predicate => To_Unbounded_String ("GrammarPredicate"), 
Lkt_Grammar_Rule_Ref => To_Unbounded_String ("GrammarRuleRef"), 
Lkt_Grammar_Skip => To_Unbounded_String ("GrammarSkip"), 
Lkt_Grammar_Stop_Cut => To_Unbounded_String ("GrammarStopCut"), 
Lkt_Parse_Node_Expr => To_Unbounded_String ("ParseNodeExpr"), 
Lkt_Token_Lit => To_Unbounded_String ("TokenLit"), 
Lkt_Token_No_Case_Lit => To_Unbounded_String ("TokenNoCaseLit"), 
Lkt_Token_Pattern_Concat => To_Unbounded_String ("TokenPatternConcat"), 
Lkt_Token_Pattern_Lit => To_Unbounded_String ("TokenPatternLit"), 
Lkt_Token_Ref => To_Unbounded_String ("TokenRef"), 
Lkt_Id => To_Unbounded_String ("Id"), 
Lkt_Def_Id => To_Unbounded_String ("DefId"), 
Lkt_Module_Ref_Id => To_Unbounded_String ("ModuleRefId"), 
Lkt_Ref_Id => To_Unbounded_String ("RefId"), 
Lkt_If_Expr => To_Unbounded_String ("IfExpr"), 
Lkt_Isa => To_Unbounded_String ("Isa"), 
Lkt_Keep_Expr => To_Unbounded_String ("KeepExpr"), 
Lkt_Lambda_Expr => To_Unbounded_String ("LambdaExpr"), 
Lkt_Big_Num_Lit => To_Unbounded_String ("BigNumLit"), 
Lkt_Char_Lit => To_Unbounded_String ("CharLit"), 
Lkt_Null_Lit => To_Unbounded_String ("NullLit"), 
Lkt_Num_Lit => To_Unbounded_String ("NumLit"), 
Lkt_Block_String_Lit => To_Unbounded_String ("BlockStringLit"), 
Lkt_Module_Doc_String_Lit => To_Unbounded_String ("ModuleDocStringLit"), 
Lkt_Single_Line_String_Lit => To_Unbounded_String ("SingleLineStringLit"), 
Lkt_Pattern_Single_Line_String_Lit => To_Unbounded_String ("PatternSingleLineStringLit"), 
Lkt_Logic_Assign => To_Unbounded_String ("LogicAssign"), 
Lkt_Logic_Expr => To_Unbounded_String ("LogicExpr"), 
Lkt_Logic_Propagate => To_Unbounded_String ("LogicPropagate"), 
Lkt_Logic_Unify => To_Unbounded_String ("LogicUnify"), 
Lkt_Match_Expr => To_Unbounded_String ("MatchExpr"), 
Lkt_Not_Expr => To_Unbounded_String ("NotExpr"), 
Lkt_Paren_Expr => To_Unbounded_String ("ParenExpr"), 
Lkt_Query => To_Unbounded_String ("Query"), 
Lkt_Raise_Expr => To_Unbounded_String ("RaiseExpr"), 
Lkt_Subscript_Expr => To_Unbounded_String ("SubscriptExpr"), 
Lkt_Try_Expr => To_Unbounded_String ("TryExpr"), 
Lkt_Un_Op => To_Unbounded_String ("UnOp"), 
Lkt_Full_Decl => To_Unbounded_String ("FullDecl"), 
Lkt_Grammar_List_Sep => To_Unbounded_String ("GrammarListSep"), 
Lkt_Import => To_Unbounded_String ("Import"), 
Lkt_Langkit_Root => To_Unbounded_String ("LangkitRoot"), 
Lkt_Lexer_Case_Rule => To_Unbounded_String ("LexerCaseRule"), 
Lkt_Lexer_Case_Rule_Send => To_Unbounded_String ("LexerCaseRuleSend"), 
Lkt_List_Kind_One => To_Unbounded_String ("ListKindOne"), 
Lkt_List_Kind_Zero => To_Unbounded_String ("ListKindZero"), 
Lkt_Argument_List => To_Unbounded_String ("ArgumentList"), 
Lkt_Base_Lexer_Case_Rule_Alt_List => To_Unbounded_String ("BaseLexerCaseRuleAltList"), 
Lkt_Base_Match_Branch_List => To_Unbounded_String ("BaseMatchBranchList"), 
Lkt_Block_String_Line_List => To_Unbounded_String ("BlockStringLineList"), 
Lkt_Call_Expr_List => To_Unbounded_String ("CallExprList"), 
Lkt_Decl_Annotation_List => To_Unbounded_String ("DeclAnnotationList"), 
Lkt_Elsif_Branch_List => To_Unbounded_String ("ElsifBranchList"), 
Lkt_Enum_Class_Alt_Decl_List => To_Unbounded_String ("EnumClassAltDeclList"), 
Lkt_Enum_Class_Case_List => To_Unbounded_String ("EnumClassCaseList"), 
Lkt_Enum_Lit_Decl_List => To_Unbounded_String ("EnumLitDeclList"), 
Lkt_Expr_List => To_Unbounded_String ("ExprList"), 
Lkt_Any_Of_List => To_Unbounded_String ("AnyOfList"), 
Lkt_Full_Decl_List => To_Unbounded_String ("FullDeclList"), 
Lkt_Decl_Block => To_Unbounded_String ("DeclBlock"), 
Lkt_Generic_Param_Decl_List => To_Unbounded_String ("GenericParamDeclList"), 
Lkt_Fun_Param_Decl_List => To_Unbounded_String ("FunParamDeclList"), 
Lkt_Grammar_Expr_List => To_Unbounded_String ("GrammarExprList"), 
Lkt_Grammar_Expr_List_List => To_Unbounded_String ("GrammarExprListList"), 
Lkt_Import_List => To_Unbounded_String ("ImportList"), 
Lkt_Lambda_Param_Decl_List => To_Unbounded_String ("LambdaParamDeclList"), 
Lkt_Lkt_Node_List => To_Unbounded_String ("LktNodeList"), 
Lkt_Module_Doc_String_Line_List => To_Unbounded_String ("ModuleDocStringLineList"), 
Lkt_Pattern_Detail_List => To_Unbounded_String ("PatternDetailList"), 
Lkt_Pattern_List => To_Unbounded_String ("PatternList"), 
Lkt_Ref_Id_List => To_Unbounded_String ("RefIdList"), 
Lkt_Type_Ref_List => To_Unbounded_String ("TypeRefList"), 
Lkt_Synthetic_Type_Ref_List => To_Unbounded_String ("SyntheticTypeRefList"), 
Lkt_Module_Doc_String_Line => To_Unbounded_String ("ModuleDocStringLine"), 
Lkt_Null_Cond_Qualifier_Absent => To_Unbounded_String ("NullCondQualifierAbsent"), 
Lkt_Null_Cond_Qualifier_Present => To_Unbounded_String ("NullCondQualifierPresent"), 
Lkt_Op_Amp => To_Unbounded_String ("OpAmp"), 
Lkt_Op_And => To_Unbounded_String ("OpAnd"), 
Lkt_Op_Div => To_Unbounded_String ("OpDiv"), 
Lkt_Op_Eq => To_Unbounded_String ("OpEq"), 
Lkt_Op_Gt => To_Unbounded_String ("OpGt"), 
Lkt_Op_Gte => To_Unbounded_String ("OpGte"), 
Lkt_Op_Logic_And => To_Unbounded_String ("OpLogicAnd"), 
Lkt_Op_Logic_Or => To_Unbounded_String ("OpLogicOr"), 
Lkt_Op_Lt => To_Unbounded_String ("OpLt"), 
Lkt_Op_Lte => To_Unbounded_String ("OpLte"), 
Lkt_Op_Minus => To_Unbounded_String ("OpMinus"), 
Lkt_Op_Mult => To_Unbounded_String ("OpMult"), 
Lkt_Op_Ne => To_Unbounded_String ("OpNe"), 
Lkt_Op_Or => To_Unbounded_String ("OpOr"), 
Lkt_Op_Or_Int => To_Unbounded_String ("OpOrInt"), 
Lkt_Op_Plus => To_Unbounded_String ("OpPlus"), 
Lkt_Op_Stream_Concat => To_Unbounded_String ("OpStreamConcat"), 
Lkt_Op_Stream_Cons => To_Unbounded_String ("OpStreamCons"), 
Lkt_Any_Type_Pattern => To_Unbounded_String ("AnyTypePattern"), 
Lkt_Binding_Pattern => To_Unbounded_String ("BindingPattern"), 
Lkt_Bool_Pattern_False => To_Unbounded_String ("BoolPatternFalse"), 
Lkt_Bool_Pattern_True => To_Unbounded_String ("BoolPatternTrue"), 
Lkt_Ellipsis_Pattern => To_Unbounded_String ("EllipsisPattern"), 
Lkt_Extended_Pattern => To_Unbounded_String ("ExtendedPattern"), 
Lkt_Filtered_Pattern => To_Unbounded_String ("FilteredPattern"), 
Lkt_Integer_Pattern => To_Unbounded_String ("IntegerPattern"), 
Lkt_List_Pattern => To_Unbounded_String ("ListPattern"), 
Lkt_Not_Pattern => To_Unbounded_String ("NotPattern"), 
Lkt_Null_Pattern => To_Unbounded_String ("NullPattern"), 
Lkt_Or_Pattern => To_Unbounded_String ("OrPattern"), 
Lkt_Paren_Pattern => To_Unbounded_String ("ParenPattern"), 
Lkt_Regex_Pattern => To_Unbounded_String ("RegexPattern"), 
Lkt_Tuple_Pattern => To_Unbounded_String ("TuplePattern"), 
Lkt_Type_Pattern => To_Unbounded_String ("TypePattern"), 
Lkt_Field_Pattern_Detail => To_Unbounded_String ("FieldPatternDetail"), 
Lkt_Property_Pattern_Detail => To_Unbounded_String ("PropertyPatternDetail"), 
Lkt_Selector_Pattern_Detail => To_Unbounded_String ("SelectorPatternDetail"), 
Lkt_Selector_Call => To_Unbounded_String ("SelectorCall"), 
Lkt_Default_List_Type_Ref => To_Unbounded_String ("DefaultListTypeRef"), 
Lkt_Function_Type_Ref => To_Unbounded_String ("FunctionTypeRef"), 
Lkt_Generic_Type_Ref => To_Unbounded_String ("GenericTypeRef"), 
Lkt_Simple_Type_Ref => To_Unbounded_String ("SimpleTypeRef"), 
Lkt_Var_Bind => To_Unbounded_String ("VarBind"));

   ---------------
   -- Kind_Name --
   ---------------

   function Kind_Name (Node : Bare_Lkt_Node) return String is
   begin
      return To_String (Kind_Names (Node.Kind));
   end Kind_Name;

   --------------------
   -- Children_Count --
   --------------------

   function Children_Count (Node : Bare_Lkt_Node) return Natural is
      C : Integer := Kind_To_Node_Children_Count (Node.Kind);
   begin
      if C = -1 then
         return Node.Count;
      else
         return C;
      end if;
   end Children_Count;

   ----------------------
   -- Free_User_Fields --
   ----------------------

   procedure Free_User_Fields (Node : Bare_Lkt_Node) is

      procedure Reset_Logic_Var (LV : in out Logic_Var_Record);
      --  Reset the LV logic variable, clearing the value it stores

      ---------------------
      -- Reset_Logic_Var --
      ---------------------

      procedure Reset_Logic_Var (LV : in out Logic_Var_Record) is
      begin
         LV.Value := No_Entity;
         Entity_Vars.Reset (LV'Unrestricted_Access);
         Entity_Vars.Destroy (LV);
      end Reset_Logic_Var;

      K : constant Lkt_Node_Kind_Type := Node.Kind;

   begin
      
      case Lkt_Lkt_Node (K) is
when Lkt_Lambda_Param_Decl_Range =>
declare
N_Bare_Lambda_Param_Decl : constant Bare_Lambda_Param_Decl := Node;
begin
Reset_Logic_Var (N_Bare_Lambda_Param_Decl.Lambda_Param_Decl_F_Type_Var);
end;
when Lkt_Synth_Fun_Decl_Range =>
declare
N_Bare_Synth_Fun_Decl : constant Bare_Synth_Fun_Decl := Node;
begin
Dec_Ref (N_Bare_Synth_Fun_Decl.Synth_Fun_Decl_F_Params);
end;
when Lkt_Function_Type_Range =>
declare
N_Bare_Function_Type : constant Bare_Function_Type := Node;
begin
Dec_Ref (N_Bare_Function_Type.Function_Type_F_Params);
end;
when Lkt_Dyn_Env_Wrapper_Range =>
declare
N_Bare_Dyn_Env_Wrapper : constant Bare_Dyn_Env_Wrapper := Node;
begin
Dec_Ref (N_Bare_Dyn_Env_Wrapper.Dyn_Env_Wrapper_F_Names);
Dec_Ref (N_Bare_Dyn_Env_Wrapper.Dyn_Env_Wrapper_F_Types);
Dec_Ref (N_Bare_Dyn_Env_Wrapper.Internal_Bare_Dyn_Env_Wrapper_Lf_Stg_Dynenvwrapper_Instantiation_Env_21);
end;
when Lkt_Expr =>
declare
N_Bare_Expr : constant Bare_Expr := Node;
begin
Reset_Logic_Var (N_Bare_Expr.Expr_F_Expected_Type_Var);
Reset_Logic_Var (N_Bare_Expr.Expr_F_Actual_Type_Var);
Reset_Logic_Var (N_Bare_Expr.Expr_F_Generic_Func_Type_Var);
case Lkt_Expr (K) is
when Lkt_Array_Literal_Range =>
declare
N_Bare_Array_Literal : constant Bare_Array_Literal := N_Bare_Expr;
begin
Reset_Logic_Var (N_Bare_Array_Literal.Array_Literal_F_Expected_Exprs_Type_Var);
Reset_Logic_Var (N_Bare_Array_Literal.Array_Literal_F_Actual_Element_Type);
end;
when Lkt_Generic_Instantiation_Range =>
declare
N_Bare_Generic_Instantiation : constant Bare_Generic_Instantiation := N_Bare_Expr;
begin
Reset_Logic_Var (N_Bare_Generic_Instantiation.Generic_Instantiation_F_Rebinded_Var);
end;
when Lkt_Ref_Id_Range =>
declare
N_Bare_Ref_Id : constant Bare_Ref_Id := N_Bare_Expr;
begin
Reset_Logic_Var (N_Bare_Ref_Id.Ref_Id_F_Ref_Var);
end;
when Lkt_If_Expr_Range =>
declare
N_Bare_If_Expr : constant Bare_If_Expr := N_Bare_Expr;
begin
Reset_Logic_Var (N_Bare_If_Expr.If_Expr_F_Expected_Branch_Type_Var);
end;
when Lkt_Keep_Expr_Range =>
declare
N_Bare_Keep_Expr : constant Bare_Keep_Expr := N_Bare_Expr;
begin
Reset_Logic_Var (N_Bare_Keep_Expr.Keep_Expr_F_Array_Element_Type);
end;
when Lkt_Match_Expr_Range =>
declare
N_Bare_Match_Expr : constant Bare_Match_Expr := N_Bare_Expr;
begin
Reset_Logic_Var (N_Bare_Match_Expr.Match_Expr_F_Expected_Branch_Type_Var);
end;
when Lkt_Try_Expr_Range =>
declare
N_Bare_Try_Expr : constant Bare_Try_Expr := N_Bare_Expr;
begin
Reset_Logic_Var (N_Bare_Try_Expr.Try_Expr_F_Expected_Expr_Type_Var);
end;
when others => null;
end case;
end;
when Lkt_Type_Ref =>
declare
N_Bare_Type_Ref : constant Bare_Type_Ref := Node;
begin
Reset_Logic_Var (N_Bare_Type_Ref.Type_Ref_F_Type_Var);
end;
when others => null;
end case;
   end Free_User_Fields;

   ----------------
   -- Token_Data --
   ----------------

   function Token_Data (Unit : Internal_Unit) return Token_Data_Handler_Access
   is (Unit.TDH'Access);

   -------------------
   -- Lookup_Symbol --
   -------------------

   function Lookup_Symbol
     (Context : Internal_Context; Symbol : Text_Type) return Symbol_Type
   is
      Canon_Symbol : constant Symbolization_Result :=
            Create_Symbol (Symbol)
      ;
   begin
      if Canon_Symbol.Success then
         return To_Symbol
           (Context.Symbols, Find (Context.Symbols, Canon_Symbol.Symbol));
      else
         raise Invalid_Symbol_Error with Image (Canon_Symbol.Error_Message);
      end if;
   end Lookup_Symbol;

   -------------------------
   -- Create_Special_Unit --
   -------------------------

   function Create_Special_Unit
     (Context             : Internal_Context;
      Normalized_Filename : Virtual_File;
      Charset             : String;
      Rule                : Grammar_Rule) return Internal_Unit
   is
      Unit : Internal_Unit := new Analysis_Unit_Type'
        (Context                      => Context,
         Is_Internal                  => False,
         Ast_Root                     => null,
         Filename                     => Normalized_Filename,
         Charset                      => To_Unbounded_String (Charset),
         TDH                          => <>,
         Diagnostics                  => <>,
         Rule                         => Rule,
         Ast_Mem_Pool                 => No_Pool,
         Destroyables                 => Destroyable_Vectors.Empty_Vector,
         Exiled_Entries               => Exiled_Entry_Vectors.Empty_Vector,
         Foreign_Nodes                =>
            Foreign_Node_Entry_Vectors.Empty_Vector,
         Exiled_Entries_In_NED        =>
            Exiled_Entry_In_NED_Vectors.Empty_Vector,
         Exiled_Envs                  => Exiled_Env_Vectors.Empty_Vector,
         Named_Envs                   => Named_Env_Vectors.Empty_Vector,
         Nodes_With_Foreign_Env       => <>,
         Rebindings                   => Env_Rebindings_Vectors.Empty_Vector,
         Cache_Version                => <>,
         Unit_Version                 => <>,
         Memoization_Map            => <>,
         others => <>
      );
   begin
      Initialize
        (Unit.TDH, Context.Symbols, Unit.all'Address, Context.Tab_Stop);
      return Unit;
   end Create_Special_Unit;

   --------------------
   -- Templates_Unit --
   --------------------

   function Templates_Unit (Context : Internal_Context) return Internal_Unit is
   begin
      if Context.Templates_Unit = No_Analysis_Unit then
         Context.Templates_Unit := Create_Special_Unit
           (Context             => Context,
            Normalized_Filename => No_File,
            Charset             => Default_Charset,
            Rule                => Main_Rule_Rule);
      end if;
      return Context.Templates_Unit;
   end Templates_Unit;

   --------------
   -- Set_Rule --
   --------------

   procedure Set_Rule (Unit : Internal_Unit; Rule : Grammar_Rule) is
   begin
      Unit.Rule := Rule;
   end Set_Rule;

   ------------------------------
   -- Normalized_Unit_Filename --
   ------------------------------

   function Normalized_Unit_Filename
     (Context : Internal_Context; Filename : String) return Virtual_File is
   begin
      return Liblktlang_Support.Internal.Analysis.Normalized_Unit_Filename
               (Context.Filenames, Filename);
   end Normalized_Unit_Filename;

   --------------------------
   -- Register_Destroyable --
   --------------------------

   procedure Register_Destroyable_Helper
     (Unit    : Internal_Unit;
      Object  : System.Address;
      Destroy : Destroy_Procedure)
   is
   begin
      Destroyable_Vectors.Append (Unit.Destroyables, (Object, Destroy));
   end Register_Destroyable_Helper;

   --------------------------
   -- Register_Destroyable --
   --------------------------

   procedure Register_Destroyable
     (Unit : Internal_Unit; Node : Bare_Lkt_Node)
   is
      procedure Helper is new Register_Destroyable_Gen
        (Root_Node_Record,
         Bare_Lkt_Node,
         Destroy_Synthetic_Node);
   begin
      Helper (Unit, Node);
   end Register_Destroyable;

   --------------------------
   -- Register_Destroyable --
   --------------------------

   procedure Register_Destroyable
     (Unit : Internal_Unit; Env : AST_Envs.Lexical_Env_Access)
   is
      procedure Helper is new Register_Destroyable_Gen
        (AST_Envs.Lexical_Env_Record, AST_Envs.Lexical_Env_Access, Destroy);
   begin
      Helper (Unit, Env);
   end Register_Destroyable;

   -----------------------
   -- Invalidate_Caches --
   -----------------------

   procedure Invalidate_Caches
     (Context : Internal_Context; Invalidate_Envs : Boolean) is
   begin
      --  Increase Context's version number. If we are about to overflow, reset
      --  all version numbers from analysis units.
      if Context.Cache_Version = Version_Number'Last then
         Context.Cache_Version := 1;
         for Unit of Context.Units loop
            Unit.Cache_Version := 0;
         end loop;
      else
         Context.Cache_Version := Context.Cache_Version + 1;
      end if;

      if Invalidate_Envs then
         Context.Reparse_Cache_Version := Context.Cache_Version;
      end if;
   end Invalidate_Caches;

   ------------------
   --  Reset_Envs  --
   ------------------

   procedure Reset_Envs (Unit : Internal_Unit) is

      procedure Reset_Refd_Envs (Node : Bare_Lkt_Node);

      -------------------------
      -- Recompute_Refd_Envs --
      -------------------------

      procedure Reset_Refd_Envs (Node : Bare_Lkt_Node) is
      begin
         if Node = null then
            return;
         end if;
         Reset_Referenced_Envs (Node.Self_Env);
         for I in 1 .. Children_Count (Node) loop
            Reset_Refd_Envs (Child (Node, I));
         end loop;
      end Reset_Refd_Envs;

   begin
      Reset_Refd_Envs (Unit.Ast_Root);
   end Reset_Envs;

   --------------
   -- Basename --
   --------------

   function Basename (Filename : String) return String is
   begin
      return +Create (+Filename).Base_Name;
   end Basename;

   --------------
   -- Basename --
   --------------

   function Basename (Unit : Internal_Unit) return String is
   begin
      return +Unit.Filename.Base_Name;
   end Basename;

   ------------------
   -- Reset_Caches --
   ------------------

   procedure Reset_Caches (Unit : Internal_Unit) is
      Cache_Version : constant Version_Number := Unit.Cache_Version;
   begin
      if Cache_Version < Unit.Context.Reparse_Cache_Version then
         Unit.Cache_Version := Unit.Context.Reparse_Cache_Version;
         Reset_Envs (Unit);
      end if;

      if Cache_Version < Unit.Context.Cache_Version then
         Unit.Cache_Version := Unit.Context.Cache_Version;
            Destroy (Unit.Memoization_Map);
      end if;
   end Reset_Caches;

   ----------------
   -- Do_Parsing --
   ----------------

   procedure Do_Parsing
     (Unit   : Internal_Unit;
      Input  : Liblktlang_Support.Internal.Analysis.Lexer_Input;
      Result : out Reparsed_Unit)
   is
      Context  : constant Internal_Context := Unit.Context;
      Unit_TDH : constant Token_Data_Handler_Access := Token_Data (Unit);

      Saved_TDH : aliased Token_Data_Handler;
      --  Holder to save tokens data in Unit.
      --
      --  By design, parsing is required to bind the nodes it creates to an
      --  analysis unit. However, this procedure is supposed to preserve the
      --  Unit itself and return its parsing result in Result.
      --
      --  In order to implement this, we first move "old" token data in this
      --  variable, then we do parsing. Only then, we can move "new" token data
      --  from the unit to Result, and restore the "old" token data to Unit.
      --  This last step is what Rotate_TDH (see below) is above.

      procedure Rotate_TDH;
      --  Move token data from Unit to Result and restore data in Saved_TDH to
      --  Unit.

      ----------------
      -- Rotate_TDH --
      ----------------

      procedure Rotate_TDH is
      begin
         Move (Result.TDH, Unit_TDH.all);
         Move (Unit_TDH.all, Saved_TDH);
      end Rotate_TDH;

   begin
      GNATCOLL.Traces.Trace (Main_Trace, "Parsing unit " & Basename (Unit));

      Result :=
        (Present      => True,
         TDH          => <>,
         Diagnostics  => <>,
         Ast_Mem_Pool => <>,
         Ast_Root     => Liblktlang_Support.Internal.Analysis.No_Internal_Node);

      Move (Saved_TDH, Unit_TDH.all);
      Initialize (Unit_TDH.all,
                  Saved_TDH.Symbols,
                  Unit.all'Address,
                  Unit.Context.Tab_Stop);

      --  This is where lexing occurs, so this is where we get most "setup"
      --  issues: missing input file, bad charset, etc. If we have such an
      --  error, catch it, turn it into diagnostics and abort parsing.
      --
      --  As it is quite common, first check if the file is readable: if not,
      --  don't bother opening it and directly emit a diagnostic. This avoid
      --  pointless exceptions which harm debugging. Note that this
      --  optimization is valid only when there is no file reader, which can
      --  work even when there is no real source file.

      if Context.File_Reader = null
         and then Input.Kind = File
         and then (Input.Filename.Is_Directory
                   or else (not Input.Filename.Is_Readable))
      then
         declare
            Name : constant String := Basename (Unit);
         begin
            GNATCOLL.Traces.Trace
              (Main_Trace, "WARNING: File is not readable: " & Name);
            Append
              (Result.Diagnostics,
               No_Source_Location_Range,
               "Cannot read " & To_Text (Name));
            Rotate_TDH;
            return;
         end;
      end if;

      --  Initialize the parser, which fetches the source buffer and extract
      --  all tokens.

      declare
         Same_Contents : Boolean;
      begin
         Init_Parser
           (Input,
            Context.With_Trivia,
            Unit,
            Unit_TDH,
            Unit.Context.Parser,
            Saved_TDH'Access,
            Same_Contents);
         if Same_Contents then
            Rotate_TDH;
            Free (Result.TDH);
            Result := (Present => False);
            return;
         end if;
      end;

      --  If we could run the lexer, run the parser and get the root node

      if Unit_TDH.Source_Buffer /= null then
         Result.Ast_Mem_Pool := Create;
         Unit.Context.Parser.Mem_Pool := Result.Ast_Mem_Pool;
         declare
            Ast_Root : constant Bare_Lkt_Node :=
              Bare_Lkt_Node
                (Parse (Unit.Context.Parser, Rule => Unit.Rule));
            function "+" is new Ada.Unchecked_Conversion
              (Bare_Lkt_Node,
               Liblktlang_Support.Internal.Analysis.Internal_Node);
         begin
            Result.Ast_Root := +Ast_Root;
         end;
      end if;

      --  Forward token data and diagnostics to the returned unit

      Rotate_TDH;
      Result.Diagnostics.Append_Vector (Unit.Context.Parser.Diagnostics);
   end Do_Parsing;

   --------------------------
   -- Update_After_Reparse --
   --------------------------

   procedure Update_After_Reparse
     (Unit : Internal_Unit; Reparsed : in out Reparsed_Unit) is
   begin
      --  If reparsing was skipped (same buffer as before), there is nothing to
      --  update.

      if not Reparsed.Present then
         return;
      end if;

      --  Remove the `symbol -> AST node` associations for Unit's nodes in
      --  foreign lexical environments.
      Remove_Exiled_Entries (Unit);

      --  Remove the named envs that Unit created
      declare
         Named_Envs_Needing_Update : NED_Maps.Map;
      begin
         Remove_Named_Envs (Unit, Named_Envs_Needing_Update);
         Update_Named_Envs (Unit.Context, Named_Envs_Needing_Update);
      end;

      --  Explicitly clear the env caches of this unit while it is still fully
      --  alive to make sure that ``Lexical_Env_Cache_Updated`` accesses valid
      --  data. Otherwise the env caches end up being cleared during the call
      --  to ``Destroy_Unit_Destroyables`` where the unit is already partially
      --  destroyed.
      Reset_Envs_Caches (Unit);

      --  At this point, envs and nodes that don't belong to this unit no
      --  longer reference this unit's envs and nodes. It is thus now safe to
      --  deallocate this unit's obsolete data.

      --  Replace Unit's diagnostics by Reparsed's
      Unit.Diagnostics := Reparsed.Diagnostics;
      Reparsed.Diagnostics.Clear;

      --  As (re-)loading a unit can change how any AST node property in the
      --  whole analysis context behaves, we have to invalidate caches. This
      --  is likely overkill, but kill all caches here as it's easy to do.
      --
      --  As an optimization, invalidate env caches only if PLE has run on this
      --  unit (U1) before: if it's the case, then envs in another unit (U2)
      --  may have cached env lookup results that would be different with the
      --  new version of U1.
      Invalidate_Caches
        (Context         => Unit.Context,
         Invalidate_Envs => (for some B of Unit.Env_Populated_Roots => B));

      --  Likewise for token data
      Free (Unit.TDH);
      Move (Unit.TDH, Reparsed.TDH);

      --  Reparsing will invalidate all lexical environments related to this
      --  unit, so destroy all related rebindings as well. This browses AST
      --  nodes, so we have to do this before destroying the old AST nodes
      --  pool.
      Destroy_Rebindings (Unit.Rebindings'Access);

      --  Destroy the old AST node and replace it by the new one
      if Unit.Ast_Root /= null then
         Destroy (Unit.Ast_Root);
      end if;
      declare
         function "+" is new Ada.Unchecked_Conversion
           (Liblktlang_Support.Internal.Analysis.Internal_Node,
            Bare_Lkt_Node);
      begin
         Unit.Ast_Root := +Reparsed.Ast_Root;
      end;

      --  Likewise for memory pools
      Free (Unit.Ast_Mem_Pool);
      Unit.Ast_Mem_Pool := Reparsed.Ast_Mem_Pool;
      Reparsed.Ast_Mem_Pool := No_Pool;

      --  Increment unit version number to invalidate caches and stale node
      --  reference. Also propagate it to the TDH.
      Unit.Unit_Version := Unit.Unit_Version + 1;
      Unit.TDH.Version := Unit.Unit_Version;

      --  Compute the PLE_Roots_Starting_Token table

      Unit.PLE_Roots_Starting_Token.Clear;

      --  Update all the lexical envs entries affected by the reparse

      declare
         Unit_Name     : constant String := +Unit.Filename.Base_Name;
         Context       : constant Internal_Context := Unit.Context;
         Foreign_Nodes : Bare_Lkt_Node_Vectors.Vector :=
           Bare_Lkt_Node_Vectors.Empty_Vector;

         Saved_In_Populate_Lexical_Env : constant Boolean :=
           Context.In_Populate_Lexical_Env;
         Saved_Env_Populated_Roots     : constant Boolean_Vectors.Vector :=
           Unit.Env_Populated_Roots;
      begin
         Context.In_Populate_Lexical_Env := True;
         if Main_Trace.Active then
            Main_Trace.Trace
              ("Updating lexical envs for " & Unit_Name & " after reparse");
            Main_Trace.Increase_Indent;
         end if;

         --  Collect all nodes that are foreign in this Unit's lexical envs.
         --  Exclude them from the corresponding lists of exiled entries.
         Extract_Foreign_Nodes (Unit, Foreign_Nodes);

         --  Temporarily reset Env_Populated_Roots so that Populate_Lexical_Env
         --  accepts to do its work on reparsed trees.

         Unit.Env_Populated_Roots := Boolean_Vectors.Empty_Vector;

         --  Now that Unit has been reparsed, we can destroy all its
         --  destroyables, which refer to the old tree (i.e. dangling
         --  pointers).
         Destroy_Unit_Destroyables (Unit);

         for FN of Foreign_Nodes loop
            declare
               Node_Image : constant String := Image (Short_Text_Image (FN));
               Unit_Name  : constant String := +FN.Unit.Filename.Base_Name;
            begin
               GNATCOLL.Traces.Trace
                 (Main_Trace, "Rerooting: " & Node_Image
                              & " (from " & Unit_Name & ")");
            end;
            Reroot_Foreign_Node (FN);
         end loop;
         Foreign_Nodes.Destroy;

         --  Re-populate all PLE roots that were requested so far for this
         --  unit. In the case where the unit has no PLE root, run PLE on the
         --  whole unit iff it was requested on at least one PLE root.

         declare
            function At_Least_One_Root_Populated return Boolean
            is (for some B of Saved_Env_Populated_Roots => B);
         begin
               if At_Least_One_Root_Populated then
                  Populate_Lexical_Env (Unit);
               end if;
         end;

         --  Restore the unit's original Env_Populated_Roots flags

         Unit.Env_Populated_Roots.Destroy;
         Unit.Env_Populated_Roots := Saved_Env_Populated_Roots;

         Context.In_Populate_Lexical_Env := Saved_In_Populate_Lexical_Env;
         if Main_Trace.Is_Active then
            Main_Trace.Decrease_Indent;
         end if;
      end;

      --  Let extension potentially add new diagnostics

      


      --  Make sure they are sorted afterwards for a better user experience

      Sort (Unit.Diagnostics);
   end Update_After_Reparse;

   -------------------------------
   -- Destroy_Unit_Destroyables --
   -------------------------------

   procedure Destroy_Unit_Destroyables (Unit : Internal_Unit) is
   begin
      for D of Unit.Destroyables loop
         D.Destroy (D.Object);
      end loop;
      Destroyable_Vectors.Clear (Unit.Destroyables);
   end Destroy_Unit_Destroyables;

   ---------------------------
   -- Remove_Exiled_Entries --
   ---------------------------

   procedure Remove_Exiled_Entries (Unit : Internal_Unit) is
   begin
      for EE of Unit.Exiled_Entries loop
         AST_Envs.Remove (EE.Env, Thin (EE.Key), EE.Node);

         --  Also strip foreign nodes information from "outer" units so that it
         --  does not contain stale information (i.e. dangling pointers to
         --  nodes that belong to the units in the queue).
         if EE.Env.Owner /= No_Generic_Unit then
            declare
               Foreign_Nodes : Foreign_Node_Entry_Vectors.Vector renames
                  Convert_Unit (EE.Env.Owner).Foreign_Nodes;
               Current       : Positive := Foreign_Nodes.First_Index;
            begin
               while Current <= Foreign_Nodes.Last_Index loop
                  if Foreign_Nodes.Get (Current).Node = EE.Node then
                     Foreign_Nodes.Pop (Current);
                  else
                     Current := Current + 1;
                  end if;
               end loop;
            end;
         end if;
      end loop;

      Unit.Exiled_Entries.Clear;
   end Remove_Exiled_Entries;

   -----------------------
   -- Remove_Named_Envs --
   -----------------------

   procedure Remove_Named_Envs
     (Unit                      : Internal_Unit;
      Named_Envs_Needing_Update : in out NED_Maps.Map) is
   begin
      --  Remove nodes in this unit from the Named_Env_Descriptor.Foreign_Nodes
      --  components in which they are registered and from the foreign
      --  environments themselves.
      for EE of Unit.Exiled_Entries_In_NED loop
         Remove (EE.Named_Env.Foreign_Nodes, EE.Key, EE.Node);
         Remove (EE.Named_Env.Env_With_Precedence, Thin (EE.Key), EE.Node);
      end loop;
      Unit.Exiled_Entries_In_NED.Clear;

      --  Remove nodes in this unit from the
      --  Named_Env_Descriptor.Nodes_With_Foreign_Env components in which they
      --  are registered.
      for Cur in Unit.Nodes_With_Foreign_Env.Iterate loop
         declare
            use Node_To_Named_Env_Maps;
            Node : constant Bare_Lkt_Node := Key (Cur);
            NE   : constant Named_Env_Descriptor_Access := Element (Cur);
         begin
            NE.Nodes_With_Foreign_Env.Delete (Node);
         end;
      end loop;
      Unit.Nodes_With_Foreign_Env.Clear;

      --  Remove ends in this unit from the Named_Env_Descriptor.Foreign_Envs
      --  components in which they are registered.
      for EE of Unit.Exiled_Envs loop
         EE.Named_Env.Foreign_Envs.Delete (Env_Node (EE.Env));
      end loop;
      Unit.Exiled_Envs.Clear;

      --  Remove named envs that this unit created
      for NE of Unit.Named_Envs loop
         declare
            NED_Access : constant Named_Env_Descriptor_Access :=
               Unit.Context.Named_Envs.Element (NE.Name);
            NED        : Named_Env_Descriptor renames NED_Access.all;
         begin
            NED.Envs.Delete (Env_Node (NE.Env));

            --  If this named environment had precedence, we must schedule an
            --  update for this name environment entry.
            if NE.Env = NED.Env_With_Precedence then
               Named_Envs_Needing_Update.Include (NE.Name, NED_Access);
               NED.Env_With_Precedence := Empty_Env;
            end if;
         end;
      end loop;
      Unit.Named_Envs.Clear;
   end Remove_Named_Envs;

   ---------------------------
   -- Extract_Foreign_Nodes --
   ---------------------------

   procedure Extract_Foreign_Nodes
     (Unit          : Internal_Unit;
      Foreign_Nodes : in out Bare_Lkt_Node_Vectors.Vector) is
   begin
      --  Go through all foreign nodes registered in Unit's lexical
      --  environments.
      for FN of Unit.Foreign_Nodes loop
         --  Collect them
         Foreign_Nodes.Append (FN.Node);

         --  For each foreign node, remove the corresponding exiled entry in
         --  that foreign unit (each foreign node in unit A has a corresponding
         --  exiled entry in unit B).
         declare
            Exiled_Entries : Exiled_Entry_Vectors.Vector renames
               FN.Unit.Exiled_Entries;
            Current        : Positive := Exiled_Entries.First_Index;
         begin
            while Current <= Exiled_Entries.Last_Index loop
               if Exiled_Entries.Get (Current).Node = FN.Node then
                  Exiled_Entries.Pop (Current);
               else
                  Current := Current + 1;
               end if;
            end loop;
         end;
      end loop;
      Unit.Foreign_Nodes.Clear;
   end Extract_Foreign_Nodes;

   --------------------------
   -- Reroot_Foreign_Nodes --
   --------------------------

   procedure Reroot_Foreign_Node (Node : Bare_Lkt_Node) is
      Unit : constant Internal_Unit := Node.Unit;
   begin
      --  First, filter the exiled entries in foreign units so that they don't
      --  contain references to this unit's lexical environments.  We need to
      --  do that before running the partial Populate_Lexical_Env pass so that
      --  we don't remove exiled entries that this pass will produce.
      declare
         Exiled_Entries : Exiled_Entry_Vectors.Vector renames
            Unit.Exiled_Entries;
         Current        : Positive := Exiled_Entries.First_Index;
      begin
         while Current <= Exiled_Entries.Last_Index loop
            if Exiled_Entries.Get (Current).Node = Node then
               Exiled_Entries.Pop (Current);
            else
               Current := Current + 1;
            end if;
         end loop;
      end;

      --  Re-do a partial Populate_Lexical_Env pass for each foreign node that
      --  this unit contains so that they are relocated in our new lexical
      --  environments.
      declare
         Unit_State : aliased PLE_Unit_State :=
           (Named_Envs_Needing_Update => <>);
         State      : PLE_Node_State :=
           (Unit_State  => Unit_State'Unchecked_Access,
            Current_Env => Node.Self_Env,
            Current_NED => null);
      begin
         Pre_Env_Actions (Node, State, Add_To_Env_Only => True);
         Post_Env_Actions (Node, State);
      end;
   end Reroot_Foreign_Node;

   ----------
   -- Text --
   ----------

   function Text (Node : Bare_Lkt_Node) return String_Type is
   begin
      return Create_String (Text (Node));
   end Text;

   ------------------------
   -- Destroy_Rebindings --
   ------------------------

   procedure Destroy_Rebindings
     (Rebindings : access Env_Rebindings_Vectors.Vector)
   is
      procedure Recurse (R : in out Env_Rebindings);
      --  Destroy R's children and then destroy R. It is up to the caller to
      --  remove R from its parent's Children vector.

      procedure Unregister
        (R          : Env_Rebindings;
         Rebindings : in out Env_Rebindings_Vectors.Vector);
      --  Remove R from Rebindings

      -------------
      -- Recurse --
      -------------

      procedure Recurse (R : in out Env_Rebindings) is
      begin
         for C of R.Children loop
            declare
               C_Var : Env_Rebindings := C;
            begin
               Recurse (C_Var);
            end;
         end loop;
         R.Children.Destroy;

         Unregister (R, Convert_Unit (R.Old_Env.Owner).Rebindings);
         Unregister (R, Convert_Unit (R.New_Env.Owner).Rebindings);

         Release_Rebinding (R);
      end Recurse;

      ----------------
      -- Unregister --
      ----------------

      procedure Unregister
        (R          : Env_Rebindings;
         Rebindings : in out Env_Rebindings_Vectors.Vector) is
      begin
         for I in 1 .. Rebindings.Length loop
            if Rebindings.Get (I) = R then
               Rebindings.Pop (I);
               return;
            end if;
         end loop;

         --  We are always supposed to find R in Rebindings, so this should be
         --  unreachable.
         raise Program_Error;
      end Unregister;

   begin
      while Rebindings.Length > 0 loop
         declare
            R : Env_Rebindings := Rebindings.Get (1);
         begin
            --  Here, we basically undo what has been done in AST_Envs.Append

            --  If this rebinding has no parent, then during its creation we
            --  registered it in its Old_Env. Otherwise, it is registered
            --  in its Parent's Children list.
            if R.Parent = null then
               Unwrap (R.Old_Env).Rebindings_Pool.Delete (R.New_Env);
            else
               Unregister (R, R.Parent.Children);
            end if;

            --  In all cases it's registered in Old_Env's and New_Env's units
            Recurse (R);
         end;
      end loop;
   end Destroy_Rebindings;

   -----------------------
   -- Create_Safety_Net --
   -----------------------

   function Create_Safety_Net
     (Context : Internal_Context) return Iterator_Safety_Net
   is
   begin
      return (Context         => Context,
              Context_Serial  => Context.Serial_Number,
              Context_Version => Context.Cache_Version);
   end Create_Safety_Net;

   ----------------------
   -- Check_Safety_Net --
   ----------------------

   procedure Check_Safety_Net (Self : Iterator_Safety_Net) is
   begin
      if Self.Context = null then
         return;
      end if;

      --  Check that the context is still the same (not released nor reused)
      if Self.Context.Serial_Number /= Self.Context_Serial
         or else Self.Context.Cache_Version /= Self.Context_Version
      then
         raise Stale_Reference_Error;
      end if;
   end Check_Safety_Net;

   ----------------------
   -- String_To_Symbol --
   ----------------------

   function String_To_Symbol
     (Self    : Bare_Lkt_Node;
      Context : Internal_Context;
      S       : String_Type) return Symbol_Type is
   begin
      return (if S.Length > 0
              then Lookup_Symbol (Context, S.Content)
              else No_Symbol);
   exception
      when Exc : Invalid_Symbol_Error =>
         Raise_Property_Exception
           (Self,
            Property_Error'Identity,
            Ada.Exceptions.Exception_Message (Exc));
   end String_To_Symbol;

   -------------
   -- Inc_Ref --
   -------------

   procedure Inc_Ref (Self : String_Type) is
   begin
      if Self.Ref_Count >= 0 then
         Self.Ref_Count := Self.Ref_Count + 1;
      end if;
   end Inc_Ref;

   -------------
   -- Dec_Ref --
   -------------

   procedure Dec_Ref (Self : in out String_Type) is
   begin
      if Self = null or else Self.Ref_Count < 0 then
         return;
      end if;

      if Self.Ref_Count = 1 then
         Free (Self);
      else
         Self.Ref_Count := Self.Ref_Count - 1;
         Self := null;
      end if;
   end Dec_Ref;

   -------------------
   -- Create_String --
   -------------------

   function Create_String (Content : Text_Type) return String_Type is
   begin
      return Result : constant String_Type := new String_Record'
        (Length    => Content'Length,
         Ref_Count => 1,
         Content   => Content);
   end Create_String;

   -------------------
   -- Create_String --
   -------------------

   function Create_String (Content : Unbounded_Text_Type) return String_Type is
      S : Big_Wide_Wide_String_Access;
      L : Natural;
   begin
      Get_Wide_Wide_String (Content, S, L);
      return Create_String (S.all (1 .. L));
   end Create_String;

   -------------------
   -- Concat_String --
   -------------------

   function Concat_String (Left, Right : String_Type) return String_Type is
   begin
      return Result : constant String_Type :=
        new String_Record (Length => Left.Length + Right.Length)
      do
         Result.Ref_Count := 1;
         Result.Content (1 .. Left.Length) := Left.Content;
         Result.Content (Left.Length + 1 .. Result.Length) := Right.Content;
      end return;
   end Concat_String;

   ----------------
   -- Equivalent --
   ----------------

   function Equivalent (Left, Right : String_Type) return Boolean is
   begin
      return Left.Content = Right.Content;
   end Equivalent;

begin
   No_Big_Integer.Value.Set (0);
end Liblktlang.Implementation;
