
import lexer_example

@with_lexer(foo_lexer)
grammar foo_grammar {
    # Test that diagnostics emitted after a Cut are properly reset when the Or
    # parser which triggered the rule that created the diagonstics backtracks
    # and tries another alternative.
    @main_rule stmt_rule <- list*(or(var_decl | unit_test | recursion_test))
    var_decl <- VarDecl("var" name "=" name !";")
    name <- Name(@Identifier)

    # Test the formatting of diagnostics for various "!" subparsers
    unit_test <- or(
        | EmptyNode(@Identifier("token_name") / discard(!Name(@Identifier)))
        | EmptyNode(@Identifier("token_lit") / discard(!Name("-")))
        | EmptyNode(
            @Identifier("skip")
            /
            discard(
                !(discard(EmptyNode() |> when(FooNode.my_pred)) skip(MyError))
            )
        )
        | EmptyNode(
            @Identifier("dont_skip") / discard(!name.dont_skip(@Identifier))
        )
        | EmptyNode(
            @Identifier("or")
            /
            discard(!or(Name(@Identifier) | Number(@Number)))
        )
        | EmptyNode(@Identifier("list") / discard(!list+(Name(@Identifier))))
        | EmptyNode(
            @Identifier("opt") / discard(!pick(?Name(@Identifier) "example"))
        )
        | EmptyNode(
            @Identifier("pick") / discard(!pick("example" Name(@Identifier)))
        )
        | EmptyNode(@Identifier("discard") / !discard(var_decl) discard(name))
        | EmptyNode(@Identifier("defer") / discard(!name))
        | EmptyNode(
            @Identifier("transform") / discard(!VarDecl("var" name "=" name))
        )
        | EmptyNode(
            @Identifier("null_tok") / discard(!pick(null(FooNode) "example"))
        )
        | EmptyNode(
            @Identifier("predicate")
            /
            discard(!(name |> when(FooNode.my_pred)))
        )
        | EmptyNode(
            @Identifier("stop_cut") / discard(!stop_cut(Name(@Identifier)))
        )
        | EmptyNode(
            @Identifier("cut") / discard( !or(/ Name(@Identifier) | var_decl))
        )
    )

    # Test the formatting of diagnostics when recursion is involved
    recursion_test <- pick(@Identifier("recursion_test") !expr)
    expr <- or(
        | DotExpr(expr "." name)
        | name
        | Number(@Number)
    )
}

@abstract
class FooNode implements Node[FooNode] {
    fun my_pred(): Bool = false
}

@abstract
class Expr: FooNode {
}

class Name: Expr implements TokenNode {
}

class Number: Expr implements TokenNode {
}

class DotExpr: Expr {
    @parse_field prefix: Expr
    @parse_field suffix: Name
}

class VarDecl: FooNode {
    @parse_field name: Name
    @parse_field value: Name
}

class EmptyNode: FooNode {
}

class MyError: FooNode implements ErrorNode {
}
