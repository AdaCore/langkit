== analysis.adb ==

Language name: Foo

Grammar rules:
  Main_Rule (default) (public): Foo_Node_List
    doc: "Parser main entry point\x0a"
  Null_Qual: Null_Qual
  Var_Decl: Var_Decl
  Def: Def
  Expr (public): Expr
    doc: "Use this to parse\x0aany kind of expression.\x0a"
  Call: Call
  Atom: Expr
  Number: Number
  Ref: Ref
  Name: Name

Token kinds:
  Colon (Punctuation)
  Comma (Punctuation)
  Comment (Comments, is_comment)
  Def (Alphanumericals)
  Dot (Punctuation)
  Equal (Punctuation)
  Error (Alphanumericals)
  Example (Alphanumericals)
  Greater_Than (Default_Family)
  Greater_Than_Or_Equal (Default_Family)
  Identifier (Alphanumericals)
  Kw_A (Alphanumericals)
  Kw_B (Alphanumericals)
  Kw_C (Alphanumericals)
  Kw_D (Alphanumericals)
  Kw_E (Alphanumericals)
  Kw_F (Alphanumericals)
  L_Brace (Punctuation)
  L_Par (Punctuation)
  Less_Than (Default_Family)
  Less_Than_Or_Equal (Default_Family)
  Lexing_Failure (Default_Family)
  Minus (Default_Family)
  Null (Alphanumericals)
  Number (Alphanumericals)
  Plus (Punctuation)
  R_Brace (Punctuation)
  R_Par (Punctuation)
  Semicolon (Punctuation)
  String (Default_Family)
  Termination (Default_Family)
  Var (Alphanumericals)
  Whitespace (Default_Family)

Token families:
  Alphanumericals
  Comments
  Punctuation
  Default_Family

Use of null token kind:
Got a Precondition_Failure exception: null token kind reference

Use of null context:
Got a Precondition_Failure exception: null context

Use of null unit:
No_Lk_Unit.Root: Got a Precondition_Failure exception: null unit
No_Lk_Unit.Charset: Got a Precondition_Failure exception: null unit

Use of null node:
Got a Precondition_Failure exception: null node

Has_With_Trivia on null context:
Got a Precondition_Failure exception: null context

Create_Context (With_Trivia => <>): Has_With_Trivia = TRUE
Create_Context (With_Trivia => False): Has_With_Trivia = FALSE
Create_Context (With_Trivia => True): Has_With_Trivia = TRUE

Parsing example.txt...
Has example.txt? -> TRUE
Has foo.txt? -> FALSE
Line 2:
  "var a = 0;"
Traversing its parsing tree...
<FooNodeList example.txt:1:1-3:15>
<Example example.txt:1:1-1:12>
<Name example.txt:1:9-1:12>
<VarDecl example.txt:2:1-2:11>
<NullQualAbsent example.txt:1:12-1:12>
<Name example.txt:2:5-2:6>
<Number example.txt:2:9-2:10>
<VarDecl example.txt:3:1-3:15>
<NullQualAbsent example.txt:2:11-2:11>
<Name example.txt:3:5-3:6>
<Addition example.txt:3:9-3:14>
<Number example.txt:3:9-3:10>
<Ref example.txt:3:13-3:14>
<Name example.txt:3:13-3:14>

Unit.Text -> "example foo\x0avar a = 0;\x0avar b = 1 + a;\x0a# Comment\x0a"
No_Lk_Unit.Text -> Got a Precondition_Failure exception: null node

Testing Get_From_Buffer
Base:
ASTList[FooNode][1:1-1:13]
|  VarDecl[1:1-1:13]
|  |f_is_null:
|  |  NullQual.Absent[1:1-1:1]
|  |f_name:
|  |  Name[1:5-1:8]: foo
|  |f_value:
|  |  Number[1:11-1:12]: 1
Reparsed:
ASTList[FooNode][1:1-1:12]
|  Example[1:1-1:12]
|  |f_fld_2: <null>
|  |f_fld_1:
|  |  Name[1:9-1:12]: foo
Custom rule:
Name[1:1-1:6]: my_id

Testing Reparse_From_File
Base:
ASTList[FooNode][1:1-1:13]
|  VarDecl[1:1-1:13]
|  |f_is_null:
|  |  NullQual.Absent[1:1-1:1]
|  |f_name:
|  |  Name[1:5-1:8]: foo
|  |f_value:
|  |  Number[1:11-1:12]: 1
Reparsed:
ASTList[FooNode][1:1-3:15]
|  Example[1:1-1:12]
|  |f_fld_2: <null>
|  |f_fld_1:
|  |  Name[1:9-1:12]: foo
|  VarDecl[2:1-2:11]
|  |f_is_null:
|  |  NullQual.Absent[1:12-1:12]
|  |f_name:
|  |  Name[2:5-2:6]: a
|  |f_value:
|  |  Number[2:9-2:10]: 0
|  VarDecl[3:1-3:15]
|  |f_is_null:
|  |  NullQual.Absent[2:11-2:11]
|  |f_name:
|  |  Name[3:5-3:6]: b
|  |f_value:
|  |  Addition[3:9-3:14]
|  |  |f_lhs:
|  |  |  Number[3:9-3:10]: 1
|  |  |f_rhs:
|  |  |  Ref[3:13-3:14]
|  |  |  |f_name:
|  |  |  |  Name[3:13-3:14]: a

Testing Reparse_From_Buffer
Base:
ASTList[FooNode][1:1-1:13]
|  VarDecl[1:1-1:13]
|  |f_is_null:
|  |  NullQual.Absent[1:1-1:1]
|  |f_name:
|  |  Name[1:5-1:8]: foo
|  |f_value:
|  |  Number[1:11-1:12]: 1
Reparsed:
ASTList[FooNode][1:1-1:13]
|  VarDecl[1:1-1:13]
|  |f_is_null:
|  |  NullQual.Absent[1:1-1:1]
|  |f_name:
|  |  Name[1:5-1:8]: bar
|  |f_value:
|  |  Number[1:11-1:12]: 2

Testing diagnostics-related primitives
without_error.txt:
  Charset: utf-8
  Has_Diagnostics? FALSE
with_error.txt:
  Charset: ascii
  Has_Diagnostics? TRUE
  with_error.txt:1:1: Skipped token var
  with_error.txt:1:5: Skipped token foo
  with_error.txt:1:9: Skipped token =
  with_error.txt:1:11: Skipped token 1
nosuchfile.txt:
  Charset: utf-8
  Has_Diagnostics? TRUE
  nosuchfile.txt: Cannot read nosuchfile.txt

Testing Print debug helpers for units:
without_error.txt:
ASTList[FooNode][1:1-1:13]
|  VarDecl[1:1-1:13]
|  |f_is_null:
|  |  NullQual.Absent[1:1-1:1]
|  |f_name:
|  |  Name[1:5-1:8]: foo
|  |f_value:
|  |  Number[1:11-1:12]: 1

with_error.txt:
with_error.txt:1:1: Skipped token var
with_error.txt:1:5: Skipped token foo
with_error.txt:1:9: Skipped token =
with_error.txt:1:11: Skipped token 1
ASTList[FooNode][1:1-1:12]
|  ErrorDecl[1:1-1:4]
|  ErrorDecl[1:5-1:8]
|  ErrorDecl[1:9-1:10]
|  ErrorDecl[1:11-1:12]

nosuchfile.txt:
nosuchfile.txt: Cannot read nosuchfile.txt
<no parse tree>

Testing various node operations:
Root.Is_Null -> FALSE
Root.Next_Sibling.Image -> None
Root.Next_Sibling.Is_Null -> TRUE
No_Lk_Node.Next_Sibling.Is_Null -> Got a Precondition_Failure exception: null node
No_Lk_Node.Previous_Sibling.Is_Null -> Got a Precondition_Failure exception: null node
Root.Child (2).Image -> <VarDecl example.txt:2:1-2:11>
Root.Child (2).Previous_Sibling.Image -> <Example example.txt:1:1-1:12>
[...].Previous_Sibling = [...] -> TRUE
[...].Previous_Sibling = [...].Previous_Sibling.Next_Sibling -> FALSE
Root.Children:
  -> <Example example.txt:1:1-1:12>
  -> <VarDecl example.txt:2:1-2:11>
  -> <VarDecl example.txt:3:1-3:15>

Parents (<NullQualAbsent example.txt:1:12-1:12>, With_Self => FALSE):
  <VarDecl example.txt:2:1-2:11>
  <FooNodeList example.txt:1:1-3:15>
Parents (<NullQualAbsent example.txt:1:12-1:12>, With_Self => TRUE):
  <NullQualAbsent example.txt:1:12-1:12>
  <VarDecl example.txt:2:1-2:11>
  <FooNodeList example.txt:1:1-3:15>
Parents (No_Lk_Node) = Got a Precondition_Failure exception: null node

Is_Ghost (<FooNodeList example.txt:1:1-3:15>) = FALSE
Is_Ghost (<NullQualAbsent example.txt:1:12-1:12>) = TRUE
Is_Ghost (No_Lk_Node) = Got a Precondition_Failure exception: null node

Root.Text -> "example foo\x0avar a = 0;\x0avar b = 1 + a;"
No_Lk_Node.Text -> Got a Precondition_Failure exception: null node

Root.Sloc_Range -> 1:1-3:15
No_Lk_Node.Sloc_Range -> Got a Precondition_Failure exception: null node

First_Child.Compare ((1, 1)) -> INSIDE
First_Child.Compare ((4, 1)) -> AFTER
No_Lk_Node.Compare ((1, 1)) -> Got a Precondition_Failure exception: null node

No_Lk_Node.Lookup (1, 1) -> None
Root.Lookup (2, 7) -> <VarDecl example.txt:2:1-2:11>

Root.Is_Incomplete -> FALSE
No_Lk_Node.Is_Incomplete -> Got a Precondition_Failure exception: null node

Root.Print (without slocs)
... ASTList[FooNode]
... |  Example
... |  |f_fld_2: <null>
... |  |f_fld_1:
... |  |  Name: foo
... |  VarDecl
... |  |f_is_null:
... |  |  NullQual.Absent
... |  |f_name:
... |  |  Name: a
... |  |f_value:
... |  |  Number: 0
... |  VarDecl
... |  |f_is_null:
... |  |  NullQual.Absent
... |  |f_name:
... |  |  Name: b
... |  |f_value:
... |  |  Addition
... |  |  |f_lhs:
... |  |  |  Number: 1
... |  |  |f_rhs:
... |  |  |  Ref
... |  |  |  |f_name:
... |  |  |  |  Name: a
Root.Print (with slocs)
... ASTList[FooNode][1:1-3:15]
... |  Example[1:1-1:12]
... |  |f_fld_2: <null>
... |  |f_fld_1:
... |  |  Name[1:9-1:12]: foo
... |  VarDecl[2:1-2:11]
... |  |f_is_null:
... |  |  NullQual.Absent[1:12-1:12]
... |  |f_name:
... |  |  Name[2:5-2:6]: a
... |  |f_value:
... |  |  Number[2:9-2:10]: 0
... |  VarDecl[3:1-3:15]
... |  |f_is_null:
... |  |  NullQual.Absent[2:11-2:11]
... |  |f_name:
... |  |  Name[3:5-3:6]: b
... |  |f_value:
... |  |  Addition[3:9-3:14]
... |  |  |f_lhs:
... |  |  |  Number[3:9-3:10]: 1
... |  |  |f_rhs:
... |  |  |  Ref[3:13-3:14]
... |  |  |  |f_name:
... |  |  |  |  Name[3:13-3:14]: a
No_Lk_Node.Print -> Got a Precondition_Failure exception: null node

Check the equality operator for nodes
Got a Stale_Reference_Error exception: unit was reparsed

Testing various token operations:
No_Lk_Token.Is_Null -> TRUE
First_Token.Is_Null -> FALSE

Checking the Token->Unit backlink...
No_Lk_Token.Unit -> Got a Precondition_Failure exception: null token

Token_Count -> 15
Trivia_Count -> 14

First_Token.Kind -> Example
Last_Token.Kind -> Termination
No_Lk_Token.Kind -> Got a Precondition_Failure exception: null token

No_Lk_Token.Image -> <No Token>
First_Token.Image -> <Token Kind=Example Text="example">
Last_Token.Image -> <Token Kind=Termination Text="">
Comment_Tok.Image -> <Token Kind=Comment Text="# Comment">
Last_Token.Previous.Image -> <Token Kind=Whitespace Text="\x0a">

First_Token.Text -> "example"
Last_Token.Text -> ""
No_Lk_Token.Text -> Got a Precondition_Failure exception: null token

No_Lk_Token.Next -> <No Token>
First_Token.Next -> <Token Kind=Whitespace Text=" ">
Last_Token.Next -> <No Token>

No_Lk_Token.Previous -> <No Token>
First_Token.Previous -> <No Token>
Last_Token.Previous -> <Token Kind=Whitespace Text="\x0a">

No_Token.Is_Trivia -> FALSE
First_Token.Is_Trivia -> FALSE
Last_Token.Is_Trivia -> FALSE
Last_Token.Previous.Is_Trivia -> TRUE

First_Token.Index -> 1
Last_Token.Index -> 15

No_Token.Is_Comment -> FALSE
First_Token.Is_Comment -> FALSE
Last_Token.Is_Comment -> FALSE
Comment_Tok.Is_Comment -> TRUE

Lookup_Token ((1, 1)).Image -> <Token Kind=Example Text="example">
Lookup_Token ((2, 1)).Image -> <Token Kind=Var Text="var">
No_Lk_Unit.Lookup_Token ((1, 1)) -> Got a Precondition_Failure exception: null unit

Testing comparison operators for various cases:
First_Token < Last_Token: -> TRUE
First_Token < No_Lk_Token: -> Got a Precondition_Failure exception: tokens from different units
No_Lk_Token < Last_Token: -> Got a Precondition_Failure exception: tokens from different units
First_Token < Other_Unit -> Got a Precondition_Failure exception: tokens from different units
First_Token < Stale -> Got a Stale_Reference_Error exception: unit was reparsed
Stale < Last_Token -> Got a Stale_Reference_Error exception: unit was reparsed

Testing consistency of all comparison operators:
         | <  | <= | >  | >=
T1 OP T1 |  F |  T |  F |  T
T1 OP T2 |  T |  T |  F |  F
T2 OP T1 |  F |  F |  T |  T
T2 OP T2 |  F |  T |  F |  T

Testing text range for various cases:
First_Token .. Last_Token: -> "example foo\x0avar a = 0;\x0avar b = 1 + a;\x0a# Comment\x0a"
First_Token .. No_Lk_Token: -> Got a Precondition_Failure exception: tokens from different units
No_Lk_Token .. Last_Token: -> Got a Precondition_Failure exception: tokens from different units
First_Token .. Other_Unit -> Got a Precondition_Failure exception: tokens from different units
First_Token .. Stale -> Got a Stale_Reference_Error exception: unit was reparsed
Stale .. Last_Token -> Got a Stale_Reference_Error exception: unit was reparsed

Testing token equivalence for various cases:
  Null token references...
  Is_Equivalent (<No Token>, <Token Kind=Example Text="example">) = Got a Precondition_Failure exception: null token
  Is_Equivalent (<Token Kind=Example Text="example">, <No Token>) = Got a Precondition_Failure exception: null token

  Different kinds...
  Is_Equivalent (<Token Kind=Example Text="example">, <Token Kind=Var Text="var">) = FALSE
  Is_Equivalent (<Token Kind=Equal Text="=">, <Token Kind=Var Text="var">) = FALSE

  Same kind on literal-matched tokens...
  Is_Equivalent (<Token Kind=Var Text="var">, <Token Kind=Var Text="var">) = TRUE
  Is_Equivalent (<Token Kind=Equal Text="=">, <Token Kind=Equal Text=":=">) = TRUE

  Same kind on symbolized tokens...
  Is_Equivalent (<Token Kind=Identifier Text="a">, <Token Kind=Identifier Text="c">) = FALSE
  Is_Equivalent (<Token Kind=Identifier Text="a">, <Token Kind=Identifier Text="a">) = TRUE

  Same kind on pattern-matched tokens...
  Is_Equivalent (<Token Kind=Number Text="0">, <Token Kind=Number Text="2">) = FALSE
  Is_Equivalent (<Token Kind=Number Text="0">, <Token Kind=Number Text="0">) = TRUE

  Stale references...
  Got a Stale_Reference_Error exception: unit was reparsed
  Got a Stale_Reference_Error exception: unit was reparsed

Use of stale node reference:
Got a Stale_Reference_Error exception: unit was reparsed

Check generic/specific context type converters
<FooNodeList foo.txt:1:1-1:12>

Check generic/specific unit type converters
<FooNodeList example.txt:1:1-3:15>

Check generic/specific node type converters
Root from specific: <FooNodeList example.txt:1:1-3:15>
Root from generic: <FooNodeList example.txt:1:1-3:15>

Check generic/specific grammar rule converters
MAIN_RULE_RULE -> Main_Rule
NULL_QUAL_RULE -> Null_Qual
VAR_DECL_RULE -> Var_Decl
DEF_RULE -> Def
EXPR_RULE -> Expr
CALL_RULE -> Call
ATOM_RULE -> Atom
NUMBER_RULE -> Number
REF_RULE -> Ref
NAME_RULE -> Name
Check error case... Got a Precondition_Failure exception: null grammar rule

Check that equality takes metadata into account
N = N2 (same metadata): TRUE
N = N2 (/= metadata, field not used in eq): TRUE
N = N2 (/= metadata, field used in eq): FALSE

Root.Children_And_Trivia:
  Node: <Example example.txt:1:1-1:12>
  Token: <Token Kind=Whitespace Text="\x0a">
  Node: <VarDecl example.txt:2:1-2:11>
  Token: <Token Kind=Whitespace Text="\x0a">
  Node: <VarDecl example.txt:3:1-3:15>
No_Lk_Node.Children_And_Trivia: Got a Precondition_Failure exception: null node

== introspection_types.adb ==

All types
=========

* AnalysisUnit
  ANALYSIS_UNIT_CATEGORY
* BigInt
  BIG_INT_CATEGORY
* Bool
  BOOL_CATEGORY
* Char
  CHAR_CATEGORY
* Int
  INT_CATEGORY
* SourceLocation
  SOURCE_LOCATION_CATEGORY
* SourceLocationRange
  SOURCE_LOCATION_RANGE_CATEGORY
* String
  STRING_CATEGORY
* Token
  TOKEN_CATEGORY
* Symbol
  SYMBOL_CATEGORY
* AnalysisUnitKind
  ENUM_CATEGORY
  is an enum
* CompletionItemKind
  ENUM_CATEGORY
  is an enum
* DesignatedEnvKind
  ENUM_CATEGORY
  is an enum
* GrammarRule
  ENUM_CATEGORY
  is an enum
* LookupKind
  ENUM_CATEGORY
  is an enum
* BigInt.array
  ARRAY_CATEGORY
  is an array
* FooNode.array
  ARRAY_CATEGORY
  is an array
* Expr.array
  ARRAY_CATEGORY
  is an array
* AnalysisUnit.array
  ARRAY_CATEGORY
  is an array
* BigInt.iterator
  ITERATOR_CATEGORY
  is an iterator
* NodeResult
  STRUCT_CATEGORY
  is a struct
* Point
  STRUCT_CATEGORY
  is a struct
  Documentation:
  |Documentation for the Point struct.
  |
  |* ``label`` provides a human readable description of the point.
  |* ``x`` provides its coordinate along the X axis.
  |* ``y`` provides its coordinate along the Y axis.
  |
  |For example:
  |
  |.. code-block:: text
  |
  |   Point("origin", 0, 0)
* FooNode
  STRUCT_CATEGORY
  is a node
* BaseExample
  STRUCT_CATEGORY
  is a node
* Example
  STRUCT_CATEGORY
  is a node
* Def
  STRUCT_CATEGORY
  is a node
* ErrorDecl
  STRUCT_CATEGORY
  is a node
* Expr
  STRUCT_CATEGORY
  is a node
* Addition
  STRUCT_CATEGORY
  is a node
* Call
  STRUCT_CATEGORY
  is a node
* Number
  STRUCT_CATEGORY
  is a node
* Ref
  STRUCT_CATEGORY
  is a node
* FooNodeBaseList
  STRUCT_CATEGORY
  is a node
* ASTList[Expr]
  STRUCT_CATEGORY
  is a node
* ASTList[FooNode]
  STRUCT_CATEGORY
  is a node
* ASTList[Name]
  STRUCT_CATEGORY
  is a node
* Name
  STRUCT_CATEGORY
  is a node
* NullQual
  STRUCT_CATEGORY
  is a node
* NullQual.Absent
  STRUCT_CATEGORY
  is a node
* NullQual.Present
  STRUCT_CATEGORY
  is a node
* SynthNode
  STRUCT_CATEGORY
  is a node
* VarDecl
  STRUCT_CATEGORY
  is a node

Language: null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
To_Index: Null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
From_Index: out of range type index: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid type index
Debug_Name: Null T argument: <No_Type_Ref>
Category: Null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Enum types
==========

Analysis_Unit_Kind ( 11)
  Default value: <No_Enum_Value_Ref>

  1: Unit_Specification
  2: Unit_Body

Completion_Item_Kind ( 12)
  Default value: <No_Enum_Value_Ref>

  1: Text_Kind
  2: Method_Kind
  3: Function_Kind
  4: Constructor_Kind
  5: Field_Kind
  6: Variable_Kind
  7: Class_Kind
  8: Interface_Kind
  9: Module_Kind
  10: Property_Kind
  11: Unit_Kind
  12: Value_Kind
  13: Enum_Kind
  14: Keyword_Kind
  15: Snippet_Kind
  16: Color_Kind
  17: File_Kind
  18: Reference_Kind
  19: Folder_Kind
  20: Enum_Member_Kind
  21: Constant_Kind
  22: Struct_Kind
  23: Event_Kind
  24: Operator_Kind
  25: Type_Parameter_Kind

Designated_Env_Kind ( 13)
  Default value: DesignatedEnvKind.none

  1: None
  2: Current_Env
  3: Named_Env
  4: Direct_Env

Grammar_Rule ( 14)
  Default value: <No_Enum_Value_Ref>

  1: Main_Rule_Rule
  2: Null_Qual_Rule
  3: Var_Decl_Rule
  4: Def_Rule
  5: Expr_Rule
  6: Call_Rule
  7: Atom_Rule
  8: Number_Rule
  9: Ref_Rule
  10: Name_Rule

Lookup_Kind ( 15)
  Default value: <No_Enum_Value_Ref>

  1: Recursive
  2: Flat
  3: Minimal

Is_Enum_Type: Null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference

Invalid args for Enum_Type_Name:
Null Enum argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-enum Enum argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid enum type

Invalid args for Enum_Last_Value:
Null Enum argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-enum Enum argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid enum type

Invalid args for Enum_Default_Value:
Null Enum argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-enum Enum argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid enum type

Enum_Value_Name: Null Value argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null enum value reference

To_Index: Null Value argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null enum value reference
From_Index: out of range enum value index: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid enum value index

Arrays
======

BigInt.array
Array of BigInt

FooNode.array
Array of FooNode

Expr.array
Array of Expr

AnalysisUnit.array
Array of AnalysisUnit

Is_Array_Type: Null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference

Invalid args for Array_Element_Type:
Null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-array T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid array type

Iterator types
==============

BigInt.iteratorIterator of BigInt

Is_Iterator_Type: Null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference

Invalid args for Iterator_Element_Type:
Null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-iterator T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid iterator type

Structs
=======

Node_Result

Point

Is_Struct_Type: Null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference

Invalid args for Struct_Type_Name:
Null Struct argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-struct Struct argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid struct type

Nodes
=====

Foo_Node ( 23)
  is abstract
  base = Bad_Type_Error: trying to get base type of root node
  last derivation = Var_Decl ( 42)
  derivations:
    Base_Example ( 24)
    Def ( 26)
    Error_Decl ( 27)
    Expr ( 28)
    Foo_Node_Base_List ( 33)
    Name ( 37)
    Null_Qual ( 38)
    Synth_Node ( 41)
    Var_Decl ( 42)

Base_Example ( 24)
  is abstract
  base = Foo_Node ( 23)
  last derivation = Example ( 25)
  derivations:
    Example ( 25)

Example ( 25)
  base = Base_Example ( 24)
  last derivation = Example ( 25)
  derivations:
    <none>

Def ( 26)
  base = Foo_Node ( 23)
  last derivation = Def ( 26)
  derivations:
    <none>

Error_Decl ( 27)
  is an error node
  base = Foo_Node ( 23)
  last derivation = Error_Decl ( 27)
  derivations:
    <none>

Expr ( 28)
  is abstract
  base = Foo_Node ( 23)
  last derivation = Ref ( 32)
  derivations:
    Addition ( 29)
    Call ( 30)
    Number ( 31)
    Ref ( 32)

Addition ( 29)
  base = Expr ( 28)
  last derivation = Addition ( 29)
  derivations:
    <none>

Call ( 30)
  base = Expr ( 28)
  last derivation = Call ( 30)
  derivations:
    <none>

Number ( 31)
  is a token node (Number token)
  base = Expr ( 28)
  last derivation = Number ( 31)
  derivations:
    <none>

Ref ( 32)
  base = Expr ( 28)
  last derivation = Ref ( 32)
  derivations:
    <none>

Foo_Node_Base_List ( 33)
  is abstract
  base = Foo_Node ( 23)
  last derivation = Name_List ( 36)
  derivations:
    Expr_List ( 34)
    Foo_Node_List ( 35)
    Name_List ( 36)

Expr_List ( 34)
  is a list node
  element type = Expr ( 28)
  base = Foo_Node_Base_List ( 33)
  last derivation = Expr_List ( 34)
  derivations:
    <none>

Foo_Node_List ( 35)
  is a list node
  element type = Foo_Node ( 23)
  base = Foo_Node_Base_List ( 33)
  last derivation = Foo_Node_List ( 35)
  derivations:
    <none>

Name_List ( 36)
  is a list node
  element type = Name ( 37)
  base = Foo_Node_Base_List ( 33)
  last derivation = Name_List ( 36)
  derivations:
    <none>

Name ( 37)
  is a token node (Identifier token)
  base = Foo_Node ( 23)
  last derivation = Name ( 37)
  derivations:
    <none>

Null_Qual ( 38)
  is abstract
  base = Foo_Node ( 23)
  last derivation = Null_Qual_Present ( 40)
  derivations:
    Null_Qual_Absent ( 39)
    Null_Qual_Present ( 40)

Null_Qual_Absent ( 39)
  base = Null_Qual ( 38)
  last derivation = Null_Qual_Absent ( 39)
  derivations:
    <none>

Null_Qual_Present ( 40)
  base = Null_Qual ( 38)
  last derivation = Null_Qual_Present ( 40)
  derivations:
    <none>

Synth_Node ( 41)
  is synthetic
  base = Foo_Node ( 23)
  last derivation = Synth_Node ( 41)
  derivations:
    <none>

Var_Decl ( 42)
  base = Foo_Node ( 23)
  last derivation = Var_Decl ( 42)
  derivations:
    <none>

Is_Node_Type: Null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference

Invalid args for Node_Type_Name:
Null Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-node Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid node type

Invalid args for Is_Abstract:
Null Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Invalid args for Is_Synthetic:
Null Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-node Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid node type

Invalid args for Is_Concrete:
Null Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-node Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid node type

Invalid args for Base_Type:
Null Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-node Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid node type
Root Node argument: LANGKIT_SUPPORT.ERRORS.INTROSPECTION.BAD_TYPE_ERROR: trying to get base type of root node

Invalid args for Derived_Types:
Null Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-node Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid node type

Invalid args for Last_Derived_Type:
Null Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-node Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid node type

Invalid args for List_Element_Type:
Null Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-list Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: list node expected

Check Type_Ref constants
Checking: FooNode type ref
Checking: Number type ref

Check Struct_Member_Ref constants
Checking: Addition.f_lhs member ref
Checking: FooNode.parent member ref

Check Is_Derived_From:
Checking: root derives from root
Checking: expr derives from root
Checking: addition derives from root
Checking: ref does not derive from number
Null Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-node Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid node type
Null Parent argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-node Parent argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid node type

Members
=======

For Node_Result
  N (NodeResult.n: 1)
  E (NodeResult.e: 2)

For Point
  Label (Point.label: 3)
  X (Point.x: 4)
  Y (Point.y: 5)

For Foo_Node
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)

For Base_Example
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)
  F_Fld_1 (BaseExample.f_fld_1: 6)
  F_Fld_2 (BaseExample.f_fld_2: 7)
  P_Id_Bool (BaseExample.p_id_bool: 32)

For Example
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)
  P_Id_Bool (BaseExample.p_id_bool: 32)
  F_Fld_2 (BaseExample.f_fld_2: 7)
  F_Fld_1 (BaseExample.f_fld_1: 6)
  P_Prop (Example.p_prop: 33)
  P_Result (Example.p_result: 34)
  P_May_Raise (Example.p_may_raise: 35)
  P_Id_Int (Example.p_id_int: 36)
  P_Id_Bigint (Example.p_id_bigint: 37)
  P_Id_Char (Example.p_id_char: 38)
  P_Id_Token (Example.p_id_token: 39)
  P_Id_Sloc (Example.p_id_sloc: 40)
  P_Id_Sym (Example.p_id_sym: 41)
  P_Id_Unit (Example.p_id_unit: 42)
  P_Id_Root_Node (Example.p_id_root_node: 43)
  P_Id_Name (Example.p_id_name: 44)
  P_Id_Unit_Kind (Example.p_id_unit_kind: 45)
  P_Id_Node_Array (Example.p_id_node_array: 46)
  P_Id_Expr_Array (Example.p_id_expr_array: 47)
  P_Id_Bigint_Array (Example.p_id_bigint_array: 48)
  P_Id_Unit_Array (Example.p_id_unit_array: 49)
  P_Create_Bigint_Iterator (Example.p_create_bigint_iterator: 50)
  P_Id_Bigint_Iterator (Example.p_id_bigint_iterator: 51)
  P_Id_Dflt_Bool (Example.p_id_dflt_bool: 52)
  P_Id_Dflt_Int (Example.p_id_dflt_int: 53)
  P_Id_Dflt_Char (Example.p_id_dflt_char: 54)
  P_Id_Dflt_Root_Node (Example.p_id_dflt_root_node: 55)
  P_With_Md (Example.p_with_md: 56)
  F_Create_Synth_Node (Example.f_create_synth_node: 57)

For Def
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)
  F_Name (Def.f_name: 8)
  F_Args (Def.f_args: 9)
  F_Expr (Def.f_expr: 10)

For Error_Decl
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)

For Expr
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)

For Addition
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)
  F_Lhs (Addition.f_lhs: 11)
  F_Rhs (Addition.f_rhs: 12)

For Call
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)
  F_Name (Call.f_name: 13)
  F_Args (Call.f_args: 14)

For Number
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)

For Ref
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)
  F_Name (Ref.f_name: 15)

For Foo_Node_Base_List
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)

For Expr_List
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)

For Foo_Node_List
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)

For Name_List
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)

For Name
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)

For Null_Qual
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)
  P_As_Bool (NullQual.p_as_bool: 58)

For Null_Qual_Absent
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)
  P_As_Bool (NullQual.p_as_bool: 58)

For Null_Qual_Present
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)
  P_As_Bool (NullQual.p_as_bool: 58)

For Synth_Node
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)
  F_Foo (SynthNode.f_foo: 16)

For Var_Decl
  Parent (FooNode.parent: 20)
  Parents (FooNode.parents: 21)
  Children (FooNode.children: 22)
  Token_Start (FooNode.token_start: 23)
  Token_End (FooNode.token_end: 24)
  Child_Index (FooNode.child_index: 25)
  Previous_Sibling (FooNode.previous_sibling: 26)
  Next_Sibling (FooNode.next_sibling: 27)
  Unit (FooNode.unit: 28)
  Is_Ghost (FooNode.is_ghost: 29)
  Full_Sloc_Image (FooNode.full_sloc_image: 30)
  Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)
  F_Is_Null (VarDecl.f_is_null: 17)
  F_Name (VarDecl.f_name: 18)
  F_Value (VarDecl.f_value: 19)

Detailed list of members
========================

N (NodeResult.n: 1)
  owner: NodeResult
  type: Example
  no argument

E (NodeResult.e: 2)
  owner: NodeResult
  type: Example
  no argument

Label (Point.label: 3)
  owner: Point
  type: String
  no argument

X (Point.x: 4)
  owner: Point
  type: BigInt
  no argument

Y (Point.y: 5)
  owner: Point
  type: BigInt
  no argument

F_Fld_1 (BaseExample.f_fld_1: 6)
  owner: BaseExample
  type: Name
  no argument

F_Fld_2 (BaseExample.f_fld_2: 7)
  owner: BaseExample
  type: FooNode
  no argument

F_Name (Def.f_name: 8)
  owner: Def
  type: Name
  no argument
  Documentation:
  |Name for this function definition.
  |
  |When there are no parsing errors, this field is never null.
  <missing newline>

F_Args (Def.f_args: 9)
  owner: Def
  type: ASTList[Name]
  no argument
  Documentation:
  |list of Arguments for this function.
  |
  |When there are no parsing errors, this field is never null.
  <missing newline>

F_Expr (Def.f_expr: 10)
  owner: Def
  type: Expr
  no argument
  Documentation:
  |Expression body for this function.
  |
  |When there are no parsing errors, this field is never null.
  <missing newline>

F_Lhs (Addition.f_lhs: 11)
  owner: Addition
  type: Expr
  no argument

F_Rhs (Addition.f_rhs: 12)
  owner: Addition
  type: Expr
  no argument

F_Name (Call.f_name: 13)
  owner: Call
  type: Name
  no argument

F_Args (Call.f_args: 14)
  owner: Call
  type: ASTList[Expr]
  no argument

F_Name (Ref.f_name: 15)
  owner: Ref
  type: Name
  no argument

F_Foo (SynthNode.f_foo: 16)
  owner: SynthNode
  type: FooNode
  no argument

F_Is_Null (VarDecl.f_is_null: 17)
  owner: VarDecl
  type: NullQual
  no argument

F_Name (VarDecl.f_name: 18)
  owner: VarDecl
  type: Name
  no argument

F_Value (VarDecl.f_value: 19)
  owner: VarDecl
  type: Expr
  no argument

Parent (FooNode.parent: 20)
  owner: FooNode
  is a property
  type: FooNode
  no argument

Parents (FooNode.parents: 21)
  owner: FooNode
  is a property
  type: FooNode.array
  arguments:
    With_Self: Bool := True

Children (FooNode.children: 22)
  owner: FooNode
  is a property
  type: FooNode.array
  no argument

Token_Start (FooNode.token_start: 23)
  owner: FooNode
  is a property
  type: Token
  no argument

Token_End (FooNode.token_end: 24)
  owner: FooNode
  is a property
  type: Token
  no argument

Child_Index (FooNode.child_index: 25)
  owner: FooNode
  is a property
  type: Int
  no argument

Previous_Sibling (FooNode.previous_sibling: 26)
  owner: FooNode
  is a property
  type: FooNode
  no argument

Next_Sibling (FooNode.next_sibling: 27)
  owner: FooNode
  is a property
  type: FooNode
  no argument

Unit (FooNode.unit: 28)
  owner: FooNode
  is a property
  type: AnalysisUnit
  no argument

Is_Ghost (FooNode.is_ghost: 29)
  owner: FooNode
  is a property
  type: Bool
  no argument

Full_Sloc_Image (FooNode.full_sloc_image: 30)
  owner: FooNode
  is a property
  type: String
  no argument

Completion_Item_Kind_To_Int (FooNode.completion_item_kind_to_int: 31)
  owner: FooNode
  is a property
  type: Int
  arguments:
    Kind: CompletionItemKind

P_Id_Bool (BaseExample.p_id_bool: 32)
  owner: BaseExample
  is a property
  type: Bool
  arguments:
    Id: Bool

P_Prop (Example.p_prop: 33)
  owner: Example
  is a property
  type: Point
  arguments:
    P: Point

P_Result (Example.p_result: 34)
  owner: Example
  is a property
  type: NodeResult
  no argument

P_May_Raise (Example.p_may_raise: 35)
  owner: Example
  is a property
  type: Int
  arguments:
    Value: Int
    Do_Raise: Bool

P_Id_Int (Example.p_id_int: 36)
  owner: Example
  is a property
  type: Int
  arguments:
    Id: Int
  Documentation:
  |Identity function for integers.

P_Id_Bigint (Example.p_id_bigint: 37)
  owner: Example
  is a property
  type: BigInt
  arguments:
    Id: BigInt
  Documentation:
  |Identity function for big integers.

P_Id_Char (Example.p_id_char: 38)
  owner: Example
  is a property
  type: Char
  arguments:
    Id: Char

P_Id_Token (Example.p_id_token: 39)
  owner: Example
  is a property
  type: Token
  arguments:
    Id: Token

P_Id_Sloc (Example.p_id_sloc: 40)
  owner: Example
  is a property
  type: SourceLocation
  arguments:
    Id: SourceLocation

P_Id_Sym (Example.p_id_sym: 41)
  owner: Example
  is a property
  type: Symbol
  arguments:
    Id: Symbol

P_Id_Unit (Example.p_id_unit: 42)
  owner: Example
  is a property
  type: AnalysisUnit
  arguments:
    Id: AnalysisUnit

P_Id_Root_Node (Example.p_id_root_node: 43)
  owner: Example
  is a property
  type: FooNode
  arguments:
    Id: FooNode

P_Id_Name (Example.p_id_name: 44)
  owner: Example
  is a property
  type: Name
  arguments:
    Id: Name

P_Id_Unit_Kind (Example.p_id_unit_kind: 45)
  owner: Example
  is a property
  type: AnalysisUnitKind
  arguments:
    Id: AnalysisUnitKind

P_Id_Node_Array (Example.p_id_node_array: 46)
  owner: Example
  is a property
  type: FooNode.array
  arguments:
    Id: FooNode.array

P_Id_Expr_Array (Example.p_id_expr_array: 47)
  owner: Example
  is a property
  type: Expr.array
  arguments:
    Id: Expr.array

P_Id_Bigint_Array (Example.p_id_bigint_array: 48)
  owner: Example
  is a property
  type: BigInt.array
  arguments:
    Id: BigInt.array

P_Id_Unit_Array (Example.p_id_unit_array: 49)
  owner: Example
  is a property
  type: AnalysisUnit.array
  arguments:
    Id: AnalysisUnit.array

P_Create_Bigint_Iterator (Example.p_create_bigint_iterator: 50)
  owner: Example
  is a property
  type: BigInt.iterator
  no argument

P_Id_Bigint_Iterator (Example.p_id_bigint_iterator: 51)
  owner: Example
  is a property
  type: BigInt.iterator
  arguments:
    Id: BigInt.iterator

P_Id_Dflt_Bool (Example.p_id_dflt_bool: 52)
  owner: Example
  is a property
  type: Bool
  arguments:
    Id: Bool := True

P_Id_Dflt_Int (Example.p_id_dflt_int: 53)
  owner: Example
  is a property
  type: Int
  arguments:
    Id: Int := 42

P_Id_Dflt_Char (Example.p_id_dflt_char: 54)
  owner: Example
  is a property
  type: Char
  arguments:
    Id: Char := '\x00'

P_Id_Dflt_Root_Node (Example.p_id_dflt_root_node: 55)
  owner: Example
  is a property
  type: FooNode
  arguments:
    Id: FooNode := <No node>

P_With_Md (Example.p_with_md: 56)
  owner: Example
  is a property
  type: Example
  arguments:
    Md1: Bool
    Md2: Bool

F_Create_Synth_Node (Example.f_create_synth_node: 57)
  owner: Example
  is a property
  type: SynthNode
  no argument

P_As_Bool (NullQual.p_as_bool: 58)
  owner: NullQual
  is a property
  type: Bool
  no argument

Language: null Member argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null struct member reference
Is_Property: Null Member argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null struct member reference

Invalid args for Members:
Null Struct argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-struct Struct argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid base struct type

Member_Name: Null Member argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null struct member reference

Member_Type: Null Member argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null struct member reference

To_Index: Null Member argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null struct member reference
From_Index: out of range member index: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid struct member index
Member_Last_Argument: Null Member argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null struct member reference

Invalid args for Member_Argument_Type:
Null Member argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null struct member reference
Invalid Argument argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid struct member argument

Invalid args for Member_Argument_Name:
Null Member argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null struct member reference
Invalid Argument argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid struct member argument

Invalid args for Member_Argument_Default_Value:
Null Member argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null struct member reference
Invalid Argument argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid struct member argument

Debug_Name: Null Member argument: <No_Struct_Member_Ref>

Name maps
=========

Enum types as UPPER
analysis_unit_kind => <No_Type_Ref>
ANALYSIS_UNIT_KIND => AnalysisUnitKind
UNIT_BODY => <No_Enum_Value_Ref>
unit_body => AnalysisUnitKind.unit_body
VAR_DECL => <No_Type_Ref>
var_decl => VarDecl
F_NAME => <No_Struct_Member_Ref>
f_name => VarDecl.f_name

Enum values as UPPER
ANALYSIS_UNIT_KIND => <No_Type_Ref>
analysis_unit_kind => AnalysisUnitKind
unit_body => <No_Enum_Value_Ref>
UNIT_BODY => AnalysisUnitKind.unit_body
VAR_DECL => <No_Type_Ref>
var_decl => VarDecl
F_NAME => <No_Struct_Member_Ref>
f_name => VarDecl.f_name

Struct types as UPPER
ANALYSIS_UNIT_KIND => <No_Type_Ref>
analysis_unit_kind => AnalysisUnitKind
UNIT_BODY => <No_Enum_Value_Ref>
unit_body => AnalysisUnitKind.unit_body
var_decl => <No_Type_Ref>
VAR_DECL => VarDecl
F_NAME => <No_Struct_Member_Ref>
f_name => VarDecl.f_name

Struct members as UPPER
ANALYSIS_UNIT_KIND => <No_Type_Ref>
analysis_unit_kind => AnalysisUnitKind
UNIT_BODY => <No_Enum_Value_Ref>
unit_body => AnalysisUnitKind.unit_body
VAR_DECL => <No_Type_Ref>
var_decl => VarDecl
f_name => <No_Struct_Member_Ref>
F_NAME => VarDecl.f_name

Invalid args for Lookup_Type
Uninitialized name map: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: uninitialized name map
Null symbol: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null symbol

Invalid args for Lookup_Enum_Value
Uninitialized name map: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: uninitialized name map
Null enum type: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Null symbol: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null symbol

Invalid args for Lookup_Struct_Member
Uninitialized name map: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: uninitialized name map
Null struct type: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Null symbol: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null symbol
Check generic/specific node kind converters
FOO_EXAMPLE -> Example
FOO_DEF -> Def
FOO_ERROR_DECL -> ErrorDecl
FOO_ADDITION -> Addition
FOO_CALL -> Call
FOO_NUMBER -> Number
FOO_REF -> Ref
FOO_EXPR_LIST -> ASTList[Expr]
FOO_FOO_NODE_LIST -> ASTList[FooNode]
FOO_NAME_LIST -> ASTList[Name]
FOO_NAME -> Name
FOO_NULL_QUAL_ABSENT -> NullQual.Absent
FOO_NULL_QUAL_PRESENT -> NullQual.Present
FOO_SYNTH_NODE -> SynthNode
FOO_VAR_DECL -> VarDecl
<No_Type_Ref> -> Got a Precondition_Failure exception: concrete node type expected
FooNode -> Got a Precondition_Failure exception: concrete node type expected
AnalysisUnitKind -> Got a Precondition_Failure exception: concrete node type expected


== introspection_values.adb ==
Value comparisons
=================

<No_Value_Ref> = <No_Value_Ref> => TRUE
<No_Value_Ref> = False => FALSE
False = False => TRUE
True = False => FALSE
False = 1 => FALSE

Value constructors/getters
==========================

Inspect: <No_Value_Ref>
  Type_Of: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null value reference
Inspect: <No analysis unit>
  Type_Of: AnalysisUnit
Inspect: <Unit for example.txt>
  Type_Of: AnalysisUnit
Inspect: BigInt(9111111111124567890)
  Type_Of: BigInt
Inspect: True
  Type_Of: Bool
Inspect: False
  Type_Of: Bool
Inspect: 'A'
  Type_Of: Char
Inspect: 42
  Type_Of: Int
Inspect: 1:2-3:4
  Type_Of: SourceLocationRange
Inspect: "hello, world!"
  Type_Of: String
Inspect: <Token Kind=Example Text="example">
  Type_Of: Token
Inspect: 1:1
  Type_Of: SourceLocation
Inspect: Symbol("foo_bar42")
  Type_Of: Symbol
Inspect: <No node>
  Type_Of: FooNode
Inspect: <FooNodeList example.txt:1:1-3:15>
  Type_Of: ASTList[FooNode]

Enum values introspection
=========================

Create_Enum: null enum value ref: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null enum value reference
Inspect: Analysis_Unit_Kind(UNIT_SPECIFICATION)
  Type_Of: AnalysisUnitKind

Array values introspection
==========================

Create_Array: null array type: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Create_Array: null value reference: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null value reference
Create_Array: value type mismatch: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: unexpected value type
Inspect: Array of 0 FooNode elements
  Type_Of: FooNode.array
Inspect: Array of 1 FooNode elements
  Type_Of: FooNode.array
As_Array: null value: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null value reference
As_Array: value type mismatch: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: non-array value
Array_Length: null value: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null value reference
Array_Length: value type mismatch: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: non-array value
Array_Item: null value: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null value reference
Array_Item: value type mismatch: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: non-array value

Array_Item: index checks
  array: Array of 3 BigInt elements
  ( 1): BigInt(10)
  ( 2): BigInt(20)
  ( 3): BigInt(30)
  ( 4): LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: out-of-bounds array index
  ( 5): LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: out-of-bounds array index

Iterator values introspection
=============================

Iterator_Next: null value: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null value reference
Iterator_Next: value type mismatch: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: non-iterator value

Full iteration through Iterator_Next:
Inspect: Iterator on BigInt
  Type_Of: BigInt.iterator

Inspect: BigInt(1)
  Type_Of: BigInt
Inspect: BigInt(2)
  Type_Of: BigInt
Inspect: BigInt(3)
  Type_Of: BigInt

Struct values introspection
===========================

Create_Struct: null struct type: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Create_Struct: invalid struct type: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid struct type
Create_Struct: null value reference: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid null value
Create_Struct: value type mismatch: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: member type mismatch
Create_Struct: value count mismatch: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: NodeResult has 2 members but got 1 value(s)
Inspect: Point("hello world!", BigInt(10), BigInt(20))
  Type_Of: Point
Eval_Member: null struct value: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null value reference
Eval_Member: invalid struct type: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid base struct type
Eval_Member: no such member: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: Point does not have the NodeResult.n member
Eval_Member: too many arguments: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: Point takes 0 arguments but got 1 values
Eval_Member: argument type mismatch: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: unexpected type for argument 1
Eval_Member: no such node member: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: ASTList[FooNode] does not have the BaseExample.p_id_bool member
Eval_Member: Point_Label on Point("hello world!", BigInt(10), BigInt(20)):
Inspect: "hello world!"
  Type_Of: String

Eval_Member: BaseExample.p_id_bool:
Inspect: True
  Type_Of: Bool

Eval_Member: Example.p_id_int:
Inspect: 42
  Type_Of: Int

Eval_Member: Example.p_id_bigint:
Inspect: BigInt(1234567890987654321)
  Type_Of: BigInt

Eval_Member: Example.p_id_char:
Inspect: 'A'
  Type_Of: Char

Eval_Member: Example.p_id_token:
Inspect: <Token Kind=Example Text="example">
  Type_Of: Token

Eval_Member: Example.p_id_sloc:
Inspect: 3:15
  Type_Of: SourceLocation

Eval_Member: Example.p_id_sym:
Inspect: Symbol("foobar")
  Type_Of: Symbol

Eval_Member: Example.p_id_unit:
Inspect: <Unit for example.txt>
  Type_Of: AnalysisUnit

Eval_Member: Example.p_id_root_node:
Inspect: <FooNodeList example.txt:1:1-3:15>
  Type_Of: ASTList[FooNode]

Eval_Member: Example.p_id_name:
Inspect: <No node>
  Type_Of: FooNode

Eval_Member: Example.p_id_name:
Inspect: <Name example.txt:2:5-2:6>
  Type_Of: Name

Eval_Member: Example.p_id_unit_kind:
Inspect: Analysis_Unit_Kind(UNIT_SPECIFICATION)
  Type_Of: AnalysisUnitKind

Eval_Member: Example.p_id_node_array:
Inspect: Array of 1 FooNode elements
  Type_Of: FooNode.array

Eval_Member: Example.p_id_expr_array:
Inspect: Array of 1 Expr elements
  Type_Of: Expr.array

Eval_Member: Example.p_id_bigint_iterator:
Inspect: Iterator on BigInt
  Type_Of: BigInt.iterator

Eval_Node_Member: abstract field with null derivation:
Inspect: <Name example.txt:1:9-1:12>
  Type_Of: Name

Eval_Node_Member: abstract field with concrete derivation:
Inspect: <No node>
  Type_Of: FooNode
Eval_Node_Member: null node value: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: the null node has no member
Eval_Node_Member: P_Id_Bool:
Inspect: True
  Type_Of: Bool

Eval_Syntax_Field: null node value: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: the null node has no member
Eval_Syntax_Field: non syntax field: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: syntax field expected
Eval_Syntax_Field: no such field: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: Example does not have the VarDecl.f_name member
Eval_Syntax_Field: F_Fld_1:
  Name[1:9-1:12]: foo

Type matching
=============

Basic cases:
32 matches Int? True
32 matches Bool? False
<FooNodeList example.txt:1:1-3:15> matches Bool? False

Nodes:
... with the Value_Ref API:
<FooNodeList example.txt:1:1-3:15> matches FooNode? True
<FooNodeList example.txt:1:1-3:15> matches VarDecl? False
<No node> matches FooNode? True
<No node> matches VarDecl? True

... with the Lk_Node API:
<FooNodeList example.txt:1:1-3:15> matches FooNode? True
<FooNodeList example.txt:1:1-3:15> matches VarDecl? False
None matches FooNode? True
None matches VarDecl? True

Error cases:
<No_Value_Ref> matches Int? LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null value reference
<No node> matches <No_Type_Ref>? LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference

Managed errors
==============

Eval_Member/Success
Inspect: 42
  Type_Of: Int

Eval_Node_Member/Success
Inspect: 42
  Type_Of: Int

Eval_Member/Error
Inspect:
  Exception name: LANGKIT_SUPPORT.ERRORS.PROPERTY_ERROR
  Exception message: from may_raise

Eval_Node_Member/Error
Inspect:
  Exception name: LANGKIT_SUPPORT.ERRORS.PROPERTY_ERROR
  Exception message: from may_raise


== hash.adb ==
hash.adb: no error

Done
