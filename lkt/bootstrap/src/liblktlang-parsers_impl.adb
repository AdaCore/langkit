
with Ada.Containers.Ordered_Maps;
with Ada.Containers.Vectors;
with Ada.Exceptions;
with Ada.Text_IO; use Ada.Text_IO;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;

with System;

with Liblktlang_Support.Bump_Ptr;    use Liblktlang_Support.Bump_Ptr;
with Liblktlang_Support.Diagnostics; use Liblktlang_Support.Diagnostics;
with Liblktlang_Support.Packrat;     use Liblktlang_Support.Packrat;
with Liblktlang_Support.Slocs;       use Liblktlang_Support.Slocs;

pragma Warnings (Off, "referenced");
with Liblktlang_Support.Symbols; use Liblktlang_Support.Symbols;
pragma Warnings (On, "referenced");

with Liblktlang_Support.Text;        use Liblktlang_Support.Text;

with Liblktlang.Common;         use Liblktlang.Common;
with Liblktlang.Implementation; use Liblktlang.Implementation;
use Liblktlang.Implementation.Precomputed_Symbols;
with Liblktlang.Lexer_Implementation;
use Liblktlang.Lexer_Implementation;

pragma Warnings (Off, "referenced");
with Liblktlang.Private_Converters; use Liblktlang.Private_Converters;
pragma Warnings (On, "referenced");

with Liblktlang.Implementation.Extensions;



package body Liblktlang.Parsers_Impl is
   pragma Warnings (Off, "use clause");
   use all type Liblktlang_Support.Symbols.Symbol_Type;
   pragma Warnings (On, "use clause");

   --  Prepare packrat instantiations: one per enum type and onefor each kind
   --  of node (including lists). Likewise for bump ptr. allocators, except
   --  we need them only for non-abstract AST nodes.

   pragma Warnings (Off, "is not referenced");
   package Memos is new Liblktlang_Support.Packrat.Tables
     (Bare_Lkt_Node, null, Token_Kind);

         
         subtype Subtype_For_Argument is
            Root_Node_Record (Lkt_Argument);
         type Access_To_Subtype_For_Argument is access all Subtype_For_Argument;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Argument);
         package Bare_Argument_Alloc is new Alloc
           (Subtype_For_Argument, Access_To_Subtype_For_Argument);

         function Allocate_Argument
           (Pool : Bump_Ptr_Pool) return Bare_Argument;

         function Allocate_Argument
           (Pool : Bump_Ptr_Pool) return Bare_Argument
         is
            Result      : constant Access_To_Subtype_For_Argument := Bare_Argument_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Argument;
            return Bare_Argument (Result);
         end Allocate_Argument;

         
         subtype Subtype_For_Import is
            Root_Node_Record (Lkt_Import);
         type Access_To_Subtype_For_Import is access all Subtype_For_Import;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Import);
         package Bare_Import_Alloc is new Alloc
           (Subtype_For_Import, Access_To_Subtype_For_Import);

         function Allocate_Import
           (Pool : Bump_Ptr_Pool) return Bare_Import;

         function Allocate_Import
           (Pool : Bump_Ptr_Pool) return Bare_Import
         is
            Result      : constant Access_To_Subtype_For_Import := Bare_Import_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Import;
            return Bare_Import (Result);
         end Allocate_Import;

         
         subtype Subtype_For_Import_All_From is
            Root_Node_Record (Lkt_Import_All_From);
         type Access_To_Subtype_For_Import_All_From is access all Subtype_For_Import_All_From;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Import_All_From);
         package Bare_Import_All_From_Alloc is new Alloc
           (Subtype_For_Import_All_From, Access_To_Subtype_For_Import_All_From);

         function Allocate_Import_All_From
           (Pool : Bump_Ptr_Pool) return Bare_Import_All_From;

         function Allocate_Import_All_From
           (Pool : Bump_Ptr_Pool) return Bare_Import_All_From
         is
            Result      : constant Access_To_Subtype_For_Import_All_From := Bare_Import_All_From_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Import_All_From;
            return Bare_Import_All_From (Result);
         end Allocate_Import_All_From;

         
         subtype Subtype_For_Import_From is
            Root_Node_Record (Lkt_Import_From);
         type Access_To_Subtype_For_Import_From is access all Subtype_For_Import_From;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Import_From);
         package Bare_Import_From_Alloc is new Alloc
           (Subtype_For_Import_From, Access_To_Subtype_For_Import_From);

         function Allocate_Import_From
           (Pool : Bump_Ptr_Pool) return Bare_Import_From;

         function Allocate_Import_From
           (Pool : Bump_Ptr_Pool) return Bare_Import_From
         is
            Result      : constant Access_To_Subtype_For_Import_From := Bare_Import_From_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Import_From;
            return Bare_Import_From (Result);
         end Allocate_Import_From;

         
         subtype Subtype_For_Error_Lexer_Case_Rule_Alt is
            Root_Node_Record (Lkt_Error_Lexer_Case_Rule_Alt);
         type Access_To_Subtype_For_Error_Lexer_Case_Rule_Alt is access all Subtype_For_Error_Lexer_Case_Rule_Alt;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Error_Lexer_Case_Rule_Alt);
         package Bare_Error_Lexer_Case_Rule_Alt_Alloc is new Alloc
           (Subtype_For_Error_Lexer_Case_Rule_Alt, Access_To_Subtype_For_Error_Lexer_Case_Rule_Alt);

         function Allocate_Error_Lexer_Case_Rule_Alt
           (Pool : Bump_Ptr_Pool) return Bare_Error_Lexer_Case_Rule_Alt;

         function Allocate_Error_Lexer_Case_Rule_Alt
           (Pool : Bump_Ptr_Pool) return Bare_Error_Lexer_Case_Rule_Alt
         is
            Result      : constant Access_To_Subtype_For_Error_Lexer_Case_Rule_Alt := Bare_Error_Lexer_Case_Rule_Alt_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Error_Lexer_Case_Rule_Alt;
            return Bare_Error_Lexer_Case_Rule_Alt (Result);
         end Allocate_Error_Lexer_Case_Rule_Alt;

         
         subtype Subtype_For_Lexer_Case_Rule_Cond_Alt is
            Root_Node_Record (Lkt_Lexer_Case_Rule_Cond_Alt);
         type Access_To_Subtype_For_Lexer_Case_Rule_Cond_Alt is access all Subtype_For_Lexer_Case_Rule_Cond_Alt;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lexer_Case_Rule_Cond_Alt);
         package Bare_Lexer_Case_Rule_Cond_Alt_Alloc is new Alloc
           (Subtype_For_Lexer_Case_Rule_Cond_Alt, Access_To_Subtype_For_Lexer_Case_Rule_Cond_Alt);

         function Allocate_Lexer_Case_Rule_Cond_Alt
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Case_Rule_Cond_Alt;

         function Allocate_Lexer_Case_Rule_Cond_Alt
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Case_Rule_Cond_Alt
         is
            Result      : constant Access_To_Subtype_For_Lexer_Case_Rule_Cond_Alt := Bare_Lexer_Case_Rule_Cond_Alt_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lexer_Case_Rule_Cond_Alt;
            return Bare_Lexer_Case_Rule_Cond_Alt (Result);
         end Allocate_Lexer_Case_Rule_Cond_Alt;

         
         subtype Subtype_For_Lexer_Case_Rule_Default_Alt is
            Root_Node_Record (Lkt_Lexer_Case_Rule_Default_Alt);
         type Access_To_Subtype_For_Lexer_Case_Rule_Default_Alt is access all Subtype_For_Lexer_Case_Rule_Default_Alt;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lexer_Case_Rule_Default_Alt);
         package Bare_Lexer_Case_Rule_Default_Alt_Alloc is new Alloc
           (Subtype_For_Lexer_Case_Rule_Default_Alt, Access_To_Subtype_For_Lexer_Case_Rule_Default_Alt);

         function Allocate_Lexer_Case_Rule_Default_Alt
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Case_Rule_Default_Alt;

         function Allocate_Lexer_Case_Rule_Default_Alt
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Case_Rule_Default_Alt
         is
            Result      : constant Access_To_Subtype_For_Lexer_Case_Rule_Default_Alt := Bare_Lexer_Case_Rule_Default_Alt_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lexer_Case_Rule_Default_Alt;
            return Bare_Lexer_Case_Rule_Default_Alt (Result);
         end Allocate_Lexer_Case_Rule_Default_Alt;

         
         subtype Subtype_For_Match_Branch is
            Root_Node_Record (Lkt_Match_Branch);
         type Access_To_Subtype_For_Match_Branch is access all Subtype_For_Match_Branch;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Match_Branch);
         package Bare_Match_Branch_Alloc is new Alloc
           (Subtype_For_Match_Branch, Access_To_Subtype_For_Match_Branch);

         function Allocate_Match_Branch
           (Pool : Bump_Ptr_Pool) return Bare_Match_Branch;

         function Allocate_Match_Branch
           (Pool : Bump_Ptr_Pool) return Bare_Match_Branch
         is
            Result      : constant Access_To_Subtype_For_Match_Branch := Bare_Match_Branch_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Match_Branch;
            return Bare_Match_Branch (Result);
         end Allocate_Match_Branch;

         
         subtype Subtype_For_Pattern_Match_Branch is
            Root_Node_Record (Lkt_Pattern_Match_Branch);
         type Access_To_Subtype_For_Pattern_Match_Branch is access all Subtype_For_Pattern_Match_Branch;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Pattern_Match_Branch);
         package Bare_Pattern_Match_Branch_Alloc is new Alloc
           (Subtype_For_Pattern_Match_Branch, Access_To_Subtype_For_Pattern_Match_Branch);

         function Allocate_Pattern_Match_Branch
           (Pool : Bump_Ptr_Pool) return Bare_Pattern_Match_Branch;

         function Allocate_Pattern_Match_Branch
           (Pool : Bump_Ptr_Pool) return Bare_Pattern_Match_Branch
         is
            Result      : constant Access_To_Subtype_For_Pattern_Match_Branch := Bare_Pattern_Match_Branch_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Pattern_Match_Branch;
            return Bare_Pattern_Match_Branch (Result);
         end Allocate_Pattern_Match_Branch;

         
         subtype Subtype_For_Block_Expr_Clause is
            Root_Node_Record (Lkt_Block_Expr_Clause);
         type Access_To_Subtype_For_Block_Expr_Clause is access all Subtype_For_Block_Expr_Clause;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Block_Expr_Clause);
         package Bare_Block_Expr_Clause_Alloc is new Alloc
           (Subtype_For_Block_Expr_Clause, Access_To_Subtype_For_Block_Expr_Clause);

         function Allocate_Block_Expr_Clause
           (Pool : Bump_Ptr_Pool) return Bare_Block_Expr_Clause;

         function Allocate_Block_Expr_Clause
           (Pool : Bump_Ptr_Pool) return Bare_Block_Expr_Clause
         is
            Result      : constant Access_To_Subtype_For_Block_Expr_Clause := Bare_Block_Expr_Clause_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Block_Expr_Clause;
            return Bare_Block_Expr_Clause (Result);
         end Allocate_Block_Expr_Clause;

         
         subtype Subtype_For_Block_String_Line is
            Root_Node_Record (Lkt_Block_String_Line);
         type Access_To_Subtype_For_Block_String_Line is access all Subtype_For_Block_String_Line;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Block_String_Line);
         package Bare_Block_String_Line_Alloc is new Alloc
           (Subtype_For_Block_String_Line, Access_To_Subtype_For_Block_String_Line);

         function Allocate_Block_String_Line
           (Pool : Bump_Ptr_Pool) return Bare_Block_String_Line;

         function Allocate_Block_String_Line
           (Pool : Bump_Ptr_Pool) return Bare_Block_String_Line
         is
            Result      : constant Access_To_Subtype_For_Block_String_Line := Bare_Block_String_Line_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Block_String_Line;
            return Bare_Block_String_Line (Result);
         end Allocate_Block_String_Line;

         
         subtype Subtype_For_Class_Qualifier_Absent is
            Root_Node_Record (Lkt_Class_Qualifier_Absent);
         type Access_To_Subtype_For_Class_Qualifier_Absent is access all Subtype_For_Class_Qualifier_Absent;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Class_Qualifier_Absent);
         package Bare_Class_Qualifier_Absent_Alloc is new Alloc
           (Subtype_For_Class_Qualifier_Absent, Access_To_Subtype_For_Class_Qualifier_Absent);

         function Allocate_Class_Qualifier_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Class_Qualifier_Absent;

         function Allocate_Class_Qualifier_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Class_Qualifier_Absent
         is
            Result      : constant Access_To_Subtype_For_Class_Qualifier_Absent := Bare_Class_Qualifier_Absent_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Class_Qualifier_Absent;
            return Bare_Class_Qualifier_Absent (Result);
         end Allocate_Class_Qualifier_Absent;

         
         subtype Subtype_For_Class_Qualifier_Present is
            Root_Node_Record (Lkt_Class_Qualifier_Present);
         type Access_To_Subtype_For_Class_Qualifier_Present is access all Subtype_For_Class_Qualifier_Present;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Class_Qualifier_Present);
         package Bare_Class_Qualifier_Present_Alloc is new Alloc
           (Subtype_For_Class_Qualifier_Present, Access_To_Subtype_For_Class_Qualifier_Present);

         function Allocate_Class_Qualifier_Present
           (Pool : Bump_Ptr_Pool) return Bare_Class_Qualifier_Present;

         function Allocate_Class_Qualifier_Present
           (Pool : Bump_Ptr_Pool) return Bare_Class_Qualifier_Present
         is
            Result      : constant Access_To_Subtype_For_Class_Qualifier_Present := Bare_Class_Qualifier_Present_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Class_Qualifier_Present;
            return Bare_Class_Qualifier_Present (Result);
         end Allocate_Class_Qualifier_Present;

         
         subtype Subtype_For_Grammar_Rule_Decl is
            Root_Node_Record (Lkt_Grammar_Rule_Decl);
         type Access_To_Subtype_For_Grammar_Rule_Decl is access all Subtype_For_Grammar_Rule_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Rule_Decl);
         package Bare_Grammar_Rule_Decl_Alloc is new Alloc
           (Subtype_For_Grammar_Rule_Decl, Access_To_Subtype_For_Grammar_Rule_Decl);

         function Allocate_Grammar_Rule_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Rule_Decl;

         function Allocate_Grammar_Rule_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Rule_Decl
         is
            Result      : constant Access_To_Subtype_For_Grammar_Rule_Decl := Bare_Grammar_Rule_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Rule_Decl;
            return Bare_Grammar_Rule_Decl (Result);
         end Allocate_Grammar_Rule_Decl;

         
         subtype Subtype_For_Synthetic_Lexer_Decl is
            Root_Node_Record (Lkt_Synthetic_Lexer_Decl);
         type Access_To_Subtype_For_Synthetic_Lexer_Decl is access all Subtype_For_Synthetic_Lexer_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Synthetic_Lexer_Decl);
         package Bare_Synthetic_Lexer_Decl_Alloc is new Alloc
           (Subtype_For_Synthetic_Lexer_Decl, Access_To_Subtype_For_Synthetic_Lexer_Decl);

         function Allocate_Synthetic_Lexer_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Lexer_Decl;

         function Allocate_Synthetic_Lexer_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Lexer_Decl
         is
            Result      : constant Access_To_Subtype_For_Synthetic_Lexer_Decl := Bare_Synthetic_Lexer_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Synthetic_Lexer_Decl;
            return Bare_Synthetic_Lexer_Decl (Result);
         end Allocate_Synthetic_Lexer_Decl;

         
         subtype Subtype_For_Node_Decl is
            Root_Node_Record (Lkt_Node_Decl);
         type Access_To_Subtype_For_Node_Decl is access all Subtype_For_Node_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Node_Decl);
         package Bare_Node_Decl_Alloc is new Alloc
           (Subtype_For_Node_Decl, Access_To_Subtype_For_Node_Decl);

         function Allocate_Node_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Node_Decl;

         function Allocate_Node_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Node_Decl
         is
            Result      : constant Access_To_Subtype_For_Node_Decl := Bare_Node_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Node_Decl;
            return Bare_Node_Decl (Result);
         end Allocate_Node_Decl;

         
         subtype Subtype_For_Self_Decl is
            Root_Node_Record (Lkt_Self_Decl);
         type Access_To_Subtype_For_Self_Decl is access all Subtype_For_Self_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Self_Decl);
         package Bare_Self_Decl_Alloc is new Alloc
           (Subtype_For_Self_Decl, Access_To_Subtype_For_Self_Decl);

         function Allocate_Self_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Self_Decl;

         function Allocate_Self_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Self_Decl
         is
            Result      : constant Access_To_Subtype_For_Self_Decl := Bare_Self_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Self_Decl;
            return Bare_Self_Decl (Result);
         end Allocate_Self_Decl;

         
         subtype Subtype_For_Binding_Val_Decl is
            Root_Node_Record (Lkt_Binding_Val_Decl);
         type Access_To_Subtype_For_Binding_Val_Decl is access all Subtype_For_Binding_Val_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Binding_Val_Decl);
         package Bare_Binding_Val_Decl_Alloc is new Alloc
           (Subtype_For_Binding_Val_Decl, Access_To_Subtype_For_Binding_Val_Decl);

         function Allocate_Binding_Val_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Binding_Val_Decl;

         function Allocate_Binding_Val_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Binding_Val_Decl
         is
            Result      : constant Access_To_Subtype_For_Binding_Val_Decl := Bare_Binding_Val_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Binding_Val_Decl;
            return Bare_Binding_Val_Decl (Result);
         end Allocate_Binding_Val_Decl;

         
         subtype Subtype_For_Enum_Lit_Decl is
            Root_Node_Record (Lkt_Enum_Lit_Decl);
         type Access_To_Subtype_For_Enum_Lit_Decl is access all Subtype_For_Enum_Lit_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Enum_Lit_Decl);
         package Bare_Enum_Lit_Decl_Alloc is new Alloc
           (Subtype_For_Enum_Lit_Decl, Access_To_Subtype_For_Enum_Lit_Decl);

         function Allocate_Enum_Lit_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Lit_Decl;

         function Allocate_Enum_Lit_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Lit_Decl
         is
            Result      : constant Access_To_Subtype_For_Enum_Lit_Decl := Bare_Enum_Lit_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Enum_Lit_Decl;
            return Bare_Enum_Lit_Decl (Result);
         end Allocate_Enum_Lit_Decl;

         
         subtype Subtype_For_Field_Decl is
            Root_Node_Record (Lkt_Field_Decl);
         type Access_To_Subtype_For_Field_Decl is access all Subtype_For_Field_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Field_Decl);
         package Bare_Field_Decl_Alloc is new Alloc
           (Subtype_For_Field_Decl, Access_To_Subtype_For_Field_Decl);

         function Allocate_Field_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Field_Decl;

         function Allocate_Field_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Field_Decl
         is
            Result      : constant Access_To_Subtype_For_Field_Decl := Bare_Field_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Field_Decl;
            return Bare_Field_Decl (Result);
         end Allocate_Field_Decl;

         
         subtype Subtype_For_Fun_Param_Decl is
            Root_Node_Record (Lkt_Fun_Param_Decl);
         type Access_To_Subtype_For_Fun_Param_Decl is access all Subtype_For_Fun_Param_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Fun_Param_Decl);
         package Bare_Fun_Param_Decl_Alloc is new Alloc
           (Subtype_For_Fun_Param_Decl, Access_To_Subtype_For_Fun_Param_Decl);

         function Allocate_Fun_Param_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Fun_Param_Decl;

         function Allocate_Fun_Param_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Fun_Param_Decl
         is
            Result      : constant Access_To_Subtype_For_Fun_Param_Decl := Bare_Fun_Param_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Fun_Param_Decl;
            return Bare_Fun_Param_Decl (Result);
         end Allocate_Fun_Param_Decl;

         
         subtype Subtype_For_Lambda_Param_Decl is
            Root_Node_Record (Lkt_Lambda_Param_Decl);
         type Access_To_Subtype_For_Lambda_Param_Decl is access all Subtype_For_Lambda_Param_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lambda_Param_Decl);
         package Bare_Lambda_Param_Decl_Alloc is new Alloc
           (Subtype_For_Lambda_Param_Decl, Access_To_Subtype_For_Lambda_Param_Decl);

         function Allocate_Lambda_Param_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Lambda_Param_Decl;

         function Allocate_Lambda_Param_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Lambda_Param_Decl
         is
            Result      : constant Access_To_Subtype_For_Lambda_Param_Decl := Bare_Lambda_Param_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lambda_Param_Decl;
            return Bare_Lambda_Param_Decl (Result);
         end Allocate_Lambda_Param_Decl;

         
         subtype Subtype_For_Dyn_Var_Decl is
            Root_Node_Record (Lkt_Dyn_Var_Decl);
         type Access_To_Subtype_For_Dyn_Var_Decl is access all Subtype_For_Dyn_Var_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Dyn_Var_Decl);
         package Bare_Dyn_Var_Decl_Alloc is new Alloc
           (Subtype_For_Dyn_Var_Decl, Access_To_Subtype_For_Dyn_Var_Decl);

         function Allocate_Dyn_Var_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Dyn_Var_Decl;

         function Allocate_Dyn_Var_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Dyn_Var_Decl
         is
            Result      : constant Access_To_Subtype_For_Dyn_Var_Decl := Bare_Dyn_Var_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Dyn_Var_Decl;
            return Bare_Dyn_Var_Decl (Result);
         end Allocate_Dyn_Var_Decl;

         
         subtype Subtype_For_Match_Val_Decl is
            Root_Node_Record (Lkt_Match_Val_Decl);
         type Access_To_Subtype_For_Match_Val_Decl is access all Subtype_For_Match_Val_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Match_Val_Decl);
         package Bare_Match_Val_Decl_Alloc is new Alloc
           (Subtype_For_Match_Val_Decl, Access_To_Subtype_For_Match_Val_Decl);

         function Allocate_Match_Val_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Match_Val_Decl;

         function Allocate_Match_Val_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Match_Val_Decl
         is
            Result      : constant Access_To_Subtype_For_Match_Val_Decl := Bare_Match_Val_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Match_Val_Decl;
            return Bare_Match_Val_Decl (Result);
         end Allocate_Match_Val_Decl;

         
         subtype Subtype_For_Val_Decl is
            Root_Node_Record (Lkt_Val_Decl);
         type Access_To_Subtype_For_Val_Decl is access all Subtype_For_Val_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Val_Decl);
         package Bare_Val_Decl_Alloc is new Alloc
           (Subtype_For_Val_Decl, Access_To_Subtype_For_Val_Decl);

         function Allocate_Val_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Val_Decl;

         function Allocate_Val_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Val_Decl
         is
            Result      : constant Access_To_Subtype_For_Val_Decl := Bare_Val_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Val_Decl;
            return Bare_Val_Decl (Result);
         end Allocate_Val_Decl;

         
         subtype Subtype_For_Fun_Decl is
            Root_Node_Record (Lkt_Fun_Decl);
         type Access_To_Subtype_For_Fun_Decl is access all Subtype_For_Fun_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Fun_Decl);
         package Bare_Fun_Decl_Alloc is new Alloc
           (Subtype_For_Fun_Decl, Access_To_Subtype_For_Fun_Decl);

         function Allocate_Fun_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Fun_Decl;

         function Allocate_Fun_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Fun_Decl
         is
            Result      : constant Access_To_Subtype_For_Fun_Decl := Bare_Fun_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Fun_Decl;
            return Bare_Fun_Decl (Result);
         end Allocate_Fun_Decl;

         
         subtype Subtype_For_Env_Spec_Decl is
            Root_Node_Record (Lkt_Env_Spec_Decl);
         type Access_To_Subtype_For_Env_Spec_Decl is access all Subtype_For_Env_Spec_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Env_Spec_Decl);
         package Bare_Env_Spec_Decl_Alloc is new Alloc
           (Subtype_For_Env_Spec_Decl, Access_To_Subtype_For_Env_Spec_Decl);

         function Allocate_Env_Spec_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Env_Spec_Decl;

         function Allocate_Env_Spec_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Env_Spec_Decl
         is
            Result      : constant Access_To_Subtype_For_Env_Spec_Decl := Bare_Env_Spec_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Env_Spec_Decl;
            return Bare_Env_Spec_Decl (Result);
         end Allocate_Env_Spec_Decl;

         
         subtype Subtype_For_Error_Decl is
            Root_Node_Record (Lkt_Error_Decl);
         type Access_To_Subtype_For_Error_Decl is access all Subtype_For_Error_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Error_Decl);
         package Bare_Error_Decl_Alloc is new Alloc
           (Subtype_For_Error_Decl, Access_To_Subtype_For_Error_Decl);

         function Allocate_Error_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Error_Decl;

         function Allocate_Error_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Error_Decl
         is
            Result      : constant Access_To_Subtype_For_Error_Decl := Bare_Error_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Error_Decl;
            return Bare_Error_Decl (Result);
         end Allocate_Error_Decl;

         
         subtype Subtype_For_Generic_Decl is
            Root_Node_Record (Lkt_Generic_Decl);
         type Access_To_Subtype_For_Generic_Decl is access all Subtype_For_Generic_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Generic_Decl);
         package Bare_Generic_Decl_Alloc is new Alloc
           (Subtype_For_Generic_Decl, Access_To_Subtype_For_Generic_Decl);

         function Allocate_Generic_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Decl;

         function Allocate_Generic_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Decl
         is
            Result      : constant Access_To_Subtype_For_Generic_Decl := Bare_Generic_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Generic_Decl;
            return Bare_Generic_Decl (Result);
         end Allocate_Generic_Decl;

         
         subtype Subtype_For_Grammar_Decl is
            Root_Node_Record (Lkt_Grammar_Decl);
         type Access_To_Subtype_For_Grammar_Decl is access all Subtype_For_Grammar_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Decl);
         package Bare_Grammar_Decl_Alloc is new Alloc
           (Subtype_For_Grammar_Decl, Access_To_Subtype_For_Grammar_Decl);

         function Allocate_Grammar_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Decl;

         function Allocate_Grammar_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Decl
         is
            Result      : constant Access_To_Subtype_For_Grammar_Decl := Bare_Grammar_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Decl;
            return Bare_Grammar_Decl (Result);
         end Allocate_Grammar_Decl;

         
         subtype Subtype_For_Lexer_Decl is
            Root_Node_Record (Lkt_Lexer_Decl);
         type Access_To_Subtype_For_Lexer_Decl is access all Subtype_For_Lexer_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lexer_Decl);
         package Bare_Lexer_Decl_Alloc is new Alloc
           (Subtype_For_Lexer_Decl, Access_To_Subtype_For_Lexer_Decl);

         function Allocate_Lexer_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Decl;

         function Allocate_Lexer_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Decl
         is
            Result      : constant Access_To_Subtype_For_Lexer_Decl := Bare_Lexer_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lexer_Decl;
            return Bare_Lexer_Decl (Result);
         end Allocate_Lexer_Decl;

         
         subtype Subtype_For_Lexer_Family_Decl is
            Root_Node_Record (Lkt_Lexer_Family_Decl);
         type Access_To_Subtype_For_Lexer_Family_Decl is access all Subtype_For_Lexer_Family_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lexer_Family_Decl);
         package Bare_Lexer_Family_Decl_Alloc is new Alloc
           (Subtype_For_Lexer_Family_Decl, Access_To_Subtype_For_Lexer_Family_Decl);

         function Allocate_Lexer_Family_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Family_Decl;

         function Allocate_Lexer_Family_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Family_Decl
         is
            Result      : constant Access_To_Subtype_For_Lexer_Family_Decl := Bare_Lexer_Family_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lexer_Family_Decl;
            return Bare_Lexer_Family_Decl (Result);
         end Allocate_Lexer_Family_Decl;

         
         subtype Subtype_For_Synth_Fun_Decl is
            Root_Node_Record (Lkt_Synth_Fun_Decl);
         type Access_To_Subtype_For_Synth_Fun_Decl is access all Subtype_For_Synth_Fun_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Synth_Fun_Decl);
         package Bare_Synth_Fun_Decl_Alloc is new Alloc
           (Subtype_For_Synth_Fun_Decl, Access_To_Subtype_For_Synth_Fun_Decl);

         function Allocate_Synth_Fun_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Synth_Fun_Decl;

         function Allocate_Synth_Fun_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Synth_Fun_Decl
         is
            Result      : constant Access_To_Subtype_For_Synth_Fun_Decl := Bare_Synth_Fun_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Synth_Fun_Decl;
            return Bare_Synth_Fun_Decl (Result);
         end Allocate_Synth_Fun_Decl;

         
         subtype Subtype_For_Synth_Param_Decl is
            Root_Node_Record (Lkt_Synth_Param_Decl);
         type Access_To_Subtype_For_Synth_Param_Decl is access all Subtype_For_Synth_Param_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Synth_Param_Decl);
         package Bare_Synth_Param_Decl_Alloc is new Alloc
           (Subtype_For_Synth_Param_Decl, Access_To_Subtype_For_Synth_Param_Decl);

         function Allocate_Synth_Param_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Synth_Param_Decl;

         function Allocate_Synth_Param_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Synth_Param_Decl
         is
            Result      : constant Access_To_Subtype_For_Synth_Param_Decl := Bare_Synth_Param_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Synth_Param_Decl;
            return Bare_Synth_Param_Decl (Result);
         end Allocate_Synth_Param_Decl;

         
         subtype Subtype_For_Any_Type_Decl is
            Root_Node_Record (Lkt_Any_Type_Decl);
         type Access_To_Subtype_For_Any_Type_Decl is access all Subtype_For_Any_Type_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Any_Type_Decl);
         package Bare_Any_Type_Decl_Alloc is new Alloc
           (Subtype_For_Any_Type_Decl, Access_To_Subtype_For_Any_Type_Decl);

         function Allocate_Any_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Any_Type_Decl;

         function Allocate_Any_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Any_Type_Decl
         is
            Result      : constant Access_To_Subtype_For_Any_Type_Decl := Bare_Any_Type_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Any_Type_Decl;
            return Bare_Any_Type_Decl (Result);
         end Allocate_Any_Type_Decl;

         
         subtype Subtype_For_Enum_Class_Alt_Decl is
            Root_Node_Record (Lkt_Enum_Class_Alt_Decl);
         type Access_To_Subtype_For_Enum_Class_Alt_Decl is access all Subtype_For_Enum_Class_Alt_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Enum_Class_Alt_Decl);
         package Bare_Enum_Class_Alt_Decl_Alloc is new Alloc
           (Subtype_For_Enum_Class_Alt_Decl, Access_To_Subtype_For_Enum_Class_Alt_Decl);

         function Allocate_Enum_Class_Alt_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Alt_Decl;

         function Allocate_Enum_Class_Alt_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Alt_Decl
         is
            Result      : constant Access_To_Subtype_For_Enum_Class_Alt_Decl := Bare_Enum_Class_Alt_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Enum_Class_Alt_Decl;
            return Bare_Enum_Class_Alt_Decl (Result);
         end Allocate_Enum_Class_Alt_Decl;

         
         subtype Subtype_For_Function_Type is
            Root_Node_Record (Lkt_Function_Type);
         type Access_To_Subtype_For_Function_Type is access all Subtype_For_Function_Type;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Function_Type);
         package Bare_Function_Type_Alloc is new Alloc
           (Subtype_For_Function_Type, Access_To_Subtype_For_Function_Type);

         function Allocate_Function_Type
           (Pool : Bump_Ptr_Pool) return Bare_Function_Type;

         function Allocate_Function_Type
           (Pool : Bump_Ptr_Pool) return Bare_Function_Type
         is
            Result      : constant Access_To_Subtype_For_Function_Type := Bare_Function_Type_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Function_Type;
            return Bare_Function_Type (Result);
         end Allocate_Function_Type;

         
         subtype Subtype_For_Generic_Param_Type_Decl is
            Root_Node_Record (Lkt_Generic_Param_Type_Decl);
         type Access_To_Subtype_For_Generic_Param_Type_Decl is access all Subtype_For_Generic_Param_Type_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Generic_Param_Type_Decl);
         package Bare_Generic_Param_Type_Decl_Alloc is new Alloc
           (Subtype_For_Generic_Param_Type_Decl, Access_To_Subtype_For_Generic_Param_Type_Decl);

         function Allocate_Generic_Param_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Param_Type_Decl;

         function Allocate_Generic_Param_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Param_Type_Decl
         is
            Result      : constant Access_To_Subtype_For_Generic_Param_Type_Decl := Bare_Generic_Param_Type_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Generic_Param_Type_Decl;
            return Bare_Generic_Param_Type_Decl (Result);
         end Allocate_Generic_Param_Type_Decl;

         
         subtype Subtype_For_Class_Decl is
            Root_Node_Record (Lkt_Class_Decl);
         type Access_To_Subtype_For_Class_Decl is access all Subtype_For_Class_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Class_Decl);
         package Bare_Class_Decl_Alloc is new Alloc
           (Subtype_For_Class_Decl, Access_To_Subtype_For_Class_Decl);

         function Allocate_Class_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Class_Decl;

         function Allocate_Class_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Class_Decl
         is
            Result      : constant Access_To_Subtype_For_Class_Decl := Bare_Class_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Class_Decl;
            return Bare_Class_Decl (Result);
         end Allocate_Class_Decl;

         
         subtype Subtype_For_Enum_Class_Decl is
            Root_Node_Record (Lkt_Enum_Class_Decl);
         type Access_To_Subtype_For_Enum_Class_Decl is access all Subtype_For_Enum_Class_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Enum_Class_Decl);
         package Bare_Enum_Class_Decl_Alloc is new Alloc
           (Subtype_For_Enum_Class_Decl, Access_To_Subtype_For_Enum_Class_Decl);

         function Allocate_Enum_Class_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Decl;

         function Allocate_Enum_Class_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Decl
         is
            Result      : constant Access_To_Subtype_For_Enum_Class_Decl := Bare_Enum_Class_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Enum_Class_Decl;
            return Bare_Enum_Class_Decl (Result);
         end Allocate_Enum_Class_Decl;

         
         subtype Subtype_For_Enum_Type_Decl is
            Root_Node_Record (Lkt_Enum_Type_Decl);
         type Access_To_Subtype_For_Enum_Type_Decl is access all Subtype_For_Enum_Type_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Enum_Type_Decl);
         package Bare_Enum_Type_Decl_Alloc is new Alloc
           (Subtype_For_Enum_Type_Decl, Access_To_Subtype_For_Enum_Type_Decl);

         function Allocate_Enum_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Type_Decl;

         function Allocate_Enum_Type_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Type_Decl
         is
            Result      : constant Access_To_Subtype_For_Enum_Type_Decl := Bare_Enum_Type_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Enum_Type_Decl;
            return Bare_Enum_Type_Decl (Result);
         end Allocate_Enum_Type_Decl;

         
         subtype Subtype_For_Struct_Decl is
            Root_Node_Record (Lkt_Struct_Decl);
         type Access_To_Subtype_For_Struct_Decl is access all Subtype_For_Struct_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Struct_Decl);
         package Bare_Struct_Decl_Alloc is new Alloc
           (Subtype_For_Struct_Decl, Access_To_Subtype_For_Struct_Decl);

         function Allocate_Struct_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Struct_Decl;

         function Allocate_Struct_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Struct_Decl
         is
            Result      : constant Access_To_Subtype_For_Struct_Decl := Bare_Struct_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Struct_Decl;
            return Bare_Struct_Decl (Result);
         end Allocate_Struct_Decl;

         
         subtype Subtype_For_Trait_Decl is
            Root_Node_Record (Lkt_Trait_Decl);
         type Access_To_Subtype_For_Trait_Decl is access all Subtype_For_Trait_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Trait_Decl);
         package Bare_Trait_Decl_Alloc is new Alloc
           (Subtype_For_Trait_Decl, Access_To_Subtype_For_Trait_Decl);

         function Allocate_Trait_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Trait_Decl;

         function Allocate_Trait_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Trait_Decl
         is
            Result      : constant Access_To_Subtype_For_Trait_Decl := Bare_Trait_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Trait_Decl;
            return Bare_Trait_Decl (Result);
         end Allocate_Trait_Decl;

         
         subtype Subtype_For_Decl_Annotation is
            Root_Node_Record (Lkt_Decl_Annotation);
         type Access_To_Subtype_For_Decl_Annotation is access all Subtype_For_Decl_Annotation;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Decl_Annotation);
         package Bare_Decl_Annotation_Alloc is new Alloc
           (Subtype_For_Decl_Annotation, Access_To_Subtype_For_Decl_Annotation);

         function Allocate_Decl_Annotation
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Annotation;

         function Allocate_Decl_Annotation
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Annotation
         is
            Result      : constant Access_To_Subtype_For_Decl_Annotation := Bare_Decl_Annotation_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Decl_Annotation;
            return Bare_Decl_Annotation (Result);
         end Allocate_Decl_Annotation;

         
         subtype Subtype_For_Decl_Annotation_Args is
            Root_Node_Record (Lkt_Decl_Annotation_Args);
         type Access_To_Subtype_For_Decl_Annotation_Args is access all Subtype_For_Decl_Annotation_Args;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Decl_Annotation_Args);
         package Bare_Decl_Annotation_Args_Alloc is new Alloc
           (Subtype_For_Decl_Annotation_Args, Access_To_Subtype_For_Decl_Annotation_Args);

         function Allocate_Decl_Annotation_Args
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Annotation_Args;

         function Allocate_Decl_Annotation_Args
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Annotation_Args
         is
            Result      : constant Access_To_Subtype_For_Decl_Annotation_Args := Bare_Decl_Annotation_Args_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Decl_Annotation_Args;
            return Bare_Decl_Annotation_Args (Result);
         end Allocate_Decl_Annotation_Args;

         
         subtype Subtype_For_Dyn_Env_Wrapper is
            Root_Node_Record (Lkt_Dyn_Env_Wrapper);
         type Access_To_Subtype_For_Dyn_Env_Wrapper is access all Subtype_For_Dyn_Env_Wrapper;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Dyn_Env_Wrapper);
         package Bare_Dyn_Env_Wrapper_Alloc is new Alloc
           (Subtype_For_Dyn_Env_Wrapper, Access_To_Subtype_For_Dyn_Env_Wrapper);

         function Allocate_Dyn_Env_Wrapper
           (Pool : Bump_Ptr_Pool) return Bare_Dyn_Env_Wrapper;

         function Allocate_Dyn_Env_Wrapper
           (Pool : Bump_Ptr_Pool) return Bare_Dyn_Env_Wrapper
         is
            Result      : constant Access_To_Subtype_For_Dyn_Env_Wrapper := Bare_Dyn_Env_Wrapper_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Dyn_Env_Wrapper;
            return Bare_Dyn_Env_Wrapper (Result);
         end Allocate_Dyn_Env_Wrapper;

         
         subtype Subtype_For_Elsif_Branch is
            Root_Node_Record (Lkt_Elsif_Branch);
         type Access_To_Subtype_For_Elsif_Branch is access all Subtype_For_Elsif_Branch;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Elsif_Branch);
         package Bare_Elsif_Branch_Alloc is new Alloc
           (Subtype_For_Elsif_Branch, Access_To_Subtype_For_Elsif_Branch);

         function Allocate_Elsif_Branch
           (Pool : Bump_Ptr_Pool) return Bare_Elsif_Branch;

         function Allocate_Elsif_Branch
           (Pool : Bump_Ptr_Pool) return Bare_Elsif_Branch
         is
            Result      : constant Access_To_Subtype_For_Elsif_Branch := Bare_Elsif_Branch_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Elsif_Branch;
            return Bare_Elsif_Branch (Result);
         end Allocate_Elsif_Branch;

         
         subtype Subtype_For_Enum_Class_Case is
            Root_Node_Record (Lkt_Enum_Class_Case);
         type Access_To_Subtype_For_Enum_Class_Case is access all Subtype_For_Enum_Class_Case;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Enum_Class_Case);
         package Bare_Enum_Class_Case_Alloc is new Alloc
           (Subtype_For_Enum_Class_Case, Access_To_Subtype_For_Enum_Class_Case);

         function Allocate_Enum_Class_Case
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Case;

         function Allocate_Enum_Class_Case
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Case
         is
            Result      : constant Access_To_Subtype_For_Enum_Class_Case := Bare_Enum_Class_Case_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Enum_Class_Case;
            return Bare_Enum_Class_Case (Result);
         end Allocate_Enum_Class_Case;

         
         subtype Subtype_For_Excludes_Null_Absent is
            Root_Node_Record (Lkt_Excludes_Null_Absent);
         type Access_To_Subtype_For_Excludes_Null_Absent is access all Subtype_For_Excludes_Null_Absent;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Excludes_Null_Absent);
         package Bare_Excludes_Null_Absent_Alloc is new Alloc
           (Subtype_For_Excludes_Null_Absent, Access_To_Subtype_For_Excludes_Null_Absent);

         function Allocate_Excludes_Null_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Excludes_Null_Absent;

         function Allocate_Excludes_Null_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Excludes_Null_Absent
         is
            Result      : constant Access_To_Subtype_For_Excludes_Null_Absent := Bare_Excludes_Null_Absent_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Excludes_Null_Absent;
            return Bare_Excludes_Null_Absent (Result);
         end Allocate_Excludes_Null_Absent;

         
         subtype Subtype_For_Excludes_Null_Present is
            Root_Node_Record (Lkt_Excludes_Null_Present);
         type Access_To_Subtype_For_Excludes_Null_Present is access all Subtype_For_Excludes_Null_Present;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Excludes_Null_Present);
         package Bare_Excludes_Null_Present_Alloc is new Alloc
           (Subtype_For_Excludes_Null_Present, Access_To_Subtype_For_Excludes_Null_Present);

         function Allocate_Excludes_Null_Present
           (Pool : Bump_Ptr_Pool) return Bare_Excludes_Null_Present;

         function Allocate_Excludes_Null_Present
           (Pool : Bump_Ptr_Pool) return Bare_Excludes_Null_Present
         is
            Result      : constant Access_To_Subtype_For_Excludes_Null_Present := Bare_Excludes_Null_Present_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Excludes_Null_Present;
            return Bare_Excludes_Null_Present (Result);
         end Allocate_Excludes_Null_Present;

         
         subtype Subtype_For_Any_Of is
            Root_Node_Record (Lkt_Any_Of);
         type Access_To_Subtype_For_Any_Of is access all Subtype_For_Any_Of;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Any_Of);
         package Bare_Any_Of_Alloc is new Alloc
           (Subtype_For_Any_Of, Access_To_Subtype_For_Any_Of);

         function Allocate_Any_Of
           (Pool : Bump_Ptr_Pool) return Bare_Any_Of;

         function Allocate_Any_Of
           (Pool : Bump_Ptr_Pool) return Bare_Any_Of
         is
            Result      : constant Access_To_Subtype_For_Any_Of := Bare_Any_Of_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Any_Of;
            return Bare_Any_Of (Result);
         end Allocate_Any_Of;

         
         subtype Subtype_For_Array_Literal is
            Root_Node_Record (Lkt_Array_Literal);
         type Access_To_Subtype_For_Array_Literal is access all Subtype_For_Array_Literal;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Array_Literal);
         package Bare_Array_Literal_Alloc is new Alloc
           (Subtype_For_Array_Literal, Access_To_Subtype_For_Array_Literal);

         function Allocate_Array_Literal
           (Pool : Bump_Ptr_Pool) return Bare_Array_Literal;

         function Allocate_Array_Literal
           (Pool : Bump_Ptr_Pool) return Bare_Array_Literal
         is
            Result      : constant Access_To_Subtype_For_Array_Literal := Bare_Array_Literal_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Array_Literal;
            return Bare_Array_Literal (Result);
         end Allocate_Array_Literal;

         
         subtype Subtype_For_Call_Expr is
            Root_Node_Record (Lkt_Call_Expr);
         type Access_To_Subtype_For_Call_Expr is access all Subtype_For_Call_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Call_Expr);
         package Bare_Call_Expr_Alloc is new Alloc
           (Subtype_For_Call_Expr, Access_To_Subtype_For_Call_Expr);

         function Allocate_Call_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Call_Expr;

         function Allocate_Call_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Call_Expr
         is
            Result      : constant Access_To_Subtype_For_Call_Expr := Bare_Call_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Call_Expr;
            return Bare_Call_Expr (Result);
         end Allocate_Call_Expr;

         
         subtype Subtype_For_Logic_Predicate is
            Root_Node_Record (Lkt_Logic_Predicate);
         type Access_To_Subtype_For_Logic_Predicate is access all Subtype_For_Logic_Predicate;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Logic_Predicate);
         package Bare_Logic_Predicate_Alloc is new Alloc
           (Subtype_For_Logic_Predicate, Access_To_Subtype_For_Logic_Predicate);

         function Allocate_Logic_Predicate
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Predicate;

         function Allocate_Logic_Predicate
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Predicate
         is
            Result      : constant Access_To_Subtype_For_Logic_Predicate := Bare_Logic_Predicate_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Logic_Predicate;
            return Bare_Logic_Predicate (Result);
         end Allocate_Logic_Predicate;

         
         subtype Subtype_For_Logic_Propagate_Call is
            Root_Node_Record (Lkt_Logic_Propagate_Call);
         type Access_To_Subtype_For_Logic_Propagate_Call is access all Subtype_For_Logic_Propagate_Call;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Logic_Propagate_Call);
         package Bare_Logic_Propagate_Call_Alloc is new Alloc
           (Subtype_For_Logic_Propagate_Call, Access_To_Subtype_For_Logic_Propagate_Call);

         function Allocate_Logic_Propagate_Call
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Propagate_Call;

         function Allocate_Logic_Propagate_Call
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Propagate_Call
         is
            Result      : constant Access_To_Subtype_For_Logic_Propagate_Call := Bare_Logic_Propagate_Call_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Logic_Propagate_Call;
            return Bare_Logic_Propagate_Call (Result);
         end Allocate_Logic_Propagate_Call;

         
         subtype Subtype_For_Bin_Op is
            Root_Node_Record (Lkt_Bin_Op);
         type Access_To_Subtype_For_Bin_Op is access all Subtype_For_Bin_Op;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Bin_Op);
         package Bare_Bin_Op_Alloc is new Alloc
           (Subtype_For_Bin_Op, Access_To_Subtype_For_Bin_Op);

         function Allocate_Bin_Op
           (Pool : Bump_Ptr_Pool) return Bare_Bin_Op;

         function Allocate_Bin_Op
           (Pool : Bump_Ptr_Pool) return Bare_Bin_Op
         is
            Result      : constant Access_To_Subtype_For_Bin_Op := Bare_Bin_Op_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Bin_Op;
            return Bare_Bin_Op (Result);
         end Allocate_Bin_Op;

         
         subtype Subtype_For_Block_Expr is
            Root_Node_Record (Lkt_Block_Expr);
         type Access_To_Subtype_For_Block_Expr is access all Subtype_For_Block_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Block_Expr);
         package Bare_Block_Expr_Alloc is new Alloc
           (Subtype_For_Block_Expr, Access_To_Subtype_For_Block_Expr);

         function Allocate_Block_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Block_Expr;

         function Allocate_Block_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Block_Expr
         is
            Result      : constant Access_To_Subtype_For_Block_Expr := Bare_Block_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Block_Expr;
            return Bare_Block_Expr (Result);
         end Allocate_Block_Expr;

         
         subtype Subtype_For_Cast_Expr is
            Root_Node_Record (Lkt_Cast_Expr);
         type Access_To_Subtype_For_Cast_Expr is access all Subtype_For_Cast_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Cast_Expr);
         package Bare_Cast_Expr_Alloc is new Alloc
           (Subtype_For_Cast_Expr, Access_To_Subtype_For_Cast_Expr);

         function Allocate_Cast_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Cast_Expr;

         function Allocate_Cast_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Cast_Expr
         is
            Result      : constant Access_To_Subtype_For_Cast_Expr := Bare_Cast_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Cast_Expr;
            return Bare_Cast_Expr (Result);
         end Allocate_Cast_Expr;

         
         subtype Subtype_For_Dot_Expr is
            Root_Node_Record (Lkt_Dot_Expr);
         type Access_To_Subtype_For_Dot_Expr is access all Subtype_For_Dot_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Dot_Expr);
         package Bare_Dot_Expr_Alloc is new Alloc
           (Subtype_For_Dot_Expr, Access_To_Subtype_For_Dot_Expr);

         function Allocate_Dot_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Dot_Expr;

         function Allocate_Dot_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Dot_Expr
         is
            Result      : constant Access_To_Subtype_For_Dot_Expr := Bare_Dot_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Dot_Expr;
            return Bare_Dot_Expr (Result);
         end Allocate_Dot_Expr;

         
         subtype Subtype_For_Error_On_Null is
            Root_Node_Record (Lkt_Error_On_Null);
         type Access_To_Subtype_For_Error_On_Null is access all Subtype_For_Error_On_Null;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Error_On_Null);
         package Bare_Error_On_Null_Alloc is new Alloc
           (Subtype_For_Error_On_Null, Access_To_Subtype_For_Error_On_Null);

         function Allocate_Error_On_Null
           (Pool : Bump_Ptr_Pool) return Bare_Error_On_Null;

         function Allocate_Error_On_Null
           (Pool : Bump_Ptr_Pool) return Bare_Error_On_Null
         is
            Result      : constant Access_To_Subtype_For_Error_On_Null := Bare_Error_On_Null_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Error_On_Null;
            return Bare_Error_On_Null (Result);
         end Allocate_Error_On_Null;

         
         subtype Subtype_For_Generic_Instantiation is
            Root_Node_Record (Lkt_Generic_Instantiation);
         type Access_To_Subtype_For_Generic_Instantiation is access all Subtype_For_Generic_Instantiation;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Generic_Instantiation);
         package Bare_Generic_Instantiation_Alloc is new Alloc
           (Subtype_For_Generic_Instantiation, Access_To_Subtype_For_Generic_Instantiation);

         function Allocate_Generic_Instantiation
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Instantiation;

         function Allocate_Generic_Instantiation
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Instantiation
         is
            Result      : constant Access_To_Subtype_For_Generic_Instantiation := Bare_Generic_Instantiation_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Generic_Instantiation;
            return Bare_Generic_Instantiation (Result);
         end Allocate_Generic_Instantiation;

         
         subtype Subtype_For_Error_Grammar_Expr is
            Root_Node_Record (Lkt_Error_Grammar_Expr);
         type Access_To_Subtype_For_Error_Grammar_Expr is access all Subtype_For_Error_Grammar_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Error_Grammar_Expr);
         package Bare_Error_Grammar_Expr_Alloc is new Alloc
           (Subtype_For_Error_Grammar_Expr, Access_To_Subtype_For_Error_Grammar_Expr);

         function Allocate_Error_Grammar_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Error_Grammar_Expr;

         function Allocate_Error_Grammar_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Error_Grammar_Expr
         is
            Result      : constant Access_To_Subtype_For_Error_Grammar_Expr := Bare_Error_Grammar_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Error_Grammar_Expr;
            return Bare_Error_Grammar_Expr (Result);
         end Allocate_Error_Grammar_Expr;

         
         subtype Subtype_For_Grammar_Cut is
            Root_Node_Record (Lkt_Grammar_Cut);
         type Access_To_Subtype_For_Grammar_Cut is access all Subtype_For_Grammar_Cut;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Cut);
         package Bare_Grammar_Cut_Alloc is new Alloc
           (Subtype_For_Grammar_Cut, Access_To_Subtype_For_Grammar_Cut);

         function Allocate_Grammar_Cut
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Cut;

         function Allocate_Grammar_Cut
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Cut
         is
            Result      : constant Access_To_Subtype_For_Grammar_Cut := Bare_Grammar_Cut_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Cut;
            return Bare_Grammar_Cut (Result);
         end Allocate_Grammar_Cut;

         
         subtype Subtype_For_Grammar_Discard is
            Root_Node_Record (Lkt_Grammar_Discard);
         type Access_To_Subtype_For_Grammar_Discard is access all Subtype_For_Grammar_Discard;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Discard);
         package Bare_Grammar_Discard_Alloc is new Alloc
           (Subtype_For_Grammar_Discard, Access_To_Subtype_For_Grammar_Discard);

         function Allocate_Grammar_Discard
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Discard;

         function Allocate_Grammar_Discard
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Discard
         is
            Result      : constant Access_To_Subtype_For_Grammar_Discard := Bare_Grammar_Discard_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Discard;
            return Bare_Grammar_Discard (Result);
         end Allocate_Grammar_Discard;

         
         subtype Subtype_For_Grammar_Dont_Skip is
            Root_Node_Record (Lkt_Grammar_Dont_Skip);
         type Access_To_Subtype_For_Grammar_Dont_Skip is access all Subtype_For_Grammar_Dont_Skip;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Dont_Skip);
         package Bare_Grammar_Dont_Skip_Alloc is new Alloc
           (Subtype_For_Grammar_Dont_Skip, Access_To_Subtype_For_Grammar_Dont_Skip);

         function Allocate_Grammar_Dont_Skip
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Dont_Skip;

         function Allocate_Grammar_Dont_Skip
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Dont_Skip
         is
            Result      : constant Access_To_Subtype_For_Grammar_Dont_Skip := Bare_Grammar_Dont_Skip_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Dont_Skip;
            return Bare_Grammar_Dont_Skip (Result);
         end Allocate_Grammar_Dont_Skip;

         
         subtype Subtype_For_Grammar_List is
            Root_Node_Record (Lkt_Grammar_List);
         type Access_To_Subtype_For_Grammar_List is access all Subtype_For_Grammar_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_List);
         package Bare_Grammar_List_Alloc is new Alloc
           (Subtype_For_Grammar_List, Access_To_Subtype_For_Grammar_List);

         function Allocate_Grammar_List
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_List;

         function Allocate_Grammar_List
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_List
         is
            Result      : constant Access_To_Subtype_For_Grammar_List := Bare_Grammar_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_List;
            return Bare_Grammar_List (Result);
         end Allocate_Grammar_List;

         
         subtype Subtype_For_Grammar_Null is
            Root_Node_Record (Lkt_Grammar_Null);
         type Access_To_Subtype_For_Grammar_Null is access all Subtype_For_Grammar_Null;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Null);
         package Bare_Grammar_Null_Alloc is new Alloc
           (Subtype_For_Grammar_Null, Access_To_Subtype_For_Grammar_Null);

         function Allocate_Grammar_Null
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Null;

         function Allocate_Grammar_Null
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Null
         is
            Result      : constant Access_To_Subtype_For_Grammar_Null := Bare_Grammar_Null_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Null;
            return Bare_Grammar_Null (Result);
         end Allocate_Grammar_Null;

         
         subtype Subtype_For_Grammar_Opt is
            Root_Node_Record (Lkt_Grammar_Opt);
         type Access_To_Subtype_For_Grammar_Opt is access all Subtype_For_Grammar_Opt;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Opt);
         package Bare_Grammar_Opt_Alloc is new Alloc
           (Subtype_For_Grammar_Opt, Access_To_Subtype_For_Grammar_Opt);

         function Allocate_Grammar_Opt
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Opt;

         function Allocate_Grammar_Opt
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Opt
         is
            Result      : constant Access_To_Subtype_For_Grammar_Opt := Bare_Grammar_Opt_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Opt;
            return Bare_Grammar_Opt (Result);
         end Allocate_Grammar_Opt;

         
         subtype Subtype_For_Grammar_Opt_Error is
            Root_Node_Record (Lkt_Grammar_Opt_Error);
         type Access_To_Subtype_For_Grammar_Opt_Error is access all Subtype_For_Grammar_Opt_Error;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Opt_Error);
         package Bare_Grammar_Opt_Error_Alloc is new Alloc
           (Subtype_For_Grammar_Opt_Error, Access_To_Subtype_For_Grammar_Opt_Error);

         function Allocate_Grammar_Opt_Error
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Opt_Error;

         function Allocate_Grammar_Opt_Error
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Opt_Error
         is
            Result      : constant Access_To_Subtype_For_Grammar_Opt_Error := Bare_Grammar_Opt_Error_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Opt_Error;
            return Bare_Grammar_Opt_Error (Result);
         end Allocate_Grammar_Opt_Error;

         
         subtype Subtype_For_Grammar_Opt_Error_Group is
            Root_Node_Record (Lkt_Grammar_Opt_Error_Group);
         type Access_To_Subtype_For_Grammar_Opt_Error_Group is access all Subtype_For_Grammar_Opt_Error_Group;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Opt_Error_Group);
         package Bare_Grammar_Opt_Error_Group_Alloc is new Alloc
           (Subtype_For_Grammar_Opt_Error_Group, Access_To_Subtype_For_Grammar_Opt_Error_Group);

         function Allocate_Grammar_Opt_Error_Group
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Opt_Error_Group;

         function Allocate_Grammar_Opt_Error_Group
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Opt_Error_Group
         is
            Result      : constant Access_To_Subtype_For_Grammar_Opt_Error_Group := Bare_Grammar_Opt_Error_Group_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Opt_Error_Group;
            return Bare_Grammar_Opt_Error_Group (Result);
         end Allocate_Grammar_Opt_Error_Group;

         
         subtype Subtype_For_Grammar_Opt_Group is
            Root_Node_Record (Lkt_Grammar_Opt_Group);
         type Access_To_Subtype_For_Grammar_Opt_Group is access all Subtype_For_Grammar_Opt_Group;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Opt_Group);
         package Bare_Grammar_Opt_Group_Alloc is new Alloc
           (Subtype_For_Grammar_Opt_Group, Access_To_Subtype_For_Grammar_Opt_Group);

         function Allocate_Grammar_Opt_Group
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Opt_Group;

         function Allocate_Grammar_Opt_Group
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Opt_Group
         is
            Result      : constant Access_To_Subtype_For_Grammar_Opt_Group := Bare_Grammar_Opt_Group_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Opt_Group;
            return Bare_Grammar_Opt_Group (Result);
         end Allocate_Grammar_Opt_Group;

         
         subtype Subtype_For_Grammar_Or_Expr is
            Root_Node_Record (Lkt_Grammar_Or_Expr);
         type Access_To_Subtype_For_Grammar_Or_Expr is access all Subtype_For_Grammar_Or_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Or_Expr);
         package Bare_Grammar_Or_Expr_Alloc is new Alloc
           (Subtype_For_Grammar_Or_Expr, Access_To_Subtype_For_Grammar_Or_Expr);

         function Allocate_Grammar_Or_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Or_Expr;

         function Allocate_Grammar_Or_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Or_Expr
         is
            Result      : constant Access_To_Subtype_For_Grammar_Or_Expr := Bare_Grammar_Or_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Or_Expr;
            return Bare_Grammar_Or_Expr (Result);
         end Allocate_Grammar_Or_Expr;

         
         subtype Subtype_For_Grammar_Pick is
            Root_Node_Record (Lkt_Grammar_Pick);
         type Access_To_Subtype_For_Grammar_Pick is access all Subtype_For_Grammar_Pick;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Pick);
         package Bare_Grammar_Pick_Alloc is new Alloc
           (Subtype_For_Grammar_Pick, Access_To_Subtype_For_Grammar_Pick);

         function Allocate_Grammar_Pick
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Pick;

         function Allocate_Grammar_Pick
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Pick
         is
            Result      : constant Access_To_Subtype_For_Grammar_Pick := Bare_Grammar_Pick_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Pick;
            return Bare_Grammar_Pick (Result);
         end Allocate_Grammar_Pick;

         
         subtype Subtype_For_Grammar_Implicit_Pick is
            Root_Node_Record (Lkt_Grammar_Implicit_Pick);
         type Access_To_Subtype_For_Grammar_Implicit_Pick is access all Subtype_For_Grammar_Implicit_Pick;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Implicit_Pick);
         package Bare_Grammar_Implicit_Pick_Alloc is new Alloc
           (Subtype_For_Grammar_Implicit_Pick, Access_To_Subtype_For_Grammar_Implicit_Pick);

         function Allocate_Grammar_Implicit_Pick
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Implicit_Pick;

         function Allocate_Grammar_Implicit_Pick
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Implicit_Pick
         is
            Result      : constant Access_To_Subtype_For_Grammar_Implicit_Pick := Bare_Grammar_Implicit_Pick_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Implicit_Pick;
            return Bare_Grammar_Implicit_Pick (Result);
         end Allocate_Grammar_Implicit_Pick;

         
         subtype Subtype_For_Grammar_Predicate is
            Root_Node_Record (Lkt_Grammar_Predicate);
         type Access_To_Subtype_For_Grammar_Predicate is access all Subtype_For_Grammar_Predicate;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Predicate);
         package Bare_Grammar_Predicate_Alloc is new Alloc
           (Subtype_For_Grammar_Predicate, Access_To_Subtype_For_Grammar_Predicate);

         function Allocate_Grammar_Predicate
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Predicate;

         function Allocate_Grammar_Predicate
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Predicate
         is
            Result      : constant Access_To_Subtype_For_Grammar_Predicate := Bare_Grammar_Predicate_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Predicate;
            return Bare_Grammar_Predicate (Result);
         end Allocate_Grammar_Predicate;

         
         subtype Subtype_For_Grammar_Rule_Ref is
            Root_Node_Record (Lkt_Grammar_Rule_Ref);
         type Access_To_Subtype_For_Grammar_Rule_Ref is access all Subtype_For_Grammar_Rule_Ref;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Rule_Ref);
         package Bare_Grammar_Rule_Ref_Alloc is new Alloc
           (Subtype_For_Grammar_Rule_Ref, Access_To_Subtype_For_Grammar_Rule_Ref);

         function Allocate_Grammar_Rule_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Rule_Ref;

         function Allocate_Grammar_Rule_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Rule_Ref
         is
            Result      : constant Access_To_Subtype_For_Grammar_Rule_Ref := Bare_Grammar_Rule_Ref_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Rule_Ref;
            return Bare_Grammar_Rule_Ref (Result);
         end Allocate_Grammar_Rule_Ref;

         
         subtype Subtype_For_Grammar_Skip is
            Root_Node_Record (Lkt_Grammar_Skip);
         type Access_To_Subtype_For_Grammar_Skip is access all Subtype_For_Grammar_Skip;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Skip);
         package Bare_Grammar_Skip_Alloc is new Alloc
           (Subtype_For_Grammar_Skip, Access_To_Subtype_For_Grammar_Skip);

         function Allocate_Grammar_Skip
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Skip;

         function Allocate_Grammar_Skip
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Skip
         is
            Result      : constant Access_To_Subtype_For_Grammar_Skip := Bare_Grammar_Skip_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Skip;
            return Bare_Grammar_Skip (Result);
         end Allocate_Grammar_Skip;

         
         subtype Subtype_For_Grammar_Stop_Cut is
            Root_Node_Record (Lkt_Grammar_Stop_Cut);
         type Access_To_Subtype_For_Grammar_Stop_Cut is access all Subtype_For_Grammar_Stop_Cut;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Stop_Cut);
         package Bare_Grammar_Stop_Cut_Alloc is new Alloc
           (Subtype_For_Grammar_Stop_Cut, Access_To_Subtype_For_Grammar_Stop_Cut);

         function Allocate_Grammar_Stop_Cut
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Stop_Cut;

         function Allocate_Grammar_Stop_Cut
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Stop_Cut
         is
            Result      : constant Access_To_Subtype_For_Grammar_Stop_Cut := Bare_Grammar_Stop_Cut_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Stop_Cut;
            return Bare_Grammar_Stop_Cut (Result);
         end Allocate_Grammar_Stop_Cut;

         
         subtype Subtype_For_Parse_Node_Expr is
            Root_Node_Record (Lkt_Parse_Node_Expr);
         type Access_To_Subtype_For_Parse_Node_Expr is access all Subtype_For_Parse_Node_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Parse_Node_Expr);
         package Bare_Parse_Node_Expr_Alloc is new Alloc
           (Subtype_For_Parse_Node_Expr, Access_To_Subtype_For_Parse_Node_Expr);

         function Allocate_Parse_Node_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Parse_Node_Expr;

         function Allocate_Parse_Node_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Parse_Node_Expr
         is
            Result      : constant Access_To_Subtype_For_Parse_Node_Expr := Bare_Parse_Node_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Parse_Node_Expr;
            return Bare_Parse_Node_Expr (Result);
         end Allocate_Parse_Node_Expr;

         
         subtype Subtype_For_Token_Lit is
            Root_Node_Record (Lkt_Token_Lit);
         type Access_To_Subtype_For_Token_Lit is access all Subtype_For_Token_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Token_Lit);
         package Bare_Token_Lit_Alloc is new Alloc
           (Subtype_For_Token_Lit, Access_To_Subtype_For_Token_Lit);

         function Allocate_Token_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Token_Lit;

         function Allocate_Token_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Token_Lit
         is
            Result      : constant Access_To_Subtype_For_Token_Lit := Bare_Token_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Token_Lit;
            return Bare_Token_Lit (Result);
         end Allocate_Token_Lit;

         
         subtype Subtype_For_Token_No_Case_Lit is
            Root_Node_Record (Lkt_Token_No_Case_Lit);
         type Access_To_Subtype_For_Token_No_Case_Lit is access all Subtype_For_Token_No_Case_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Token_No_Case_Lit);
         package Bare_Token_No_Case_Lit_Alloc is new Alloc
           (Subtype_For_Token_No_Case_Lit, Access_To_Subtype_For_Token_No_Case_Lit);

         function Allocate_Token_No_Case_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Token_No_Case_Lit;

         function Allocate_Token_No_Case_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Token_No_Case_Lit
         is
            Result      : constant Access_To_Subtype_For_Token_No_Case_Lit := Bare_Token_No_Case_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Token_No_Case_Lit;
            return Bare_Token_No_Case_Lit (Result);
         end Allocate_Token_No_Case_Lit;

         
         subtype Subtype_For_Token_Pattern_Concat is
            Root_Node_Record (Lkt_Token_Pattern_Concat);
         type Access_To_Subtype_For_Token_Pattern_Concat is access all Subtype_For_Token_Pattern_Concat;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Token_Pattern_Concat);
         package Bare_Token_Pattern_Concat_Alloc is new Alloc
           (Subtype_For_Token_Pattern_Concat, Access_To_Subtype_For_Token_Pattern_Concat);

         function Allocate_Token_Pattern_Concat
           (Pool : Bump_Ptr_Pool) return Bare_Token_Pattern_Concat;

         function Allocate_Token_Pattern_Concat
           (Pool : Bump_Ptr_Pool) return Bare_Token_Pattern_Concat
         is
            Result      : constant Access_To_Subtype_For_Token_Pattern_Concat := Bare_Token_Pattern_Concat_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Token_Pattern_Concat;
            return Bare_Token_Pattern_Concat (Result);
         end Allocate_Token_Pattern_Concat;

         
         subtype Subtype_For_Token_Pattern_Lit is
            Root_Node_Record (Lkt_Token_Pattern_Lit);
         type Access_To_Subtype_For_Token_Pattern_Lit is access all Subtype_For_Token_Pattern_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Token_Pattern_Lit);
         package Bare_Token_Pattern_Lit_Alloc is new Alloc
           (Subtype_For_Token_Pattern_Lit, Access_To_Subtype_For_Token_Pattern_Lit);

         function Allocate_Token_Pattern_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Token_Pattern_Lit;

         function Allocate_Token_Pattern_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Token_Pattern_Lit
         is
            Result      : constant Access_To_Subtype_For_Token_Pattern_Lit := Bare_Token_Pattern_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Token_Pattern_Lit;
            return Bare_Token_Pattern_Lit (Result);
         end Allocate_Token_Pattern_Lit;

         
         subtype Subtype_For_Token_Ref is
            Root_Node_Record (Lkt_Token_Ref);
         type Access_To_Subtype_For_Token_Ref is access all Subtype_For_Token_Ref;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Token_Ref);
         package Bare_Token_Ref_Alloc is new Alloc
           (Subtype_For_Token_Ref, Access_To_Subtype_For_Token_Ref);

         function Allocate_Token_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Token_Ref;

         function Allocate_Token_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Token_Ref
         is
            Result      : constant Access_To_Subtype_For_Token_Ref := Bare_Token_Ref_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Token_Ref;
            return Bare_Token_Ref (Result);
         end Allocate_Token_Ref;

         
         subtype Subtype_For_Id is
            Root_Node_Record (Lkt_Id);
         type Access_To_Subtype_For_Id is access all Subtype_For_Id;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Id);
         package Bare_Id_Alloc is new Alloc
           (Subtype_For_Id, Access_To_Subtype_For_Id);

         function Allocate_Id
           (Pool : Bump_Ptr_Pool) return Bare_Id;

         function Allocate_Id
           (Pool : Bump_Ptr_Pool) return Bare_Id
         is
            Result      : constant Access_To_Subtype_For_Id := Bare_Id_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Id;
            return Bare_Id (Result);
         end Allocate_Id;

         
         subtype Subtype_For_Def_Id is
            Root_Node_Record (Lkt_Def_Id);
         type Access_To_Subtype_For_Def_Id is access all Subtype_For_Def_Id;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Def_Id);
         package Bare_Def_Id_Alloc is new Alloc
           (Subtype_For_Def_Id, Access_To_Subtype_For_Def_Id);

         function Allocate_Def_Id
           (Pool : Bump_Ptr_Pool) return Bare_Def_Id;

         function Allocate_Def_Id
           (Pool : Bump_Ptr_Pool) return Bare_Def_Id
         is
            Result      : constant Access_To_Subtype_For_Def_Id := Bare_Def_Id_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Def_Id;
            return Bare_Def_Id (Result);
         end Allocate_Def_Id;

         
         subtype Subtype_For_Imported_Id is
            Root_Node_Record (Lkt_Imported_Id);
         type Access_To_Subtype_For_Imported_Id is access all Subtype_For_Imported_Id;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Imported_Id);
         package Bare_Imported_Id_Alloc is new Alloc
           (Subtype_For_Imported_Id, Access_To_Subtype_For_Imported_Id);

         function Allocate_Imported_Id
           (Pool : Bump_Ptr_Pool) return Bare_Imported_Id;

         function Allocate_Imported_Id
           (Pool : Bump_Ptr_Pool) return Bare_Imported_Id
         is
            Result      : constant Access_To_Subtype_For_Imported_Id := Bare_Imported_Id_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Imported_Id;
            return Bare_Imported_Id (Result);
         end Allocate_Imported_Id;

         
         subtype Subtype_For_Module_Id is
            Root_Node_Record (Lkt_Module_Id);
         type Access_To_Subtype_For_Module_Id is access all Subtype_For_Module_Id;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Module_Id);
         package Bare_Module_Id_Alloc is new Alloc
           (Subtype_For_Module_Id, Access_To_Subtype_For_Module_Id);

         function Allocate_Module_Id
           (Pool : Bump_Ptr_Pool) return Bare_Module_Id;

         function Allocate_Module_Id
           (Pool : Bump_Ptr_Pool) return Bare_Module_Id
         is
            Result      : constant Access_To_Subtype_For_Module_Id := Bare_Module_Id_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Module_Id;
            return Bare_Module_Id (Result);
         end Allocate_Module_Id;

         
         subtype Subtype_For_Ref_Id is
            Root_Node_Record (Lkt_Ref_Id);
         type Access_To_Subtype_For_Ref_Id is access all Subtype_For_Ref_Id;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Ref_Id);
         package Bare_Ref_Id_Alloc is new Alloc
           (Subtype_For_Ref_Id, Access_To_Subtype_For_Ref_Id);

         function Allocate_Ref_Id
           (Pool : Bump_Ptr_Pool) return Bare_Ref_Id;

         function Allocate_Ref_Id
           (Pool : Bump_Ptr_Pool) return Bare_Ref_Id
         is
            Result      : constant Access_To_Subtype_For_Ref_Id := Bare_Ref_Id_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Ref_Id;
            return Bare_Ref_Id (Result);
         end Allocate_Ref_Id;

         
         subtype Subtype_For_If_Expr is
            Root_Node_Record (Lkt_If_Expr);
         type Access_To_Subtype_For_If_Expr is access all Subtype_For_If_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_If_Expr);
         package Bare_If_Expr_Alloc is new Alloc
           (Subtype_For_If_Expr, Access_To_Subtype_For_If_Expr);

         function Allocate_If_Expr
           (Pool : Bump_Ptr_Pool) return Bare_If_Expr;

         function Allocate_If_Expr
           (Pool : Bump_Ptr_Pool) return Bare_If_Expr
         is
            Result      : constant Access_To_Subtype_For_If_Expr := Bare_If_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_If_Expr;
            return Bare_If_Expr (Result);
         end Allocate_If_Expr;

         
         subtype Subtype_For_Isa is
            Root_Node_Record (Lkt_Isa);
         type Access_To_Subtype_For_Isa is access all Subtype_For_Isa;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Isa);
         package Bare_Isa_Alloc is new Alloc
           (Subtype_For_Isa, Access_To_Subtype_For_Isa);

         function Allocate_Isa
           (Pool : Bump_Ptr_Pool) return Bare_Isa;

         function Allocate_Isa
           (Pool : Bump_Ptr_Pool) return Bare_Isa
         is
            Result      : constant Access_To_Subtype_For_Isa := Bare_Isa_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Isa;
            return Bare_Isa (Result);
         end Allocate_Isa;

         
         subtype Subtype_For_Keep_Expr is
            Root_Node_Record (Lkt_Keep_Expr);
         type Access_To_Subtype_For_Keep_Expr is access all Subtype_For_Keep_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Keep_Expr);
         package Bare_Keep_Expr_Alloc is new Alloc
           (Subtype_For_Keep_Expr, Access_To_Subtype_For_Keep_Expr);

         function Allocate_Keep_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Keep_Expr;

         function Allocate_Keep_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Keep_Expr
         is
            Result      : constant Access_To_Subtype_For_Keep_Expr := Bare_Keep_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Keep_Expr;
            return Bare_Keep_Expr (Result);
         end Allocate_Keep_Expr;

         
         subtype Subtype_For_Lambda_Expr is
            Root_Node_Record (Lkt_Lambda_Expr);
         type Access_To_Subtype_For_Lambda_Expr is access all Subtype_For_Lambda_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lambda_Expr);
         package Bare_Lambda_Expr_Alloc is new Alloc
           (Subtype_For_Lambda_Expr, Access_To_Subtype_For_Lambda_Expr);

         function Allocate_Lambda_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Lambda_Expr;

         function Allocate_Lambda_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Lambda_Expr
         is
            Result      : constant Access_To_Subtype_For_Lambda_Expr := Bare_Lambda_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lambda_Expr;
            return Bare_Lambda_Expr (Result);
         end Allocate_Lambda_Expr;

         
         subtype Subtype_For_Big_Num_Lit is
            Root_Node_Record (Lkt_Big_Num_Lit);
         type Access_To_Subtype_For_Big_Num_Lit is access all Subtype_For_Big_Num_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Big_Num_Lit);
         package Bare_Big_Num_Lit_Alloc is new Alloc
           (Subtype_For_Big_Num_Lit, Access_To_Subtype_For_Big_Num_Lit);

         function Allocate_Big_Num_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Big_Num_Lit;

         function Allocate_Big_Num_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Big_Num_Lit
         is
            Result      : constant Access_To_Subtype_For_Big_Num_Lit := Bare_Big_Num_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Big_Num_Lit;
            return Bare_Big_Num_Lit (Result);
         end Allocate_Big_Num_Lit;

         
         subtype Subtype_For_Char_Lit is
            Root_Node_Record (Lkt_Char_Lit);
         type Access_To_Subtype_For_Char_Lit is access all Subtype_For_Char_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Char_Lit);
         package Bare_Char_Lit_Alloc is new Alloc
           (Subtype_For_Char_Lit, Access_To_Subtype_For_Char_Lit);

         function Allocate_Char_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Char_Lit;

         function Allocate_Char_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Char_Lit
         is
            Result      : constant Access_To_Subtype_For_Char_Lit := Bare_Char_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Char_Lit;
            return Bare_Char_Lit (Result);
         end Allocate_Char_Lit;

         
         subtype Subtype_For_Null_Lit is
            Root_Node_Record (Lkt_Null_Lit);
         type Access_To_Subtype_For_Null_Lit is access all Subtype_For_Null_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Null_Lit);
         package Bare_Null_Lit_Alloc is new Alloc
           (Subtype_For_Null_Lit, Access_To_Subtype_For_Null_Lit);

         function Allocate_Null_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Null_Lit;

         function Allocate_Null_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Null_Lit
         is
            Result      : constant Access_To_Subtype_For_Null_Lit := Bare_Null_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Null_Lit;
            return Bare_Null_Lit (Result);
         end Allocate_Null_Lit;

         
         subtype Subtype_For_Num_Lit is
            Root_Node_Record (Lkt_Num_Lit);
         type Access_To_Subtype_For_Num_Lit is access all Subtype_For_Num_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Num_Lit);
         package Bare_Num_Lit_Alloc is new Alloc
           (Subtype_For_Num_Lit, Access_To_Subtype_For_Num_Lit);

         function Allocate_Num_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Num_Lit;

         function Allocate_Num_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Num_Lit
         is
            Result      : constant Access_To_Subtype_For_Num_Lit := Bare_Num_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Num_Lit;
            return Bare_Num_Lit (Result);
         end Allocate_Num_Lit;

         
         subtype Subtype_For_Block_String_Lit is
            Root_Node_Record (Lkt_Block_String_Lit);
         type Access_To_Subtype_For_Block_String_Lit is access all Subtype_For_Block_String_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Block_String_Lit);
         package Bare_Block_String_Lit_Alloc is new Alloc
           (Subtype_For_Block_String_Lit, Access_To_Subtype_For_Block_String_Lit);

         function Allocate_Block_String_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Block_String_Lit;

         function Allocate_Block_String_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Block_String_Lit
         is
            Result      : constant Access_To_Subtype_For_Block_String_Lit := Bare_Block_String_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Block_String_Lit;
            return Bare_Block_String_Lit (Result);
         end Allocate_Block_String_Lit;

         
         subtype Subtype_For_Module_Doc_String_Lit is
            Root_Node_Record (Lkt_Module_Doc_String_Lit);
         type Access_To_Subtype_For_Module_Doc_String_Lit is access all Subtype_For_Module_Doc_String_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Module_Doc_String_Lit);
         package Bare_Module_Doc_String_Lit_Alloc is new Alloc
           (Subtype_For_Module_Doc_String_Lit, Access_To_Subtype_For_Module_Doc_String_Lit);

         function Allocate_Module_Doc_String_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Module_Doc_String_Lit;

         function Allocate_Module_Doc_String_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Module_Doc_String_Lit
         is
            Result      : constant Access_To_Subtype_For_Module_Doc_String_Lit := Bare_Module_Doc_String_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Module_Doc_String_Lit;
            return Bare_Module_Doc_String_Lit (Result);
         end Allocate_Module_Doc_String_Lit;

         
         subtype Subtype_For_Single_Line_String_Lit is
            Root_Node_Record (Lkt_Single_Line_String_Lit);
         type Access_To_Subtype_For_Single_Line_String_Lit is access all Subtype_For_Single_Line_String_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Single_Line_String_Lit);
         package Bare_Single_Line_String_Lit_Alloc is new Alloc
           (Subtype_For_Single_Line_String_Lit, Access_To_Subtype_For_Single_Line_String_Lit);

         function Allocate_Single_Line_String_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Single_Line_String_Lit;

         function Allocate_Single_Line_String_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Single_Line_String_Lit
         is
            Result      : constant Access_To_Subtype_For_Single_Line_String_Lit := Bare_Single_Line_String_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Single_Line_String_Lit;
            return Bare_Single_Line_String_Lit (Result);
         end Allocate_Single_Line_String_Lit;

         
         subtype Subtype_For_Pattern_Single_Line_String_Lit is
            Root_Node_Record (Lkt_Pattern_Single_Line_String_Lit);
         type Access_To_Subtype_For_Pattern_Single_Line_String_Lit is access all Subtype_For_Pattern_Single_Line_String_Lit;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Pattern_Single_Line_String_Lit);
         package Bare_Pattern_Single_Line_String_Lit_Alloc is new Alloc
           (Subtype_For_Pattern_Single_Line_String_Lit, Access_To_Subtype_For_Pattern_Single_Line_String_Lit);

         function Allocate_Pattern_Single_Line_String_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Pattern_Single_Line_String_Lit;

         function Allocate_Pattern_Single_Line_String_Lit
           (Pool : Bump_Ptr_Pool) return Bare_Pattern_Single_Line_String_Lit
         is
            Result      : constant Access_To_Subtype_For_Pattern_Single_Line_String_Lit := Bare_Pattern_Single_Line_String_Lit_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Pattern_Single_Line_String_Lit;
            return Bare_Pattern_Single_Line_String_Lit (Result);
         end Allocate_Pattern_Single_Line_String_Lit;

         
         subtype Subtype_For_Logic_Assign is
            Root_Node_Record (Lkt_Logic_Assign);
         type Access_To_Subtype_For_Logic_Assign is access all Subtype_For_Logic_Assign;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Logic_Assign);
         package Bare_Logic_Assign_Alloc is new Alloc
           (Subtype_For_Logic_Assign, Access_To_Subtype_For_Logic_Assign);

         function Allocate_Logic_Assign
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Assign;

         function Allocate_Logic_Assign
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Assign
         is
            Result      : constant Access_To_Subtype_For_Logic_Assign := Bare_Logic_Assign_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Logic_Assign;
            return Bare_Logic_Assign (Result);
         end Allocate_Logic_Assign;

         
         subtype Subtype_For_Logic_Expr is
            Root_Node_Record (Lkt_Logic_Expr);
         type Access_To_Subtype_For_Logic_Expr is access all Subtype_For_Logic_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Logic_Expr);
         package Bare_Logic_Expr_Alloc is new Alloc
           (Subtype_For_Logic_Expr, Access_To_Subtype_For_Logic_Expr);

         function Allocate_Logic_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Expr;

         function Allocate_Logic_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Expr
         is
            Result      : constant Access_To_Subtype_For_Logic_Expr := Bare_Logic_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Logic_Expr;
            return Bare_Logic_Expr (Result);
         end Allocate_Logic_Expr;

         
         subtype Subtype_For_Logic_Propagate is
            Root_Node_Record (Lkt_Logic_Propagate);
         type Access_To_Subtype_For_Logic_Propagate is access all Subtype_For_Logic_Propagate;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Logic_Propagate);
         package Bare_Logic_Propagate_Alloc is new Alloc
           (Subtype_For_Logic_Propagate, Access_To_Subtype_For_Logic_Propagate);

         function Allocate_Logic_Propagate
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Propagate;

         function Allocate_Logic_Propagate
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Propagate
         is
            Result      : constant Access_To_Subtype_For_Logic_Propagate := Bare_Logic_Propagate_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Logic_Propagate;
            return Bare_Logic_Propagate (Result);
         end Allocate_Logic_Propagate;

         
         subtype Subtype_For_Logic_Unify is
            Root_Node_Record (Lkt_Logic_Unify);
         type Access_To_Subtype_For_Logic_Unify is access all Subtype_For_Logic_Unify;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Logic_Unify);
         package Bare_Logic_Unify_Alloc is new Alloc
           (Subtype_For_Logic_Unify, Access_To_Subtype_For_Logic_Unify);

         function Allocate_Logic_Unify
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Unify;

         function Allocate_Logic_Unify
           (Pool : Bump_Ptr_Pool) return Bare_Logic_Unify
         is
            Result      : constant Access_To_Subtype_For_Logic_Unify := Bare_Logic_Unify_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Logic_Unify;
            return Bare_Logic_Unify (Result);
         end Allocate_Logic_Unify;

         
         subtype Subtype_For_Match_Expr is
            Root_Node_Record (Lkt_Match_Expr);
         type Access_To_Subtype_For_Match_Expr is access all Subtype_For_Match_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Match_Expr);
         package Bare_Match_Expr_Alloc is new Alloc
           (Subtype_For_Match_Expr, Access_To_Subtype_For_Match_Expr);

         function Allocate_Match_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Match_Expr;

         function Allocate_Match_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Match_Expr
         is
            Result      : constant Access_To_Subtype_For_Match_Expr := Bare_Match_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Match_Expr;
            return Bare_Match_Expr (Result);
         end Allocate_Match_Expr;

         
         subtype Subtype_For_Not_Expr is
            Root_Node_Record (Lkt_Not_Expr);
         type Access_To_Subtype_For_Not_Expr is access all Subtype_For_Not_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Not_Expr);
         package Bare_Not_Expr_Alloc is new Alloc
           (Subtype_For_Not_Expr, Access_To_Subtype_For_Not_Expr);

         function Allocate_Not_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Not_Expr;

         function Allocate_Not_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Not_Expr
         is
            Result      : constant Access_To_Subtype_For_Not_Expr := Bare_Not_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Not_Expr;
            return Bare_Not_Expr (Result);
         end Allocate_Not_Expr;

         
         subtype Subtype_For_Paren_Expr is
            Root_Node_Record (Lkt_Paren_Expr);
         type Access_To_Subtype_For_Paren_Expr is access all Subtype_For_Paren_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Paren_Expr);
         package Bare_Paren_Expr_Alloc is new Alloc
           (Subtype_For_Paren_Expr, Access_To_Subtype_For_Paren_Expr);

         function Allocate_Paren_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Paren_Expr;

         function Allocate_Paren_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Paren_Expr
         is
            Result      : constant Access_To_Subtype_For_Paren_Expr := Bare_Paren_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Paren_Expr;
            return Bare_Paren_Expr (Result);
         end Allocate_Paren_Expr;

         
         subtype Subtype_For_Query is
            Root_Node_Record (Lkt_Query);
         type Access_To_Subtype_For_Query is access all Subtype_For_Query;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Query);
         package Bare_Query_Alloc is new Alloc
           (Subtype_For_Query, Access_To_Subtype_For_Query);

         function Allocate_Query
           (Pool : Bump_Ptr_Pool) return Bare_Query;

         function Allocate_Query
           (Pool : Bump_Ptr_Pool) return Bare_Query
         is
            Result      : constant Access_To_Subtype_For_Query := Bare_Query_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Query;
            return Bare_Query (Result);
         end Allocate_Query;

         
         subtype Subtype_For_Raise_Expr is
            Root_Node_Record (Lkt_Raise_Expr);
         type Access_To_Subtype_For_Raise_Expr is access all Subtype_For_Raise_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Raise_Expr);
         package Bare_Raise_Expr_Alloc is new Alloc
           (Subtype_For_Raise_Expr, Access_To_Subtype_For_Raise_Expr);

         function Allocate_Raise_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Raise_Expr;

         function Allocate_Raise_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Raise_Expr
         is
            Result      : constant Access_To_Subtype_For_Raise_Expr := Bare_Raise_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Raise_Expr;
            return Bare_Raise_Expr (Result);
         end Allocate_Raise_Expr;

         
         subtype Subtype_For_Subscript_Expr is
            Root_Node_Record (Lkt_Subscript_Expr);
         type Access_To_Subtype_For_Subscript_Expr is access all Subtype_For_Subscript_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Subscript_Expr);
         package Bare_Subscript_Expr_Alloc is new Alloc
           (Subtype_For_Subscript_Expr, Access_To_Subtype_For_Subscript_Expr);

         function Allocate_Subscript_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Subscript_Expr;

         function Allocate_Subscript_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Subscript_Expr
         is
            Result      : constant Access_To_Subtype_For_Subscript_Expr := Bare_Subscript_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Subscript_Expr;
            return Bare_Subscript_Expr (Result);
         end Allocate_Subscript_Expr;

         
         subtype Subtype_For_Try_Expr is
            Root_Node_Record (Lkt_Try_Expr);
         type Access_To_Subtype_For_Try_Expr is access all Subtype_For_Try_Expr;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Try_Expr);
         package Bare_Try_Expr_Alloc is new Alloc
           (Subtype_For_Try_Expr, Access_To_Subtype_For_Try_Expr);

         function Allocate_Try_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Try_Expr;

         function Allocate_Try_Expr
           (Pool : Bump_Ptr_Pool) return Bare_Try_Expr
         is
            Result      : constant Access_To_Subtype_For_Try_Expr := Bare_Try_Expr_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Try_Expr;
            return Bare_Try_Expr (Result);
         end Allocate_Try_Expr;

         
         subtype Subtype_For_Un_Op is
            Root_Node_Record (Lkt_Un_Op);
         type Access_To_Subtype_For_Un_Op is access all Subtype_For_Un_Op;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Un_Op);
         package Bare_Un_Op_Alloc is new Alloc
           (Subtype_For_Un_Op, Access_To_Subtype_For_Un_Op);

         function Allocate_Un_Op
           (Pool : Bump_Ptr_Pool) return Bare_Un_Op;

         function Allocate_Un_Op
           (Pool : Bump_Ptr_Pool) return Bare_Un_Op
         is
            Result      : constant Access_To_Subtype_For_Un_Op := Bare_Un_Op_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Un_Op;
            return Bare_Un_Op (Result);
         end Allocate_Un_Op;

         
         subtype Subtype_For_Full_Decl is
            Root_Node_Record (Lkt_Full_Decl);
         type Access_To_Subtype_For_Full_Decl is access all Subtype_For_Full_Decl;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Full_Decl);
         package Bare_Full_Decl_Alloc is new Alloc
           (Subtype_For_Full_Decl, Access_To_Subtype_For_Full_Decl);

         function Allocate_Full_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Full_Decl;

         function Allocate_Full_Decl
           (Pool : Bump_Ptr_Pool) return Bare_Full_Decl
         is
            Result      : constant Access_To_Subtype_For_Full_Decl := Bare_Full_Decl_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Full_Decl;
            return Bare_Full_Decl (Result);
         end Allocate_Full_Decl;

         
         subtype Subtype_For_Grammar_List_Sep is
            Root_Node_Record (Lkt_Grammar_List_Sep);
         type Access_To_Subtype_For_Grammar_List_Sep is access all Subtype_For_Grammar_List_Sep;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_List_Sep);
         package Bare_Grammar_List_Sep_Alloc is new Alloc
           (Subtype_For_Grammar_List_Sep, Access_To_Subtype_For_Grammar_List_Sep);

         function Allocate_Grammar_List_Sep
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_List_Sep;

         function Allocate_Grammar_List_Sep
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_List_Sep
         is
            Result      : constant Access_To_Subtype_For_Grammar_List_Sep := Bare_Grammar_List_Sep_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_List_Sep;
            return Bare_Grammar_List_Sep (Result);
         end Allocate_Grammar_List_Sep;

         
         subtype Subtype_For_Imported_Name is
            Root_Node_Record (Lkt_Imported_Name);
         type Access_To_Subtype_For_Imported_Name is access all Subtype_For_Imported_Name;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Imported_Name);
         package Bare_Imported_Name_Alloc is new Alloc
           (Subtype_For_Imported_Name, Access_To_Subtype_For_Imported_Name);

         function Allocate_Imported_Name
           (Pool : Bump_Ptr_Pool) return Bare_Imported_Name;

         function Allocate_Imported_Name
           (Pool : Bump_Ptr_Pool) return Bare_Imported_Name
         is
            Result      : constant Access_To_Subtype_For_Imported_Name := Bare_Imported_Name_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Imported_Name;
            return Bare_Imported_Name (Result);
         end Allocate_Imported_Name;

         
         subtype Subtype_For_Langkit_Root is
            Root_Node_Record (Lkt_Langkit_Root);
         type Access_To_Subtype_For_Langkit_Root is access all Subtype_For_Langkit_Root;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Langkit_Root);
         package Bare_Langkit_Root_Alloc is new Alloc
           (Subtype_For_Langkit_Root, Access_To_Subtype_For_Langkit_Root);

         function Allocate_Langkit_Root
           (Pool : Bump_Ptr_Pool) return Bare_Langkit_Root;

         function Allocate_Langkit_Root
           (Pool : Bump_Ptr_Pool) return Bare_Langkit_Root
         is
            Result      : constant Access_To_Subtype_For_Langkit_Root := Bare_Langkit_Root_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Langkit_Root;
            return Bare_Langkit_Root (Result);
         end Allocate_Langkit_Root;

         
         subtype Subtype_For_Lexer_Case_Rule is
            Root_Node_Record (Lkt_Lexer_Case_Rule);
         type Access_To_Subtype_For_Lexer_Case_Rule is access all Subtype_For_Lexer_Case_Rule;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lexer_Case_Rule);
         package Bare_Lexer_Case_Rule_Alloc is new Alloc
           (Subtype_For_Lexer_Case_Rule, Access_To_Subtype_For_Lexer_Case_Rule);

         function Allocate_Lexer_Case_Rule
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Case_Rule;

         function Allocate_Lexer_Case_Rule
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Case_Rule
         is
            Result      : constant Access_To_Subtype_For_Lexer_Case_Rule := Bare_Lexer_Case_Rule_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lexer_Case_Rule;
            return Bare_Lexer_Case_Rule (Result);
         end Allocate_Lexer_Case_Rule;

         
         subtype Subtype_For_Lexer_Case_Rule_Send is
            Root_Node_Record (Lkt_Lexer_Case_Rule_Send);
         type Access_To_Subtype_For_Lexer_Case_Rule_Send is access all Subtype_For_Lexer_Case_Rule_Send;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lexer_Case_Rule_Send);
         package Bare_Lexer_Case_Rule_Send_Alloc is new Alloc
           (Subtype_For_Lexer_Case_Rule_Send, Access_To_Subtype_For_Lexer_Case_Rule_Send);

         function Allocate_Lexer_Case_Rule_Send
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Case_Rule_Send;

         function Allocate_Lexer_Case_Rule_Send
           (Pool : Bump_Ptr_Pool) return Bare_Lexer_Case_Rule_Send
         is
            Result      : constant Access_To_Subtype_For_Lexer_Case_Rule_Send := Bare_Lexer_Case_Rule_Send_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lexer_Case_Rule_Send;
            return Bare_Lexer_Case_Rule_Send (Result);
         end Allocate_Lexer_Case_Rule_Send;

         
         subtype Subtype_For_List_Kind_One is
            Root_Node_Record (Lkt_List_Kind_One);
         type Access_To_Subtype_For_List_Kind_One is access all Subtype_For_List_Kind_One;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_List_Kind_One);
         package Bare_List_Kind_One_Alloc is new Alloc
           (Subtype_For_List_Kind_One, Access_To_Subtype_For_List_Kind_One);

         function Allocate_List_Kind_One
           (Pool : Bump_Ptr_Pool) return Bare_List_Kind_One;

         function Allocate_List_Kind_One
           (Pool : Bump_Ptr_Pool) return Bare_List_Kind_One
         is
            Result      : constant Access_To_Subtype_For_List_Kind_One := Bare_List_Kind_One_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_List_Kind_One;
            return Bare_List_Kind_One (Result);
         end Allocate_List_Kind_One;

         
         subtype Subtype_For_List_Kind_Zero is
            Root_Node_Record (Lkt_List_Kind_Zero);
         type Access_To_Subtype_For_List_Kind_Zero is access all Subtype_For_List_Kind_Zero;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_List_Kind_Zero);
         package Bare_List_Kind_Zero_Alloc is new Alloc
           (Subtype_For_List_Kind_Zero, Access_To_Subtype_For_List_Kind_Zero);

         function Allocate_List_Kind_Zero
           (Pool : Bump_Ptr_Pool) return Bare_List_Kind_Zero;

         function Allocate_List_Kind_Zero
           (Pool : Bump_Ptr_Pool) return Bare_List_Kind_Zero
         is
            Result      : constant Access_To_Subtype_For_List_Kind_Zero := Bare_List_Kind_Zero_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_List_Kind_Zero;
            return Bare_List_Kind_Zero (Result);
         end Allocate_List_Kind_Zero;

         
         subtype Subtype_For_Argument_List is
            Root_Node_Record (Lkt_Argument_List);
         type Access_To_Subtype_For_Argument_List is access all Subtype_For_Argument_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Argument_List);
         package Bare_Argument_List_Alloc is new Alloc
           (Subtype_For_Argument_List, Access_To_Subtype_For_Argument_List);

         function Allocate_Argument_List
           (Pool : Bump_Ptr_Pool) return Bare_Argument_List;

         function Allocate_Argument_List
           (Pool : Bump_Ptr_Pool) return Bare_Argument_List
         is
            Result      : constant Access_To_Subtype_For_Argument_List := Bare_Argument_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Argument_List;
            return Bare_Argument_List (Result);
         end Allocate_Argument_List;

         
         subtype Subtype_For_Base_Import_List is
            Root_Node_Record (Lkt_Base_Import_List);
         type Access_To_Subtype_For_Base_Import_List is access all Subtype_For_Base_Import_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Base_Import_List);
         package Bare_Base_Import_List_Alloc is new Alloc
           (Subtype_For_Base_Import_List, Access_To_Subtype_For_Base_Import_List);

         function Allocate_Base_Import_List
           (Pool : Bump_Ptr_Pool) return Bare_Base_Import_List;

         function Allocate_Base_Import_List
           (Pool : Bump_Ptr_Pool) return Bare_Base_Import_List
         is
            Result      : constant Access_To_Subtype_For_Base_Import_List := Bare_Base_Import_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Base_Import_List;
            return Bare_Base_Import_List (Result);
         end Allocate_Base_Import_List;

         
         subtype Subtype_For_Base_Lexer_Case_Rule_Alt_List is
            Root_Node_Record (Lkt_Base_Lexer_Case_Rule_Alt_List);
         type Access_To_Subtype_For_Base_Lexer_Case_Rule_Alt_List is access all Subtype_For_Base_Lexer_Case_Rule_Alt_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Base_Lexer_Case_Rule_Alt_List);
         package Bare_Base_Lexer_Case_Rule_Alt_List_Alloc is new Alloc
           (Subtype_For_Base_Lexer_Case_Rule_Alt_List, Access_To_Subtype_For_Base_Lexer_Case_Rule_Alt_List);

         function Allocate_Base_Lexer_Case_Rule_Alt_List
           (Pool : Bump_Ptr_Pool) return Bare_Base_Lexer_Case_Rule_Alt_List;

         function Allocate_Base_Lexer_Case_Rule_Alt_List
           (Pool : Bump_Ptr_Pool) return Bare_Base_Lexer_Case_Rule_Alt_List
         is
            Result      : constant Access_To_Subtype_For_Base_Lexer_Case_Rule_Alt_List := Bare_Base_Lexer_Case_Rule_Alt_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Base_Lexer_Case_Rule_Alt_List;
            return Bare_Base_Lexer_Case_Rule_Alt_List (Result);
         end Allocate_Base_Lexer_Case_Rule_Alt_List;

         
         subtype Subtype_For_Base_Match_Branch_List is
            Root_Node_Record (Lkt_Base_Match_Branch_List);
         type Access_To_Subtype_For_Base_Match_Branch_List is access all Subtype_For_Base_Match_Branch_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Base_Match_Branch_List);
         package Bare_Base_Match_Branch_List_Alloc is new Alloc
           (Subtype_For_Base_Match_Branch_List, Access_To_Subtype_For_Base_Match_Branch_List);

         function Allocate_Base_Match_Branch_List
           (Pool : Bump_Ptr_Pool) return Bare_Base_Match_Branch_List;

         function Allocate_Base_Match_Branch_List
           (Pool : Bump_Ptr_Pool) return Bare_Base_Match_Branch_List
         is
            Result      : constant Access_To_Subtype_For_Base_Match_Branch_List := Bare_Base_Match_Branch_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Base_Match_Branch_List;
            return Bare_Base_Match_Branch_List (Result);
         end Allocate_Base_Match_Branch_List;

         
         subtype Subtype_For_Block_String_Line_List is
            Root_Node_Record (Lkt_Block_String_Line_List);
         type Access_To_Subtype_For_Block_String_Line_List is access all Subtype_For_Block_String_Line_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Block_String_Line_List);
         package Bare_Block_String_Line_List_Alloc is new Alloc
           (Subtype_For_Block_String_Line_List, Access_To_Subtype_For_Block_String_Line_List);

         function Allocate_Block_String_Line_List
           (Pool : Bump_Ptr_Pool) return Bare_Block_String_Line_List;

         function Allocate_Block_String_Line_List
           (Pool : Bump_Ptr_Pool) return Bare_Block_String_Line_List
         is
            Result      : constant Access_To_Subtype_For_Block_String_Line_List := Bare_Block_String_Line_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Block_String_Line_List;
            return Bare_Block_String_Line_List (Result);
         end Allocate_Block_String_Line_List;

         
         subtype Subtype_For_Call_Expr_List is
            Root_Node_Record (Lkt_Call_Expr_List);
         type Access_To_Subtype_For_Call_Expr_List is access all Subtype_For_Call_Expr_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Call_Expr_List);
         package Bare_Call_Expr_List_Alloc is new Alloc
           (Subtype_For_Call_Expr_List, Access_To_Subtype_For_Call_Expr_List);

         function Allocate_Call_Expr_List
           (Pool : Bump_Ptr_Pool) return Bare_Call_Expr_List;

         function Allocate_Call_Expr_List
           (Pool : Bump_Ptr_Pool) return Bare_Call_Expr_List
         is
            Result      : constant Access_To_Subtype_For_Call_Expr_List := Bare_Call_Expr_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Call_Expr_List;
            return Bare_Call_Expr_List (Result);
         end Allocate_Call_Expr_List;

         
         subtype Subtype_For_Decl_Annotation_List is
            Root_Node_Record (Lkt_Decl_Annotation_List);
         type Access_To_Subtype_For_Decl_Annotation_List is access all Subtype_For_Decl_Annotation_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Decl_Annotation_List);
         package Bare_Decl_Annotation_List_Alloc is new Alloc
           (Subtype_For_Decl_Annotation_List, Access_To_Subtype_For_Decl_Annotation_List);

         function Allocate_Decl_Annotation_List
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Annotation_List;

         function Allocate_Decl_Annotation_List
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Annotation_List
         is
            Result      : constant Access_To_Subtype_For_Decl_Annotation_List := Bare_Decl_Annotation_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Decl_Annotation_List;
            return Bare_Decl_Annotation_List (Result);
         end Allocate_Decl_Annotation_List;

         
         subtype Subtype_For_Elsif_Branch_List is
            Root_Node_Record (Lkt_Elsif_Branch_List);
         type Access_To_Subtype_For_Elsif_Branch_List is access all Subtype_For_Elsif_Branch_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Elsif_Branch_List);
         package Bare_Elsif_Branch_List_Alloc is new Alloc
           (Subtype_For_Elsif_Branch_List, Access_To_Subtype_For_Elsif_Branch_List);

         function Allocate_Elsif_Branch_List
           (Pool : Bump_Ptr_Pool) return Bare_Elsif_Branch_List;

         function Allocate_Elsif_Branch_List
           (Pool : Bump_Ptr_Pool) return Bare_Elsif_Branch_List
         is
            Result      : constant Access_To_Subtype_For_Elsif_Branch_List := Bare_Elsif_Branch_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Elsif_Branch_List;
            return Bare_Elsif_Branch_List (Result);
         end Allocate_Elsif_Branch_List;

         
         subtype Subtype_For_Enum_Class_Alt_Decl_List is
            Root_Node_Record (Lkt_Enum_Class_Alt_Decl_List);
         type Access_To_Subtype_For_Enum_Class_Alt_Decl_List is access all Subtype_For_Enum_Class_Alt_Decl_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Enum_Class_Alt_Decl_List);
         package Bare_Enum_Class_Alt_Decl_List_Alloc is new Alloc
           (Subtype_For_Enum_Class_Alt_Decl_List, Access_To_Subtype_For_Enum_Class_Alt_Decl_List);

         function Allocate_Enum_Class_Alt_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Alt_Decl_List;

         function Allocate_Enum_Class_Alt_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Alt_Decl_List
         is
            Result      : constant Access_To_Subtype_For_Enum_Class_Alt_Decl_List := Bare_Enum_Class_Alt_Decl_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Enum_Class_Alt_Decl_List;
            return Bare_Enum_Class_Alt_Decl_List (Result);
         end Allocate_Enum_Class_Alt_Decl_List;

         
         subtype Subtype_For_Enum_Class_Case_List is
            Root_Node_Record (Lkt_Enum_Class_Case_List);
         type Access_To_Subtype_For_Enum_Class_Case_List is access all Subtype_For_Enum_Class_Case_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Enum_Class_Case_List);
         package Bare_Enum_Class_Case_List_Alloc is new Alloc
           (Subtype_For_Enum_Class_Case_List, Access_To_Subtype_For_Enum_Class_Case_List);

         function Allocate_Enum_Class_Case_List
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Case_List;

         function Allocate_Enum_Class_Case_List
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Class_Case_List
         is
            Result      : constant Access_To_Subtype_For_Enum_Class_Case_List := Bare_Enum_Class_Case_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Enum_Class_Case_List;
            return Bare_Enum_Class_Case_List (Result);
         end Allocate_Enum_Class_Case_List;

         
         subtype Subtype_For_Enum_Lit_Decl_List is
            Root_Node_Record (Lkt_Enum_Lit_Decl_List);
         type Access_To_Subtype_For_Enum_Lit_Decl_List is access all Subtype_For_Enum_Lit_Decl_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Enum_Lit_Decl_List);
         package Bare_Enum_Lit_Decl_List_Alloc is new Alloc
           (Subtype_For_Enum_Lit_Decl_List, Access_To_Subtype_For_Enum_Lit_Decl_List);

         function Allocate_Enum_Lit_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Lit_Decl_List;

         function Allocate_Enum_Lit_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Enum_Lit_Decl_List
         is
            Result      : constant Access_To_Subtype_For_Enum_Lit_Decl_List := Bare_Enum_Lit_Decl_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Enum_Lit_Decl_List;
            return Bare_Enum_Lit_Decl_List (Result);
         end Allocate_Enum_Lit_Decl_List;

         
         subtype Subtype_For_Expr_List is
            Root_Node_Record (Lkt_Expr_List);
         type Access_To_Subtype_For_Expr_List is access all Subtype_For_Expr_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Expr_List);
         package Bare_Expr_List_Alloc is new Alloc
           (Subtype_For_Expr_List, Access_To_Subtype_For_Expr_List);

         function Allocate_Expr_List
           (Pool : Bump_Ptr_Pool) return Bare_Expr_List;

         function Allocate_Expr_List
           (Pool : Bump_Ptr_Pool) return Bare_Expr_List
         is
            Result      : constant Access_To_Subtype_For_Expr_List := Bare_Expr_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Expr_List;
            return Bare_Expr_List (Result);
         end Allocate_Expr_List;

         
         subtype Subtype_For_Any_Of_List is
            Root_Node_Record (Lkt_Any_Of_List);
         type Access_To_Subtype_For_Any_Of_List is access all Subtype_For_Any_Of_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Any_Of_List);
         package Bare_Any_Of_List_Alloc is new Alloc
           (Subtype_For_Any_Of_List, Access_To_Subtype_For_Any_Of_List);

         function Allocate_Any_Of_List
           (Pool : Bump_Ptr_Pool) return Bare_Any_Of_List;

         function Allocate_Any_Of_List
           (Pool : Bump_Ptr_Pool) return Bare_Any_Of_List
         is
            Result      : constant Access_To_Subtype_For_Any_Of_List := Bare_Any_Of_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Any_Of_List;
            return Bare_Any_Of_List (Result);
         end Allocate_Any_Of_List;

         
         subtype Subtype_For_Full_Decl_List is
            Root_Node_Record (Lkt_Full_Decl_List);
         type Access_To_Subtype_For_Full_Decl_List is access all Subtype_For_Full_Decl_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Full_Decl_List);
         package Bare_Full_Decl_List_Alloc is new Alloc
           (Subtype_For_Full_Decl_List, Access_To_Subtype_For_Full_Decl_List);

         function Allocate_Full_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Full_Decl_List;

         function Allocate_Full_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Full_Decl_List
         is
            Result      : constant Access_To_Subtype_For_Full_Decl_List := Bare_Full_Decl_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Full_Decl_List;
            return Bare_Full_Decl_List (Result);
         end Allocate_Full_Decl_List;

         
         subtype Subtype_For_Decl_Block is
            Root_Node_Record (Lkt_Decl_Block);
         type Access_To_Subtype_For_Decl_Block is access all Subtype_For_Decl_Block;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Decl_Block);
         package Bare_Decl_Block_Alloc is new Alloc
           (Subtype_For_Decl_Block, Access_To_Subtype_For_Decl_Block);

         function Allocate_Decl_Block
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Block;

         function Allocate_Decl_Block
           (Pool : Bump_Ptr_Pool) return Bare_Decl_Block
         is
            Result      : constant Access_To_Subtype_For_Decl_Block := Bare_Decl_Block_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Decl_Block;
            return Bare_Decl_Block (Result);
         end Allocate_Decl_Block;

         
         subtype Subtype_For_Generic_Param_Decl_List is
            Root_Node_Record (Lkt_Generic_Param_Decl_List);
         type Access_To_Subtype_For_Generic_Param_Decl_List is access all Subtype_For_Generic_Param_Decl_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Generic_Param_Decl_List);
         package Bare_Generic_Param_Decl_List_Alloc is new Alloc
           (Subtype_For_Generic_Param_Decl_List, Access_To_Subtype_For_Generic_Param_Decl_List);

         function Allocate_Generic_Param_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Param_Decl_List;

         function Allocate_Generic_Param_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Param_Decl_List
         is
            Result      : constant Access_To_Subtype_For_Generic_Param_Decl_List := Bare_Generic_Param_Decl_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Generic_Param_Decl_List;
            return Bare_Generic_Param_Decl_List (Result);
         end Allocate_Generic_Param_Decl_List;

         
         subtype Subtype_For_Fun_Param_Decl_List is
            Root_Node_Record (Lkt_Fun_Param_Decl_List);
         type Access_To_Subtype_For_Fun_Param_Decl_List is access all Subtype_For_Fun_Param_Decl_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Fun_Param_Decl_List);
         package Bare_Fun_Param_Decl_List_Alloc is new Alloc
           (Subtype_For_Fun_Param_Decl_List, Access_To_Subtype_For_Fun_Param_Decl_List);

         function Allocate_Fun_Param_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Fun_Param_Decl_List;

         function Allocate_Fun_Param_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Fun_Param_Decl_List
         is
            Result      : constant Access_To_Subtype_For_Fun_Param_Decl_List := Bare_Fun_Param_Decl_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Fun_Param_Decl_List;
            return Bare_Fun_Param_Decl_List (Result);
         end Allocate_Fun_Param_Decl_List;

         
         subtype Subtype_For_Grammar_Expr_List is
            Root_Node_Record (Lkt_Grammar_Expr_List);
         type Access_To_Subtype_For_Grammar_Expr_List is access all Subtype_For_Grammar_Expr_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Expr_List);
         package Bare_Grammar_Expr_List_Alloc is new Alloc
           (Subtype_For_Grammar_Expr_List, Access_To_Subtype_For_Grammar_Expr_List);

         function Allocate_Grammar_Expr_List
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Expr_List;

         function Allocate_Grammar_Expr_List
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Expr_List
         is
            Result      : constant Access_To_Subtype_For_Grammar_Expr_List := Bare_Grammar_Expr_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Expr_List;
            return Bare_Grammar_Expr_List (Result);
         end Allocate_Grammar_Expr_List;

         
         subtype Subtype_For_Grammar_Expr_List_List is
            Root_Node_Record (Lkt_Grammar_Expr_List_List);
         type Access_To_Subtype_For_Grammar_Expr_List_List is access all Subtype_For_Grammar_Expr_List_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Grammar_Expr_List_List);
         package Bare_Grammar_Expr_List_List_Alloc is new Alloc
           (Subtype_For_Grammar_Expr_List_List, Access_To_Subtype_For_Grammar_Expr_List_List);

         function Allocate_Grammar_Expr_List_List
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Expr_List_List;

         function Allocate_Grammar_Expr_List_List
           (Pool : Bump_Ptr_Pool) return Bare_Grammar_Expr_List_List
         is
            Result      : constant Access_To_Subtype_For_Grammar_Expr_List_List := Bare_Grammar_Expr_List_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Grammar_Expr_List_List;
            return Bare_Grammar_Expr_List_List (Result);
         end Allocate_Grammar_Expr_List_List;

         
         subtype Subtype_For_Imported_Name_List is
            Root_Node_Record (Lkt_Imported_Name_List);
         type Access_To_Subtype_For_Imported_Name_List is access all Subtype_For_Imported_Name_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Imported_Name_List);
         package Bare_Imported_Name_List_Alloc is new Alloc
           (Subtype_For_Imported_Name_List, Access_To_Subtype_For_Imported_Name_List);

         function Allocate_Imported_Name_List
           (Pool : Bump_Ptr_Pool) return Bare_Imported_Name_List;

         function Allocate_Imported_Name_List
           (Pool : Bump_Ptr_Pool) return Bare_Imported_Name_List
         is
            Result      : constant Access_To_Subtype_For_Imported_Name_List := Bare_Imported_Name_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Imported_Name_List;
            return Bare_Imported_Name_List (Result);
         end Allocate_Imported_Name_List;

         
         subtype Subtype_For_Lambda_Param_Decl_List is
            Root_Node_Record (Lkt_Lambda_Param_Decl_List);
         type Access_To_Subtype_For_Lambda_Param_Decl_List is access all Subtype_For_Lambda_Param_Decl_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lambda_Param_Decl_List);
         package Bare_Lambda_Param_Decl_List_Alloc is new Alloc
           (Subtype_For_Lambda_Param_Decl_List, Access_To_Subtype_For_Lambda_Param_Decl_List);

         function Allocate_Lambda_Param_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Lambda_Param_Decl_List;

         function Allocate_Lambda_Param_Decl_List
           (Pool : Bump_Ptr_Pool) return Bare_Lambda_Param_Decl_List
         is
            Result      : constant Access_To_Subtype_For_Lambda_Param_Decl_List := Bare_Lambda_Param_Decl_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lambda_Param_Decl_List;
            return Bare_Lambda_Param_Decl_List (Result);
         end Allocate_Lambda_Param_Decl_List;

         
         subtype Subtype_For_Lkt_Node_List is
            Root_Node_Record (Lkt_Lkt_Node_List);
         type Access_To_Subtype_For_Lkt_Node_List is access all Subtype_For_Lkt_Node_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Lkt_Node_List);
         package Bare_Lkt_Node_List_Alloc is new Alloc
           (Subtype_For_Lkt_Node_List, Access_To_Subtype_For_Lkt_Node_List);

         function Allocate_Lkt_Node_List
           (Pool : Bump_Ptr_Pool) return Bare_Lkt_Node_List;

         function Allocate_Lkt_Node_List
           (Pool : Bump_Ptr_Pool) return Bare_Lkt_Node_List
         is
            Result      : constant Access_To_Subtype_For_Lkt_Node_List := Bare_Lkt_Node_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Lkt_Node_List;
            return Bare_Lkt_Node_List (Result);
         end Allocate_Lkt_Node_List;

         
         subtype Subtype_For_Module_Doc_String_Line_List is
            Root_Node_Record (Lkt_Module_Doc_String_Line_List);
         type Access_To_Subtype_For_Module_Doc_String_Line_List is access all Subtype_For_Module_Doc_String_Line_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Module_Doc_String_Line_List);
         package Bare_Module_Doc_String_Line_List_Alloc is new Alloc
           (Subtype_For_Module_Doc_String_Line_List, Access_To_Subtype_For_Module_Doc_String_Line_List);

         function Allocate_Module_Doc_String_Line_List
           (Pool : Bump_Ptr_Pool) return Bare_Module_Doc_String_Line_List;

         function Allocate_Module_Doc_String_Line_List
           (Pool : Bump_Ptr_Pool) return Bare_Module_Doc_String_Line_List
         is
            Result      : constant Access_To_Subtype_For_Module_Doc_String_Line_List := Bare_Module_Doc_String_Line_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Module_Doc_String_Line_List;
            return Bare_Module_Doc_String_Line_List (Result);
         end Allocate_Module_Doc_String_Line_List;

         
         subtype Subtype_For_Pattern_Detail_List is
            Root_Node_Record (Lkt_Pattern_Detail_List);
         type Access_To_Subtype_For_Pattern_Detail_List is access all Subtype_For_Pattern_Detail_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Pattern_Detail_List);
         package Bare_Pattern_Detail_List_Alloc is new Alloc
           (Subtype_For_Pattern_Detail_List, Access_To_Subtype_For_Pattern_Detail_List);

         function Allocate_Pattern_Detail_List
           (Pool : Bump_Ptr_Pool) return Bare_Pattern_Detail_List;

         function Allocate_Pattern_Detail_List
           (Pool : Bump_Ptr_Pool) return Bare_Pattern_Detail_List
         is
            Result      : constant Access_To_Subtype_For_Pattern_Detail_List := Bare_Pattern_Detail_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Pattern_Detail_List;
            return Bare_Pattern_Detail_List (Result);
         end Allocate_Pattern_Detail_List;

         
         subtype Subtype_For_Pattern_List is
            Root_Node_Record (Lkt_Pattern_List);
         type Access_To_Subtype_For_Pattern_List is access all Subtype_For_Pattern_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Pattern_List);
         package Bare_Pattern_List_Alloc is new Alloc
           (Subtype_For_Pattern_List, Access_To_Subtype_For_Pattern_List);

         function Allocate_Pattern_List
           (Pool : Bump_Ptr_Pool) return Bare_Pattern_List;

         function Allocate_Pattern_List
           (Pool : Bump_Ptr_Pool) return Bare_Pattern_List
         is
            Result      : constant Access_To_Subtype_For_Pattern_List := Bare_Pattern_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Pattern_List;
            return Bare_Pattern_List (Result);
         end Allocate_Pattern_List;

         
         subtype Subtype_For_Ref_Id_List is
            Root_Node_Record (Lkt_Ref_Id_List);
         type Access_To_Subtype_For_Ref_Id_List is access all Subtype_For_Ref_Id_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Ref_Id_List);
         package Bare_Ref_Id_List_Alloc is new Alloc
           (Subtype_For_Ref_Id_List, Access_To_Subtype_For_Ref_Id_List);

         function Allocate_Ref_Id_List
           (Pool : Bump_Ptr_Pool) return Bare_Ref_Id_List;

         function Allocate_Ref_Id_List
           (Pool : Bump_Ptr_Pool) return Bare_Ref_Id_List
         is
            Result      : constant Access_To_Subtype_For_Ref_Id_List := Bare_Ref_Id_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Ref_Id_List;
            return Bare_Ref_Id_List (Result);
         end Allocate_Ref_Id_List;

         
         subtype Subtype_For_Type_Ref_List is
            Root_Node_Record (Lkt_Type_Ref_List);
         type Access_To_Subtype_For_Type_Ref_List is access all Subtype_For_Type_Ref_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Type_Ref_List);
         package Bare_Type_Ref_List_Alloc is new Alloc
           (Subtype_For_Type_Ref_List, Access_To_Subtype_For_Type_Ref_List);

         function Allocate_Type_Ref_List
           (Pool : Bump_Ptr_Pool) return Bare_Type_Ref_List;

         function Allocate_Type_Ref_List
           (Pool : Bump_Ptr_Pool) return Bare_Type_Ref_List
         is
            Result      : constant Access_To_Subtype_For_Type_Ref_List := Bare_Type_Ref_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Type_Ref_List;
            return Bare_Type_Ref_List (Result);
         end Allocate_Type_Ref_List;

         
         subtype Subtype_For_Synthetic_Type_Ref_List is
            Root_Node_Record (Lkt_Synthetic_Type_Ref_List);
         type Access_To_Subtype_For_Synthetic_Type_Ref_List is access all Subtype_For_Synthetic_Type_Ref_List;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Synthetic_Type_Ref_List);
         package Bare_Synthetic_Type_Ref_List_Alloc is new Alloc
           (Subtype_For_Synthetic_Type_Ref_List, Access_To_Subtype_For_Synthetic_Type_Ref_List);

         function Allocate_Synthetic_Type_Ref_List
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Type_Ref_List;

         function Allocate_Synthetic_Type_Ref_List
           (Pool : Bump_Ptr_Pool) return Bare_Synthetic_Type_Ref_List
         is
            Result      : constant Access_To_Subtype_For_Synthetic_Type_Ref_List := Bare_Synthetic_Type_Ref_List_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Synthetic_Type_Ref_List;
            return Bare_Synthetic_Type_Ref_List (Result);
         end Allocate_Synthetic_Type_Ref_List;

         
         subtype Subtype_For_Module_Doc_String_Line is
            Root_Node_Record (Lkt_Module_Doc_String_Line);
         type Access_To_Subtype_For_Module_Doc_String_Line is access all Subtype_For_Module_Doc_String_Line;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Module_Doc_String_Line);
         package Bare_Module_Doc_String_Line_Alloc is new Alloc
           (Subtype_For_Module_Doc_String_Line, Access_To_Subtype_For_Module_Doc_String_Line);

         function Allocate_Module_Doc_String_Line
           (Pool : Bump_Ptr_Pool) return Bare_Module_Doc_String_Line;

         function Allocate_Module_Doc_String_Line
           (Pool : Bump_Ptr_Pool) return Bare_Module_Doc_String_Line
         is
            Result      : constant Access_To_Subtype_For_Module_Doc_String_Line := Bare_Module_Doc_String_Line_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Module_Doc_String_Line;
            return Bare_Module_Doc_String_Line (Result);
         end Allocate_Module_Doc_String_Line;

         
         subtype Subtype_For_Null_Cond_Qualifier_Absent is
            Root_Node_Record (Lkt_Null_Cond_Qualifier_Absent);
         type Access_To_Subtype_For_Null_Cond_Qualifier_Absent is access all Subtype_For_Null_Cond_Qualifier_Absent;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Null_Cond_Qualifier_Absent);
         package Bare_Null_Cond_Qualifier_Absent_Alloc is new Alloc
           (Subtype_For_Null_Cond_Qualifier_Absent, Access_To_Subtype_For_Null_Cond_Qualifier_Absent);

         function Allocate_Null_Cond_Qualifier_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Null_Cond_Qualifier_Absent;

         function Allocate_Null_Cond_Qualifier_Absent
           (Pool : Bump_Ptr_Pool) return Bare_Null_Cond_Qualifier_Absent
         is
            Result      : constant Access_To_Subtype_For_Null_Cond_Qualifier_Absent := Bare_Null_Cond_Qualifier_Absent_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Null_Cond_Qualifier_Absent;
            return Bare_Null_Cond_Qualifier_Absent (Result);
         end Allocate_Null_Cond_Qualifier_Absent;

         
         subtype Subtype_For_Null_Cond_Qualifier_Present is
            Root_Node_Record (Lkt_Null_Cond_Qualifier_Present);
         type Access_To_Subtype_For_Null_Cond_Qualifier_Present is access all Subtype_For_Null_Cond_Qualifier_Present;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Null_Cond_Qualifier_Present);
         package Bare_Null_Cond_Qualifier_Present_Alloc is new Alloc
           (Subtype_For_Null_Cond_Qualifier_Present, Access_To_Subtype_For_Null_Cond_Qualifier_Present);

         function Allocate_Null_Cond_Qualifier_Present
           (Pool : Bump_Ptr_Pool) return Bare_Null_Cond_Qualifier_Present;

         function Allocate_Null_Cond_Qualifier_Present
           (Pool : Bump_Ptr_Pool) return Bare_Null_Cond_Qualifier_Present
         is
            Result      : constant Access_To_Subtype_For_Null_Cond_Qualifier_Present := Bare_Null_Cond_Qualifier_Present_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Null_Cond_Qualifier_Present;
            return Bare_Null_Cond_Qualifier_Present (Result);
         end Allocate_Null_Cond_Qualifier_Present;

         
         subtype Subtype_For_Op_Amp is
            Root_Node_Record (Lkt_Op_Amp);
         type Access_To_Subtype_For_Op_Amp is access all Subtype_For_Op_Amp;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Amp);
         package Bare_Op_Amp_Alloc is new Alloc
           (Subtype_For_Op_Amp, Access_To_Subtype_For_Op_Amp);

         function Allocate_Op_Amp
           (Pool : Bump_Ptr_Pool) return Bare_Op_Amp;

         function Allocate_Op_Amp
           (Pool : Bump_Ptr_Pool) return Bare_Op_Amp
         is
            Result      : constant Access_To_Subtype_For_Op_Amp := Bare_Op_Amp_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Amp;
            return Bare_Op_Amp (Result);
         end Allocate_Op_Amp;

         
         subtype Subtype_For_Op_And is
            Root_Node_Record (Lkt_Op_And);
         type Access_To_Subtype_For_Op_And is access all Subtype_For_Op_And;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_And);
         package Bare_Op_And_Alloc is new Alloc
           (Subtype_For_Op_And, Access_To_Subtype_For_Op_And);

         function Allocate_Op_And
           (Pool : Bump_Ptr_Pool) return Bare_Op_And;

         function Allocate_Op_And
           (Pool : Bump_Ptr_Pool) return Bare_Op_And
         is
            Result      : constant Access_To_Subtype_For_Op_And := Bare_Op_And_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_And;
            return Bare_Op_And (Result);
         end Allocate_Op_And;

         
         subtype Subtype_For_Op_Div is
            Root_Node_Record (Lkt_Op_Div);
         type Access_To_Subtype_For_Op_Div is access all Subtype_For_Op_Div;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Div);
         package Bare_Op_Div_Alloc is new Alloc
           (Subtype_For_Op_Div, Access_To_Subtype_For_Op_Div);

         function Allocate_Op_Div
           (Pool : Bump_Ptr_Pool) return Bare_Op_Div;

         function Allocate_Op_Div
           (Pool : Bump_Ptr_Pool) return Bare_Op_Div
         is
            Result      : constant Access_To_Subtype_For_Op_Div := Bare_Op_Div_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Div;
            return Bare_Op_Div (Result);
         end Allocate_Op_Div;

         
         subtype Subtype_For_Op_Eq is
            Root_Node_Record (Lkt_Op_Eq);
         type Access_To_Subtype_For_Op_Eq is access all Subtype_For_Op_Eq;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Eq);
         package Bare_Op_Eq_Alloc is new Alloc
           (Subtype_For_Op_Eq, Access_To_Subtype_For_Op_Eq);

         function Allocate_Op_Eq
           (Pool : Bump_Ptr_Pool) return Bare_Op_Eq;

         function Allocate_Op_Eq
           (Pool : Bump_Ptr_Pool) return Bare_Op_Eq
         is
            Result      : constant Access_To_Subtype_For_Op_Eq := Bare_Op_Eq_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Eq;
            return Bare_Op_Eq (Result);
         end Allocate_Op_Eq;

         
         subtype Subtype_For_Op_Gt is
            Root_Node_Record (Lkt_Op_Gt);
         type Access_To_Subtype_For_Op_Gt is access all Subtype_For_Op_Gt;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Gt);
         package Bare_Op_Gt_Alloc is new Alloc
           (Subtype_For_Op_Gt, Access_To_Subtype_For_Op_Gt);

         function Allocate_Op_Gt
           (Pool : Bump_Ptr_Pool) return Bare_Op_Gt;

         function Allocate_Op_Gt
           (Pool : Bump_Ptr_Pool) return Bare_Op_Gt
         is
            Result      : constant Access_To_Subtype_For_Op_Gt := Bare_Op_Gt_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Gt;
            return Bare_Op_Gt (Result);
         end Allocate_Op_Gt;

         
         subtype Subtype_For_Op_Gte is
            Root_Node_Record (Lkt_Op_Gte);
         type Access_To_Subtype_For_Op_Gte is access all Subtype_For_Op_Gte;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Gte);
         package Bare_Op_Gte_Alloc is new Alloc
           (Subtype_For_Op_Gte, Access_To_Subtype_For_Op_Gte);

         function Allocate_Op_Gte
           (Pool : Bump_Ptr_Pool) return Bare_Op_Gte;

         function Allocate_Op_Gte
           (Pool : Bump_Ptr_Pool) return Bare_Op_Gte
         is
            Result      : constant Access_To_Subtype_For_Op_Gte := Bare_Op_Gte_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Gte;
            return Bare_Op_Gte (Result);
         end Allocate_Op_Gte;

         
         subtype Subtype_For_Op_Logic_And is
            Root_Node_Record (Lkt_Op_Logic_And);
         type Access_To_Subtype_For_Op_Logic_And is access all Subtype_For_Op_Logic_And;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Logic_And);
         package Bare_Op_Logic_And_Alloc is new Alloc
           (Subtype_For_Op_Logic_And, Access_To_Subtype_For_Op_Logic_And);

         function Allocate_Op_Logic_And
           (Pool : Bump_Ptr_Pool) return Bare_Op_Logic_And;

         function Allocate_Op_Logic_And
           (Pool : Bump_Ptr_Pool) return Bare_Op_Logic_And
         is
            Result      : constant Access_To_Subtype_For_Op_Logic_And := Bare_Op_Logic_And_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Logic_And;
            return Bare_Op_Logic_And (Result);
         end Allocate_Op_Logic_And;

         
         subtype Subtype_For_Op_Logic_Or is
            Root_Node_Record (Lkt_Op_Logic_Or);
         type Access_To_Subtype_For_Op_Logic_Or is access all Subtype_For_Op_Logic_Or;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Logic_Or);
         package Bare_Op_Logic_Or_Alloc is new Alloc
           (Subtype_For_Op_Logic_Or, Access_To_Subtype_For_Op_Logic_Or);

         function Allocate_Op_Logic_Or
           (Pool : Bump_Ptr_Pool) return Bare_Op_Logic_Or;

         function Allocate_Op_Logic_Or
           (Pool : Bump_Ptr_Pool) return Bare_Op_Logic_Or
         is
            Result      : constant Access_To_Subtype_For_Op_Logic_Or := Bare_Op_Logic_Or_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Logic_Or;
            return Bare_Op_Logic_Or (Result);
         end Allocate_Op_Logic_Or;

         
         subtype Subtype_For_Op_Lt is
            Root_Node_Record (Lkt_Op_Lt);
         type Access_To_Subtype_For_Op_Lt is access all Subtype_For_Op_Lt;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Lt);
         package Bare_Op_Lt_Alloc is new Alloc
           (Subtype_For_Op_Lt, Access_To_Subtype_For_Op_Lt);

         function Allocate_Op_Lt
           (Pool : Bump_Ptr_Pool) return Bare_Op_Lt;

         function Allocate_Op_Lt
           (Pool : Bump_Ptr_Pool) return Bare_Op_Lt
         is
            Result      : constant Access_To_Subtype_For_Op_Lt := Bare_Op_Lt_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Lt;
            return Bare_Op_Lt (Result);
         end Allocate_Op_Lt;

         
         subtype Subtype_For_Op_Lte is
            Root_Node_Record (Lkt_Op_Lte);
         type Access_To_Subtype_For_Op_Lte is access all Subtype_For_Op_Lte;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Lte);
         package Bare_Op_Lte_Alloc is new Alloc
           (Subtype_For_Op_Lte, Access_To_Subtype_For_Op_Lte);

         function Allocate_Op_Lte
           (Pool : Bump_Ptr_Pool) return Bare_Op_Lte;

         function Allocate_Op_Lte
           (Pool : Bump_Ptr_Pool) return Bare_Op_Lte
         is
            Result      : constant Access_To_Subtype_For_Op_Lte := Bare_Op_Lte_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Lte;
            return Bare_Op_Lte (Result);
         end Allocate_Op_Lte;

         
         subtype Subtype_For_Op_Minus is
            Root_Node_Record (Lkt_Op_Minus);
         type Access_To_Subtype_For_Op_Minus is access all Subtype_For_Op_Minus;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Minus);
         package Bare_Op_Minus_Alloc is new Alloc
           (Subtype_For_Op_Minus, Access_To_Subtype_For_Op_Minus);

         function Allocate_Op_Minus
           (Pool : Bump_Ptr_Pool) return Bare_Op_Minus;

         function Allocate_Op_Minus
           (Pool : Bump_Ptr_Pool) return Bare_Op_Minus
         is
            Result      : constant Access_To_Subtype_For_Op_Minus := Bare_Op_Minus_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Minus;
            return Bare_Op_Minus (Result);
         end Allocate_Op_Minus;

         
         subtype Subtype_For_Op_Mult is
            Root_Node_Record (Lkt_Op_Mult);
         type Access_To_Subtype_For_Op_Mult is access all Subtype_For_Op_Mult;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Mult);
         package Bare_Op_Mult_Alloc is new Alloc
           (Subtype_For_Op_Mult, Access_To_Subtype_For_Op_Mult);

         function Allocate_Op_Mult
           (Pool : Bump_Ptr_Pool) return Bare_Op_Mult;

         function Allocate_Op_Mult
           (Pool : Bump_Ptr_Pool) return Bare_Op_Mult
         is
            Result      : constant Access_To_Subtype_For_Op_Mult := Bare_Op_Mult_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Mult;
            return Bare_Op_Mult (Result);
         end Allocate_Op_Mult;

         
         subtype Subtype_For_Op_Ne is
            Root_Node_Record (Lkt_Op_Ne);
         type Access_To_Subtype_For_Op_Ne is access all Subtype_For_Op_Ne;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Ne);
         package Bare_Op_Ne_Alloc is new Alloc
           (Subtype_For_Op_Ne, Access_To_Subtype_For_Op_Ne);

         function Allocate_Op_Ne
           (Pool : Bump_Ptr_Pool) return Bare_Op_Ne;

         function Allocate_Op_Ne
           (Pool : Bump_Ptr_Pool) return Bare_Op_Ne
         is
            Result      : constant Access_To_Subtype_For_Op_Ne := Bare_Op_Ne_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Ne;
            return Bare_Op_Ne (Result);
         end Allocate_Op_Ne;

         
         subtype Subtype_For_Op_Or is
            Root_Node_Record (Lkt_Op_Or);
         type Access_To_Subtype_For_Op_Or is access all Subtype_For_Op_Or;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Or);
         package Bare_Op_Or_Alloc is new Alloc
           (Subtype_For_Op_Or, Access_To_Subtype_For_Op_Or);

         function Allocate_Op_Or
           (Pool : Bump_Ptr_Pool) return Bare_Op_Or;

         function Allocate_Op_Or
           (Pool : Bump_Ptr_Pool) return Bare_Op_Or
         is
            Result      : constant Access_To_Subtype_For_Op_Or := Bare_Op_Or_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Or;
            return Bare_Op_Or (Result);
         end Allocate_Op_Or;

         
         subtype Subtype_For_Op_Or_Int is
            Root_Node_Record (Lkt_Op_Or_Int);
         type Access_To_Subtype_For_Op_Or_Int is access all Subtype_For_Op_Or_Int;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Or_Int);
         package Bare_Op_Or_Int_Alloc is new Alloc
           (Subtype_For_Op_Or_Int, Access_To_Subtype_For_Op_Or_Int);

         function Allocate_Op_Or_Int
           (Pool : Bump_Ptr_Pool) return Bare_Op_Or_Int;

         function Allocate_Op_Or_Int
           (Pool : Bump_Ptr_Pool) return Bare_Op_Or_Int
         is
            Result      : constant Access_To_Subtype_For_Op_Or_Int := Bare_Op_Or_Int_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Or_Int;
            return Bare_Op_Or_Int (Result);
         end Allocate_Op_Or_Int;

         
         subtype Subtype_For_Op_Plus is
            Root_Node_Record (Lkt_Op_Plus);
         type Access_To_Subtype_For_Op_Plus is access all Subtype_For_Op_Plus;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Plus);
         package Bare_Op_Plus_Alloc is new Alloc
           (Subtype_For_Op_Plus, Access_To_Subtype_For_Op_Plus);

         function Allocate_Op_Plus
           (Pool : Bump_Ptr_Pool) return Bare_Op_Plus;

         function Allocate_Op_Plus
           (Pool : Bump_Ptr_Pool) return Bare_Op_Plus
         is
            Result      : constant Access_To_Subtype_For_Op_Plus := Bare_Op_Plus_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Plus;
            return Bare_Op_Plus (Result);
         end Allocate_Op_Plus;

         
         subtype Subtype_For_Op_Stream_Concat is
            Root_Node_Record (Lkt_Op_Stream_Concat);
         type Access_To_Subtype_For_Op_Stream_Concat is access all Subtype_For_Op_Stream_Concat;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Stream_Concat);
         package Bare_Op_Stream_Concat_Alloc is new Alloc
           (Subtype_For_Op_Stream_Concat, Access_To_Subtype_For_Op_Stream_Concat);

         function Allocate_Op_Stream_Concat
           (Pool : Bump_Ptr_Pool) return Bare_Op_Stream_Concat;

         function Allocate_Op_Stream_Concat
           (Pool : Bump_Ptr_Pool) return Bare_Op_Stream_Concat
         is
            Result      : constant Access_To_Subtype_For_Op_Stream_Concat := Bare_Op_Stream_Concat_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Stream_Concat;
            return Bare_Op_Stream_Concat (Result);
         end Allocate_Op_Stream_Concat;

         
         subtype Subtype_For_Op_Stream_Cons is
            Root_Node_Record (Lkt_Op_Stream_Cons);
         type Access_To_Subtype_For_Op_Stream_Cons is access all Subtype_For_Op_Stream_Cons;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Op_Stream_Cons);
         package Bare_Op_Stream_Cons_Alloc is new Alloc
           (Subtype_For_Op_Stream_Cons, Access_To_Subtype_For_Op_Stream_Cons);

         function Allocate_Op_Stream_Cons
           (Pool : Bump_Ptr_Pool) return Bare_Op_Stream_Cons;

         function Allocate_Op_Stream_Cons
           (Pool : Bump_Ptr_Pool) return Bare_Op_Stream_Cons
         is
            Result      : constant Access_To_Subtype_For_Op_Stream_Cons := Bare_Op_Stream_Cons_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Op_Stream_Cons;
            return Bare_Op_Stream_Cons (Result);
         end Allocate_Op_Stream_Cons;

         
         subtype Subtype_For_Any_Type_Pattern is
            Root_Node_Record (Lkt_Any_Type_Pattern);
         type Access_To_Subtype_For_Any_Type_Pattern is access all Subtype_For_Any_Type_Pattern;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Any_Type_Pattern);
         package Bare_Any_Type_Pattern_Alloc is new Alloc
           (Subtype_For_Any_Type_Pattern, Access_To_Subtype_For_Any_Type_Pattern);

         function Allocate_Any_Type_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Any_Type_Pattern;

         function Allocate_Any_Type_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Any_Type_Pattern
         is
            Result      : constant Access_To_Subtype_For_Any_Type_Pattern := Bare_Any_Type_Pattern_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Any_Type_Pattern;
            return Bare_Any_Type_Pattern (Result);
         end Allocate_Any_Type_Pattern;

         
         subtype Subtype_For_Binding_Pattern is
            Root_Node_Record (Lkt_Binding_Pattern);
         type Access_To_Subtype_For_Binding_Pattern is access all Subtype_For_Binding_Pattern;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Binding_Pattern);
         package Bare_Binding_Pattern_Alloc is new Alloc
           (Subtype_For_Binding_Pattern, Access_To_Subtype_For_Binding_Pattern);

         function Allocate_Binding_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Binding_Pattern;

         function Allocate_Binding_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Binding_Pattern
         is
            Result      : constant Access_To_Subtype_For_Binding_Pattern := Bare_Binding_Pattern_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Binding_Pattern;
            return Bare_Binding_Pattern (Result);
         end Allocate_Binding_Pattern;

         
         subtype Subtype_For_Bool_Pattern_False is
            Root_Node_Record (Lkt_Bool_Pattern_False);
         type Access_To_Subtype_For_Bool_Pattern_False is access all Subtype_For_Bool_Pattern_False;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Bool_Pattern_False);
         package Bare_Bool_Pattern_False_Alloc is new Alloc
           (Subtype_For_Bool_Pattern_False, Access_To_Subtype_For_Bool_Pattern_False);

         function Allocate_Bool_Pattern_False
           (Pool : Bump_Ptr_Pool) return Bare_Bool_Pattern_False;

         function Allocate_Bool_Pattern_False
           (Pool : Bump_Ptr_Pool) return Bare_Bool_Pattern_False
         is
            Result      : constant Access_To_Subtype_For_Bool_Pattern_False := Bare_Bool_Pattern_False_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Bool_Pattern_False;
            return Bare_Bool_Pattern_False (Result);
         end Allocate_Bool_Pattern_False;

         
         subtype Subtype_For_Bool_Pattern_True is
            Root_Node_Record (Lkt_Bool_Pattern_True);
         type Access_To_Subtype_For_Bool_Pattern_True is access all Subtype_For_Bool_Pattern_True;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Bool_Pattern_True);
         package Bare_Bool_Pattern_True_Alloc is new Alloc
           (Subtype_For_Bool_Pattern_True, Access_To_Subtype_For_Bool_Pattern_True);

         function Allocate_Bool_Pattern_True
           (Pool : Bump_Ptr_Pool) return Bare_Bool_Pattern_True;

         function Allocate_Bool_Pattern_True
           (Pool : Bump_Ptr_Pool) return Bare_Bool_Pattern_True
         is
            Result      : constant Access_To_Subtype_For_Bool_Pattern_True := Bare_Bool_Pattern_True_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Bool_Pattern_True;
            return Bare_Bool_Pattern_True (Result);
         end Allocate_Bool_Pattern_True;

         
         subtype Subtype_For_Ellipsis_Pattern is
            Root_Node_Record (Lkt_Ellipsis_Pattern);
         type Access_To_Subtype_For_Ellipsis_Pattern is access all Subtype_For_Ellipsis_Pattern;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Ellipsis_Pattern);
         package Bare_Ellipsis_Pattern_Alloc is new Alloc
           (Subtype_For_Ellipsis_Pattern, Access_To_Subtype_For_Ellipsis_Pattern);

         function Allocate_Ellipsis_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Ellipsis_Pattern;

         function Allocate_Ellipsis_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Ellipsis_Pattern
         is
            Result      : constant Access_To_Subtype_For_Ellipsis_Pattern := Bare_Ellipsis_Pattern_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Ellipsis_Pattern;
            return Bare_Ellipsis_Pattern (Result);
         end Allocate_Ellipsis_Pattern;

         
         subtype Subtype_For_Extended_Pattern is
            Root_Node_Record (Lkt_Extended_Pattern);
         type Access_To_Subtype_For_Extended_Pattern is access all Subtype_For_Extended_Pattern;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Extended_Pattern);
         package Bare_Extended_Pattern_Alloc is new Alloc
           (Subtype_For_Extended_Pattern, Access_To_Subtype_For_Extended_Pattern);

         function Allocate_Extended_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Extended_Pattern;

         function Allocate_Extended_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Extended_Pattern
         is
            Result      : constant Access_To_Subtype_For_Extended_Pattern := Bare_Extended_Pattern_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Extended_Pattern;
            return Bare_Extended_Pattern (Result);
         end Allocate_Extended_Pattern;

         
         subtype Subtype_For_Filtered_Pattern is
            Root_Node_Record (Lkt_Filtered_Pattern);
         type Access_To_Subtype_For_Filtered_Pattern is access all Subtype_For_Filtered_Pattern;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Filtered_Pattern);
         package Bare_Filtered_Pattern_Alloc is new Alloc
           (Subtype_For_Filtered_Pattern, Access_To_Subtype_For_Filtered_Pattern);

         function Allocate_Filtered_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Filtered_Pattern;

         function Allocate_Filtered_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Filtered_Pattern
         is
            Result      : constant Access_To_Subtype_For_Filtered_Pattern := Bare_Filtered_Pattern_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Filtered_Pattern;
            return Bare_Filtered_Pattern (Result);
         end Allocate_Filtered_Pattern;

         
         subtype Subtype_For_Integer_Pattern is
            Root_Node_Record (Lkt_Integer_Pattern);
         type Access_To_Subtype_For_Integer_Pattern is access all Subtype_For_Integer_Pattern;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Integer_Pattern);
         package Bare_Integer_Pattern_Alloc is new Alloc
           (Subtype_For_Integer_Pattern, Access_To_Subtype_For_Integer_Pattern);

         function Allocate_Integer_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Integer_Pattern;

         function Allocate_Integer_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Integer_Pattern
         is
            Result      : constant Access_To_Subtype_For_Integer_Pattern := Bare_Integer_Pattern_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Integer_Pattern;
            return Bare_Integer_Pattern (Result);
         end Allocate_Integer_Pattern;

         
         subtype Subtype_For_List_Pattern is
            Root_Node_Record (Lkt_List_Pattern);
         type Access_To_Subtype_For_List_Pattern is access all Subtype_For_List_Pattern;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_List_Pattern);
         package Bare_List_Pattern_Alloc is new Alloc
           (Subtype_For_List_Pattern, Access_To_Subtype_For_List_Pattern);

         function Allocate_List_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_List_Pattern;

         function Allocate_List_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_List_Pattern
         is
            Result      : constant Access_To_Subtype_For_List_Pattern := Bare_List_Pattern_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_List_Pattern;
            return Bare_List_Pattern (Result);
         end Allocate_List_Pattern;

         
         subtype Subtype_For_Not_Pattern is
            Root_Node_Record (Lkt_Not_Pattern);
         type Access_To_Subtype_For_Not_Pattern is access all Subtype_For_Not_Pattern;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Not_Pattern);
         package Bare_Not_Pattern_Alloc is new Alloc
           (Subtype_For_Not_Pattern, Access_To_Subtype_For_Not_Pattern);

         function Allocate_Not_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Not_Pattern;

         function Allocate_Not_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Not_Pattern
         is
            Result      : constant Access_To_Subtype_For_Not_Pattern := Bare_Not_Pattern_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Not_Pattern;
            return Bare_Not_Pattern (Result);
         end Allocate_Not_Pattern;

         
         subtype Subtype_For_Null_Pattern is
            Root_Node_Record (Lkt_Null_Pattern);
         type Access_To_Subtype_For_Null_Pattern is access all Subtype_For_Null_Pattern;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Null_Pattern);
         package Bare_Null_Pattern_Alloc is new Alloc
           (Subtype_For_Null_Pattern, Access_To_Subtype_For_Null_Pattern);

         function Allocate_Null_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Null_Pattern;

         function Allocate_Null_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Null_Pattern
         is
            Result      : constant Access_To_Subtype_For_Null_Pattern := Bare_Null_Pattern_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Null_Pattern;
            return Bare_Null_Pattern (Result);
         end Allocate_Null_Pattern;

         
         subtype Subtype_For_Or_Pattern is
            Root_Node_Record (Lkt_Or_Pattern);
         type Access_To_Subtype_For_Or_Pattern is access all Subtype_For_Or_Pattern;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Or_Pattern);
         package Bare_Or_Pattern_Alloc is new Alloc
           (Subtype_For_Or_Pattern, Access_To_Subtype_For_Or_Pattern);

         function Allocate_Or_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Or_Pattern;

         function Allocate_Or_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Or_Pattern
         is
            Result      : constant Access_To_Subtype_For_Or_Pattern := Bare_Or_Pattern_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Or_Pattern;
            return Bare_Or_Pattern (Result);
         end Allocate_Or_Pattern;

         
         subtype Subtype_For_Paren_Pattern is
            Root_Node_Record (Lkt_Paren_Pattern);
         type Access_To_Subtype_For_Paren_Pattern is access all Subtype_For_Paren_Pattern;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Paren_Pattern);
         package Bare_Paren_Pattern_Alloc is new Alloc
           (Subtype_For_Paren_Pattern, Access_To_Subtype_For_Paren_Pattern);

         function Allocate_Paren_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Paren_Pattern;

         function Allocate_Paren_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Paren_Pattern
         is
            Result      : constant Access_To_Subtype_For_Paren_Pattern := Bare_Paren_Pattern_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Paren_Pattern;
            return Bare_Paren_Pattern (Result);
         end Allocate_Paren_Pattern;

         
         subtype Subtype_For_Regex_Pattern is
            Root_Node_Record (Lkt_Regex_Pattern);
         type Access_To_Subtype_For_Regex_Pattern is access all Subtype_For_Regex_Pattern;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Regex_Pattern);
         package Bare_Regex_Pattern_Alloc is new Alloc
           (Subtype_For_Regex_Pattern, Access_To_Subtype_For_Regex_Pattern);

         function Allocate_Regex_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Regex_Pattern;

         function Allocate_Regex_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Regex_Pattern
         is
            Result      : constant Access_To_Subtype_For_Regex_Pattern := Bare_Regex_Pattern_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Regex_Pattern;
            return Bare_Regex_Pattern (Result);
         end Allocate_Regex_Pattern;

         
         subtype Subtype_For_Tuple_Pattern is
            Root_Node_Record (Lkt_Tuple_Pattern);
         type Access_To_Subtype_For_Tuple_Pattern is access all Subtype_For_Tuple_Pattern;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Tuple_Pattern);
         package Bare_Tuple_Pattern_Alloc is new Alloc
           (Subtype_For_Tuple_Pattern, Access_To_Subtype_For_Tuple_Pattern);

         function Allocate_Tuple_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Tuple_Pattern;

         function Allocate_Tuple_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Tuple_Pattern
         is
            Result      : constant Access_To_Subtype_For_Tuple_Pattern := Bare_Tuple_Pattern_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Tuple_Pattern;
            return Bare_Tuple_Pattern (Result);
         end Allocate_Tuple_Pattern;

         
         subtype Subtype_For_Type_Pattern is
            Root_Node_Record (Lkt_Type_Pattern);
         type Access_To_Subtype_For_Type_Pattern is access all Subtype_For_Type_Pattern;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Type_Pattern);
         package Bare_Type_Pattern_Alloc is new Alloc
           (Subtype_For_Type_Pattern, Access_To_Subtype_For_Type_Pattern);

         function Allocate_Type_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Type_Pattern;

         function Allocate_Type_Pattern
           (Pool : Bump_Ptr_Pool) return Bare_Type_Pattern
         is
            Result      : constant Access_To_Subtype_For_Type_Pattern := Bare_Type_Pattern_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Type_Pattern;
            return Bare_Type_Pattern (Result);
         end Allocate_Type_Pattern;

         
         subtype Subtype_For_Field_Pattern_Detail is
            Root_Node_Record (Lkt_Field_Pattern_Detail);
         type Access_To_Subtype_For_Field_Pattern_Detail is access all Subtype_For_Field_Pattern_Detail;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Field_Pattern_Detail);
         package Bare_Field_Pattern_Detail_Alloc is new Alloc
           (Subtype_For_Field_Pattern_Detail, Access_To_Subtype_For_Field_Pattern_Detail);

         function Allocate_Field_Pattern_Detail
           (Pool : Bump_Ptr_Pool) return Bare_Field_Pattern_Detail;

         function Allocate_Field_Pattern_Detail
           (Pool : Bump_Ptr_Pool) return Bare_Field_Pattern_Detail
         is
            Result      : constant Access_To_Subtype_For_Field_Pattern_Detail := Bare_Field_Pattern_Detail_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Field_Pattern_Detail;
            return Bare_Field_Pattern_Detail (Result);
         end Allocate_Field_Pattern_Detail;

         
         subtype Subtype_For_Property_Pattern_Detail is
            Root_Node_Record (Lkt_Property_Pattern_Detail);
         type Access_To_Subtype_For_Property_Pattern_Detail is access all Subtype_For_Property_Pattern_Detail;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Property_Pattern_Detail);
         package Bare_Property_Pattern_Detail_Alloc is new Alloc
           (Subtype_For_Property_Pattern_Detail, Access_To_Subtype_For_Property_Pattern_Detail);

         function Allocate_Property_Pattern_Detail
           (Pool : Bump_Ptr_Pool) return Bare_Property_Pattern_Detail;

         function Allocate_Property_Pattern_Detail
           (Pool : Bump_Ptr_Pool) return Bare_Property_Pattern_Detail
         is
            Result      : constant Access_To_Subtype_For_Property_Pattern_Detail := Bare_Property_Pattern_Detail_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Property_Pattern_Detail;
            return Bare_Property_Pattern_Detail (Result);
         end Allocate_Property_Pattern_Detail;

         
         subtype Subtype_For_Selector_Pattern_Detail is
            Root_Node_Record (Lkt_Selector_Pattern_Detail);
         type Access_To_Subtype_For_Selector_Pattern_Detail is access all Subtype_For_Selector_Pattern_Detail;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Selector_Pattern_Detail);
         package Bare_Selector_Pattern_Detail_Alloc is new Alloc
           (Subtype_For_Selector_Pattern_Detail, Access_To_Subtype_For_Selector_Pattern_Detail);

         function Allocate_Selector_Pattern_Detail
           (Pool : Bump_Ptr_Pool) return Bare_Selector_Pattern_Detail;

         function Allocate_Selector_Pattern_Detail
           (Pool : Bump_Ptr_Pool) return Bare_Selector_Pattern_Detail
         is
            Result      : constant Access_To_Subtype_For_Selector_Pattern_Detail := Bare_Selector_Pattern_Detail_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Selector_Pattern_Detail;
            return Bare_Selector_Pattern_Detail (Result);
         end Allocate_Selector_Pattern_Detail;

         
         subtype Subtype_For_Selector_Call is
            Root_Node_Record (Lkt_Selector_Call);
         type Access_To_Subtype_For_Selector_Call is access all Subtype_For_Selector_Call;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Selector_Call);
         package Bare_Selector_Call_Alloc is new Alloc
           (Subtype_For_Selector_Call, Access_To_Subtype_For_Selector_Call);

         function Allocate_Selector_Call
           (Pool : Bump_Ptr_Pool) return Bare_Selector_Call;

         function Allocate_Selector_Call
           (Pool : Bump_Ptr_Pool) return Bare_Selector_Call
         is
            Result      : constant Access_To_Subtype_For_Selector_Call := Bare_Selector_Call_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Selector_Call;
            return Bare_Selector_Call (Result);
         end Allocate_Selector_Call;

         
         subtype Subtype_For_Default_List_Type_Ref is
            Root_Node_Record (Lkt_Default_List_Type_Ref);
         type Access_To_Subtype_For_Default_List_Type_Ref is access all Subtype_For_Default_List_Type_Ref;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Default_List_Type_Ref);
         package Bare_Default_List_Type_Ref_Alloc is new Alloc
           (Subtype_For_Default_List_Type_Ref, Access_To_Subtype_For_Default_List_Type_Ref);

         function Allocate_Default_List_Type_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Default_List_Type_Ref;

         function Allocate_Default_List_Type_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Default_List_Type_Ref
         is
            Result      : constant Access_To_Subtype_For_Default_List_Type_Ref := Bare_Default_List_Type_Ref_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Default_List_Type_Ref;
            return Bare_Default_List_Type_Ref (Result);
         end Allocate_Default_List_Type_Ref;

         
         subtype Subtype_For_Function_Type_Ref is
            Root_Node_Record (Lkt_Function_Type_Ref);
         type Access_To_Subtype_For_Function_Type_Ref is access all Subtype_For_Function_Type_Ref;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Function_Type_Ref);
         package Bare_Function_Type_Ref_Alloc is new Alloc
           (Subtype_For_Function_Type_Ref, Access_To_Subtype_For_Function_Type_Ref);

         function Allocate_Function_Type_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Function_Type_Ref;

         function Allocate_Function_Type_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Function_Type_Ref
         is
            Result      : constant Access_To_Subtype_For_Function_Type_Ref := Bare_Function_Type_Ref_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Function_Type_Ref;
            return Bare_Function_Type_Ref (Result);
         end Allocate_Function_Type_Ref;

         
         subtype Subtype_For_Generic_Type_Ref is
            Root_Node_Record (Lkt_Generic_Type_Ref);
         type Access_To_Subtype_For_Generic_Type_Ref is access all Subtype_For_Generic_Type_Ref;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Generic_Type_Ref);
         package Bare_Generic_Type_Ref_Alloc is new Alloc
           (Subtype_For_Generic_Type_Ref, Access_To_Subtype_For_Generic_Type_Ref);

         function Allocate_Generic_Type_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Type_Ref;

         function Allocate_Generic_Type_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Generic_Type_Ref
         is
            Result      : constant Access_To_Subtype_For_Generic_Type_Ref := Bare_Generic_Type_Ref_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Generic_Type_Ref;
            return Bare_Generic_Type_Ref (Result);
         end Allocate_Generic_Type_Ref;

         
         subtype Subtype_For_Simple_Type_Ref is
            Root_Node_Record (Lkt_Simple_Type_Ref);
         type Access_To_Subtype_For_Simple_Type_Ref is access all Subtype_For_Simple_Type_Ref;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Simple_Type_Ref);
         package Bare_Simple_Type_Ref_Alloc is new Alloc
           (Subtype_For_Simple_Type_Ref, Access_To_Subtype_For_Simple_Type_Ref);

         function Allocate_Simple_Type_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Simple_Type_Ref;

         function Allocate_Simple_Type_Ref
           (Pool : Bump_Ptr_Pool) return Bare_Simple_Type_Ref
         is
            Result      : constant Access_To_Subtype_For_Simple_Type_Ref := Bare_Simple_Type_Ref_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Simple_Type_Ref;
            return Bare_Simple_Type_Ref (Result);
         end Allocate_Simple_Type_Ref;

         
         subtype Subtype_For_Var_Bind is
            Root_Node_Record (Lkt_Var_Bind);
         type Access_To_Subtype_For_Var_Bind is access all Subtype_For_Var_Bind;
         pragma No_Strict_Aliasing (Access_To_Subtype_For_Var_Bind);
         package Bare_Var_Bind_Alloc is new Alloc
           (Subtype_For_Var_Bind, Access_To_Subtype_For_Var_Bind);

         function Allocate_Var_Bind
           (Pool : Bump_Ptr_Pool) return Bare_Var_Bind;

         function Allocate_Var_Bind
           (Pool : Bump_Ptr_Pool) return Bare_Var_Bind
         is
            Result      : constant Access_To_Subtype_For_Var_Bind := Bare_Var_Bind_Alloc.Alloc (Pool);
            Result_Kind : Lkt_Node_Kind_Type
               with Import, Address => Result.Kind'Address;
            --  Result.Kind is a discriminant, so we can't modify it directly.
            --  We need to initialize it manually, though, as we don't use a
            --  standard Ada allocator for nodes. Use an overlay to workaround
            --  Ada's restrictions.
         begin
            Result_Kind := Lkt_Var_Bind;
            return Bare_Var_Bind (Result);
         end Allocate_Var_Bind;


   pragma Warnings (On, "is not referenced");

   procedure Set_Failure
     (Memo     : in out Memos.Memo_Type;
      Pos      : Token_Index;
      Info     : Fail_Info;
      Mark     : Diagnostic_Mark);
   --  Convenience wrapper for ``Memos.Set_Failure``

   procedure Set_Last_Fail
     (Parser : in out Parser_Type; M : Memos.Memo_Entry);
   --  Set ``Parser.Last_Fail`` from a failing memo entry

   type Dontskip_Parser_Function is access function
     (Parser : in out Parser_Type;
      Pos    : Token_Index) return Bare_Lkt_Node;

   package Dont_Skip_Fn_Vectors
   is new Ada.Containers.Vectors (Natural, Dontskip_Parser_Function);

   type Free_Parse_List_Record;
   type Free_Parse_List is access all Free_Parse_List_Record;
   --  Cache of temporary lists of AST nodes used in List parsers

   type Free_Parse_List_Record is record
      Nodes : Bare_Lkt_Node_Vectors.Vector;
      Next  : Free_Parse_List;
   end record;

   type Parser_Private_Part_Type is record
      Parse_Lists : Free_Parse_List;

      
      Args_List_Parse0_Memo : Memos.Memo_Type;
      
      Argument_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Arith_1_Or_Parse1_Memo : Memos.Memo_Type;
      
      Arith_2_Or_Parse1_Memo : Memos.Memo_Type;
      
      Arith_3_Or_Parse1_Memo : Memos.Memo_Type;
      
      Array_Literal_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Bare_Decl_Or_Parse0_Memo : Memos.Memo_Type;
      
      Basic_Expr_Or_Parse0_Memo : Memos.Memo_Type;
      
      Basic_Name_Or_Parse0_Memo : Memos.Memo_Type;
      
      Big_Num_Lit_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Block_String_Lit_Transform_Parse1_Memo : Memos.Memo_Type;
      
      Block_Transform_Parse2_Memo : Memos.Memo_Type;
      
      Bool_Pattern_Or_Parse0_Memo : Memos.Memo_Type;
      
      Callable_Ref_Or_Parse0_Memo : Memos.Memo_Type;
      
      Char_Lit_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Decl_Annotation_Args_Opt_Parse0_Memo : Memos.Memo_Type;
      
      Decl_Annotation_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Decl_Block_List_Parse0_Memo : Memos.Memo_Type;
      
      Decl_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Decls_Dont_Skip_Parse0_Memo : Memos.Memo_Type;
      
      Def_Id_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Doc_Opt_Parse0_Memo : Memos.Memo_Type;
      
      Dontskip_Block0_Extract_Parse0_Memo : Memos.Memo_Type;
      
      Dontskip_Decls0_Extract_Parse0_Memo : Memos.Memo_Type;
      
      Dontskip_Grammar_List_Expr0_Extract_Parse0_Memo : Memos.Memo_Type;
      
      Dontskip_Grammar_List_Expr1_Extract_Parse0_Memo : Memos.Memo_Type;
      
      Dontskip_Grammar_Opt0_Extract_Parse0_Memo : Memos.Memo_Type;
      
      Dontskip_Grammar_Opt_Error0_Extract_Parse0_Memo : Memos.Memo_Type;
      
      Dontskip_Grammar_Or_Expr0_Extract_Parse0_Memo : Memos.Memo_Type;
      
      Dontskip_Grammar_Or_Expr1_Extract_Parse0_Memo : Memos.Memo_Type;
      
      Dontskip_Grammar_Pick0_Extract_Parse0_Memo : Memos.Memo_Type;
      
      Dontskip_Lexer_Case_Rule0_Extract_Parse0_Memo : Memos.Memo_Type;
      
      Dontskip_Lexer_Decl0_Extract_Parse0_Memo : Memos.Memo_Type;
      
      Dontskip_Lexer_Family_Decl0_Extract_Parse0_Memo : Memos.Memo_Type;
      
      Dontskip_Parse_Node_Expr0_Extract_Parse0_Memo : Memos.Memo_Type;
      
      Dontskip_Type_Decl0_Extract_Parse0_Memo : Memos.Memo_Type;
      
      Dontskip_Type_Decl1_Extract_Parse0_Memo : Memos.Memo_Type;
      
      Dontskip_Type_Decl2_Extract_Parse0_Memo : Memos.Memo_Type;
      
      Dontskip_Type_Decl3_Extract_Parse0_Memo : Memos.Memo_Type;
      
      Dontskip_Type_Decl4_Extract_Parse0_Memo : Memos.Memo_Type;
      
      Dynvar_Decl_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Ellipsis_Pattern_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Enum_Lit_Decl_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Env_Spec_Action_Transform_Parse1_Memo : Memos.Memo_Type;
      
      Env_Spec_Decl_Transform_Parse1_Memo : Memos.Memo_Type;
      
      Eq_Or_Parse1_Memo : Memos.Memo_Type;
      
      Expr_Or_Parse0_Memo : Memos.Memo_Type;
      
      Field_Decl_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Fil_Pattern_Or_Parse0_Memo : Memos.Memo_Type;
      
      Fun_Decl_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Fun_Param_Decl_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Fun_Param_List_List_Parse0_Memo : Memos.Memo_Type;
      
      Generic_Decl_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Generic_Param_Type_Transform_Parse1_Memo : Memos.Memo_Type;
      
      Grammar_Cut_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Grammar_Decl_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Grammar_Discard_Expr_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Grammar_Expr_Or_Parse0_Memo : Memos.Memo_Type;
      
      Grammar_Implicit_Pick_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Grammar_List_Expr_Transform_Parse3_Memo : Memos.Memo_Type;
      
      Grammar_List_Sep_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Grammar_Null_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Grammar_Opt_Error_Or_Parse0_Memo : Memos.Memo_Type;
      
      Grammar_Opt_Or_Parse0_Memo : Memos.Memo_Type;
      
      Grammar_Or_Expr_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Grammar_Pick_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Grammar_Primary_Or_Parse0_Memo : Memos.Memo_Type;
      
      Grammar_Rule_Ref_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Grammar_Rule_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Grammar_Skip_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Grammar_Stopcut_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Grammar_Token_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Id_Transform_Parse0_Memo : Memos.Memo_Type;
      
      If_Expr_Transform_Parse1_Memo : Memos.Memo_Type;
      
      Import_Clause_Or_Parse0_Memo : Memos.Memo_Type;
      
      Imported_Name_Transform_Parse1_Memo : Memos.Memo_Type;
      
      Imports_List_Parse0_Memo : Memos.Memo_Type;
      
      Integer_Pattern_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Isa_Or_Primary_Or_Parse0_Memo : Memos.Memo_Type;
      
      Lambda_Expr_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Lambda_Param_Decl_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Lambda_Param_List_List_Parse0_Memo : Memos.Memo_Type;
      
      Lexer_Case_Alt_Or_Parse0_Memo : Memos.Memo_Type;
      
      Lexer_Case_Rule_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Lexer_Case_Send_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Lexer_Decl_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Lexer_Family_Decl_Transform_Parse0_Memo : Memos.Memo_Type;
      
      List_Pattern_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Logic_Or_Parse1_Memo : Memos.Memo_Type;
      
      Logic_Propagate_Call_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Main_Rule_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Match_Expr_Transform_Parse3_Memo : Memos.Memo_Type;
      
      Module_Doc_Opt_Parse0_Memo : Memos.Memo_Type;
      
      Module_Id_Predicate_Parse0_Memo : Memos.Memo_Type;
      
      Null_Cond_Qual_Opt_Parse0_Memo : Memos.Memo_Type;
      
      Null_Lit_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Num_Lit_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Parse_Node_Expr_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Pattern_Arg_Or_Parse0_Memo : Memos.Memo_Type;
      
      Pattern_Or_Parse0_Memo : Memos.Memo_Type;
      
      Primary_Or_Parse0_Memo : Memos.Memo_Type;
      
      Query_Comprehension_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Raise_Expr_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Ref_Id_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Regex_Pattern_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Rel_Or_Parse0_Memo : Memos.Memo_Type;
      
      Selector_Call_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Stream_Concat_Or_Parse0_Memo : Memos.Memo_Type;
      
      String_Lit_Or_Parse0_Memo : Memos.Memo_Type;
      
      Term_Or_Parse0_Memo : Memos.Memo_Type;
      
      Token_Literal_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Token_No_Case_Literal_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Token_Pattern_Literal_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Token_Pattern_Or_Parse0_Memo : Memos.Memo_Type;
      
      Try_Expr_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Tuple_Pattern_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Type_Decl_Or_Parse0_Memo : Memos.Memo_Type;
      
      Type_Expr_Or_Parse0_Memo : Memos.Memo_Type;
      
      Type_List_List_Parse0_Memo : Memos.Memo_Type;
      
      Type_Member_Ref_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Type_Ref_Id_Predicate_Parse0_Memo : Memos.Memo_Type;
      
      Type_Ref_Or_Parse0_Memo : Memos.Memo_Type;
      
      Val_Decl_Transform_Parse0_Memo : Memos.Memo_Type;
      
      Value_Pattern_Or_Parse1_Memo : Memos.Memo_Type;
      
      Var_Bind_Transform_Parse0_Memo : Memos.Memo_Type;

      Dont_Skip : Dont_Skip_Fn_Vectors.Vector;
   end record;
   type Parser_Private_Part is access all Parser_Private_Part_Type;
   pragma No_Strict_Aliasing (Parser_Private_Part);
   function "+" is new Ada.Unchecked_Conversion
     (System.Address, Parser_Private_Part);
   function "+" is new Ada.Unchecked_Conversion
     (Parser_Private_Part, System.Address);

   
function Args_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Argument_List;

   
function Argument_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Argument;

   
function Arith_1_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Arith_2_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Arith_3_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Array_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Array_Literal;

   
function Bare_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decl;

   
function Basic_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Basic_Name_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Big_Num_Lit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Big_Num_Lit;

   
function Block_Transform_Parse2
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Block_Expr;

   
function Block_String_Lit_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Block_String_Lit;

   
function Bool_Pattern_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Bool_Pattern;

   
function Callable_Ref_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Char_Lit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Char_Lit;

   
function Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Full_Decl;

   
function Decl_Annotation_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decl_Annotation;

   
function Decl_Annotation_Args_Opt_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decl_Annotation_Args;

   
function Decl_Block_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decl_Block;

   
function Decls_Dont_Skip_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Full_Decl_List;

   
function Def_Id_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Def_Id;

   
function Doc_Opt_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_String_Lit;

   
function Dontskip_Block0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Dontskip_Decls0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Dontskip_Grammar_List_Expr0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Dontskip_Grammar_List_Expr1_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Dontskip_Grammar_Opt0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Dontskip_Grammar_Opt_Error0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Dontskip_Grammar_Or_Expr0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Dontskip_Grammar_Or_Expr1_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Dontskip_Grammar_Pick0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Dontskip_Lexer_Case_Rule0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Dontskip_Lexer_Decl0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Dontskip_Lexer_Family_Decl0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Dontskip_Parse_Node_Expr0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Dontskip_Type_Decl0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Dontskip_Type_Decl1_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Dontskip_Type_Decl2_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Dontskip_Type_Decl3_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Dontskip_Type_Decl4_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node;

   
function Dynvar_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Dyn_Var_Decl;

   
function Ellipsis_Pattern_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ellipsis_Pattern;

   
function Enum_Lit_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Enum_Lit_Decl;

   
function Env_Spec_Action_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Call_Expr;

   
function Env_Spec_Decl_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Env_Spec_Decl;

   
function Eq_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Field_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Field_Decl;

   
function Fil_Pattern_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Pattern;

   
function Fun_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Fun_Decl;

   
function Fun_Param_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Fun_Param_Decl;

   
function Fun_Param_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Fun_Param_Decl_List;

   
function Generic_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Generic_Decl;

   
function Generic_Param_Type_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Full_Decl;

   
function Grammar_Cut_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Cut;

   
function Grammar_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Decl;

   
function Grammar_Discard_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Discard;

   
function Grammar_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr;

   
function Grammar_Implicit_Pick_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Implicit_Pick;

   
function Grammar_List_Expr_Transform_Parse3
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_List;

   
function Grammar_List_Sep_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_List_Sep;

   
function Grammar_Null_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Null;

   
function Grammar_Opt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr;

   
function Grammar_Opt_Error_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr;

   
function Grammar_Or_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Or_Expr;

   
function Grammar_Pick_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Pick;

   
function Grammar_Primary_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr;

   
function Grammar_Rule_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Rule_Decl;

   
function Grammar_Rule_Ref_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Rule_Ref;

   
function Grammar_Skip_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Skip;

   
function Grammar_Stopcut_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Stop_Cut;

   
function Grammar_Token_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Token_Ref;

   
function Id_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Id;

   
function If_Expr_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_If_Expr;

   
function Import_Clause_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Import;

   
function Imported_Name_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Imported_Name;

   
function Imports_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Import_List;

   
function Integer_Pattern_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Integer_Pattern;

   
function Isa_Or_Primary_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Lambda_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lambda_Expr;

   
function Lambda_Param_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lambda_Param_Decl;

   
function Lambda_Param_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lambda_Param_Decl_List;

   
function Lexer_Case_Alt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Lexer_Case_Rule_Alt;

   
function Lexer_Case_Rule_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lexer_Case_Rule;

   
function Lexer_Case_Send_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lexer_Case_Rule_Send;

   
function Lexer_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lexer_Decl;

   
function Lexer_Family_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lexer_Family_Decl;

   
function List_Pattern_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_List_Pattern;

   
function Logic_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Logic_Propagate_Call_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Logic_Propagate_Call;

   
function Main_Rule_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Langkit_Root;

   
function Match_Expr_Transform_Parse3
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Match_Expr;

   
function Module_Doc_Opt_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Module_Doc_String_Lit;

   
function Module_Id_Predicate_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Module_Id;

   
function Null_Cond_Qual_Opt_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Null_Cond_Qualifier;

   
function Null_Lit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Null_Lit;

   
function Num_Lit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Num_Lit;

   
function Parse_Node_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Parse_Node_Expr;

   
function Pattern_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Pattern;

   
function Pattern_Arg_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Pattern_Detail;

   
function Primary_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Query_Comprehension_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Query;

   
function Raise_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Raise_Expr;

   
function Ref_Id_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ref_Id;

   
function Regex_Pattern_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Regex_Pattern;

   
function Rel_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Selector_Call_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Selector_Call;

   
function Stream_Concat_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function String_Lit_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_String_Lit;

   
function Term_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Token_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Token_Lit;

   
function Token_No_Case_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Token_No_Case_Lit;

   
function Token_Pattern_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr;

   
function Token_Pattern_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Token_Pattern_Lit;

   
function Try_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Try_Expr;

   
function Tuple_Pattern_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Tuple_Pattern;

   
function Type_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Named_Type_Decl;

   
function Type_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr;

   
function Type_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Type_Ref_List;

   
function Type_Member_Ref_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Dot_Expr;

   
function Type_Ref_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Type_Ref;

   
function Type_Ref_Id_Predicate_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ref_Id;

   
function Val_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Val_Decl;

   
function Value_Pattern_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Pattern;

   
function Var_Bind_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Var_Bind;


   procedure Process_Parsing_Error
     (Parser         : in out Parser_Type;
      Check_Complete : Boolean := True);
   --  Helper for the user parsing function, to be called after a low-level
   --  parsing function. Check_Complete has the same semantics as in Parse. If
   --  the parsing failed (Parser.Current_Pos = No_Token_Index), append
   --  corresponding diagnostics to Parser.Diagnostics, do nothing instead.

   pragma Warnings (Off, "is not referenced");

   -------------------------
   -- Diagnostics helpers --
   -------------------------

   procedure Append
     (Parser : in out Parser_Type; Location : Token_Index; Message : String);

   procedure Add_Last_Fail_Diagnostic (Parser : in out Parser_Type);
   --  Add a diagnostic for the last fail position of the parser

   procedure Import_Diagnostics (Parser : in out Parser_Type);
   --  Import the chain of diagnostics from ``Parser.Last_Diag`` to
   --  ``Parser.Diagnostics``.

   ------------------
   -- List helpers --
   ------------------

   function Get_Parse_List (Parser : Parser_Type) return Free_Parse_List;
   --  Get a free parse list, or allocate one if there is no free parse list in
   --  Parser. When done with the result, the caller must invoke
   --  Release_Parse_List.

   procedure Release_Parse_List
     (Parser : Parser_Type; List : in out Free_Parse_List);
   --  Release a parse list, putting it in Parsers' free list. Set List to
   --  null.

   procedure Initialize_List
     (Self   : Bare_Lkt_Node_Base_List;
      Parser : Parser_Type;
      Count  : Natural);
   --  Helper for parsers, to initialize the list of children in a freshly
   --  allocated list node.

   pragma Warnings (On, "is not referenced");

   -----------------
   -- Set_Failure --
   -----------------

   procedure Set_Failure
     (Memo     : in out Memos.Memo_Type;
      Pos      : Token_Index;
      Info     : Fail_Info;
      Mark     : Diagnostic_Mark)
   is
      Expected_Token_Id : Token_Kind := Token_Kind'First;
      Found_Token_Id    : Token_Kind := Token_Kind'First;
   begin
      if Info.Data.Kind = Token_Fail then
         Expected_Token_Id := Info.Data.Expected_Token_Id;
         Found_Token_Id := Info.Data.Found_Token_Id;
      end if;

      Memos.Set_Failure
        (Memo,
         Pos,
         Mark,
         Info.Data.Kind,
         Info.Pos,
         Expected_Token_Id,
         Found_Token_Id);
   end Set_Failure;

   -------------------
   -- Set_Last_Fail --
   -------------------

   procedure Set_Last_Fail (Parser : in out Parser_Type; M : Memos.Memo_Entry)
   is
   begin
      Parser.Last_Fail.Pos := M.Final_Pos;
      case M.Fail_Kind is
         when Token_Fail =>
            Parser.Last_Fail.Data :=
              (Token_Fail, M.Expected_Token_Id, M.Found_Token_Id);
         when Predicate_Fail =>
            Parser.Last_Fail.Data := (Kind => Predicate_Fail);
      end case;
   end Set_Last_Fail;

   ---------------------
   -- Initialize_List --
   ---------------------

   procedure Initialize_List
     (Self   : Bare_Lkt_Node_Base_List;
      Parser : Parser_Type;
      Count  : Natural) is
   begin
      Self.Count := Count;
      Self.Nodes := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, 0);
   end Initialize_List;

   -----------------
   -- Init_Parser --
   -----------------

   procedure Init_Parser
     (Input         : Lexer_Input;
      With_Trivia   : Boolean;
      Unit          : access Implementation.Analysis_Unit_Type;
      TDH           : Token_Data_Handler_Access;
      Parser        : in out Parser_Type;
      Old_TDH       : access constant Token_Data_Handler;
      Same_Contents : out Boolean)
   is
      --  Never try to use file readers for internal units: these are generally
      --  not actual source files, and file readers, which are external users
      --  of the generated library, have no reason to be aware of them.

      FR : constant Internal_File_Reader_Access :=
        (if Unit.Is_Internal
         then null
         else Unit.Context.File_Reader);
   begin
      Reset (Parser);
      Extract_Tokens
        (Input,
         With_Trivia,
         FR,
         TDH.all,
         Parser.Diagnostics,
         Old_TDH,
         Same_Contents);
      if Same_Contents then
         return;
      end if;
      Parser.Unit := Unit;
      Parser.TDH := TDH;
   end Init_Parser;

   ------------
   -- Append --
   ------------

   procedure Append
     (Parser : in out Parser_Type; Location : Token_Index; Message : String) is
   begin
      Append
        (Self     => Parser.Pool,
         Mark     => Parser.Last_Diag,
         Location => Sloc_Range
                       (Parser.TDH.all, Get_Token (Parser.TDH.all, Location)),
         Message  => To_Unbounded_Text (To_Text (Message)));
   end Append;

   ------------------------------
   -- Add_Last_Fail_Diagnostic --
   ------------------------------

   procedure Add_Last_Fail_Diagnostic (Parser : in out Parser_Type) is
   begin
      Append
        (Parser,
         Parser.Last_Fail.Pos,
         Message =>
           (if Parser.Last_Fail.Data.Kind = Token_Fail
            then "Expected "
                 & Token_Error_Image (Parser.Last_Fail.Data.Expected_Token_Id)
                 & ", got "
                 & Token_Error_Image (Parser.Last_Fail.Data.Found_Token_Id)
            else "Syntax error"));
   end Add_Last_Fail_Diagnostic;

   ------------------------
   -- Import_Diagnostics --
   ------------------------

   procedure Import_Diagnostics (Parser : in out Parser_Type) is
      procedure Append_One (D : Liblktlang_Support.Diagnostics.Diagnostic);

      ----------------
      -- Append_One --
      ----------------

      procedure Append_One (D : Liblktlang_Support.Diagnostics.Diagnostic) is
      begin
         Parser.Diagnostics.Append (D);
      end Append_One;
   begin
      Iterate (Parser.Pool, Parser.Last_Diag, Append_One'Access);
   end Import_Diagnostics;

   ---------------------------
   -- Process_Parsing_Error --
   ---------------------------

   procedure Process_Parsing_Error
     (Parser         : in out Parser_Type;
      Check_Complete : Boolean := True) is
   begin

      if Parser.Current_Pos = No_Token_Index then
         Add_Last_Fail_Diagnostic (Parser);
      elsif Check_Complete
        and then Parser.Current_Pos /= Last_Token (Parser.TDH.all)
      then
         --  If the fail pos is the current position of the parser or after,
         --  it means that the longest parse is the correct result, and that we
         --  have some garbage afterwards.
         if Parser.Current_Pos >= Parser.Last_Fail.Pos then
            declare
               First_Garbage_Token : Stored_Token_Data renames
                  Get_Token (Parser.TDH.all, Parser.Current_Pos);
            begin
               Append
                 (Parser,
                  Parser.Current_Pos,
                  "End of input expected, got """
                  & Token_Kind_Name (To_Token_Kind (First_Garbage_Token.Kind))
                  & """");
            end;

         --  Else, the last fail pos is further down the line, and we want to
         --  have the diagnostic of what exactly failed.
         else
            Add_Last_Fail_Diagnostic (Parser);
         end if;
      end if;

   end Process_Parsing_Error;

   -----------
   -- Parse --
   -----------

   function Parse
     (Parser         : in out Parser_Type;
      Check_Complete : Boolean := True;
      Rule           : Grammar_Rule) return Parsed_Node
   is
      Result : Bare_Lkt_Node;
   begin
      case Rule is
         when Main_Rule_Rule =>
            Result := Main_Rule_Transform_Parse0
              (Parser, First_Token_Index);
         when Id_Rule =>
            Result := Id_Transform_Parse0
              (Parser, First_Token_Index);
         when Ref_Id_Rule =>
            Result := Ref_Id_Transform_Parse0
              (Parser, First_Token_Index);
         when Type_Ref_Id_Rule =>
            Result := Type_Ref_Id_Predicate_Parse0
              (Parser, First_Token_Index);
         when Module_Id_Rule =>
            Result := Module_Id_Predicate_Parse0
              (Parser, First_Token_Index);
         when Def_Id_Rule =>
            Result := Def_Id_Transform_Parse0
              (Parser, First_Token_Index);
         when Doc_Rule =>
            Result := Doc_Opt_Parse0
              (Parser, First_Token_Index);
         when Module_Doc_Rule =>
            Result := Module_Doc_Opt_Parse0
              (Parser, First_Token_Index);
         when Imported_Name_Rule =>
            Result := Imported_Name_Transform_Parse1
              (Parser, First_Token_Index);
         when Import_Clause_Rule =>
            Result := Import_Clause_Or_Parse0
              (Parser, First_Token_Index);
         when Imports_Rule =>
            Result := Imports_List_Parse0
              (Parser, First_Token_Index);
         when Lexer_Decl_Rule =>
            Result := Lexer_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Decl_Rule =>
            Result := Grammar_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Rule_Rule =>
            Result := Grammar_Rule_Transform_Parse0
              (Parser, First_Token_Index);
         when Lexer_Case_Rule_Rule =>
            Result := Lexer_Case_Rule_Transform_Parse0
              (Parser, First_Token_Index);
         when Lexer_Case_Alt_Rule =>
            Result := Lexer_Case_Alt_Or_Parse0
              (Parser, First_Token_Index);
         when Lexer_Case_Send_Rule =>
            Result := Lexer_Case_Send_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Primary_Rule =>
            Result := Grammar_Primary_Or_Parse0
              (Parser, First_Token_Index);
         when Grammar_Expr_Rule =>
            Result := Grammar_Expr_Or_Parse0
              (Parser, First_Token_Index);
         when Grammar_Pick_Rule =>
            Result := Grammar_Pick_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Implicit_Pick_Rule =>
            Result := Grammar_Implicit_Pick_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Opt_Rule =>
            Result := Grammar_Opt_Or_Parse0
              (Parser, First_Token_Index);
         when Grammar_Opt_Error_Rule =>
            Result := Grammar_Opt_Error_Or_Parse0
              (Parser, First_Token_Index);
         when Grammar_Cut_Rule =>
            Result := Grammar_Cut_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Stopcut_Rule =>
            Result := Grammar_Stopcut_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Or_Expr_Rule =>
            Result := Grammar_Or_Expr_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Discard_Expr_Rule =>
            Result := Grammar_Discard_Expr_Transform_Parse0
              (Parser, First_Token_Index);
         when Token_Literal_Rule =>
            Result := Token_Literal_Transform_Parse0
              (Parser, First_Token_Index);
         when Token_No_Case_Literal_Rule =>
            Result := Token_No_Case_Literal_Transform_Parse0
              (Parser, First_Token_Index);
         when Token_Pattern_Rule =>
            Result := Token_Pattern_Or_Parse0
              (Parser, First_Token_Index);
         when Token_Pattern_Literal_Rule =>
            Result := Token_Pattern_Literal_Transform_Parse0
              (Parser, First_Token_Index);
         when Parse_Node_Expr_Rule =>
            Result := Parse_Node_Expr_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Rule_Ref_Rule =>
            Result := Grammar_Rule_Ref_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_List_Expr_Rule =>
            Result := Grammar_List_Expr_Transform_Parse3
              (Parser, First_Token_Index);
         when Grammar_List_Sep_Rule =>
            Result := Grammar_List_Sep_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Skip_Rule =>
            Result := Grammar_Skip_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Null_Rule =>
            Result := Grammar_Null_Transform_Parse0
              (Parser, First_Token_Index);
         when Grammar_Token_Rule =>
            Result := Grammar_Token_Transform_Parse0
              (Parser, First_Token_Index);
         when Type_Decl_Rule =>
            Result := Type_Decl_Or_Parse0
              (Parser, First_Token_Index);
         when Generic_Decl_Rule =>
            Result := Generic_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Generic_Param_Type_Rule =>
            Result := Generic_Param_Type_Transform_Parse1
              (Parser, First_Token_Index);
         when Enum_Lit_Decl_Rule =>
            Result := Enum_Lit_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Fun_Decl_Rule =>
            Result := Fun_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Lambda_Param_Decl_Rule =>
            Result := Lambda_Param_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Fun_Param_Decl_Rule =>
            Result := Fun_Param_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Fun_Param_List_Rule =>
            Result := Fun_Param_List_List_Parse0
              (Parser, First_Token_Index);
         when Lambda_Param_List_Rule =>
            Result := Lambda_Param_List_List_Parse0
              (Parser, First_Token_Index);
         when Field_Decl_Rule =>
            Result := Field_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Lexer_Family_Decl_Rule =>
            Result := Lexer_Family_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Bare_Decl_Rule =>
            Result := Bare_Decl_Or_Parse0
              (Parser, First_Token_Index);
         when Decl_Rule =>
            Result := Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Type_Member_Ref_Rule =>
            Result := Type_Member_Ref_Transform_Parse0
              (Parser, First_Token_Index);
         when Type_Expr_Rule =>
            Result := Type_Expr_Or_Parse0
              (Parser, First_Token_Index);
         when Type_Ref_Rule =>
            Result := Type_Ref_Or_Parse0
              (Parser, First_Token_Index);
         when Type_List_Rule =>
            Result := Type_List_List_Parse0
              (Parser, First_Token_Index);
         when Decls_Rule =>
            Result := Decls_Dont_Skip_Parse0
              (Parser, First_Token_Index);
         when Decl_Block_Rule =>
            Result := Decl_Block_List_Parse0
              (Parser, First_Token_Index);
         when Val_Decl_Rule =>
            Result := Val_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Dynvar_Decl_Rule =>
            Result := Dynvar_Decl_Transform_Parse0
              (Parser, First_Token_Index);
         when Var_Bind_Rule =>
            Result := Var_Bind_Transform_Parse0
              (Parser, First_Token_Index);
         when Env_Spec_Action_Rule =>
            Result := Env_Spec_Action_Transform_Parse1
              (Parser, First_Token_Index);
         when Env_Spec_Decl_Rule =>
            Result := Env_Spec_Decl_Transform_Parse1
              (Parser, First_Token_Index);
         when Block_Rule =>
            Result := Block_Transform_Parse2
              (Parser, First_Token_Index);
         when Pattern_Rule =>
            Result := Pattern_Or_Parse0
              (Parser, First_Token_Index);
         when Fil_Pattern_Rule =>
            Result := Fil_Pattern_Or_Parse0
              (Parser, First_Token_Index);
         when Value_Pattern_Rule =>
            Result := Value_Pattern_Or_Parse1
              (Parser, First_Token_Index);
         when Regex_Pattern_Rule =>
            Result := Regex_Pattern_Transform_Parse0
              (Parser, First_Token_Index);
         when Bool_Pattern_Rule =>
            Result := Bool_Pattern_Or_Parse0
              (Parser, First_Token_Index);
         when Ellipsis_Pattern_Rule =>
            Result := Ellipsis_Pattern_Transform_Parse0
              (Parser, First_Token_Index);
         when Integer_Pattern_Rule =>
            Result := Integer_Pattern_Transform_Parse0
              (Parser, First_Token_Index);
         when List_Pattern_Rule =>
            Result := List_Pattern_Transform_Parse0
              (Parser, First_Token_Index);
         when Tuple_Pattern_Rule =>
            Result := Tuple_Pattern_Transform_Parse0
              (Parser, First_Token_Index);
         when Pattern_Arg_Rule =>
            Result := Pattern_Arg_Or_Parse0
              (Parser, First_Token_Index);
         when Selector_Call_Rule =>
            Result := Selector_Call_Transform_Parse0
              (Parser, First_Token_Index);
         when Expr_Rule =>
            Result := Expr_Or_Parse0
              (Parser, First_Token_Index);
         when Stream_Concat_Rule =>
            Result := Stream_Concat_Or_Parse0
              (Parser, First_Token_Index);
         when Logic_Rule =>
            Result := Logic_Or_Parse1
              (Parser, First_Token_Index);
         when Rel_Rule =>
            Result := Rel_Or_Parse0
              (Parser, First_Token_Index);
         when Eq_Rule =>
            Result := Eq_Or_Parse1
              (Parser, First_Token_Index);
         when Arith_1_Rule =>
            Result := Arith_1_Or_Parse1
              (Parser, First_Token_Index);
         when Arith_2_Rule =>
            Result := Arith_2_Or_Parse1
              (Parser, First_Token_Index);
         when Arith_3_Rule =>
            Result := Arith_3_Or_Parse1
              (Parser, First_Token_Index);
         when Isa_Or_Primary_Rule =>
            Result := Isa_Or_Primary_Or_Parse0
              (Parser, First_Token_Index);
         when Logic_Propagate_Call_Rule =>
            Result := Logic_Propagate_Call_Transform_Parse0
              (Parser, First_Token_Index);
         when Primary_Rule =>
            Result := Primary_Or_Parse0
              (Parser, First_Token_Index);
         when Match_Expr_Rule =>
            Result := Match_Expr_Transform_Parse3
              (Parser, First_Token_Index);
         when Num_Lit_Rule =>
            Result := Num_Lit_Transform_Parse0
              (Parser, First_Token_Index);
         when Big_Num_Lit_Rule =>
            Result := Big_Num_Lit_Transform_Parse0
              (Parser, First_Token_Index);
         when String_Lit_Rule =>
            Result := String_Lit_Or_Parse0
              (Parser, First_Token_Index);
         when Block_String_Lit_Rule =>
            Result := Block_String_Lit_Transform_Parse1
              (Parser, First_Token_Index);
         when Char_Lit_Rule =>
            Result := Char_Lit_Transform_Parse0
              (Parser, First_Token_Index);
         when If_Expr_Rule =>
            Result := If_Expr_Transform_Parse1
              (Parser, First_Token_Index);
         when Raise_Expr_Rule =>
            Result := Raise_Expr_Transform_Parse0
              (Parser, First_Token_Index);
         when Try_Expr_Rule =>
            Result := Try_Expr_Transform_Parse0
              (Parser, First_Token_Index);
         when Array_Literal_Rule =>
            Result := Array_Literal_Transform_Parse0
              (Parser, First_Token_Index);
         when Callable_Ref_Rule =>
            Result := Callable_Ref_Or_Parse0
              (Parser, First_Token_Index);
         when Null_Cond_Qual_Rule =>
            Result := Null_Cond_Qual_Opt_Parse0
              (Parser, First_Token_Index);
         when Basic_Expr_Rule =>
            Result := Basic_Expr_Or_Parse0
              (Parser, First_Token_Index);
         when Term_Rule =>
            Result := Term_Or_Parse0
              (Parser, First_Token_Index);
         when Basic_Name_Rule =>
            Result := Basic_Name_Or_Parse0
              (Parser, First_Token_Index);
         when Lambda_Expr_Rule =>
            Result := Lambda_Expr_Transform_Parse0
              (Parser, First_Token_Index);
         when Null_Lit_Rule =>
            Result := Null_Lit_Transform_Parse0
              (Parser, First_Token_Index);
         when Argument_Rule =>
            Result := Argument_Transform_Parse0
              (Parser, First_Token_Index);
         when Args_Rule =>
            Result := Args_List_Parse0
              (Parser, First_Token_Index);
         when Decl_Annotation_Args_Rule =>
            Result := Decl_Annotation_Args_Opt_Parse0
              (Parser, First_Token_Index);
         when Decl_Annotation_Rule =>
            Result := Decl_Annotation_Transform_Parse0
              (Parser, First_Token_Index);
         when Query_Comprehension_Rule =>
            Result := Query_Comprehension_Transform_Parse0
              (Parser, First_Token_Index);
      end case;
      Process_Parsing_Error (Parser, Check_Complete);
      Set_Parents (Result, null);
      Import_Diagnostics (Parser);
      return Parsed_Node (Result);
   exception
      when Exc : Property_Error =>
         Import_Diagnostics (Parser);
         Append
           (Parser.Diagnostics,
            No_Source_Location_Range,
            To_Text ("Error during parsing: "
                     & Ada.Exceptions.Exception_Message (Exc)));
         return Parsed_Node (No_Bare_Lkt_Node);
   end Parse;

   function Args_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Argument_List
is
      Lst_Cpos0 : Token_Index := No_Token_Index;
      Tmp_List0 : Free_Parse_List;
      Defer_Pos0 : Token_Index := No_Token_Index;
      Defer_Res0 : Bare_Argument := No_Bare_Lkt_Node;
      Token_Pos0 : Token_Index := No_Token_Index;
      Token_Res0 : Token_Index := No_Token_Index;
      List_Pos0 : Token_Index := No_Token_Index;
      List_Res0 : Bare_Argument_List := No_Bare_Lkt_Node;
      Diag_Mark0 : Diagnostic_Mark;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Args_List_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      List_Res0 := M.Instance;
      return List_Res0;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return List_Res0;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <List (root of 'args') at parser.lkt:504:13>
--  pos=List_Pos0, res=List_Res0, nobt=None
    List_Pos0 := Pos;
Lst_Cpos0 := Pos;
Tmp_List0 := Get_Parse_List (Parser);
Diag_Mark0 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'argument') at parser.lkt:504:19>
--  pos=Defer_Pos0, res=Defer_Res0, nobt=None
Defer_Res0 :=
   Argument_Transform_Parse0 (Parser, Lst_Cpos0);
Defer_Pos0 := Parser.Current_Pos;
--  END <Defer (for 'argument') at parser.lkt:504:19>
   exit when Defer_Pos0 = No_Token_Index;
   List_Pos0 := Defer_Pos0;
   Lst_Cpos0 := List_Pos0;
   Diag_Mark0 := Parser.Last_Diag;
   Tmp_List0.Nodes.Append (Defer_Res0);
--  BEGIN <Token(<WithText Comma>, ) (root of 'args') at parser.lkt:504:29>
--  pos=Token_Pos0, res=Token_Res0, nobt=None
Token_Res0 := Lst_Cpos0;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res0));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos0 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Lst_Cpos0 then
          Parser.Last_Fail :=
            (Pos  => Lst_Cpos0,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Comma,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos0 := Lst_Cpos0 + 1;
   end if;
end;
--  END <Token(<WithText Comma>, ) (root of 'args') at parser.lkt:504:29>
      exit when Token_Pos0 = No_Token_Index;
      Lst_Cpos0 := Token_Pos0;
end loop;
Parser.Last_Diag := Diag_Mark0;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List0.Nodes.Length;
begin
   List_Res0 := Allocate_Argument_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos0 = Pos
                    then Pos
                    else List_Pos0 - 1);
   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res0,
      Kind              => Lkt_Argument_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res0,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List0.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res0.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List0);
--  END <List (root of 'args') at parser.lkt:504:13>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if List_Pos0 = No_Token_Index then
      Set_Failure
        (PP.Args_List_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Args_List_Parse0_Memo, Pos, List_Res0, Parser.Last_Diag, List_Pos0);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := List_Pos0;
   return List_Res0;
end Args_List_Parse0;
   function Argument_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Argument
is
      Row_Pos0 : Token_Index := No_Token_Index;
      Row_Pos1 : Token_Index := No_Token_Index;
      Defer_Pos1 : Token_Index := No_Token_Index;
      Defer_Res1 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Token_Pos1 : Token_Index := No_Token_Index;
      Token_Res1 : Token_Index := No_Token_Index;
      Diag_Mark1 : Diagnostic_Mark;
      Defer_Pos2 : Token_Index := No_Token_Index;
      Defer_Res2 : Bare_Expr := No_Bare_Lkt_Node;
      Transform_Res0 : Bare_Argument := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Argument_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res0 := M.Instance;
      return Transform_Res0;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res0;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType Argument>) (root of 'argument') at parser.lkt:503:17>
--  pos=Row_Pos0, res=Transform_Res0, nobt=None
--  BEGIN <_Row (root of 'argument') at parser.lkt:503:17>
--  pos=Row_Pos0, res=None, nobt=None
Row_Pos0 := Pos;
--  BEGIN <Opt (root of 'argument') at parser.lkt:503:26>
--  pos=Row_Pos1, res=Defer_Res1, nobt=None
Diag_Mark1 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'argument') at parser.lkt:503:27>
--  pos=Row_Pos1, res=Defer_Res1, nobt=None
--  BEGIN <_Row (root of 'argument') at parser.lkt:503:27>
--  pos=Row_Pos1, res=None, nobt=None
Row_Pos1 := Row_Pos0;
--  BEGIN <Defer (for 'ref_id') at parser.lkt:503:32>
--  pos=Defer_Pos1, res=Defer_Res1, nobt=None
Defer_Res1 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos1);
Defer_Pos1 := Parser.Current_Pos;
--  END <Defer (for 'ref_id') at parser.lkt:503:32>
if Defer_Pos1 /= No_Token_Index then
   Row_Pos1 := Defer_Pos1;
else
   Row_Pos1 := No_Token_Index;
   goto Exit_Row1_0;
end if;
--  BEGIN <Token(<WithText Equal>, ) (root of 'argument') at parser.lkt:503:39>
--  pos=Token_Pos1, res=Token_Res1, nobt=None
Token_Res1 := Row_Pos1;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res1));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Equal)
   then
       Token_Pos1 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos1 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos1,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Equal,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos1 := Row_Pos1 + 1;
   end if;
end;
--  END <Token(<WithText Equal>, ) (root of 'argument') at parser.lkt:503:39>
if Token_Pos1 /= No_Token_Index then
   Row_Pos1 := Token_Pos1;
else
   Row_Pos1 := No_Token_Index;
   goto Exit_Row1_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row1_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'argument') at parser.lkt:503:27>
--  END <_Extract (root of 'argument') at parser.lkt:503:27>
if Row_Pos1 = No_Token_Index then
   Defer_Res1 := No_Bare_Lkt_Node;
   Row_Pos1 := Row_Pos0;
      Parser.Last_Diag := Diag_Mark1;
end if;
--  END <Opt (root of 'argument') at parser.lkt:503:26>
if Row_Pos1 /= No_Token_Index then
   Row_Pos0 := Row_Pos1;
else
   Row_Pos0 := No_Token_Index;
   goto Exit_Row0_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:503:44>
--  pos=Defer_Pos2, res=Defer_Res2, nobt=None
Defer_Res2 :=
   Expr_Or_Parse0 (Parser, Row_Pos0);
Defer_Pos2 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:503:44>
if Defer_Pos2 /= No_Token_Index then
   Row_Pos0 := Defer_Pos2;
else
   Row_Pos0 := No_Token_Index;
   goto Exit_Row0_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row0_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'argument') at parser.lkt:503:17>
if Row_Pos0 /= No_Token_Index then
   Transform_Res0 := Allocate_Argument (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res0,
      Kind => Lkt_Argument,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos0 = Pos
                            then No_Token_Index
                            else Row_Pos0 - 1));
      Initialize_Fields_For_Argument
        (Self => Transform_Res0,
         Argument_F_Name => Defer_Res1,
         Argument_F_Value => Defer_Res2);
         if Defer_Res1 /= null and then Is_Incomplete (Defer_Res1) then
            Transform_Res0.Last_Attempted_Child := 0;
         elsif Defer_Res1 /= null and then not Is_Ghost (Defer_Res1) then
            Transform_Res0.Last_Attempted_Child := -1;
         end if;
         if Defer_Res2 /= null and then Is_Incomplete (Defer_Res2) then
            Transform_Res0.Last_Attempted_Child := 0;
         elsif Defer_Res2 /= null and then not Is_Ghost (Defer_Res2) then
            Transform_Res0.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType Argument>) (root of 'argument') at parser.lkt:503:17>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos0 = No_Token_Index then
      Set_Failure
        (PP.Argument_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Argument_Transform_Parse0_Memo, Pos, Transform_Res0, Parser.Last_Diag, Row_Pos0);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos0;
   return Transform_Res0;
end Argument_Transform_Parse0;
   function Arith_1_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
      Row_Pos2 : Token_Index := No_Token_Index;
      Defer_Pos3 : Token_Index := No_Token_Index;
      Defer_Res3 : Bare_Expr := No_Bare_Lkt_Node;
      Row_Pos3 : Token_Index := No_Token_Index;
      Token_Pos2 : Token_Index := No_Token_Index;
      Token_Res2 : Token_Index := No_Token_Index;
      Transform_Res1 : Bare_Op_Plus := No_Bare_Lkt_Node;
      Row_Pos4 : Token_Index := No_Token_Index;
      Token_Pos3 : Token_Index := No_Token_Index;
      Token_Res3 : Token_Index := No_Token_Index;
      Transform_Res2 : Bare_Op_Minus := No_Bare_Lkt_Node;
      Row_Pos5 : Token_Index := No_Token_Index;
      Token_Pos4 : Token_Index := No_Token_Index;
      Token_Res4 : Token_Index := No_Token_Index;
      Transform_Res3 : Bare_Op_Amp := No_Bare_Lkt_Node;
      Or_Pos0 : Token_Index := No_Token_Index;
      Or_Res0 : Bare_Op := No_Bare_Lkt_Node;
      Diag_Mark2 : Diagnostic_Mark;
      Last_Fail0 : Fail_Info;
      Branch_Diag_Mark0 : Diagnostic_Mark;
      Branch_Last_Fail0 : Fail_Info;
      Defer_Pos4 : Token_Index := No_Token_Index;
      Defer_Res4 : Bare_Expr := No_Bare_Lkt_Node;
      Transform_Res4 : Bare_Bin_Op := No_Bare_Lkt_Node;
      Defer_Pos5 : Token_Index := No_Token_Index;
      Defer_Res5 : Bare_Expr := No_Bare_Lkt_Node;
      Or_Pos1 : Token_Index := No_Token_Index;
      Or_Res1 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark3 : Diagnostic_Mark;
      Last_Fail1 : Fail_Info;
      Branch_Diag_Mark1 : Diagnostic_Mark;
      Branch_Last_Fail1 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
      Mem_Pos  : Token_Index := Pos;
      Mem_Res  : Bare_Expr := No_Bare_Lkt_Node;
      Mem_Mark : Diagnostic_Mark := Mark_On_Entry;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Arith_1_Or_Parse1_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res1 := M.Instance;
      return Or_Res1;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res1;
   end if;
   Parser.Last_Diag := No_Diagnostic;
       Set_Failure
         (PP.Arith_1_Or_Parse1_Memo,
          Pos,
          Parser.Last_Fail,
          Parser.Last_Diag);
       <<Try_Again>>
       Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'arith_1') at parser.lkt:393:16>
--  pos=Or_Pos1, res=Or_Res1, nobt=None
Or_Pos1 := No_Token_Index;
Or_Res1 := No_Bare_Lkt_Node;
Diag_Mark3 := Parser.Last_Diag;
Last_Fail1 := Parser.Last_Fail;
Branch_Diag_Mark1 := Parser.Last_Diag;
Branch_Last_Fail1 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark3;
    Parser.Last_Fail := Last_Fail1;
--  BEGIN <Transform(<ASTNodeType BinOp>) (root of 'arith_1') at parser.lkt:394:11>
--  pos=Row_Pos2, res=Transform_Res4, nobt=None
--  BEGIN <_Row (root of 'arith_1') at parser.lkt:394:11>
--  pos=Row_Pos2, res=None, nobt=None
Row_Pos2 := Pos;
--  BEGIN <Defer (for 'arith_1') at parser.lkt:394:17>
--  pos=Defer_Pos3, res=Defer_Res3, nobt=None
Defer_Res3 :=
   Arith_1_Or_Parse1 (Parser, Row_Pos2);
Defer_Pos3 := Parser.Current_Pos;
--  END <Defer (for 'arith_1') at parser.lkt:394:17>
if Defer_Pos3 /= No_Token_Index then
   Row_Pos2 := Defer_Pos3;
else
   Row_Pos2 := No_Token_Index;
   goto Exit_Row2_0;
end if;
--  BEGIN <Or (root of 'arith_1') at parser.lkt:394:25>
--  pos=Or_Pos0, res=Or_Res0, nobt=None
Or_Pos0 := No_Token_Index;
Or_Res0 := No_Bare_Lkt_Node;
Diag_Mark2 := Parser.Last_Diag;
Last_Fail0 := Parser.Last_Fail;
Branch_Diag_Mark0 := Parser.Last_Diag;
Branch_Last_Fail0 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark2;
    Parser.Last_Fail := Last_Fail0;
--  BEGIN <Transform(<ASTNodeType Op.Plus>) (root of 'arith_1') at parser.lkt:394:28>
--  pos=Row_Pos3, res=Transform_Res1, nobt=None
--  BEGIN <_Row (root of 'arith_1') at parser.lkt:394:28>
--  pos=Row_Pos3, res=None, nobt=None
Row_Pos3 := Row_Pos2;
--  BEGIN <Token(<WithText Plus>, ) (root of 'arith_1') at parser.lkt:394:36>
--  pos=Token_Pos2, res=Token_Res2, nobt=None
Token_Res2 := Row_Pos3;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res2));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Plus)
   then
       Token_Pos2 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos3 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos3,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Plus,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos2 := Row_Pos3 + 1;
   end if;
end;
--  END <Token(<WithText Plus>, ) (root of 'arith_1') at parser.lkt:394:36>
if Token_Pos2 /= No_Token_Index then
   Row_Pos3 := Token_Pos2;
else
   Row_Pos3 := No_Token_Index;
   goto Exit_Row3_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row3_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'arith_1') at parser.lkt:394:28>
if Row_Pos3 /= No_Token_Index then
   Transform_Res1 := Allocate_Op_Plus (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res1,
      Kind => Lkt_Op_Plus,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos2,
      Token_End_Index   => (if Row_Pos3 = Row_Pos2
                            then No_Token_Index
                            else Row_Pos3 - 1));
end if;
--  END <Transform(<ASTNodeType Op.Plus>) (root of 'arith_1') at parser.lkt:394:28>
    if Row_Pos3 /= No_Token_Index then
        Or_Pos0 := Row_Pos3;
        Or_Res0 := Transform_Res1;
        goto Exit_Or1;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail0.Pos then
       Branch_Diag_Mark0 := Parser.Last_Diag;
       Branch_Last_Fail0 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark2;
    Parser.Last_Fail := Last_Fail0;
--  BEGIN <Transform(<ASTNodeType Op.Minus>) (root of 'arith_1') at parser.lkt:394:43>
--  pos=Row_Pos4, res=Transform_Res2, nobt=None
--  BEGIN <_Row (root of 'arith_1') at parser.lkt:394:43>
--  pos=Row_Pos4, res=None, nobt=None
Row_Pos4 := Row_Pos2;
--  BEGIN <Token(<WithText Minus>, ) (root of 'arith_1') at parser.lkt:394:52>
--  pos=Token_Pos3, res=Token_Res3, nobt=None
Token_Res3 := Row_Pos4;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res3));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Minus)
   then
       Token_Pos3 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos4 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos4,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Minus,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos3 := Row_Pos4 + 1;
   end if;
end;
--  END <Token(<WithText Minus>, ) (root of 'arith_1') at parser.lkt:394:52>
if Token_Pos3 /= No_Token_Index then
   Row_Pos4 := Token_Pos3;
else
   Row_Pos4 := No_Token_Index;
   goto Exit_Row4_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row4_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'arith_1') at parser.lkt:394:43>
if Row_Pos4 /= No_Token_Index then
   Transform_Res2 := Allocate_Op_Minus (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res2,
      Kind => Lkt_Op_Minus,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos2,
      Token_End_Index   => (if Row_Pos4 = Row_Pos2
                            then No_Token_Index
                            else Row_Pos4 - 1));
end if;
--  END <Transform(<ASTNodeType Op.Minus>) (root of 'arith_1') at parser.lkt:394:43>
    if Row_Pos4 /= No_Token_Index then
        Or_Pos0 := Row_Pos4;
        Or_Res0 := Transform_Res2;
        goto Exit_Or1;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail0.Pos then
       Branch_Diag_Mark0 := Parser.Last_Diag;
       Branch_Last_Fail0 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark2;
    Parser.Last_Fail := Last_Fail0;
--  BEGIN <Transform(<ASTNodeType Op.Amp>) (root of 'arith_1') at parser.lkt:394:59>
--  pos=Row_Pos5, res=Transform_Res3, nobt=None
--  BEGIN <_Row (root of 'arith_1') at parser.lkt:394:59>
--  pos=Row_Pos5, res=None, nobt=None
Row_Pos5 := Row_Pos2;
--  BEGIN <Token(<WithText Amp>, ) (root of 'arith_1') at parser.lkt:394:66>
--  pos=Token_Pos4, res=Token_Res4, nobt=None
Token_Res4 := Row_Pos5;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res4));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Amp)
   then
       Token_Pos4 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos5 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos5,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Amp,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos4 := Row_Pos5 + 1;
   end if;
end;
--  END <Token(<WithText Amp>, ) (root of 'arith_1') at parser.lkt:394:66>
if Token_Pos4 /= No_Token_Index then
   Row_Pos5 := Token_Pos4;
else
   Row_Pos5 := No_Token_Index;
   goto Exit_Row5_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row5_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'arith_1') at parser.lkt:394:59>
if Row_Pos5 /= No_Token_Index then
   Transform_Res3 := Allocate_Op_Amp (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res3,
      Kind => Lkt_Op_Amp,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos2,
      Token_End_Index   => (if Row_Pos5 = Row_Pos2
                            then No_Token_Index
                            else Row_Pos5 - 1));
end if;
--  END <Transform(<ASTNodeType Op.Amp>) (root of 'arith_1') at parser.lkt:394:59>
    if Row_Pos5 /= No_Token_Index then
        Or_Pos0 := Row_Pos5;
        Or_Res0 := Transform_Res3;
        goto Exit_Or1;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail0.Pos then
       Branch_Diag_Mark0 := Parser.Last_Diag;
       Branch_Last_Fail0 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark0;
Parser.Last_Fail := Branch_Last_Fail0;
<<Exit_Or1>>
--  END <Or (root of 'arith_1') at parser.lkt:394:25>
if Or_Pos0 /= No_Token_Index then
   Row_Pos2 := Or_Pos0;
else
   Row_Pos2 := No_Token_Index;
   goto Exit_Row2_0;
end if;
--  BEGIN <Defer (for 'arith_2') at parser.lkt:394:72>
--  pos=Defer_Pos4, res=Defer_Res4, nobt=None
Defer_Res4 :=
   Arith_2_Or_Parse1 (Parser, Row_Pos2);
Defer_Pos4 := Parser.Current_Pos;
--  END <Defer (for 'arith_2') at parser.lkt:394:72>
if Defer_Pos4 /= No_Token_Index then
   Row_Pos2 := Defer_Pos4;
else
   Row_Pos2 := No_Token_Index;
   goto Exit_Row2_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row2_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'arith_1') at parser.lkt:394:11>
if Row_Pos2 /= No_Token_Index then
   Transform_Res4 := Allocate_Bin_Op (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res4,
      Kind => Lkt_Bin_Op,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos2 = Pos
                            then No_Token_Index
                            else Row_Pos2 - 1));
      Initialize_Fields_For_Bin_Op
        (Self => Transform_Res4,
         Bin_Op_F_Left => Defer_Res3,
         Bin_Op_F_Op => Or_Res0,
         Bin_Op_F_Right => Defer_Res4);
         if Defer_Res3 /= null and then Is_Incomplete (Defer_Res3) then
            Transform_Res4.Last_Attempted_Child := 0;
         elsif Defer_Res3 /= null and then not Is_Ghost (Defer_Res3) then
            Transform_Res4.Last_Attempted_Child := -1;
         end if;
         if Or_Res0 /= null and then Is_Incomplete (Or_Res0) then
            Transform_Res4.Last_Attempted_Child := 0;
         elsif Or_Res0 /= null and then not Is_Ghost (Or_Res0) then
            Transform_Res4.Last_Attempted_Child := -1;
         end if;
         if Defer_Res4 /= null and then Is_Incomplete (Defer_Res4) then
            Transform_Res4.Last_Attempted_Child := 0;
         elsif Defer_Res4 /= null and then not Is_Ghost (Defer_Res4) then
            Transform_Res4.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType BinOp>) (root of 'arith_1') at parser.lkt:394:11>
    if Row_Pos2 /= No_Token_Index then
        Or_Pos1 := Row_Pos2;
        Or_Res1 := Transform_Res4;
        goto Exit_Or0;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail1.Pos then
       Branch_Diag_Mark1 := Parser.Last_Diag;
       Branch_Last_Fail1 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark3;
    Parser.Last_Fail := Last_Fail1;
--  BEGIN <Defer (for 'arith_2') at parser.lkt:395:11>
--  pos=Defer_Pos5, res=Defer_Res5, nobt=None
Defer_Res5 :=
   Arith_2_Or_Parse1 (Parser, Pos);
Defer_Pos5 := Parser.Current_Pos;
--  END <Defer (for 'arith_2') at parser.lkt:395:11>
    if Defer_Pos5 /= No_Token_Index then
        Or_Pos1 := Defer_Pos5;
        Or_Res1 := Defer_Res5;
        goto Exit_Or0;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail1.Pos then
       Branch_Diag_Mark1 := Parser.Last_Diag;
       Branch_Last_Fail1 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark1;
Parser.Last_Fail := Branch_Last_Fail1;
<<Exit_Or0>>
--  END <Or (root of 'arith_1') at parser.lkt:393:16>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
      if Or_Pos1 > Mem_Pos then
         Mem_Pos := Or_Pos1;
         Mem_Res := Or_Res1;
         Mem_Mark := Parser.Last_Diag;
         if Or_Pos1 = No_Token_Index then
            Set_Failure (PP.Arith_1_Or_Parse1_Memo, Pos, Parser.Last_Fail, Mem_Mark);
         else
            Memos.Set_Success
              (PP.Arith_1_Or_Parse1_Memo,
               Pos,
               Or_Res1,
               Mem_Mark,
               Or_Pos1);
         end if;
         goto Try_Again;
      elsif Mem_Pos > Pos then
         Or_Res1 := Mem_Res;
         Or_Pos1 := Mem_Pos;
         Parser.Last_Diag := Mem_Mark;
         goto No_Memo;
      end if;
   if Or_Pos1 = No_Token_Index then
      Set_Failure
        (PP.Arith_1_Or_Parse1_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Arith_1_Or_Parse1_Memo, Pos, Or_Res1, Parser.Last_Diag, Or_Pos1);
   end if;
       <<No_Memo>>
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos1;
   return Or_Res1;
end Arith_1_Or_Parse1;
   function Arith_2_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
      Row_Pos6 : Token_Index := No_Token_Index;
      Defer_Pos6 : Token_Index := No_Token_Index;
      Defer_Res6 : Bare_Expr := No_Bare_Lkt_Node;
      Row_Pos7 : Token_Index := No_Token_Index;
      Token_Pos5 : Token_Index := No_Token_Index;
      Token_Res5 : Token_Index := No_Token_Index;
      Transform_Res5 : Bare_Op_Mult := No_Bare_Lkt_Node;
      Row_Pos8 : Token_Index := No_Token_Index;
      Token_Pos6 : Token_Index := No_Token_Index;
      Token_Res6 : Token_Index := No_Token_Index;
      Transform_Res6 : Bare_Op_Div := No_Bare_Lkt_Node;
      Or_Pos2 : Token_Index := No_Token_Index;
      Or_Res2 : Bare_Op := No_Bare_Lkt_Node;
      Diag_Mark4 : Diagnostic_Mark;
      Last_Fail2 : Fail_Info;
      Branch_Diag_Mark2 : Diagnostic_Mark;
      Branch_Last_Fail2 : Fail_Info;
      Defer_Pos7 : Token_Index := No_Token_Index;
      Defer_Res7 : Bare_Expr := No_Bare_Lkt_Node;
      Transform_Res7 : Bare_Bin_Op := No_Bare_Lkt_Node;
      Defer_Pos8 : Token_Index := No_Token_Index;
      Defer_Res8 : Bare_Expr := No_Bare_Lkt_Node;
      Or_Pos3 : Token_Index := No_Token_Index;
      Or_Res3 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark5 : Diagnostic_Mark;
      Last_Fail3 : Fail_Info;
      Branch_Diag_Mark3 : Diagnostic_Mark;
      Branch_Last_Fail3 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
      Mem_Pos  : Token_Index := Pos;
      Mem_Res  : Bare_Expr := No_Bare_Lkt_Node;
      Mem_Mark : Diagnostic_Mark := Mark_On_Entry;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Arith_2_Or_Parse1_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res3 := M.Instance;
      return Or_Res3;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res3;
   end if;
   Parser.Last_Diag := No_Diagnostic;
       Set_Failure
         (PP.Arith_2_Or_Parse1_Memo,
          Pos,
          Parser.Last_Fail,
          Parser.Last_Diag);
       <<Try_Again>>
       Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'arith_2') at parser.lkt:397:16>
--  pos=Or_Pos3, res=Or_Res3, nobt=None
Or_Pos3 := No_Token_Index;
Or_Res3 := No_Bare_Lkt_Node;
Diag_Mark5 := Parser.Last_Diag;
Last_Fail3 := Parser.Last_Fail;
Branch_Diag_Mark3 := Parser.Last_Diag;
Branch_Last_Fail3 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark5;
    Parser.Last_Fail := Last_Fail3;
--  BEGIN <Transform(<ASTNodeType BinOp>) (root of 'arith_2') at parser.lkt:398:11>
--  pos=Row_Pos6, res=Transform_Res7, nobt=None
--  BEGIN <_Row (root of 'arith_2') at parser.lkt:398:11>
--  pos=Row_Pos6, res=None, nobt=None
Row_Pos6 := Pos;
--  BEGIN <Defer (for 'arith_2') at parser.lkt:398:17>
--  pos=Defer_Pos6, res=Defer_Res6, nobt=None
Defer_Res6 :=
   Arith_2_Or_Parse1 (Parser, Row_Pos6);
Defer_Pos6 := Parser.Current_Pos;
--  END <Defer (for 'arith_2') at parser.lkt:398:17>
if Defer_Pos6 /= No_Token_Index then
   Row_Pos6 := Defer_Pos6;
else
   Row_Pos6 := No_Token_Index;
   goto Exit_Row6_0;
end if;
--  BEGIN <Or (root of 'arith_2') at parser.lkt:398:25>
--  pos=Or_Pos2, res=Or_Res2, nobt=None
Or_Pos2 := No_Token_Index;
Or_Res2 := No_Bare_Lkt_Node;
Diag_Mark4 := Parser.Last_Diag;
Last_Fail2 := Parser.Last_Fail;
Branch_Diag_Mark2 := Parser.Last_Diag;
Branch_Last_Fail2 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark4;
    Parser.Last_Fail := Last_Fail2;
--  BEGIN <Transform(<ASTNodeType Op.Mult>) (root of 'arith_2') at parser.lkt:398:28>
--  pos=Row_Pos7, res=Transform_Res5, nobt=None
--  BEGIN <_Row (root of 'arith_2') at parser.lkt:398:28>
--  pos=Row_Pos7, res=None, nobt=None
Row_Pos7 := Row_Pos6;
--  BEGIN <Token(<WithText Times>, ) (root of 'arith_2') at parser.lkt:398:36>
--  pos=Token_Pos5, res=Token_Res5, nobt=None
Token_Res5 := Row_Pos7;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res5));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Times)
   then
       Token_Pos5 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos7 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos7,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Times,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos5 := Row_Pos7 + 1;
   end if;
end;
--  END <Token(<WithText Times>, ) (root of 'arith_2') at parser.lkt:398:36>
if Token_Pos5 /= No_Token_Index then
   Row_Pos7 := Token_Pos5;
else
   Row_Pos7 := No_Token_Index;
   goto Exit_Row7_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row7_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'arith_2') at parser.lkt:398:28>
if Row_Pos7 /= No_Token_Index then
   Transform_Res5 := Allocate_Op_Mult (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res5,
      Kind => Lkt_Op_Mult,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos6,
      Token_End_Index   => (if Row_Pos7 = Row_Pos6
                            then No_Token_Index
                            else Row_Pos7 - 1));
end if;
--  END <Transform(<ASTNodeType Op.Mult>) (root of 'arith_2') at parser.lkt:398:28>
    if Row_Pos7 /= No_Token_Index then
        Or_Pos2 := Row_Pos7;
        Or_Res2 := Transform_Res5;
        goto Exit_Or3;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail2.Pos then
       Branch_Diag_Mark2 := Parser.Last_Diag;
       Branch_Last_Fail2 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark4;
    Parser.Last_Fail := Last_Fail2;
--  BEGIN <Transform(<ASTNodeType Op.Div>) (root of 'arith_2') at parser.lkt:398:43>
--  pos=Row_Pos8, res=Transform_Res6, nobt=None
--  BEGIN <_Row (root of 'arith_2') at parser.lkt:398:43>
--  pos=Row_Pos8, res=None, nobt=None
Row_Pos8 := Row_Pos6;
--  BEGIN <Token(<WithText Div>, ) (root of 'arith_2') at parser.lkt:398:50>
--  pos=Token_Pos6, res=Token_Res6, nobt=None
Token_Res6 := Row_Pos8;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res6));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Div)
   then
       Token_Pos6 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos8 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos8,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Div,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos6 := Row_Pos8 + 1;
   end if;
end;
--  END <Token(<WithText Div>, ) (root of 'arith_2') at parser.lkt:398:50>
if Token_Pos6 /= No_Token_Index then
   Row_Pos8 := Token_Pos6;
else
   Row_Pos8 := No_Token_Index;
   goto Exit_Row8_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row8_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'arith_2') at parser.lkt:398:43>
if Row_Pos8 /= No_Token_Index then
   Transform_Res6 := Allocate_Op_Div (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res6,
      Kind => Lkt_Op_Div,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos6,
      Token_End_Index   => (if Row_Pos8 = Row_Pos6
                            then No_Token_Index
                            else Row_Pos8 - 1));
end if;
--  END <Transform(<ASTNodeType Op.Div>) (root of 'arith_2') at parser.lkt:398:43>
    if Row_Pos8 /= No_Token_Index then
        Or_Pos2 := Row_Pos8;
        Or_Res2 := Transform_Res6;
        goto Exit_Or3;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail2.Pos then
       Branch_Diag_Mark2 := Parser.Last_Diag;
       Branch_Last_Fail2 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark2;
Parser.Last_Fail := Branch_Last_Fail2;
<<Exit_Or3>>
--  END <Or (root of 'arith_2') at parser.lkt:398:25>
if Or_Pos2 /= No_Token_Index then
   Row_Pos6 := Or_Pos2;
else
   Row_Pos6 := No_Token_Index;
   goto Exit_Row6_0;
end if;
--  BEGIN <Defer (for 'arith_3') at parser.lkt:398:56>
--  pos=Defer_Pos7, res=Defer_Res7, nobt=None
Defer_Res7 :=
   Arith_3_Or_Parse1 (Parser, Row_Pos6);
Defer_Pos7 := Parser.Current_Pos;
--  END <Defer (for 'arith_3') at parser.lkt:398:56>
if Defer_Pos7 /= No_Token_Index then
   Row_Pos6 := Defer_Pos7;
else
   Row_Pos6 := No_Token_Index;
   goto Exit_Row6_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row6_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'arith_2') at parser.lkt:398:11>
if Row_Pos6 /= No_Token_Index then
   Transform_Res7 := Allocate_Bin_Op (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res7,
      Kind => Lkt_Bin_Op,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos6 = Pos
                            then No_Token_Index
                            else Row_Pos6 - 1));
      Initialize_Fields_For_Bin_Op
        (Self => Transform_Res7,
         Bin_Op_F_Left => Defer_Res6,
         Bin_Op_F_Op => Or_Res2,
         Bin_Op_F_Right => Defer_Res7);
         if Defer_Res6 /= null and then Is_Incomplete (Defer_Res6) then
            Transform_Res7.Last_Attempted_Child := 0;
         elsif Defer_Res6 /= null and then not Is_Ghost (Defer_Res6) then
            Transform_Res7.Last_Attempted_Child := -1;
         end if;
         if Or_Res2 /= null and then Is_Incomplete (Or_Res2) then
            Transform_Res7.Last_Attempted_Child := 0;
         elsif Or_Res2 /= null and then not Is_Ghost (Or_Res2) then
            Transform_Res7.Last_Attempted_Child := -1;
         end if;
         if Defer_Res7 /= null and then Is_Incomplete (Defer_Res7) then
            Transform_Res7.Last_Attempted_Child := 0;
         elsif Defer_Res7 /= null and then not Is_Ghost (Defer_Res7) then
            Transform_Res7.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType BinOp>) (root of 'arith_2') at parser.lkt:398:11>
    if Row_Pos6 /= No_Token_Index then
        Or_Pos3 := Row_Pos6;
        Or_Res3 := Transform_Res7;
        goto Exit_Or2;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail3.Pos then
       Branch_Diag_Mark3 := Parser.Last_Diag;
       Branch_Last_Fail3 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark5;
    Parser.Last_Fail := Last_Fail3;
--  BEGIN <Defer (for 'arith_3') at parser.lkt:399:11>
--  pos=Defer_Pos8, res=Defer_Res8, nobt=None
Defer_Res8 :=
   Arith_3_Or_Parse1 (Parser, Pos);
Defer_Pos8 := Parser.Current_Pos;
--  END <Defer (for 'arith_3') at parser.lkt:399:11>
    if Defer_Pos8 /= No_Token_Index then
        Or_Pos3 := Defer_Pos8;
        Or_Res3 := Defer_Res8;
        goto Exit_Or2;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail3.Pos then
       Branch_Diag_Mark3 := Parser.Last_Diag;
       Branch_Last_Fail3 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark3;
Parser.Last_Fail := Branch_Last_Fail3;
<<Exit_Or2>>
--  END <Or (root of 'arith_2') at parser.lkt:397:16>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
      if Or_Pos3 > Mem_Pos then
         Mem_Pos := Or_Pos3;
         Mem_Res := Or_Res3;
         Mem_Mark := Parser.Last_Diag;
         if Or_Pos3 = No_Token_Index then
            Set_Failure (PP.Arith_2_Or_Parse1_Memo, Pos, Parser.Last_Fail, Mem_Mark);
         else
            Memos.Set_Success
              (PP.Arith_2_Or_Parse1_Memo,
               Pos,
               Or_Res3,
               Mem_Mark,
               Or_Pos3);
         end if;
         goto Try_Again;
      elsif Mem_Pos > Pos then
         Or_Res3 := Mem_Res;
         Or_Pos3 := Mem_Pos;
         Parser.Last_Diag := Mem_Mark;
         goto No_Memo;
      end if;
   if Or_Pos3 = No_Token_Index then
      Set_Failure
        (PP.Arith_2_Or_Parse1_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Arith_2_Or_Parse1_Memo, Pos, Or_Res3, Parser.Last_Diag, Or_Pos3);
   end if;
       <<No_Memo>>
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos3;
   return Or_Res3;
end Arith_2_Or_Parse1;
   function Arith_3_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
      Row_Pos9 : Token_Index := No_Token_Index;
      Row_Pos10 : Token_Index := No_Token_Index;
      Token_Pos7 : Token_Index := No_Token_Index;
      Token_Res7 : Token_Index := No_Token_Index;
      Transform_Res8 : Bare_Op_Plus := No_Bare_Lkt_Node;
      Row_Pos11 : Token_Index := No_Token_Index;
      Token_Pos8 : Token_Index := No_Token_Index;
      Token_Res8 : Token_Index := No_Token_Index;
      Transform_Res9 : Bare_Op_Minus := No_Bare_Lkt_Node;
      Or_Pos4 : Token_Index := No_Token_Index;
      Or_Res4 : Bare_Op := No_Bare_Lkt_Node;
      Diag_Mark6 : Diagnostic_Mark;
      Last_Fail4 : Fail_Info;
      Branch_Diag_Mark4 : Diagnostic_Mark;
      Branch_Last_Fail4 : Fail_Info;
      Defer_Pos9 : Token_Index := No_Token_Index;
      Defer_Res9 : Bare_Expr := No_Bare_Lkt_Node;
      Transform_Res10 : Bare_Un_Op := No_Bare_Lkt_Node;
      Defer_Pos10 : Token_Index := No_Token_Index;
      Defer_Res10 : Bare_Expr := No_Bare_Lkt_Node;
      Or_Pos5 : Token_Index := No_Token_Index;
      Or_Res5 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark7 : Diagnostic_Mark;
      Last_Fail5 : Fail_Info;
      Branch_Diag_Mark5 : Diagnostic_Mark;
      Branch_Last_Fail5 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Arith_3_Or_Parse1_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res5 := M.Instance;
      return Or_Res5;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res5;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'arith_3') at parser.lkt:401:16>
--  pos=Or_Pos5, res=Or_Res5, nobt=None
Or_Pos5 := No_Token_Index;
Or_Res5 := No_Bare_Lkt_Node;
Diag_Mark7 := Parser.Last_Diag;
Last_Fail5 := Parser.Last_Fail;
Branch_Diag_Mark5 := Parser.Last_Diag;
Branch_Last_Fail5 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark7;
    Parser.Last_Fail := Last_Fail5;
--  BEGIN <Transform(<ASTNodeType UnOp>) (root of 'arith_3') at parser.lkt:402:11>
--  pos=Row_Pos9, res=Transform_Res10, nobt=None
--  BEGIN <_Row (root of 'arith_3') at parser.lkt:402:11>
--  pos=Row_Pos9, res=None, nobt=None
Row_Pos9 := Pos;
--  BEGIN <Or (root of 'arith_3') at parser.lkt:402:16>
--  pos=Or_Pos4, res=Or_Res4, nobt=None
Or_Pos4 := No_Token_Index;
Or_Res4 := No_Bare_Lkt_Node;
Diag_Mark6 := Parser.Last_Diag;
Last_Fail4 := Parser.Last_Fail;
Branch_Diag_Mark4 := Parser.Last_Diag;
Branch_Last_Fail4 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark6;
    Parser.Last_Fail := Last_Fail4;
--  BEGIN <Transform(<ASTNodeType Op.Plus>) (root of 'arith_3') at parser.lkt:402:19>
--  pos=Row_Pos10, res=Transform_Res8, nobt=None
--  BEGIN <_Row (root of 'arith_3') at parser.lkt:402:19>
--  pos=Row_Pos10, res=None, nobt=None
Row_Pos10 := Row_Pos9;
--  BEGIN <Token(<WithText Plus>, ) (root of 'arith_3') at parser.lkt:402:27>
--  pos=Token_Pos7, res=Token_Res7, nobt=None
Token_Res7 := Row_Pos10;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res7));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Plus)
   then
       Token_Pos7 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos10 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos10,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Plus,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos7 := Row_Pos10 + 1;
   end if;
end;
--  END <Token(<WithText Plus>, ) (root of 'arith_3') at parser.lkt:402:27>
if Token_Pos7 /= No_Token_Index then
   Row_Pos10 := Token_Pos7;
else
   Row_Pos10 := No_Token_Index;
   goto Exit_Row10_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row10_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'arith_3') at parser.lkt:402:19>
if Row_Pos10 /= No_Token_Index then
   Transform_Res8 := Allocate_Op_Plus (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res8,
      Kind => Lkt_Op_Plus,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos9,
      Token_End_Index   => (if Row_Pos10 = Row_Pos9
                            then No_Token_Index
                            else Row_Pos10 - 1));
end if;
--  END <Transform(<ASTNodeType Op.Plus>) (root of 'arith_3') at parser.lkt:402:19>
    if Row_Pos10 /= No_Token_Index then
        Or_Pos4 := Row_Pos10;
        Or_Res4 := Transform_Res8;
        goto Exit_Or5;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail4.Pos then
       Branch_Diag_Mark4 := Parser.Last_Diag;
       Branch_Last_Fail4 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark6;
    Parser.Last_Fail := Last_Fail4;
--  BEGIN <Transform(<ASTNodeType Op.Minus>) (root of 'arith_3') at parser.lkt:402:34>
--  pos=Row_Pos11, res=Transform_Res9, nobt=None
--  BEGIN <_Row (root of 'arith_3') at parser.lkt:402:34>
--  pos=Row_Pos11, res=None, nobt=None
Row_Pos11 := Row_Pos9;
--  BEGIN <Token(<WithText Minus>, ) (root of 'arith_3') at parser.lkt:402:43>
--  pos=Token_Pos8, res=Token_Res8, nobt=None
Token_Res8 := Row_Pos11;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res8));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Minus)
   then
       Token_Pos8 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos11 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos11,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Minus,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos8 := Row_Pos11 + 1;
   end if;
end;
--  END <Token(<WithText Minus>, ) (root of 'arith_3') at parser.lkt:402:43>
if Token_Pos8 /= No_Token_Index then
   Row_Pos11 := Token_Pos8;
else
   Row_Pos11 := No_Token_Index;
   goto Exit_Row11_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row11_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'arith_3') at parser.lkt:402:34>
if Row_Pos11 /= No_Token_Index then
   Transform_Res9 := Allocate_Op_Minus (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res9,
      Kind => Lkt_Op_Minus,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos9,
      Token_End_Index   => (if Row_Pos11 = Row_Pos9
                            then No_Token_Index
                            else Row_Pos11 - 1));
end if;
--  END <Transform(<ASTNodeType Op.Minus>) (root of 'arith_3') at parser.lkt:402:34>
    if Row_Pos11 /= No_Token_Index then
        Or_Pos4 := Row_Pos11;
        Or_Res4 := Transform_Res9;
        goto Exit_Or5;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail4.Pos then
       Branch_Diag_Mark4 := Parser.Last_Diag;
       Branch_Last_Fail4 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark4;
Parser.Last_Fail := Branch_Last_Fail4;
<<Exit_Or5>>
--  END <Or (root of 'arith_3') at parser.lkt:402:16>
if Or_Pos4 /= No_Token_Index then
   Row_Pos9 := Or_Pos4;
else
   Row_Pos9 := No_Token_Index;
   goto Exit_Row9_0;
end if;
--  BEGIN <Defer (for 'isa_or_primary') at parser.lkt:402:49>
--  pos=Defer_Pos9, res=Defer_Res9, nobt=None
Defer_Res9 :=
   Isa_Or_Primary_Or_Parse0 (Parser, Row_Pos9);
Defer_Pos9 := Parser.Current_Pos;
--  END <Defer (for 'isa_or_primary') at parser.lkt:402:49>
if Defer_Pos9 /= No_Token_Index then
   Row_Pos9 := Defer_Pos9;
else
   Row_Pos9 := No_Token_Index;
   goto Exit_Row9_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row9_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'arith_3') at parser.lkt:402:11>
if Row_Pos9 /= No_Token_Index then
   Transform_Res10 := Allocate_Un_Op (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res10,
      Kind => Lkt_Un_Op,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos9 = Pos
                            then No_Token_Index
                            else Row_Pos9 - 1));
      Initialize_Fields_For_Un_Op
        (Self => Transform_Res10,
         Un_Op_F_Op => Or_Res4,
         Un_Op_F_Expr => Defer_Res9);
         if Or_Res4 /= null and then Is_Incomplete (Or_Res4) then
            Transform_Res10.Last_Attempted_Child := 0;
         elsif Or_Res4 /= null and then not Is_Ghost (Or_Res4) then
            Transform_Res10.Last_Attempted_Child := -1;
         end if;
         if Defer_Res9 /= null and then Is_Incomplete (Defer_Res9) then
            Transform_Res10.Last_Attempted_Child := 0;
         elsif Defer_Res9 /= null and then not Is_Ghost (Defer_Res9) then
            Transform_Res10.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType UnOp>) (root of 'arith_3') at parser.lkt:402:11>
    if Row_Pos9 /= No_Token_Index then
        Or_Pos5 := Row_Pos9;
        Or_Res5 := Transform_Res10;
        goto Exit_Or4;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail5.Pos then
       Branch_Diag_Mark5 := Parser.Last_Diag;
       Branch_Last_Fail5 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark7;
    Parser.Last_Fail := Last_Fail5;
--  BEGIN <Defer (for 'isa_or_primary') at parser.lkt:403:11>
--  pos=Defer_Pos10, res=Defer_Res10, nobt=None
Defer_Res10 :=
   Isa_Or_Primary_Or_Parse0 (Parser, Pos);
Defer_Pos10 := Parser.Current_Pos;
--  END <Defer (for 'isa_or_primary') at parser.lkt:403:11>
    if Defer_Pos10 /= No_Token_Index then
        Or_Pos5 := Defer_Pos10;
        Or_Res5 := Defer_Res10;
        goto Exit_Or4;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail5.Pos then
       Branch_Diag_Mark5 := Parser.Last_Diag;
       Branch_Last_Fail5 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark5;
Parser.Last_Fail := Branch_Last_Fail5;
<<Exit_Or4>>
--  END <Or (root of 'arith_3') at parser.lkt:401:16>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos5 = No_Token_Index then
      Set_Failure
        (PP.Arith_3_Or_Parse1_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Arith_3_Or_Parse1_Memo, Pos, Or_Res5, Parser.Last_Diag, Or_Pos5);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos5;
   return Or_Res5;
end Arith_3_Or_Parse1;
   function Array_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Array_Literal
is
      Nobt0 : Boolean := False;
      Nobt1 : Boolean := False;
      Row_Pos12 : Token_Index := No_Token_Index;
      Token_Pos9 : Token_Index := No_Token_Index;
      Token_Res9 : Token_Index := No_Token_Index;
      Lst_Cpos1 : Token_Index := No_Token_Index;
      Tmp_List1 : Free_Parse_List;
      Defer_Pos11 : Token_Index := No_Token_Index;
      Defer_Res11 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos10 : Token_Index := No_Token_Index;
      Token_Res10 : Token_Index := No_Token_Index;
      List_Pos1 : Token_Index := No_Token_Index;
      List_Res1 : Bare_Expr_List := No_Bare_Lkt_Node;
      Diag_Mark8 : Diagnostic_Mark;
      Token_Pos11 : Token_Index := No_Token_Index;
      Token_Res11 : Token_Index := No_Token_Index;
      Row_Pos13 : Token_Index := No_Token_Index;
      Token_Pos12 : Token_Index := No_Token_Index;
      Token_Res12 : Token_Index := No_Token_Index;
      Defer_Pos12 : Token_Index := No_Token_Index;
      Defer_Res12 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Diag_Mark9 : Diagnostic_Mark;
      Row_Progress0 : Integer := 0;
      Transform_Res11 : Bare_Array_Literal := No_Bare_Lkt_Node;
      Transform_Has_Failed0 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Array_Literal_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res11 := M.Instance;
      return Transform_Res11;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res11;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType ArrayLiteral>) (root of 'array_literal') at parser.lkt:451:22>
--  pos=Row_Pos12, res=Transform_Res11, nobt=Nobt0
--  BEGIN <_Row (root of 'array_literal') at parser.lkt:451:22>
--  pos=Row_Pos12, res=None, nobt=Nobt0
Row_Pos12 := Pos;
--  BEGIN <Token(<WithText LBrack>, ) (root of 'array_literal') at parser.lkt:452:9>
--  pos=Token_Pos9, res=Token_Res9, nobt=None
Token_Res9 := Row_Pos12;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res9));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos9 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos12 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos12,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos9 := Row_Pos12 + 1;
   end if;
end;
--  END <Token(<WithText LBrack>, ) (root of 'array_literal') at parser.lkt:452:9>
Row_Progress0 := 1;
if Token_Pos9 /= No_Token_Index then
   Row_Pos12 := Token_Pos9;
else
   Row_Pos12 := No_Token_Index;
   goto Exit_Row12_0;
end if;
--  BEGIN <Cut (root of 'array_literal') at parser.lkt:452:13>
--  pos=Row_Pos12, res=None, nobt=Nobt0
Nobt0 := True;
--  END <Cut (root of 'array_literal') at parser.lkt:452:13>
Row_Progress0 := 2;
if Row_Pos12 /= No_Token_Index then
   Row_Pos12 := Row_Pos12;
else
   Row_Pos12 := No_Token_Index;
   goto Exit_Row12_0;
end if;
--  BEGIN <List (root of 'array_literal') at parser.lkt:452:15>
--  pos=List_Pos1, res=List_Res1, nobt=None
    List_Pos1 := Row_Pos12;
Lst_Cpos1 := Row_Pos12;
Tmp_List1 := Get_Parse_List (Parser);
Diag_Mark8 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'expr') at parser.lkt:452:21>
--  pos=Defer_Pos11, res=Defer_Res11, nobt=None
Defer_Res11 :=
   Expr_Or_Parse0 (Parser, Lst_Cpos1);
Defer_Pos11 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:452:21>
   exit when Defer_Pos11 = No_Token_Index;
   List_Pos1 := Defer_Pos11;
   Lst_Cpos1 := List_Pos1;
   Diag_Mark8 := Parser.Last_Diag;
   Tmp_List1.Nodes.Append (Defer_Res11);
--  BEGIN <Token(<WithText Comma>, ) (root of 'array_literal') at parser.lkt:452:27>
--  pos=Token_Pos10, res=Token_Res10, nobt=None
Token_Res10 := Lst_Cpos1;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res10));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos10 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Lst_Cpos1 then
          Parser.Last_Fail :=
            (Pos  => Lst_Cpos1,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Comma,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos10 := Lst_Cpos1 + 1;
   end if;
end;
--  END <Token(<WithText Comma>, ) (root of 'array_literal') at parser.lkt:452:27>
      exit when Token_Pos10 = No_Token_Index;
      Lst_Cpos1 := Token_Pos10;
end loop;
Parser.Last_Diag := Diag_Mark8;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List1.Nodes.Length;
begin
   List_Res1 := Allocate_Expr_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos12;
      Token_End := (if Lst_Cpos1 = Row_Pos12
                    then Row_Pos12
                    else List_Pos1 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos12, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res1,
      Kind              => Lkt_Expr_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res1,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List1.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res1.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List1);
--  END <List (root of 'array_literal') at parser.lkt:452:15>
Row_Progress0 := 3;
if List_Pos1 /= No_Token_Index then
   Row_Pos12 := List_Pos1;
else
   Row_Pos12 := No_Token_Index;
   goto Exit_Row12_0;
end if;
--  BEGIN <Token(<WithText RBrack>, ) (root of 'array_literal') at parser.lkt:452:32>
--  pos=Token_Pos11, res=Token_Res11, nobt=None
Token_Res11 := Row_Pos12;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res11));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos11 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos12 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos12,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos11 := Row_Pos12 + 1;
   end if;
end;
--  END <Token(<WithText RBrack>, ) (root of 'array_literal') at parser.lkt:452:32>
Row_Progress0 := 4;
if Token_Pos11 /= No_Token_Index then
   Row_Pos12 := Token_Pos11;
else
   Row_Pos12 := No_Token_Index;
   goto Exit_Row12_0;
end if;
--  BEGIN <Opt (root of 'array_literal') at parser.lkt:452:36>
--  pos=Row_Pos13, res=Defer_Res12, nobt=Nobt1
Diag_Mark9 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'array_literal') at parser.lkt:452:37>
--  pos=Row_Pos13, res=Defer_Res12, nobt=Nobt1
--  BEGIN <_Row (root of 'array_literal') at parser.lkt:452:37>
--  pos=Row_Pos13, res=None, nobt=Nobt1
Row_Pos13 := Row_Pos12;
--  BEGIN <Token(<WithText Colon>, ) (root of 'array_literal') at parser.lkt:452:42>
--  pos=Token_Pos12, res=Token_Res12, nobt=None
Token_Res12 := Row_Pos13;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res12));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos12 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos13 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos13,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Colon,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos12 := Row_Pos13 + 1;
   end if;
end;
--  END <Token(<WithText Colon>, ) (root of 'array_literal') at parser.lkt:452:42>
if Token_Pos12 /= No_Token_Index then
   Row_Pos13 := Token_Pos12;
else
   Row_Pos13 := No_Token_Index;
   goto Exit_Row13_0;
end if;
--  BEGIN <Cut (root of 'array_literal') at parser.lkt:452:46>
--  pos=Row_Pos13, res=None, nobt=Nobt1
Nobt1 := True;
--  END <Cut (root of 'array_literal') at parser.lkt:452:46>
if Row_Pos13 /= No_Token_Index then
   Row_Pos13 := Row_Pos13;
else
   Row_Pos13 := No_Token_Index;
   goto Exit_Row13_0;
end if;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:452:48>
--  pos=Defer_Pos12, res=Defer_Res12, nobt=None
Defer_Res12 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos13);
Defer_Pos12 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:452:48>
if Defer_Pos12 /= No_Token_Index then
   Row_Pos13 := Defer_Pos12;
else
   Row_Pos13 := No_Token_Index;
   goto Exit_Row13_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row13_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'array_literal') at parser.lkt:452:37>
--  END <_Extract (root of 'array_literal') at parser.lkt:452:37>
if Row_Pos13 = No_Token_Index then
   if Nobt1 then
      Row_Pos13 := Parser.Last_Fail.Pos;
      Append (Parser, Row_Pos13, "Cannot parse <array_literal>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
         if not Nobt1 then
   Defer_Res12 := No_Bare_Lkt_Node;
         end if;
       if not Nobt1 then
   Row_Pos13 := Row_Pos12;
      Parser.Last_Diag := Diag_Mark9;
       end if;
end if;
--  END <Opt (root of 'array_literal') at parser.lkt:452:36>
   Nobt0 := Nobt1;
Row_Progress0 := 5;
if Row_Pos13 /= No_Token_Index then
   Row_Pos12 := Row_Pos13;
else
   Row_Pos12 := No_Token_Index;
   goto Exit_Row12_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row12_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'array_literal') at parser.lkt:451:22>
if Row_Pos12 = No_Token_Index and then Nobt0 then
   Row_Pos12 := Parser.Last_Fail.Pos;
   Transform_Has_Failed0 := True;
end if;
if Row_Pos12 /= No_Token_Index then
   Transform_Res11 := Allocate_Array_Literal (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res11,
      Kind => Lkt_Array_Literal,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos12 = Pos
                            then No_Token_Index
                            else Row_Pos12 - 1));
      Initialize_Fields_For_Array_Literal
        (Self => Transform_Res11,
         Array_Literal_F_Exprs => List_Res1,
         Array_Literal_F_Element_Type => Defer_Res12);
         if List_Res1 /= null and then Is_Incomplete (List_Res1) then
            Transform_Res11.Last_Attempted_Child := 0;
         elsif List_Res1 /= null and then not Is_Ghost (List_Res1) then
            Transform_Res11.Last_Attempted_Child := -1;
         end if;
         if Defer_Res12 /= null and then Is_Incomplete (Defer_Res12) then
            Transform_Res11.Last_Attempted_Child := 0;
         elsif Defer_Res12 /= null and then not Is_Ghost (Defer_Res12) then
            Transform_Res11.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed0 then
      Transform_Res11.Last_Attempted_Child :=
         Row_Progress0;
      Append (Parser, Pos, "Cannot parse <array_literal>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType ArrayLiteral>) (root of 'array_literal') at parser.lkt:451:22>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos12 = No_Token_Index then
      Set_Failure
        (PP.Array_Literal_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Array_Literal_Transform_Parse0_Memo, Pos, Transform_Res11, Parser.Last_Diag, Row_Pos12);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos12;
   return Transform_Res11;
end Array_Literal_Transform_Parse0;
   function Bare_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decl
is
      Defer_Pos13 : Token_Index := No_Token_Index;
      Defer_Res13 : Bare_Generic_Decl := No_Bare_Lkt_Node;
      Defer_Pos14 : Token_Index := No_Token_Index;
      Defer_Res14 : Bare_Named_Type_Decl := No_Bare_Lkt_Node;
      Defer_Pos15 : Token_Index := No_Token_Index;
      Defer_Res15 : Bare_Fun_Decl := No_Bare_Lkt_Node;
      Defer_Pos16 : Token_Index := No_Token_Index;
      Defer_Res16 : Bare_Lexer_Decl := No_Bare_Lkt_Node;
      Defer_Pos17 : Token_Index := No_Token_Index;
      Defer_Res17 : Bare_Grammar_Decl := No_Bare_Lkt_Node;
      Defer_Pos18 : Token_Index := No_Token_Index;
      Defer_Res18 : Bare_Field_Decl := No_Bare_Lkt_Node;
      Defer_Pos19 : Token_Index := No_Token_Index;
      Defer_Res19 : Bare_Val_Decl := No_Bare_Lkt_Node;
      Defer_Pos20 : Token_Index := No_Token_Index;
      Defer_Res20 : Bare_Env_Spec_Decl := No_Bare_Lkt_Node;
      Defer_Pos21 : Token_Index := No_Token_Index;
      Defer_Res21 : Bare_Lexer_Family_Decl := No_Bare_Lkt_Node;
      Defer_Pos22 : Token_Index := No_Token_Index;
      Defer_Res22 : Bare_Grammar_Rule_Decl := No_Bare_Lkt_Node;
      Defer_Pos23 : Token_Index := No_Token_Index;
      Defer_Res23 : Bare_Dyn_Var_Decl := No_Bare_Lkt_Node;
      Row_Pos14 : Token_Index := No_Token_Index;
      Transform_Res12 : Bare_Error_Decl := No_Bare_Lkt_Node;
      Skip_Pos0 : Token_Index := No_Token_Index;
      Skip_Dummy0 : Bare_Lkt_Node := No_Bare_Lkt_Node;
      Or_Pos6 : Token_Index := No_Token_Index;
      Or_Res6 : Bare_Decl := No_Bare_Lkt_Node;
      Diag_Mark10 : Diagnostic_Mark;
      Last_Fail6 : Fail_Info;
      Branch_Diag_Mark6 : Diagnostic_Mark;
      Branch_Last_Fail6 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Bare_Decl_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res6 := M.Instance;
      return Or_Res6;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res6;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'bare_decl') at parser.lkt:259:18>
--  pos=Or_Pos6, res=Or_Res6, nobt=None
Or_Pos6 := No_Token_Index;
Or_Res6 := No_Bare_Lkt_Node;
Diag_Mark10 := Parser.Last_Diag;
Last_Fail6 := Parser.Last_Fail;
Branch_Diag_Mark6 := Parser.Last_Diag;
Branch_Last_Fail6 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark10;
    Parser.Last_Fail := Last_Fail6;
--  BEGIN <Defer (for 'generic_decl') at parser.lkt:260:11>
--  pos=Defer_Pos13, res=Defer_Res13, nobt=None
Defer_Res13 :=
   Generic_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos13 := Parser.Current_Pos;
--  END <Defer (for 'generic_decl') at parser.lkt:260:11>
    if Defer_Pos13 /= No_Token_Index then
        Or_Pos6 := Defer_Pos13;
        Or_Res6 := Defer_Res13;
        goto Exit_Or6;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail6.Pos then
       Branch_Diag_Mark6 := Parser.Last_Diag;
       Branch_Last_Fail6 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark10;
    Parser.Last_Fail := Last_Fail6;
--  BEGIN <Defer (for 'type_decl') at parser.lkt:261:11>
--  pos=Defer_Pos14, res=Defer_Res14, nobt=None
Defer_Res14 :=
   Type_Decl_Or_Parse0 (Parser, Pos);
Defer_Pos14 := Parser.Current_Pos;
--  END <Defer (for 'type_decl') at parser.lkt:261:11>
    if Defer_Pos14 /= No_Token_Index then
        Or_Pos6 := Defer_Pos14;
        Or_Res6 := Defer_Res14;
        goto Exit_Or6;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail6.Pos then
       Branch_Diag_Mark6 := Parser.Last_Diag;
       Branch_Last_Fail6 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark10;
    Parser.Last_Fail := Last_Fail6;
--  BEGIN <Defer (for 'fun_decl') at parser.lkt:262:11>
--  pos=Defer_Pos15, res=Defer_Res15, nobt=None
Defer_Res15 :=
   Fun_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos15 := Parser.Current_Pos;
--  END <Defer (for 'fun_decl') at parser.lkt:262:11>
    if Defer_Pos15 /= No_Token_Index then
        Or_Pos6 := Defer_Pos15;
        Or_Res6 := Defer_Res15;
        goto Exit_Or6;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail6.Pos then
       Branch_Diag_Mark6 := Parser.Last_Diag;
       Branch_Last_Fail6 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark10;
    Parser.Last_Fail := Last_Fail6;
--  BEGIN <Defer (for 'lexer_decl') at parser.lkt:263:11>
--  pos=Defer_Pos16, res=Defer_Res16, nobt=None
Defer_Res16 :=
   Lexer_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos16 := Parser.Current_Pos;
--  END <Defer (for 'lexer_decl') at parser.lkt:263:11>
    if Defer_Pos16 /= No_Token_Index then
        Or_Pos6 := Defer_Pos16;
        Or_Res6 := Defer_Res16;
        goto Exit_Or6;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail6.Pos then
       Branch_Diag_Mark6 := Parser.Last_Diag;
       Branch_Last_Fail6 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark10;
    Parser.Last_Fail := Last_Fail6;
--  BEGIN <Defer (for 'grammar_decl') at parser.lkt:264:11>
--  pos=Defer_Pos17, res=Defer_Res17, nobt=None
Defer_Res17 :=
   Grammar_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos17 := Parser.Current_Pos;
--  END <Defer (for 'grammar_decl') at parser.lkt:264:11>
    if Defer_Pos17 /= No_Token_Index then
        Or_Pos6 := Defer_Pos17;
        Or_Res6 := Defer_Res17;
        goto Exit_Or6;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail6.Pos then
       Branch_Diag_Mark6 := Parser.Last_Diag;
       Branch_Last_Fail6 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark10;
    Parser.Last_Fail := Last_Fail6;
--  BEGIN <Defer (for 'field_decl') at parser.lkt:265:11>
--  pos=Defer_Pos18, res=Defer_Res18, nobt=None
Defer_Res18 :=
   Field_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos18 := Parser.Current_Pos;
--  END <Defer (for 'field_decl') at parser.lkt:265:11>
    if Defer_Pos18 /= No_Token_Index then
        Or_Pos6 := Defer_Pos18;
        Or_Res6 := Defer_Res18;
        goto Exit_Or6;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail6.Pos then
       Branch_Diag_Mark6 := Parser.Last_Diag;
       Branch_Last_Fail6 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark10;
    Parser.Last_Fail := Last_Fail6;
--  BEGIN <Defer (for 'val_decl') at parser.lkt:266:11>
--  pos=Defer_Pos19, res=Defer_Res19, nobt=None
Defer_Res19 :=
   Val_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos19 := Parser.Current_Pos;
--  END <Defer (for 'val_decl') at parser.lkt:266:11>
    if Defer_Pos19 /= No_Token_Index then
        Or_Pos6 := Defer_Pos19;
        Or_Res6 := Defer_Res19;
        goto Exit_Or6;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail6.Pos then
       Branch_Diag_Mark6 := Parser.Last_Diag;
       Branch_Last_Fail6 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark10;
    Parser.Last_Fail := Last_Fail6;
--  BEGIN <Defer (for 'env_spec_decl') at parser.lkt:267:11>
--  pos=Defer_Pos20, res=Defer_Res20, nobt=None
Defer_Res20 :=
   Env_Spec_Decl_Transform_Parse1 (Parser, Pos);
Defer_Pos20 := Parser.Current_Pos;
--  END <Defer (for 'env_spec_decl') at parser.lkt:267:11>
    if Defer_Pos20 /= No_Token_Index then
        Or_Pos6 := Defer_Pos20;
        Or_Res6 := Defer_Res20;
        goto Exit_Or6;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail6.Pos then
       Branch_Diag_Mark6 := Parser.Last_Diag;
       Branch_Last_Fail6 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark10;
    Parser.Last_Fail := Last_Fail6;
--  BEGIN <Defer (for 'lexer_family_decl') at parser.lkt:268:11>
--  pos=Defer_Pos21, res=Defer_Res21, nobt=None
Defer_Res21 :=
   Lexer_Family_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos21 := Parser.Current_Pos;
--  END <Defer (for 'lexer_family_decl') at parser.lkt:268:11>
    if Defer_Pos21 /= No_Token_Index then
        Or_Pos6 := Defer_Pos21;
        Or_Res6 := Defer_Res21;
        goto Exit_Or6;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail6.Pos then
       Branch_Diag_Mark6 := Parser.Last_Diag;
       Branch_Last_Fail6 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark10;
    Parser.Last_Fail := Last_Fail6;
--  BEGIN <Defer (for 'grammar_rule') at parser.lkt:269:11>
--  pos=Defer_Pos22, res=Defer_Res22, nobt=None
Defer_Res22 :=
   Grammar_Rule_Transform_Parse0 (Parser, Pos);
Defer_Pos22 := Parser.Current_Pos;
--  END <Defer (for 'grammar_rule') at parser.lkt:269:11>
    if Defer_Pos22 /= No_Token_Index then
        Or_Pos6 := Defer_Pos22;
        Or_Res6 := Defer_Res22;
        goto Exit_Or6;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail6.Pos then
       Branch_Diag_Mark6 := Parser.Last_Diag;
       Branch_Last_Fail6 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark10;
    Parser.Last_Fail := Last_Fail6;
--  BEGIN <Defer (for 'dynvar_decl') at parser.lkt:270:11>
--  pos=Defer_Pos23, res=Defer_Res23, nobt=None
Defer_Res23 :=
   Dynvar_Decl_Transform_Parse0 (Parser, Pos);
Defer_Pos23 := Parser.Current_Pos;
--  END <Defer (for 'dynvar_decl') at parser.lkt:270:11>
    if Defer_Pos23 /= No_Token_Index then
        Or_Pos6 := Defer_Pos23;
        Or_Res6 := Defer_Res23;
        goto Exit_Or6;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail6.Pos then
       Branch_Diag_Mark6 := Parser.Last_Diag;
       Branch_Last_Fail6 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark10;
    Parser.Last_Fail := Last_Fail6;
--  BEGIN <Skip (root of 'bare_decl') at parser.lkt:271:11>
--  pos=Skip_Pos0, res=Transform_Res12, nobt=None
if Get_Token (Parser.TDH.all, Pos).Kind
   = From_Token_Kind (Lkt_Termination)
then
   Skip_Pos0 := No_Token_Index;
   goto Exit_Or7;
end if;
for Fn of PP.Dont_Skip loop
   Skip_Dummy0 := Fn (Parser, Pos);
   if Parser.Current_Pos /= No_Token_Index  then
      Skip_Pos0 := No_Token_Index;
      goto Exit_Or7;
   end if;
end loop;
Skip_Pos0 := Pos + 1;
--  BEGIN <Transform(<ASTNodeType ErrorDecl>) (root of 'bare_decl') at parser.lkt:271:11>
--  pos=Row_Pos14, res=Transform_Res12, nobt=None
--  BEGIN <_Row (root of 'bare_decl') at parser.lkt:271:11>
--  pos=Row_Pos14, res=None, nobt=None
Row_Pos14 := Pos;
pragma Warnings (Off, "referenced");
<<Exit_Row14_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'bare_decl') at parser.lkt:271:11>
if Row_Pos14 /= No_Token_Index then
   Transform_Res12 := Allocate_Error_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res12,
      Kind => Lkt_Error_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos14 = Pos
                            then No_Token_Index
                            else Row_Pos14 - 1));
end if;
--  END <Transform(<ASTNodeType ErrorDecl>) (root of 'bare_decl') at parser.lkt:271:11>
Transform_Res12.Token_End_Index := Pos;
declare
   Tok      : constant Token_Reference :=
     Wrap_Token_Reference
      (Parser.Unit.Context,
       Parser.TDH,
       (Pos, No_Token_Index));
   Tok_Text : constant Text_Type := Common.Text (Tok);
begin
   Append (Parser, Pos, "Skipped token " & Image (Tok_Text));
end;
<<Exit_Or7>>
--  END <Skip (root of 'bare_decl') at parser.lkt:271:11>
    if Skip_Pos0 /= No_Token_Index then
        Or_Pos6 := Skip_Pos0;
        Or_Res6 := Transform_Res12;
        goto Exit_Or6;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail6.Pos then
       Branch_Diag_Mark6 := Parser.Last_Diag;
       Branch_Last_Fail6 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark6;
Parser.Last_Fail := Branch_Last_Fail6;
<<Exit_Or6>>
--  END <Or (root of 'bare_decl') at parser.lkt:259:18>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos6 = No_Token_Index then
      Set_Failure
        (PP.Bare_Decl_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Bare_Decl_Or_Parse0_Memo, Pos, Or_Res6, Parser.Last_Diag, Or_Pos6);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos6;
   return Or_Res6;
end Bare_Decl_Or_Parse0;
   function Basic_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
      Nobt2 : Boolean := False;
      Nobt3 : Boolean := False;
      Nobt4 : Boolean := False;
      Nobt5 : Boolean := False;
      Nobt6 : Boolean := False;
      Nobt7 : Boolean := False;
      Nobt8 : Boolean := False;
      Row_Pos15 : Token_Index := No_Token_Index;
      Defer_Pos24 : Token_Index := No_Token_Index;
      Defer_Res24 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos13 : Token_Index := No_Token_Index;
      Token_Res13 : Token_Index := No_Token_Index;
      Defer_Pos25 : Token_Index := No_Token_Index;
      Defer_Res25 : Bare_Argument_List := No_Bare_Lkt_Node;
      Token_Pos14 : Token_Index := No_Token_Index;
      Token_Res14 : Token_Index := No_Token_Index;
      Row_Progress1 : Integer := 0;
      Transform_Res13 : Bare_Call_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed1 : Boolean := False;
      Row_Pos16 : Token_Index := No_Token_Index;
      Defer_Pos26 : Token_Index := No_Token_Index;
      Defer_Res26 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos15 : Token_Index := No_Token_Index;
      Token_Res15 : Token_Index := No_Token_Index;
      Defer_Pos27 : Token_Index := No_Token_Index;
      Defer_Res27 : Bare_Type_Ref_List := No_Bare_Lkt_Node;
      Token_Pos16 : Token_Index := No_Token_Index;
      Token_Res16 : Token_Index := No_Token_Index;
      Transform_Res14 : Bare_Generic_Instantiation := No_Bare_Lkt_Node;
      Row_Pos17 : Token_Index := No_Token_Index;
      Defer_Pos28 : Token_Index := No_Token_Index;
      Defer_Res28 : Bare_Expr := No_Bare_Lkt_Node;
      Defer_Pos29 : Token_Index := No_Token_Index;
      Defer_Res29 : Bare_Null_Cond_Qualifier := No_Bare_Lkt_Node;
      Token_Pos17 : Token_Index := No_Token_Index;
      Token_Res17 : Token_Index := No_Token_Index;
      Defer_Pos30 : Token_Index := No_Token_Index;
      Defer_Res30 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos18 : Token_Index := No_Token_Index;
      Token_Res18 : Token_Index := No_Token_Index;
      Row_Progress2 : Integer := 0;
      Transform_Res15 : Bare_Subscript_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed2 : Boolean := False;
      Row_Pos18 : Token_Index := No_Token_Index;
      Defer_Pos31 : Token_Index := No_Token_Index;
      Defer_Res31 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos19 : Token_Index := No_Token_Index;
      Token_Res19 : Token_Index := No_Token_Index;
      Transform_Res16 : Bare_Error_On_Null := No_Bare_Lkt_Node;
      Row_Pos19 : Token_Index := No_Token_Index;
      Defer_Pos32 : Token_Index := No_Token_Index;
      Defer_Res32 : Bare_Expr := No_Bare_Lkt_Node;
      Defer_Pos33 : Token_Index := No_Token_Index;
      Defer_Res33 : Bare_Null_Cond_Qualifier := No_Bare_Lkt_Node;
      Token_Pos20 : Token_Index := No_Token_Index;
      Token_Res20 : Token_Index := No_Token_Index;
      Token_Pos21 : Token_Index := No_Token_Index;
      Token_Res21 : Token_Index := No_Token_Index;
      Token_Pos22 : Token_Index := No_Token_Index;
      Token_Res22 : Token_Index := No_Token_Index;
      Defer_Pos34 : Token_Index := No_Token_Index;
      Defer_Res34 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Token_Pos23 : Token_Index := No_Token_Index;
      Token_Res23 : Token_Index := No_Token_Index;
      Transform_Res17 : Bare_Keep_Expr := No_Bare_Lkt_Node;
      Row_Pos20 : Token_Index := No_Token_Index;
      Defer_Pos35 : Token_Index := No_Token_Index;
      Defer_Res35 : Bare_Expr := No_Bare_Lkt_Node;
      Defer_Pos36 : Token_Index := No_Token_Index;
      Defer_Res36 : Bare_Null_Cond_Qualifier := No_Bare_Lkt_Node;
      Token_Pos24 : Token_Index := No_Token_Index;
      Token_Res24 : Token_Index := No_Token_Index;
      Token_Pos25 : Token_Index := No_Token_Index;
      Token_Res25 : Token_Index := No_Token_Index;
      Token_Pos26 : Token_Index := No_Token_Index;
      Token_Res26 : Token_Index := No_Token_Index;
      Opt_Res0 : Bare_Excludes_Null := No_Bare_Lkt_Node;
      Diag_Mark11 : Diagnostic_Mark;
      Token_Pos27 : Token_Index := No_Token_Index;
      Token_Res27 : Token_Index := No_Token_Index;
      Defer_Pos37 : Token_Index := No_Token_Index;
      Defer_Res37 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Token_Pos28 : Token_Index := No_Token_Index;
      Token_Res28 : Token_Index := No_Token_Index;
      Row_Progress3 : Integer := 0;
      Transform_Res18 : Bare_Cast_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed3 : Boolean := False;
      Row_Pos21 : Token_Index := No_Token_Index;
      Defer_Pos38 : Token_Index := No_Token_Index;
      Defer_Res38 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos29 : Token_Index := No_Token_Index;
      Token_Res29 : Token_Index := No_Token_Index;
      Token_Pos30 : Token_Index := No_Token_Index;
      Token_Res30 : Token_Index := No_Token_Index;
      Defer_Pos39 : Token_Index := No_Token_Index;
      Defer_Res39 : Bare_Argument_List := No_Bare_Lkt_Node;
      Token_Pos31 : Token_Index := No_Token_Index;
      Token_Res31 : Token_Index := No_Token_Index;
      Row_Progress4 : Integer := 0;
      Transform_Res19 : Bare_Logic_Predicate := No_Bare_Lkt_Node;
      Transform_Has_Failed4 : Boolean := False;
      Row_Pos22 : Token_Index := No_Token_Index;
      Defer_Pos40 : Token_Index := No_Token_Index;
      Defer_Res40 : Bare_Expr := No_Bare_Lkt_Node;
      Defer_Pos41 : Token_Index := No_Token_Index;
      Defer_Res41 : Bare_Null_Cond_Qualifier := No_Bare_Lkt_Node;
      Token_Pos32 : Token_Index := No_Token_Index;
      Token_Res32 : Token_Index := No_Token_Index;
      Defer_Pos42 : Token_Index := No_Token_Index;
      Defer_Res42 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Row_Progress5 : Integer := 0;
      Transform_Res20 : Bare_Dot_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed5 : Boolean := False;
      Row_Pos23 : Token_Index := No_Token_Index;
      Token_Pos33 : Token_Index := No_Token_Index;
      Token_Res33 : Token_Index := No_Token_Index;
      Row_Pos24 : Token_Index := No_Token_Index;
      Defer_Pos43 : Token_Index := No_Token_Index;
      Defer_Res43 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Token_Pos34 : Token_Index := No_Token_Index;
      Token_Res34 : Token_Index := No_Token_Index;
      Defer_Pos44 : Token_Index := No_Token_Index;
      Defer_Res44 : Bare_Argument_List := No_Bare_Lkt_Node;
      Token_Pos35 : Token_Index := No_Token_Index;
      Token_Res35 : Token_Index := No_Token_Index;
      Row_Progress6 : Integer := 0;
      Transform_Res21 : Bare_Call_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed6 : Boolean := False;
      Row_Progress7 : Integer := 0;
      Transform_Res22 : Bare_Logic_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed7 : Boolean := False;
      Row_Pos25 : Token_Index := No_Token_Index;
      Token_Pos36 : Token_Index := No_Token_Index;
      Token_Res36 : Token_Index := No_Token_Index;
      Defer_Pos45 : Token_Index := No_Token_Index;
      Defer_Res45 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Row_Progress8 : Integer := 0;
      Transform_Res23 : Bare_Logic_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed8 : Boolean := False;
      Defer_Pos46 : Token_Index := No_Token_Index;
      Defer_Res46 : Bare_Expr := No_Bare_Lkt_Node;
      Or_Pos7 : Token_Index := No_Token_Index;
      Or_Res7 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark12 : Diagnostic_Mark;
      Last_Fail7 : Fail_Info;
      Branch_Diag_Mark7 : Diagnostic_Mark;
      Branch_Last_Fail7 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
      Mem_Pos  : Token_Index := Pos;
      Mem_Res  : Bare_Expr := No_Bare_Lkt_Node;
      Mem_Mark : Diagnostic_Mark := Mark_On_Entry;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Basic_Expr_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res7 := M.Instance;
      return Or_Res7;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res7;
   end if;
   Parser.Last_Diag := No_Diagnostic;
       Set_Failure
         (PP.Basic_Expr_Or_Parse0_Memo,
          Pos,
          Parser.Last_Fail,
          Parser.Last_Diag);
       <<Try_Again>>
       Parser.Last_Diag := No_Diagnostic;
      Nobt2 := False;
      Nobt3 := False;
      Nobt4 := False;
      Nobt5 := False;
      Nobt6 := False;
      Nobt7 := False;
      Nobt8 := False;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'basic_expr') at parser.lkt:458:19>
--  pos=Or_Pos7, res=Or_Res7, nobt=None
Or_Pos7 := No_Token_Index;
Or_Res7 := No_Bare_Lkt_Node;
Diag_Mark12 := Parser.Last_Diag;
Last_Fail7 := Parser.Last_Fail;
Branch_Diag_Mark7 := Parser.Last_Diag;
Branch_Last_Fail7 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark12;
    Parser.Last_Fail := Last_Fail7;
--  BEGIN <Transform(<ASTNodeType CallExpr>) (root of 'basic_expr') at parser.lkt:459:11>
--  pos=Row_Pos15, res=Transform_Res13, nobt=Nobt2
--  BEGIN <_Row (root of 'basic_expr') at parser.lkt:459:11>
--  pos=Row_Pos15, res=None, nobt=Nobt2
Row_Pos15 := Pos;
--  BEGIN <Defer (for 'basic_expr') at parser.lkt:459:20>
--  pos=Defer_Pos24, res=Defer_Res24, nobt=None
Defer_Res24 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos15);
Defer_Pos24 := Parser.Current_Pos;
--  END <Defer (for 'basic_expr') at parser.lkt:459:20>
Row_Progress1 := 1;
if Defer_Pos24 /= No_Token_Index then
   Row_Pos15 := Defer_Pos24;
else
   Row_Pos15 := No_Token_Index;
   goto Exit_Row15_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'basic_expr') at parser.lkt:459:31>
--  pos=Token_Pos13, res=Token_Res13, nobt=None
Token_Res13 := Row_Pos15;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res13));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos13 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos15 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos15,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos13 := Row_Pos15 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'basic_expr') at parser.lkt:459:31>
Row_Progress1 := 2;
if Token_Pos13 /= No_Token_Index then
   Row_Pos15 := Token_Pos13;
else
   Row_Pos15 := No_Token_Index;
   goto Exit_Row15_0;
end if;
--  BEGIN <Cut (root of 'basic_expr') at parser.lkt:459:35>
--  pos=Row_Pos15, res=None, nobt=Nobt2
Nobt2 := True;
--  END <Cut (root of 'basic_expr') at parser.lkt:459:35>
Row_Progress1 := 3;
if Row_Pos15 /= No_Token_Index then
   Row_Pos15 := Row_Pos15;
else
   Row_Pos15 := No_Token_Index;
   goto Exit_Row15_0;
end if;
--  BEGIN <Defer (for 'args') at parser.lkt:459:37>
--  pos=Defer_Pos25, res=Defer_Res25, nobt=None
Defer_Res25 :=
   Args_List_Parse0 (Parser, Row_Pos15);
Defer_Pos25 := Parser.Current_Pos;
--  END <Defer (for 'args') at parser.lkt:459:37>
Row_Progress1 := 4;
if Defer_Pos25 /= No_Token_Index then
   Row_Pos15 := Defer_Pos25;
else
   Row_Pos15 := No_Token_Index;
   goto Exit_Row15_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'basic_expr') at parser.lkt:459:42>
--  pos=Token_Pos14, res=Token_Res14, nobt=None
Token_Res14 := Row_Pos15;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res14));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos14 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos15 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos15,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos14 := Row_Pos15 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'basic_expr') at parser.lkt:459:42>
Row_Progress1 := 5;
if Token_Pos14 /= No_Token_Index then
   Row_Pos15 := Token_Pos14;
else
   Row_Pos15 := No_Token_Index;
   goto Exit_Row15_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row15_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'basic_expr') at parser.lkt:459:11>
if Row_Pos15 = No_Token_Index and then Nobt2 then
   Row_Pos15 := Parser.Last_Fail.Pos;
   Transform_Has_Failed1 := True;
end if;
if Row_Pos15 /= No_Token_Index then
   Transform_Res13 := Allocate_Call_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res13,
      Kind => Lkt_Call_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos15 = Pos
                            then No_Token_Index
                            else Row_Pos15 - 1));
      Initialize_Fields_For_Call_Expr
        (Self => Transform_Res13,
         Base_Call_Expr_F_Name => Defer_Res24,
         Base_Call_Expr_F_Args => Defer_Res25);
         if Defer_Res24 /= null and then Is_Incomplete (Defer_Res24) then
            Transform_Res13.Last_Attempted_Child := 0;
         elsif Defer_Res24 /= null and then not Is_Ghost (Defer_Res24) then
            Transform_Res13.Last_Attempted_Child := -1;
         end if;
         if Defer_Res25 /= null and then Is_Incomplete (Defer_Res25) then
            Transform_Res13.Last_Attempted_Child := 0;
         elsif Defer_Res25 /= null and then not Is_Ghost (Defer_Res25) then
            Transform_Res13.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed1 then
      Transform_Res13.Last_Attempted_Child :=
         Row_Progress1;
      Append (Parser, Pos, "Cannot parse <basic_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType CallExpr>) (root of 'basic_expr') at parser.lkt:459:11>
    if Row_Pos15 /= No_Token_Index then
        Or_Pos7 := Row_Pos15;
        Or_Res7 := Transform_Res13;
        goto Exit_Or8;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail7.Pos then
       Branch_Diag_Mark7 := Parser.Last_Diag;
       Branch_Last_Fail7 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark12;
    Parser.Last_Fail := Last_Fail7;
--  BEGIN <Transform(<ASTNodeType GenericInstantiation>) (root of 'basic_expr') at parser.lkt:460:11>
--  pos=Row_Pos16, res=Transform_Res14, nobt=None
--  BEGIN <_Row (root of 'basic_expr') at parser.lkt:460:11>
--  pos=Row_Pos16, res=None, nobt=None
Row_Pos16 := Pos;
--  BEGIN <Defer (for 'basic_expr') at parser.lkt:460:32>
--  pos=Defer_Pos26, res=Defer_Res26, nobt=None
Defer_Res26 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos16);
Defer_Pos26 := Parser.Current_Pos;
--  END <Defer (for 'basic_expr') at parser.lkt:460:32>
if Defer_Pos26 /= No_Token_Index then
   Row_Pos16 := Defer_Pos26;
else
   Row_Pos16 := No_Token_Index;
   goto Exit_Row16_0;
end if;
--  BEGIN <Token(<WithText LBrack>, ) (root of 'basic_expr') at parser.lkt:460:43>
--  pos=Token_Pos15, res=Token_Res15, nobt=None
Token_Res15 := Row_Pos16;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res15));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos15 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos16 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos16,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos15 := Row_Pos16 + 1;
   end if;
end;
--  END <Token(<WithText LBrack>, ) (root of 'basic_expr') at parser.lkt:460:43>
if Token_Pos15 /= No_Token_Index then
   Row_Pos16 := Token_Pos15;
else
   Row_Pos16 := No_Token_Index;
   goto Exit_Row16_0;
end if;
--  BEGIN <Defer (for 'type_list') at parser.lkt:460:47>
--  pos=Defer_Pos27, res=Defer_Res27, nobt=None
Defer_Res27 :=
   Type_List_List_Parse0 (Parser, Row_Pos16);
Defer_Pos27 := Parser.Current_Pos;
--  END <Defer (for 'type_list') at parser.lkt:460:47>
if Defer_Pos27 /= No_Token_Index then
   Row_Pos16 := Defer_Pos27;
else
   Row_Pos16 := No_Token_Index;
   goto Exit_Row16_0;
end if;
--  BEGIN <Token(<WithText RBrack>, ) (root of 'basic_expr') at parser.lkt:460:57>
--  pos=Token_Pos16, res=Token_Res16, nobt=None
Token_Res16 := Row_Pos16;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res16));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos16 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos16 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos16,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos16 := Row_Pos16 + 1;
   end if;
end;
--  END <Token(<WithText RBrack>, ) (root of 'basic_expr') at parser.lkt:460:57>
if Token_Pos16 /= No_Token_Index then
   Row_Pos16 := Token_Pos16;
else
   Row_Pos16 := No_Token_Index;
   goto Exit_Row16_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row16_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'basic_expr') at parser.lkt:460:11>
if Row_Pos16 /= No_Token_Index then
   Transform_Res14 := Allocate_Generic_Instantiation (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res14,
      Kind => Lkt_Generic_Instantiation,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos16 = Pos
                            then No_Token_Index
                            else Row_Pos16 - 1));
      Initialize_Fields_For_Generic_Instantiation
        (Self => Transform_Res14,
         Generic_Instantiation_F_Name => Defer_Res26,
         Generic_Instantiation_F_Args => Defer_Res27);
         if Defer_Res26 /= null and then Is_Incomplete (Defer_Res26) then
            Transform_Res14.Last_Attempted_Child := 0;
         elsif Defer_Res26 /= null and then not Is_Ghost (Defer_Res26) then
            Transform_Res14.Last_Attempted_Child := -1;
         end if;
         if Defer_Res27 /= null and then Is_Incomplete (Defer_Res27) then
            Transform_Res14.Last_Attempted_Child := 0;
         elsif Defer_Res27 /= null and then not Is_Ghost (Defer_Res27) then
            Transform_Res14.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType GenericInstantiation>) (root of 'basic_expr') at parser.lkt:460:11>
    if Row_Pos16 /= No_Token_Index then
        Or_Pos7 := Row_Pos16;
        Or_Res7 := Transform_Res14;
        goto Exit_Or8;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail7.Pos then
       Branch_Diag_Mark7 := Parser.Last_Diag;
       Branch_Last_Fail7 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark12;
    Parser.Last_Fail := Last_Fail7;
--  BEGIN <Transform(<ASTNodeType SubscriptExpr>) (root of 'basic_expr') at parser.lkt:461:11>
--  pos=Row_Pos17, res=Transform_Res15, nobt=Nobt3
--  BEGIN <_Row (root of 'basic_expr') at parser.lkt:461:11>
--  pos=Row_Pos17, res=None, nobt=Nobt3
Row_Pos17 := Pos;
--  BEGIN <Defer (for 'basic_expr') at parser.lkt:461:25>
--  pos=Defer_Pos28, res=Defer_Res28, nobt=None
Defer_Res28 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos17);
Defer_Pos28 := Parser.Current_Pos;
--  END <Defer (for 'basic_expr') at parser.lkt:461:25>
Row_Progress2 := 1;
if Defer_Pos28 /= No_Token_Index then
   Row_Pos17 := Defer_Pos28;
else
   Row_Pos17 := No_Token_Index;
   goto Exit_Row17_0;
end if;
--  BEGIN <Defer (for 'null_cond_qual') at parser.lkt:461:36>
--  pos=Defer_Pos29, res=Defer_Res29, nobt=None
Defer_Res29 :=
   Null_Cond_Qual_Opt_Parse0 (Parser, Row_Pos17);
Defer_Pos29 := Parser.Current_Pos;
--  END <Defer (for 'null_cond_qual') at parser.lkt:461:36>
Row_Progress2 := 2;
if Defer_Pos29 /= No_Token_Index then
   Row_Pos17 := Defer_Pos29;
else
   Row_Pos17 := No_Token_Index;
   goto Exit_Row17_0;
end if;
--  BEGIN <Token(<WithText LBrack>, ) (root of 'basic_expr') at parser.lkt:461:51>
--  pos=Token_Pos17, res=Token_Res17, nobt=None
Token_Res17 := Row_Pos17;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res17));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos17 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos17 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos17,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos17 := Row_Pos17 + 1;
   end if;
end;
--  END <Token(<WithText LBrack>, ) (root of 'basic_expr') at parser.lkt:461:51>
Row_Progress2 := 3;
if Token_Pos17 /= No_Token_Index then
   Row_Pos17 := Token_Pos17;
else
   Row_Pos17 := No_Token_Index;
   goto Exit_Row17_0;
end if;
--  BEGIN <Cut (root of 'basic_expr') at parser.lkt:461:55>
--  pos=Row_Pos17, res=None, nobt=Nobt3
Nobt3 := True;
--  END <Cut (root of 'basic_expr') at parser.lkt:461:55>
Row_Progress2 := 4;
if Row_Pos17 /= No_Token_Index then
   Row_Pos17 := Row_Pos17;
else
   Row_Pos17 := No_Token_Index;
   goto Exit_Row17_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:461:57>
--  pos=Defer_Pos30, res=Defer_Res30, nobt=None
Defer_Res30 :=
   Expr_Or_Parse0 (Parser, Row_Pos17);
Defer_Pos30 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:461:57>
Row_Progress2 := 5;
if Defer_Pos30 /= No_Token_Index then
   Row_Pos17 := Defer_Pos30;
else
   Row_Pos17 := No_Token_Index;
   goto Exit_Row17_0;
end if;
--  BEGIN <Token(<WithText RBrack>, ) (root of 'basic_expr') at parser.lkt:461:62>
--  pos=Token_Pos18, res=Token_Res18, nobt=None
Token_Res18 := Row_Pos17;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res18));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos18 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos17 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos17,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos18 := Row_Pos17 + 1;
   end if;
end;
--  END <Token(<WithText RBrack>, ) (root of 'basic_expr') at parser.lkt:461:62>
Row_Progress2 := 6;
if Token_Pos18 /= No_Token_Index then
   Row_Pos17 := Token_Pos18;
else
   Row_Pos17 := No_Token_Index;
   goto Exit_Row17_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row17_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'basic_expr') at parser.lkt:461:11>
if Row_Pos17 = No_Token_Index and then Nobt3 then
   Row_Pos17 := Parser.Last_Fail.Pos;
   Transform_Has_Failed2 := True;
end if;
if Row_Pos17 /= No_Token_Index then
   Transform_Res15 := Allocate_Subscript_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res15,
      Kind => Lkt_Subscript_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos17 = Pos
                            then No_Token_Index
                            else Row_Pos17 - 1));
      Initialize_Fields_For_Subscript_Expr
        (Self => Transform_Res15,
         Subscript_Expr_F_Prefix => Defer_Res28,
         Subscript_Expr_F_Null_Cond => Defer_Res29,
         Subscript_Expr_F_Index => Defer_Res30);
         if Defer_Res28 /= null and then Is_Incomplete (Defer_Res28) then
            Transform_Res15.Last_Attempted_Child := 0;
         elsif Defer_Res28 /= null and then not Is_Ghost (Defer_Res28) then
            Transform_Res15.Last_Attempted_Child := -1;
         end if;
         if Defer_Res29 /= null and then Is_Incomplete (Defer_Res29) then
            Transform_Res15.Last_Attempted_Child := 0;
         elsif Defer_Res29 /= null and then not Is_Ghost (Defer_Res29) then
            Transform_Res15.Last_Attempted_Child := -1;
         end if;
         if Defer_Res30 /= null and then Is_Incomplete (Defer_Res30) then
            Transform_Res15.Last_Attempted_Child := 0;
         elsif Defer_Res30 /= null and then not Is_Ghost (Defer_Res30) then
            Transform_Res15.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed2 then
      Transform_Res15.Last_Attempted_Child :=
         Row_Progress2;
      Append (Parser, Pos, "Cannot parse <basic_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType SubscriptExpr>) (root of 'basic_expr') at parser.lkt:461:11>
    if Row_Pos17 /= No_Token_Index then
        Or_Pos7 := Row_Pos17;
        Or_Res7 := Transform_Res15;
        goto Exit_Or8;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail7.Pos then
       Branch_Diag_Mark7 := Parser.Last_Diag;
       Branch_Last_Fail7 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark12;
    Parser.Last_Fail := Last_Fail7;
--  BEGIN <Transform(<ASTNodeType ErrorOnNull>) (root of 'basic_expr') at parser.lkt:462:11>
--  pos=Row_Pos18, res=Transform_Res16, nobt=None
--  BEGIN <_Row (root of 'basic_expr') at parser.lkt:462:11>
--  pos=Row_Pos18, res=None, nobt=None
Row_Pos18 := Pos;
--  BEGIN <Defer (for 'basic_expr') at parser.lkt:462:23>
--  pos=Defer_Pos31, res=Defer_Res31, nobt=None
Defer_Res31 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos18);
Defer_Pos31 := Parser.Current_Pos;
--  END <Defer (for 'basic_expr') at parser.lkt:462:23>
if Defer_Pos31 /= No_Token_Index then
   Row_Pos18 := Defer_Pos31;
else
   Row_Pos18 := No_Token_Index;
   goto Exit_Row18_0;
end if;
--  BEGIN <Token(<WithText ExclMark>, ) (root of 'basic_expr') at parser.lkt:462:34>
--  pos=Token_Pos19, res=Token_Res19, nobt=None
Token_Res19 := Row_Pos18;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res19));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Excl_Mark)
   then
       Token_Pos19 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos18 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos18,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Excl_Mark,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos19 := Row_Pos18 + 1;
   end if;
end;
--  END <Token(<WithText ExclMark>, ) (root of 'basic_expr') at parser.lkt:462:34>
if Token_Pos19 /= No_Token_Index then
   Row_Pos18 := Token_Pos19;
else
   Row_Pos18 := No_Token_Index;
   goto Exit_Row18_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row18_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'basic_expr') at parser.lkt:462:11>
if Row_Pos18 /= No_Token_Index then
   Transform_Res16 := Allocate_Error_On_Null (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res16,
      Kind => Lkt_Error_On_Null,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos18 = Pos
                            then No_Token_Index
                            else Row_Pos18 - 1));
      Initialize_Fields_For_Error_On_Null
        (Self => Transform_Res16,
         Error_On_Null_F_Expr => Defer_Res31);
         if Defer_Res31 /= null and then Is_Incomplete (Defer_Res31) then
            Transform_Res16.Last_Attempted_Child := 0;
         elsif Defer_Res31 /= null and then not Is_Ghost (Defer_Res31) then
            Transform_Res16.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType ErrorOnNull>) (root of 'basic_expr') at parser.lkt:462:11>
    if Row_Pos18 /= No_Token_Index then
        Or_Pos7 := Row_Pos18;
        Or_Res7 := Transform_Res16;
        goto Exit_Or8;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail7.Pos then
       Branch_Diag_Mark7 := Parser.Last_Diag;
       Branch_Last_Fail7 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark12;
    Parser.Last_Fail := Last_Fail7;
--  BEGIN <Transform(<ASTNodeType KeepExpr>) (root of 'basic_expr') at parser.lkt:463:11>
--  pos=Row_Pos19, res=Transform_Res17, nobt=None
--  BEGIN <_Row (root of 'basic_expr') at parser.lkt:463:11>
--  pos=Row_Pos19, res=None, nobt=None
Row_Pos19 := Pos;
--  BEGIN <Defer (for 'basic_expr') at parser.lkt:464:13>
--  pos=Defer_Pos32, res=Defer_Res32, nobt=None
Defer_Res32 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos19);
Defer_Pos32 := Parser.Current_Pos;
--  END <Defer (for 'basic_expr') at parser.lkt:464:13>
if Defer_Pos32 /= No_Token_Index then
   Row_Pos19 := Defer_Pos32;
else
   Row_Pos19 := No_Token_Index;
   goto Exit_Row19_0;
end if;
--  BEGIN <Defer (for 'null_cond_qual') at parser.lkt:464:24>
--  pos=Defer_Pos33, res=Defer_Res33, nobt=None
Defer_Res33 :=
   Null_Cond_Qual_Opt_Parse0 (Parser, Row_Pos19);
Defer_Pos33 := Parser.Current_Pos;
--  END <Defer (for 'null_cond_qual') at parser.lkt:464:24>
if Defer_Pos33 /= No_Token_Index then
   Row_Pos19 := Defer_Pos33;
else
   Row_Pos19 := No_Token_Index;
   goto Exit_Row19_0;
end if;
--  BEGIN <Token(<WithText Dot>, ) (root of 'basic_expr') at parser.lkt:464:39>
--  pos=Token_Pos20, res=Token_Res20, nobt=None
Token_Res20 := Row_Pos19;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res20));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dot)
   then
       Token_Pos20 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos19 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos19,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Dot,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos20 := Row_Pos19 + 1;
   end if;
end;
--  END <Token(<WithText Dot>, ) (root of 'basic_expr') at parser.lkt:464:39>
if Token_Pos20 /= No_Token_Index then
   Row_Pos19 := Token_Pos20;
else
   Row_Pos19 := No_Token_Index;
   goto Exit_Row19_0;
end if;
--  BEGIN <Token(<WithSymbol Identifier>, keep) (root of 'basic_expr') at parser.lkt:464:43>
--  pos=Token_Pos21, res=Token_Res21, nobt=None
Token_Res21 := Row_Pos19;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res21));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Keep)
   then
       Token_Pos21 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos19 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos19,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos21 := Row_Pos19 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, keep) (root of 'basic_expr') at parser.lkt:464:43>
if Token_Pos21 /= No_Token_Index then
   Row_Pos19 := Token_Pos21;
else
   Row_Pos19 := No_Token_Index;
   goto Exit_Row19_0;
end if;
--  BEGIN <Token(<WithText LBrack>, ) (root of 'basic_expr') at parser.lkt:464:63>
--  pos=Token_Pos22, res=Token_Res22, nobt=None
Token_Res22 := Row_Pos19;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res22));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos22 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos19 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos19,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos22 := Row_Pos19 + 1;
   end if;
end;
--  END <Token(<WithText LBrack>, ) (root of 'basic_expr') at parser.lkt:464:63>
if Token_Pos22 /= No_Token_Index then
   Row_Pos19 := Token_Pos22;
else
   Row_Pos19 := No_Token_Index;
   goto Exit_Row19_0;
end if;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:464:67>
--  pos=Defer_Pos34, res=Defer_Res34, nobt=None
Defer_Res34 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos19);
Defer_Pos34 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:464:67>
if Defer_Pos34 /= No_Token_Index then
   Row_Pos19 := Defer_Pos34;
else
   Row_Pos19 := No_Token_Index;
   goto Exit_Row19_0;
end if;
--  BEGIN <Token(<WithText RBrack>, ) (root of 'basic_expr') at parser.lkt:464:76>
--  pos=Token_Pos23, res=Token_Res23, nobt=None
Token_Res23 := Row_Pos19;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res23));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos23 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos19 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos19,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos23 := Row_Pos19 + 1;
   end if;
end;
--  END <Token(<WithText RBrack>, ) (root of 'basic_expr') at parser.lkt:464:76>
if Token_Pos23 /= No_Token_Index then
   Row_Pos19 := Token_Pos23;
else
   Row_Pos19 := No_Token_Index;
   goto Exit_Row19_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row19_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'basic_expr') at parser.lkt:463:11>
if Row_Pos19 /= No_Token_Index then
   Transform_Res17 := Allocate_Keep_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res17,
      Kind => Lkt_Keep_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos19 = Pos
                            then No_Token_Index
                            else Row_Pos19 - 1));
      Initialize_Fields_For_Keep_Expr
        (Self => Transform_Res17,
         Keep_Expr_F_Expr => Defer_Res32,
         Keep_Expr_F_Null_Cond => Defer_Res33,
         Keep_Expr_F_Keep_Type => Defer_Res34);
         if Defer_Res32 /= null and then Is_Incomplete (Defer_Res32) then
            Transform_Res17.Last_Attempted_Child := 0;
         elsif Defer_Res32 /= null and then not Is_Ghost (Defer_Res32) then
            Transform_Res17.Last_Attempted_Child := -1;
         end if;
         if Defer_Res33 /= null and then Is_Incomplete (Defer_Res33) then
            Transform_Res17.Last_Attempted_Child := 0;
         elsif Defer_Res33 /= null and then not Is_Ghost (Defer_Res33) then
            Transform_Res17.Last_Attempted_Child := -1;
         end if;
         if Defer_Res34 /= null and then Is_Incomplete (Defer_Res34) then
            Transform_Res17.Last_Attempted_Child := 0;
         elsif Defer_Res34 /= null and then not Is_Ghost (Defer_Res34) then
            Transform_Res17.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType KeepExpr>) (root of 'basic_expr') at parser.lkt:463:11>
    if Row_Pos19 /= No_Token_Index then
        Or_Pos7 := Row_Pos19;
        Or_Res7 := Transform_Res17;
        goto Exit_Or8;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail7.Pos then
       Branch_Diag_Mark7 := Parser.Last_Diag;
       Branch_Last_Fail7 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark12;
    Parser.Last_Fail := Last_Fail7;
--  BEGIN <Transform(<ASTNodeType CastExpr>) (root of 'basic_expr') at parser.lkt:466:11>
--  pos=Row_Pos20, res=Transform_Res18, nobt=Nobt4
--  BEGIN <_Row (root of 'basic_expr') at parser.lkt:466:11>
--  pos=Row_Pos20, res=None, nobt=Nobt4
Row_Pos20 := Pos;
--  BEGIN <Defer (for 'basic_expr') at parser.lkt:467:13>
--  pos=Defer_Pos35, res=Defer_Res35, nobt=None
Defer_Res35 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos20);
Defer_Pos35 := Parser.Current_Pos;
--  END <Defer (for 'basic_expr') at parser.lkt:467:13>
Row_Progress3 := 1;
if Defer_Pos35 /= No_Token_Index then
   Row_Pos20 := Defer_Pos35;
else
   Row_Pos20 := No_Token_Index;
   goto Exit_Row20_0;
end if;
--  BEGIN <Defer (for 'null_cond_qual') at parser.lkt:468:13>
--  pos=Defer_Pos36, res=Defer_Res36, nobt=None
Defer_Res36 :=
   Null_Cond_Qual_Opt_Parse0 (Parser, Row_Pos20);
Defer_Pos36 := Parser.Current_Pos;
--  END <Defer (for 'null_cond_qual') at parser.lkt:468:13>
Row_Progress3 := 2;
if Defer_Pos36 /= No_Token_Index then
   Row_Pos20 := Defer_Pos36;
else
   Row_Pos20 := No_Token_Index;
   goto Exit_Row20_0;
end if;
--  BEGIN <Token(<WithText Dot>, ) (root of 'basic_expr') at parser.lkt:469:13>
--  pos=Token_Pos24, res=Token_Res24, nobt=None
Token_Res24 := Row_Pos20;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res24));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dot)
   then
       Token_Pos24 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos20 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos20,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Dot,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos24 := Row_Pos20 + 1;
   end if;
end;
--  END <Token(<WithText Dot>, ) (root of 'basic_expr') at parser.lkt:469:13>
Row_Progress3 := 3;
if Token_Pos24 /= No_Token_Index then
   Row_Pos20 := Token_Pos24;
else
   Row_Pos20 := No_Token_Index;
   goto Exit_Row20_0;
end if;
--  BEGIN <Token(<WithSymbol Identifier>, as) (root of 'basic_expr') at parser.lkt:470:13>
--  pos=Token_Pos25, res=Token_Res25, nobt=None
Token_Res25 := Row_Pos20;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res25));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_As)
   then
       Token_Pos25 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos20 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos20,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos25 := Row_Pos20 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, as) (root of 'basic_expr') at parser.lkt:470:13>
Row_Progress3 := 4;
if Token_Pos25 /= No_Token_Index then
   Row_Pos20 := Token_Pos25;
else
   Row_Pos20 := No_Token_Index;
   goto Exit_Row20_0;
end if;
--  BEGIN <Cut (root of 'basic_expr') at parser.lkt:471:13>
--  pos=Row_Pos20, res=None, nobt=Nobt4
Nobt4 := True;
--  END <Cut (root of 'basic_expr') at parser.lkt:471:13>
Row_Progress3 := 5;
if Row_Pos20 /= No_Token_Index then
   Row_Pos20 := Row_Pos20;
else
   Row_Pos20 := No_Token_Index;
   goto Exit_Row20_0;
end if;
--  BEGIN <Opt (root of 'basic_expr') at parser.lkt:472:13>
--  pos=Token_Pos26, res=Opt_Res0, nobt=None
Diag_Mark11 := Parser.Last_Diag;
--  BEGIN <Token(<WithText ExclMark>, ) (root of 'basic_expr') at parser.lkt:472:26>
--  pos=Token_Pos26, res=Token_Res26, nobt=None
Token_Res26 := Row_Pos20;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res26));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Excl_Mark)
   then
       Token_Pos26 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos20 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos20,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Excl_Mark,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos26 := Row_Pos20 + 1;
   end if;
end;
--  END <Token(<WithText ExclMark>, ) (root of 'basic_expr') at parser.lkt:472:26>
if Token_Pos26 = No_Token_Index then
         Opt_Res0 := Allocate_Excludes_Null_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res0,
            Kind              => Lkt_Excludes_Null_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos20,
            Token_End_Index   => No_Token_Index);
   Token_Pos26 := Row_Pos20;
      Parser.Last_Diag := Diag_Mark11;
else
      Opt_Res0 := Allocate_Excludes_Null_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res0,
         Kind              => Lkt_Excludes_Null_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos20,
         Token_End_Index   => Token_Pos26 - 1);
end if;
--  END <Opt (root of 'basic_expr') at parser.lkt:472:13>
Row_Progress3 := 6;
if Token_Pos26 /= No_Token_Index then
   Row_Pos20 := Token_Pos26;
else
   Row_Pos20 := No_Token_Index;
   goto Exit_Row20_0;
end if;
--  BEGIN <Token(<WithText LBrack>, ) (root of 'basic_expr') at parser.lkt:473:13>
--  pos=Token_Pos27, res=Token_Res27, nobt=None
Token_Res27 := Row_Pos20;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res27));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos27 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos20 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos20,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos27 := Row_Pos20 + 1;
   end if;
end;
--  END <Token(<WithText LBrack>, ) (root of 'basic_expr') at parser.lkt:473:13>
Row_Progress3 := 7;
if Token_Pos27 /= No_Token_Index then
   Row_Pos20 := Token_Pos27;
else
   Row_Pos20 := No_Token_Index;
   goto Exit_Row20_0;
end if;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:474:13>
--  pos=Defer_Pos37, res=Defer_Res37, nobt=None
Defer_Res37 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos20);
Defer_Pos37 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:474:13>
Row_Progress3 := 8;
if Defer_Pos37 /= No_Token_Index then
   Row_Pos20 := Defer_Pos37;
else
   Row_Pos20 := No_Token_Index;
   goto Exit_Row20_0;
end if;
--  BEGIN <Token(<WithText RBrack>, ) (root of 'basic_expr') at parser.lkt:475:13>
--  pos=Token_Pos28, res=Token_Res28, nobt=None
Token_Res28 := Row_Pos20;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res28));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos28 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos20 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos20,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos28 := Row_Pos20 + 1;
   end if;
end;
--  END <Token(<WithText RBrack>, ) (root of 'basic_expr') at parser.lkt:475:13>
Row_Progress3 := 9;
if Token_Pos28 /= No_Token_Index then
   Row_Pos20 := Token_Pos28;
else
   Row_Pos20 := No_Token_Index;
   goto Exit_Row20_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row20_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'basic_expr') at parser.lkt:466:11>
if Row_Pos20 = No_Token_Index and then Nobt4 then
   Row_Pos20 := Parser.Last_Fail.Pos;
   Transform_Has_Failed3 := True;
end if;
if Row_Pos20 /= No_Token_Index then
   Transform_Res18 := Allocate_Cast_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res18,
      Kind => Lkt_Cast_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos20 = Pos
                            then No_Token_Index
                            else Row_Pos20 - 1));
      Initialize_Fields_For_Cast_Expr
        (Self => Transform_Res18,
         Cast_Expr_F_Expr => Defer_Res35,
         Cast_Expr_F_Null_Cond => Defer_Res36,
         Cast_Expr_F_Excludes_Null => Opt_Res0,
         Cast_Expr_F_Dest_Type => Defer_Res37);
         if Defer_Res35 /= null and then Is_Incomplete (Defer_Res35) then
            Transform_Res18.Last_Attempted_Child := 0;
         elsif Defer_Res35 /= null and then not Is_Ghost (Defer_Res35) then
            Transform_Res18.Last_Attempted_Child := -1;
         end if;
         if Defer_Res36 /= null and then Is_Incomplete (Defer_Res36) then
            Transform_Res18.Last_Attempted_Child := 0;
         elsif Defer_Res36 /= null and then not Is_Ghost (Defer_Res36) then
            Transform_Res18.Last_Attempted_Child := -1;
         end if;
         if Opt_Res0 /= null and then Is_Incomplete (Opt_Res0) then
            Transform_Res18.Last_Attempted_Child := 0;
         elsif Opt_Res0 /= null and then not Is_Ghost (Opt_Res0) then
            Transform_Res18.Last_Attempted_Child := -1;
         end if;
         if Defer_Res37 /= null and then Is_Incomplete (Defer_Res37) then
            Transform_Res18.Last_Attempted_Child := 0;
         elsif Defer_Res37 /= null and then not Is_Ghost (Defer_Res37) then
            Transform_Res18.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed3 then
      Transform_Res18.Last_Attempted_Child :=
         Row_Progress3;
      Append (Parser, Pos, "Cannot parse <basic_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType CastExpr>) (root of 'basic_expr') at parser.lkt:466:11>
    if Row_Pos20 /= No_Token_Index then
        Or_Pos7 := Row_Pos20;
        Or_Res7 := Transform_Res18;
        goto Exit_Or8;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail7.Pos then
       Branch_Diag_Mark7 := Parser.Last_Diag;
       Branch_Last_Fail7 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark12;
    Parser.Last_Fail := Last_Fail7;
--  BEGIN <Transform(<ASTNodeType LogicPredicate>) (root of 'basic_expr') at parser.lkt:477:11>
--  pos=Row_Pos21, res=Transform_Res19, nobt=Nobt5
--  BEGIN <_Row (root of 'basic_expr') at parser.lkt:477:11>
--  pos=Row_Pos21, res=None, nobt=Nobt5
Row_Pos21 := Pos;
--  BEGIN <Defer (for 'basic_expr') at parser.lkt:477:26>
--  pos=Defer_Pos38, res=Defer_Res38, nobt=None
Defer_Res38 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos21);
Defer_Pos38 := Parser.Current_Pos;
--  END <Defer (for 'basic_expr') at parser.lkt:477:26>
Row_Progress4 := 1;
if Defer_Pos38 /= No_Token_Index then
   Row_Pos21 := Defer_Pos38;
else
   Row_Pos21 := No_Token_Index;
   goto Exit_Row21_0;
end if;
--  BEGIN <Token(<WithText Percent>, ) (root of 'basic_expr') at parser.lkt:477:37>
--  pos=Token_Pos29, res=Token_Res29, nobt=None
Token_Res29 := Row_Pos21;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res29));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Percent)
   then
       Token_Pos29 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos21 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos21,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Percent,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos29 := Row_Pos21 + 1;
   end if;
end;
--  END <Token(<WithText Percent>, ) (root of 'basic_expr') at parser.lkt:477:37>
Row_Progress4 := 2;
if Token_Pos29 /= No_Token_Index then
   Row_Pos21 := Token_Pos29;
else
   Row_Pos21 := No_Token_Index;
   goto Exit_Row21_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'basic_expr') at parser.lkt:477:41>
--  pos=Token_Pos30, res=Token_Res30, nobt=None
Token_Res30 := Row_Pos21;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res30));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos30 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos21 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos21,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos30 := Row_Pos21 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'basic_expr') at parser.lkt:477:41>
Row_Progress4 := 3;
if Token_Pos30 /= No_Token_Index then
   Row_Pos21 := Token_Pos30;
else
   Row_Pos21 := No_Token_Index;
   goto Exit_Row21_0;
end if;
--  BEGIN <Cut (root of 'basic_expr') at parser.lkt:477:45>
--  pos=Row_Pos21, res=None, nobt=Nobt5
Nobt5 := True;
--  END <Cut (root of 'basic_expr') at parser.lkt:477:45>
Row_Progress4 := 4;
if Row_Pos21 /= No_Token_Index then
   Row_Pos21 := Row_Pos21;
else
   Row_Pos21 := No_Token_Index;
   goto Exit_Row21_0;
end if;
--  BEGIN <Defer (for 'args') at parser.lkt:477:47>
--  pos=Defer_Pos39, res=Defer_Res39, nobt=None
Defer_Res39 :=
   Args_List_Parse0 (Parser, Row_Pos21);
Defer_Pos39 := Parser.Current_Pos;
--  END <Defer (for 'args') at parser.lkt:477:47>
Row_Progress4 := 5;
if Defer_Pos39 /= No_Token_Index then
   Row_Pos21 := Defer_Pos39;
else
   Row_Pos21 := No_Token_Index;
   goto Exit_Row21_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'basic_expr') at parser.lkt:477:52>
--  pos=Token_Pos31, res=Token_Res31, nobt=None
Token_Res31 := Row_Pos21;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res31));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos31 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos21 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos21,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos31 := Row_Pos21 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'basic_expr') at parser.lkt:477:52>
Row_Progress4 := 6;
if Token_Pos31 /= No_Token_Index then
   Row_Pos21 := Token_Pos31;
else
   Row_Pos21 := No_Token_Index;
   goto Exit_Row21_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row21_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'basic_expr') at parser.lkt:477:11>
if Row_Pos21 = No_Token_Index and then Nobt5 then
   Row_Pos21 := Parser.Last_Fail.Pos;
   Transform_Has_Failed4 := True;
end if;
if Row_Pos21 /= No_Token_Index then
   Transform_Res19 := Allocate_Logic_Predicate (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res19,
      Kind => Lkt_Logic_Predicate,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos21 = Pos
                            then No_Token_Index
                            else Row_Pos21 - 1));
      Initialize_Fields_For_Logic_Predicate
        (Self => Transform_Res19,
         Base_Call_Expr_F_Name => Defer_Res38,
         Base_Call_Expr_F_Args => Defer_Res39);
         if Defer_Res38 /= null and then Is_Incomplete (Defer_Res38) then
            Transform_Res19.Last_Attempted_Child := 0;
         elsif Defer_Res38 /= null and then not Is_Ghost (Defer_Res38) then
            Transform_Res19.Last_Attempted_Child := -1;
         end if;
         if Defer_Res39 /= null and then Is_Incomplete (Defer_Res39) then
            Transform_Res19.Last_Attempted_Child := 0;
         elsif Defer_Res39 /= null and then not Is_Ghost (Defer_Res39) then
            Transform_Res19.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed4 then
      Transform_Res19.Last_Attempted_Child :=
         Row_Progress4;
      Append (Parser, Pos, "Cannot parse <basic_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType LogicPredicate>) (root of 'basic_expr') at parser.lkt:477:11>
    if Row_Pos21 /= No_Token_Index then
        Or_Pos7 := Row_Pos21;
        Or_Res7 := Transform_Res19;
        goto Exit_Or8;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail7.Pos then
       Branch_Diag_Mark7 := Parser.Last_Diag;
       Branch_Last_Fail7 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark12;
    Parser.Last_Fail := Last_Fail7;
--  BEGIN <Transform(<ASTNodeType DotExpr>) (root of 'basic_expr') at parser.lkt:478:11>
--  pos=Row_Pos22, res=Transform_Res20, nobt=Nobt6
--  BEGIN <_Row (root of 'basic_expr') at parser.lkt:478:11>
--  pos=Row_Pos22, res=None, nobt=Nobt6
Row_Pos22 := Pos;
--  BEGIN <Defer (for 'basic_expr') at parser.lkt:478:19>
--  pos=Defer_Pos40, res=Defer_Res40, nobt=None
Defer_Res40 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos22);
Defer_Pos40 := Parser.Current_Pos;
--  END <Defer (for 'basic_expr') at parser.lkt:478:19>
Row_Progress5 := 1;
if Defer_Pos40 /= No_Token_Index then
   Row_Pos22 := Defer_Pos40;
else
   Row_Pos22 := No_Token_Index;
   goto Exit_Row22_0;
end if;
--  BEGIN <Defer (for 'null_cond_qual') at parser.lkt:478:30>
--  pos=Defer_Pos41, res=Defer_Res41, nobt=None
Defer_Res41 :=
   Null_Cond_Qual_Opt_Parse0 (Parser, Row_Pos22);
Defer_Pos41 := Parser.Current_Pos;
--  END <Defer (for 'null_cond_qual') at parser.lkt:478:30>
Row_Progress5 := 2;
if Defer_Pos41 /= No_Token_Index then
   Row_Pos22 := Defer_Pos41;
else
   Row_Pos22 := No_Token_Index;
   goto Exit_Row22_0;
end if;
--  BEGIN <Token(<WithText Dot>, ) (root of 'basic_expr') at parser.lkt:478:45>
--  pos=Token_Pos32, res=Token_Res32, nobt=None
Token_Res32 := Row_Pos22;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res32));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dot)
   then
       Token_Pos32 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos22 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos22,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Dot,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos32 := Row_Pos22 + 1;
   end if;
end;
--  END <Token(<WithText Dot>, ) (root of 'basic_expr') at parser.lkt:478:45>
Row_Progress5 := 3;
if Token_Pos32 /= No_Token_Index then
   Row_Pos22 := Token_Pos32;
else
   Row_Pos22 := No_Token_Index;
   goto Exit_Row22_0;
end if;
--  BEGIN <Cut (root of 'basic_expr') at parser.lkt:478:49>
--  pos=Row_Pos22, res=None, nobt=Nobt6
Nobt6 := True;
--  END <Cut (root of 'basic_expr') at parser.lkt:478:49>
Row_Progress5 := 4;
if Row_Pos22 /= No_Token_Index then
   Row_Pos22 := Row_Pos22;
else
   Row_Pos22 := No_Token_Index;
   goto Exit_Row22_0;
end if;
--  BEGIN <Defer (for 'ref_id') at parser.lkt:478:51>
--  pos=Defer_Pos42, res=Defer_Res42, nobt=None
Defer_Res42 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos22);
Defer_Pos42 := Parser.Current_Pos;
--  END <Defer (for 'ref_id') at parser.lkt:478:51>
Row_Progress5 := 5;
if Defer_Pos42 /= No_Token_Index then
   Row_Pos22 := Defer_Pos42;
else
   Row_Pos22 := No_Token_Index;
   goto Exit_Row22_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row22_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'basic_expr') at parser.lkt:478:11>
if Row_Pos22 = No_Token_Index and then Nobt6 then
   Row_Pos22 := Parser.Last_Fail.Pos;
   Transform_Has_Failed5 := True;
end if;
if Row_Pos22 /= No_Token_Index then
   Transform_Res20 := Allocate_Dot_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res20,
      Kind => Lkt_Dot_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos22 = Pos
                            then No_Token_Index
                            else Row_Pos22 - 1));
      Initialize_Fields_For_Dot_Expr
        (Self => Transform_Res20,
         Dot_Expr_F_Prefix => Defer_Res40,
         Dot_Expr_F_Null_Cond => Defer_Res41,
         Dot_Expr_F_Suffix => Defer_Res42);
         if Defer_Res40 /= null and then Is_Incomplete (Defer_Res40) then
            Transform_Res20.Last_Attempted_Child := 0;
         elsif Defer_Res40 /= null and then not Is_Ghost (Defer_Res40) then
            Transform_Res20.Last_Attempted_Child := -1;
         end if;
         if Defer_Res41 /= null and then Is_Incomplete (Defer_Res41) then
            Transform_Res20.Last_Attempted_Child := 0;
         elsif Defer_Res41 /= null and then not Is_Ghost (Defer_Res41) then
            Transform_Res20.Last_Attempted_Child := -1;
         end if;
         if Defer_Res42 /= null and then Is_Incomplete (Defer_Res42) then
            Transform_Res20.Last_Attempted_Child := 0;
         elsif Defer_Res42 /= null and then not Is_Ghost (Defer_Res42) then
            Transform_Res20.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed5 then
      Transform_Res20.Last_Attempted_Child :=
         Row_Progress5;
      Append (Parser, Pos, "Cannot parse <basic_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType DotExpr>) (root of 'basic_expr') at parser.lkt:478:11>
    if Row_Pos22 /= No_Token_Index then
        Or_Pos7 := Row_Pos22;
        Or_Res7 := Transform_Res20;
        goto Exit_Or8;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail7.Pos then
       Branch_Diag_Mark7 := Parser.Last_Diag;
       Branch_Last_Fail7 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark12;
    Parser.Last_Fail := Last_Fail7;
--  BEGIN <Transform(<ASTNodeType LogicExpr>) (root of 'basic_expr') at parser.lkt:479:11>
--  pos=Row_Pos23, res=Transform_Res22, nobt=Nobt7
--  BEGIN <_Row (root of 'basic_expr') at parser.lkt:479:11>
--  pos=Row_Pos23, res=None, nobt=Nobt7
Row_Pos23 := Pos;
--  BEGIN <Token(<WithText Percent>, ) (root of 'basic_expr') at parser.lkt:479:21>
--  pos=Token_Pos33, res=Token_Res33, nobt=None
Token_Res33 := Row_Pos23;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res33));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Percent)
   then
       Token_Pos33 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos23 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos23,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Percent,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos33 := Row_Pos23 + 1;
   end if;
end;
--  END <Token(<WithText Percent>, ) (root of 'basic_expr') at parser.lkt:479:21>
Row_Progress7 := 1;
if Token_Pos33 /= No_Token_Index then
   Row_Pos23 := Token_Pos33;
else
   Row_Pos23 := No_Token_Index;
   goto Exit_Row23_0;
end if;
--  BEGIN <Transform(<ASTNodeType CallExpr>) (root of 'basic_expr') at parser.lkt:479:25>
--  pos=Row_Pos24, res=Transform_Res21, nobt=Nobt7
--  BEGIN <_Row (root of 'basic_expr') at parser.lkt:479:25>
--  pos=Row_Pos24, res=None, nobt=Nobt7
Row_Pos24 := Row_Pos23;
--  BEGIN <Defer (for 'ref_id') at parser.lkt:479:34>
--  pos=Defer_Pos43, res=Defer_Res43, nobt=None
Defer_Res43 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos24);
Defer_Pos43 := Parser.Current_Pos;
--  END <Defer (for 'ref_id') at parser.lkt:479:34>
Row_Progress6 := 1;
if Defer_Pos43 /= No_Token_Index then
   Row_Pos24 := Defer_Pos43;
else
   Row_Pos24 := No_Token_Index;
   goto Exit_Row24_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'basic_expr') at parser.lkt:479:41>
--  pos=Token_Pos34, res=Token_Res34, nobt=None
Token_Res34 := Row_Pos24;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res34));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos34 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos24 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos24,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos34 := Row_Pos24 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'basic_expr') at parser.lkt:479:41>
Row_Progress6 := 2;
if Token_Pos34 /= No_Token_Index then
   Row_Pos24 := Token_Pos34;
else
   Row_Pos24 := No_Token_Index;
   goto Exit_Row24_0;
end if;
--  BEGIN <Cut (root of 'basic_expr') at parser.lkt:479:45>
--  pos=Row_Pos24, res=None, nobt=Nobt7
Nobt7 := True;
--  END <Cut (root of 'basic_expr') at parser.lkt:479:45>
Row_Progress6 := 3;
if Row_Pos24 /= No_Token_Index then
   Row_Pos24 := Row_Pos24;
else
   Row_Pos24 := No_Token_Index;
   goto Exit_Row24_0;
end if;
--  BEGIN <Defer (for 'args') at parser.lkt:479:47>
--  pos=Defer_Pos44, res=Defer_Res44, nobt=None
Defer_Res44 :=
   Args_List_Parse0 (Parser, Row_Pos24);
Defer_Pos44 := Parser.Current_Pos;
--  END <Defer (for 'args') at parser.lkt:479:47>
Row_Progress6 := 4;
if Defer_Pos44 /= No_Token_Index then
   Row_Pos24 := Defer_Pos44;
else
   Row_Pos24 := No_Token_Index;
   goto Exit_Row24_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'basic_expr') at parser.lkt:479:52>
--  pos=Token_Pos35, res=Token_Res35, nobt=None
Token_Res35 := Row_Pos24;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res35));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos35 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos24 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos24,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos35 := Row_Pos24 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'basic_expr') at parser.lkt:479:52>
Row_Progress6 := 5;
if Token_Pos35 /= No_Token_Index then
   Row_Pos24 := Token_Pos35;
else
   Row_Pos24 := No_Token_Index;
   goto Exit_Row24_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row24_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'basic_expr') at parser.lkt:479:25>
if Row_Pos24 = No_Token_Index and then Nobt7 then
   Row_Pos24 := Parser.Last_Fail.Pos;
   Transform_Has_Failed6 := True;
end if;
if Row_Pos24 /= No_Token_Index then
   Transform_Res21 := Allocate_Call_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res21,
      Kind => Lkt_Call_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos23,
      Token_End_Index   => (if Row_Pos24 = Row_Pos23
                            then No_Token_Index
                            else Row_Pos24 - 1));
      Initialize_Fields_For_Call_Expr
        (Self => Transform_Res21,
         Base_Call_Expr_F_Name => Defer_Res43,
         Base_Call_Expr_F_Args => Defer_Res44);
         if Defer_Res43 /= null and then Is_Incomplete (Defer_Res43) then
            Transform_Res21.Last_Attempted_Child := 0;
         elsif Defer_Res43 /= null and then not Is_Ghost (Defer_Res43) then
            Transform_Res21.Last_Attempted_Child := -1;
         end if;
         if Defer_Res44 /= null and then Is_Incomplete (Defer_Res44) then
            Transform_Res21.Last_Attempted_Child := 0;
         elsif Defer_Res44 /= null and then not Is_Ghost (Defer_Res44) then
            Transform_Res21.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed6 then
      Transform_Res21.Last_Attempted_Child :=
         Row_Progress6;
      Append (Parser, Row_Pos23, "Cannot parse <basic_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType CallExpr>) (root of 'basic_expr') at parser.lkt:479:25>
Row_Progress7 := 2;
if Row_Pos24 /= No_Token_Index then
   Row_Pos23 := Row_Pos24;
else
   Row_Pos23 := No_Token_Index;
   goto Exit_Row23_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row23_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'basic_expr') at parser.lkt:479:11>
if Row_Pos23 = No_Token_Index and then Nobt7 then
   Row_Pos23 := Parser.Last_Fail.Pos;
   Transform_Has_Failed7 := True;
end if;
if Row_Pos23 /= No_Token_Index then
   Transform_Res22 := Allocate_Logic_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res22,
      Kind => Lkt_Logic_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos23 = Pos
                            then No_Token_Index
                            else Row_Pos23 - 1));
      Initialize_Fields_For_Logic_Expr
        (Self => Transform_Res22,
         Logic_Expr_F_Expr => Transform_Res21);
         if Transform_Res21 /= null and then Is_Incomplete (Transform_Res21) then
            Transform_Res22.Last_Attempted_Child := 0;
         elsif Transform_Res21 /= null and then not Is_Ghost (Transform_Res21) then
            Transform_Res22.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed7 then
      Transform_Res22.Last_Attempted_Child :=
         Row_Progress7;
      Append (Parser, Pos, "Cannot parse <basic_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType LogicExpr>) (root of 'basic_expr') at parser.lkt:479:11>
    if Row_Pos23 /= No_Token_Index then
        Or_Pos7 := Row_Pos23;
        Or_Res7 := Transform_Res22;
        goto Exit_Or8;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail7.Pos then
       Branch_Diag_Mark7 := Parser.Last_Diag;
       Branch_Last_Fail7 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark12;
    Parser.Last_Fail := Last_Fail7;
--  BEGIN <Transform(<ASTNodeType LogicExpr>) (root of 'basic_expr') at parser.lkt:480:11>
--  pos=Row_Pos25, res=Transform_Res23, nobt=Nobt8
--  BEGIN <_Row (root of 'basic_expr') at parser.lkt:480:11>
--  pos=Row_Pos25, res=None, nobt=Nobt8
Row_Pos25 := Pos;
--  BEGIN <Token(<WithText Percent>, ) (root of 'basic_expr') at parser.lkt:480:21>
--  pos=Token_Pos36, res=Token_Res36, nobt=None
Token_Res36 := Row_Pos25;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res36));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Percent)
   then
       Token_Pos36 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos25 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos25,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Percent,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos36 := Row_Pos25 + 1;
   end if;
end;
--  END <Token(<WithText Percent>, ) (root of 'basic_expr') at parser.lkt:480:21>
Row_Progress8 := 1;
if Token_Pos36 /= No_Token_Index then
   Row_Pos25 := Token_Pos36;
else
   Row_Pos25 := No_Token_Index;
   goto Exit_Row25_0;
end if;
--  BEGIN <Cut (root of 'basic_expr') at parser.lkt:480:25>
--  pos=Row_Pos25, res=None, nobt=Nobt8
Nobt8 := True;
--  END <Cut (root of 'basic_expr') at parser.lkt:480:25>
Row_Progress8 := 2;
if Row_Pos25 /= No_Token_Index then
   Row_Pos25 := Row_Pos25;
else
   Row_Pos25 := No_Token_Index;
   goto Exit_Row25_0;
end if;
--  BEGIN <Defer (for 'ref_id') at parser.lkt:480:27>
--  pos=Defer_Pos45, res=Defer_Res45, nobt=None
Defer_Res45 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos25);
Defer_Pos45 := Parser.Current_Pos;
--  END <Defer (for 'ref_id') at parser.lkt:480:27>
Row_Progress8 := 3;
if Defer_Pos45 /= No_Token_Index then
   Row_Pos25 := Defer_Pos45;
else
   Row_Pos25 := No_Token_Index;
   goto Exit_Row25_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row25_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'basic_expr') at parser.lkt:480:11>
if Row_Pos25 = No_Token_Index and then Nobt8 then
   Row_Pos25 := Parser.Last_Fail.Pos;
   Transform_Has_Failed8 := True;
end if;
if Row_Pos25 /= No_Token_Index then
   Transform_Res23 := Allocate_Logic_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res23,
      Kind => Lkt_Logic_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos25 = Pos
                            then No_Token_Index
                            else Row_Pos25 - 1));
      Initialize_Fields_For_Logic_Expr
        (Self => Transform_Res23,
         Logic_Expr_F_Expr => Defer_Res45);
         if Defer_Res45 /= null and then Is_Incomplete (Defer_Res45) then
            Transform_Res23.Last_Attempted_Child := 0;
         elsif Defer_Res45 /= null and then not Is_Ghost (Defer_Res45) then
            Transform_Res23.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed8 then
      Transform_Res23.Last_Attempted_Child :=
         Row_Progress8;
      Append (Parser, Pos, "Cannot parse <basic_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType LogicExpr>) (root of 'basic_expr') at parser.lkt:480:11>
    if Row_Pos25 /= No_Token_Index then
        Or_Pos7 := Row_Pos25;
        Or_Res7 := Transform_Res23;
        goto Exit_Or8;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail7.Pos then
       Branch_Diag_Mark7 := Parser.Last_Diag;
       Branch_Last_Fail7 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark12;
    Parser.Last_Fail := Last_Fail7;
--  BEGIN <Defer (for 'term') at parser.lkt:481:11>
--  pos=Defer_Pos46, res=Defer_Res46, nobt=None
Defer_Res46 :=
   Term_Or_Parse0 (Parser, Pos);
Defer_Pos46 := Parser.Current_Pos;
--  END <Defer (for 'term') at parser.lkt:481:11>
    if Defer_Pos46 /= No_Token_Index then
        Or_Pos7 := Defer_Pos46;
        Or_Res7 := Defer_Res46;
        goto Exit_Or8;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail7.Pos then
       Branch_Diag_Mark7 := Parser.Last_Diag;
       Branch_Last_Fail7 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark7;
Parser.Last_Fail := Branch_Last_Fail7;
<<Exit_Or8>>
--  END <Or (root of 'basic_expr') at parser.lkt:458:19>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
      if Or_Pos7 > Mem_Pos then
         Mem_Pos := Or_Pos7;
         Mem_Res := Or_Res7;
         Mem_Mark := Parser.Last_Diag;
         if Or_Pos7 = No_Token_Index then
            Set_Failure (PP.Basic_Expr_Or_Parse0_Memo, Pos, Parser.Last_Fail, Mem_Mark);
         else
            Memos.Set_Success
              (PP.Basic_Expr_Or_Parse0_Memo,
               Pos,
               Or_Res7,
               Mem_Mark,
               Or_Pos7);
         end if;
         goto Try_Again;
      elsif Mem_Pos > Pos then
         Or_Res7 := Mem_Res;
         Or_Pos7 := Mem_Pos;
         Parser.Last_Diag := Mem_Mark;
         goto No_Memo;
      end if;
   if Or_Pos7 = No_Token_Index then
      Set_Failure
        (PP.Basic_Expr_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Basic_Expr_Or_Parse0_Memo, Pos, Or_Res7, Parser.Last_Diag, Or_Pos7);
   end if;
       <<No_Memo>>
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos7;
   return Or_Res7;
end Basic_Expr_Or_Parse0;
   function Basic_Name_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
      Nobt9 : Boolean := False;
      Row_Pos26 : Token_Index := No_Token_Index;
      Defer_Pos47 : Token_Index := No_Token_Index;
      Defer_Res47 : Bare_Expr := No_Bare_Lkt_Node;
      Null_Res0 : Bare_Null_Cond_Qualifier := No_Bare_Lkt_Node;
      Token_Pos37 : Token_Index := No_Token_Index;
      Token_Res37 : Token_Index := No_Token_Index;
      Defer_Pos48 : Token_Index := No_Token_Index;
      Defer_Res48 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Row_Progress9 : Integer := 0;
      Transform_Res24 : Bare_Dot_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed9 : Boolean := False;
      Defer_Pos49 : Token_Index := No_Token_Index;
      Defer_Res49 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Or_Pos8 : Token_Index := No_Token_Index;
      Or_Res8 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark13 : Diagnostic_Mark;
      Last_Fail8 : Fail_Info;
      Branch_Diag_Mark8 : Diagnostic_Mark;
      Branch_Last_Fail8 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
      Mem_Pos  : Token_Index := Pos;
      Mem_Res  : Bare_Expr := No_Bare_Lkt_Node;
      Mem_Mark : Diagnostic_Mark := Mark_On_Entry;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Basic_Name_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res8 := M.Instance;
      return Or_Res8;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res8;
   end if;
   Parser.Last_Diag := No_Diagnostic;
       Set_Failure
         (PP.Basic_Name_Or_Parse0_Memo,
          Pos,
          Parser.Last_Fail,
          Parser.Last_Diag);
       <<Try_Again>>
       Parser.Last_Diag := No_Diagnostic;
      Nobt9 := False;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'basic_name') at parser.lkt:496:19>
--  pos=Or_Pos8, res=Or_Res8, nobt=None
Or_Pos8 := No_Token_Index;
Or_Res8 := No_Bare_Lkt_Node;
Diag_Mark13 := Parser.Last_Diag;
Last_Fail8 := Parser.Last_Fail;
Branch_Diag_Mark8 := Parser.Last_Diag;
Branch_Last_Fail8 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark13;
    Parser.Last_Fail := Last_Fail8;
--  BEGIN <Transform(<ASTNodeType DotExpr>) (root of 'basic_name') at parser.lkt:497:9>
--  pos=Row_Pos26, res=Transform_Res24, nobt=Nobt9
--  BEGIN <_Row (root of 'basic_name') at parser.lkt:497:9>
--  pos=Row_Pos26, res=None, nobt=Nobt9
Row_Pos26 := Pos;
--  BEGIN <Defer (for 'basic_name') at parser.lkt:497:17>
--  pos=Defer_Pos47, res=Defer_Res47, nobt=None
Defer_Res47 :=
   Basic_Name_Or_Parse0 (Parser, Row_Pos26);
Defer_Pos47 := Parser.Current_Pos;
--  END <Defer (for 'basic_name') at parser.lkt:497:17>
Row_Progress9 := 1;
if Defer_Pos47 /= No_Token_Index then
   Row_Pos26 := Defer_Pos47;
else
   Row_Pos26 := No_Token_Index;
   goto Exit_Row26_0;
end if;
--  BEGIN <Null (root of 'basic_name') at parser.lkt:497:28>
--  pos=Row_Pos26, res=Null_Res0, nobt=None
   Null_Res0 := Allocate_Null_Cond_Qualifier_Absent (Parser.Mem_Pool);
   Initialize
     (Self              => Null_Res0,
      Kind              => Lkt_Null_Cond_Qualifier_Absent,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos26,
      Token_End_Index   => No_Token_Index);
--  END <Null (root of 'basic_name') at parser.lkt:497:28>
Row_Progress9 := 2;
if Row_Pos26 /= No_Token_Index then
   Row_Pos26 := Row_Pos26;
else
   Row_Pos26 := No_Token_Index;
   goto Exit_Row26_0;
end if;
--  BEGIN <Token(<WithText Dot>, ) (root of 'basic_name') at parser.lkt:497:52>
--  pos=Token_Pos37, res=Token_Res37, nobt=None
Token_Res37 := Row_Pos26;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res37));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dot)
   then
       Token_Pos37 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos26 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos26,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Dot,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos37 := Row_Pos26 + 1;
   end if;
end;
--  END <Token(<WithText Dot>, ) (root of 'basic_name') at parser.lkt:497:52>
Row_Progress9 := 3;
if Token_Pos37 /= No_Token_Index then
   Row_Pos26 := Token_Pos37;
else
   Row_Pos26 := No_Token_Index;
   goto Exit_Row26_0;
end if;
--  BEGIN <Cut (root of 'basic_name') at parser.lkt:497:56>
--  pos=Row_Pos26, res=None, nobt=Nobt9
Nobt9 := True;
--  END <Cut (root of 'basic_name') at parser.lkt:497:56>
Row_Progress9 := 4;
if Row_Pos26 /= No_Token_Index then
   Row_Pos26 := Row_Pos26;
else
   Row_Pos26 := No_Token_Index;
   goto Exit_Row26_0;
end if;
--  BEGIN <Defer (for 'ref_id') at parser.lkt:497:58>
--  pos=Defer_Pos48, res=Defer_Res48, nobt=None
Defer_Res48 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos26);
Defer_Pos48 := Parser.Current_Pos;
--  END <Defer (for 'ref_id') at parser.lkt:497:58>
Row_Progress9 := 5;
if Defer_Pos48 /= No_Token_Index then
   Row_Pos26 := Defer_Pos48;
else
   Row_Pos26 := No_Token_Index;
   goto Exit_Row26_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row26_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'basic_name') at parser.lkt:497:9>
if Row_Pos26 = No_Token_Index and then Nobt9 then
   Row_Pos26 := Parser.Last_Fail.Pos;
   Transform_Has_Failed9 := True;
end if;
if Row_Pos26 /= No_Token_Index then
   Transform_Res24 := Allocate_Dot_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res24,
      Kind => Lkt_Dot_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos26 = Pos
                            then No_Token_Index
                            else Row_Pos26 - 1));
      Initialize_Fields_For_Dot_Expr
        (Self => Transform_Res24,
         Dot_Expr_F_Prefix => Defer_Res47,
         Dot_Expr_F_Null_Cond => Null_Res0,
         Dot_Expr_F_Suffix => Defer_Res48);
         if Defer_Res47 /= null and then Is_Incomplete (Defer_Res47) then
            Transform_Res24.Last_Attempted_Child := 0;
         elsif Defer_Res47 /= null and then not Is_Ghost (Defer_Res47) then
            Transform_Res24.Last_Attempted_Child := -1;
         end if;
         if Null_Res0 /= null and then Is_Incomplete (Null_Res0) then
            Transform_Res24.Last_Attempted_Child := 0;
         elsif Null_Res0 /= null and then not Is_Ghost (Null_Res0) then
            Transform_Res24.Last_Attempted_Child := -1;
         end if;
         if Defer_Res48 /= null and then Is_Incomplete (Defer_Res48) then
            Transform_Res24.Last_Attempted_Child := 0;
         elsif Defer_Res48 /= null and then not Is_Ghost (Defer_Res48) then
            Transform_Res24.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed9 then
      Transform_Res24.Last_Attempted_Child :=
         Row_Progress9;
      Append (Parser, Pos, "Cannot parse <basic_name>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType DotExpr>) (root of 'basic_name') at parser.lkt:497:9>
    if Row_Pos26 /= No_Token_Index then
        Or_Pos8 := Row_Pos26;
        Or_Res8 := Transform_Res24;
        goto Exit_Or9;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail8.Pos then
       Branch_Diag_Mark8 := Parser.Last_Diag;
       Branch_Last_Fail8 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark13;
    Parser.Last_Fail := Last_Fail8;
--  BEGIN <Defer (for 'ref_id') at parser.lkt:497:68>
--  pos=Defer_Pos49, res=Defer_Res49, nobt=None
Defer_Res49 :=
   Ref_Id_Transform_Parse0 (Parser, Pos);
Defer_Pos49 := Parser.Current_Pos;
--  END <Defer (for 'ref_id') at parser.lkt:497:68>
    if Defer_Pos49 /= No_Token_Index then
        Or_Pos8 := Defer_Pos49;
        Or_Res8 := Defer_Res49;
        goto Exit_Or9;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail8.Pos then
       Branch_Diag_Mark8 := Parser.Last_Diag;
       Branch_Last_Fail8 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark8;
Parser.Last_Fail := Branch_Last_Fail8;
<<Exit_Or9>>
--  END <Or (root of 'basic_name') at parser.lkt:496:19>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
      if Or_Pos8 > Mem_Pos then
         Mem_Pos := Or_Pos8;
         Mem_Res := Or_Res8;
         Mem_Mark := Parser.Last_Diag;
         if Or_Pos8 = No_Token_Index then
            Set_Failure (PP.Basic_Name_Or_Parse0_Memo, Pos, Parser.Last_Fail, Mem_Mark);
         else
            Memos.Set_Success
              (PP.Basic_Name_Or_Parse0_Memo,
               Pos,
               Or_Res8,
               Mem_Mark,
               Or_Pos8);
         end if;
         goto Try_Again;
      elsif Mem_Pos > Pos then
         Or_Res8 := Mem_Res;
         Or_Pos8 := Mem_Pos;
         Parser.Last_Diag := Mem_Mark;
         goto No_Memo;
      end if;
   if Or_Pos8 = No_Token_Index then
      Set_Failure
        (PP.Basic_Name_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Basic_Name_Or_Parse0_Memo, Pos, Or_Res8, Parser.Last_Diag, Or_Pos8);
   end if;
       <<No_Memo>>
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos8;
   return Or_Res8;
end Basic_Name_Or_Parse0;
   function Big_Num_Lit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Big_Num_Lit
is
      Row_Pos27 : Token_Index := No_Token_Index;
      Token_Pos38 : Token_Index := No_Token_Index;
      Token_Res38 : Token_Index := No_Token_Index;
      Transform_Res25 : Bare_Big_Num_Lit := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Big_Num_Lit_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res25 := M.Instance;
      return Transform_Res25;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res25;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType BigNumLit>) (root of 'big_num_lit') at parser.lkt:429:20>
--  pos=Row_Pos27, res=Transform_Res25, nobt=None
--  BEGIN <_Row (root of 'big_num_lit') at parser.lkt:429:20>
--  pos=Row_Pos27, res=None, nobt=None
Row_Pos27 := Pos;
--  BEGIN <Token(<WithText BigNumber>, ) (root of 'big_num_lit') at parser.lkt:429:30>
--  pos=Token_Pos38, res=Token_Res38, nobt=None
Token_Res38 := Row_Pos27;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res38));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Big_Number)
   then
       Token_Pos38 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos27 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos27,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Big_Number,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos38 := Row_Pos27 + 1;
   end if;
end;
--  END <Token(<WithText BigNumber>, ) (root of 'big_num_lit') at parser.lkt:429:30>
if Token_Pos38 /= No_Token_Index then
   Row_Pos27 := Token_Pos38;
else
   Row_Pos27 := No_Token_Index;
   goto Exit_Row27_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row27_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'big_num_lit') at parser.lkt:429:20>
if Row_Pos27 /= No_Token_Index then
   Transform_Res25 := Allocate_Big_Num_Lit (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res25,
      Kind => Lkt_Big_Num_Lit,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos27 = Pos
                            then No_Token_Index
                            else Row_Pos27 - 1));
      Initialize_Fields_For_Big_Num_Lit
        (Self => Transform_Res25);
end if;
--  END <Transform(<ASTNodeType BigNumLit>) (root of 'big_num_lit') at parser.lkt:429:20>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos27 = No_Token_Index then
      Set_Failure
        (PP.Big_Num_Lit_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Big_Num_Lit_Transform_Parse0_Memo, Pos, Transform_Res25, Parser.Last_Diag, Row_Pos27);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos27;
   return Transform_Res25;
end Big_Num_Lit_Transform_Parse0;
   function Block_Transform_Parse2
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Block_Expr
is
      Nobt10 : Boolean := False;
      Row_Pos28 : Token_Index := No_Token_Index;
      Token_Pos39 : Token_Index := No_Token_Index;
      Token_Res39 : Token_Index := No_Token_Index;
      Lst_Cpos2 : Token_Index := No_Token_Index;
      Tmp_List2 : Free_Parse_List;
      Row_Pos29 : Token_Index := No_Token_Index;
      Defer_Pos50 : Token_Index := No_Token_Index;
      Defer_Res50 : Bare_Var_Bind := No_Bare_Lkt_Node;
      Defer_Pos51 : Token_Index := No_Token_Index;
      Defer_Res51 : Bare_Full_Decl := No_Bare_Lkt_Node;
      Or_Pos9 : Token_Index := No_Token_Index;
      Or_Res9 : Bare_Lkt_Node := No_Bare_Lkt_Node;
      Diag_Mark14 : Diagnostic_Mark;
      Last_Fail9 : Fail_Info;
      Branch_Diag_Mark9 : Diagnostic_Mark;
      Branch_Last_Fail9 : Fail_Info;
      Token_Pos40 : Token_Index := No_Token_Index;
      Token_Res40 : Token_Index := No_Token_Index;
      Transform_Res26 : Bare_Block_Expr_Clause := No_Bare_Lkt_Node;
      Defer_Pos52 : Token_Index := No_Token_Index;
      Defer_Res52 : Bare_Expr := No_Bare_Lkt_Node;
      Row_Pos30 : Token_Index := No_Token_Index;
      Transform_Res27 : Bare_Error_Decl := No_Bare_Lkt_Node;
      Skip_Pos1 : Token_Index := No_Token_Index;
      Skip_Dummy1 : Bare_Lkt_Node := No_Bare_Lkt_Node;
      Or_Pos10 : Token_Index := No_Token_Index;
      Or_Res10 : Bare_Lkt_Node := No_Bare_Lkt_Node;
      Diag_Mark15 : Diagnostic_Mark;
      Last_Fail10 : Fail_Info;
      Branch_Diag_Mark10 : Diagnostic_Mark;
      Branch_Last_Fail10 : Fail_Info;
      List_Pos2 : Token_Index := No_Token_Index;
      List_Res2 : Bare_Lkt_Node_List := No_Bare_Lkt_Node;
      Diag_Mark16 : Diagnostic_Mark;
      Token_Pos41 : Token_Index := No_Token_Index;
      Token_Res41 : Token_Index := No_Token_Index;
      Row_Progress10 : Integer := 0;
      Transform_Res28 : Bare_Block_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed10 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Block_Transform_Parse2_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res28 := M.Instance;
      return Transform_Res28;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res28;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType BlockExpr>) (root of 'block') at parser.lkt:295:14>
--  pos=Row_Pos28, res=Transform_Res28, nobt=Nobt10
--  BEGIN <_Row (root of 'block') at parser.lkt:295:14>
--  pos=Row_Pos28, res=None, nobt=Nobt10
Row_Pos28 := Pos;
--  BEGIN <Token(<WithText LBrace>, ) (root of 'block') at parser.lkt:296:9>
--  pos=Token_Pos39, res=Token_Res39, nobt=None
Token_Res39 := Row_Pos28;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res39));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos39 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos28 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos28,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos39 := Row_Pos28 + 1;
   end if;
end;
--  END <Token(<WithText LBrace>, ) (root of 'block') at parser.lkt:296:9>
Row_Progress10 := 1;
if Token_Pos39 /= No_Token_Index then
   Row_Pos28 := Token_Pos39;
else
   Row_Pos28 := No_Token_Index;
   goto Exit_Row28_0;
end if;
--  BEGIN <Cut (root of 'block') at parser.lkt:297:9>
--  pos=Row_Pos28, res=None, nobt=Nobt10
Nobt10 := True;
--  END <Cut (root of 'block') at parser.lkt:297:9>
Row_Progress10 := 2;
if Row_Pos28 /= No_Token_Index then
   Row_Pos28 := Row_Pos28;
else
   Row_Pos28 := No_Token_Index;
   goto Exit_Row28_0;
end if;
--  BEGIN <DontSkip (root of 'block') at parser.lkt:298:9>
--  pos=List_Pos2, res=List_Res2, nobt=None
        PP.Dont_Skip.Append (Dontskip_Block0_Extract_Parse0'Access);
--  BEGIN <List (root of 'block') at parser.lkt:298:9>
--  pos=List_Pos2, res=List_Res2, nobt=None
    List_Pos2 := No_Token_Index;
Lst_Cpos2 := Row_Pos28;
Tmp_List2 := Get_Parse_List (Parser);
Diag_Mark16 := Parser.Last_Diag;
loop
--  BEGIN <Or (root of 'block') at parser.lkt:299:13>
--  pos=Or_Pos10, res=Or_Res10, nobt=None
Or_Pos10 := No_Token_Index;
Or_Res10 := No_Bare_Lkt_Node;
Diag_Mark15 := Parser.Last_Diag;
Last_Fail10 := Parser.Last_Fail;
Branch_Diag_Mark10 := Parser.Last_Diag;
Branch_Last_Fail10 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark15;
    Parser.Last_Fail := Last_Fail10;
--  BEGIN <Transform(<ASTNodeType BlockExprClause>) (root of 'block') at parser.lkt:300:19>
--  pos=Row_Pos29, res=Transform_Res26, nobt=None
--  BEGIN <_Row (root of 'block') at parser.lkt:300:19>
--  pos=Row_Pos29, res=None, nobt=None
Row_Pos29 := Lst_Cpos2;
--  BEGIN <Or (root of 'block') at parser.lkt:300:35>
--  pos=Or_Pos9, res=Or_Res9, nobt=None
Or_Pos9 := No_Token_Index;
Or_Res9 := No_Bare_Lkt_Node;
Diag_Mark14 := Parser.Last_Diag;
Last_Fail9 := Parser.Last_Fail;
Branch_Diag_Mark9 := Parser.Last_Diag;
Branch_Last_Fail9 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark14;
    Parser.Last_Fail := Last_Fail9;
--  BEGIN <Defer (for 'var_bind') at parser.lkt:300:38>
--  pos=Defer_Pos50, res=Defer_Res50, nobt=None
Defer_Res50 :=
   Var_Bind_Transform_Parse0 (Parser, Row_Pos29);
Defer_Pos50 := Parser.Current_Pos;
--  END <Defer (for 'var_bind') at parser.lkt:300:38>
    if Defer_Pos50 /= No_Token_Index then
        Or_Pos9 := Defer_Pos50;
        Or_Res9 := Defer_Res50;
        goto Exit_Or11;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail9.Pos then
       Branch_Diag_Mark9 := Parser.Last_Diag;
       Branch_Last_Fail9 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark14;
    Parser.Last_Fail := Last_Fail9;
--  BEGIN <Defer (for 'decl') at parser.lkt:300:49>
--  pos=Defer_Pos51, res=Defer_Res51, nobt=None
Defer_Res51 :=
   Decl_Transform_Parse0 (Parser, Row_Pos29);
Defer_Pos51 := Parser.Current_Pos;
--  END <Defer (for 'decl') at parser.lkt:300:49>
    if Defer_Pos51 /= No_Token_Index then
        Or_Pos9 := Defer_Pos51;
        Or_Res9 := Defer_Res51;
        goto Exit_Or11;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail9.Pos then
       Branch_Diag_Mark9 := Parser.Last_Diag;
       Branch_Last_Fail9 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark9;
Parser.Last_Fail := Branch_Last_Fail9;
<<Exit_Or11>>
--  END <Or (root of 'block') at parser.lkt:300:35>
if Or_Pos9 /= No_Token_Index then
   Row_Pos29 := Or_Pos9;
else
   Row_Pos29 := No_Token_Index;
   goto Exit_Row29_0;
end if;
--  BEGIN <Token(<WithText Semicolon>, ) (root of 'block') at parser.lkt:300:55>
--  pos=Token_Pos40, res=Token_Res40, nobt=None
Token_Res40 := Row_Pos29;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res40));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Semicolon)
   then
       Token_Pos40 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos29 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos29,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Semicolon,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos40 := Row_Pos29 + 1;
   end if;
end;
--  END <Token(<WithText Semicolon>, ) (root of 'block') at parser.lkt:300:55>
if Token_Pos40 /= No_Token_Index then
   Row_Pos29 := Token_Pos40;
else
   Row_Pos29 := No_Token_Index;
   goto Exit_Row29_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row29_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'block') at parser.lkt:300:19>
if Row_Pos29 /= No_Token_Index then
   Transform_Res26 := Allocate_Block_Expr_Clause (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res26,
      Kind => Lkt_Block_Expr_Clause,
      Unit => Parser.Unit,
      Token_Start_Index => Lst_Cpos2,
      Token_End_Index   => (if Row_Pos29 = Lst_Cpos2
                            then No_Token_Index
                            else Row_Pos29 - 1));
      Initialize_Fields_For_Block_Expr_Clause
        (Self => Transform_Res26,
         Block_Expr_Clause_F_Clause => Or_Res9);
         if Or_Res9 /= null and then Is_Incomplete (Or_Res9) then
            Transform_Res26.Last_Attempted_Child := 0;
         elsif Or_Res9 /= null and then not Is_Ghost (Or_Res9) then
            Transform_Res26.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType BlockExprClause>) (root of 'block') at parser.lkt:300:19>
    if Row_Pos29 /= No_Token_Index then
        Or_Pos10 := Row_Pos29;
        Or_Res10 := Transform_Res26;
        goto Exit_Or10;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail10.Pos then
       Branch_Diag_Mark10 := Parser.Last_Diag;
       Branch_Last_Fail10 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark15;
    Parser.Last_Fail := Last_Fail10;
--  BEGIN <Defer (for 'expr') at parser.lkt:301:19>
--  pos=Defer_Pos52, res=Defer_Res52, nobt=None
Defer_Res52 :=
   Expr_Or_Parse0 (Parser, Lst_Cpos2);
Defer_Pos52 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:301:19>
    if Defer_Pos52 /= No_Token_Index then
        Or_Pos10 := Defer_Pos52;
        Or_Res10 := Defer_Res52;
        goto Exit_Or10;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail10.Pos then
       Branch_Diag_Mark10 := Parser.Last_Diag;
       Branch_Last_Fail10 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark15;
    Parser.Last_Fail := Last_Fail10;
--  BEGIN <Skip (root of 'block') at parser.lkt:302:19>
--  pos=Skip_Pos1, res=Transform_Res27, nobt=None
if Get_Token (Parser.TDH.all, Lst_Cpos2).Kind
   = From_Token_Kind (Lkt_Termination)
then
   Skip_Pos1 := No_Token_Index;
   goto Exit_Or12;
end if;
for Fn of PP.Dont_Skip loop
   Skip_Dummy1 := Fn (Parser, Lst_Cpos2);
   if Parser.Current_Pos /= No_Token_Index  then
      Skip_Pos1 := No_Token_Index;
      goto Exit_Or12;
   end if;
end loop;
Skip_Pos1 := Lst_Cpos2 + 1;
--  BEGIN <Transform(<ASTNodeType ErrorDecl>) (root of 'block') at parser.lkt:302:19>
--  pos=Row_Pos30, res=Transform_Res27, nobt=None
--  BEGIN <_Row (root of 'block') at parser.lkt:302:19>
--  pos=Row_Pos30, res=None, nobt=None
Row_Pos30 := Lst_Cpos2;
pragma Warnings (Off, "referenced");
<<Exit_Row30_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'block') at parser.lkt:302:19>
if Row_Pos30 /= No_Token_Index then
   Transform_Res27 := Allocate_Error_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res27,
      Kind => Lkt_Error_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Lst_Cpos2,
      Token_End_Index   => (if Row_Pos30 = Lst_Cpos2
                            then No_Token_Index
                            else Row_Pos30 - 1));
end if;
--  END <Transform(<ASTNodeType ErrorDecl>) (root of 'block') at parser.lkt:302:19>
Transform_Res27.Token_End_Index := Lst_Cpos2;
declare
   Tok      : constant Token_Reference :=
     Wrap_Token_Reference
      (Parser.Unit.Context,
       Parser.TDH,
       (Lst_Cpos2, No_Token_Index));
   Tok_Text : constant Text_Type := Common.Text (Tok);
begin
   Append (Parser, Lst_Cpos2, "Skipped token " & Image (Tok_Text));
end;
<<Exit_Or12>>
--  END <Skip (root of 'block') at parser.lkt:302:19>
    if Skip_Pos1 /= No_Token_Index then
        Or_Pos10 := Skip_Pos1;
        Or_Res10 := Transform_Res27;
        goto Exit_Or10;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail10.Pos then
       Branch_Diag_Mark10 := Parser.Last_Diag;
       Branch_Last_Fail10 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark10;
Parser.Last_Fail := Branch_Last_Fail10;
<<Exit_Or10>>
--  END <Or (root of 'block') at parser.lkt:299:13>
   exit when Or_Pos10 = No_Token_Index;
   List_Pos2 := Or_Pos10;
   Lst_Cpos2 := List_Pos2;
   Diag_Mark16 := Parser.Last_Diag;
   Tmp_List2.Nodes.Append (Or_Res10);
end loop;
Parser.Last_Diag := Diag_Mark16;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List2.Nodes.Length;
begin
   List_Res2 := Allocate_Lkt_Node_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos28;
      Token_End := (if Lst_Cpos2 = Row_Pos28
                    then Row_Pos28
                    else List_Pos2 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos28, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res2,
      Kind              => Lkt_Lkt_Node_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res2,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List2.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res2.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List2);
--  END <List (root of 'block') at parser.lkt:298:9>
        PP.Dont_Skip.Delete_Last;
--  END <DontSkip (root of 'block') at parser.lkt:298:9>
Row_Progress10 := 3;
if List_Pos2 /= No_Token_Index then
   Row_Pos28 := List_Pos2;
else
   Row_Pos28 := No_Token_Index;
   goto Exit_Row28_0;
end if;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'block') at parser.lkt:305:9>
--  pos=Token_Pos41, res=Token_Res41, nobt=None
Token_Res41 := Row_Pos28;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res41));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos41 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos28 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos28,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos41 := Row_Pos28 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'block') at parser.lkt:305:9>
Row_Progress10 := 4;
if Token_Pos41 /= No_Token_Index then
   Row_Pos28 := Token_Pos41;
else
   Row_Pos28 := No_Token_Index;
   goto Exit_Row28_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row28_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'block') at parser.lkt:295:14>
if Row_Pos28 = No_Token_Index and then Nobt10 then
   Row_Pos28 := Parser.Last_Fail.Pos;
   Transform_Has_Failed10 := True;
end if;
if Row_Pos28 /= No_Token_Index then
   Transform_Res28 := Allocate_Block_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res28,
      Kind => Lkt_Block_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos28 = Pos
                            then No_Token_Index
                            else Row_Pos28 - 1));
      Initialize_Fields_For_Block_Expr
        (Self => Transform_Res28,
         Block_Expr_F_Clauses => List_Res2);
         if List_Res2 /= null and then Is_Incomplete (List_Res2) then
            Transform_Res28.Last_Attempted_Child := 0;
         elsif List_Res2 /= null and then not Is_Ghost (List_Res2) then
            Transform_Res28.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed10 then
      Transform_Res28.Last_Attempted_Child :=
         Row_Progress10;
      Append (Parser, Pos, "Cannot parse <block>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType BlockExpr>) (root of 'block') at parser.lkt:295:14>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos28 = No_Token_Index then
      Set_Failure
        (PP.Block_Transform_Parse2_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Block_Transform_Parse2_Memo, Pos, Transform_Res28, Parser.Last_Diag, Row_Pos28);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos28;
   return Transform_Res28;
end Block_Transform_Parse2;
   function Block_String_Lit_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Block_String_Lit
is
      Row_Pos31 : Token_Index := No_Token_Index;
      Lst_Cpos3 : Token_Index := No_Token_Index;
      Tmp_List3 : Free_Parse_List;
      Row_Pos32 : Token_Index := No_Token_Index;
      Token_Pos42 : Token_Index := No_Token_Index;
      Token_Res42 : Token_Index := No_Token_Index;
      Transform_Res29 : Bare_Block_String_Line := No_Bare_Lkt_Node;
      List_Pos3 : Token_Index := No_Token_Index;
      List_Res3 : Bare_Block_String_Line_List := No_Bare_Lkt_Node;
      Diag_Mark17 : Diagnostic_Mark;
      Transform_Res30 : Bare_Block_String_Lit := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Block_String_Lit_Transform_Parse1_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res30 := M.Instance;
      return Transform_Res30;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res30;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType BlockStringLit>) (root of 'block_string_lit') at parser.lkt:435:25>
--  pos=Row_Pos31, res=Transform_Res30, nobt=None
--  BEGIN <_Row (root of 'block_string_lit') at parser.lkt:435:25>
--  pos=Row_Pos31, res=None, nobt=None
Row_Pos31 := Pos;
--  BEGIN <List (root of 'block_string_lit') at parser.lkt:436:9>
--  pos=List_Pos3, res=List_Res3, nobt=None
    List_Pos3 := No_Token_Index;
Lst_Cpos3 := Row_Pos31;
Tmp_List3 := Get_Parse_List (Parser);
Diag_Mark17 := Parser.Last_Diag;
loop
--  BEGIN <Transform(<ASTNodeType BlockStringLine>) (root of 'block_string_lit') at parser.lkt:436:15>
--  pos=Row_Pos32, res=Transform_Res29, nobt=None
--  BEGIN <_Row (root of 'block_string_lit') at parser.lkt:436:15>
--  pos=Row_Pos32, res=None, nobt=None
Row_Pos32 := Lst_Cpos3;
--  BEGIN <Token(<WithText BlockStringLine>, ) (root of 'block_string_lit') at parser.lkt:436:31>
--  pos=Token_Pos42, res=Token_Res42, nobt=None
Token_Res42 := Row_Pos32;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res42));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Block_String_Line)
   then
       Token_Pos42 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos32 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos32,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Block_String_Line,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos42 := Row_Pos32 + 1;
   end if;
end;
--  END <Token(<WithText BlockStringLine>, ) (root of 'block_string_lit') at parser.lkt:436:31>
if Token_Pos42 /= No_Token_Index then
   Row_Pos32 := Token_Pos42;
else
   Row_Pos32 := No_Token_Index;
   goto Exit_Row32_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row32_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'block_string_lit') at parser.lkt:436:15>
if Row_Pos32 /= No_Token_Index then
   Transform_Res29 := Allocate_Block_String_Line (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res29,
      Kind => Lkt_Block_String_Line,
      Unit => Parser.Unit,
      Token_Start_Index => Lst_Cpos3,
      Token_End_Index   => (if Row_Pos32 = Lst_Cpos3
                            then No_Token_Index
                            else Row_Pos32 - 1));
end if;
--  END <Transform(<ASTNodeType BlockStringLine>) (root of 'block_string_lit') at parser.lkt:436:15>
   exit when Row_Pos32 = No_Token_Index;
   List_Pos3 := Row_Pos32;
   Lst_Cpos3 := List_Pos3;
   Diag_Mark17 := Parser.Last_Diag;
   Tmp_List3.Nodes.Append (Transform_Res29);
end loop;
Parser.Last_Diag := Diag_Mark17;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List3.Nodes.Length;
begin
   List_Res3 := Allocate_Block_String_Line_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos31;
      Token_End := (if Lst_Cpos3 = Row_Pos31
                    then Row_Pos31
                    else List_Pos3 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos31, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res3,
      Kind              => Lkt_Block_String_Line_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res3,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List3.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res3.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List3);
--  END <List (root of 'block_string_lit') at parser.lkt:436:9>
if List_Pos3 /= No_Token_Index then
   Row_Pos31 := List_Pos3;
else
   Row_Pos31 := No_Token_Index;
   goto Exit_Row31_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row31_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'block_string_lit') at parser.lkt:435:25>
if Row_Pos31 /= No_Token_Index then
   Transform_Res30 := Allocate_Block_String_Lit (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res30,
      Kind => Lkt_Block_String_Lit,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos31 = Pos
                            then No_Token_Index
                            else Row_Pos31 - 1));
      Initialize_Fields_For_Block_String_Lit
        (Self => Transform_Res30,
         Block_String_Lit_F_Lines => List_Res3);
         if List_Res3 /= null and then Is_Incomplete (List_Res3) then
            Transform_Res30.Last_Attempted_Child := 0;
         elsif List_Res3 /= null and then not Is_Ghost (List_Res3) then
            Transform_Res30.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType BlockStringLit>) (root of 'block_string_lit') at parser.lkt:435:25>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos31 = No_Token_Index then
      Set_Failure
        (PP.Block_String_Lit_Transform_Parse1_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Block_String_Lit_Transform_Parse1_Memo, Pos, Transform_Res30, Parser.Last_Diag, Row_Pos31);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos31;
   return Transform_Res30;
end Block_String_Lit_Transform_Parse1;
   function Bool_Pattern_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Bool_Pattern
is
      Row_Pos33 : Token_Index := No_Token_Index;
      Token_Pos43 : Token_Index := No_Token_Index;
      Token_Res43 : Token_Index := No_Token_Index;
      Transform_Res31 : Bare_Bool_Pattern_True := No_Bare_Lkt_Node;
      Row_Pos34 : Token_Index := No_Token_Index;
      Token_Pos44 : Token_Index := No_Token_Index;
      Token_Res44 : Token_Index := No_Token_Index;
      Transform_Res32 : Bare_Bool_Pattern_False := No_Bare_Lkt_Node;
      Or_Pos11 : Token_Index := No_Token_Index;
      Or_Res11 : Bare_Bool_Pattern := No_Bare_Lkt_Node;
      Diag_Mark18 : Diagnostic_Mark;
      Last_Fail11 : Fail_Info;
      Branch_Diag_Mark11 : Diagnostic_Mark;
      Branch_Last_Fail11 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Bool_Pattern_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res11 := M.Instance;
      return Or_Res11;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res11;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'bool_pattern') at parser.lkt:336:21>
--  pos=Or_Pos11, res=Or_Res11, nobt=None
Or_Pos11 := No_Token_Index;
Or_Res11 := No_Bare_Lkt_Node;
Diag_Mark18 := Parser.Last_Diag;
Last_Fail11 := Parser.Last_Fail;
Branch_Diag_Mark11 := Parser.Last_Diag;
Branch_Last_Fail11 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark18;
    Parser.Last_Fail := Last_Fail11;
--  BEGIN <Transform(<ASTNodeType BoolPattern.True>) (root of 'bool_pattern') at parser.lkt:337:11>
--  pos=Row_Pos33, res=Transform_Res31, nobt=None
--  BEGIN <_Row (root of 'bool_pattern') at parser.lkt:337:11>
--  pos=Row_Pos33, res=None, nobt=None
Row_Pos33 := Pos;
--  BEGIN <Token(<WithSymbol Identifier>, true) (root of 'bool_pattern') at parser.lkt:337:28>
--  pos=Token_Pos43, res=Token_Res43, nobt=None
Token_Res43 := Row_Pos33;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res43));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_True)
   then
       Token_Pos43 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos33 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos33,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos43 := Row_Pos33 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, true) (root of 'bool_pattern') at parser.lkt:337:28>
if Token_Pos43 /= No_Token_Index then
   Row_Pos33 := Token_Pos43;
else
   Row_Pos33 := No_Token_Index;
   goto Exit_Row33_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row33_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'bool_pattern') at parser.lkt:337:11>
if Row_Pos33 /= No_Token_Index then
   Transform_Res31 := Allocate_Bool_Pattern_True (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res31,
      Kind => Lkt_Bool_Pattern_True,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos33 = Pos
                            then No_Token_Index
                            else Row_Pos33 - 1));
end if;
--  END <Transform(<ASTNodeType BoolPattern.True>) (root of 'bool_pattern') at parser.lkt:337:11>
    if Row_Pos33 /= No_Token_Index then
        Or_Pos11 := Row_Pos33;
        Or_Res11 := Transform_Res31;
        goto Exit_Or13;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail11.Pos then
       Branch_Diag_Mark11 := Parser.Last_Diag;
       Branch_Last_Fail11 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark18;
    Parser.Last_Fail := Last_Fail11;
--  BEGIN <Transform(<ASTNodeType BoolPattern.False>) (root of 'bool_pattern') at parser.lkt:338:11>
--  pos=Row_Pos34, res=Transform_Res32, nobt=None
--  BEGIN <_Row (root of 'bool_pattern') at parser.lkt:338:11>
--  pos=Row_Pos34, res=None, nobt=None
Row_Pos34 := Pos;
--  BEGIN <Token(<WithSymbol Identifier>, false) (root of 'bool_pattern') at parser.lkt:338:29>
--  pos=Token_Pos44, res=Token_Res44, nobt=None
Token_Res44 := Row_Pos34;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res44));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_False)
   then
       Token_Pos44 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos34 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos34,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos44 := Row_Pos34 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, false) (root of 'bool_pattern') at parser.lkt:338:29>
if Token_Pos44 /= No_Token_Index then
   Row_Pos34 := Token_Pos44;
else
   Row_Pos34 := No_Token_Index;
   goto Exit_Row34_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row34_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'bool_pattern') at parser.lkt:338:11>
if Row_Pos34 /= No_Token_Index then
   Transform_Res32 := Allocate_Bool_Pattern_False (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res32,
      Kind => Lkt_Bool_Pattern_False,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos34 = Pos
                            then No_Token_Index
                            else Row_Pos34 - 1));
end if;
--  END <Transform(<ASTNodeType BoolPattern.False>) (root of 'bool_pattern') at parser.lkt:338:11>
    if Row_Pos34 /= No_Token_Index then
        Or_Pos11 := Row_Pos34;
        Or_Res11 := Transform_Res32;
        goto Exit_Or13;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail11.Pos then
       Branch_Diag_Mark11 := Parser.Last_Diag;
       Branch_Last_Fail11 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark11;
Parser.Last_Fail := Branch_Last_Fail11;
<<Exit_Or13>>
--  END <Or (root of 'bool_pattern') at parser.lkt:336:21>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos11 = No_Token_Index then
      Set_Failure
        (PP.Bool_Pattern_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Bool_Pattern_Or_Parse0_Memo, Pos, Or_Res11, Parser.Last_Diag, Or_Pos11);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos11;
   return Or_Res11;
end Bool_Pattern_Or_Parse0;
   function Callable_Ref_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
      Row_Pos35 : Token_Index := No_Token_Index;
      Defer_Pos53 : Token_Index := No_Token_Index;
      Defer_Res53 : Bare_Expr := No_Bare_Lkt_Node;
      Null_Res1 : Bare_Null_Cond_Qualifier := No_Bare_Lkt_Node;
      Token_Pos45 : Token_Index := No_Token_Index;
      Token_Res45 : Token_Index := No_Token_Index;
      Defer_Pos54 : Token_Index := No_Token_Index;
      Defer_Res54 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Transform_Res33 : Bare_Dot_Expr := No_Bare_Lkt_Node;
      Defer_Pos55 : Token_Index := No_Token_Index;
      Defer_Res55 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Or_Pos12 : Token_Index := No_Token_Index;
      Or_Res12 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark19 : Diagnostic_Mark;
      Last_Fail12 : Fail_Info;
      Branch_Diag_Mark12 : Diagnostic_Mark;
      Branch_Last_Fail12 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
      Mem_Pos  : Token_Index := Pos;
      Mem_Res  : Bare_Expr := No_Bare_Lkt_Node;
      Mem_Mark : Diagnostic_Mark := Mark_On_Entry;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Callable_Ref_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res12 := M.Instance;
      return Or_Res12;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res12;
   end if;
   Parser.Last_Diag := No_Diagnostic;
       Set_Failure
         (PP.Callable_Ref_Or_Parse0_Memo,
          Pos,
          Parser.Last_Fail,
          Parser.Last_Diag);
       <<Try_Again>>
       Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'callable_ref') at parser.lkt:454:21>
--  pos=Or_Pos12, res=Or_Res12, nobt=None
Or_Pos12 := No_Token_Index;
Or_Res12 := No_Bare_Lkt_Node;
Diag_Mark19 := Parser.Last_Diag;
Last_Fail12 := Parser.Last_Fail;
Branch_Diag_Mark12 := Parser.Last_Diag;
Branch_Last_Fail12 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark19;
    Parser.Last_Fail := Last_Fail12;
--  BEGIN <Transform(<ASTNodeType DotExpr>) (root of 'callable_ref') at parser.lkt:455:9>
--  pos=Row_Pos35, res=Transform_Res33, nobt=None
--  BEGIN <_Row (root of 'callable_ref') at parser.lkt:455:9>
--  pos=Row_Pos35, res=None, nobt=None
Row_Pos35 := Pos;
--  BEGIN <Defer (for 'callable_ref') at parser.lkt:455:17>
--  pos=Defer_Pos53, res=Defer_Res53, nobt=None
Defer_Res53 :=
   Callable_Ref_Or_Parse0 (Parser, Row_Pos35);
Defer_Pos53 := Parser.Current_Pos;
--  END <Defer (for 'callable_ref') at parser.lkt:455:17>
if Defer_Pos53 /= No_Token_Index then
   Row_Pos35 := Defer_Pos53;
else
   Row_Pos35 := No_Token_Index;
   goto Exit_Row35_0;
end if;
--  BEGIN <Null (root of 'callable_ref') at parser.lkt:455:30>
--  pos=Row_Pos35, res=Null_Res1, nobt=None
   Null_Res1 := Allocate_Null_Cond_Qualifier_Absent (Parser.Mem_Pool);
   Initialize
     (Self              => Null_Res1,
      Kind              => Lkt_Null_Cond_Qualifier_Absent,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos35,
      Token_End_Index   => No_Token_Index);
--  END <Null (root of 'callable_ref') at parser.lkt:455:30>
if Row_Pos35 /= No_Token_Index then
   Row_Pos35 := Row_Pos35;
else
   Row_Pos35 := No_Token_Index;
   goto Exit_Row35_0;
end if;
--  BEGIN <Token(<WithText Dot>, ) (root of 'callable_ref') at parser.lkt:455:54>
--  pos=Token_Pos45, res=Token_Res45, nobt=None
Token_Res45 := Row_Pos35;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res45));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dot)
   then
       Token_Pos45 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos35 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos35,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Dot,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos45 := Row_Pos35 + 1;
   end if;
end;
--  END <Token(<WithText Dot>, ) (root of 'callable_ref') at parser.lkt:455:54>
if Token_Pos45 /= No_Token_Index then
   Row_Pos35 := Token_Pos45;
else
   Row_Pos35 := No_Token_Index;
   goto Exit_Row35_0;
end if;
--  BEGIN <Defer (for 'ref_id') at parser.lkt:455:58>
--  pos=Defer_Pos54, res=Defer_Res54, nobt=None
Defer_Res54 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos35);
Defer_Pos54 := Parser.Current_Pos;
--  END <Defer (for 'ref_id') at parser.lkt:455:58>
if Defer_Pos54 /= No_Token_Index then
   Row_Pos35 := Defer_Pos54;
else
   Row_Pos35 := No_Token_Index;
   goto Exit_Row35_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row35_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'callable_ref') at parser.lkt:455:9>
if Row_Pos35 /= No_Token_Index then
   Transform_Res33 := Allocate_Dot_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res33,
      Kind => Lkt_Dot_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos35 = Pos
                            then No_Token_Index
                            else Row_Pos35 - 1));
      Initialize_Fields_For_Dot_Expr
        (Self => Transform_Res33,
         Dot_Expr_F_Prefix => Defer_Res53,
         Dot_Expr_F_Null_Cond => Null_Res1,
         Dot_Expr_F_Suffix => Defer_Res54);
         if Defer_Res53 /= null and then Is_Incomplete (Defer_Res53) then
            Transform_Res33.Last_Attempted_Child := 0;
         elsif Defer_Res53 /= null and then not Is_Ghost (Defer_Res53) then
            Transform_Res33.Last_Attempted_Child := -1;
         end if;
         if Null_Res1 /= null and then Is_Incomplete (Null_Res1) then
            Transform_Res33.Last_Attempted_Child := 0;
         elsif Null_Res1 /= null and then not Is_Ghost (Null_Res1) then
            Transform_Res33.Last_Attempted_Child := -1;
         end if;
         if Defer_Res54 /= null and then Is_Incomplete (Defer_Res54) then
            Transform_Res33.Last_Attempted_Child := 0;
         elsif Defer_Res54 /= null and then not Is_Ghost (Defer_Res54) then
            Transform_Res33.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType DotExpr>) (root of 'callable_ref') at parser.lkt:455:9>
    if Row_Pos35 /= No_Token_Index then
        Or_Pos12 := Row_Pos35;
        Or_Res12 := Transform_Res33;
        goto Exit_Or14;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail12.Pos then
       Branch_Diag_Mark12 := Parser.Last_Diag;
       Branch_Last_Fail12 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark19;
    Parser.Last_Fail := Last_Fail12;
--  BEGIN <Defer (for 'ref_id') at parser.lkt:455:68>
--  pos=Defer_Pos55, res=Defer_Res55, nobt=None
Defer_Res55 :=
   Ref_Id_Transform_Parse0 (Parser, Pos);
Defer_Pos55 := Parser.Current_Pos;
--  END <Defer (for 'ref_id') at parser.lkt:455:68>
    if Defer_Pos55 /= No_Token_Index then
        Or_Pos12 := Defer_Pos55;
        Or_Res12 := Defer_Res55;
        goto Exit_Or14;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail12.Pos then
       Branch_Diag_Mark12 := Parser.Last_Diag;
       Branch_Last_Fail12 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark12;
Parser.Last_Fail := Branch_Last_Fail12;
<<Exit_Or14>>
--  END <Or (root of 'callable_ref') at parser.lkt:454:21>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
      if Or_Pos12 > Mem_Pos then
         Mem_Pos := Or_Pos12;
         Mem_Res := Or_Res12;
         Mem_Mark := Parser.Last_Diag;
         if Or_Pos12 = No_Token_Index then
            Set_Failure (PP.Callable_Ref_Or_Parse0_Memo, Pos, Parser.Last_Fail, Mem_Mark);
         else
            Memos.Set_Success
              (PP.Callable_Ref_Or_Parse0_Memo,
               Pos,
               Or_Res12,
               Mem_Mark,
               Or_Pos12);
         end if;
         goto Try_Again;
      elsif Mem_Pos > Pos then
         Or_Res12 := Mem_Res;
         Or_Pos12 := Mem_Pos;
         Parser.Last_Diag := Mem_Mark;
         goto No_Memo;
      end if;
   if Or_Pos12 = No_Token_Index then
      Set_Failure
        (PP.Callable_Ref_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Callable_Ref_Or_Parse0_Memo, Pos, Or_Res12, Parser.Last_Diag, Or_Pos12);
   end if;
       <<No_Memo>>
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos12;
   return Or_Res12;
end Callable_Ref_Or_Parse0;
   function Char_Lit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Char_Lit
is
      Row_Pos36 : Token_Index := No_Token_Index;
      Token_Pos46 : Token_Index := No_Token_Index;
      Token_Res46 : Token_Index := No_Token_Index;
      Transform_Res34 : Bare_Char_Lit := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Char_Lit_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res34 := M.Instance;
      return Transform_Res34;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res34;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType CharLit>) (root of 'char_lit') at parser.lkt:438:17>
--  pos=Row_Pos36, res=Transform_Res34, nobt=None
--  BEGIN <_Row (root of 'char_lit') at parser.lkt:438:17>
--  pos=Row_Pos36, res=None, nobt=None
Row_Pos36 := Pos;
--  BEGIN <Token(<WithText Char>, ) (root of 'char_lit') at parser.lkt:438:25>
--  pos=Token_Pos46, res=Token_Res46, nobt=None
Token_Res46 := Row_Pos36;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res46));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Char)
   then
       Token_Pos46 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos36 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos36,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Char,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos46 := Row_Pos36 + 1;
   end if;
end;
--  END <Token(<WithText Char>, ) (root of 'char_lit') at parser.lkt:438:25>
if Token_Pos46 /= No_Token_Index then
   Row_Pos36 := Token_Pos46;
else
   Row_Pos36 := No_Token_Index;
   goto Exit_Row36_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row36_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'char_lit') at parser.lkt:438:17>
if Row_Pos36 /= No_Token_Index then
   Transform_Res34 := Allocate_Char_Lit (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res34,
      Kind => Lkt_Char_Lit,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos36 = Pos
                            then No_Token_Index
                            else Row_Pos36 - 1));
      Initialize_Fields_For_Char_Lit
        (Self => Transform_Res34);
end if;
--  END <Transform(<ASTNodeType CharLit>) (root of 'char_lit') at parser.lkt:438:17>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos36 = No_Token_Index then
      Set_Failure
        (PP.Char_Lit_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Char_Lit_Transform_Parse0_Memo, Pos, Transform_Res34, Parser.Last_Diag, Row_Pos36);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos36;
   return Transform_Res34;
end Char_Lit_Transform_Parse0;
   function Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Full_Decl
is
      Row_Pos37 : Token_Index := No_Token_Index;
      Defer_Pos56 : Token_Index := No_Token_Index;
      Defer_Res56 : Bare_String_Lit := No_Bare_Lkt_Node;
      Lst_Cpos4 : Token_Index := No_Token_Index;
      Tmp_List4 : Free_Parse_List;
      Defer_Pos57 : Token_Index := No_Token_Index;
      Defer_Res57 : Bare_Decl_Annotation := No_Bare_Lkt_Node;
      List_Pos4 : Token_Index := No_Token_Index;
      List_Res4 : Bare_Decl_Annotation_List := No_Bare_Lkt_Node;
      Diag_Mark20 : Diagnostic_Mark;
      Defer_Pos58 : Token_Index := No_Token_Index;
      Defer_Res58 : Bare_Decl := No_Bare_Lkt_Node;
      Transform_Res35 : Bare_Full_Decl := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Decl_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res35 := M.Instance;
      return Transform_Res35;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res35;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType FullDecl>) (root of 'decl') at parser.lkt:273:13>
--  pos=Row_Pos37, res=Transform_Res35, nobt=None
--  BEGIN <_Row (root of 'decl') at parser.lkt:273:13>
--  pos=Row_Pos37, res=None, nobt=None
Row_Pos37 := Pos;
--  BEGIN <Defer (for 'doc') at parser.lkt:273:22>
--  pos=Defer_Pos56, res=Defer_Res56, nobt=None
Defer_Res56 :=
   Doc_Opt_Parse0 (Parser, Row_Pos37);
Defer_Pos56 := Parser.Current_Pos;
--  END <Defer (for 'doc') at parser.lkt:273:22>
if Defer_Pos56 /= No_Token_Index then
   Row_Pos37 := Defer_Pos56;
else
   Row_Pos37 := No_Token_Index;
   goto Exit_Row37_0;
end if;
--  BEGIN <List (root of 'decl') at parser.lkt:273:26>
--  pos=List_Pos4, res=List_Res4, nobt=None
    List_Pos4 := Row_Pos37;
Lst_Cpos4 := Row_Pos37;
Tmp_List4 := Get_Parse_List (Parser);
Diag_Mark20 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'decl_annotation') at parser.lkt:273:32>
--  pos=Defer_Pos57, res=Defer_Res57, nobt=None
Defer_Res57 :=
   Decl_Annotation_Transform_Parse0 (Parser, Lst_Cpos4);
Defer_Pos57 := Parser.Current_Pos;
--  END <Defer (for 'decl_annotation') at parser.lkt:273:32>
   exit when Defer_Pos57 = No_Token_Index;
   List_Pos4 := Defer_Pos57;
   Lst_Cpos4 := List_Pos4;
   Diag_Mark20 := Parser.Last_Diag;
   Tmp_List4.Nodes.Append (Defer_Res57);
end loop;
Parser.Last_Diag := Diag_Mark20;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List4.Nodes.Length;
begin
   List_Res4 := Allocate_Decl_Annotation_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos37;
      Token_End := (if Lst_Cpos4 = Row_Pos37
                    then Row_Pos37
                    else List_Pos4 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos37, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res4,
      Kind              => Lkt_Decl_Annotation_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res4,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List4.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res4.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List4);
--  END <List (root of 'decl') at parser.lkt:273:26>
if List_Pos4 /= No_Token_Index then
   Row_Pos37 := List_Pos4;
else
   Row_Pos37 := No_Token_Index;
   goto Exit_Row37_0;
end if;
--  BEGIN <Defer (for 'bare_decl') at parser.lkt:273:49>
--  pos=Defer_Pos58, res=Defer_Res58, nobt=None
Defer_Res58 :=
   Bare_Decl_Or_Parse0 (Parser, Row_Pos37);
Defer_Pos58 := Parser.Current_Pos;
--  END <Defer (for 'bare_decl') at parser.lkt:273:49>
if Defer_Pos58 /= No_Token_Index then
   Row_Pos37 := Defer_Pos58;
else
   Row_Pos37 := No_Token_Index;
   goto Exit_Row37_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row37_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'decl') at parser.lkt:273:13>
if Row_Pos37 /= No_Token_Index then
   Transform_Res35 := Allocate_Full_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res35,
      Kind => Lkt_Full_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos37 = Pos
                            then No_Token_Index
                            else Row_Pos37 - 1));
      Initialize_Fields_For_Full_Decl
        (Self => Transform_Res35,
         Full_Decl_F_Doc => Defer_Res56,
         Full_Decl_F_Decl_Annotations => List_Res4,
         Full_Decl_F_Decl => Defer_Res58);
         if Defer_Res56 /= null and then Is_Incomplete (Defer_Res56) then
            Transform_Res35.Last_Attempted_Child := 0;
         elsif Defer_Res56 /= null and then not Is_Ghost (Defer_Res56) then
            Transform_Res35.Last_Attempted_Child := -1;
         end if;
         if List_Res4 /= null and then Is_Incomplete (List_Res4) then
            Transform_Res35.Last_Attempted_Child := 0;
         elsif List_Res4 /= null and then not Is_Ghost (List_Res4) then
            Transform_Res35.Last_Attempted_Child := -1;
         end if;
         if Defer_Res58 /= null and then Is_Incomplete (Defer_Res58) then
            Transform_Res35.Last_Attempted_Child := 0;
         elsif Defer_Res58 /= null and then not Is_Ghost (Defer_Res58) then
            Transform_Res35.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType FullDecl>) (root of 'decl') at parser.lkt:273:13>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos37 = No_Token_Index then
      Set_Failure
        (PP.Decl_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Decl_Transform_Parse0_Memo, Pos, Transform_Res35, Parser.Last_Diag, Row_Pos37);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos37;
   return Transform_Res35;
end Decl_Transform_Parse0;
   function Decl_Annotation_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decl_Annotation
is
      Nobt11 : Boolean := False;
      Row_Pos38 : Token_Index := No_Token_Index;
      Token_Pos47 : Token_Index := No_Token_Index;
      Token_Res47 : Token_Index := No_Token_Index;
      Defer_Pos59 : Token_Index := No_Token_Index;
      Defer_Res59 : Bare_Id := No_Bare_Lkt_Node;
      Defer_Pos60 : Token_Index := No_Token_Index;
      Defer_Res60 : Bare_Decl_Annotation_Args := No_Bare_Lkt_Node;
      Row_Progress11 : Integer := 0;
      Transform_Res36 : Bare_Decl_Annotation := No_Bare_Lkt_Node;
      Transform_Has_Failed11 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Decl_Annotation_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res36 := M.Instance;
      return Transform_Res36;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res36;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType DeclAnnotation>) (root of 'decl_annotation') at parser.lkt:506:24>
--  pos=Row_Pos38, res=Transform_Res36, nobt=Nobt11
--  BEGIN <_Row (root of 'decl_annotation') at parser.lkt:506:24>
--  pos=Row_Pos38, res=None, nobt=Nobt11
Row_Pos38 := Pos;
--  BEGIN <Token(<WithText At>, ) (root of 'decl_annotation') at parser.lkt:506:39>
--  pos=Token_Pos47, res=Token_Res47, nobt=None
Token_Res47 := Row_Pos38;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res47));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_At)
   then
       Token_Pos47 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos38 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos38,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_At,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos47 := Row_Pos38 + 1;
   end if;
end;
--  END <Token(<WithText At>, ) (root of 'decl_annotation') at parser.lkt:506:39>
Row_Progress11 := 1;
if Token_Pos47 /= No_Token_Index then
   Row_Pos38 := Token_Pos47;
else
   Row_Pos38 := No_Token_Index;
   goto Exit_Row38_0;
end if;
--  BEGIN <Cut (root of 'decl_annotation') at parser.lkt:506:43>
--  pos=Row_Pos38, res=None, nobt=Nobt11
Nobt11 := True;
--  END <Cut (root of 'decl_annotation') at parser.lkt:506:43>
Row_Progress11 := 2;
if Row_Pos38 /= No_Token_Index then
   Row_Pos38 := Row_Pos38;
else
   Row_Pos38 := No_Token_Index;
   goto Exit_Row38_0;
end if;
--  BEGIN <Defer (for 'id') at parser.lkt:506:45>
--  pos=Defer_Pos59, res=Defer_Res59, nobt=None
Defer_Res59 :=
   Id_Transform_Parse0 (Parser, Row_Pos38);
Defer_Pos59 := Parser.Current_Pos;
--  END <Defer (for 'id') at parser.lkt:506:45>
Row_Progress11 := 3;
if Defer_Pos59 /= No_Token_Index then
   Row_Pos38 := Defer_Pos59;
else
   Row_Pos38 := No_Token_Index;
   goto Exit_Row38_0;
end if;
--  BEGIN <Defer (for 'decl_annotation_args') at parser.lkt:506:48>
--  pos=Defer_Pos60, res=Defer_Res60, nobt=None
Defer_Res60 :=
   Decl_Annotation_Args_Opt_Parse0 (Parser, Row_Pos38);
Defer_Pos60 := Parser.Current_Pos;
--  END <Defer (for 'decl_annotation_args') at parser.lkt:506:48>
Row_Progress11 := 4;
if Defer_Pos60 /= No_Token_Index then
   Row_Pos38 := Defer_Pos60;
else
   Row_Pos38 := No_Token_Index;
   goto Exit_Row38_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row38_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'decl_annotation') at parser.lkt:506:24>
if Row_Pos38 = No_Token_Index and then Nobt11 then
   Row_Pos38 := Parser.Last_Fail.Pos;
   Transform_Has_Failed11 := True;
end if;
if Row_Pos38 /= No_Token_Index then
   Transform_Res36 := Allocate_Decl_Annotation (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res36,
      Kind => Lkt_Decl_Annotation,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos38 = Pos
                            then No_Token_Index
                            else Row_Pos38 - 1));
      Initialize_Fields_For_Decl_Annotation
        (Self => Transform_Res36,
         Decl_Annotation_F_Name => Defer_Res59,
         Decl_Annotation_F_Args => Defer_Res60);
         if Defer_Res59 /= null and then Is_Incomplete (Defer_Res59) then
            Transform_Res36.Last_Attempted_Child := 0;
         elsif Defer_Res59 /= null and then not Is_Ghost (Defer_Res59) then
            Transform_Res36.Last_Attempted_Child := -1;
         end if;
         if Defer_Res60 /= null and then Is_Incomplete (Defer_Res60) then
            Transform_Res36.Last_Attempted_Child := 0;
         elsif Defer_Res60 /= null and then not Is_Ghost (Defer_Res60) then
            Transform_Res36.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed11 then
      Transform_Res36.Last_Attempted_Child :=
         Row_Progress11;
      Append (Parser, Pos, "Cannot parse <decl_annotation>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType DeclAnnotation>) (root of 'decl_annotation') at parser.lkt:506:24>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos38 = No_Token_Index then
      Set_Failure
        (PP.Decl_Annotation_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Decl_Annotation_Transform_Parse0_Memo, Pos, Transform_Res36, Parser.Last_Diag, Row_Pos38);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos38;
   return Transform_Res36;
end Decl_Annotation_Transform_Parse0;
   function Decl_Annotation_Args_Opt_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decl_Annotation_Args
is
      Row_Pos39 : Token_Index := No_Token_Index;
      Token_Pos48 : Token_Index := No_Token_Index;
      Token_Res48 : Token_Index := No_Token_Index;
      Defer_Pos61 : Token_Index := No_Token_Index;
      Defer_Res61 : Bare_Argument_List := No_Bare_Lkt_Node;
      Token_Pos49 : Token_Index := No_Token_Index;
      Token_Res49 : Token_Index := No_Token_Index;
      Transform_Res37 : Bare_Decl_Annotation_Args := No_Bare_Lkt_Node;
      Diag_Mark21 : Diagnostic_Mark;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Decl_Annotation_Args_Opt_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res37 := M.Instance;
      return Transform_Res37;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res37;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Opt (root of 'decl_annotation_args') at parser.lkt:505:29>
--  pos=Row_Pos39, res=Transform_Res37, nobt=None
Diag_Mark21 := Parser.Last_Diag;
--  BEGIN <Transform(<ASTNodeType DeclAnnotationArgs>) (root of 'decl_annotation_args') at parser.lkt:505:30>
--  pos=Row_Pos39, res=Transform_Res37, nobt=None
--  BEGIN <_Row (root of 'decl_annotation_args') at parser.lkt:505:30>
--  pos=Row_Pos39, res=None, nobt=None
Row_Pos39 := Pos;
--  BEGIN <Token(<WithText LPar>, ) (root of 'decl_annotation_args') at parser.lkt:505:49>
--  pos=Token_Pos48, res=Token_Res48, nobt=None
Token_Res48 := Row_Pos39;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res48));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos48 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos39 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos39,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos48 := Row_Pos39 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'decl_annotation_args') at parser.lkt:505:49>
if Token_Pos48 /= No_Token_Index then
   Row_Pos39 := Token_Pos48;
else
   Row_Pos39 := No_Token_Index;
   goto Exit_Row39_0;
end if;
--  BEGIN <Defer (for 'args') at parser.lkt:505:53>
--  pos=Defer_Pos61, res=Defer_Res61, nobt=None
Defer_Res61 :=
   Args_List_Parse0 (Parser, Row_Pos39);
Defer_Pos61 := Parser.Current_Pos;
--  END <Defer (for 'args') at parser.lkt:505:53>
if Defer_Pos61 /= No_Token_Index then
   Row_Pos39 := Defer_Pos61;
else
   Row_Pos39 := No_Token_Index;
   goto Exit_Row39_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'decl_annotation_args') at parser.lkt:505:58>
--  pos=Token_Pos49, res=Token_Res49, nobt=None
Token_Res49 := Row_Pos39;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res49));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos49 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos39 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos39,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos49 := Row_Pos39 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'decl_annotation_args') at parser.lkt:505:58>
if Token_Pos49 /= No_Token_Index then
   Row_Pos39 := Token_Pos49;
else
   Row_Pos39 := No_Token_Index;
   goto Exit_Row39_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row39_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'decl_annotation_args') at parser.lkt:505:30>
if Row_Pos39 /= No_Token_Index then
   Transform_Res37 := Allocate_Decl_Annotation_Args (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res37,
      Kind => Lkt_Decl_Annotation_Args,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos39 = Pos
                            then No_Token_Index
                            else Row_Pos39 - 1));
      Initialize_Fields_For_Decl_Annotation_Args
        (Self => Transform_Res37,
         Decl_Annotation_Args_F_Args => Defer_Res61);
         if Defer_Res61 /= null and then Is_Incomplete (Defer_Res61) then
            Transform_Res37.Last_Attempted_Child := 0;
         elsif Defer_Res61 /= null and then not Is_Ghost (Defer_Res61) then
            Transform_Res37.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType DeclAnnotationArgs>) (root of 'decl_annotation_args') at parser.lkt:505:30>
if Row_Pos39 = No_Token_Index then
   Transform_Res37 := No_Bare_Lkt_Node;
   Row_Pos39 := Pos;
      Parser.Last_Diag := Diag_Mark21;
end if;
--  END <Opt (root of 'decl_annotation_args') at parser.lkt:505:29>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos39 = No_Token_Index then
      Set_Failure
        (PP.Decl_Annotation_Args_Opt_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Decl_Annotation_Args_Opt_Parse0_Memo, Pos, Transform_Res37, Parser.Last_Diag, Row_Pos39);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos39;
   return Transform_Res37;
end Decl_Annotation_Args_Opt_Parse0;
   function Decl_Block_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Decl_Block
is
      Lst_Cpos5 : Token_Index := No_Token_Index;
      Tmp_List5 : Free_Parse_List;
      Defer_Pos62 : Token_Index := No_Token_Index;
      Defer_Res62 : Bare_Full_Decl := No_Bare_Lkt_Node;
      List_Pos5 : Token_Index := No_Token_Index;
      List_Res5 : Bare_Decl_Block := No_Bare_Lkt_Node;
      Diag_Mark22 : Diagnostic_Mark;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Decl_Block_List_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      List_Res5 := M.Instance;
      return List_Res5;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return List_Res5;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <List (root of 'decl_block') at parser.lkt:287:19>
--  pos=List_Pos5, res=List_Res5, nobt=None
    List_Pos5 := Pos;
Lst_Cpos5 := Pos;
Tmp_List5 := Get_Parse_List (Parser);
Diag_Mark22 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'decl') at parser.lkt:287:30>
--  pos=Defer_Pos62, res=Defer_Res62, nobt=None
Defer_Res62 :=
   Decl_Transform_Parse0 (Parser, Lst_Cpos5);
Defer_Pos62 := Parser.Current_Pos;
--  END <Defer (for 'decl') at parser.lkt:287:30>
   exit when Defer_Pos62 = No_Token_Index;
   List_Pos5 := Defer_Pos62;
   Lst_Cpos5 := List_Pos5;
   Diag_Mark22 := Parser.Last_Diag;
   Tmp_List5.Nodes.Append (Defer_Res62);
end loop;
Parser.Last_Diag := Diag_Mark22;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List5.Nodes.Length;
begin
   List_Res5 := Allocate_Decl_Block (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos5 = Pos
                    then Pos
                    else List_Pos5 - 1);
   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res5,
      Kind              => Lkt_Decl_Block,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res5,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List5.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res5.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List5);
--  END <List (root of 'decl_block') at parser.lkt:287:19>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if List_Pos5 = No_Token_Index then
      Set_Failure
        (PP.Decl_Block_List_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Decl_Block_List_Parse0_Memo, Pos, List_Res5, Parser.Last_Diag, List_Pos5);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := List_Pos5;
   return List_Res5;
end Decl_Block_List_Parse0;
   function Decls_Dont_Skip_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Full_Decl_List
is
      Lst_Cpos6 : Token_Index := No_Token_Index;
      Tmp_List6 : Free_Parse_List;
      Defer_Pos63 : Token_Index := No_Token_Index;
      Defer_Res63 : Bare_Full_Decl := No_Bare_Lkt_Node;
      List_Pos6 : Token_Index := No_Token_Index;
      List_Res6 : Bare_Full_Decl_List := No_Bare_Lkt_Node;
      Diag_Mark23 : Diagnostic_Mark;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Decls_Dont_Skip_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      List_Res6 := M.Instance;
      return List_Res6;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return List_Res6;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <DontSkip (root of 'decls') at parser.lkt:286:14>
--  pos=List_Pos6, res=List_Res6, nobt=None
        PP.Dont_Skip.Append (Dontskip_Decls0_Extract_Parse0'Access);
--  BEGIN <List (root of 'decls') at parser.lkt:286:14>
--  pos=List_Pos6, res=List_Res6, nobt=None
    List_Pos6 := Pos;
Lst_Cpos6 := Pos;
Tmp_List6 := Get_Parse_List (Parser);
Diag_Mark23 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'decl') at parser.lkt:286:20>
--  pos=Defer_Pos63, res=Defer_Res63, nobt=None
Defer_Res63 :=
   Decl_Transform_Parse0 (Parser, Lst_Cpos6);
Defer_Pos63 := Parser.Current_Pos;
--  END <Defer (for 'decl') at parser.lkt:286:20>
   exit when Defer_Pos63 = No_Token_Index;
   List_Pos6 := Defer_Pos63;
   Lst_Cpos6 := List_Pos6;
   Diag_Mark23 := Parser.Last_Diag;
   Tmp_List6.Nodes.Append (Defer_Res63);
end loop;
Parser.Last_Diag := Diag_Mark23;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List6.Nodes.Length;
begin
   List_Res6 := Allocate_Full_Decl_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos6 = Pos
                    then Pos
                    else List_Pos6 - 1);
   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res6,
      Kind              => Lkt_Full_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res6,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List6.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res6.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List6);
--  END <List (root of 'decls') at parser.lkt:286:14>
        PP.Dont_Skip.Delete_Last;
--  END <DontSkip (root of 'decls') at parser.lkt:286:14>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if List_Pos6 = No_Token_Index then
      Set_Failure
        (PP.Decls_Dont_Skip_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Decls_Dont_Skip_Parse0_Memo, Pos, List_Res6, Parser.Last_Diag, List_Pos6);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := List_Pos6;
   return List_Res6;
end Decls_Dont_Skip_Parse0;
   function Def_Id_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Def_Id
is
      Row_Pos40 : Token_Index := No_Token_Index;
      Token_Pos50 : Token_Index := No_Token_Index;
      Token_Res50 : Token_Index := No_Token_Index;
      Transform_Res38 : Bare_Def_Id := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Def_Id_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res38 := M.Instance;
      return Transform_Res38;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res38;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType DefId>) (root of 'def_id') at parser.lkt:13:15>
--  pos=Row_Pos40, res=Transform_Res38, nobt=None
--  BEGIN <_Row (root of 'def_id') at parser.lkt:13:15>
--  pos=Row_Pos40, res=None, nobt=None
Row_Pos40 := Pos;
--  BEGIN <Token(<WithSymbol Identifier>, ) (root of 'def_id') at parser.lkt:13:21>
--  pos=Token_Pos50, res=Token_Res50, nobt=None
Token_Res50 := Row_Pos40;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res50));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
   then
       Token_Pos50 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos40 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos40,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos50 := Row_Pos40 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, ) (root of 'def_id') at parser.lkt:13:21>
if Token_Pos50 /= No_Token_Index then
   Row_Pos40 := Token_Pos50;
else
   Row_Pos40 := No_Token_Index;
   goto Exit_Row40_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row40_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'def_id') at parser.lkt:13:15>
if Row_Pos40 /= No_Token_Index then
   Transform_Res38 := Allocate_Def_Id (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res38,
      Kind => Lkt_Def_Id,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos40 = Pos
                            then No_Token_Index
                            else Row_Pos40 - 1));
      Initialize_Fields_For_Def_Id
        (Self => Transform_Res38);
end if;
--  END <Transform(<ASTNodeType DefId>) (root of 'def_id') at parser.lkt:13:15>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos40 = No_Token_Index then
      Set_Failure
        (PP.Def_Id_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Def_Id_Transform_Parse0_Memo, Pos, Transform_Res38, Parser.Last_Diag, Row_Pos40);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos40;
   return Transform_Res38;
end Def_Id_Transform_Parse0;
   function Doc_Opt_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_String_Lit
is
      Defer_Pos64 : Token_Index := No_Token_Index;
      Defer_Res64 : Bare_String_Lit := No_Bare_Lkt_Node;
      Diag_Mark24 : Diagnostic_Mark;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Doc_Opt_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Defer_Res64 := M.Instance;
      return Defer_Res64;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Defer_Res64;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Opt (root of 'doc') at parser.lkt:14:12>
--  pos=Defer_Pos64, res=Defer_Res64, nobt=None
Diag_Mark24 := Parser.Last_Diag;
--  BEGIN <Defer (for 'string_lit') at parser.lkt:14:13>
--  pos=Defer_Pos64, res=Defer_Res64, nobt=None
Defer_Res64 :=
   String_Lit_Or_Parse0 (Parser, Pos);
Defer_Pos64 := Parser.Current_Pos;
--  END <Defer (for 'string_lit') at parser.lkt:14:13>
if Defer_Pos64 = No_Token_Index then
   Defer_Res64 := No_Bare_Lkt_Node;
   Defer_Pos64 := Pos;
      Parser.Last_Diag := Diag_Mark24;
end if;
--  END <Opt (root of 'doc') at parser.lkt:14:12>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Defer_Pos64 = No_Token_Index then
      Set_Failure
        (PP.Doc_Opt_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Doc_Opt_Parse0_Memo, Pos, Defer_Res64, Parser.Last_Diag, Defer_Pos64);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Defer_Pos64;
   return Defer_Res64;
end Doc_Opt_Parse0;
   function Dontskip_Block0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
      Row_Pos41 : Token_Index := No_Token_Index;
      Token_Pos51 : Token_Index := No_Token_Index;
      Token_Res51 : Token_Index := No_Token_Index;
      Null_Res2 : Bare_Lkt_Node := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dontskip_Block0_Extract_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Null_Res2 := M.Instance;
      return Null_Res2;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Null_Res2;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <_Extract (root of 'dontskip_block0') at parser.lkt:298:9>
--  pos=Row_Pos41, res=Null_Res2, nobt=None
--  BEGIN <_Row (root of 'dontskip_block0') at parser.lkt:298:9>
--  pos=Row_Pos41, res=None, nobt=None
Row_Pos41 := Pos;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'dontskip_block0') at parser.lkt:304:21>
--  pos=Token_Pos51, res=Token_Res51, nobt=None
Token_Res51 := Row_Pos41;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res51));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos51 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos41 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos41,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos51 := Row_Pos41 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'dontskip_block0') at parser.lkt:304:21>
if Token_Pos51 /= No_Token_Index then
   Row_Pos41 := Token_Pos51;
else
   Row_Pos41 := No_Token_Index;
   goto Exit_Row41_0;
end if;
--  BEGIN <Null (root of 'dontskip_block0') at <builtin>>
--  pos=Row_Pos41, res=Null_Res2, nobt=None
   Null_Res2 := No_Bare_Lkt_Node;
--  END <Null (root of 'dontskip_block0') at <builtin>>
if Row_Pos41 /= No_Token_Index then
   Row_Pos41 := Row_Pos41;
else
   Row_Pos41 := No_Token_Index;
   goto Exit_Row41_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row41_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dontskip_block0') at parser.lkt:298:9>
--  END <_Extract (root of 'dontskip_block0') at parser.lkt:298:9>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos41 = No_Token_Index then
      Set_Failure
        (PP.Dontskip_Block0_Extract_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dontskip_Block0_Extract_Parse0_Memo, Pos, Null_Res2, Parser.Last_Diag, Row_Pos41);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos41;
   return Null_Res2;
end Dontskip_Block0_Extract_Parse0;
   function Dontskip_Decls0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
      Row_Pos42 : Token_Index := No_Token_Index;
      Token_Pos52 : Token_Index := No_Token_Index;
      Token_Res52 : Token_Index := No_Token_Index;
      Null_Res3 : Bare_Lkt_Node := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dontskip_Decls0_Extract_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Null_Res3 := M.Instance;
      return Null_Res3;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Null_Res3;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <_Extract (root of 'dontskip_decls0') at parser.lkt:286:14>
--  pos=Row_Pos42, res=Null_Res3, nobt=None
--  BEGIN <_Row (root of 'dontskip_decls0') at parser.lkt:286:14>
--  pos=Row_Pos42, res=None, nobt=None
Row_Pos42 := Pos;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'dontskip_decls0') at parser.lkt:286:36>
--  pos=Token_Pos52, res=Token_Res52, nobt=None
Token_Res52 := Row_Pos42;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res52));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos52 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos42 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos42,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos52 := Row_Pos42 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'dontskip_decls0') at parser.lkt:286:36>
if Token_Pos52 /= No_Token_Index then
   Row_Pos42 := Token_Pos52;
else
   Row_Pos42 := No_Token_Index;
   goto Exit_Row42_0;
end if;
--  BEGIN <Null (root of 'dontskip_decls0') at <builtin>>
--  pos=Row_Pos42, res=Null_Res3, nobt=None
   Null_Res3 := No_Bare_Lkt_Node;
--  END <Null (root of 'dontskip_decls0') at <builtin>>
if Row_Pos42 /= No_Token_Index then
   Row_Pos42 := Row_Pos42;
else
   Row_Pos42 := No_Token_Index;
   goto Exit_Row42_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row42_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dontskip_decls0') at parser.lkt:286:14>
--  END <_Extract (root of 'dontskip_decls0') at parser.lkt:286:14>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos42 = No_Token_Index then
      Set_Failure
        (PP.Dontskip_Decls0_Extract_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dontskip_Decls0_Extract_Parse0_Memo, Pos, Null_Res3, Parser.Last_Diag, Row_Pos42);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos42;
   return Null_Res3;
end Dontskip_Decls0_Extract_Parse0;
   function Dontskip_Grammar_List_Expr0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
      Row_Pos43 : Token_Index := No_Token_Index;
      Token_Pos53 : Token_Index := No_Token_Index;
      Token_Res53 : Token_Index := No_Token_Index;
      Null_Res4 : Bare_Lkt_Node := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dontskip_Grammar_List_Expr0_Extract_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Null_Res4 := M.Instance;
      return Null_Res4;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Null_Res4;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <_Extract (root of 'dontskip_grammar_list_expr0') at parser.lkt:145:9>
--  pos=Row_Pos43, res=Null_Res4, nobt=None
--  BEGIN <_Row (root of 'dontskip_grammar_list_expr0') at parser.lkt:145:9>
--  pos=Row_Pos43, res=None, nobt=None
Row_Pos43 := Pos;
--  BEGIN <Token(<WithText Comma>, ) (root of 'dontskip_grammar_list_expr0') at parser.lkt:145:75>
--  pos=Token_Pos53, res=Token_Res53, nobt=None
Token_Res53 := Row_Pos43;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res53));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos53 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos43 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos43,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Comma,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos53 := Row_Pos43 + 1;
   end if;
end;
--  END <Token(<WithText Comma>, ) (root of 'dontskip_grammar_list_expr0') at parser.lkt:145:75>
if Token_Pos53 /= No_Token_Index then
   Row_Pos43 := Token_Pos53;
else
   Row_Pos43 := No_Token_Index;
   goto Exit_Row43_0;
end if;
--  BEGIN <Null (root of 'dontskip_grammar_list_expr0') at <builtin>>
--  pos=Row_Pos43, res=Null_Res4, nobt=None
   Null_Res4 := No_Bare_Lkt_Node;
--  END <Null (root of 'dontskip_grammar_list_expr0') at <builtin>>
if Row_Pos43 /= No_Token_Index then
   Row_Pos43 := Row_Pos43;
else
   Row_Pos43 := No_Token_Index;
   goto Exit_Row43_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row43_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dontskip_grammar_list_expr0') at parser.lkt:145:9>
--  END <_Extract (root of 'dontskip_grammar_list_expr0') at parser.lkt:145:9>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos43 = No_Token_Index then
      Set_Failure
        (PP.Dontskip_Grammar_List_Expr0_Extract_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dontskip_Grammar_List_Expr0_Extract_Parse0_Memo, Pos, Null_Res4, Parser.Last_Diag, Row_Pos43);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos43;
   return Null_Res4;
end Dontskip_Grammar_List_Expr0_Extract_Parse0;
   function Dontskip_Grammar_List_Expr1_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
      Row_Pos44 : Token_Index := No_Token_Index;
      Token_Pos54 : Token_Index := No_Token_Index;
      Token_Res54 : Token_Index := No_Token_Index;
      Null_Res5 : Bare_Lkt_Node := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dontskip_Grammar_List_Expr1_Extract_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Null_Res5 := M.Instance;
      return Null_Res5;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Null_Res5;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <_Extract (root of 'dontskip_grammar_list_expr1') at parser.lkt:145:9>
--  pos=Row_Pos44, res=Null_Res5, nobt=None
--  BEGIN <_Row (root of 'dontskip_grammar_list_expr1') at parser.lkt:145:9>
--  pos=Row_Pos44, res=None, nobt=None
Row_Pos44 := Pos;
--  BEGIN <Token(<WithText RPar>, ) (root of 'dontskip_grammar_list_expr1') at parser.lkt:145:60>
--  pos=Token_Pos54, res=Token_Res54, nobt=None
Token_Res54 := Row_Pos44;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res54));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos54 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos44 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos44,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos54 := Row_Pos44 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'dontskip_grammar_list_expr1') at parser.lkt:145:60>
if Token_Pos54 /= No_Token_Index then
   Row_Pos44 := Token_Pos54;
else
   Row_Pos44 := No_Token_Index;
   goto Exit_Row44_0;
end if;
--  BEGIN <Null (root of 'dontskip_grammar_list_expr1') at <builtin>>
--  pos=Row_Pos44, res=Null_Res5, nobt=None
   Null_Res5 := No_Bare_Lkt_Node;
--  END <Null (root of 'dontskip_grammar_list_expr1') at <builtin>>
if Row_Pos44 /= No_Token_Index then
   Row_Pos44 := Row_Pos44;
else
   Row_Pos44 := No_Token_Index;
   goto Exit_Row44_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row44_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dontskip_grammar_list_expr1') at parser.lkt:145:9>
--  END <_Extract (root of 'dontskip_grammar_list_expr1') at parser.lkt:145:9>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos44 = No_Token_Index then
      Set_Failure
        (PP.Dontskip_Grammar_List_Expr1_Extract_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dontskip_Grammar_List_Expr1_Extract_Parse0_Memo, Pos, Null_Res5, Parser.Last_Diag, Row_Pos44);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos44;
   return Null_Res5;
end Dontskip_Grammar_List_Expr1_Extract_Parse0;
   function Dontskip_Grammar_Opt0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
      Row_Pos45 : Token_Index := No_Token_Index;
      Token_Pos55 : Token_Index := No_Token_Index;
      Token_Res55 : Token_Index := No_Token_Index;
      Null_Res6 : Bare_Lkt_Node := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dontskip_Grammar_Opt0_Extract_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Null_Res6 := M.Instance;
      return Null_Res6;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Null_Res6;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <_Extract (root of 'dontskip_grammar_opt0') at parser.lkt:97:37>
--  pos=Row_Pos45, res=Null_Res6, nobt=None
--  BEGIN <_Row (root of 'dontskip_grammar_opt0') at parser.lkt:97:37>
--  pos=Row_Pos45, res=None, nobt=None
Row_Pos45 := Pos;
--  BEGIN <Token(<WithText RPar>, ) (root of 'dontskip_grammar_opt0') at parser.lkt:97:67>
--  pos=Token_Pos55, res=Token_Res55, nobt=None
Token_Res55 := Row_Pos45;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res55));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos55 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos45 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos45,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos55 := Row_Pos45 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'dontskip_grammar_opt0') at parser.lkt:97:67>
if Token_Pos55 /= No_Token_Index then
   Row_Pos45 := Token_Pos55;
else
   Row_Pos45 := No_Token_Index;
   goto Exit_Row45_0;
end if;
--  BEGIN <Null (root of 'dontskip_grammar_opt0') at <builtin>>
--  pos=Row_Pos45, res=Null_Res6, nobt=None
   Null_Res6 := No_Bare_Lkt_Node;
--  END <Null (root of 'dontskip_grammar_opt0') at <builtin>>
if Row_Pos45 /= No_Token_Index then
   Row_Pos45 := Row_Pos45;
else
   Row_Pos45 := No_Token_Index;
   goto Exit_Row45_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row45_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dontskip_grammar_opt0') at parser.lkt:97:37>
--  END <_Extract (root of 'dontskip_grammar_opt0') at parser.lkt:97:37>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos45 = No_Token_Index then
      Set_Failure
        (PP.Dontskip_Grammar_Opt0_Extract_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dontskip_Grammar_Opt0_Extract_Parse0_Memo, Pos, Null_Res6, Parser.Last_Diag, Row_Pos45);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos45;
   return Null_Res6;
end Dontskip_Grammar_Opt0_Extract_Parse0;
   function Dontskip_Grammar_Opt_Error0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
      Row_Pos46 : Token_Index := No_Token_Index;
      Token_Pos56 : Token_Index := No_Token_Index;
      Token_Res56 : Token_Index := No_Token_Index;
      Null_Res7 : Bare_Lkt_Node := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dontskip_Grammar_Opt_Error0_Extract_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Null_Res7 := M.Instance;
      return Null_Res7;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Null_Res7;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <_Extract (root of 'dontskip_grammar_opt_error0') at parser.lkt:102:23>
--  pos=Row_Pos46, res=Null_Res7, nobt=None
--  BEGIN <_Row (root of 'dontskip_grammar_opt_error0') at parser.lkt:102:23>
--  pos=Row_Pos46, res=None, nobt=None
Row_Pos46 := Pos;
--  BEGIN <Token(<WithText RPar>, ) (root of 'dontskip_grammar_opt_error0') at parser.lkt:102:53>
--  pos=Token_Pos56, res=Token_Res56, nobt=None
Token_Res56 := Row_Pos46;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res56));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos56 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos46 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos46,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos56 := Row_Pos46 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'dontskip_grammar_opt_error0') at parser.lkt:102:53>
if Token_Pos56 /= No_Token_Index then
   Row_Pos46 := Token_Pos56;
else
   Row_Pos46 := No_Token_Index;
   goto Exit_Row46_0;
end if;
--  BEGIN <Null (root of 'dontskip_grammar_opt_error0') at <builtin>>
--  pos=Row_Pos46, res=Null_Res7, nobt=None
   Null_Res7 := No_Bare_Lkt_Node;
--  END <Null (root of 'dontskip_grammar_opt_error0') at <builtin>>
if Row_Pos46 /= No_Token_Index then
   Row_Pos46 := Row_Pos46;
else
   Row_Pos46 := No_Token_Index;
   goto Exit_Row46_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row46_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dontskip_grammar_opt_error0') at parser.lkt:102:23>
--  END <_Extract (root of 'dontskip_grammar_opt_error0') at parser.lkt:102:23>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos46 = No_Token_Index then
      Set_Failure
        (PP.Dontskip_Grammar_Opt_Error0_Extract_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dontskip_Grammar_Opt_Error0_Extract_Parse0_Memo, Pos, Null_Res7, Parser.Last_Diag, Row_Pos46);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos46;
   return Null_Res7;
end Dontskip_Grammar_Opt_Error0_Extract_Parse0;
   function Dontskip_Grammar_Or_Expr0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
      Row_Pos47 : Token_Index := No_Token_Index;
      Token_Pos57 : Token_Index := No_Token_Index;
      Token_Res57 : Token_Index := No_Token_Index;
      Null_Res8 : Bare_Lkt_Node := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dontskip_Grammar_Or_Expr0_Extract_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Null_Res8 := M.Instance;
      return Null_Res8;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Null_Res8;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <_Extract (root of 'dontskip_grammar_or_expr0') at parser.lkt:113:9>
--  pos=Row_Pos47, res=Null_Res8, nobt=None
--  BEGIN <_Row (root of 'dontskip_grammar_or_expr0') at parser.lkt:113:9>
--  pos=Row_Pos47, res=None, nobt=None
Row_Pos47 := Pos;
--  BEGIN <Token(<WithText RPar>, ) (root of 'dontskip_grammar_or_expr0') at parser.lkt:115:21>
--  pos=Token_Pos57, res=Token_Res57, nobt=None
Token_Res57 := Row_Pos47;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res57));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos57 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos47 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos47,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos57 := Row_Pos47 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'dontskip_grammar_or_expr0') at parser.lkt:115:21>
if Token_Pos57 /= No_Token_Index then
   Row_Pos47 := Token_Pos57;
else
   Row_Pos47 := No_Token_Index;
   goto Exit_Row47_0;
end if;
--  BEGIN <Null (root of 'dontskip_grammar_or_expr0') at <builtin>>
--  pos=Row_Pos47, res=Null_Res8, nobt=None
   Null_Res8 := No_Bare_Lkt_Node;
--  END <Null (root of 'dontskip_grammar_or_expr0') at <builtin>>
if Row_Pos47 /= No_Token_Index then
   Row_Pos47 := Row_Pos47;
else
   Row_Pos47 := No_Token_Index;
   goto Exit_Row47_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row47_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dontskip_grammar_or_expr0') at parser.lkt:113:9>
--  END <_Extract (root of 'dontskip_grammar_or_expr0') at parser.lkt:113:9>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos47 = No_Token_Index then
      Set_Failure
        (PP.Dontskip_Grammar_Or_Expr0_Extract_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dontskip_Grammar_Or_Expr0_Extract_Parse0_Memo, Pos, Null_Res8, Parser.Last_Diag, Row_Pos47);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos47;
   return Null_Res8;
end Dontskip_Grammar_Or_Expr0_Extract_Parse0;
   function Dontskip_Grammar_Or_Expr1_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
      Row_Pos48 : Token_Index := No_Token_Index;
      Token_Pos58 : Token_Index := No_Token_Index;
      Token_Res58 : Token_Index := No_Token_Index;
      Null_Res9 : Bare_Lkt_Node := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dontskip_Grammar_Or_Expr1_Extract_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Null_Res9 := M.Instance;
      return Null_Res9;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Null_Res9;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <_Extract (root of 'dontskip_grammar_or_expr1') at parser.lkt:114:13>
--  pos=Row_Pos48, res=Null_Res9, nobt=None
--  BEGIN <_Row (root of 'dontskip_grammar_or_expr1') at parser.lkt:114:13>
--  pos=Row_Pos48, res=None, nobt=None
Row_Pos48 := Pos;
--  BEGIN <Token(<WithText Pipe>, ) (root of 'dontskip_grammar_or_expr1') at parser.lkt:114:43>
--  pos=Token_Pos58, res=Token_Res58, nobt=None
Token_Res58 := Row_Pos48;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res58));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Pipe)
   then
       Token_Pos58 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos48 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos48,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Pipe,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos58 := Row_Pos48 + 1;
   end if;
end;
--  END <Token(<WithText Pipe>, ) (root of 'dontskip_grammar_or_expr1') at parser.lkt:114:43>
if Token_Pos58 /= No_Token_Index then
   Row_Pos48 := Token_Pos58;
else
   Row_Pos48 := No_Token_Index;
   goto Exit_Row48_0;
end if;
--  BEGIN <Null (root of 'dontskip_grammar_or_expr1') at <builtin>>
--  pos=Row_Pos48, res=Null_Res9, nobt=None
   Null_Res9 := No_Bare_Lkt_Node;
--  END <Null (root of 'dontskip_grammar_or_expr1') at <builtin>>
if Row_Pos48 /= No_Token_Index then
   Row_Pos48 := Row_Pos48;
else
   Row_Pos48 := No_Token_Index;
   goto Exit_Row48_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row48_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dontskip_grammar_or_expr1') at parser.lkt:114:13>
--  END <_Extract (root of 'dontskip_grammar_or_expr1') at parser.lkt:114:13>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos48 = No_Token_Index then
      Set_Failure
        (PP.Dontskip_Grammar_Or_Expr1_Extract_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dontskip_Grammar_Or_Expr1_Extract_Parse0_Memo, Pos, Null_Res9, Parser.Last_Diag, Row_Pos48);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos48;
   return Null_Res9;
end Dontskip_Grammar_Or_Expr1_Extract_Parse0;
   function Dontskip_Grammar_Pick0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
      Row_Pos49 : Token_Index := No_Token_Index;
      Token_Pos59 : Token_Index := No_Token_Index;
      Token_Res59 : Token_Index := No_Token_Index;
      Null_Res10 : Bare_Lkt_Node := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dontskip_Grammar_Pick0_Extract_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Null_Res10 := M.Instance;
      return Null_Res10;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Null_Res10;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <_Extract (root of 'dontskip_grammar_pick0') at parser.lkt:93:33>
--  pos=Row_Pos49, res=Null_Res10, nobt=None
--  BEGIN <_Row (root of 'dontskip_grammar_pick0') at parser.lkt:93:33>
--  pos=Row_Pos49, res=None, nobt=None
Row_Pos49 := Pos;
--  BEGIN <Token(<WithText RPar>, ) (root of 'dontskip_grammar_pick0') at parser.lkt:93:63>
--  pos=Token_Pos59, res=Token_Res59, nobt=None
Token_Res59 := Row_Pos49;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res59));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos59 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos49 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos49,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos59 := Row_Pos49 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'dontskip_grammar_pick0') at parser.lkt:93:63>
if Token_Pos59 /= No_Token_Index then
   Row_Pos49 := Token_Pos59;
else
   Row_Pos49 := No_Token_Index;
   goto Exit_Row49_0;
end if;
--  BEGIN <Null (root of 'dontskip_grammar_pick0') at <builtin>>
--  pos=Row_Pos49, res=Null_Res10, nobt=None
   Null_Res10 := No_Bare_Lkt_Node;
--  END <Null (root of 'dontskip_grammar_pick0') at <builtin>>
if Row_Pos49 /= No_Token_Index then
   Row_Pos49 := Row_Pos49;
else
   Row_Pos49 := No_Token_Index;
   goto Exit_Row49_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row49_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dontskip_grammar_pick0') at parser.lkt:93:33>
--  END <_Extract (root of 'dontskip_grammar_pick0') at parser.lkt:93:33>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos49 = No_Token_Index then
      Set_Failure
        (PP.Dontskip_Grammar_Pick0_Extract_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dontskip_Grammar_Pick0_Extract_Parse0_Memo, Pos, Null_Res10, Parser.Last_Diag, Row_Pos49);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos49;
   return Null_Res10;
end Dontskip_Grammar_Pick0_Extract_Parse0;
   function Dontskip_Lexer_Case_Rule0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
      Row_Pos50 : Token_Index := No_Token_Index;
      Token_Pos60 : Token_Index := No_Token_Index;
      Token_Res60 : Token_Index := No_Token_Index;
      Null_Res11 : Bare_Lkt_Node := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dontskip_Lexer_Case_Rule0_Extract_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Null_Res11 := M.Instance;
      return Null_Res11;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Null_Res11;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <_Extract (root of 'dontskip_lexer_case_rule0') at parser.lkt:46:39>
--  pos=Row_Pos50, res=Null_Res11, nobt=None
--  BEGIN <_Row (root of 'dontskip_lexer_case_rule0') at parser.lkt:46:39>
--  pos=Row_Pos50, res=None, nobt=None
Row_Pos50 := Pos;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'dontskip_lexer_case_rule0') at parser.lkt:46:71>
--  pos=Token_Pos60, res=Token_Res60, nobt=None
Token_Res60 := Row_Pos50;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res60));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos60 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos50 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos50,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos60 := Row_Pos50 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'dontskip_lexer_case_rule0') at parser.lkt:46:71>
if Token_Pos60 /= No_Token_Index then
   Row_Pos50 := Token_Pos60;
else
   Row_Pos50 := No_Token_Index;
   goto Exit_Row50_0;
end if;
--  BEGIN <Null (root of 'dontskip_lexer_case_rule0') at <builtin>>
--  pos=Row_Pos50, res=Null_Res11, nobt=None
   Null_Res11 := No_Bare_Lkt_Node;
--  END <Null (root of 'dontskip_lexer_case_rule0') at <builtin>>
if Row_Pos50 /= No_Token_Index then
   Row_Pos50 := Row_Pos50;
else
   Row_Pos50 := No_Token_Index;
   goto Exit_Row50_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row50_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dontskip_lexer_case_rule0') at parser.lkt:46:39>
--  END <_Extract (root of 'dontskip_lexer_case_rule0') at parser.lkt:46:39>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos50 = No_Token_Index then
      Set_Failure
        (PP.Dontskip_Lexer_Case_Rule0_Extract_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dontskip_Lexer_Case_Rule0_Extract_Parse0_Memo, Pos, Null_Res11, Parser.Last_Diag, Row_Pos50);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos50;
   return Null_Res11;
end Dontskip_Lexer_Case_Rule0_Extract_Parse0;
   function Dontskip_Lexer_Decl0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
      Row_Pos51 : Token_Index := No_Token_Index;
      Token_Pos61 : Token_Index := No_Token_Index;
      Token_Res61 : Token_Index := No_Token_Index;
      Null_Res12 : Bare_Lkt_Node := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dontskip_Lexer_Decl0_Extract_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Null_Res12 := M.Instance;
      return Null_Res12;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Null_Res12;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <_Extract (root of 'dontskip_lexer_decl0') at parser.lkt:40:9>
--  pos=Row_Pos51, res=Null_Res12, nobt=None
--  BEGIN <_Row (root of 'dontskip_lexer_decl0') at parser.lkt:40:9>
--  pos=Row_Pos51, res=None, nobt=None
Row_Pos51 := Pos;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'dontskip_lexer_decl0') at parser.lkt:40:53>
--  pos=Token_Pos61, res=Token_Res61, nobt=None
Token_Res61 := Row_Pos51;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res61));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos61 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos51 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos51,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos61 := Row_Pos51 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'dontskip_lexer_decl0') at parser.lkt:40:53>
if Token_Pos61 /= No_Token_Index then
   Row_Pos51 := Token_Pos61;
else
   Row_Pos51 := No_Token_Index;
   goto Exit_Row51_0;
end if;
--  BEGIN <Null (root of 'dontskip_lexer_decl0') at <builtin>>
--  pos=Row_Pos51, res=Null_Res12, nobt=None
   Null_Res12 := No_Bare_Lkt_Node;
--  END <Null (root of 'dontskip_lexer_decl0') at <builtin>>
if Row_Pos51 /= No_Token_Index then
   Row_Pos51 := Row_Pos51;
else
   Row_Pos51 := No_Token_Index;
   goto Exit_Row51_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row51_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dontskip_lexer_decl0') at parser.lkt:40:9>
--  END <_Extract (root of 'dontskip_lexer_decl0') at parser.lkt:40:9>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos51 = No_Token_Index then
      Set_Failure
        (PP.Dontskip_Lexer_Decl0_Extract_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dontskip_Lexer_Decl0_Extract_Parse0_Memo, Pos, Null_Res12, Parser.Last_Diag, Row_Pos51);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos51;
   return Null_Res12;
end Dontskip_Lexer_Decl0_Extract_Parse0;
   function Dontskip_Lexer_Family_Decl0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
      Row_Pos52 : Token_Index := No_Token_Index;
      Token_Pos62 : Token_Index := No_Token_Index;
      Token_Res62 : Token_Index := No_Token_Index;
      Null_Res13 : Bare_Lkt_Node := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dontskip_Lexer_Family_Decl0_Extract_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Null_Res13 := M.Instance;
      return Null_Res13;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Null_Res13;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <_Extract (root of 'dontskip_lexer_family_decl0') at parser.lkt:257:44>
--  pos=Row_Pos52, res=Null_Res13, nobt=None
--  BEGIN <_Row (root of 'dontskip_lexer_family_decl0') at parser.lkt:257:44>
--  pos=Row_Pos52, res=None, nobt=None
Row_Pos52 := Pos;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'dontskip_lexer_family_decl0') at parser.lkt:257:66>
--  pos=Token_Pos62, res=Token_Res62, nobt=None
Token_Res62 := Row_Pos52;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res62));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos62 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos52 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos52,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos62 := Row_Pos52 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'dontskip_lexer_family_decl0') at parser.lkt:257:66>
if Token_Pos62 /= No_Token_Index then
   Row_Pos52 := Token_Pos62;
else
   Row_Pos52 := No_Token_Index;
   goto Exit_Row52_0;
end if;
--  BEGIN <Null (root of 'dontskip_lexer_family_decl0') at <builtin>>
--  pos=Row_Pos52, res=Null_Res13, nobt=None
   Null_Res13 := No_Bare_Lkt_Node;
--  END <Null (root of 'dontskip_lexer_family_decl0') at <builtin>>
if Row_Pos52 /= No_Token_Index then
   Row_Pos52 := Row_Pos52;
else
   Row_Pos52 := No_Token_Index;
   goto Exit_Row52_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row52_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dontskip_lexer_family_decl0') at parser.lkt:257:44>
--  END <_Extract (root of 'dontskip_lexer_family_decl0') at parser.lkt:257:44>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos52 = No_Token_Index then
      Set_Failure
        (PP.Dontskip_Lexer_Family_Decl0_Extract_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dontskip_Lexer_Family_Decl0_Extract_Parse0_Memo, Pos, Null_Res13, Parser.Last_Diag, Row_Pos52);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos52;
   return Null_Res13;
end Dontskip_Lexer_Family_Decl0_Extract_Parse0;
   function Dontskip_Parse_Node_Expr0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
      Row_Pos53 : Token_Index := No_Token_Index;
      Token_Pos63 : Token_Index := No_Token_Index;
      Token_Res63 : Token_Index := No_Token_Index;
      Null_Res14 : Bare_Lkt_Node := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dontskip_Parse_Node_Expr0_Extract_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Null_Res14 := M.Instance;
      return Null_Res14;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Null_Res14;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <_Extract (root of 'dontskip_parse_node_expr0') at parser.lkt:132:9>
--  pos=Row_Pos53, res=Null_Res14, nobt=None
--  BEGIN <_Row (root of 'dontskip_parse_node_expr0') at parser.lkt:132:9>
--  pos=Row_Pos53, res=None, nobt=None
Row_Pos53 := Pos;
--  BEGIN <Token(<WithText RPar>, ) (root of 'dontskip_parse_node_expr0') at parser.lkt:132:39>
--  pos=Token_Pos63, res=Token_Res63, nobt=None
Token_Res63 := Row_Pos53;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res63));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos63 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos53 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos53,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos63 := Row_Pos53 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'dontskip_parse_node_expr0') at parser.lkt:132:39>
if Token_Pos63 /= No_Token_Index then
   Row_Pos53 := Token_Pos63;
else
   Row_Pos53 := No_Token_Index;
   goto Exit_Row53_0;
end if;
--  BEGIN <Null (root of 'dontskip_parse_node_expr0') at <builtin>>
--  pos=Row_Pos53, res=Null_Res14, nobt=None
   Null_Res14 := No_Bare_Lkt_Node;
--  END <Null (root of 'dontskip_parse_node_expr0') at <builtin>>
if Row_Pos53 /= No_Token_Index then
   Row_Pos53 := Row_Pos53;
else
   Row_Pos53 := No_Token_Index;
   goto Exit_Row53_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row53_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dontskip_parse_node_expr0') at parser.lkt:132:9>
--  END <_Extract (root of 'dontskip_parse_node_expr0') at parser.lkt:132:9>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos53 = No_Token_Index then
      Set_Failure
        (PP.Dontskip_Parse_Node_Expr0_Extract_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dontskip_Parse_Node_Expr0_Extract_Parse0_Memo, Pos, Null_Res14, Parser.Last_Diag, Row_Pos53);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos53;
   return Null_Res14;
end Dontskip_Parse_Node_Expr0_Extract_Parse0;
   function Dontskip_Type_Decl0_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
      Row_Pos54 : Token_Index := No_Token_Index;
      Token_Pos64 : Token_Index := No_Token_Index;
      Token_Res64 : Token_Index := No_Token_Index;
      Null_Res15 : Bare_Lkt_Node := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dontskip_Type_Decl0_Extract_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Null_Res15 := M.Instance;
      return Null_Res15;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Null_Res15;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <_Extract (root of 'dontskip_type_decl0') at parser.lkt:162:13>
--  pos=Row_Pos54, res=Null_Res15, nobt=None
--  BEGIN <_Row (root of 'dontskip_type_decl0') at parser.lkt:162:13>
--  pos=Row_Pos54, res=None, nobt=None
Row_Pos54 := Pos;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'dontskip_type_decl0') at parser.lkt:162:34>
--  pos=Token_Pos64, res=Token_Res64, nobt=None
Token_Res64 := Row_Pos54;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res64));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos64 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos54 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos54,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos64 := Row_Pos54 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'dontskip_type_decl0') at parser.lkt:162:34>
if Token_Pos64 /= No_Token_Index then
   Row_Pos54 := Token_Pos64;
else
   Row_Pos54 := No_Token_Index;
   goto Exit_Row54_0;
end if;
--  BEGIN <Null (root of 'dontskip_type_decl0') at <builtin>>
--  pos=Row_Pos54, res=Null_Res15, nobt=None
   Null_Res15 := No_Bare_Lkt_Node;
--  END <Null (root of 'dontskip_type_decl0') at <builtin>>
if Row_Pos54 /= No_Token_Index then
   Row_Pos54 := Row_Pos54;
else
   Row_Pos54 := No_Token_Index;
   goto Exit_Row54_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row54_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dontskip_type_decl0') at parser.lkt:162:13>
--  END <_Extract (root of 'dontskip_type_decl0') at parser.lkt:162:13>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos54 = No_Token_Index then
      Set_Failure
        (PP.Dontskip_Type_Decl0_Extract_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dontskip_Type_Decl0_Extract_Parse0_Memo, Pos, Null_Res15, Parser.Last_Diag, Row_Pos54);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos54;
   return Null_Res15;
end Dontskip_Type_Decl0_Extract_Parse0;
   function Dontskip_Type_Decl1_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
      Row_Pos55 : Token_Index := No_Token_Index;
      Token_Pos65 : Token_Index := No_Token_Index;
      Token_Res65 : Token_Index := No_Token_Index;
      Null_Res16 : Bare_Lkt_Node := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dontskip_Type_Decl1_Extract_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Null_Res16 := M.Instance;
      return Null_Res16;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Null_Res16;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <_Extract (root of 'dontskip_type_decl1') at parser.lkt:179:13>
--  pos=Row_Pos55, res=Null_Res16, nobt=None
--  BEGIN <_Row (root of 'dontskip_type_decl1') at parser.lkt:179:13>
--  pos=Row_Pos55, res=None, nobt=None
Row_Pos55 := Pos;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'dontskip_type_decl1') at parser.lkt:179:34>
--  pos=Token_Pos65, res=Token_Res65, nobt=None
Token_Res65 := Row_Pos55;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res65));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos65 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos55 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos55,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos65 := Row_Pos55 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'dontskip_type_decl1') at parser.lkt:179:34>
if Token_Pos65 /= No_Token_Index then
   Row_Pos55 := Token_Pos65;
else
   Row_Pos55 := No_Token_Index;
   goto Exit_Row55_0;
end if;
--  BEGIN <Null (root of 'dontskip_type_decl1') at <builtin>>
--  pos=Row_Pos55, res=Null_Res16, nobt=None
   Null_Res16 := No_Bare_Lkt_Node;
--  END <Null (root of 'dontskip_type_decl1') at <builtin>>
if Row_Pos55 /= No_Token_Index then
   Row_Pos55 := Row_Pos55;
else
   Row_Pos55 := No_Token_Index;
   goto Exit_Row55_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row55_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dontskip_type_decl1') at parser.lkt:179:13>
--  END <_Extract (root of 'dontskip_type_decl1') at parser.lkt:179:13>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos55 = No_Token_Index then
      Set_Failure
        (PP.Dontskip_Type_Decl1_Extract_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dontskip_Type_Decl1_Extract_Parse0_Memo, Pos, Null_Res16, Parser.Last_Diag, Row_Pos55);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos55;
   return Null_Res16;
end Dontskip_Type_Decl1_Extract_Parse0;
   function Dontskip_Type_Decl2_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
      Row_Pos56 : Token_Index := No_Token_Index;
      Token_Pos66 : Token_Index := No_Token_Index;
      Token_Res66 : Token_Index := No_Token_Index;
      Null_Res17 : Bare_Lkt_Node := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dontskip_Type_Decl2_Extract_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Null_Res17 := M.Instance;
      return Null_Res17;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Null_Res17;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <_Extract (root of 'dontskip_type_decl2') at parser.lkt:189:13>
--  pos=Row_Pos56, res=Null_Res17, nobt=None
--  BEGIN <_Row (root of 'dontskip_type_decl2') at parser.lkt:189:13>
--  pos=Row_Pos56, res=None, nobt=None
Row_Pos56 := Pos;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'dontskip_type_decl2') at parser.lkt:189:34>
--  pos=Token_Pos66, res=Token_Res66, nobt=None
Token_Res66 := Row_Pos56;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res66));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos66 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos56 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos56,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos66 := Row_Pos56 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'dontskip_type_decl2') at parser.lkt:189:34>
if Token_Pos66 /= No_Token_Index then
   Row_Pos56 := Token_Pos66;
else
   Row_Pos56 := No_Token_Index;
   goto Exit_Row56_0;
end if;
--  BEGIN <Null (root of 'dontskip_type_decl2') at <builtin>>
--  pos=Row_Pos56, res=Null_Res17, nobt=None
   Null_Res17 := No_Bare_Lkt_Node;
--  END <Null (root of 'dontskip_type_decl2') at <builtin>>
if Row_Pos56 /= No_Token_Index then
   Row_Pos56 := Row_Pos56;
else
   Row_Pos56 := No_Token_Index;
   goto Exit_Row56_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row56_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dontskip_type_decl2') at parser.lkt:189:13>
--  END <_Extract (root of 'dontskip_type_decl2') at parser.lkt:189:13>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos56 = No_Token_Index then
      Set_Failure
        (PP.Dontskip_Type_Decl2_Extract_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dontskip_Type_Decl2_Extract_Parse0_Memo, Pos, Null_Res17, Parser.Last_Diag, Row_Pos56);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos56;
   return Null_Res17;
end Dontskip_Type_Decl2_Extract_Parse0;
   function Dontskip_Type_Decl3_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
      Row_Pos57 : Token_Index := No_Token_Index;
      Token_Pos67 : Token_Index := No_Token_Index;
      Token_Res67 : Token_Index := No_Token_Index;
      Null_Res18 : Bare_Lkt_Node := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dontskip_Type_Decl3_Extract_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Null_Res18 := M.Instance;
      return Null_Res18;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Null_Res18;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <_Extract (root of 'dontskip_type_decl3') at parser.lkt:200:13>
--  pos=Row_Pos57, res=Null_Res18, nobt=None
--  BEGIN <_Row (root of 'dontskip_type_decl3') at parser.lkt:200:13>
--  pos=Row_Pos57, res=None, nobt=None
Row_Pos57 := Pos;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'dontskip_type_decl3') at parser.lkt:200:34>
--  pos=Token_Pos67, res=Token_Res67, nobt=None
Token_Res67 := Row_Pos57;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res67));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos67 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos57 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos57,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos67 := Row_Pos57 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'dontskip_type_decl3') at parser.lkt:200:34>
if Token_Pos67 /= No_Token_Index then
   Row_Pos57 := Token_Pos67;
else
   Row_Pos57 := No_Token_Index;
   goto Exit_Row57_0;
end if;
--  BEGIN <Null (root of 'dontskip_type_decl3') at <builtin>>
--  pos=Row_Pos57, res=Null_Res18, nobt=None
   Null_Res18 := No_Bare_Lkt_Node;
--  END <Null (root of 'dontskip_type_decl3') at <builtin>>
if Row_Pos57 /= No_Token_Index then
   Row_Pos57 := Row_Pos57;
else
   Row_Pos57 := No_Token_Index;
   goto Exit_Row57_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row57_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dontskip_type_decl3') at parser.lkt:200:13>
--  END <_Extract (root of 'dontskip_type_decl3') at parser.lkt:200:13>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos57 = No_Token_Index then
      Set_Failure
        (PP.Dontskip_Type_Decl3_Extract_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dontskip_Type_Decl3_Extract_Parse0_Memo, Pos, Null_Res18, Parser.Last_Diag, Row_Pos57);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos57;
   return Null_Res18;
end Dontskip_Type_Decl3_Extract_Parse0;
   function Dontskip_Type_Decl4_Extract_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lkt_Node
is
      Row_Pos58 : Token_Index := No_Token_Index;
      Token_Pos68 : Token_Index := No_Token_Index;
      Token_Res68 : Token_Index := No_Token_Index;
      Null_Res19 : Bare_Lkt_Node := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dontskip_Type_Decl4_Extract_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Null_Res19 := M.Instance;
      return Null_Res19;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Null_Res19;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <_Extract (root of 'dontskip_type_decl4') at parser.lkt:209:13>
--  pos=Row_Pos58, res=Null_Res19, nobt=None
--  BEGIN <_Row (root of 'dontskip_type_decl4') at parser.lkt:209:13>
--  pos=Row_Pos58, res=None, nobt=None
Row_Pos58 := Pos;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'dontskip_type_decl4') at parser.lkt:209:34>
--  pos=Token_Pos68, res=Token_Res68, nobt=None
Token_Res68 := Row_Pos58;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res68));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos68 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos58 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos58,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos68 := Row_Pos58 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'dontskip_type_decl4') at parser.lkt:209:34>
if Token_Pos68 /= No_Token_Index then
   Row_Pos58 := Token_Pos68;
else
   Row_Pos58 := No_Token_Index;
   goto Exit_Row58_0;
end if;
--  BEGIN <Null (root of 'dontskip_type_decl4') at <builtin>>
--  pos=Row_Pos58, res=Null_Res19, nobt=None
   Null_Res19 := No_Bare_Lkt_Node;
--  END <Null (root of 'dontskip_type_decl4') at <builtin>>
if Row_Pos58 /= No_Token_Index then
   Row_Pos58 := Row_Pos58;
else
   Row_Pos58 := No_Token_Index;
   goto Exit_Row58_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row58_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dontskip_type_decl4') at parser.lkt:209:13>
--  END <_Extract (root of 'dontskip_type_decl4') at parser.lkt:209:13>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos58 = No_Token_Index then
      Set_Failure
        (PP.Dontskip_Type_Decl4_Extract_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dontskip_Type_Decl4_Extract_Parse0_Memo, Pos, Null_Res19, Parser.Last_Diag, Row_Pos58);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos58;
   return Null_Res19;
end Dontskip_Type_Decl4_Extract_Parse0;
   function Dynvar_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Dyn_Var_Decl
is
      Row_Pos59 : Token_Index := No_Token_Index;
      Token_Pos69 : Token_Index := No_Token_Index;
      Token_Res69 : Token_Index := No_Token_Index;
      Defer_Pos65 : Token_Index := No_Token_Index;
      Defer_Res65 : Bare_Def_Id := No_Bare_Lkt_Node;
      Token_Pos70 : Token_Index := No_Token_Index;
      Token_Res70 : Token_Index := No_Token_Index;
      Defer_Pos66 : Token_Index := No_Token_Index;
      Defer_Res66 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Transform_Res39 : Bare_Dyn_Var_Decl := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Dynvar_Decl_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res39 := M.Instance;
      return Transform_Res39;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res39;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType DynVarDecl>) (root of 'dynvar_decl') at parser.lkt:289:20>
--  pos=Row_Pos59, res=Transform_Res39, nobt=None
--  BEGIN <_Row (root of 'dynvar_decl') at parser.lkt:289:20>
--  pos=Row_Pos59, res=None, nobt=None
Row_Pos59 := Pos;
--  BEGIN <Token(<WithText DynVarKw>, ) (root of 'dynvar_decl') at parser.lkt:289:31>
--  pos=Token_Pos69, res=Token_Res69, nobt=None
Token_Res69 := Row_Pos59;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res69));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dyn_Var_Kw)
   then
       Token_Pos69 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos59 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos59,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Dyn_Var_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos69 := Row_Pos59 + 1;
   end if;
end;
--  END <Token(<WithText DynVarKw>, ) (root of 'dynvar_decl') at parser.lkt:289:31>
if Token_Pos69 /= No_Token_Index then
   Row_Pos59 := Token_Pos69;
else
   Row_Pos59 := No_Token_Index;
   goto Exit_Row59_0;
end if;
--  BEGIN <Defer (for 'def_id') at parser.lkt:289:40>
--  pos=Defer_Pos65, res=Defer_Res65, nobt=None
Defer_Res65 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos59);
Defer_Pos65 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:289:40>
if Defer_Pos65 /= No_Token_Index then
   Row_Pos59 := Defer_Pos65;
else
   Row_Pos59 := No_Token_Index;
   goto Exit_Row59_0;
end if;
--  BEGIN <Token(<WithText Colon>, ) (root of 'dynvar_decl') at parser.lkt:289:47>
--  pos=Token_Pos70, res=Token_Res70, nobt=None
Token_Res70 := Row_Pos59;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res70));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos70 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos59 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos59,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Colon,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos70 := Row_Pos59 + 1;
   end if;
end;
--  END <Token(<WithText Colon>, ) (root of 'dynvar_decl') at parser.lkt:289:47>
if Token_Pos70 /= No_Token_Index then
   Row_Pos59 := Token_Pos70;
else
   Row_Pos59 := No_Token_Index;
   goto Exit_Row59_0;
end if;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:289:51>
--  pos=Defer_Pos66, res=Defer_Res66, nobt=None
Defer_Res66 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos59);
Defer_Pos66 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:289:51>
if Defer_Pos66 /= No_Token_Index then
   Row_Pos59 := Defer_Pos66;
else
   Row_Pos59 := No_Token_Index;
   goto Exit_Row59_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row59_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'dynvar_decl') at parser.lkt:289:20>
if Row_Pos59 /= No_Token_Index then
   Transform_Res39 := Allocate_Dyn_Var_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res39,
      Kind => Lkt_Dyn_Var_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos59 = Pos
                            then No_Token_Index
                            else Row_Pos59 - 1));
      Initialize_Fields_For_Dyn_Var_Decl
        (Self => Transform_Res39,
         Dyn_Var_Decl_F_Syn_Name => Defer_Res65,
         Dyn_Var_Decl_F_Decl_Type => Defer_Res66);
         if Defer_Res65 /= null and then Is_Incomplete (Defer_Res65) then
            Transform_Res39.Last_Attempted_Child := 0;
         elsif Defer_Res65 /= null and then not Is_Ghost (Defer_Res65) then
            Transform_Res39.Last_Attempted_Child := -1;
         end if;
         if Defer_Res66 /= null and then Is_Incomplete (Defer_Res66) then
            Transform_Res39.Last_Attempted_Child := 0;
         elsif Defer_Res66 /= null and then not Is_Ghost (Defer_Res66) then
            Transform_Res39.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType DynVarDecl>) (root of 'dynvar_decl') at parser.lkt:289:20>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos59 = No_Token_Index then
      Set_Failure
        (PP.Dynvar_Decl_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Dynvar_Decl_Transform_Parse0_Memo, Pos, Transform_Res39, Parser.Last_Diag, Row_Pos59);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos59;
   return Transform_Res39;
end Dynvar_Decl_Transform_Parse0;
   function Ellipsis_Pattern_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ellipsis_Pattern
is
      Row_Pos60 : Token_Index := No_Token_Index;
      Row_Pos61 : Token_Index := No_Token_Index;
      Defer_Pos67 : Token_Index := No_Token_Index;
      Defer_Res67 : Bare_Id := No_Bare_Lkt_Node;
      Token_Pos71 : Token_Index := No_Token_Index;
      Token_Res71 : Token_Index := No_Token_Index;
      Diag_Mark25 : Diagnostic_Mark;
      Token_Pos72 : Token_Index := No_Token_Index;
      Token_Res72 : Token_Index := No_Token_Index;
      Transform_Res40 : Bare_Ellipsis_Pattern := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Ellipsis_Pattern_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res40 := M.Instance;
      return Transform_Res40;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res40;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType EllipsisPattern>) (root of 'ellipsis_pattern') at parser.lkt:341:25>
--  pos=Row_Pos60, res=Transform_Res40, nobt=None
--  BEGIN <_Row (root of 'ellipsis_pattern') at parser.lkt:341:25>
--  pos=Row_Pos60, res=None, nobt=None
Row_Pos60 := Pos;
--  BEGIN <Opt (root of 'ellipsis_pattern') at parser.lkt:341:41>
--  pos=Row_Pos61, res=Defer_Res67, nobt=None
Diag_Mark25 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'ellipsis_pattern') at parser.lkt:341:42>
--  pos=Row_Pos61, res=Defer_Res67, nobt=None
--  BEGIN <_Row (root of 'ellipsis_pattern') at parser.lkt:341:42>
--  pos=Row_Pos61, res=None, nobt=None
Row_Pos61 := Row_Pos60;
--  BEGIN <Defer (for 'id') at parser.lkt:341:47>
--  pos=Defer_Pos67, res=Defer_Res67, nobt=None
Defer_Res67 :=
   Id_Transform_Parse0 (Parser, Row_Pos61);
Defer_Pos67 := Parser.Current_Pos;
--  END <Defer (for 'id') at parser.lkt:341:47>
if Defer_Pos67 /= No_Token_Index then
   Row_Pos61 := Defer_Pos67;
else
   Row_Pos61 := No_Token_Index;
   goto Exit_Row61_0;
end if;
--  BEGIN <Token(<WithText At>, ) (root of 'ellipsis_pattern') at parser.lkt:341:50>
--  pos=Token_Pos71, res=Token_Res71, nobt=None
Token_Res71 := Row_Pos61;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res71));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_At)
   then
       Token_Pos71 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos61 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos61,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_At,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos71 := Row_Pos61 + 1;
   end if;
end;
--  END <Token(<WithText At>, ) (root of 'ellipsis_pattern') at parser.lkt:341:50>
if Token_Pos71 /= No_Token_Index then
   Row_Pos61 := Token_Pos71;
else
   Row_Pos61 := No_Token_Index;
   goto Exit_Row61_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row61_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'ellipsis_pattern') at parser.lkt:341:42>
--  END <_Extract (root of 'ellipsis_pattern') at parser.lkt:341:42>
if Row_Pos61 = No_Token_Index then
   Defer_Res67 := No_Bare_Lkt_Node;
   Row_Pos61 := Row_Pos60;
      Parser.Last_Diag := Diag_Mark25;
end if;
--  END <Opt (root of 'ellipsis_pattern') at parser.lkt:341:41>
if Row_Pos61 /= No_Token_Index then
   Row_Pos60 := Row_Pos61;
else
   Row_Pos60 := No_Token_Index;
   goto Exit_Row60_0;
end if;
--  BEGIN <Token(<WithText Ellipsis>, ) (root of 'ellipsis_pattern') at parser.lkt:341:55>
--  pos=Token_Pos72, res=Token_Res72, nobt=None
Token_Res72 := Row_Pos60;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res72));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Ellipsis)
   then
       Token_Pos72 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos60 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos60,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Ellipsis,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos72 := Row_Pos60 + 1;
   end if;
end;
--  END <Token(<WithText Ellipsis>, ) (root of 'ellipsis_pattern') at parser.lkt:341:55>
if Token_Pos72 /= No_Token_Index then
   Row_Pos60 := Token_Pos72;
else
   Row_Pos60 := No_Token_Index;
   goto Exit_Row60_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row60_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'ellipsis_pattern') at parser.lkt:341:25>
if Row_Pos60 /= No_Token_Index then
   Transform_Res40 := Allocate_Ellipsis_Pattern (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res40,
      Kind => Lkt_Ellipsis_Pattern,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos60 = Pos
                            then No_Token_Index
                            else Row_Pos60 - 1));
      Initialize_Fields_For_Ellipsis_Pattern
        (Self => Transform_Res40,
         Ellipsis_Pattern_F_Binding => Defer_Res67);
         if Defer_Res67 /= null and then Is_Incomplete (Defer_Res67) then
            Transform_Res40.Last_Attempted_Child := 0;
         elsif Defer_Res67 /= null and then not Is_Ghost (Defer_Res67) then
            Transform_Res40.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType EllipsisPattern>) (root of 'ellipsis_pattern') at parser.lkt:341:25>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos60 = No_Token_Index then
      Set_Failure
        (PP.Ellipsis_Pattern_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Ellipsis_Pattern_Transform_Parse0_Memo, Pos, Transform_Res40, Parser.Last_Diag, Row_Pos60);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos60;
   return Transform_Res40;
end Ellipsis_Pattern_Transform_Parse0;
   function Enum_Lit_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Enum_Lit_Decl
is
      Row_Pos62 : Token_Index := No_Token_Index;
      Defer_Pos68 : Token_Index := No_Token_Index;
      Defer_Res68 : Bare_Def_Id := No_Bare_Lkt_Node;
      Transform_Res41 : Bare_Enum_Lit_Decl := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Enum_Lit_Decl_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res41 := M.Instance;
      return Transform_Res41;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res41;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType EnumLitDecl>) (root of 'enum_lit_decl') at parser.lkt:228:22>
--  pos=Row_Pos62, res=Transform_Res41, nobt=None
--  BEGIN <_Row (root of 'enum_lit_decl') at parser.lkt:228:22>
--  pos=Row_Pos62, res=None, nobt=None
Row_Pos62 := Pos;
--  BEGIN <Defer (for 'def_id') at parser.lkt:228:34>
--  pos=Defer_Pos68, res=Defer_Res68, nobt=None
Defer_Res68 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos62);
Defer_Pos68 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:228:34>
if Defer_Pos68 /= No_Token_Index then
   Row_Pos62 := Defer_Pos68;
else
   Row_Pos62 := No_Token_Index;
   goto Exit_Row62_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row62_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'enum_lit_decl') at parser.lkt:228:22>
if Row_Pos62 /= No_Token_Index then
   Transform_Res41 := Allocate_Enum_Lit_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res41,
      Kind => Lkt_Enum_Lit_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos62 = Pos
                            then No_Token_Index
                            else Row_Pos62 - 1));
      Initialize_Fields_For_Enum_Lit_Decl
        (Self => Transform_Res41,
         Enum_Lit_Decl_F_Syn_Name => Defer_Res68);
         if Defer_Res68 /= null and then Is_Incomplete (Defer_Res68) then
            Transform_Res41.Last_Attempted_Child := 0;
         elsif Defer_Res68 /= null and then not Is_Ghost (Defer_Res68) then
            Transform_Res41.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType EnumLitDecl>) (root of 'enum_lit_decl') at parser.lkt:228:22>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos62 = No_Token_Index then
      Set_Failure
        (PP.Enum_Lit_Decl_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Enum_Lit_Decl_Transform_Parse0_Memo, Pos, Transform_Res41, Parser.Last_Diag, Row_Pos62);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos62;
   return Transform_Res41;
end Enum_Lit_Decl_Transform_Parse0;
   function Env_Spec_Action_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Call_Expr
is
      Row_Pos63 : Token_Index := No_Token_Index;
      Row_Pos64 : Token_Index := No_Token_Index;
      Token_Pos73 : Token_Index := No_Token_Index;
      Token_Res73 : Token_Index := No_Token_Index;
      Transform_Res42 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Token_Pos74 : Token_Index := No_Token_Index;
      Token_Res74 : Token_Index := No_Token_Index;
      Defer_Pos69 : Token_Index := No_Token_Index;
      Defer_Res69 : Bare_Argument_List := No_Bare_Lkt_Node;
      Token_Pos75 : Token_Index := No_Token_Index;
      Token_Res75 : Token_Index := No_Token_Index;
      Transform_Res43 : Bare_Call_Expr := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Env_Spec_Action_Transform_Parse1_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res43 := M.Instance;
      return Transform_Res43;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res43;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType CallExpr>) (root of 'env_spec_action') at parser.lkt:291:24>
--  pos=Row_Pos63, res=Transform_Res43, nobt=None
--  BEGIN <_Row (root of 'env_spec_action') at parser.lkt:291:24>
--  pos=Row_Pos63, res=None, nobt=None
Row_Pos63 := Pos;
--  BEGIN <Transform(<ASTNodeType RefId>) (root of 'env_spec_action') at parser.lkt:291:33>
--  pos=Row_Pos64, res=Transform_Res42, nobt=None
--  BEGIN <_Row (root of 'env_spec_action') at parser.lkt:291:33>
--  pos=Row_Pos64, res=None, nobt=None
Row_Pos64 := Row_Pos63;
--  BEGIN <Token(<WithSymbol Identifier>, ) (root of 'env_spec_action') at parser.lkt:291:39>
--  pos=Token_Pos73, res=Token_Res73, nobt=None
Token_Res73 := Row_Pos64;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res73));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
   then
       Token_Pos73 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos64 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos64,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos73 := Row_Pos64 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, ) (root of 'env_spec_action') at parser.lkt:291:39>
if Token_Pos73 /= No_Token_Index then
   Row_Pos64 := Token_Pos73;
else
   Row_Pos64 := No_Token_Index;
   goto Exit_Row64_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row64_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'env_spec_action') at parser.lkt:291:33>
if Row_Pos64 /= No_Token_Index then
   Transform_Res42 := Allocate_Ref_Id (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res42,
      Kind => Lkt_Ref_Id,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos63,
      Token_End_Index   => (if Row_Pos64 = Row_Pos63
                            then No_Token_Index
                            else Row_Pos64 - 1));
      Initialize_Fields_For_Ref_Id
        (Self => Transform_Res42);
end if;
--  END <Transform(<ASTNodeType RefId>) (root of 'env_spec_action') at parser.lkt:291:33>
if Row_Pos64 /= No_Token_Index then
   Row_Pos63 := Row_Pos64;
else
   Row_Pos63 := No_Token_Index;
   goto Exit_Row63_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'env_spec_action') at parser.lkt:291:52>
--  pos=Token_Pos74, res=Token_Res74, nobt=None
Token_Res74 := Row_Pos63;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res74));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos74 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos63 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos63,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos74 := Row_Pos63 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'env_spec_action') at parser.lkt:291:52>
if Token_Pos74 /= No_Token_Index then
   Row_Pos63 := Token_Pos74;
else
   Row_Pos63 := No_Token_Index;
   goto Exit_Row63_0;
end if;
--  BEGIN <Defer (for 'args') at parser.lkt:291:56>
--  pos=Defer_Pos69, res=Defer_Res69, nobt=None
Defer_Res69 :=
   Args_List_Parse0 (Parser, Row_Pos63);
Defer_Pos69 := Parser.Current_Pos;
--  END <Defer (for 'args') at parser.lkt:291:56>
if Defer_Pos69 /= No_Token_Index then
   Row_Pos63 := Defer_Pos69;
else
   Row_Pos63 := No_Token_Index;
   goto Exit_Row63_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'env_spec_action') at parser.lkt:291:61>
--  pos=Token_Pos75, res=Token_Res75, nobt=None
Token_Res75 := Row_Pos63;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res75));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos75 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos63 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos63,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos75 := Row_Pos63 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'env_spec_action') at parser.lkt:291:61>
if Token_Pos75 /= No_Token_Index then
   Row_Pos63 := Token_Pos75;
else
   Row_Pos63 := No_Token_Index;
   goto Exit_Row63_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row63_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'env_spec_action') at parser.lkt:291:24>
if Row_Pos63 /= No_Token_Index then
   Transform_Res43 := Allocate_Call_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res43,
      Kind => Lkt_Call_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos63 = Pos
                            then No_Token_Index
                            else Row_Pos63 - 1));
      Initialize_Fields_For_Call_Expr
        (Self => Transform_Res43,
         Base_Call_Expr_F_Name => Transform_Res42,
         Base_Call_Expr_F_Args => Defer_Res69);
         if Transform_Res42 /= null and then Is_Incomplete (Transform_Res42) then
            Transform_Res43.Last_Attempted_Child := 0;
         elsif Transform_Res42 /= null and then not Is_Ghost (Transform_Res42) then
            Transform_Res43.Last_Attempted_Child := -1;
         end if;
         if Defer_Res69 /= null and then Is_Incomplete (Defer_Res69) then
            Transform_Res43.Last_Attempted_Child := 0;
         elsif Defer_Res69 /= null and then not Is_Ghost (Defer_Res69) then
            Transform_Res43.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType CallExpr>) (root of 'env_spec_action') at parser.lkt:291:24>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos63 = No_Token_Index then
      Set_Failure
        (PP.Env_Spec_Action_Transform_Parse1_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Env_Spec_Action_Transform_Parse1_Memo, Pos, Transform_Res43, Parser.Last_Diag, Row_Pos63);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos63;
   return Transform_Res43;
end Env_Spec_Action_Transform_Parse1;
   function Env_Spec_Decl_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Env_Spec_Decl
is
      Row_Pos65 : Token_Index := No_Token_Index;
      Row_Pos66 : Token_Index := No_Token_Index;
      Token_Pos76 : Token_Index := No_Token_Index;
      Token_Res76 : Token_Index := No_Token_Index;
      Transform_Res44 : Bare_Def_Id := No_Bare_Lkt_Node;
      Token_Pos77 : Token_Index := No_Token_Index;
      Token_Res77 : Token_Index := No_Token_Index;
      Lst_Cpos7 : Token_Index := No_Token_Index;
      Tmp_List7 : Free_Parse_List;
      Defer_Pos70 : Token_Index := No_Token_Index;
      Defer_Res70 : Bare_Call_Expr := No_Bare_Lkt_Node;
      List_Pos7 : Token_Index := No_Token_Index;
      List_Res7 : Bare_Call_Expr_List := No_Bare_Lkt_Node;
      Diag_Mark26 : Diagnostic_Mark;
      Token_Pos78 : Token_Index := No_Token_Index;
      Token_Res78 : Token_Index := No_Token_Index;
      Transform_Res45 : Bare_Env_Spec_Decl := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Env_Spec_Decl_Transform_Parse1_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res45 := M.Instance;
      return Transform_Res45;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res45;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType EnvSpecDecl>) (root of 'env_spec_decl') at parser.lkt:292:22>
--  pos=Row_Pos65, res=Transform_Res45, nobt=None
--  BEGIN <_Row (root of 'env_spec_decl') at parser.lkt:292:22>
--  pos=Row_Pos65, res=None, nobt=None
Row_Pos65 := Pos;
--  BEGIN <Transform(<ASTNodeType DefId>) (root of 'env_spec_decl') at parser.lkt:293:9>
--  pos=Row_Pos66, res=Transform_Res44, nobt=None
--  BEGIN <_Row (root of 'env_spec_decl') at parser.lkt:293:9>
--  pos=Row_Pos66, res=None, nobt=None
Row_Pos66 := Row_Pos65;
--  BEGIN <Token(<WithSymbol Identifier>, env_spec) (root of 'env_spec_decl') at parser.lkt:293:15>
--  pos=Token_Pos76, res=Token_Res76, nobt=None
Token_Res76 := Row_Pos66;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res76));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Env_Spec)
   then
       Token_Pos76 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos66 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos66,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos76 := Row_Pos66 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, env_spec) (root of 'env_spec_decl') at parser.lkt:293:15>
if Token_Pos76 /= No_Token_Index then
   Row_Pos66 := Token_Pos76;
else
   Row_Pos66 := No_Token_Index;
   goto Exit_Row66_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row66_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'env_spec_decl') at parser.lkt:293:9>
if Row_Pos66 /= No_Token_Index then
   Transform_Res44 := Allocate_Def_Id (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res44,
      Kind => Lkt_Def_Id,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos65,
      Token_End_Index   => (if Row_Pos66 = Row_Pos65
                            then No_Token_Index
                            else Row_Pos66 - 1));
      Initialize_Fields_For_Def_Id
        (Self => Transform_Res44);
end if;
--  END <Transform(<ASTNodeType DefId>) (root of 'env_spec_decl') at parser.lkt:293:9>
if Row_Pos66 /= No_Token_Index then
   Row_Pos65 := Row_Pos66;
else
   Row_Pos65 := No_Token_Index;
   goto Exit_Row65_0;
end if;
--  BEGIN <Token(<WithText LBrace>, ) (root of 'env_spec_decl') at parser.lkt:293:40>
--  pos=Token_Pos77, res=Token_Res77, nobt=None
Token_Res77 := Row_Pos65;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res77));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos77 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos65 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos65,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos77 := Row_Pos65 + 1;
   end if;
end;
--  END <Token(<WithText LBrace>, ) (root of 'env_spec_decl') at parser.lkt:293:40>
if Token_Pos77 /= No_Token_Index then
   Row_Pos65 := Token_Pos77;
else
   Row_Pos65 := No_Token_Index;
   goto Exit_Row65_0;
end if;
--  BEGIN <List (root of 'env_spec_decl') at parser.lkt:293:44>
--  pos=List_Pos7, res=List_Res7, nobt=None
    List_Pos7 := Row_Pos65;
Lst_Cpos7 := Row_Pos65;
Tmp_List7 := Get_Parse_List (Parser);
Diag_Mark26 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'env_spec_action') at parser.lkt:293:50>
--  pos=Defer_Pos70, res=Defer_Res70, nobt=None
Defer_Res70 :=
   Env_Spec_Action_Transform_Parse1 (Parser, Lst_Cpos7);
Defer_Pos70 := Parser.Current_Pos;
--  END <Defer (for 'env_spec_action') at parser.lkt:293:50>
   exit when Defer_Pos70 = No_Token_Index;
   List_Pos7 := Defer_Pos70;
   Lst_Cpos7 := List_Pos7;
   Diag_Mark26 := Parser.Last_Diag;
   Tmp_List7.Nodes.Append (Defer_Res70);
end loop;
Parser.Last_Diag := Diag_Mark26;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List7.Nodes.Length;
begin
   List_Res7 := Allocate_Call_Expr_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos65;
      Token_End := (if Lst_Cpos7 = Row_Pos65
                    then Row_Pos65
                    else List_Pos7 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos65, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res7,
      Kind              => Lkt_Call_Expr_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res7,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List7.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res7.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List7);
--  END <List (root of 'env_spec_decl') at parser.lkt:293:44>
if List_Pos7 /= No_Token_Index then
   Row_Pos65 := List_Pos7;
else
   Row_Pos65 := No_Token_Index;
   goto Exit_Row65_0;
end if;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'env_spec_decl') at parser.lkt:293:67>
--  pos=Token_Pos78, res=Token_Res78, nobt=None
Token_Res78 := Row_Pos65;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res78));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos78 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos65 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos65,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos78 := Row_Pos65 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'env_spec_decl') at parser.lkt:293:67>
if Token_Pos78 /= No_Token_Index then
   Row_Pos65 := Token_Pos78;
else
   Row_Pos65 := No_Token_Index;
   goto Exit_Row65_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row65_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'env_spec_decl') at parser.lkt:292:22>
if Row_Pos65 /= No_Token_Index then
   Transform_Res45 := Allocate_Env_Spec_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res45,
      Kind => Lkt_Env_Spec_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos65 = Pos
                            then No_Token_Index
                            else Row_Pos65 - 1));
      Initialize_Fields_For_Env_Spec_Decl
        (Self => Transform_Res45,
         Env_Spec_Decl_F_Syn_Name => Transform_Res44,
         Env_Spec_Decl_F_Actions => List_Res7);
         if Transform_Res44 /= null and then Is_Incomplete (Transform_Res44) then
            Transform_Res45.Last_Attempted_Child := 0;
         elsif Transform_Res44 /= null and then not Is_Ghost (Transform_Res44) then
            Transform_Res45.Last_Attempted_Child := -1;
         end if;
         if List_Res7 /= null and then Is_Incomplete (List_Res7) then
            Transform_Res45.Last_Attempted_Child := 0;
         elsif List_Res7 /= null and then not Is_Ghost (List_Res7) then
            Transform_Res45.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType EnvSpecDecl>) (root of 'env_spec_decl') at parser.lkt:292:22>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos65 = No_Token_Index then
      Set_Failure
        (PP.Env_Spec_Decl_Transform_Parse1_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Env_Spec_Decl_Transform_Parse1_Memo, Pos, Transform_Res45, Parser.Last_Diag, Row_Pos65);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos65;
   return Transform_Res45;
end Env_Spec_Decl_Transform_Parse1;
   function Eq_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
      Row_Pos67 : Token_Index := No_Token_Index;
      Defer_Pos71 : Token_Index := No_Token_Index;
      Defer_Res71 : Bare_Expr := No_Bare_Lkt_Node;
      Row_Pos68 : Token_Index := No_Token_Index;
      Token_Pos79 : Token_Index := No_Token_Index;
      Token_Res79 : Token_Index := No_Token_Index;
      Transform_Res46 : Bare_Op_Lte := No_Bare_Lkt_Node;
      Row_Pos69 : Token_Index := No_Token_Index;
      Token_Pos80 : Token_Index := No_Token_Index;
      Token_Res80 : Token_Index := No_Token_Index;
      Transform_Res47 : Bare_Op_Lt := No_Bare_Lkt_Node;
      Row_Pos70 : Token_Index := No_Token_Index;
      Token_Pos81 : Token_Index := No_Token_Index;
      Token_Res81 : Token_Index := No_Token_Index;
      Transform_Res48 : Bare_Op_Gte := No_Bare_Lkt_Node;
      Row_Pos71 : Token_Index := No_Token_Index;
      Token_Pos82 : Token_Index := No_Token_Index;
      Token_Res82 : Token_Index := No_Token_Index;
      Transform_Res49 : Bare_Op_Gt := No_Bare_Lkt_Node;
      Row_Pos72 : Token_Index := No_Token_Index;
      Token_Pos83 : Token_Index := No_Token_Index;
      Token_Res83 : Token_Index := No_Token_Index;
      Transform_Res50 : Bare_Op_Eq := No_Bare_Lkt_Node;
      Row_Pos73 : Token_Index := No_Token_Index;
      Token_Pos84 : Token_Index := No_Token_Index;
      Token_Res84 : Token_Index := No_Token_Index;
      Transform_Res51 : Bare_Op_Ne := No_Bare_Lkt_Node;
      Or_Pos13 : Token_Index := No_Token_Index;
      Or_Res13 : Bare_Op := No_Bare_Lkt_Node;
      Diag_Mark27 : Diagnostic_Mark;
      Last_Fail13 : Fail_Info;
      Branch_Diag_Mark13 : Diagnostic_Mark;
      Branch_Last_Fail13 : Fail_Info;
      Defer_Pos72 : Token_Index := No_Token_Index;
      Defer_Res72 : Bare_Expr := No_Bare_Lkt_Node;
      Transform_Res52 : Bare_Bin_Op := No_Bare_Lkt_Node;
      Defer_Pos73 : Token_Index := No_Token_Index;
      Defer_Res73 : Bare_Expr := No_Bare_Lkt_Node;
      Or_Pos14 : Token_Index := No_Token_Index;
      Or_Res14 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark28 : Diagnostic_Mark;
      Last_Fail14 : Fail_Info;
      Branch_Diag_Mark14 : Diagnostic_Mark;
      Branch_Last_Fail14 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
      Mem_Pos  : Token_Index := Pos;
      Mem_Res  : Bare_Expr := No_Bare_Lkt_Node;
      Mem_Mark : Diagnostic_Mark := Mark_On_Entry;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Eq_Or_Parse1_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res14 := M.Instance;
      return Or_Res14;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res14;
   end if;
   Parser.Last_Diag := No_Diagnostic;
       Set_Failure
         (PP.Eq_Or_Parse1_Memo,
          Pos,
          Parser.Last_Fail,
          Parser.Last_Diag);
       <<Try_Again>>
       Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'eq') at parser.lkt:378:11>
--  pos=Or_Pos14, res=Or_Res14, nobt=None
Or_Pos14 := No_Token_Index;
Or_Res14 := No_Bare_Lkt_Node;
Diag_Mark28 := Parser.Last_Diag;
Last_Fail14 := Parser.Last_Fail;
Branch_Diag_Mark14 := Parser.Last_Diag;
Branch_Last_Fail14 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark28;
    Parser.Last_Fail := Last_Fail14;
--  BEGIN <Transform(<ASTNodeType BinOp>) (root of 'eq') at parser.lkt:379:11>
--  pos=Row_Pos67, res=Transform_Res52, nobt=None
--  BEGIN <_Row (root of 'eq') at parser.lkt:379:11>
--  pos=Row_Pos67, res=None, nobt=None
Row_Pos67 := Pos;
--  BEGIN <Defer (for 'eq') at parser.lkt:380:13>
--  pos=Defer_Pos71, res=Defer_Res71, nobt=None
Defer_Res71 :=
   Eq_Or_Parse1 (Parser, Row_Pos67);
Defer_Pos71 := Parser.Current_Pos;
--  END <Defer (for 'eq') at parser.lkt:380:13>
if Defer_Pos71 /= No_Token_Index then
   Row_Pos67 := Defer_Pos71;
else
   Row_Pos67 := No_Token_Index;
   goto Exit_Row67_0;
end if;
--  BEGIN <Or (root of 'eq') at parser.lkt:381:13>
--  pos=Or_Pos13, res=Or_Res13, nobt=None
Or_Pos13 := No_Token_Index;
Or_Res13 := No_Bare_Lkt_Node;
Diag_Mark27 := Parser.Last_Diag;
Last_Fail13 := Parser.Last_Fail;
Branch_Diag_Mark13 := Parser.Last_Diag;
Branch_Last_Fail13 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark27;
    Parser.Last_Fail := Last_Fail13;
--  BEGIN <Transform(<ASTNodeType Op.Lte>) (root of 'eq') at parser.lkt:382:19>
--  pos=Row_Pos68, res=Transform_Res46, nobt=None
--  BEGIN <_Row (root of 'eq') at parser.lkt:382:19>
--  pos=Row_Pos68, res=None, nobt=None
Row_Pos68 := Row_Pos67;
--  BEGIN <Token(<WithText LTE>, ) (root of 'eq') at parser.lkt:382:26>
--  pos=Token_Pos79, res=Token_Res79, nobt=None
Token_Res79 := Row_Pos68;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res79));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_T_E)
   then
       Token_Pos79 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos68 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos68,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_T_E,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos79 := Row_Pos68 + 1;
   end if;
end;
--  END <Token(<WithText LTE>, ) (root of 'eq') at parser.lkt:382:26>
if Token_Pos79 /= No_Token_Index then
   Row_Pos68 := Token_Pos79;
else
   Row_Pos68 := No_Token_Index;
   goto Exit_Row68_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row68_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'eq') at parser.lkt:382:19>
if Row_Pos68 /= No_Token_Index then
   Transform_Res46 := Allocate_Op_Lte (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res46,
      Kind => Lkt_Op_Lte,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos67,
      Token_End_Index   => (if Row_Pos68 = Row_Pos67
                            then No_Token_Index
                            else Row_Pos68 - 1));
end if;
--  END <Transform(<ASTNodeType Op.Lte>) (root of 'eq') at parser.lkt:382:19>
    if Row_Pos68 /= No_Token_Index then
        Or_Pos13 := Row_Pos68;
        Or_Res13 := Transform_Res46;
        goto Exit_Or16;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail13.Pos then
       Branch_Diag_Mark13 := Parser.Last_Diag;
       Branch_Last_Fail13 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark27;
    Parser.Last_Fail := Last_Fail13;
--  BEGIN <Transform(<ASTNodeType Op.Lt>) (root of 'eq') at parser.lkt:383:19>
--  pos=Row_Pos69, res=Transform_Res47, nobt=None
--  BEGIN <_Row (root of 'eq') at parser.lkt:383:19>
--  pos=Row_Pos69, res=None, nobt=None
Row_Pos69 := Row_Pos67;
--  BEGIN <Token(<WithText LT>, ) (root of 'eq') at parser.lkt:383:25>
--  pos=Token_Pos80, res=Token_Res80, nobt=None
Token_Res80 := Row_Pos69;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res80));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_T)
   then
       Token_Pos80 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos69 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos69,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_T,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos80 := Row_Pos69 + 1;
   end if;
end;
--  END <Token(<WithText LT>, ) (root of 'eq') at parser.lkt:383:25>
if Token_Pos80 /= No_Token_Index then
   Row_Pos69 := Token_Pos80;
else
   Row_Pos69 := No_Token_Index;
   goto Exit_Row69_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row69_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'eq') at parser.lkt:383:19>
if Row_Pos69 /= No_Token_Index then
   Transform_Res47 := Allocate_Op_Lt (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res47,
      Kind => Lkt_Op_Lt,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos67,
      Token_End_Index   => (if Row_Pos69 = Row_Pos67
                            then No_Token_Index
                            else Row_Pos69 - 1));
end if;
--  END <Transform(<ASTNodeType Op.Lt>) (root of 'eq') at parser.lkt:383:19>
    if Row_Pos69 /= No_Token_Index then
        Or_Pos13 := Row_Pos69;
        Or_Res13 := Transform_Res47;
        goto Exit_Or16;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail13.Pos then
       Branch_Diag_Mark13 := Parser.Last_Diag;
       Branch_Last_Fail13 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark27;
    Parser.Last_Fail := Last_Fail13;
--  BEGIN <Transform(<ASTNodeType Op.Gte>) (root of 'eq') at parser.lkt:384:19>
--  pos=Row_Pos70, res=Transform_Res48, nobt=None
--  BEGIN <_Row (root of 'eq') at parser.lkt:384:19>
--  pos=Row_Pos70, res=None, nobt=None
Row_Pos70 := Row_Pos67;
--  BEGIN <Token(<WithText GTE>, ) (root of 'eq') at parser.lkt:384:26>
--  pos=Token_Pos81, res=Token_Res81, nobt=None
Token_Res81 := Row_Pos70;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res81));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_G_T_E)
   then
       Token_Pos81 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos70 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos70,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_G_T_E,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos81 := Row_Pos70 + 1;
   end if;
end;
--  END <Token(<WithText GTE>, ) (root of 'eq') at parser.lkt:384:26>
if Token_Pos81 /= No_Token_Index then
   Row_Pos70 := Token_Pos81;
else
   Row_Pos70 := No_Token_Index;
   goto Exit_Row70_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row70_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'eq') at parser.lkt:384:19>
if Row_Pos70 /= No_Token_Index then
   Transform_Res48 := Allocate_Op_Gte (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res48,
      Kind => Lkt_Op_Gte,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos67,
      Token_End_Index   => (if Row_Pos70 = Row_Pos67
                            then No_Token_Index
                            else Row_Pos70 - 1));
end if;
--  END <Transform(<ASTNodeType Op.Gte>) (root of 'eq') at parser.lkt:384:19>
    if Row_Pos70 /= No_Token_Index then
        Or_Pos13 := Row_Pos70;
        Or_Res13 := Transform_Res48;
        goto Exit_Or16;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail13.Pos then
       Branch_Diag_Mark13 := Parser.Last_Diag;
       Branch_Last_Fail13 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark27;
    Parser.Last_Fail := Last_Fail13;
--  BEGIN <Transform(<ASTNodeType Op.Gt>) (root of 'eq') at parser.lkt:385:19>
--  pos=Row_Pos71, res=Transform_Res49, nobt=None
--  BEGIN <_Row (root of 'eq') at parser.lkt:385:19>
--  pos=Row_Pos71, res=None, nobt=None
Row_Pos71 := Row_Pos67;
--  BEGIN <Token(<WithText GT>, ) (root of 'eq') at parser.lkt:385:25>
--  pos=Token_Pos82, res=Token_Res82, nobt=None
Token_Res82 := Row_Pos71;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res82));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_G_T)
   then
       Token_Pos82 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos71 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos71,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_G_T,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos82 := Row_Pos71 + 1;
   end if;
end;
--  END <Token(<WithText GT>, ) (root of 'eq') at parser.lkt:385:25>
if Token_Pos82 /= No_Token_Index then
   Row_Pos71 := Token_Pos82;
else
   Row_Pos71 := No_Token_Index;
   goto Exit_Row71_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row71_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'eq') at parser.lkt:385:19>
if Row_Pos71 /= No_Token_Index then
   Transform_Res49 := Allocate_Op_Gt (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res49,
      Kind => Lkt_Op_Gt,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos67,
      Token_End_Index   => (if Row_Pos71 = Row_Pos67
                            then No_Token_Index
                            else Row_Pos71 - 1));
end if;
--  END <Transform(<ASTNodeType Op.Gt>) (root of 'eq') at parser.lkt:385:19>
    if Row_Pos71 /= No_Token_Index then
        Or_Pos13 := Row_Pos71;
        Or_Res13 := Transform_Res49;
        goto Exit_Or16;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail13.Pos then
       Branch_Diag_Mark13 := Parser.Last_Diag;
       Branch_Last_Fail13 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark27;
    Parser.Last_Fail := Last_Fail13;
--  BEGIN <Transform(<ASTNodeType Op.Eq>) (root of 'eq') at parser.lkt:386:19>
--  pos=Row_Pos72, res=Transform_Res50, nobt=None
--  BEGIN <_Row (root of 'eq') at parser.lkt:386:19>
--  pos=Row_Pos72, res=None, nobt=None
Row_Pos72 := Row_Pos67;
--  BEGIN <Token(<WithText EQ>, ) (root of 'eq') at parser.lkt:386:25>
--  pos=Token_Pos83, res=Token_Res83, nobt=None
Token_Res83 := Row_Pos72;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res83));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_E_Q)
   then
       Token_Pos83 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos72 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos72,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_E_Q,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos83 := Row_Pos72 + 1;
   end if;
end;
--  END <Token(<WithText EQ>, ) (root of 'eq') at parser.lkt:386:25>
if Token_Pos83 /= No_Token_Index then
   Row_Pos72 := Token_Pos83;
else
   Row_Pos72 := No_Token_Index;
   goto Exit_Row72_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row72_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'eq') at parser.lkt:386:19>
if Row_Pos72 /= No_Token_Index then
   Transform_Res50 := Allocate_Op_Eq (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res50,
      Kind => Lkt_Op_Eq,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos67,
      Token_End_Index   => (if Row_Pos72 = Row_Pos67
                            then No_Token_Index
                            else Row_Pos72 - 1));
end if;
--  END <Transform(<ASTNodeType Op.Eq>) (root of 'eq') at parser.lkt:386:19>
    if Row_Pos72 /= No_Token_Index then
        Or_Pos13 := Row_Pos72;
        Or_Res13 := Transform_Res50;
        goto Exit_Or16;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail13.Pos then
       Branch_Diag_Mark13 := Parser.Last_Diag;
       Branch_Last_Fail13 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark27;
    Parser.Last_Fail := Last_Fail13;
--  BEGIN <Transform(<ASTNodeType Op.Ne>) (root of 'eq') at parser.lkt:387:19>
--  pos=Row_Pos73, res=Transform_Res51, nobt=None
--  BEGIN <_Row (root of 'eq') at parser.lkt:387:19>
--  pos=Row_Pos73, res=None, nobt=None
Row_Pos73 := Row_Pos67;
--  BEGIN <Token(<WithText NE>, ) (root of 'eq') at parser.lkt:387:25>
--  pos=Token_Pos84, res=Token_Res84, nobt=None
Token_Res84 := Row_Pos73;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res84));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_N_E)
   then
       Token_Pos84 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos73 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos73,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_N_E,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos84 := Row_Pos73 + 1;
   end if;
end;
--  END <Token(<WithText NE>, ) (root of 'eq') at parser.lkt:387:25>
if Token_Pos84 /= No_Token_Index then
   Row_Pos73 := Token_Pos84;
else
   Row_Pos73 := No_Token_Index;
   goto Exit_Row73_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row73_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'eq') at parser.lkt:387:19>
if Row_Pos73 /= No_Token_Index then
   Transform_Res51 := Allocate_Op_Ne (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res51,
      Kind => Lkt_Op_Ne,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos67,
      Token_End_Index   => (if Row_Pos73 = Row_Pos67
                            then No_Token_Index
                            else Row_Pos73 - 1));
end if;
--  END <Transform(<ASTNodeType Op.Ne>) (root of 'eq') at parser.lkt:387:19>
    if Row_Pos73 /= No_Token_Index then
        Or_Pos13 := Row_Pos73;
        Or_Res13 := Transform_Res51;
        goto Exit_Or16;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail13.Pos then
       Branch_Diag_Mark13 := Parser.Last_Diag;
       Branch_Last_Fail13 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark13;
Parser.Last_Fail := Branch_Last_Fail13;
<<Exit_Or16>>
--  END <Or (root of 'eq') at parser.lkt:381:13>
if Or_Pos13 /= No_Token_Index then
   Row_Pos67 := Or_Pos13;
else
   Row_Pos67 := No_Token_Index;
   goto Exit_Row67_0;
end if;
--  BEGIN <Defer (for 'arith_1') at parser.lkt:389:13>
--  pos=Defer_Pos72, res=Defer_Res72, nobt=None
Defer_Res72 :=
   Arith_1_Or_Parse1 (Parser, Row_Pos67);
Defer_Pos72 := Parser.Current_Pos;
--  END <Defer (for 'arith_1') at parser.lkt:389:13>
if Defer_Pos72 /= No_Token_Index then
   Row_Pos67 := Defer_Pos72;
else
   Row_Pos67 := No_Token_Index;
   goto Exit_Row67_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row67_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'eq') at parser.lkt:379:11>
if Row_Pos67 /= No_Token_Index then
   Transform_Res52 := Allocate_Bin_Op (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res52,
      Kind => Lkt_Bin_Op,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos67 = Pos
                            then No_Token_Index
                            else Row_Pos67 - 1));
      Initialize_Fields_For_Bin_Op
        (Self => Transform_Res52,
         Bin_Op_F_Left => Defer_Res71,
         Bin_Op_F_Op => Or_Res13,
         Bin_Op_F_Right => Defer_Res72);
         if Defer_Res71 /= null and then Is_Incomplete (Defer_Res71) then
            Transform_Res52.Last_Attempted_Child := 0;
         elsif Defer_Res71 /= null and then not Is_Ghost (Defer_Res71) then
            Transform_Res52.Last_Attempted_Child := -1;
         end if;
         if Or_Res13 /= null and then Is_Incomplete (Or_Res13) then
            Transform_Res52.Last_Attempted_Child := 0;
         elsif Or_Res13 /= null and then not Is_Ghost (Or_Res13) then
            Transform_Res52.Last_Attempted_Child := -1;
         end if;
         if Defer_Res72 /= null and then Is_Incomplete (Defer_Res72) then
            Transform_Res52.Last_Attempted_Child := 0;
         elsif Defer_Res72 /= null and then not Is_Ghost (Defer_Res72) then
            Transform_Res52.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType BinOp>) (root of 'eq') at parser.lkt:379:11>
    if Row_Pos67 /= No_Token_Index then
        Or_Pos14 := Row_Pos67;
        Or_Res14 := Transform_Res52;
        goto Exit_Or15;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail14.Pos then
       Branch_Diag_Mark14 := Parser.Last_Diag;
       Branch_Last_Fail14 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark28;
    Parser.Last_Fail := Last_Fail14;
--  BEGIN <Defer (for 'arith_1') at parser.lkt:391:11>
--  pos=Defer_Pos73, res=Defer_Res73, nobt=None
Defer_Res73 :=
   Arith_1_Or_Parse1 (Parser, Pos);
Defer_Pos73 := Parser.Current_Pos;
--  END <Defer (for 'arith_1') at parser.lkt:391:11>
    if Defer_Pos73 /= No_Token_Index then
        Or_Pos14 := Defer_Pos73;
        Or_Res14 := Defer_Res73;
        goto Exit_Or15;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail14.Pos then
       Branch_Diag_Mark14 := Parser.Last_Diag;
       Branch_Last_Fail14 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark14;
Parser.Last_Fail := Branch_Last_Fail14;
<<Exit_Or15>>
--  END <Or (root of 'eq') at parser.lkt:378:11>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
      if Or_Pos14 > Mem_Pos then
         Mem_Pos := Or_Pos14;
         Mem_Res := Or_Res14;
         Mem_Mark := Parser.Last_Diag;
         if Or_Pos14 = No_Token_Index then
            Set_Failure (PP.Eq_Or_Parse1_Memo, Pos, Parser.Last_Fail, Mem_Mark);
         else
            Memos.Set_Success
              (PP.Eq_Or_Parse1_Memo,
               Pos,
               Or_Res14,
               Mem_Mark,
               Or_Pos14);
         end if;
         goto Try_Again;
      elsif Mem_Pos > Pos then
         Or_Res14 := Mem_Res;
         Or_Pos14 := Mem_Pos;
         Parser.Last_Diag := Mem_Mark;
         goto No_Memo;
      end if;
   if Or_Pos14 = No_Token_Index then
      Set_Failure
        (PP.Eq_Or_Parse1_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Eq_Or_Parse1_Memo, Pos, Or_Res14, Parser.Last_Diag, Or_Pos14);
   end if;
       <<No_Memo>>
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos14;
   return Or_Res14;
end Eq_Or_Parse1;
   function Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
      Row_Pos74 : Token_Index := No_Token_Index;
      Defer_Pos74 : Token_Index := No_Token_Index;
      Defer_Res74 : Bare_Expr := No_Bare_Lkt_Node;
      Row_Pos75 : Token_Index := No_Token_Index;
      Token_Pos85 : Token_Index := No_Token_Index;
      Token_Res85 : Token_Index := No_Token_Index;
      Transform_Res53 : Bare_Op_Stream_Concat := No_Bare_Lkt_Node;
      Defer_Pos75 : Token_Index := No_Token_Index;
      Defer_Res75 : Bare_Expr := No_Bare_Lkt_Node;
      Transform_Res54 : Bare_Bin_Op := No_Bare_Lkt_Node;
      Defer_Pos76 : Token_Index := No_Token_Index;
      Defer_Res76 : Bare_Expr := No_Bare_Lkt_Node;
      Or_Pos15 : Token_Index := No_Token_Index;
      Or_Res15 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark29 : Diagnostic_Mark;
      Last_Fail15 : Fail_Info;
      Branch_Diag_Mark15 : Diagnostic_Mark;
      Branch_Last_Fail15 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Expr_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res15 := M.Instance;
      return Or_Res15;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res15;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'expr') at parser.lkt:355:13>
--  pos=Or_Pos15, res=Or_Res15, nobt=None
Or_Pos15 := No_Token_Index;
Or_Res15 := No_Bare_Lkt_Node;
Diag_Mark29 := Parser.Last_Diag;
Last_Fail15 := Parser.Last_Fail;
Branch_Diag_Mark15 := Parser.Last_Diag;
Branch_Last_Fail15 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark29;
    Parser.Last_Fail := Last_Fail15;
--  BEGIN <Transform(<ASTNodeType BinOp>) (root of 'expr') at parser.lkt:356:11>
--  pos=Row_Pos74, res=Transform_Res54, nobt=None
--  BEGIN <_Row (root of 'expr') at parser.lkt:356:11>
--  pos=Row_Pos74, res=None, nobt=None
Row_Pos74 := Pos;
--  BEGIN <Defer (for 'stream_concat') at parser.lkt:356:17>
--  pos=Defer_Pos74, res=Defer_Res74, nobt=None
Defer_Res74 :=
   Stream_Concat_Or_Parse0 (Parser, Row_Pos74);
Defer_Pos74 := Parser.Current_Pos;
--  END <Defer (for 'stream_concat') at parser.lkt:356:17>
if Defer_Pos74 /= No_Token_Index then
   Row_Pos74 := Defer_Pos74;
else
   Row_Pos74 := No_Token_Index;
   goto Exit_Row74_0;
end if;
--  BEGIN <Transform(<ASTNodeType Op.StreamConcat>) (root of 'expr') at parser.lkt:356:31>
--  pos=Row_Pos75, res=Transform_Res53, nobt=None
--  BEGIN <_Row (root of 'expr') at parser.lkt:356:31>
--  pos=Row_Pos75, res=None, nobt=None
Row_Pos75 := Row_Pos74;
--  BEGIN <Token(<WithText TripleColon>, ) (root of 'expr') at parser.lkt:356:47>
--  pos=Token_Pos85, res=Token_Res85, nobt=None
Token_Res85 := Row_Pos75;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res85));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Triple_Colon)
   then
       Token_Pos85 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos75 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos75,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Triple_Colon,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos85 := Row_Pos75 + 1;
   end if;
end;
--  END <Token(<WithText TripleColon>, ) (root of 'expr') at parser.lkt:356:47>
if Token_Pos85 /= No_Token_Index then
   Row_Pos75 := Token_Pos85;
else
   Row_Pos75 := No_Token_Index;
   goto Exit_Row75_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row75_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'expr') at parser.lkt:356:31>
if Row_Pos75 /= No_Token_Index then
   Transform_Res53 := Allocate_Op_Stream_Concat (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res53,
      Kind => Lkt_Op_Stream_Concat,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos74,
      Token_End_Index   => (if Row_Pos75 = Row_Pos74
                            then No_Token_Index
                            else Row_Pos75 - 1));
end if;
--  END <Transform(<ASTNodeType Op.StreamConcat>) (root of 'expr') at parser.lkt:356:31>
if Row_Pos75 /= No_Token_Index then
   Row_Pos74 := Row_Pos75;
else
   Row_Pos74 := No_Token_Index;
   goto Exit_Row74_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:356:54>
--  pos=Defer_Pos75, res=Defer_Res75, nobt=None
Defer_Res75 :=
   Expr_Or_Parse0 (Parser, Row_Pos74);
Defer_Pos75 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:356:54>
if Defer_Pos75 /= No_Token_Index then
   Row_Pos74 := Defer_Pos75;
else
   Row_Pos74 := No_Token_Index;
   goto Exit_Row74_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row74_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'expr') at parser.lkt:356:11>
if Row_Pos74 /= No_Token_Index then
   Transform_Res54 := Allocate_Bin_Op (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res54,
      Kind => Lkt_Bin_Op,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos74 = Pos
                            then No_Token_Index
                            else Row_Pos74 - 1));
      Initialize_Fields_For_Bin_Op
        (Self => Transform_Res54,
         Bin_Op_F_Left => Defer_Res74,
         Bin_Op_F_Op => Transform_Res53,
         Bin_Op_F_Right => Defer_Res75);
         if Defer_Res74 /= null and then Is_Incomplete (Defer_Res74) then
            Transform_Res54.Last_Attempted_Child := 0;
         elsif Defer_Res74 /= null and then not Is_Ghost (Defer_Res74) then
            Transform_Res54.Last_Attempted_Child := -1;
         end if;
         if Transform_Res53 /= null and then Is_Incomplete (Transform_Res53) then
            Transform_Res54.Last_Attempted_Child := 0;
         elsif Transform_Res53 /= null and then not Is_Ghost (Transform_Res53) then
            Transform_Res54.Last_Attempted_Child := -1;
         end if;
         if Defer_Res75 /= null and then Is_Incomplete (Defer_Res75) then
            Transform_Res54.Last_Attempted_Child := 0;
         elsif Defer_Res75 /= null and then not Is_Ghost (Defer_Res75) then
            Transform_Res54.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType BinOp>) (root of 'expr') at parser.lkt:356:11>
    if Row_Pos74 /= No_Token_Index then
        Or_Pos15 := Row_Pos74;
        Or_Res15 := Transform_Res54;
        goto Exit_Or17;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail15.Pos then
       Branch_Diag_Mark15 := Parser.Last_Diag;
       Branch_Last_Fail15 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark29;
    Parser.Last_Fail := Last_Fail15;
--  BEGIN <Defer (for 'stream_concat') at parser.lkt:357:11>
--  pos=Defer_Pos76, res=Defer_Res76, nobt=None
Defer_Res76 :=
   Stream_Concat_Or_Parse0 (Parser, Pos);
Defer_Pos76 := Parser.Current_Pos;
--  END <Defer (for 'stream_concat') at parser.lkt:357:11>
    if Defer_Pos76 /= No_Token_Index then
        Or_Pos15 := Defer_Pos76;
        Or_Res15 := Defer_Res76;
        goto Exit_Or17;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail15.Pos then
       Branch_Diag_Mark15 := Parser.Last_Diag;
       Branch_Last_Fail15 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark15;
Parser.Last_Fail := Branch_Last_Fail15;
<<Exit_Or17>>
--  END <Or (root of 'expr') at parser.lkt:355:13>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos15 = No_Token_Index then
      Set_Failure
        (PP.Expr_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Expr_Or_Parse0_Memo, Pos, Or_Res15, Parser.Last_Diag, Or_Pos15);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos15;
   return Or_Res15;
end Expr_Or_Parse0;
   function Field_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Field_Decl
is
      Row_Pos76 : Token_Index := No_Token_Index;
      Defer_Pos77 : Token_Index := No_Token_Index;
      Defer_Res77 : Bare_Def_Id := No_Bare_Lkt_Node;
      Token_Pos86 : Token_Index := No_Token_Index;
      Token_Res86 : Token_Index := No_Token_Index;
      Defer_Pos78 : Token_Index := No_Token_Index;
      Defer_Res78 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Row_Pos77 : Token_Index := No_Token_Index;
      Token_Pos87 : Token_Index := No_Token_Index;
      Token_Res87 : Token_Index := No_Token_Index;
      Defer_Pos79 : Token_Index := No_Token_Index;
      Defer_Res79 : Bare_Dot_Expr := No_Bare_Lkt_Node;
      Diag_Mark30 : Diagnostic_Mark;
      Row_Pos78 : Token_Index := No_Token_Index;
      Token_Pos88 : Token_Index := No_Token_Index;
      Token_Res88 : Token_Index := No_Token_Index;
      Defer_Pos80 : Token_Index := No_Token_Index;
      Defer_Res80 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark31 : Diagnostic_Mark;
      Transform_Res55 : Bare_Field_Decl := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Field_Decl_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res55 := M.Instance;
      return Transform_Res55;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res55;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType FieldDecl>) (root of 'field_decl') at parser.lkt:249:19>
--  pos=Row_Pos76, res=Transform_Res55, nobt=None
--  BEGIN <_Row (root of 'field_decl') at parser.lkt:249:19>
--  pos=Row_Pos76, res=None, nobt=None
Row_Pos76 := Pos;
--  BEGIN <Defer (for 'def_id') at parser.lkt:250:9>
--  pos=Defer_Pos77, res=Defer_Res77, nobt=None
Defer_Res77 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos76);
Defer_Pos77 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:250:9>
if Defer_Pos77 /= No_Token_Index then
   Row_Pos76 := Defer_Pos77;
else
   Row_Pos76 := No_Token_Index;
   goto Exit_Row76_0;
end if;
--  BEGIN <Token(<WithText Colon>, ) (root of 'field_decl') at parser.lkt:251:9>
--  pos=Token_Pos86, res=Token_Res86, nobt=None
Token_Res86 := Row_Pos76;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res86));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos86 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos76 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos76,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Colon,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos86 := Row_Pos76 + 1;
   end if;
end;
--  END <Token(<WithText Colon>, ) (root of 'field_decl') at parser.lkt:251:9>
if Token_Pos86 /= No_Token_Index then
   Row_Pos76 := Token_Pos86;
else
   Row_Pos76 := No_Token_Index;
   goto Exit_Row76_0;
end if;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:252:9>
--  pos=Defer_Pos78, res=Defer_Res78, nobt=None
Defer_Res78 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos76);
Defer_Pos78 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:252:9>
if Defer_Pos78 /= No_Token_Index then
   Row_Pos76 := Defer_Pos78;
else
   Row_Pos76 := No_Token_Index;
   goto Exit_Row76_0;
end if;
--  BEGIN <Opt (root of 'field_decl') at parser.lkt:253:9>
--  pos=Row_Pos77, res=Defer_Res79, nobt=None
Diag_Mark30 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'field_decl') at parser.lkt:253:10>
--  pos=Row_Pos77, res=Defer_Res79, nobt=None
--  BEGIN <_Row (root of 'field_decl') at parser.lkt:253:10>
--  pos=Row_Pos77, res=None, nobt=None
Row_Pos77 := Row_Pos76;
--  BEGIN <Token(<WithText ImplementsKw>, ) (root of 'field_decl') at parser.lkt:253:15>
--  pos=Token_Pos87, res=Token_Res87, nobt=None
Token_Res87 := Row_Pos77;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res87));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Implements_Kw)
   then
       Token_Pos87 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos77 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos77,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Implements_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos87 := Row_Pos77 + 1;
   end if;
end;
--  END <Token(<WithText ImplementsKw>, ) (root of 'field_decl') at parser.lkt:253:15>
if Token_Pos87 /= No_Token_Index then
   Row_Pos77 := Token_Pos87;
else
   Row_Pos77 := No_Token_Index;
   goto Exit_Row77_0;
end if;
--  BEGIN <Defer (for 'type_member_ref') at parser.lkt:253:28>
--  pos=Defer_Pos79, res=Defer_Res79, nobt=None
Defer_Res79 :=
   Type_Member_Ref_Transform_Parse0 (Parser, Row_Pos77);
Defer_Pos79 := Parser.Current_Pos;
--  END <Defer (for 'type_member_ref') at parser.lkt:253:28>
if Defer_Pos79 /= No_Token_Index then
   Row_Pos77 := Defer_Pos79;
else
   Row_Pos77 := No_Token_Index;
   goto Exit_Row77_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row77_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'field_decl') at parser.lkt:253:10>
--  END <_Extract (root of 'field_decl') at parser.lkt:253:10>
if Row_Pos77 = No_Token_Index then
   Defer_Res79 := No_Bare_Lkt_Node;
   Row_Pos77 := Row_Pos76;
      Parser.Last_Diag := Diag_Mark30;
end if;
--  END <Opt (root of 'field_decl') at parser.lkt:253:9>
if Row_Pos77 /= No_Token_Index then
   Row_Pos76 := Row_Pos77;
else
   Row_Pos76 := No_Token_Index;
   goto Exit_Row76_0;
end if;
--  BEGIN <Opt (root of 'field_decl') at parser.lkt:254:9>
--  pos=Row_Pos78, res=Defer_Res80, nobt=None
Diag_Mark31 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'field_decl') at parser.lkt:254:10>
--  pos=Row_Pos78, res=Defer_Res80, nobt=None
--  BEGIN <_Row (root of 'field_decl') at parser.lkt:254:10>
--  pos=Row_Pos78, res=None, nobt=None
Row_Pos78 := Row_Pos76;
--  BEGIN <Token(<WithText Equal>, ) (root of 'field_decl') at parser.lkt:254:15>
--  pos=Token_Pos88, res=Token_Res88, nobt=None
Token_Res88 := Row_Pos78;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res88));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Equal)
   then
       Token_Pos88 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos78 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos78,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Equal,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos88 := Row_Pos78 + 1;
   end if;
end;
--  END <Token(<WithText Equal>, ) (root of 'field_decl') at parser.lkt:254:15>
if Token_Pos88 /= No_Token_Index then
   Row_Pos78 := Token_Pos88;
else
   Row_Pos78 := No_Token_Index;
   goto Exit_Row78_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:254:19>
--  pos=Defer_Pos80, res=Defer_Res80, nobt=None
Defer_Res80 :=
   Expr_Or_Parse0 (Parser, Row_Pos78);
Defer_Pos80 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:254:19>
if Defer_Pos80 /= No_Token_Index then
   Row_Pos78 := Defer_Pos80;
else
   Row_Pos78 := No_Token_Index;
   goto Exit_Row78_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row78_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'field_decl') at parser.lkt:254:10>
--  END <_Extract (root of 'field_decl') at parser.lkt:254:10>
if Row_Pos78 = No_Token_Index then
   Defer_Res80 := No_Bare_Lkt_Node;
   Row_Pos78 := Row_Pos76;
      Parser.Last_Diag := Diag_Mark31;
end if;
--  END <Opt (root of 'field_decl') at parser.lkt:254:9>
if Row_Pos78 /= No_Token_Index then
   Row_Pos76 := Row_Pos78;
else
   Row_Pos76 := No_Token_Index;
   goto Exit_Row76_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row76_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'field_decl') at parser.lkt:249:19>
if Row_Pos76 /= No_Token_Index then
   Transform_Res55 := Allocate_Field_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res55,
      Kind => Lkt_Field_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos76 = Pos
                            then No_Token_Index
                            else Row_Pos76 - 1));
      Initialize_Fields_For_Field_Decl
        (Self => Transform_Res55,
         Field_Decl_F_Syn_Name => Defer_Res77,
         Field_Decl_F_Decl_Type => Defer_Res78,
         Field_Decl_F_Trait_Ref => Defer_Res79,
         Field_Decl_F_Default_Val => Defer_Res80);
         if Defer_Res77 /= null and then Is_Incomplete (Defer_Res77) then
            Transform_Res55.Last_Attempted_Child := 0;
         elsif Defer_Res77 /= null and then not Is_Ghost (Defer_Res77) then
            Transform_Res55.Last_Attempted_Child := -1;
         end if;
         if Defer_Res78 /= null and then Is_Incomplete (Defer_Res78) then
            Transform_Res55.Last_Attempted_Child := 0;
         elsif Defer_Res78 /= null and then not Is_Ghost (Defer_Res78) then
            Transform_Res55.Last_Attempted_Child := -1;
         end if;
         if Defer_Res79 /= null and then Is_Incomplete (Defer_Res79) then
            Transform_Res55.Last_Attempted_Child := 0;
         elsif Defer_Res79 /= null and then not Is_Ghost (Defer_Res79) then
            Transform_Res55.Last_Attempted_Child := -1;
         end if;
         if Defer_Res80 /= null and then Is_Incomplete (Defer_Res80) then
            Transform_Res55.Last_Attempted_Child := 0;
         elsif Defer_Res80 /= null and then not Is_Ghost (Defer_Res80) then
            Transform_Res55.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType FieldDecl>) (root of 'field_decl') at parser.lkt:249:19>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos76 = No_Token_Index then
      Set_Failure
        (PP.Field_Decl_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Field_Decl_Transform_Parse0_Memo, Pos, Transform_Res55, Parser.Last_Diag, Row_Pos76);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos76;
   return Transform_Res55;
end Field_Decl_Transform_Parse0;
   function Fil_Pattern_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Pattern
is
      Row_Pos79 : Token_Index := No_Token_Index;
      Defer_Pos81 : Token_Index := No_Token_Index;
      Defer_Res81 : Bare_Pattern := No_Bare_Lkt_Node;
      Token_Pos89 : Token_Index := No_Token_Index;
      Token_Res89 : Token_Index := No_Token_Index;
      Defer_Pos82 : Token_Index := No_Token_Index;
      Defer_Res82 : Bare_Expr := No_Bare_Lkt_Node;
      Transform_Res56 : Bare_Filtered_Pattern := No_Bare_Lkt_Node;
      Defer_Pos83 : Token_Index := No_Token_Index;
      Defer_Res83 : Bare_Pattern := No_Bare_Lkt_Node;
      Or_Pos16 : Token_Index := No_Token_Index;
      Or_Res16 : Bare_Pattern := No_Bare_Lkt_Node;
      Diag_Mark32 : Diagnostic_Mark;
      Last_Fail16 : Fail_Info;
      Branch_Diag_Mark16 : Diagnostic_Mark;
      Branch_Last_Fail16 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Fil_Pattern_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res16 := M.Instance;
      return Or_Res16;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res16;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'fil_pattern') at parser.lkt:308:20>
--  pos=Or_Pos16, res=Or_Res16, nobt=None
Or_Pos16 := No_Token_Index;
Or_Res16 := No_Bare_Lkt_Node;
Diag_Mark32 := Parser.Last_Diag;
Last_Fail16 := Parser.Last_Fail;
Branch_Diag_Mark16 := Parser.Last_Diag;
Branch_Last_Fail16 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark32;
    Parser.Last_Fail := Last_Fail16;
--  BEGIN <Transform(<ASTNodeType FilteredPattern>) (root of 'fil_pattern') at parser.lkt:309:11>
--  pos=Row_Pos79, res=Transform_Res56, nobt=None
--  BEGIN <_Row (root of 'fil_pattern') at parser.lkt:309:11>
--  pos=Row_Pos79, res=None, nobt=None
Row_Pos79 := Pos;
--  BEGIN <Defer (for 'value_pattern') at parser.lkt:309:27>
--  pos=Defer_Pos81, res=Defer_Res81, nobt=None
Defer_Res81 :=
   Value_Pattern_Or_Parse1 (Parser, Row_Pos79);
Defer_Pos81 := Parser.Current_Pos;
--  END <Defer (for 'value_pattern') at parser.lkt:309:27>
if Defer_Pos81 /= No_Token_Index then
   Row_Pos79 := Defer_Pos81;
else
   Row_Pos79 := No_Token_Index;
   goto Exit_Row79_0;
end if;
--  BEGIN <Token(<WithText WhenKw>, ) (root of 'fil_pattern') at parser.lkt:309:41>
--  pos=Token_Pos89, res=Token_Res89, nobt=None
Token_Res89 := Row_Pos79;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res89));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_When_Kw)
   then
       Token_Pos89 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos79 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos79,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_When_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos89 := Row_Pos79 + 1;
   end if;
end;
--  END <Token(<WithText WhenKw>, ) (root of 'fil_pattern') at parser.lkt:309:41>
if Token_Pos89 /= No_Token_Index then
   Row_Pos79 := Token_Pos89;
else
   Row_Pos79 := No_Token_Index;
   goto Exit_Row79_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:309:48>
--  pos=Defer_Pos82, res=Defer_Res82, nobt=None
Defer_Res82 :=
   Expr_Or_Parse0 (Parser, Row_Pos79);
Defer_Pos82 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:309:48>
if Defer_Pos82 /= No_Token_Index then
   Row_Pos79 := Defer_Pos82;
else
   Row_Pos79 := No_Token_Index;
   goto Exit_Row79_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row79_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'fil_pattern') at parser.lkt:309:11>
if Row_Pos79 /= No_Token_Index then
   Transform_Res56 := Allocate_Filtered_Pattern (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res56,
      Kind => Lkt_Filtered_Pattern,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos79 = Pos
                            then No_Token_Index
                            else Row_Pos79 - 1));
      Initialize_Fields_For_Filtered_Pattern
        (Self => Transform_Res56,
         Filtered_Pattern_F_Sub_Pattern => Defer_Res81,
         Filtered_Pattern_F_Predicate => Defer_Res82);
         if Defer_Res81 /= null and then Is_Incomplete (Defer_Res81) then
            Transform_Res56.Last_Attempted_Child := 0;
         elsif Defer_Res81 /= null and then not Is_Ghost (Defer_Res81) then
            Transform_Res56.Last_Attempted_Child := -1;
         end if;
         if Defer_Res82 /= null and then Is_Incomplete (Defer_Res82) then
            Transform_Res56.Last_Attempted_Child := 0;
         elsif Defer_Res82 /= null and then not Is_Ghost (Defer_Res82) then
            Transform_Res56.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType FilteredPattern>) (root of 'fil_pattern') at parser.lkt:309:11>
    if Row_Pos79 /= No_Token_Index then
        Or_Pos16 := Row_Pos79;
        Or_Res16 := Transform_Res56;
        goto Exit_Or18;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail16.Pos then
       Branch_Diag_Mark16 := Parser.Last_Diag;
       Branch_Last_Fail16 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark32;
    Parser.Last_Fail := Last_Fail16;
--  BEGIN <Defer (for 'value_pattern') at parser.lkt:310:11>
--  pos=Defer_Pos83, res=Defer_Res83, nobt=None
Defer_Res83 :=
   Value_Pattern_Or_Parse1 (Parser, Pos);
Defer_Pos83 := Parser.Current_Pos;
--  END <Defer (for 'value_pattern') at parser.lkt:310:11>
    if Defer_Pos83 /= No_Token_Index then
        Or_Pos16 := Defer_Pos83;
        Or_Res16 := Defer_Res83;
        goto Exit_Or18;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail16.Pos then
       Branch_Diag_Mark16 := Parser.Last_Diag;
       Branch_Last_Fail16 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark16;
Parser.Last_Fail := Branch_Last_Fail16;
<<Exit_Or18>>
--  END <Or (root of 'fil_pattern') at parser.lkt:308:20>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos16 = No_Token_Index then
      Set_Failure
        (PP.Fil_Pattern_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Fil_Pattern_Or_Parse0_Memo, Pos, Or_Res16, Parser.Last_Diag, Or_Pos16);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos16;
   return Or_Res16;
end Fil_Pattern_Or_Parse0;
   function Fun_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Fun_Decl
is
      Nobt12 : Boolean := False;
      Row_Pos80 : Token_Index := No_Token_Index;
      Token_Pos90 : Token_Index := No_Token_Index;
      Token_Res90 : Token_Index := No_Token_Index;
      Defer_Pos84 : Token_Index := No_Token_Index;
      Defer_Res84 : Bare_Def_Id := No_Bare_Lkt_Node;
      Token_Pos91 : Token_Index := No_Token_Index;
      Token_Res91 : Token_Index := No_Token_Index;
      Defer_Pos85 : Token_Index := No_Token_Index;
      Defer_Res85 : Bare_Fun_Param_Decl_List := No_Bare_Lkt_Node;
      Token_Pos92 : Token_Index := No_Token_Index;
      Token_Res92 : Token_Index := No_Token_Index;
      Token_Pos93 : Token_Index := No_Token_Index;
      Token_Res93 : Token_Index := No_Token_Index;
      Defer_Pos86 : Token_Index := No_Token_Index;
      Defer_Res86 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Row_Pos81 : Token_Index := No_Token_Index;
      Token_Pos94 : Token_Index := No_Token_Index;
      Token_Res94 : Token_Index := No_Token_Index;
      Defer_Pos87 : Token_Index := No_Token_Index;
      Defer_Res87 : Bare_Dot_Expr := No_Bare_Lkt_Node;
      Diag_Mark33 : Diagnostic_Mark;
      Row_Pos82 : Token_Index := No_Token_Index;
      Token_Pos95 : Token_Index := No_Token_Index;
      Token_Res95 : Token_Index := No_Token_Index;
      Defer_Pos88 : Token_Index := No_Token_Index;
      Defer_Res88 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark34 : Diagnostic_Mark;
      Row_Progress12 : Integer := 0;
      Transform_Res57 : Bare_Fun_Decl := No_Bare_Lkt_Node;
      Transform_Has_Failed12 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Fun_Decl_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res57 := M.Instance;
      return Transform_Res57;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res57;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType FunDecl>) (root of 'fun_decl') at parser.lkt:229:17>
--  pos=Row_Pos80, res=Transform_Res57, nobt=Nobt12
--  BEGIN <_Row (root of 'fun_decl') at parser.lkt:229:17>
--  pos=Row_Pos80, res=None, nobt=Nobt12
Row_Pos80 := Pos;
--  BEGIN <Token(<WithText FunKw>, ) (root of 'fun_decl') at parser.lkt:230:9>
--  pos=Token_Pos90, res=Token_Res90, nobt=None
Token_Res90 := Row_Pos80;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res90));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Fun_Kw)
   then
       Token_Pos90 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos80 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos80,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Fun_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos90 := Row_Pos80 + 1;
   end if;
end;
--  END <Token(<WithText FunKw>, ) (root of 'fun_decl') at parser.lkt:230:9>
Row_Progress12 := 1;
if Token_Pos90 /= No_Token_Index then
   Row_Pos80 := Token_Pos90;
else
   Row_Pos80 := No_Token_Index;
   goto Exit_Row80_0;
end if;
--  BEGIN <Cut (root of 'fun_decl') at parser.lkt:231:9>
--  pos=Row_Pos80, res=None, nobt=Nobt12
Nobt12 := True;
--  END <Cut (root of 'fun_decl') at parser.lkt:231:9>
Row_Progress12 := 2;
if Row_Pos80 /= No_Token_Index then
   Row_Pos80 := Row_Pos80;
else
   Row_Pos80 := No_Token_Index;
   goto Exit_Row80_0;
end if;
--  BEGIN <Defer (for 'def_id') at parser.lkt:232:9>
--  pos=Defer_Pos84, res=Defer_Res84, nobt=None
Defer_Res84 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos80);
Defer_Pos84 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:232:9>
Row_Progress12 := 3;
if Defer_Pos84 /= No_Token_Index then
   Row_Pos80 := Defer_Pos84;
else
   Row_Pos80 := No_Token_Index;
   goto Exit_Row80_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'fun_decl') at parser.lkt:233:9>
--  pos=Token_Pos91, res=Token_Res91, nobt=None
Token_Res91 := Row_Pos80;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res91));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos91 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos80 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos80,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos91 := Row_Pos80 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'fun_decl') at parser.lkt:233:9>
Row_Progress12 := 4;
if Token_Pos91 /= No_Token_Index then
   Row_Pos80 := Token_Pos91;
else
   Row_Pos80 := No_Token_Index;
   goto Exit_Row80_0;
end if;
--  BEGIN <Defer (for 'fun_param_list') at parser.lkt:234:9>
--  pos=Defer_Pos85, res=Defer_Res85, nobt=None
Defer_Res85 :=
   Fun_Param_List_List_Parse0 (Parser, Row_Pos80);
Defer_Pos85 := Parser.Current_Pos;
--  END <Defer (for 'fun_param_list') at parser.lkt:234:9>
Row_Progress12 := 5;
if Defer_Pos85 /= No_Token_Index then
   Row_Pos80 := Defer_Pos85;
else
   Row_Pos80 := No_Token_Index;
   goto Exit_Row80_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'fun_decl') at parser.lkt:235:9>
--  pos=Token_Pos92, res=Token_Res92, nobt=None
Token_Res92 := Row_Pos80;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res92));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos92 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos80 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos80,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos92 := Row_Pos80 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'fun_decl') at parser.lkt:235:9>
Row_Progress12 := 6;
if Token_Pos92 /= No_Token_Index then
   Row_Pos80 := Token_Pos92;
else
   Row_Pos80 := No_Token_Index;
   goto Exit_Row80_0;
end if;
--  BEGIN <Token(<WithText Colon>, ) (root of 'fun_decl') at parser.lkt:236:9>
--  pos=Token_Pos93, res=Token_Res93, nobt=None
Token_Res93 := Row_Pos80;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res93));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos93 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos80 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos80,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Colon,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos93 := Row_Pos80 + 1;
   end if;
end;
--  END <Token(<WithText Colon>, ) (root of 'fun_decl') at parser.lkt:236:9>
Row_Progress12 := 7;
if Token_Pos93 /= No_Token_Index then
   Row_Pos80 := Token_Pos93;
else
   Row_Pos80 := No_Token_Index;
   goto Exit_Row80_0;
end if;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:237:9>
--  pos=Defer_Pos86, res=Defer_Res86, nobt=None
Defer_Res86 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos80);
Defer_Pos86 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:237:9>
Row_Progress12 := 8;
if Defer_Pos86 /= No_Token_Index then
   Row_Pos80 := Defer_Pos86;
else
   Row_Pos80 := No_Token_Index;
   goto Exit_Row80_0;
end if;
--  BEGIN <Opt (root of 'fun_decl') at parser.lkt:238:9>
--  pos=Row_Pos81, res=Defer_Res87, nobt=None
Diag_Mark33 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'fun_decl') at parser.lkt:238:10>
--  pos=Row_Pos81, res=Defer_Res87, nobt=None
--  BEGIN <_Row (root of 'fun_decl') at parser.lkt:238:10>
--  pos=Row_Pos81, res=None, nobt=None
Row_Pos81 := Row_Pos80;
--  BEGIN <Token(<WithText ImplementsKw>, ) (root of 'fun_decl') at parser.lkt:238:15>
--  pos=Token_Pos94, res=Token_Res94, nobt=None
Token_Res94 := Row_Pos81;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res94));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Implements_Kw)
   then
       Token_Pos94 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos81 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos81,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Implements_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos94 := Row_Pos81 + 1;
   end if;
end;
--  END <Token(<WithText ImplementsKw>, ) (root of 'fun_decl') at parser.lkt:238:15>
if Token_Pos94 /= No_Token_Index then
   Row_Pos81 := Token_Pos94;
else
   Row_Pos81 := No_Token_Index;
   goto Exit_Row81_0;
end if;
--  BEGIN <Defer (for 'type_member_ref') at parser.lkt:238:28>
--  pos=Defer_Pos87, res=Defer_Res87, nobt=None
Defer_Res87 :=
   Type_Member_Ref_Transform_Parse0 (Parser, Row_Pos81);
Defer_Pos87 := Parser.Current_Pos;
--  END <Defer (for 'type_member_ref') at parser.lkt:238:28>
if Defer_Pos87 /= No_Token_Index then
   Row_Pos81 := Defer_Pos87;
else
   Row_Pos81 := No_Token_Index;
   goto Exit_Row81_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row81_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'fun_decl') at parser.lkt:238:10>
--  END <_Extract (root of 'fun_decl') at parser.lkt:238:10>
if Row_Pos81 = No_Token_Index then
   Defer_Res87 := No_Bare_Lkt_Node;
   Row_Pos81 := Row_Pos80;
      Parser.Last_Diag := Diag_Mark33;
end if;
--  END <Opt (root of 'fun_decl') at parser.lkt:238:9>
Row_Progress12 := 9;
if Row_Pos81 /= No_Token_Index then
   Row_Pos80 := Row_Pos81;
else
   Row_Pos80 := No_Token_Index;
   goto Exit_Row80_0;
end if;
--  BEGIN <Opt (root of 'fun_decl') at parser.lkt:239:9>
--  pos=Row_Pos82, res=Defer_Res88, nobt=None
Diag_Mark34 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'fun_decl') at parser.lkt:239:10>
--  pos=Row_Pos82, res=Defer_Res88, nobt=None
--  BEGIN <_Row (root of 'fun_decl') at parser.lkt:239:10>
--  pos=Row_Pos82, res=None, nobt=None
Row_Pos82 := Row_Pos80;
--  BEGIN <Token(<WithText Equal>, ) (root of 'fun_decl') at parser.lkt:239:15>
--  pos=Token_Pos95, res=Token_Res95, nobt=None
Token_Res95 := Row_Pos82;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res95));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Equal)
   then
       Token_Pos95 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos82 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos82,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Equal,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos95 := Row_Pos82 + 1;
   end if;
end;
--  END <Token(<WithText Equal>, ) (root of 'fun_decl') at parser.lkt:239:15>
if Token_Pos95 /= No_Token_Index then
   Row_Pos82 := Token_Pos95;
else
   Row_Pos82 := No_Token_Index;
   goto Exit_Row82_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:239:19>
--  pos=Defer_Pos88, res=Defer_Res88, nobt=None
Defer_Res88 :=
   Expr_Or_Parse0 (Parser, Row_Pos82);
Defer_Pos88 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:239:19>
if Defer_Pos88 /= No_Token_Index then
   Row_Pos82 := Defer_Pos88;
else
   Row_Pos82 := No_Token_Index;
   goto Exit_Row82_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row82_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'fun_decl') at parser.lkt:239:10>
--  END <_Extract (root of 'fun_decl') at parser.lkt:239:10>
if Row_Pos82 = No_Token_Index then
   Defer_Res88 := No_Bare_Lkt_Node;
   Row_Pos82 := Row_Pos80;
      Parser.Last_Diag := Diag_Mark34;
end if;
--  END <Opt (root of 'fun_decl') at parser.lkt:239:9>
Row_Progress12 := 10;
if Row_Pos82 /= No_Token_Index then
   Row_Pos80 := Row_Pos82;
else
   Row_Pos80 := No_Token_Index;
   goto Exit_Row80_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row80_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'fun_decl') at parser.lkt:229:17>
if Row_Pos80 = No_Token_Index and then Nobt12 then
   Row_Pos80 := Parser.Last_Fail.Pos;
   Transform_Has_Failed12 := True;
end if;
if Row_Pos80 /= No_Token_Index then
   Transform_Res57 := Allocate_Fun_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res57,
      Kind => Lkt_Fun_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos80 = Pos
                            then No_Token_Index
                            else Row_Pos80 - 1));
      Initialize_Fields_For_Fun_Decl
        (Self => Transform_Res57,
         Fun_Decl_F_Syn_Name => Defer_Res84,
         Fun_Decl_F_Params => Defer_Res85,
         Fun_Decl_F_Return_Type => Defer_Res86,
         Fun_Decl_F_Trait_Ref => Defer_Res87,
         Fun_Decl_F_Body => Defer_Res88);
         if Defer_Res84 /= null and then Is_Incomplete (Defer_Res84) then
            Transform_Res57.Last_Attempted_Child := 0;
         elsif Defer_Res84 /= null and then not Is_Ghost (Defer_Res84) then
            Transform_Res57.Last_Attempted_Child := -1;
         end if;
         if Defer_Res85 /= null and then Is_Incomplete (Defer_Res85) then
            Transform_Res57.Last_Attempted_Child := 0;
         elsif Defer_Res85 /= null and then not Is_Ghost (Defer_Res85) then
            Transform_Res57.Last_Attempted_Child := -1;
         end if;
         if Defer_Res86 /= null and then Is_Incomplete (Defer_Res86) then
            Transform_Res57.Last_Attempted_Child := 0;
         elsif Defer_Res86 /= null and then not Is_Ghost (Defer_Res86) then
            Transform_Res57.Last_Attempted_Child := -1;
         end if;
         if Defer_Res87 /= null and then Is_Incomplete (Defer_Res87) then
            Transform_Res57.Last_Attempted_Child := 0;
         elsif Defer_Res87 /= null and then not Is_Ghost (Defer_Res87) then
            Transform_Res57.Last_Attempted_Child := -1;
         end if;
         if Defer_Res88 /= null and then Is_Incomplete (Defer_Res88) then
            Transform_Res57.Last_Attempted_Child := 0;
         elsif Defer_Res88 /= null and then not Is_Ghost (Defer_Res88) then
            Transform_Res57.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed12 then
      Transform_Res57.Last_Attempted_Child :=
         Row_Progress12;
      Append (Parser, Pos, "Cannot parse <fun_decl>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType FunDecl>) (root of 'fun_decl') at parser.lkt:229:17>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos80 = No_Token_Index then
      Set_Failure
        (PP.Fun_Decl_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Fun_Decl_Transform_Parse0_Memo, Pos, Transform_Res57, Parser.Last_Diag, Row_Pos80);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos80;
   return Transform_Res57;
end Fun_Decl_Transform_Parse0;
   function Fun_Param_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Fun_Param_Decl
is
      Row_Pos83 : Token_Index := No_Token_Index;
      Lst_Cpos8 : Token_Index := No_Token_Index;
      Tmp_List8 : Free_Parse_List;
      Defer_Pos89 : Token_Index := No_Token_Index;
      Defer_Res89 : Bare_Decl_Annotation := No_Bare_Lkt_Node;
      List_Pos8 : Token_Index := No_Token_Index;
      List_Res8 : Bare_Decl_Annotation_List := No_Bare_Lkt_Node;
      Diag_Mark35 : Diagnostic_Mark;
      Defer_Pos90 : Token_Index := No_Token_Index;
      Defer_Res90 : Bare_Def_Id := No_Bare_Lkt_Node;
      Token_Pos96 : Token_Index := No_Token_Index;
      Token_Res96 : Token_Index := No_Token_Index;
      Defer_Pos91 : Token_Index := No_Token_Index;
      Defer_Res91 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Row_Pos84 : Token_Index := No_Token_Index;
      Token_Pos97 : Token_Index := No_Token_Index;
      Token_Res97 : Token_Index := No_Token_Index;
      Defer_Pos92 : Token_Index := No_Token_Index;
      Defer_Res92 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark36 : Diagnostic_Mark;
      Transform_Res58 : Bare_Fun_Param_Decl := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Fun_Param_Decl_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res58 := M.Instance;
      return Transform_Res58;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res58;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType FunParamDecl>) (root of 'fun_param_decl') at parser.lkt:244:23>
--  pos=Row_Pos83, res=Transform_Res58, nobt=None
--  BEGIN <_Row (root of 'fun_param_decl') at parser.lkt:244:23>
--  pos=Row_Pos83, res=None, nobt=None
Row_Pos83 := Pos;
--  BEGIN <List (root of 'fun_param_decl') at parser.lkt:245:9>
--  pos=List_Pos8, res=List_Res8, nobt=None
    List_Pos8 := Row_Pos83;
Lst_Cpos8 := Row_Pos83;
Tmp_List8 := Get_Parse_List (Parser);
Diag_Mark35 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'decl_annotation') at parser.lkt:245:15>
--  pos=Defer_Pos89, res=Defer_Res89, nobt=None
Defer_Res89 :=
   Decl_Annotation_Transform_Parse0 (Parser, Lst_Cpos8);
Defer_Pos89 := Parser.Current_Pos;
--  END <Defer (for 'decl_annotation') at parser.lkt:245:15>
   exit when Defer_Pos89 = No_Token_Index;
   List_Pos8 := Defer_Pos89;
   Lst_Cpos8 := List_Pos8;
   Diag_Mark35 := Parser.Last_Diag;
   Tmp_List8.Nodes.Append (Defer_Res89);
end loop;
Parser.Last_Diag := Diag_Mark35;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List8.Nodes.Length;
begin
   List_Res8 := Allocate_Decl_Annotation_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos83;
      Token_End := (if Lst_Cpos8 = Row_Pos83
                    then Row_Pos83
                    else List_Pos8 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos83, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res8,
      Kind              => Lkt_Decl_Annotation_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res8,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List8.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res8.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List8);
--  END <List (root of 'fun_param_decl') at parser.lkt:245:9>
if List_Pos8 /= No_Token_Index then
   Row_Pos83 := List_Pos8;
else
   Row_Pos83 := No_Token_Index;
   goto Exit_Row83_0;
end if;
--  BEGIN <Defer (for 'def_id') at parser.lkt:245:32>
--  pos=Defer_Pos90, res=Defer_Res90, nobt=None
Defer_Res90 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos83);
Defer_Pos90 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:245:32>
if Defer_Pos90 /= No_Token_Index then
   Row_Pos83 := Defer_Pos90;
else
   Row_Pos83 := No_Token_Index;
   goto Exit_Row83_0;
end if;
--  BEGIN <Token(<WithText Colon>, ) (root of 'fun_param_decl') at parser.lkt:245:39>
--  pos=Token_Pos96, res=Token_Res96, nobt=None
Token_Res96 := Row_Pos83;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res96));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos96 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos83 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos83,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Colon,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos96 := Row_Pos83 + 1;
   end if;
end;
--  END <Token(<WithText Colon>, ) (root of 'fun_param_decl') at parser.lkt:245:39>
if Token_Pos96 /= No_Token_Index then
   Row_Pos83 := Token_Pos96;
else
   Row_Pos83 := No_Token_Index;
   goto Exit_Row83_0;
end if;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:245:43>
--  pos=Defer_Pos91, res=Defer_Res91, nobt=None
Defer_Res91 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos83);
Defer_Pos91 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:245:43>
if Defer_Pos91 /= No_Token_Index then
   Row_Pos83 := Defer_Pos91;
else
   Row_Pos83 := No_Token_Index;
   goto Exit_Row83_0;
end if;
--  BEGIN <Opt (root of 'fun_param_decl') at parser.lkt:245:52>
--  pos=Row_Pos84, res=Defer_Res92, nobt=None
Diag_Mark36 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'fun_param_decl') at parser.lkt:245:53>
--  pos=Row_Pos84, res=Defer_Res92, nobt=None
--  BEGIN <_Row (root of 'fun_param_decl') at parser.lkt:245:53>
--  pos=Row_Pos84, res=None, nobt=None
Row_Pos84 := Row_Pos83;
--  BEGIN <Token(<WithText Equal>, ) (root of 'fun_param_decl') at parser.lkt:245:58>
--  pos=Token_Pos97, res=Token_Res97, nobt=None
Token_Res97 := Row_Pos84;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res97));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Equal)
   then
       Token_Pos97 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos84 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos84,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Equal,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos97 := Row_Pos84 + 1;
   end if;
end;
--  END <Token(<WithText Equal>, ) (root of 'fun_param_decl') at parser.lkt:245:58>
if Token_Pos97 /= No_Token_Index then
   Row_Pos84 := Token_Pos97;
else
   Row_Pos84 := No_Token_Index;
   goto Exit_Row84_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:245:62>
--  pos=Defer_Pos92, res=Defer_Res92, nobt=None
Defer_Res92 :=
   Expr_Or_Parse0 (Parser, Row_Pos84);
Defer_Pos92 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:245:62>
if Defer_Pos92 /= No_Token_Index then
   Row_Pos84 := Defer_Pos92;
else
   Row_Pos84 := No_Token_Index;
   goto Exit_Row84_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row84_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'fun_param_decl') at parser.lkt:245:53>
--  END <_Extract (root of 'fun_param_decl') at parser.lkt:245:53>
if Row_Pos84 = No_Token_Index then
   Defer_Res92 := No_Bare_Lkt_Node;
   Row_Pos84 := Row_Pos83;
      Parser.Last_Diag := Diag_Mark36;
end if;
--  END <Opt (root of 'fun_param_decl') at parser.lkt:245:52>
if Row_Pos84 /= No_Token_Index then
   Row_Pos83 := Row_Pos84;
else
   Row_Pos83 := No_Token_Index;
   goto Exit_Row83_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row83_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'fun_param_decl') at parser.lkt:244:23>
if Row_Pos83 /= No_Token_Index then
   Transform_Res58 := Allocate_Fun_Param_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res58,
      Kind => Lkt_Fun_Param_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos83 = Pos
                            then No_Token_Index
                            else Row_Pos83 - 1));
      Initialize_Fields_For_Fun_Param_Decl
        (Self => Transform_Res58,
         Fun_Param_Decl_F_Decl_Annotations => List_Res8,
         Fun_Param_Decl_F_Syn_Name => Defer_Res90,
         Fun_Param_Decl_F_Decl_Type => Defer_Res91,
         Fun_Param_Decl_F_Default_Val => Defer_Res92);
         if List_Res8 /= null and then Is_Incomplete (List_Res8) then
            Transform_Res58.Last_Attempted_Child := 0;
         elsif List_Res8 /= null and then not Is_Ghost (List_Res8) then
            Transform_Res58.Last_Attempted_Child := -1;
         end if;
         if Defer_Res90 /= null and then Is_Incomplete (Defer_Res90) then
            Transform_Res58.Last_Attempted_Child := 0;
         elsif Defer_Res90 /= null and then not Is_Ghost (Defer_Res90) then
            Transform_Res58.Last_Attempted_Child := -1;
         end if;
         if Defer_Res91 /= null and then Is_Incomplete (Defer_Res91) then
            Transform_Res58.Last_Attempted_Child := 0;
         elsif Defer_Res91 /= null and then not Is_Ghost (Defer_Res91) then
            Transform_Res58.Last_Attempted_Child := -1;
         end if;
         if Defer_Res92 /= null and then Is_Incomplete (Defer_Res92) then
            Transform_Res58.Last_Attempted_Child := 0;
         elsif Defer_Res92 /= null and then not Is_Ghost (Defer_Res92) then
            Transform_Res58.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType FunParamDecl>) (root of 'fun_param_decl') at parser.lkt:244:23>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos83 = No_Token_Index then
      Set_Failure
        (PP.Fun_Param_Decl_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Fun_Param_Decl_Transform_Parse0_Memo, Pos, Transform_Res58, Parser.Last_Diag, Row_Pos83);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos83;
   return Transform_Res58;
end Fun_Param_Decl_Transform_Parse0;
   function Fun_Param_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Fun_Param_Decl_List
is
      Lst_Cpos9 : Token_Index := No_Token_Index;
      Tmp_List9 : Free_Parse_List;
      Defer_Pos93 : Token_Index := No_Token_Index;
      Defer_Res93 : Bare_Fun_Param_Decl := No_Bare_Lkt_Node;
      Token_Pos98 : Token_Index := No_Token_Index;
      Token_Res98 : Token_Index := No_Token_Index;
      List_Pos9 : Token_Index := No_Token_Index;
      List_Res9 : Bare_Fun_Param_Decl_List := No_Bare_Lkt_Node;
      Diag_Mark37 : Diagnostic_Mark;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Fun_Param_List_List_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      List_Res9 := M.Instance;
      return List_Res9;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return List_Res9;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <List (root of 'fun_param_list') at parser.lkt:247:23>
--  pos=List_Pos9, res=List_Res9, nobt=None
    List_Pos9 := Pos;
Lst_Cpos9 := Pos;
Tmp_List9 := Get_Parse_List (Parser);
Diag_Mark37 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'fun_param_decl') at parser.lkt:247:29>
--  pos=Defer_Pos93, res=Defer_Res93, nobt=None
Defer_Res93 :=
   Fun_Param_Decl_Transform_Parse0 (Parser, Lst_Cpos9);
Defer_Pos93 := Parser.Current_Pos;
--  END <Defer (for 'fun_param_decl') at parser.lkt:247:29>
   exit when Defer_Pos93 = No_Token_Index;
   List_Pos9 := Defer_Pos93;
   Lst_Cpos9 := List_Pos9;
   Diag_Mark37 := Parser.Last_Diag;
   Tmp_List9.Nodes.Append (Defer_Res93);
--  BEGIN <Token(<WithText Comma>, ) (root of 'fun_param_list') at parser.lkt:247:45>
--  pos=Token_Pos98, res=Token_Res98, nobt=None
Token_Res98 := Lst_Cpos9;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res98));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos98 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Lst_Cpos9 then
          Parser.Last_Fail :=
            (Pos  => Lst_Cpos9,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Comma,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos98 := Lst_Cpos9 + 1;
   end if;
end;
--  END <Token(<WithText Comma>, ) (root of 'fun_param_list') at parser.lkt:247:45>
      exit when Token_Pos98 = No_Token_Index;
      Lst_Cpos9 := Token_Pos98;
end loop;
Parser.Last_Diag := Diag_Mark37;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List9.Nodes.Length;
begin
   List_Res9 := Allocate_Fun_Param_Decl_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos9 = Pos
                    then Pos
                    else List_Pos9 - 1);
   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res9,
      Kind              => Lkt_Fun_Param_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res9,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List9.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res9.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List9);
--  END <List (root of 'fun_param_list') at parser.lkt:247:23>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if List_Pos9 = No_Token_Index then
      Set_Failure
        (PP.Fun_Param_List_List_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Fun_Param_List_List_Parse0_Memo, Pos, List_Res9, Parser.Last_Diag, List_Pos9);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := List_Pos9;
   return List_Res9;
end Fun_Param_List_List_Parse0;
   function Generic_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Generic_Decl
is
      Nobt13 : Boolean := False;
      Row_Pos85 : Token_Index := No_Token_Index;
      Token_Pos99 : Token_Index := No_Token_Index;
      Token_Res99 : Token_Index := No_Token_Index;
      Token_Pos100 : Token_Index := No_Token_Index;
      Token_Res100 : Token_Index := No_Token_Index;
      Lst_Cpos10 : Token_Index := No_Token_Index;
      Tmp_List10 : Free_Parse_List;
      Defer_Pos94 : Token_Index := No_Token_Index;
      Defer_Res94 : Bare_Full_Decl := No_Bare_Lkt_Node;
      Token_Pos101 : Token_Index := No_Token_Index;
      Token_Res101 : Token_Index := No_Token_Index;
      List_Pos10 : Token_Index := No_Token_Index;
      List_Res10 : Bare_Generic_Param_Decl_List := No_Bare_Lkt_Node;
      Diag_Mark38 : Diagnostic_Mark;
      Token_Pos102 : Token_Index := No_Token_Index;
      Token_Res102 : Token_Index := No_Token_Index;
      Defer_Pos95 : Token_Index := No_Token_Index;
      Defer_Res95 : Bare_Decl := No_Bare_Lkt_Node;
      Row_Progress13 : Integer := 0;
      Transform_Res59 : Bare_Generic_Decl := No_Bare_Lkt_Node;
      Transform_Has_Failed13 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Generic_Decl_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res59 := M.Instance;
      return Transform_Res59;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res59;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType GenericDecl>) (root of 'generic_decl') at parser.lkt:213:21>
--  pos=Row_Pos85, res=Transform_Res59, nobt=Nobt13
--  BEGIN <_Row (root of 'generic_decl') at parser.lkt:213:21>
--  pos=Row_Pos85, res=None, nobt=Nobt13
Row_Pos85 := Pos;
--  BEGIN <Token(<WithText GenericKw>, ) (root of 'generic_decl') at parser.lkt:214:9>
--  pos=Token_Pos99, res=Token_Res99, nobt=None
Token_Res99 := Row_Pos85;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res99));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Generic_Kw)
   then
       Token_Pos99 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos85 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos85,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Generic_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos99 := Row_Pos85 + 1;
   end if;
end;
--  END <Token(<WithText GenericKw>, ) (root of 'generic_decl') at parser.lkt:214:9>
Row_Progress13 := 1;
if Token_Pos99 /= No_Token_Index then
   Row_Pos85 := Token_Pos99;
else
   Row_Pos85 := No_Token_Index;
   goto Exit_Row85_0;
end if;
--  BEGIN <Cut (root of 'generic_decl') at parser.lkt:215:9>
--  pos=Row_Pos85, res=None, nobt=Nobt13
Nobt13 := True;
--  END <Cut (root of 'generic_decl') at parser.lkt:215:9>
Row_Progress13 := 2;
if Row_Pos85 /= No_Token_Index then
   Row_Pos85 := Row_Pos85;
else
   Row_Pos85 := No_Token_Index;
   goto Exit_Row85_0;
end if;
--  BEGIN <Token(<WithText LBrack>, ) (root of 'generic_decl') at parser.lkt:216:9>
--  pos=Token_Pos100, res=Token_Res100, nobt=None
Token_Res100 := Row_Pos85;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res100));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos100 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos85 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos85,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos100 := Row_Pos85 + 1;
   end if;
end;
--  END <Token(<WithText LBrack>, ) (root of 'generic_decl') at parser.lkt:216:9>
Row_Progress13 := 3;
if Token_Pos100 /= No_Token_Index then
   Row_Pos85 := Token_Pos100;
else
   Row_Pos85 := No_Token_Index;
   goto Exit_Row85_0;
end if;
--  BEGIN <List (root of 'generic_decl') at parser.lkt:217:9>
--  pos=List_Pos10, res=List_Res10, nobt=None
    List_Pos10 := No_Token_Index;
Lst_Cpos10 := Row_Pos85;
Tmp_List10 := Get_Parse_List (Parser);
Diag_Mark38 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'generic_param_type') at parser.lkt:217:31>
--  pos=Defer_Pos94, res=Defer_Res94, nobt=None
Defer_Res94 :=
   Generic_Param_Type_Transform_Parse1 (Parser, Lst_Cpos10);
Defer_Pos94 := Parser.Current_Pos;
--  END <Defer (for 'generic_param_type') at parser.lkt:217:31>
   exit when Defer_Pos94 = No_Token_Index;
   List_Pos10 := Defer_Pos94;
   Lst_Cpos10 := List_Pos10;
   Diag_Mark38 := Parser.Last_Diag;
   Tmp_List10.Nodes.Append (Defer_Res94);
--  BEGIN <Token(<WithText Comma>, ) (root of 'generic_decl') at parser.lkt:217:51>
--  pos=Token_Pos101, res=Token_Res101, nobt=None
Token_Res101 := Lst_Cpos10;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res101));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos101 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Lst_Cpos10 then
          Parser.Last_Fail :=
            (Pos  => Lst_Cpos10,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Comma,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos101 := Lst_Cpos10 + 1;
   end if;
end;
--  END <Token(<WithText Comma>, ) (root of 'generic_decl') at parser.lkt:217:51>
      exit when Token_Pos101 = No_Token_Index;
      Lst_Cpos10 := Token_Pos101;
end loop;
Parser.Last_Diag := Diag_Mark38;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List10.Nodes.Length;
begin
   List_Res10 := Allocate_Generic_Param_Decl_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos85;
      Token_End := (if Lst_Cpos10 = Row_Pos85
                    then Row_Pos85
                    else List_Pos10 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos85, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res10,
      Kind              => Lkt_Generic_Param_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res10,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List10.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res10.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List10);
--  END <List (root of 'generic_decl') at parser.lkt:217:9>
Row_Progress13 := 4;
if List_Pos10 /= No_Token_Index then
   Row_Pos85 := List_Pos10;
else
   Row_Pos85 := No_Token_Index;
   goto Exit_Row85_0;
end if;
--  BEGIN <Token(<WithText RBrack>, ) (root of 'generic_decl') at parser.lkt:218:9>
--  pos=Token_Pos102, res=Token_Res102, nobt=None
Token_Res102 := Row_Pos85;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res102));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos102 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos85 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos85,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos102 := Row_Pos85 + 1;
   end if;
end;
--  END <Token(<WithText RBrack>, ) (root of 'generic_decl') at parser.lkt:218:9>
Row_Progress13 := 5;
if Token_Pos102 /= No_Token_Index then
   Row_Pos85 := Token_Pos102;
else
   Row_Pos85 := No_Token_Index;
   goto Exit_Row85_0;
end if;
--  BEGIN <Defer (for 'bare_decl') at parser.lkt:219:9>
--  pos=Defer_Pos95, res=Defer_Res95, nobt=None
Defer_Res95 :=
   Bare_Decl_Or_Parse0 (Parser, Row_Pos85);
Defer_Pos95 := Parser.Current_Pos;
--  END <Defer (for 'bare_decl') at parser.lkt:219:9>
Row_Progress13 := 6;
if Defer_Pos95 /= No_Token_Index then
   Row_Pos85 := Defer_Pos95;
else
   Row_Pos85 := No_Token_Index;
   goto Exit_Row85_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row85_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'generic_decl') at parser.lkt:213:21>
if Row_Pos85 = No_Token_Index and then Nobt13 then
   Row_Pos85 := Parser.Last_Fail.Pos;
   Transform_Has_Failed13 := True;
end if;
if Row_Pos85 /= No_Token_Index then
   Transform_Res59 := Allocate_Generic_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res59,
      Kind => Lkt_Generic_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos85 = Pos
                            then No_Token_Index
                            else Row_Pos85 - 1));
      Initialize_Fields_For_Generic_Decl
        (Self => Transform_Res59,
         Generic_Decl_F_Generic_Param_Decls => List_Res10,
         Generic_Decl_F_Decl => Defer_Res95);
         if List_Res10 /= null and then Is_Incomplete (List_Res10) then
            Transform_Res59.Last_Attempted_Child := 0;
         elsif List_Res10 /= null and then not Is_Ghost (List_Res10) then
            Transform_Res59.Last_Attempted_Child := -1;
         end if;
         if Defer_Res95 /= null and then Is_Incomplete (Defer_Res95) then
            Transform_Res59.Last_Attempted_Child := 0;
         elsif Defer_Res95 /= null and then not Is_Ghost (Defer_Res95) then
            Transform_Res59.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed13 then
      Transform_Res59.Last_Attempted_Child :=
         Row_Progress13;
      Append (Parser, Pos, "Cannot parse <generic_decl>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType GenericDecl>) (root of 'generic_decl') at parser.lkt:213:21>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos85 = No_Token_Index then
      Set_Failure
        (PP.Generic_Decl_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Generic_Decl_Transform_Parse0_Memo, Pos, Transform_Res59, Parser.Last_Diag, Row_Pos85);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos85;
   return Transform_Res59;
end Generic_Decl_Transform_Parse0;
   function Generic_Param_Type_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Full_Decl
is
      Row_Pos86 : Token_Index := No_Token_Index;
      Defer_Pos96 : Token_Index := No_Token_Index;
      Defer_Res96 : Bare_String_Lit := No_Bare_Lkt_Node;
      Lst_Cpos11 : Token_Index := No_Token_Index;
      Tmp_List11 : Free_Parse_List;
      Defer_Pos97 : Token_Index := No_Token_Index;
      Defer_Res97 : Bare_Decl_Annotation := No_Bare_Lkt_Node;
      List_Pos11 : Token_Index := No_Token_Index;
      List_Res11 : Bare_Decl_Annotation_List := No_Bare_Lkt_Node;
      Diag_Mark39 : Diagnostic_Mark;
      Row_Pos87 : Token_Index := No_Token_Index;
      Token_Pos103 : Token_Index := No_Token_Index;
      Token_Res103 : Token_Index := No_Token_Index;
      Opt_Res1 : Bare_Class_Qualifier := No_Bare_Lkt_Node;
      Diag_Mark40 : Diagnostic_Mark;
      Defer_Pos98 : Token_Index := No_Token_Index;
      Defer_Res98 : Bare_Def_Id := No_Bare_Lkt_Node;
      Null_Res20 : Bare_Type_Ref_List := No_Bare_Lkt_Node;
      Transform_Res60 : Bare_Generic_Param_Type_Decl := No_Bare_Lkt_Node;
      Transform_Res61 : Bare_Full_Decl := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Generic_Param_Type_Transform_Parse1_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res61 := M.Instance;
      return Transform_Res61;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res61;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType FullDecl>) (root of 'generic_param_type') at parser.lkt:221:27>
--  pos=Row_Pos86, res=Transform_Res61, nobt=None
--  BEGIN <_Row (root of 'generic_param_type') at parser.lkt:221:27>
--  pos=Row_Pos86, res=None, nobt=None
Row_Pos86 := Pos;
--  BEGIN <Defer (for 'doc') at parser.lkt:222:9>
--  pos=Defer_Pos96, res=Defer_Res96, nobt=None
Defer_Res96 :=
   Doc_Opt_Parse0 (Parser, Row_Pos86);
Defer_Pos96 := Parser.Current_Pos;
--  END <Defer (for 'doc') at parser.lkt:222:9>
if Defer_Pos96 /= No_Token_Index then
   Row_Pos86 := Defer_Pos96;
else
   Row_Pos86 := No_Token_Index;
   goto Exit_Row86_0;
end if;
--  BEGIN <List (root of 'generic_param_type') at parser.lkt:223:9>
--  pos=List_Pos11, res=List_Res11, nobt=None
    List_Pos11 := Row_Pos86;
Lst_Cpos11 := Row_Pos86;
Tmp_List11 := Get_Parse_List (Parser);
Diag_Mark39 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'decl_annotation') at parser.lkt:223:15>
--  pos=Defer_Pos97, res=Defer_Res97, nobt=None
Defer_Res97 :=
   Decl_Annotation_Transform_Parse0 (Parser, Lst_Cpos11);
Defer_Pos97 := Parser.Current_Pos;
--  END <Defer (for 'decl_annotation') at parser.lkt:223:15>
   exit when Defer_Pos97 = No_Token_Index;
   List_Pos11 := Defer_Pos97;
   Lst_Cpos11 := List_Pos11;
   Diag_Mark39 := Parser.Last_Diag;
   Tmp_List11.Nodes.Append (Defer_Res97);
end loop;
Parser.Last_Diag := Diag_Mark39;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List11.Nodes.Length;
begin
   List_Res11 := Allocate_Decl_Annotation_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos86;
      Token_End := (if Lst_Cpos11 = Row_Pos86
                    then Row_Pos86
                    else List_Pos11 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos86, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res11,
      Kind              => Lkt_Decl_Annotation_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res11,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List11.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res11.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List11);
--  END <List (root of 'generic_param_type') at parser.lkt:223:9>
if List_Pos11 /= No_Token_Index then
   Row_Pos86 := List_Pos11;
else
   Row_Pos86 := No_Token_Index;
   goto Exit_Row86_0;
end if;
--  BEGIN <Transform(<ASTNodeType GenericParamTypeDecl>) (root of 'generic_param_type') at parser.lkt:224:9>
--  pos=Row_Pos87, res=Transform_Res60, nobt=None
--  BEGIN <_Row (root of 'generic_param_type') at parser.lkt:224:9>
--  pos=Row_Pos87, res=None, nobt=None
Row_Pos87 := Row_Pos86;
--  BEGIN <Opt (root of 'generic_param_type') at parser.lkt:225:13>
--  pos=Token_Pos103, res=Opt_Res1, nobt=None
Diag_Mark40 := Parser.Last_Diag;
--  BEGIN <Token(<WithText ClassKw>, ) (root of 'generic_param_type') at parser.lkt:225:28>
--  pos=Token_Pos103, res=Token_Res103, nobt=None
Token_Res103 := Row_Pos87;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res103));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Class_Kw)
   then
       Token_Pos103 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos87 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos87,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Class_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos103 := Row_Pos87 + 1;
   end if;
end;
--  END <Token(<WithText ClassKw>, ) (root of 'generic_param_type') at parser.lkt:225:28>
if Token_Pos103 = No_Token_Index then
         Opt_Res1 := Allocate_Class_Qualifier_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res1,
            Kind              => Lkt_Class_Qualifier_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Row_Pos87,
            Token_End_Index   => No_Token_Index);
   Token_Pos103 := Row_Pos87;
      Parser.Last_Diag := Diag_Mark40;
else
      Opt_Res1 := Allocate_Class_Qualifier_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res1,
         Kind              => Lkt_Class_Qualifier_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Row_Pos87,
         Token_End_Index   => Token_Pos103 - 1);
end if;
--  END <Opt (root of 'generic_param_type') at parser.lkt:225:13>
if Token_Pos103 /= No_Token_Index then
   Row_Pos87 := Token_Pos103;
else
   Row_Pos87 := No_Token_Index;
   goto Exit_Row87_0;
end if;
--  BEGIN <Defer (for 'def_id') at parser.lkt:225:37>
--  pos=Defer_Pos98, res=Defer_Res98, nobt=None
Defer_Res98 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos87);
Defer_Pos98 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:225:37>
if Defer_Pos98 /= No_Token_Index then
   Row_Pos87 := Defer_Pos98;
else
   Row_Pos87 := No_Token_Index;
   goto Exit_Row87_0;
end if;
--  BEGIN <Null (root of 'generic_param_type') at parser.lkt:225:44>
--  pos=Row_Pos87, res=Null_Res20, nobt=None
   Null_Res20 := Allocate_Type_Ref_List (Parser.Mem_Pool);
   Initialize
     (Self              => Null_Res20,
      Kind              => Lkt_Type_Ref_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Index'Max (Row_Pos87, 1),
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Null_Res20,
      Parser => Parser,
      Count  => 0);
--  END <Null (root of 'generic_param_type') at parser.lkt:225:44>
if Row_Pos87 /= No_Token_Index then
   Row_Pos87 := Row_Pos87;
else
   Row_Pos87 := No_Token_Index;
   goto Exit_Row87_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row87_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'generic_param_type') at parser.lkt:224:9>
if Row_Pos87 /= No_Token_Index then
   Transform_Res60 := Allocate_Generic_Param_Type_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res60,
      Kind => Lkt_Generic_Param_Type_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos86,
      Token_End_Index   => (if Row_Pos87 = Row_Pos86
                            then No_Token_Index
                            else Row_Pos87 - 1));
      Initialize_Fields_For_Generic_Param_Type_Decl
        (Self => Transform_Res60,
         Generic_Param_Type_Decl_F_Has_Class => Opt_Res1,
         Generic_Param_Type_Decl_F_Syn_Name => Defer_Res98,
         Generic_Param_Type_Decl_F_Traits => Null_Res20);
         if Opt_Res1 /= null and then Is_Incomplete (Opt_Res1) then
            Transform_Res60.Last_Attempted_Child := 0;
         elsif Opt_Res1 /= null and then not Is_Ghost (Opt_Res1) then
            Transform_Res60.Last_Attempted_Child := -1;
         end if;
         if Defer_Res98 /= null and then Is_Incomplete (Defer_Res98) then
            Transform_Res60.Last_Attempted_Child := 0;
         elsif Defer_Res98 /= null and then not Is_Ghost (Defer_Res98) then
            Transform_Res60.Last_Attempted_Child := -1;
         end if;
         if Null_Res20 /= null and then Is_Incomplete (Null_Res20) then
            Transform_Res60.Last_Attempted_Child := 0;
         elsif Null_Res20 /= null and then not Is_Ghost (Null_Res20) then
            Transform_Res60.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType GenericParamTypeDecl>) (root of 'generic_param_type') at parser.lkt:224:9>
if Row_Pos87 /= No_Token_Index then
   Row_Pos86 := Row_Pos87;
else
   Row_Pos86 := No_Token_Index;
   goto Exit_Row86_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row86_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'generic_param_type') at parser.lkt:221:27>
if Row_Pos86 /= No_Token_Index then
   Transform_Res61 := Allocate_Full_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res61,
      Kind => Lkt_Full_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos86 = Pos
                            then No_Token_Index
                            else Row_Pos86 - 1));
      Initialize_Fields_For_Full_Decl
        (Self => Transform_Res61,
         Full_Decl_F_Doc => Defer_Res96,
         Full_Decl_F_Decl_Annotations => List_Res11,
         Full_Decl_F_Decl => Transform_Res60);
         if Defer_Res96 /= null and then Is_Incomplete (Defer_Res96) then
            Transform_Res61.Last_Attempted_Child := 0;
         elsif Defer_Res96 /= null and then not Is_Ghost (Defer_Res96) then
            Transform_Res61.Last_Attempted_Child := -1;
         end if;
         if List_Res11 /= null and then Is_Incomplete (List_Res11) then
            Transform_Res61.Last_Attempted_Child := 0;
         elsif List_Res11 /= null and then not Is_Ghost (List_Res11) then
            Transform_Res61.Last_Attempted_Child := -1;
         end if;
         if Transform_Res60 /= null and then Is_Incomplete (Transform_Res60) then
            Transform_Res61.Last_Attempted_Child := 0;
         elsif Transform_Res60 /= null and then not Is_Ghost (Transform_Res60) then
            Transform_Res61.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType FullDecl>) (root of 'generic_param_type') at parser.lkt:221:27>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos86 = No_Token_Index then
      Set_Failure
        (PP.Generic_Param_Type_Transform_Parse1_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Generic_Param_Type_Transform_Parse1_Memo, Pos, Transform_Res61, Parser.Last_Diag, Row_Pos86);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos86;
   return Transform_Res61;
end Generic_Param_Type_Transform_Parse1;
   function Grammar_Cut_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Cut
is
      Row_Pos88 : Token_Index := No_Token_Index;
      Token_Pos104 : Token_Index := No_Token_Index;
      Token_Res104 : Token_Index := No_Token_Index;
      Transform_Res62 : Bare_Grammar_Cut := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Grammar_Cut_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res62 := M.Instance;
      return Transform_Res62;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res62;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType GrammarCut>) (root of 'grammar_cut') at parser.lkt:106:20>
--  pos=Row_Pos88, res=Transform_Res62, nobt=None
--  BEGIN <_Row (root of 'grammar_cut') at parser.lkt:106:20>
--  pos=Row_Pos88, res=None, nobt=None
Row_Pos88 := Pos;
--  BEGIN <Token(<WithText Div>, ) (root of 'grammar_cut') at parser.lkt:106:31>
--  pos=Token_Pos104, res=Token_Res104, nobt=None
Token_Res104 := Row_Pos88;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res104));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Div)
   then
       Token_Pos104 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos88 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos88,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Div,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos104 := Row_Pos88 + 1;
   end if;
end;
--  END <Token(<WithText Div>, ) (root of 'grammar_cut') at parser.lkt:106:31>
if Token_Pos104 /= No_Token_Index then
   Row_Pos88 := Token_Pos104;
else
   Row_Pos88 := No_Token_Index;
   goto Exit_Row88_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row88_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_cut') at parser.lkt:106:20>
if Row_Pos88 /= No_Token_Index then
   Transform_Res62 := Allocate_Grammar_Cut (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res62,
      Kind => Lkt_Grammar_Cut,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos88 = Pos
                            then No_Token_Index
                            else Row_Pos88 - 1));
      Initialize_Fields_For_Grammar_Cut
        (Self => Transform_Res62);
end if;
--  END <Transform(<ASTNodeType GrammarCut>) (root of 'grammar_cut') at parser.lkt:106:20>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos88 = No_Token_Index then
      Set_Failure
        (PP.Grammar_Cut_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Grammar_Cut_Transform_Parse0_Memo, Pos, Transform_Res62, Parser.Last_Diag, Row_Pos88);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos88;
   return Transform_Res62;
end Grammar_Cut_Transform_Parse0;
   function Grammar_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Decl
is
      Nobt14 : Boolean := False;
      Row_Pos89 : Token_Index := No_Token_Index;
      Token_Pos105 : Token_Index := No_Token_Index;
      Token_Res105 : Token_Index := No_Token_Index;
      Defer_Pos99 : Token_Index := No_Token_Index;
      Defer_Res99 : Bare_Def_Id := No_Bare_Lkt_Node;
      Token_Pos106 : Token_Index := No_Token_Index;
      Token_Res106 : Token_Index := No_Token_Index;
      Defer_Pos100 : Token_Index := No_Token_Index;
      Defer_Res100 : Bare_Full_Decl_List := No_Bare_Lkt_Node;
      Token_Pos107 : Token_Index := No_Token_Index;
      Token_Res107 : Token_Index := No_Token_Index;
      Row_Progress14 : Integer := 0;
      Transform_Res63 : Bare_Grammar_Decl := No_Bare_Lkt_Node;
      Transform_Has_Failed14 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Grammar_Decl_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res63 := M.Instance;
      return Transform_Res63;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res63;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType GrammarDecl>) (root of 'grammar_decl') at parser.lkt:43:21>
--  pos=Row_Pos89, res=Transform_Res63, nobt=Nobt14
--  BEGIN <_Row (root of 'grammar_decl') at parser.lkt:43:21>
--  pos=Row_Pos89, res=None, nobt=Nobt14
Row_Pos89 := Pos;
--  BEGIN <Token(<WithText GrammarKw>, ) (root of 'grammar_decl') at parser.lkt:43:33>
--  pos=Token_Pos105, res=Token_Res105, nobt=None
Token_Res105 := Row_Pos89;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res105));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Grammar_Kw)
   then
       Token_Pos105 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos89 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos89,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Grammar_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos105 := Row_Pos89 + 1;
   end if;
end;
--  END <Token(<WithText GrammarKw>, ) (root of 'grammar_decl') at parser.lkt:43:33>
Row_Progress14 := 1;
if Token_Pos105 /= No_Token_Index then
   Row_Pos89 := Token_Pos105;
else
   Row_Pos89 := No_Token_Index;
   goto Exit_Row89_0;
end if;
--  BEGIN <Cut (root of 'grammar_decl') at parser.lkt:43:43>
--  pos=Row_Pos89, res=None, nobt=Nobt14
Nobt14 := True;
--  END <Cut (root of 'grammar_decl') at parser.lkt:43:43>
Row_Progress14 := 2;
if Row_Pos89 /= No_Token_Index then
   Row_Pos89 := Row_Pos89;
else
   Row_Pos89 := No_Token_Index;
   goto Exit_Row89_0;
end if;
--  BEGIN <Defer (for 'def_id') at parser.lkt:43:45>
--  pos=Defer_Pos99, res=Defer_Res99, nobt=None
Defer_Res99 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos89);
Defer_Pos99 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:43:45>
Row_Progress14 := 3;
if Defer_Pos99 /= No_Token_Index then
   Row_Pos89 := Defer_Pos99;
else
   Row_Pos89 := No_Token_Index;
   goto Exit_Row89_0;
end if;
--  BEGIN <Token(<WithText LBrace>, ) (root of 'grammar_decl') at parser.lkt:43:52>
--  pos=Token_Pos106, res=Token_Res106, nobt=None
Token_Res106 := Row_Pos89;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res106));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos106 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos89 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos89,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos106 := Row_Pos89 + 1;
   end if;
end;
--  END <Token(<WithText LBrace>, ) (root of 'grammar_decl') at parser.lkt:43:52>
Row_Progress14 := 4;
if Token_Pos106 /= No_Token_Index then
   Row_Pos89 := Token_Pos106;
else
   Row_Pos89 := No_Token_Index;
   goto Exit_Row89_0;
end if;
--  BEGIN <Defer (for 'decls') at parser.lkt:43:56>
--  pos=Defer_Pos100, res=Defer_Res100, nobt=None
Defer_Res100 :=
   Decls_Dont_Skip_Parse0 (Parser, Row_Pos89);
Defer_Pos100 := Parser.Current_Pos;
--  END <Defer (for 'decls') at parser.lkt:43:56>
Row_Progress14 := 5;
if Defer_Pos100 /= No_Token_Index then
   Row_Pos89 := Defer_Pos100;
else
   Row_Pos89 := No_Token_Index;
   goto Exit_Row89_0;
end if;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'grammar_decl') at parser.lkt:43:62>
--  pos=Token_Pos107, res=Token_Res107, nobt=None
Token_Res107 := Row_Pos89;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res107));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos107 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos89 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos89,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos107 := Row_Pos89 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'grammar_decl') at parser.lkt:43:62>
Row_Progress14 := 6;
if Token_Pos107 /= No_Token_Index then
   Row_Pos89 := Token_Pos107;
else
   Row_Pos89 := No_Token_Index;
   goto Exit_Row89_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row89_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_decl') at parser.lkt:43:21>
if Row_Pos89 = No_Token_Index and then Nobt14 then
   Row_Pos89 := Parser.Last_Fail.Pos;
   Transform_Has_Failed14 := True;
end if;
if Row_Pos89 /= No_Token_Index then
   Transform_Res63 := Allocate_Grammar_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res63,
      Kind => Lkt_Grammar_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos89 = Pos
                            then No_Token_Index
                            else Row_Pos89 - 1));
      Initialize_Fields_For_Grammar_Decl
        (Self => Transform_Res63,
         Grammar_Decl_F_Syn_Name => Defer_Res99,
         Grammar_Decl_F_Rules => Defer_Res100);
         if Defer_Res99 /= null and then Is_Incomplete (Defer_Res99) then
            Transform_Res63.Last_Attempted_Child := 0;
         elsif Defer_Res99 /= null and then not Is_Ghost (Defer_Res99) then
            Transform_Res63.Last_Attempted_Child := -1;
         end if;
         if Defer_Res100 /= null and then Is_Incomplete (Defer_Res100) then
            Transform_Res63.Last_Attempted_Child := 0;
         elsif Defer_Res100 /= null and then not Is_Ghost (Defer_Res100) then
            Transform_Res63.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed14 then
      Transform_Res63.Last_Attempted_Child :=
         Row_Progress14;
      Append (Parser, Pos, "Cannot parse <grammar_decl>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType GrammarDecl>) (root of 'grammar_decl') at parser.lkt:43:21>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos89 = No_Token_Index then
      Set_Failure
        (PP.Grammar_Decl_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Grammar_Decl_Transform_Parse0_Memo, Pos, Transform_Res63, Parser.Last_Diag, Row_Pos89);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos89;
   return Transform_Res63;
end Grammar_Decl_Transform_Parse0;
   function Grammar_Discard_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Discard
is
      Row_Pos90 : Token_Index := No_Token_Index;
      Token_Pos108 : Token_Index := No_Token_Index;
      Token_Res108 : Token_Index := No_Token_Index;
      Token_Pos109 : Token_Index := No_Token_Index;
      Token_Res109 : Token_Index := No_Token_Index;
      Defer_Pos101 : Token_Index := No_Token_Index;
      Defer_Res101 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Token_Pos110 : Token_Index := No_Token_Index;
      Token_Res110 : Token_Index := No_Token_Index;
      Transform_Res64 : Bare_Grammar_Discard := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Grammar_Discard_Expr_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res64 := M.Instance;
      return Transform_Res64;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res64;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType GrammarDiscard>) (root of 'grammar_discard_expr') at parser.lkt:118:29>
--  pos=Row_Pos90, res=Transform_Res64, nobt=None
--  BEGIN <_Row (root of 'grammar_discard_expr') at parser.lkt:118:29>
--  pos=Row_Pos90, res=None, nobt=None
Row_Pos90 := Pos;
--  BEGIN <Token(<WithText DiscardKw>, ) (root of 'grammar_discard_expr') at parser.lkt:118:44>
--  pos=Token_Pos108, res=Token_Res108, nobt=None
Token_Res108 := Row_Pos90;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res108));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Discard_Kw)
   then
       Token_Pos108 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos90 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos90,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Discard_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos108 := Row_Pos90 + 1;
   end if;
end;
--  END <Token(<WithText DiscardKw>, ) (root of 'grammar_discard_expr') at parser.lkt:118:44>
if Token_Pos108 /= No_Token_Index then
   Row_Pos90 := Token_Pos108;
else
   Row_Pos90 := No_Token_Index;
   goto Exit_Row90_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_discard_expr') at parser.lkt:118:54>
--  pos=Token_Pos109, res=Token_Res109, nobt=None
Token_Res109 := Row_Pos90;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res109));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos109 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos90 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos90,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos109 := Row_Pos90 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'grammar_discard_expr') at parser.lkt:118:54>
if Token_Pos109 /= No_Token_Index then
   Row_Pos90 := Token_Pos109;
else
   Row_Pos90 := No_Token_Index;
   goto Exit_Row90_0;
end if;
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:118:58>
--  pos=Defer_Pos101, res=Defer_Res101, nobt=None
Defer_Res101 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos90);
Defer_Pos101 := Parser.Current_Pos;
--  END <Defer (for 'grammar_expr') at parser.lkt:118:58>
if Defer_Pos101 /= No_Token_Index then
   Row_Pos90 := Defer_Pos101;
else
   Row_Pos90 := No_Token_Index;
   goto Exit_Row90_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_discard_expr') at parser.lkt:118:71>
--  pos=Token_Pos110, res=Token_Res110, nobt=None
Token_Res110 := Row_Pos90;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res110));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos110 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos90 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos90,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos110 := Row_Pos90 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'grammar_discard_expr') at parser.lkt:118:71>
if Token_Pos110 /= No_Token_Index then
   Row_Pos90 := Token_Pos110;
else
   Row_Pos90 := No_Token_Index;
   goto Exit_Row90_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row90_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_discard_expr') at parser.lkt:118:29>
if Row_Pos90 /= No_Token_Index then
   Transform_Res64 := Allocate_Grammar_Discard (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res64,
      Kind => Lkt_Grammar_Discard,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos90 = Pos
                            then No_Token_Index
                            else Row_Pos90 - 1));
      Initialize_Fields_For_Grammar_Discard
        (Self => Transform_Res64,
         Grammar_Discard_F_Expr => Defer_Res101);
         if Defer_Res101 /= null and then Is_Incomplete (Defer_Res101) then
            Transform_Res64.Last_Attempted_Child := 0;
         elsif Defer_Res101 /= null and then not Is_Ghost (Defer_Res101) then
            Transform_Res64.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType GrammarDiscard>) (root of 'grammar_discard_expr') at parser.lkt:118:29>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos90 = No_Token_Index then
      Set_Failure
        (PP.Grammar_Discard_Expr_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Grammar_Discard_Expr_Transform_Parse0_Memo, Pos, Transform_Res64, Parser.Last_Diag, Row_Pos90);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos90;
   return Transform_Res64;
end Grammar_Discard_Expr_Transform_Parse0;
   function Grammar_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr
is
      Row_Pos91 : Token_Index := No_Token_Index;
      Defer_Pos102 : Token_Index := No_Token_Index;
      Defer_Res102 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Token_Pos111 : Token_Index := No_Token_Index;
      Token_Res111 : Token_Index := No_Token_Index;
      Token_Pos112 : Token_Index := No_Token_Index;
      Token_Res112 : Token_Index := No_Token_Index;
      Token_Pos113 : Token_Index := No_Token_Index;
      Token_Res113 : Token_Index := No_Token_Index;
      Defer_Pos103 : Token_Index := No_Token_Index;
      Defer_Res103 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Token_Pos114 : Token_Index := No_Token_Index;
      Token_Res114 : Token_Index := No_Token_Index;
      Transform_Res65 : Bare_Grammar_Dont_Skip := No_Bare_Lkt_Node;
      Row_Pos92 : Token_Index := No_Token_Index;
      Defer_Pos104 : Token_Index := No_Token_Index;
      Defer_Res104 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Token_Pos115 : Token_Index := No_Token_Index;
      Token_Res115 : Token_Index := No_Token_Index;
      Token_Pos116 : Token_Index := No_Token_Index;
      Token_Res116 : Token_Index := No_Token_Index;
      Token_Pos117 : Token_Index := No_Token_Index;
      Token_Res117 : Token_Index := No_Token_Index;
      Defer_Pos105 : Token_Index := No_Token_Index;
      Defer_Res105 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos118 : Token_Index := No_Token_Index;
      Token_Res118 : Token_Index := No_Token_Index;
      Transform_Res66 : Bare_Grammar_Predicate := No_Bare_Lkt_Node;
      Defer_Pos106 : Token_Index := No_Token_Index;
      Defer_Res106 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Or_Pos17 : Token_Index := No_Token_Index;
      Or_Res17 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Diag_Mark41 : Diagnostic_Mark;
      Last_Fail17 : Fail_Info;
      Branch_Diag_Mark17 : Diagnostic_Mark;
      Branch_Last_Fail17 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
      Mem_Pos  : Token_Index := Pos;
      Mem_Res  : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Mem_Mark : Diagnostic_Mark := Mark_On_Entry;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Grammar_Expr_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res17 := M.Instance;
      return Or_Res17;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res17;
   end if;
   Parser.Last_Diag := No_Diagnostic;
       Set_Failure
         (PP.Grammar_Expr_Or_Parse0_Memo,
          Pos,
          Parser.Last_Fail,
          Parser.Last_Diag);
       <<Try_Again>>
       Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'grammar_expr') at parser.lkt:83:21>
--  pos=Or_Pos17, res=Or_Res17, nobt=None
Or_Pos17 := No_Token_Index;
Or_Res17 := No_Bare_Lkt_Node;
Diag_Mark41 := Parser.Last_Diag;
Last_Fail17 := Parser.Last_Fail;
Branch_Diag_Mark17 := Parser.Last_Diag;
Branch_Last_Fail17 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark41;
    Parser.Last_Fail := Last_Fail17;
--  BEGIN <Transform(<ASTNodeType GrammarDontSkip>) (root of 'grammar_expr') at parser.lkt:84:11>
--  pos=Row_Pos91, res=Transform_Res65, nobt=None
--  BEGIN <_Row (root of 'grammar_expr') at parser.lkt:84:11>
--  pos=Row_Pos91, res=None, nobt=None
Row_Pos91 := Pos;
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:85:13>
--  pos=Defer_Pos102, res=Defer_Res102, nobt=None
Defer_Res102 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos91);
Defer_Pos102 := Parser.Current_Pos;
--  END <Defer (for 'grammar_expr') at parser.lkt:85:13>
if Defer_Pos102 /= No_Token_Index then
   Row_Pos91 := Defer_Pos102;
else
   Row_Pos91 := No_Token_Index;
   goto Exit_Row91_0;
end if;
--  BEGIN <Token(<WithText Dot>, ) (root of 'grammar_expr') at parser.lkt:85:26>
--  pos=Token_Pos111, res=Token_Res111, nobt=None
Token_Res111 := Row_Pos91;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res111));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dot)
   then
       Token_Pos111 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos91 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos91,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Dot,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos111 := Row_Pos91 + 1;
   end if;
end;
--  END <Token(<WithText Dot>, ) (root of 'grammar_expr') at parser.lkt:85:26>
if Token_Pos111 /= No_Token_Index then
   Row_Pos91 := Token_Pos111;
else
   Row_Pos91 := No_Token_Index;
   goto Exit_Row91_0;
end if;
--  BEGIN <Token(<WithSymbol Identifier>, dont_skip) (root of 'grammar_expr') at parser.lkt:85:30>
--  pos=Token_Pos112, res=Token_Res112, nobt=None
Token_Res112 := Row_Pos91;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res112));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Dont_Skip)
   then
       Token_Pos112 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos91 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos91,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos112 := Row_Pos91 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, dont_skip) (root of 'grammar_expr') at parser.lkt:85:30>
if Token_Pos112 /= No_Token_Index then
   Row_Pos91 := Token_Pos112;
else
   Row_Pos91 := No_Token_Index;
   goto Exit_Row91_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_expr') at parser.lkt:85:55>
--  pos=Token_Pos113, res=Token_Res113, nobt=None
Token_Res113 := Row_Pos91;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res113));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos113 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos91 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos91,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos113 := Row_Pos91 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'grammar_expr') at parser.lkt:85:55>
if Token_Pos113 /= No_Token_Index then
   Row_Pos91 := Token_Pos113;
else
   Row_Pos91 := No_Token_Index;
   goto Exit_Row91_0;
end if;
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:85:59>
--  pos=Defer_Pos103, res=Defer_Res103, nobt=None
Defer_Res103 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos91);
Defer_Pos103 := Parser.Current_Pos;
--  END <Defer (for 'grammar_expr') at parser.lkt:85:59>
if Defer_Pos103 /= No_Token_Index then
   Row_Pos91 := Defer_Pos103;
else
   Row_Pos91 := No_Token_Index;
   goto Exit_Row91_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_expr') at parser.lkt:85:72>
--  pos=Token_Pos114, res=Token_Res114, nobt=None
Token_Res114 := Row_Pos91;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res114));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos114 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos91 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos91,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos114 := Row_Pos91 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'grammar_expr') at parser.lkt:85:72>
if Token_Pos114 /= No_Token_Index then
   Row_Pos91 := Token_Pos114;
else
   Row_Pos91 := No_Token_Index;
   goto Exit_Row91_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row91_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_expr') at parser.lkt:84:11>
if Row_Pos91 /= No_Token_Index then
   Transform_Res65 := Allocate_Grammar_Dont_Skip (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res65,
      Kind => Lkt_Grammar_Dont_Skip,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos91 = Pos
                            then No_Token_Index
                            else Row_Pos91 - 1));
      Initialize_Fields_For_Grammar_Dont_Skip
        (Self => Transform_Res65,
         Grammar_Dont_Skip_F_Expr => Defer_Res102,
         Grammar_Dont_Skip_F_Dont_Skip => Defer_Res103);
         if Defer_Res102 /= null and then Is_Incomplete (Defer_Res102) then
            Transform_Res65.Last_Attempted_Child := 0;
         elsif Defer_Res102 /= null and then not Is_Ghost (Defer_Res102) then
            Transform_Res65.Last_Attempted_Child := -1;
         end if;
         if Defer_Res103 /= null and then Is_Incomplete (Defer_Res103) then
            Transform_Res65.Last_Attempted_Child := 0;
         elsif Defer_Res103 /= null and then not Is_Ghost (Defer_Res103) then
            Transform_Res65.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType GrammarDontSkip>) (root of 'grammar_expr') at parser.lkt:84:11>
    if Row_Pos91 /= No_Token_Index then
        Or_Pos17 := Row_Pos91;
        Or_Res17 := Transform_Res65;
        goto Exit_Or19;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail17.Pos then
       Branch_Diag_Mark17 := Parser.Last_Diag;
       Branch_Last_Fail17 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark41;
    Parser.Last_Fail := Last_Fail17;
--  BEGIN <Transform(<ASTNodeType GrammarPredicate>) (root of 'grammar_expr') at parser.lkt:87:11>
--  pos=Row_Pos92, res=Transform_Res66, nobt=None
--  BEGIN <_Row (root of 'grammar_expr') at parser.lkt:87:11>
--  pos=Row_Pos92, res=None, nobt=None
Row_Pos92 := Pos;
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:88:13>
--  pos=Defer_Pos104, res=Defer_Res104, nobt=None
Defer_Res104 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos92);
Defer_Pos104 := Parser.Current_Pos;
--  END <Defer (for 'grammar_expr') at parser.lkt:88:13>
if Defer_Pos104 /= No_Token_Index then
   Row_Pos92 := Defer_Pos104;
else
   Row_Pos92 := No_Token_Index;
   goto Exit_Row92_0;
end if;
--  BEGIN <Token(<WithText Comb>, ) (root of 'grammar_expr') at parser.lkt:88:26>
--  pos=Token_Pos115, res=Token_Res115, nobt=None
Token_Res115 := Row_Pos92;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res115));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comb)
   then
       Token_Pos115 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos92 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos92,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Comb,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos115 := Row_Pos92 + 1;
   end if;
end;
--  END <Token(<WithText Comb>, ) (root of 'grammar_expr') at parser.lkt:88:26>
if Token_Pos115 /= No_Token_Index then
   Row_Pos92 := Token_Pos115;
else
   Row_Pos92 := No_Token_Index;
   goto Exit_Row92_0;
end if;
--  BEGIN <Token(<WithText WhenKw>, ) (root of 'grammar_expr') at parser.lkt:88:31>
--  pos=Token_Pos116, res=Token_Res116, nobt=None
Token_Res116 := Row_Pos92;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res116));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_When_Kw)
   then
       Token_Pos116 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos92 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos92,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_When_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos116 := Row_Pos92 + 1;
   end if;
end;
--  END <Token(<WithText WhenKw>, ) (root of 'grammar_expr') at parser.lkt:88:31>
if Token_Pos116 /= No_Token_Index then
   Row_Pos92 := Token_Pos116;
else
   Row_Pos92 := No_Token_Index;
   goto Exit_Row92_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_expr') at parser.lkt:88:38>
--  pos=Token_Pos117, res=Token_Res117, nobt=None
Token_Res117 := Row_Pos92;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res117));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos117 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos92 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos92,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos117 := Row_Pos92 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'grammar_expr') at parser.lkt:88:38>
if Token_Pos117 /= No_Token_Index then
   Row_Pos92 := Token_Pos117;
else
   Row_Pos92 := No_Token_Index;
   goto Exit_Row92_0;
end if;
--  BEGIN <Defer (for 'basic_name') at parser.lkt:88:42>
--  pos=Defer_Pos105, res=Defer_Res105, nobt=None
Defer_Res105 :=
   Basic_Name_Or_Parse0 (Parser, Row_Pos92);
Defer_Pos105 := Parser.Current_Pos;
--  END <Defer (for 'basic_name') at parser.lkt:88:42>
if Defer_Pos105 /= No_Token_Index then
   Row_Pos92 := Defer_Pos105;
else
   Row_Pos92 := No_Token_Index;
   goto Exit_Row92_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_expr') at parser.lkt:88:53>
--  pos=Token_Pos118, res=Token_Res118, nobt=None
Token_Res118 := Row_Pos92;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res118));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos118 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos92 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos92,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos118 := Row_Pos92 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'grammar_expr') at parser.lkt:88:53>
if Token_Pos118 /= No_Token_Index then
   Row_Pos92 := Token_Pos118;
else
   Row_Pos92 := No_Token_Index;
   goto Exit_Row92_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row92_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_expr') at parser.lkt:87:11>
if Row_Pos92 /= No_Token_Index then
   Transform_Res66 := Allocate_Grammar_Predicate (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res66,
      Kind => Lkt_Grammar_Predicate,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos92 = Pos
                            then No_Token_Index
                            else Row_Pos92 - 1));
      Initialize_Fields_For_Grammar_Predicate
        (Self => Transform_Res66,
         Grammar_Predicate_F_Expr => Defer_Res104,
         Grammar_Predicate_F_Prop_Ref => Defer_Res105);
         if Defer_Res104 /= null and then Is_Incomplete (Defer_Res104) then
            Transform_Res66.Last_Attempted_Child := 0;
         elsif Defer_Res104 /= null and then not Is_Ghost (Defer_Res104) then
            Transform_Res66.Last_Attempted_Child := -1;
         end if;
         if Defer_Res105 /= null and then Is_Incomplete (Defer_Res105) then
            Transform_Res66.Last_Attempted_Child := 0;
         elsif Defer_Res105 /= null and then not Is_Ghost (Defer_Res105) then
            Transform_Res66.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType GrammarPredicate>) (root of 'grammar_expr') at parser.lkt:87:11>
    if Row_Pos92 /= No_Token_Index then
        Or_Pos17 := Row_Pos92;
        Or_Res17 := Transform_Res66;
        goto Exit_Or19;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail17.Pos then
       Branch_Diag_Mark17 := Parser.Last_Diag;
       Branch_Last_Fail17 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark41;
    Parser.Last_Fail := Last_Fail17;
--  BEGIN <Defer (for 'grammar_primary') at parser.lkt:90:11>
--  pos=Defer_Pos106, res=Defer_Res106, nobt=None
Defer_Res106 :=
   Grammar_Primary_Or_Parse0 (Parser, Pos);
Defer_Pos106 := Parser.Current_Pos;
--  END <Defer (for 'grammar_primary') at parser.lkt:90:11>
    if Defer_Pos106 /= No_Token_Index then
        Or_Pos17 := Defer_Pos106;
        Or_Res17 := Defer_Res106;
        goto Exit_Or19;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail17.Pos then
       Branch_Diag_Mark17 := Parser.Last_Diag;
       Branch_Last_Fail17 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark17;
Parser.Last_Fail := Branch_Last_Fail17;
<<Exit_Or19>>
--  END <Or (root of 'grammar_expr') at parser.lkt:83:21>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
      if Or_Pos17 > Mem_Pos then
         Mem_Pos := Or_Pos17;
         Mem_Res := Or_Res17;
         Mem_Mark := Parser.Last_Diag;
         if Or_Pos17 = No_Token_Index then
            Set_Failure (PP.Grammar_Expr_Or_Parse0_Memo, Pos, Parser.Last_Fail, Mem_Mark);
         else
            Memos.Set_Success
              (PP.Grammar_Expr_Or_Parse0_Memo,
               Pos,
               Or_Res17,
               Mem_Mark,
               Or_Pos17);
         end if;
         goto Try_Again;
      elsif Mem_Pos > Pos then
         Or_Res17 := Mem_Res;
         Or_Pos17 := Mem_Pos;
         Parser.Last_Diag := Mem_Mark;
         goto No_Memo;
      end if;
   if Or_Pos17 = No_Token_Index then
      Set_Failure
        (PP.Grammar_Expr_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Grammar_Expr_Or_Parse0_Memo, Pos, Or_Res17, Parser.Last_Diag, Or_Pos17);
   end if;
       <<No_Memo>>
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos17;
   return Or_Res17;
end Grammar_Expr_Or_Parse0;
   function Grammar_Implicit_Pick_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Implicit_Pick
is
      Row_Pos93 : Token_Index := No_Token_Index;
      Lst_Cpos12 : Token_Index := No_Token_Index;
      Tmp_List12 : Free_Parse_List;
      Defer_Pos107 : Token_Index := No_Token_Index;
      Defer_Res107 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      List_Pos12 : Token_Index := No_Token_Index;
      List_Res12 : Bare_Grammar_Expr_List := No_Bare_Lkt_Node;
      Diag_Mark42 : Diagnostic_Mark;
      Transform_Res67 : Bare_Grammar_Implicit_Pick := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Grammar_Implicit_Pick_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res67 := M.Instance;
      return Transform_Res67;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res67;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType GrammarImplicitPick>) (root of 'grammar_implicit_pick') at parser.lkt:95:30>
--  pos=Row_Pos93, res=Transform_Res67, nobt=None
--  BEGIN <_Row (root of 'grammar_implicit_pick') at parser.lkt:95:30>
--  pos=Row_Pos93, res=None, nobt=None
Row_Pos93 := Pos;
--  BEGIN <List (root of 'grammar_implicit_pick') at parser.lkt:95:50>
--  pos=List_Pos12, res=List_Res12, nobt=None
    List_Pos12 := No_Token_Index;
Lst_Cpos12 := Row_Pos93;
Tmp_List12 := Get_Parse_List (Parser);
Diag_Mark42 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:95:56>
--  pos=Defer_Pos107, res=Defer_Res107, nobt=None
Defer_Res107 :=
   Grammar_Expr_Or_Parse0 (Parser, Lst_Cpos12);
Defer_Pos107 := Parser.Current_Pos;
--  END <Defer (for 'grammar_expr') at parser.lkt:95:56>
   exit when Defer_Pos107 = No_Token_Index;
   List_Pos12 := Defer_Pos107;
   Lst_Cpos12 := List_Pos12;
   Diag_Mark42 := Parser.Last_Diag;
   Tmp_List12.Nodes.Append (Defer_Res107);
end loop;
Parser.Last_Diag := Diag_Mark42;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List12.Nodes.Length;
begin
   List_Res12 := Allocate_Grammar_Expr_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos93;
      Token_End := (if Lst_Cpos12 = Row_Pos93
                    then Row_Pos93
                    else List_Pos12 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos93, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res12,
      Kind              => Lkt_Grammar_Expr_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res12,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List12.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res12.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List12);
--  END <List (root of 'grammar_implicit_pick') at parser.lkt:95:50>
if List_Pos12 /= No_Token_Index then
   Row_Pos93 := List_Pos12;
else
   Row_Pos93 := No_Token_Index;
   goto Exit_Row93_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row93_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_implicit_pick') at parser.lkt:95:30>
if Row_Pos93 /= No_Token_Index then
   Transform_Res67 := Allocate_Grammar_Implicit_Pick (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res67,
      Kind => Lkt_Grammar_Implicit_Pick,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos93 = Pos
                            then No_Token_Index
                            else Row_Pos93 - 1));
      Initialize_Fields_For_Grammar_Implicit_Pick
        (Self => Transform_Res67,
         Grammar_Pick_F_Exprs => List_Res12);
         if List_Res12 /= null and then Is_Incomplete (List_Res12) then
            Transform_Res67.Last_Attempted_Child := 0;
         elsif List_Res12 /= null and then not Is_Ghost (List_Res12) then
            Transform_Res67.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType GrammarImplicitPick>) (root of 'grammar_implicit_pick') at parser.lkt:95:30>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos93 = No_Token_Index then
      Set_Failure
        (PP.Grammar_Implicit_Pick_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Grammar_Implicit_Pick_Transform_Parse0_Memo, Pos, Transform_Res67, Parser.Last_Diag, Row_Pos93);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos93;
   return Transform_Res67;
end Grammar_Implicit_Pick_Transform_Parse0;
   function Grammar_List_Expr_Transform_Parse3
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_List
is
      Row_Pos94 : Token_Index := No_Token_Index;
      Row_Pos95 : Token_Index := No_Token_Index;
      Token_Pos119 : Token_Index := No_Token_Index;
      Token_Res119 : Token_Index := No_Token_Index;
      Transform_Res68 : Bare_Default_List_Type_Ref := No_Bare_Lkt_Node;
      Defer_Pos108 : Token_Index := No_Token_Index;
      Defer_Res108 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Or_Pos18 : Token_Index := No_Token_Index;
      Or_Res18 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Diag_Mark43 : Diagnostic_Mark;
      Last_Fail18 : Fail_Info;
      Branch_Diag_Mark18 : Diagnostic_Mark;
      Branch_Last_Fail18 : Fail_Info;
      Row_Pos96 : Token_Index := No_Token_Index;
      Token_Pos120 : Token_Index := No_Token_Index;
      Token_Res120 : Token_Index := No_Token_Index;
      Transform_Res69 : Bare_List_Kind_One := No_Bare_Lkt_Node;
      Row_Pos97 : Token_Index := No_Token_Index;
      Token_Pos121 : Token_Index := No_Token_Index;
      Token_Res121 : Token_Index := No_Token_Index;
      Transform_Res70 : Bare_List_Kind_Zero := No_Bare_Lkt_Node;
      Or_Pos19 : Token_Index := No_Token_Index;
      Or_Res19 : Bare_List_Kind := No_Bare_Lkt_Node;
      Diag_Mark44 : Diagnostic_Mark;
      Last_Fail19 : Fail_Info;
      Branch_Diag_Mark19 : Diagnostic_Mark;
      Branch_Last_Fail19 : Fail_Info;
      Token_Pos122 : Token_Index := No_Token_Index;
      Token_Res122 : Token_Index := No_Token_Index;
      Defer_Pos109 : Token_Index := No_Token_Index;
      Defer_Res109 : Bare_Grammar_Implicit_Pick := No_Bare_Lkt_Node;
      Defer_Pos110 : Token_Index := No_Token_Index;
      Defer_Res110 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Or_Pos20 : Token_Index := No_Token_Index;
      Or_Res20 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Diag_Mark45 : Diagnostic_Mark;
      Last_Fail20 : Fail_Info;
      Branch_Diag_Mark20 : Diagnostic_Mark;
      Branch_Last_Fail20 : Fail_Info;
      Row_Pos98 : Token_Index := No_Token_Index;
      Token_Pos123 : Token_Index := No_Token_Index;
      Token_Res123 : Token_Index := No_Token_Index;
      Defer_Pos111 : Token_Index := No_Token_Index;
      Defer_Res111 : Bare_Grammar_List_Sep := No_Bare_Lkt_Node;
      Diag_Mark46 : Diagnostic_Mark;
      Token_Pos124 : Token_Index := No_Token_Index;
      Token_Res124 : Token_Index := No_Token_Index;
      Transform_Res71 : Bare_Grammar_List := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Grammar_List_Expr_Transform_Parse3_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res71 := M.Instance;
      return Transform_Res71;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res71;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType GrammarList>) (root of 'grammar_list_expr') at parser.lkt:136:26>
--  pos=Row_Pos94, res=Transform_Res71, nobt=None
--  BEGIN <_Row (root of 'grammar_list_expr') at parser.lkt:136:26>
--  pos=Row_Pos94, res=None, nobt=None
Row_Pos94 := Pos;
--  BEGIN <Or (root of 'grammar_list_expr') at parser.lkt:139:9>
--  pos=Or_Pos18, res=Or_Res18, nobt=None
Or_Pos18 := No_Token_Index;
Or_Res18 := No_Bare_Lkt_Node;
Diag_Mark43 := Parser.Last_Diag;
Last_Fail18 := Parser.Last_Fail;
Branch_Diag_Mark18 := Parser.Last_Diag;
Branch_Last_Fail18 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark43;
    Parser.Last_Fail := Last_Fail18;
--  BEGIN <Transform(<ASTNodeType DefaultListTypeRef>) (root of 'grammar_list_expr') at parser.lkt:139:12>
--  pos=Row_Pos95, res=Transform_Res68, nobt=None
--  BEGIN <_Row (root of 'grammar_list_expr') at parser.lkt:139:12>
--  pos=Row_Pos95, res=None, nobt=None
Row_Pos95 := Row_Pos94;
--  BEGIN <Token(<WithSymbol Identifier>, list) (root of 'grammar_list_expr') at parser.lkt:139:31>
--  pos=Token_Pos119, res=Token_Res119, nobt=None
Token_Res119 := Row_Pos95;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res119));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_List)
   then
       Token_Pos119 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos95 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos95,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos119 := Row_Pos95 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, list) (root of 'grammar_list_expr') at parser.lkt:139:31>
if Token_Pos119 /= No_Token_Index then
   Row_Pos95 := Token_Pos119;
else
   Row_Pos95 := No_Token_Index;
   goto Exit_Row95_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row95_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_list_expr') at parser.lkt:139:12>
if Row_Pos95 /= No_Token_Index then
   Transform_Res68 := Allocate_Default_List_Type_Ref (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res68,
      Kind => Lkt_Default_List_Type_Ref,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos94,
      Token_End_Index   => (if Row_Pos95 = Row_Pos94
                            then No_Token_Index
                            else Row_Pos95 - 1));
      Initialize_Fields_For_Default_List_Type_Ref
        (Self => Transform_Res68);
end if;
--  END <Transform(<ASTNodeType DefaultListTypeRef>) (root of 'grammar_list_expr') at parser.lkt:139:12>
    if Row_Pos95 /= No_Token_Index then
        Or_Pos18 := Row_Pos95;
        Or_Res18 := Transform_Res68;
        goto Exit_Or20;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail18.Pos then
       Branch_Diag_Mark18 := Parser.Last_Diag;
       Branch_Last_Fail18 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark43;
    Parser.Last_Fail := Last_Fail18;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:139:54>
--  pos=Defer_Pos108, res=Defer_Res108, nobt=None
Defer_Res108 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos94);
Defer_Pos108 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:139:54>
    if Defer_Pos108 /= No_Token_Index then
        Or_Pos18 := Defer_Pos108;
        Or_Res18 := Defer_Res108;
        goto Exit_Or20;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail18.Pos then
       Branch_Diag_Mark18 := Parser.Last_Diag;
       Branch_Last_Fail18 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark18;
Parser.Last_Fail := Branch_Last_Fail18;
<<Exit_Or20>>
--  END <Or (root of 'grammar_list_expr') at parser.lkt:139:9>
if Or_Pos18 /= No_Token_Index then
   Row_Pos94 := Or_Pos18;
else
   Row_Pos94 := No_Token_Index;
   goto Exit_Row94_0;
end if;
--  BEGIN <Or (root of 'grammar_list_expr') at parser.lkt:141:9>
--  pos=Or_Pos19, res=Or_Res19, nobt=None
Or_Pos19 := No_Token_Index;
Or_Res19 := No_Bare_Lkt_Node;
Diag_Mark44 := Parser.Last_Diag;
Last_Fail19 := Parser.Last_Fail;
Branch_Diag_Mark19 := Parser.Last_Diag;
Branch_Last_Fail19 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark44;
    Parser.Last_Fail := Last_Fail19;
--  BEGIN <Transform(<ASTNodeType ListKind.One>) (root of 'grammar_list_expr') at parser.lkt:141:12>
--  pos=Row_Pos96, res=Transform_Res69, nobt=None
--  BEGIN <_Row (root of 'grammar_list_expr') at parser.lkt:141:12>
--  pos=Row_Pos96, res=None, nobt=None
Row_Pos96 := Row_Pos94;
--  BEGIN <Token(<WithText Plus>, ) (root of 'grammar_list_expr') at parser.lkt:141:25>
--  pos=Token_Pos120, res=Token_Res120, nobt=None
Token_Res120 := Row_Pos96;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res120));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Plus)
   then
       Token_Pos120 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos96 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos96,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Plus,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos120 := Row_Pos96 + 1;
   end if;
end;
--  END <Token(<WithText Plus>, ) (root of 'grammar_list_expr') at parser.lkt:141:25>
if Token_Pos120 /= No_Token_Index then
   Row_Pos96 := Token_Pos120;
else
   Row_Pos96 := No_Token_Index;
   goto Exit_Row96_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row96_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_list_expr') at parser.lkt:141:12>
if Row_Pos96 /= No_Token_Index then
   Transform_Res69 := Allocate_List_Kind_One (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res69,
      Kind => Lkt_List_Kind_One,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos94,
      Token_End_Index   => (if Row_Pos96 = Row_Pos94
                            then No_Token_Index
                            else Row_Pos96 - 1));
end if;
--  END <Transform(<ASTNodeType ListKind.One>) (root of 'grammar_list_expr') at parser.lkt:141:12>
    if Row_Pos96 /= No_Token_Index then
        Or_Pos19 := Row_Pos96;
        Or_Res19 := Transform_Res69;
        goto Exit_Or21;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail19.Pos then
       Branch_Diag_Mark19 := Parser.Last_Diag;
       Branch_Last_Fail19 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark44;
    Parser.Last_Fail := Last_Fail19;
--  BEGIN <Transform(<ASTNodeType ListKind.Zero>) (root of 'grammar_list_expr') at parser.lkt:141:32>
--  pos=Row_Pos97, res=Transform_Res70, nobt=None
--  BEGIN <_Row (root of 'grammar_list_expr') at parser.lkt:141:32>
--  pos=Row_Pos97, res=None, nobt=None
Row_Pos97 := Row_Pos94;
--  BEGIN <Token(<WithText Times>, ) (root of 'grammar_list_expr') at parser.lkt:141:46>
--  pos=Token_Pos121, res=Token_Res121, nobt=None
Token_Res121 := Row_Pos97;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res121));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Times)
   then
       Token_Pos121 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos97 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos97,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Times,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos121 := Row_Pos97 + 1;
   end if;
end;
--  END <Token(<WithText Times>, ) (root of 'grammar_list_expr') at parser.lkt:141:46>
if Token_Pos121 /= No_Token_Index then
   Row_Pos97 := Token_Pos121;
else
   Row_Pos97 := No_Token_Index;
   goto Exit_Row97_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row97_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_list_expr') at parser.lkt:141:32>
if Row_Pos97 /= No_Token_Index then
   Transform_Res70 := Allocate_List_Kind_Zero (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res70,
      Kind => Lkt_List_Kind_Zero,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos94,
      Token_End_Index   => (if Row_Pos97 = Row_Pos94
                            then No_Token_Index
                            else Row_Pos97 - 1));
end if;
--  END <Transform(<ASTNodeType ListKind.Zero>) (root of 'grammar_list_expr') at parser.lkt:141:32>
    if Row_Pos97 /= No_Token_Index then
        Or_Pos19 := Row_Pos97;
        Or_Res19 := Transform_Res70;
        goto Exit_Or21;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail19.Pos then
       Branch_Diag_Mark19 := Parser.Last_Diag;
       Branch_Last_Fail19 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark19;
Parser.Last_Fail := Branch_Last_Fail19;
<<Exit_Or21>>
--  END <Or (root of 'grammar_list_expr') at parser.lkt:141:9>
if Or_Pos19 /= No_Token_Index then
   Row_Pos94 := Or_Pos19;
else
   Row_Pos94 := No_Token_Index;
   goto Exit_Row94_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_list_expr') at parser.lkt:142:9>
--  pos=Token_Pos122, res=Token_Res122, nobt=None
Token_Res122 := Row_Pos94;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res122));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos122 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos94 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos94,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos122 := Row_Pos94 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'grammar_list_expr') at parser.lkt:142:9>
if Token_Pos122 /= No_Token_Index then
   Row_Pos94 := Token_Pos122;
else
   Row_Pos94 := No_Token_Index;
   goto Exit_Row94_0;
end if;
--  BEGIN <DontSkip (root of 'grammar_list_expr') at parser.lkt:145:9>
--  pos=Or_Pos20, res=Or_Res20, nobt=None
        PP.Dont_Skip.Append (Dontskip_Grammar_List_Expr0_Extract_Parse0'Access);
--  BEGIN <DontSkip (root of 'grammar_list_expr') at parser.lkt:145:9>
--  pos=Or_Pos20, res=Or_Res20, nobt=None
        PP.Dont_Skip.Append (Dontskip_Grammar_List_Expr1_Extract_Parse0'Access);
--  BEGIN <Or (root of 'grammar_list_expr') at parser.lkt:145:9>
--  pos=Or_Pos20, res=Or_Res20, nobt=None
Or_Pos20 := No_Token_Index;
Or_Res20 := No_Bare_Lkt_Node;
Diag_Mark45 := Parser.Last_Diag;
Last_Fail20 := Parser.Last_Fail;
Branch_Diag_Mark20 := Parser.Last_Diag;
Branch_Last_Fail20 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark45;
    Parser.Last_Fail := Last_Fail20;
--  BEGIN <Defer (for 'grammar_implicit_pick') at parser.lkt:145:12>
--  pos=Defer_Pos109, res=Defer_Res109, nobt=None
Defer_Res109 :=
   Grammar_Implicit_Pick_Transform_Parse0 (Parser, Row_Pos94);
Defer_Pos109 := Parser.Current_Pos;
--  END <Defer (for 'grammar_implicit_pick') at parser.lkt:145:12>
    if Defer_Pos109 /= No_Token_Index then
        Or_Pos20 := Defer_Pos109;
        Or_Res20 := Defer_Res109;
        goto Exit_Or22;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail20.Pos then
       Branch_Diag_Mark20 := Parser.Last_Diag;
       Branch_Last_Fail20 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark45;
    Parser.Last_Fail := Last_Fail20;
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:145:36>
--  pos=Defer_Pos110, res=Defer_Res110, nobt=None
Defer_Res110 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos94);
Defer_Pos110 := Parser.Current_Pos;
--  END <Defer (for 'grammar_expr') at parser.lkt:145:36>
    if Defer_Pos110 /= No_Token_Index then
        Or_Pos20 := Defer_Pos110;
        Or_Res20 := Defer_Res110;
        goto Exit_Or22;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail20.Pos then
       Branch_Diag_Mark20 := Parser.Last_Diag;
       Branch_Last_Fail20 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark20;
Parser.Last_Fail := Branch_Last_Fail20;
<<Exit_Or22>>
--  END <Or (root of 'grammar_list_expr') at parser.lkt:145:9>
        PP.Dont_Skip.Delete_Last;
--  END <DontSkip (root of 'grammar_list_expr') at parser.lkt:145:9>
        PP.Dont_Skip.Delete_Last;
--  END <DontSkip (root of 'grammar_list_expr') at parser.lkt:145:9>
if Or_Pos20 /= No_Token_Index then
   Row_Pos94 := Or_Pos20;
else
   Row_Pos94 := No_Token_Index;
   goto Exit_Row94_0;
end if;
--  BEGIN <Opt (root of 'grammar_list_expr') at parser.lkt:148:9>
--  pos=Row_Pos98, res=Defer_Res111, nobt=None
Diag_Mark46 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'grammar_list_expr') at parser.lkt:148:10>
--  pos=Row_Pos98, res=Defer_Res111, nobt=None
--  BEGIN <_Row (root of 'grammar_list_expr') at parser.lkt:148:10>
--  pos=Row_Pos98, res=None, nobt=None
Row_Pos98 := Row_Pos94;
--  BEGIN <Token(<WithText Comma>, ) (root of 'grammar_list_expr') at parser.lkt:148:15>
--  pos=Token_Pos123, res=Token_Res123, nobt=None
Token_Res123 := Row_Pos98;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res123));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos123 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos98 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos98,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Comma,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos123 := Row_Pos98 + 1;
   end if;
end;
--  END <Token(<WithText Comma>, ) (root of 'grammar_list_expr') at parser.lkt:148:15>
if Token_Pos123 /= No_Token_Index then
   Row_Pos98 := Token_Pos123;
else
   Row_Pos98 := No_Token_Index;
   goto Exit_Row98_0;
end if;
--  BEGIN <Defer (for 'grammar_list_sep') at parser.lkt:148:19>
--  pos=Defer_Pos111, res=Defer_Res111, nobt=None
Defer_Res111 :=
   Grammar_List_Sep_Transform_Parse0 (Parser, Row_Pos98);
Defer_Pos111 := Parser.Current_Pos;
--  END <Defer (for 'grammar_list_sep') at parser.lkt:148:19>
if Defer_Pos111 /= No_Token_Index then
   Row_Pos98 := Defer_Pos111;
else
   Row_Pos98 := No_Token_Index;
   goto Exit_Row98_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row98_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_list_expr') at parser.lkt:148:10>
--  END <_Extract (root of 'grammar_list_expr') at parser.lkt:148:10>
if Row_Pos98 = No_Token_Index then
   Defer_Res111 := No_Bare_Lkt_Node;
   Row_Pos98 := Row_Pos94;
      Parser.Last_Diag := Diag_Mark46;
end if;
--  END <Opt (root of 'grammar_list_expr') at parser.lkt:148:9>
if Row_Pos98 /= No_Token_Index then
   Row_Pos94 := Row_Pos98;
else
   Row_Pos94 := No_Token_Index;
   goto Exit_Row94_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_list_expr') at parser.lkt:149:9>
--  pos=Token_Pos124, res=Token_Res124, nobt=None
Token_Res124 := Row_Pos94;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res124));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos124 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos94 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos94,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos124 := Row_Pos94 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'grammar_list_expr') at parser.lkt:149:9>
if Token_Pos124 /= No_Token_Index then
   Row_Pos94 := Token_Pos124;
else
   Row_Pos94 := No_Token_Index;
   goto Exit_Row94_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row94_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_list_expr') at parser.lkt:136:26>
if Row_Pos94 /= No_Token_Index then
   Transform_Res71 := Allocate_Grammar_List (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res71,
      Kind => Lkt_Grammar_List,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos94 = Pos
                            then No_Token_Index
                            else Row_Pos94 - 1));
      Initialize_Fields_For_Grammar_List
        (Self => Transform_Res71,
         Grammar_List_F_List_Type => Or_Res18,
         Grammar_List_F_Kind => Or_Res19,
         Grammar_List_F_Expr => Or_Res20,
         Grammar_List_F_Sep => Defer_Res111);
         if Or_Res18 /= null and then Is_Incomplete (Or_Res18) then
            Transform_Res71.Last_Attempted_Child := 0;
         elsif Or_Res18 /= null and then not Is_Ghost (Or_Res18) then
            Transform_Res71.Last_Attempted_Child := -1;
         end if;
         if Or_Res19 /= null and then Is_Incomplete (Or_Res19) then
            Transform_Res71.Last_Attempted_Child := 0;
         elsif Or_Res19 /= null and then not Is_Ghost (Or_Res19) then
            Transform_Res71.Last_Attempted_Child := -1;
         end if;
         if Or_Res20 /= null and then Is_Incomplete (Or_Res20) then
            Transform_Res71.Last_Attempted_Child := 0;
         elsif Or_Res20 /= null and then not Is_Ghost (Or_Res20) then
            Transform_Res71.Last_Attempted_Child := -1;
         end if;
         if Defer_Res111 /= null and then Is_Incomplete (Defer_Res111) then
            Transform_Res71.Last_Attempted_Child := 0;
         elsif Defer_Res111 /= null and then not Is_Ghost (Defer_Res111) then
            Transform_Res71.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType GrammarList>) (root of 'grammar_list_expr') at parser.lkt:136:26>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos94 = No_Token_Index then
      Set_Failure
        (PP.Grammar_List_Expr_Transform_Parse3_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Grammar_List_Expr_Transform_Parse3_Memo, Pos, Transform_Res71, Parser.Last_Diag, Row_Pos94);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos94;
   return Transform_Res71;
end Grammar_List_Expr_Transform_Parse3;
   function Grammar_List_Sep_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_List_Sep
is
      Row_Pos99 : Token_Index := No_Token_Index;
      Defer_Pos112 : Token_Index := No_Token_Index;
      Defer_Res112 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Row_Pos100 : Token_Index := No_Token_Index;
      Token_Pos125 : Token_Index := No_Token_Index;
      Token_Res125 : Token_Index := No_Token_Index;
      Defer_Pos113 : Token_Index := No_Token_Index;
      Defer_Res113 : Bare_Id := No_Bare_Lkt_Node;
      Diag_Mark47 : Diagnostic_Mark;
      Transform_Res72 : Bare_Grammar_List_Sep := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Grammar_List_Sep_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res72 := M.Instance;
      return Transform_Res72;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res72;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType GrammarListSep>) (root of 'grammar_list_sep') at parser.lkt:151:25>
--  pos=Row_Pos99, res=Transform_Res72, nobt=None
--  BEGIN <_Row (root of 'grammar_list_sep') at parser.lkt:151:25>
--  pos=Row_Pos99, res=None, nobt=None
Row_Pos99 := Pos;
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:151:40>
--  pos=Defer_Pos112, res=Defer_Res112, nobt=None
Defer_Res112 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos99);
Defer_Pos112 := Parser.Current_Pos;
--  END <Defer (for 'grammar_expr') at parser.lkt:151:40>
if Defer_Pos112 /= No_Token_Index then
   Row_Pos99 := Defer_Pos112;
else
   Row_Pos99 := No_Token_Index;
   goto Exit_Row99_0;
end if;
--  BEGIN <Opt (root of 'grammar_list_sep') at parser.lkt:151:53>
--  pos=Row_Pos100, res=Defer_Res113, nobt=None
Diag_Mark47 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'grammar_list_sep') at parser.lkt:151:54>
--  pos=Row_Pos100, res=Defer_Res113, nobt=None
--  BEGIN <_Row (root of 'grammar_list_sep') at parser.lkt:151:54>
--  pos=Row_Pos100, res=None, nobt=None
Row_Pos100 := Row_Pos99;
--  BEGIN <Token(<WithText Comma>, ) (root of 'grammar_list_sep') at parser.lkt:151:59>
--  pos=Token_Pos125, res=Token_Res125, nobt=None
Token_Res125 := Row_Pos100;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res125));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos125 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos100 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos100,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Comma,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos125 := Row_Pos100 + 1;
   end if;
end;
--  END <Token(<WithText Comma>, ) (root of 'grammar_list_sep') at parser.lkt:151:59>
if Token_Pos125 /= No_Token_Index then
   Row_Pos100 := Token_Pos125;
else
   Row_Pos100 := No_Token_Index;
   goto Exit_Row100_0;
end if;
--  BEGIN <Defer (for 'id') at parser.lkt:151:63>
--  pos=Defer_Pos113, res=Defer_Res113, nobt=None
Defer_Res113 :=
   Id_Transform_Parse0 (Parser, Row_Pos100);
Defer_Pos113 := Parser.Current_Pos;
--  END <Defer (for 'id') at parser.lkt:151:63>
if Defer_Pos113 /= No_Token_Index then
   Row_Pos100 := Defer_Pos113;
else
   Row_Pos100 := No_Token_Index;
   goto Exit_Row100_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row100_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_list_sep') at parser.lkt:151:54>
--  END <_Extract (root of 'grammar_list_sep') at parser.lkt:151:54>
if Row_Pos100 = No_Token_Index then
   Defer_Res113 := No_Bare_Lkt_Node;
   Row_Pos100 := Row_Pos99;
      Parser.Last_Diag := Diag_Mark47;
end if;
--  END <Opt (root of 'grammar_list_sep') at parser.lkt:151:53>
if Row_Pos100 /= No_Token_Index then
   Row_Pos99 := Row_Pos100;
else
   Row_Pos99 := No_Token_Index;
   goto Exit_Row99_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row99_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_list_sep') at parser.lkt:151:25>
if Row_Pos99 /= No_Token_Index then
   Transform_Res72 := Allocate_Grammar_List_Sep (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res72,
      Kind => Lkt_Grammar_List_Sep,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos99 = Pos
                            then No_Token_Index
                            else Row_Pos99 - 1));
      Initialize_Fields_For_Grammar_List_Sep
        (Self => Transform_Res72,
         Grammar_List_Sep_F_Token => Defer_Res112,
         Grammar_List_Sep_F_Extra => Defer_Res113);
         if Defer_Res112 /= null and then Is_Incomplete (Defer_Res112) then
            Transform_Res72.Last_Attempted_Child := 0;
         elsif Defer_Res112 /= null and then not Is_Ghost (Defer_Res112) then
            Transform_Res72.Last_Attempted_Child := -1;
         end if;
         if Defer_Res113 /= null and then Is_Incomplete (Defer_Res113) then
            Transform_Res72.Last_Attempted_Child := 0;
         elsif Defer_Res113 /= null and then not Is_Ghost (Defer_Res113) then
            Transform_Res72.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType GrammarListSep>) (root of 'grammar_list_sep') at parser.lkt:151:25>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos99 = No_Token_Index then
      Set_Failure
        (PP.Grammar_List_Sep_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Grammar_List_Sep_Transform_Parse0_Memo, Pos, Transform_Res72, Parser.Last_Diag, Row_Pos99);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos99;
   return Transform_Res72;
end Grammar_List_Sep_Transform_Parse0;
   function Grammar_Null_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Null
is
      Row_Pos101 : Token_Index := No_Token_Index;
      Token_Pos126 : Token_Index := No_Token_Index;
      Token_Res126 : Token_Index := No_Token_Index;
      Row_Pos102 : Token_Index := No_Token_Index;
      Token_Pos127 : Token_Index := No_Token_Index;
      Token_Res127 : Token_Index := No_Token_Index;
      Defer_Pos114 : Token_Index := No_Token_Index;
      Defer_Res114 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Token_Pos128 : Token_Index := No_Token_Index;
      Token_Res128 : Token_Index := No_Token_Index;
      Diag_Mark48 : Diagnostic_Mark;
      Transform_Res73 : Bare_Grammar_Null := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Grammar_Null_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res73 := M.Instance;
      return Transform_Res73;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res73;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType GrammarNull>) (root of 'grammar_null') at parser.lkt:153:21>
--  pos=Row_Pos101, res=Transform_Res73, nobt=None
--  BEGIN <_Row (root of 'grammar_null') at parser.lkt:153:21>
--  pos=Row_Pos101, res=None, nobt=None
Row_Pos101 := Pos;
--  BEGIN <Token(<WithText NullKw>, ) (root of 'grammar_null') at parser.lkt:153:33>
--  pos=Token_Pos126, res=Token_Res126, nobt=None
Token_Res126 := Row_Pos101;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res126));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Null_Kw)
   then
       Token_Pos126 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos101 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos101,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Null_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos126 := Row_Pos101 + 1;
   end if;
end;
--  END <Token(<WithText NullKw>, ) (root of 'grammar_null') at parser.lkt:153:33>
if Token_Pos126 /= No_Token_Index then
   Row_Pos101 := Token_Pos126;
else
   Row_Pos101 := No_Token_Index;
   goto Exit_Row101_0;
end if;
--  BEGIN <Opt (root of 'grammar_null') at parser.lkt:153:40>
--  pos=Row_Pos102, res=Defer_Res114, nobt=None
Diag_Mark48 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'grammar_null') at parser.lkt:153:41>
--  pos=Row_Pos102, res=Defer_Res114, nobt=None
--  BEGIN <_Row (root of 'grammar_null') at parser.lkt:153:41>
--  pos=Row_Pos102, res=None, nobt=None
Row_Pos102 := Row_Pos101;
--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_null') at parser.lkt:153:46>
--  pos=Token_Pos127, res=Token_Res127, nobt=None
Token_Res127 := Row_Pos102;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res127));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos127 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos102 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos102,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos127 := Row_Pos102 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'grammar_null') at parser.lkt:153:46>
if Token_Pos127 /= No_Token_Index then
   Row_Pos102 := Token_Pos127;
else
   Row_Pos102 := No_Token_Index;
   goto Exit_Row102_0;
end if;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:153:50>
--  pos=Defer_Pos114, res=Defer_Res114, nobt=None
Defer_Res114 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos102);
Defer_Pos114 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:153:50>
if Defer_Pos114 /= No_Token_Index then
   Row_Pos102 := Defer_Pos114;
else
   Row_Pos102 := No_Token_Index;
   goto Exit_Row102_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_null') at parser.lkt:153:59>
--  pos=Token_Pos128, res=Token_Res128, nobt=None
Token_Res128 := Row_Pos102;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res128));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos128 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos102 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos102,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos128 := Row_Pos102 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'grammar_null') at parser.lkt:153:59>
if Token_Pos128 /= No_Token_Index then
   Row_Pos102 := Token_Pos128;
else
   Row_Pos102 := No_Token_Index;
   goto Exit_Row102_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row102_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_null') at parser.lkt:153:41>
--  END <_Extract (root of 'grammar_null') at parser.lkt:153:41>
if Row_Pos102 = No_Token_Index then
   Defer_Res114 := No_Bare_Lkt_Node;
   Row_Pos102 := Row_Pos101;
      Parser.Last_Diag := Diag_Mark48;
end if;
--  END <Opt (root of 'grammar_null') at parser.lkt:153:40>
if Row_Pos102 /= No_Token_Index then
   Row_Pos101 := Row_Pos102;
else
   Row_Pos101 := No_Token_Index;
   goto Exit_Row101_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row101_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_null') at parser.lkt:153:21>
if Row_Pos101 /= No_Token_Index then
   Transform_Res73 := Allocate_Grammar_Null (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res73,
      Kind => Lkt_Grammar_Null,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos101 = Pos
                            then No_Token_Index
                            else Row_Pos101 - 1));
      Initialize_Fields_For_Grammar_Null
        (Self => Transform_Res73,
         Grammar_Null_F_Name => Defer_Res114);
         if Defer_Res114 /= null and then Is_Incomplete (Defer_Res114) then
            Transform_Res73.Last_Attempted_Child := 0;
         elsif Defer_Res114 /= null and then not Is_Ghost (Defer_Res114) then
            Transform_Res73.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType GrammarNull>) (root of 'grammar_null') at parser.lkt:153:21>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos101 = No_Token_Index then
      Set_Failure
        (PP.Grammar_Null_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Grammar_Null_Transform_Parse0_Memo, Pos, Transform_Res73, Parser.Last_Diag, Row_Pos101);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos101;
   return Transform_Res73;
end Grammar_Null_Transform_Parse0;
   function Grammar_Opt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr
is
      Nobt15 : Boolean := False;
      Nobt16 : Boolean := False;
      Row_Pos103 : Token_Index := No_Token_Index;
      Token_Pos129 : Token_Index := No_Token_Index;
      Token_Res129 : Token_Index := No_Token_Index;
      Token_Pos130 : Token_Index := No_Token_Index;
      Token_Res130 : Token_Index := No_Token_Index;
      Lst_Cpos13 : Token_Index := No_Token_Index;
      Tmp_List13 : Free_Parse_List;
      Defer_Pos115 : Token_Index := No_Token_Index;
      Defer_Res115 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      List_Pos13 : Token_Index := No_Token_Index;
      List_Res13 : Bare_Grammar_Expr_List := No_Bare_Lkt_Node;
      Diag_Mark49 : Diagnostic_Mark;
      Token_Pos131 : Token_Index := No_Token_Index;
      Token_Res131 : Token_Index := No_Token_Index;
      Row_Progress15 : Integer := 0;
      Transform_Res74 : Bare_Grammar_Opt_Group := No_Bare_Lkt_Node;
      Transform_Has_Failed15 : Boolean := False;
      Row_Pos104 : Token_Index := No_Token_Index;
      Token_Pos132 : Token_Index := No_Token_Index;
      Token_Res132 : Token_Index := No_Token_Index;
      Defer_Pos116 : Token_Index := No_Token_Index;
      Defer_Res116 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Row_Progress16 : Integer := 0;
      Transform_Res75 : Bare_Grammar_Opt := No_Bare_Lkt_Node;
      Transform_Has_Failed16 : Boolean := False;
      Or_Pos21 : Token_Index := No_Token_Index;
      Or_Res21 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Diag_Mark50 : Diagnostic_Mark;
      Last_Fail21 : Fail_Info;
      Branch_Diag_Mark21 : Diagnostic_Mark;
      Branch_Last_Fail21 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Grammar_Opt_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res21 := M.Instance;
      return Or_Res21;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res21;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'grammar_opt') at parser.lkt:96:20>
--  pos=Or_Pos21, res=Or_Res21, nobt=None
Or_Pos21 := No_Token_Index;
Or_Res21 := No_Bare_Lkt_Node;
Diag_Mark50 := Parser.Last_Diag;
Last_Fail21 := Parser.Last_Fail;
Branch_Diag_Mark21 := Parser.Last_Diag;
Branch_Last_Fail21 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark50;
    Parser.Last_Fail := Last_Fail21;
--  BEGIN <Transform(<ASTNodeType GrammarOptGroup>) (root of 'grammar_opt') at parser.lkt:97:11>
--  pos=Row_Pos103, res=Transform_Res74, nobt=Nobt15
--  BEGIN <_Row (root of 'grammar_opt') at parser.lkt:97:11>
--  pos=Row_Pos103, res=None, nobt=Nobt15
Row_Pos103 := Pos;
--  BEGIN <Token(<WithText IntMark>, ) (root of 'grammar_opt') at parser.lkt:97:27>
--  pos=Token_Pos129, res=Token_Res129, nobt=None
Token_Res129 := Row_Pos103;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res129));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Int_Mark)
   then
       Token_Pos129 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos103 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos103,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Int_Mark,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos129 := Row_Pos103 + 1;
   end if;
end;
--  END <Token(<WithText IntMark>, ) (root of 'grammar_opt') at parser.lkt:97:27>
Row_Progress15 := 1;
if Token_Pos129 /= No_Token_Index then
   Row_Pos103 := Token_Pos129;
else
   Row_Pos103 := No_Token_Index;
   goto Exit_Row103_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_opt') at parser.lkt:97:31>
--  pos=Token_Pos130, res=Token_Res130, nobt=None
Token_Res130 := Row_Pos103;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res130));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos130 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos103 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos103,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos130 := Row_Pos103 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'grammar_opt') at parser.lkt:97:31>
Row_Progress15 := 2;
if Token_Pos130 /= No_Token_Index then
   Row_Pos103 := Token_Pos130;
else
   Row_Pos103 := No_Token_Index;
   goto Exit_Row103_0;
end if;
--  BEGIN <Cut (root of 'grammar_opt') at parser.lkt:97:35>
--  pos=Row_Pos103, res=None, nobt=Nobt15
Nobt15 := True;
--  END <Cut (root of 'grammar_opt') at parser.lkt:97:35>
Row_Progress15 := 3;
if Row_Pos103 /= No_Token_Index then
   Row_Pos103 := Row_Pos103;
else
   Row_Pos103 := No_Token_Index;
   goto Exit_Row103_0;
end if;
--  BEGIN <DontSkip (root of 'grammar_opt') at parser.lkt:97:37>
--  pos=List_Pos13, res=List_Res13, nobt=None
        PP.Dont_Skip.Append (Dontskip_Grammar_Opt0_Extract_Parse0'Access);
--  BEGIN <List (root of 'grammar_opt') at parser.lkt:97:37>
--  pos=List_Pos13, res=List_Res13, nobt=None
    List_Pos13 := Row_Pos103;
Lst_Cpos13 := Row_Pos103;
Tmp_List13 := Get_Parse_List (Parser);
Diag_Mark49 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:97:43>
--  pos=Defer_Pos115, res=Defer_Res115, nobt=None
Defer_Res115 :=
   Grammar_Expr_Or_Parse0 (Parser, Lst_Cpos13);
Defer_Pos115 := Parser.Current_Pos;
--  END <Defer (for 'grammar_expr') at parser.lkt:97:43>
   exit when Defer_Pos115 = No_Token_Index;
   List_Pos13 := Defer_Pos115;
   Lst_Cpos13 := List_Pos13;
   Diag_Mark49 := Parser.Last_Diag;
   Tmp_List13.Nodes.Append (Defer_Res115);
end loop;
Parser.Last_Diag := Diag_Mark49;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List13.Nodes.Length;
begin
   List_Res13 := Allocate_Grammar_Expr_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos103;
      Token_End := (if Lst_Cpos13 = Row_Pos103
                    then Row_Pos103
                    else List_Pos13 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos103, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res13,
      Kind              => Lkt_Grammar_Expr_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res13,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List13.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res13.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List13);
--  END <List (root of 'grammar_opt') at parser.lkt:97:37>
        PP.Dont_Skip.Delete_Last;
--  END <DontSkip (root of 'grammar_opt') at parser.lkt:97:37>
Row_Progress15 := 4;
if List_Pos13 /= No_Token_Index then
   Row_Pos103 := List_Pos13;
else
   Row_Pos103 := No_Token_Index;
   goto Exit_Row103_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_opt') at parser.lkt:97:72>
--  pos=Token_Pos131, res=Token_Res131, nobt=None
Token_Res131 := Row_Pos103;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res131));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos131 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos103 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos103,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos131 := Row_Pos103 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'grammar_opt') at parser.lkt:97:72>
Row_Progress15 := 5;
if Token_Pos131 /= No_Token_Index then
   Row_Pos103 := Token_Pos131;
else
   Row_Pos103 := No_Token_Index;
   goto Exit_Row103_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row103_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_opt') at parser.lkt:97:11>
if Row_Pos103 = No_Token_Index and then Nobt15 then
   Row_Pos103 := Parser.Last_Fail.Pos;
   Transform_Has_Failed15 := True;
end if;
if Row_Pos103 /= No_Token_Index then
   Transform_Res74 := Allocate_Grammar_Opt_Group (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res74,
      Kind => Lkt_Grammar_Opt_Group,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos103 = Pos
                            then No_Token_Index
                            else Row_Pos103 - 1));
      Initialize_Fields_For_Grammar_Opt_Group
        (Self => Transform_Res74,
         Grammar_Opt_Group_F_Expr => List_Res13);
         if List_Res13 /= null and then Is_Incomplete (List_Res13) then
            Transform_Res74.Last_Attempted_Child := 0;
         elsif List_Res13 /= null and then not Is_Ghost (List_Res13) then
            Transform_Res74.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed15 then
      Transform_Res74.Last_Attempted_Child :=
         Row_Progress15;
      Append (Parser, Pos, "Cannot parse <grammar_opt>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType GrammarOptGroup>) (root of 'grammar_opt') at parser.lkt:97:11>
    if Row_Pos103 /= No_Token_Index then
        Or_Pos21 := Row_Pos103;
        Or_Res21 := Transform_Res74;
        goto Exit_Or23;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail21.Pos then
       Branch_Diag_Mark21 := Parser.Last_Diag;
       Branch_Last_Fail21 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark50;
    Parser.Last_Fail := Last_Fail21;
--  BEGIN <Transform(<ASTNodeType GrammarOpt>) (root of 'grammar_opt') at parser.lkt:98:11>
--  pos=Row_Pos104, res=Transform_Res75, nobt=Nobt16
--  BEGIN <_Row (root of 'grammar_opt') at parser.lkt:98:11>
--  pos=Row_Pos104, res=None, nobt=Nobt16
Row_Pos104 := Pos;
--  BEGIN <Token(<WithText IntMark>, ) (root of 'grammar_opt') at parser.lkt:98:22>
--  pos=Token_Pos132, res=Token_Res132, nobt=None
Token_Res132 := Row_Pos104;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res132));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Int_Mark)
   then
       Token_Pos132 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos104 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos104,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Int_Mark,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos132 := Row_Pos104 + 1;
   end if;
end;
--  END <Token(<WithText IntMark>, ) (root of 'grammar_opt') at parser.lkt:98:22>
Row_Progress16 := 1;
if Token_Pos132 /= No_Token_Index then
   Row_Pos104 := Token_Pos132;
else
   Row_Pos104 := No_Token_Index;
   goto Exit_Row104_0;
end if;
--  BEGIN <Cut (root of 'grammar_opt') at parser.lkt:98:26>
--  pos=Row_Pos104, res=None, nobt=Nobt16
Nobt16 := True;
--  END <Cut (root of 'grammar_opt') at parser.lkt:98:26>
Row_Progress16 := 2;
if Row_Pos104 /= No_Token_Index then
   Row_Pos104 := Row_Pos104;
else
   Row_Pos104 := No_Token_Index;
   goto Exit_Row104_0;
end if;
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:98:28>
--  pos=Defer_Pos116, res=Defer_Res116, nobt=None
Defer_Res116 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos104);
Defer_Pos116 := Parser.Current_Pos;
--  END <Defer (for 'grammar_expr') at parser.lkt:98:28>
Row_Progress16 := 3;
if Defer_Pos116 /= No_Token_Index then
   Row_Pos104 := Defer_Pos116;
else
   Row_Pos104 := No_Token_Index;
   goto Exit_Row104_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row104_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_opt') at parser.lkt:98:11>
if Row_Pos104 = No_Token_Index and then Nobt16 then
   Row_Pos104 := Parser.Last_Fail.Pos;
   Transform_Has_Failed16 := True;
end if;
if Row_Pos104 /= No_Token_Index then
   Transform_Res75 := Allocate_Grammar_Opt (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res75,
      Kind => Lkt_Grammar_Opt,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos104 = Pos
                            then No_Token_Index
                            else Row_Pos104 - 1));
      Initialize_Fields_For_Grammar_Opt
        (Self => Transform_Res75,
         Grammar_Opt_F_Expr => Defer_Res116);
         if Defer_Res116 /= null and then Is_Incomplete (Defer_Res116) then
            Transform_Res75.Last_Attempted_Child := 0;
         elsif Defer_Res116 /= null and then not Is_Ghost (Defer_Res116) then
            Transform_Res75.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed16 then
      Transform_Res75.Last_Attempted_Child :=
         Row_Progress16;
      Append (Parser, Pos, "Cannot parse <grammar_opt>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType GrammarOpt>) (root of 'grammar_opt') at parser.lkt:98:11>
    if Row_Pos104 /= No_Token_Index then
        Or_Pos21 := Row_Pos104;
        Or_Res21 := Transform_Res75;
        goto Exit_Or23;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail21.Pos then
       Branch_Diag_Mark21 := Parser.Last_Diag;
       Branch_Last_Fail21 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark21;
Parser.Last_Fail := Branch_Last_Fail21;
<<Exit_Or23>>
--  END <Or (root of 'grammar_opt') at parser.lkt:96:20>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos21 = No_Token_Index then
      Set_Failure
        (PP.Grammar_Opt_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Grammar_Opt_Or_Parse0_Memo, Pos, Or_Res21, Parser.Last_Diag, Or_Pos21);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos21;
   return Or_Res21;
end Grammar_Opt_Or_Parse0;
   function Grammar_Opt_Error_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr
is
      Nobt17 : Boolean := False;
      Nobt18 : Boolean := False;
      Row_Pos105 : Token_Index := No_Token_Index;
      Token_Pos133 : Token_Index := No_Token_Index;
      Token_Res133 : Token_Index := No_Token_Index;
      Token_Pos134 : Token_Index := No_Token_Index;
      Token_Res134 : Token_Index := No_Token_Index;
      Lst_Cpos14 : Token_Index := No_Token_Index;
      Tmp_List14 : Free_Parse_List;
      Defer_Pos117 : Token_Index := No_Token_Index;
      Defer_Res117 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      List_Pos14 : Token_Index := No_Token_Index;
      List_Res14 : Bare_Grammar_Expr_List := No_Bare_Lkt_Node;
      Diag_Mark51 : Diagnostic_Mark;
      Token_Pos135 : Token_Index := No_Token_Index;
      Token_Res135 : Token_Index := No_Token_Index;
      Row_Progress17 : Integer := 0;
      Transform_Res76 : Bare_Grammar_Opt_Error_Group := No_Bare_Lkt_Node;
      Transform_Has_Failed17 : Boolean := False;
      Row_Pos106 : Token_Index := No_Token_Index;
      Token_Pos136 : Token_Index := No_Token_Index;
      Token_Res136 : Token_Index := No_Token_Index;
      Defer_Pos118 : Token_Index := No_Token_Index;
      Defer_Res118 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Row_Progress18 : Integer := 0;
      Transform_Res77 : Bare_Grammar_Opt_Error := No_Bare_Lkt_Node;
      Transform_Has_Failed18 : Boolean := False;
      Or_Pos22 : Token_Index := No_Token_Index;
      Or_Res22 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Diag_Mark52 : Diagnostic_Mark;
      Last_Fail22 : Fail_Info;
      Branch_Diag_Mark22 : Diagnostic_Mark;
      Branch_Last_Fail22 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Grammar_Opt_Error_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res22 := M.Instance;
      return Or_Res22;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res22;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'grammar_opt_error') at parser.lkt:100:26>
--  pos=Or_Pos22, res=Or_Res22, nobt=None
Or_Pos22 := No_Token_Index;
Or_Res22 := No_Bare_Lkt_Node;
Diag_Mark52 := Parser.Last_Diag;
Last_Fail22 := Parser.Last_Fail;
Branch_Diag_Mark22 := Parser.Last_Diag;
Branch_Last_Fail22 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark52;
    Parser.Last_Fail := Last_Fail22;
--  BEGIN <Transform(<ASTNodeType GrammarOptErrorGroup>) (root of 'grammar_opt_error') at parser.lkt:101:11>
--  pos=Row_Pos105, res=Transform_Res76, nobt=Nobt17
--  BEGIN <_Row (root of 'grammar_opt_error') at parser.lkt:101:11>
--  pos=Row_Pos105, res=None, nobt=Nobt17
Row_Pos105 := Pos;
--  BEGIN <Token(<WithText ExclMark>, ) (root of 'grammar_opt_error') at parser.lkt:102:13>
--  pos=Token_Pos133, res=Token_Res133, nobt=None
Token_Res133 := Row_Pos105;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res133));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Excl_Mark)
   then
       Token_Pos133 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos105 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos105,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Excl_Mark,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos133 := Row_Pos105 + 1;
   end if;
end;
--  END <Token(<WithText ExclMark>, ) (root of 'grammar_opt_error') at parser.lkt:102:13>
Row_Progress17 := 1;
if Token_Pos133 /= No_Token_Index then
   Row_Pos105 := Token_Pos133;
else
   Row_Pos105 := No_Token_Index;
   goto Exit_Row105_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_opt_error') at parser.lkt:102:17>
--  pos=Token_Pos134, res=Token_Res134, nobt=None
Token_Res134 := Row_Pos105;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res134));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos134 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos105 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos105,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos134 := Row_Pos105 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'grammar_opt_error') at parser.lkt:102:17>
Row_Progress17 := 2;
if Token_Pos134 /= No_Token_Index then
   Row_Pos105 := Token_Pos134;
else
   Row_Pos105 := No_Token_Index;
   goto Exit_Row105_0;
end if;
--  BEGIN <Cut (root of 'grammar_opt_error') at parser.lkt:102:21>
--  pos=Row_Pos105, res=None, nobt=Nobt17
Nobt17 := True;
--  END <Cut (root of 'grammar_opt_error') at parser.lkt:102:21>
Row_Progress17 := 3;
if Row_Pos105 /= No_Token_Index then
   Row_Pos105 := Row_Pos105;
else
   Row_Pos105 := No_Token_Index;
   goto Exit_Row105_0;
end if;
--  BEGIN <DontSkip (root of 'grammar_opt_error') at parser.lkt:102:23>
--  pos=List_Pos14, res=List_Res14, nobt=None
        PP.Dont_Skip.Append (Dontskip_Grammar_Opt_Error0_Extract_Parse0'Access);
--  BEGIN <List (root of 'grammar_opt_error') at parser.lkt:102:23>
--  pos=List_Pos14, res=List_Res14, nobt=None
    List_Pos14 := Row_Pos105;
Lst_Cpos14 := Row_Pos105;
Tmp_List14 := Get_Parse_List (Parser);
Diag_Mark51 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:102:29>
--  pos=Defer_Pos117, res=Defer_Res117, nobt=None
Defer_Res117 :=
   Grammar_Expr_Or_Parse0 (Parser, Lst_Cpos14);
Defer_Pos117 := Parser.Current_Pos;
--  END <Defer (for 'grammar_expr') at parser.lkt:102:29>
   exit when Defer_Pos117 = No_Token_Index;
   List_Pos14 := Defer_Pos117;
   Lst_Cpos14 := List_Pos14;
   Diag_Mark51 := Parser.Last_Diag;
   Tmp_List14.Nodes.Append (Defer_Res117);
end loop;
Parser.Last_Diag := Diag_Mark51;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List14.Nodes.Length;
begin
   List_Res14 := Allocate_Grammar_Expr_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos105;
      Token_End := (if Lst_Cpos14 = Row_Pos105
                    then Row_Pos105
                    else List_Pos14 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos105, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res14,
      Kind              => Lkt_Grammar_Expr_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res14,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List14.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res14.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List14);
--  END <List (root of 'grammar_opt_error') at parser.lkt:102:23>
        PP.Dont_Skip.Delete_Last;
--  END <DontSkip (root of 'grammar_opt_error') at parser.lkt:102:23>
Row_Progress17 := 4;
if List_Pos14 /= No_Token_Index then
   Row_Pos105 := List_Pos14;
else
   Row_Pos105 := No_Token_Index;
   goto Exit_Row105_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_opt_error') at parser.lkt:102:58>
--  pos=Token_Pos135, res=Token_Res135, nobt=None
Token_Res135 := Row_Pos105;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res135));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos135 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos105 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos105,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos135 := Row_Pos105 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'grammar_opt_error') at parser.lkt:102:58>
Row_Progress17 := 5;
if Token_Pos135 /= No_Token_Index then
   Row_Pos105 := Token_Pos135;
else
   Row_Pos105 := No_Token_Index;
   goto Exit_Row105_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row105_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_opt_error') at parser.lkt:101:11>
if Row_Pos105 = No_Token_Index and then Nobt17 then
   Row_Pos105 := Parser.Last_Fail.Pos;
   Transform_Has_Failed17 := True;
end if;
if Row_Pos105 /= No_Token_Index then
   Transform_Res76 := Allocate_Grammar_Opt_Error_Group (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res76,
      Kind => Lkt_Grammar_Opt_Error_Group,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos105 = Pos
                            then No_Token_Index
                            else Row_Pos105 - 1));
      Initialize_Fields_For_Grammar_Opt_Error_Group
        (Self => Transform_Res76,
         Grammar_Opt_Error_Group_F_Expr => List_Res14);
         if List_Res14 /= null and then Is_Incomplete (List_Res14) then
            Transform_Res76.Last_Attempted_Child := 0;
         elsif List_Res14 /= null and then not Is_Ghost (List_Res14) then
            Transform_Res76.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed17 then
      Transform_Res76.Last_Attempted_Child :=
         Row_Progress17;
      Append (Parser, Pos, "Cannot parse <grammar_opt_error>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType GrammarOptErrorGroup>) (root of 'grammar_opt_error') at parser.lkt:101:11>
    if Row_Pos105 /= No_Token_Index then
        Or_Pos22 := Row_Pos105;
        Or_Res22 := Transform_Res76;
        goto Exit_Or24;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail22.Pos then
       Branch_Diag_Mark22 := Parser.Last_Diag;
       Branch_Last_Fail22 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark52;
    Parser.Last_Fail := Last_Fail22;
--  BEGIN <Transform(<ASTNodeType GrammarOptError>) (root of 'grammar_opt_error') at parser.lkt:104:11>
--  pos=Row_Pos106, res=Transform_Res77, nobt=Nobt18
--  BEGIN <_Row (root of 'grammar_opt_error') at parser.lkt:104:11>
--  pos=Row_Pos106, res=None, nobt=Nobt18
Row_Pos106 := Pos;
--  BEGIN <Token(<WithText ExclMark>, ) (root of 'grammar_opt_error') at parser.lkt:104:27>
--  pos=Token_Pos136, res=Token_Res136, nobt=None
Token_Res136 := Row_Pos106;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res136));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Excl_Mark)
   then
       Token_Pos136 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos106 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos106,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Excl_Mark,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos136 := Row_Pos106 + 1;
   end if;
end;
--  END <Token(<WithText ExclMark>, ) (root of 'grammar_opt_error') at parser.lkt:104:27>
Row_Progress18 := 1;
if Token_Pos136 /= No_Token_Index then
   Row_Pos106 := Token_Pos136;
else
   Row_Pos106 := No_Token_Index;
   goto Exit_Row106_0;
end if;
--  BEGIN <Cut (root of 'grammar_opt_error') at parser.lkt:104:31>
--  pos=Row_Pos106, res=None, nobt=Nobt18
Nobt18 := True;
--  END <Cut (root of 'grammar_opt_error') at parser.lkt:104:31>
Row_Progress18 := 2;
if Row_Pos106 /= No_Token_Index then
   Row_Pos106 := Row_Pos106;
else
   Row_Pos106 := No_Token_Index;
   goto Exit_Row106_0;
end if;
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:104:33>
--  pos=Defer_Pos118, res=Defer_Res118, nobt=None
Defer_Res118 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos106);
Defer_Pos118 := Parser.Current_Pos;
--  END <Defer (for 'grammar_expr') at parser.lkt:104:33>
Row_Progress18 := 3;
if Defer_Pos118 /= No_Token_Index then
   Row_Pos106 := Defer_Pos118;
else
   Row_Pos106 := No_Token_Index;
   goto Exit_Row106_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row106_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_opt_error') at parser.lkt:104:11>
if Row_Pos106 = No_Token_Index and then Nobt18 then
   Row_Pos106 := Parser.Last_Fail.Pos;
   Transform_Has_Failed18 := True;
end if;
if Row_Pos106 /= No_Token_Index then
   Transform_Res77 := Allocate_Grammar_Opt_Error (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res77,
      Kind => Lkt_Grammar_Opt_Error,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos106 = Pos
                            then No_Token_Index
                            else Row_Pos106 - 1));
      Initialize_Fields_For_Grammar_Opt_Error
        (Self => Transform_Res77,
         Grammar_Opt_Error_F_Expr => Defer_Res118);
         if Defer_Res118 /= null and then Is_Incomplete (Defer_Res118) then
            Transform_Res77.Last_Attempted_Child := 0;
         elsif Defer_Res118 /= null and then not Is_Ghost (Defer_Res118) then
            Transform_Res77.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed18 then
      Transform_Res77.Last_Attempted_Child :=
         Row_Progress18;
      Append (Parser, Pos, "Cannot parse <grammar_opt_error>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType GrammarOptError>) (root of 'grammar_opt_error') at parser.lkt:104:11>
    if Row_Pos106 /= No_Token_Index then
        Or_Pos22 := Row_Pos106;
        Or_Res22 := Transform_Res77;
        goto Exit_Or24;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail22.Pos then
       Branch_Diag_Mark22 := Parser.Last_Diag;
       Branch_Last_Fail22 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark22;
Parser.Last_Fail := Branch_Last_Fail22;
<<Exit_Or24>>
--  END <Or (root of 'grammar_opt_error') at parser.lkt:100:26>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos22 = No_Token_Index then
      Set_Failure
        (PP.Grammar_Opt_Error_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Grammar_Opt_Error_Or_Parse0_Memo, Pos, Or_Res22, Parser.Last_Diag, Or_Pos22);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos22;
   return Or_Res22;
end Grammar_Opt_Error_Or_Parse0;
   function Grammar_Or_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Or_Expr
is
      Row_Pos107 : Token_Index := No_Token_Index;
      Token_Pos137 : Token_Index := No_Token_Index;
      Token_Res137 : Token_Index := No_Token_Index;
      Token_Pos138 : Token_Index := No_Token_Index;
      Token_Res138 : Token_Index := No_Token_Index;
      Lst_Cpos15 : Token_Index := No_Token_Index;
      Tmp_List15 : Free_Parse_List;
      Has_Leading0 : Boolean := False;
      Lst_Cpos16 : Token_Index := No_Token_Index;
      Tmp_List16 : Free_Parse_List;
      Defer_Pos119 : Token_Index := No_Token_Index;
      Defer_Res119 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      List_Pos15 : Token_Index := No_Token_Index;
      List_Res15 : Bare_Grammar_Expr_List := No_Bare_Lkt_Node;
      Diag_Mark53 : Diagnostic_Mark;
      Token_Pos139 : Token_Index := No_Token_Index;
      Token_Res139 : Token_Index := No_Token_Index;
      List_Pos16 : Token_Index := No_Token_Index;
      List_Res16 : Bare_Grammar_Expr_List_List := No_Bare_Lkt_Node;
      Diag_Mark54 : Diagnostic_Mark;
      Token_Pos140 : Token_Index := No_Token_Index;
      Token_Res140 : Token_Index := No_Token_Index;
      Transform_Res78 : Bare_Grammar_Or_Expr := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Grammar_Or_Expr_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res78 := M.Instance;
      return Transform_Res78;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res78;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType GrammarOrExpr>) (root of 'grammar_or_expr') at parser.lkt:110:24>
--  pos=Row_Pos107, res=Transform_Res78, nobt=None
--  BEGIN <_Row (root of 'grammar_or_expr') at parser.lkt:110:24>
--  pos=Row_Pos107, res=None, nobt=None
Row_Pos107 := Pos;
--  BEGIN <Token(<WithText OrKw>, ) (root of 'grammar_or_expr') at parser.lkt:111:9>
--  pos=Token_Pos137, res=Token_Res137, nobt=None
Token_Res137 := Row_Pos107;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res137));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Or_Kw)
   then
       Token_Pos137 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos107 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos107,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Or_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos137 := Row_Pos107 + 1;
   end if;
end;
--  END <Token(<WithText OrKw>, ) (root of 'grammar_or_expr') at parser.lkt:111:9>
if Token_Pos137 /= No_Token_Index then
   Row_Pos107 := Token_Pos137;
else
   Row_Pos107 := No_Token_Index;
   goto Exit_Row107_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_or_expr') at parser.lkt:112:9>
--  pos=Token_Pos138, res=Token_Res138, nobt=None
Token_Res138 := Row_Pos107;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res138));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos138 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos107 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos107,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos138 := Row_Pos107 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'grammar_or_expr') at parser.lkt:112:9>
if Token_Pos138 /= No_Token_Index then
   Row_Pos107 := Token_Pos138;
else
   Row_Pos107 := No_Token_Index;
   goto Exit_Row107_0;
end if;
--  BEGIN <DontSkip (root of 'grammar_or_expr') at parser.lkt:113:9>
--  pos=List_Pos16, res=List_Res16, nobt=None
        PP.Dont_Skip.Append (Dontskip_Grammar_Or_Expr0_Extract_Parse0'Access);
--  BEGIN <List (root of 'grammar_or_expr') at parser.lkt:113:9>
--  pos=List_Pos16, res=List_Res16, nobt=None
    List_Pos16 := No_Token_Index;
Lst_Cpos15 := Row_Pos107;
Tmp_List15 := Get_Parse_List (Parser);
--  BEGIN <Token(<WithText Pipe>, ) (root of 'grammar_or_expr') at parser.lkt:114:49>
--  pos=Token_Pos139, res=Token_Res139, nobt=None
Token_Res139 := Lst_Cpos15;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res139));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Pipe)
   then
       Token_Pos139 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Lst_Cpos15 then
          Parser.Last_Fail :=
            (Pos  => Lst_Cpos15,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Pipe,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos139 := Lst_Cpos15 + 1;
   end if;
end;
--  END <Token(<WithText Pipe>, ) (root of 'grammar_or_expr') at parser.lkt:114:49>
   if Token_Pos139 /= No_Token_Index then
       Lst_Cpos15 := Token_Pos139;
       Has_Leading0 := True;
   else
       Has_Leading0 := False;
   end if;
Diag_Mark54 := Parser.Last_Diag;
loop
--  BEGIN <DontSkip (root of 'grammar_or_expr') at parser.lkt:114:13>
--  pos=List_Pos15, res=List_Res15, nobt=None
        PP.Dont_Skip.Append (Dontskip_Grammar_Or_Expr1_Extract_Parse0'Access);
--  BEGIN <List (root of 'grammar_or_expr') at parser.lkt:114:13>
--  pos=List_Pos15, res=List_Res15, nobt=None
    List_Pos15 := No_Token_Index;
Lst_Cpos16 := Lst_Cpos15;
Tmp_List16 := Get_Parse_List (Parser);
Diag_Mark53 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:114:19>
--  pos=Defer_Pos119, res=Defer_Res119, nobt=None
Defer_Res119 :=
   Grammar_Expr_Or_Parse0 (Parser, Lst_Cpos16);
Defer_Pos119 := Parser.Current_Pos;
--  END <Defer (for 'grammar_expr') at parser.lkt:114:19>
   exit when Defer_Pos119 = No_Token_Index;
   List_Pos15 := Defer_Pos119;
   Lst_Cpos16 := List_Pos15;
   Diag_Mark53 := Parser.Last_Diag;
   Tmp_List16.Nodes.Append (Defer_Res119);
end loop;
Parser.Last_Diag := Diag_Mark53;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List16.Nodes.Length;
begin
   List_Res15 := Allocate_Grammar_Expr_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Lst_Cpos15;
      Token_End := (if Lst_Cpos16 = Lst_Cpos15
                    then Lst_Cpos15
                    else List_Pos15 - 1);
   else
      Token_Start := Token_Index'Max (Lst_Cpos15, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res15,
      Kind              => Lkt_Grammar_Expr_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res15,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List16.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res15.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List16);
--  END <List (root of 'grammar_or_expr') at parser.lkt:114:13>
        PP.Dont_Skip.Delete_Last;
--  END <DontSkip (root of 'grammar_or_expr') at parser.lkt:114:13>
   exit when List_Pos15 = No_Token_Index;
   List_Pos16 := List_Pos15;
   Lst_Cpos15 := List_Pos16;
   Diag_Mark54 := Parser.Last_Diag;
   Tmp_List15.Nodes.Append (List_Res15);
--  BEGIN <Token(<WithText Pipe>, ) (root of 'grammar_or_expr') at parser.lkt:114:49>
--  pos=Token_Pos139, res=Token_Res139, nobt=None
Token_Res139 := Lst_Cpos15;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res139));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Pipe)
   then
       Token_Pos139 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Lst_Cpos15 then
          Parser.Last_Fail :=
            (Pos  => Lst_Cpos15,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Pipe,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos139 := Lst_Cpos15 + 1;
   end if;
end;
--  END <Token(<WithText Pipe>, ) (root of 'grammar_or_expr') at parser.lkt:114:49>
      exit when Token_Pos139 = No_Token_Index;
      Lst_Cpos15 := Token_Pos139;
end loop;
Parser.Last_Diag := Diag_Mark54;
   if Has_Leading0 and then Tmp_List15.Nodes.Is_Empty then
      List_Pos16 := No_Token_Index;
   end if;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List15.Nodes.Length;
begin
   List_Res16 := Allocate_Grammar_Expr_List_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos107;
      Token_End := (if Lst_Cpos15 = Row_Pos107
                    then Row_Pos107
                    else List_Pos16 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos107, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res16,
      Kind              => Lkt_Grammar_Expr_List_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res16,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List15.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res16.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List15);
--  END <List (root of 'grammar_or_expr') at parser.lkt:113:9>
        PP.Dont_Skip.Delete_Last;
--  END <DontSkip (root of 'grammar_or_expr') at parser.lkt:113:9>
if List_Pos16 /= No_Token_Index then
   Row_Pos107 := List_Pos16;
else
   Row_Pos107 := No_Token_Index;
   goto Exit_Row107_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_or_expr') at parser.lkt:116:9>
--  pos=Token_Pos140, res=Token_Res140, nobt=None
Token_Res140 := Row_Pos107;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res140));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos140 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos107 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos107,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos140 := Row_Pos107 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'grammar_or_expr') at parser.lkt:116:9>
if Token_Pos140 /= No_Token_Index then
   Row_Pos107 := Token_Pos140;
else
   Row_Pos107 := No_Token_Index;
   goto Exit_Row107_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row107_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_or_expr') at parser.lkt:110:24>
if Row_Pos107 /= No_Token_Index then
   Transform_Res78 := Allocate_Grammar_Or_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res78,
      Kind => Lkt_Grammar_Or_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos107 = Pos
                            then No_Token_Index
                            else Row_Pos107 - 1));
      Initialize_Fields_For_Grammar_Or_Expr
        (Self => Transform_Res78,
         Grammar_Or_Expr_F_Sub_Exprs => List_Res16);
         if List_Res16 /= null and then Is_Incomplete (List_Res16) then
            Transform_Res78.Last_Attempted_Child := 0;
         elsif List_Res16 /= null and then not Is_Ghost (List_Res16) then
            Transform_Res78.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType GrammarOrExpr>) (root of 'grammar_or_expr') at parser.lkt:110:24>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos107 = No_Token_Index then
      Set_Failure
        (PP.Grammar_Or_Expr_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Grammar_Or_Expr_Transform_Parse0_Memo, Pos, Transform_Res78, Parser.Last_Diag, Row_Pos107);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos107;
   return Transform_Res78;
end Grammar_Or_Expr_Transform_Parse0;
   function Grammar_Pick_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Pick
is
      Row_Pos108 : Token_Index := No_Token_Index;
      Token_Pos141 : Token_Index := No_Token_Index;
      Token_Res141 : Token_Index := No_Token_Index;
      Token_Pos142 : Token_Index := No_Token_Index;
      Token_Res142 : Token_Index := No_Token_Index;
      Lst_Cpos17 : Token_Index := No_Token_Index;
      Tmp_List17 : Free_Parse_List;
      Defer_Pos120 : Token_Index := No_Token_Index;
      Defer_Res120 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      List_Pos17 : Token_Index := No_Token_Index;
      List_Res17 : Bare_Grammar_Expr_List := No_Bare_Lkt_Node;
      Diag_Mark55 : Diagnostic_Mark;
      Token_Pos143 : Token_Index := No_Token_Index;
      Token_Res143 : Token_Index := No_Token_Index;
      Transform_Res79 : Bare_Grammar_Pick := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Grammar_Pick_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res79 := M.Instance;
      return Transform_Res79;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res79;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType GrammarPick>) (root of 'grammar_pick') at parser.lkt:92:21>
--  pos=Row_Pos108, res=Transform_Res79, nobt=None
--  BEGIN <_Row (root of 'grammar_pick') at parser.lkt:92:21>
--  pos=Row_Pos108, res=None, nobt=None
Row_Pos108 := Pos;
--  BEGIN <Token(<WithSymbol Identifier>, pick) (root of 'grammar_pick') at parser.lkt:93:9>
--  pos=Token_Pos141, res=Token_Res141, nobt=None
Token_Res141 := Row_Pos108;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res141));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Pick)
   then
       Token_Pos141 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos108 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos108,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos141 := Row_Pos108 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, pick) (root of 'grammar_pick') at parser.lkt:93:9>
if Token_Pos141 /= No_Token_Index then
   Row_Pos108 := Token_Pos141;
else
   Row_Pos108 := No_Token_Index;
   goto Exit_Row108_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_pick') at parser.lkt:93:29>
--  pos=Token_Pos142, res=Token_Res142, nobt=None
Token_Res142 := Row_Pos108;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res142));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos142 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos108 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos108,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos142 := Row_Pos108 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'grammar_pick') at parser.lkt:93:29>
if Token_Pos142 /= No_Token_Index then
   Row_Pos108 := Token_Pos142;
else
   Row_Pos108 := No_Token_Index;
   goto Exit_Row108_0;
end if;
--  BEGIN <DontSkip (root of 'grammar_pick') at parser.lkt:93:33>
--  pos=List_Pos17, res=List_Res17, nobt=None
        PP.Dont_Skip.Append (Dontskip_Grammar_Pick0_Extract_Parse0'Access);
--  BEGIN <List (root of 'grammar_pick') at parser.lkt:93:33>
--  pos=List_Pos17, res=List_Res17, nobt=None
    List_Pos17 := No_Token_Index;
Lst_Cpos17 := Row_Pos108;
Tmp_List17 := Get_Parse_List (Parser);
Diag_Mark55 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:93:39>
--  pos=Defer_Pos120, res=Defer_Res120, nobt=None
Defer_Res120 :=
   Grammar_Expr_Or_Parse0 (Parser, Lst_Cpos17);
Defer_Pos120 := Parser.Current_Pos;
--  END <Defer (for 'grammar_expr') at parser.lkt:93:39>
   exit when Defer_Pos120 = No_Token_Index;
   List_Pos17 := Defer_Pos120;
   Lst_Cpos17 := List_Pos17;
   Diag_Mark55 := Parser.Last_Diag;
   Tmp_List17.Nodes.Append (Defer_Res120);
end loop;
Parser.Last_Diag := Diag_Mark55;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List17.Nodes.Length;
begin
   List_Res17 := Allocate_Grammar_Expr_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos108;
      Token_End := (if Lst_Cpos17 = Row_Pos108
                    then Row_Pos108
                    else List_Pos17 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos108, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res17,
      Kind              => Lkt_Grammar_Expr_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res17,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List17.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res17.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List17);
--  END <List (root of 'grammar_pick') at parser.lkt:93:33>
        PP.Dont_Skip.Delete_Last;
--  END <DontSkip (root of 'grammar_pick') at parser.lkt:93:33>
if List_Pos17 /= No_Token_Index then
   Row_Pos108 := List_Pos17;
else
   Row_Pos108 := No_Token_Index;
   goto Exit_Row108_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_pick') at parser.lkt:93:68>
--  pos=Token_Pos143, res=Token_Res143, nobt=None
Token_Res143 := Row_Pos108;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res143));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos143 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos108 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos108,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos143 := Row_Pos108 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'grammar_pick') at parser.lkt:93:68>
if Token_Pos143 /= No_Token_Index then
   Row_Pos108 := Token_Pos143;
else
   Row_Pos108 := No_Token_Index;
   goto Exit_Row108_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row108_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_pick') at parser.lkt:92:21>
if Row_Pos108 /= No_Token_Index then
   Transform_Res79 := Allocate_Grammar_Pick (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res79,
      Kind => Lkt_Grammar_Pick,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos108 = Pos
                            then No_Token_Index
                            else Row_Pos108 - 1));
      Initialize_Fields_For_Grammar_Pick
        (Self => Transform_Res79,
         Grammar_Pick_F_Exprs => List_Res17);
         if List_Res17 /= null and then Is_Incomplete (List_Res17) then
            Transform_Res79.Last_Attempted_Child := 0;
         elsif List_Res17 /= null and then not Is_Ghost (List_Res17) then
            Transform_Res79.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType GrammarPick>) (root of 'grammar_pick') at parser.lkt:92:21>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos108 = No_Token_Index then
      Set_Failure
        (PP.Grammar_Pick_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Grammar_Pick_Transform_Parse0_Memo, Pos, Transform_Res79, Parser.Last_Diag, Row_Pos108);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos108;
   return Transform_Res79;
end Grammar_Pick_Transform_Parse0;
   function Grammar_Primary_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr
is
      Defer_Pos121 : Token_Index := No_Token_Index;
      Defer_Res121 : Bare_Grammar_Pick := No_Bare_Lkt_Node;
      Defer_Pos122 : Token_Index := No_Token_Index;
      Defer_Res122 : Bare_Grammar_List := No_Bare_Lkt_Node;
      Defer_Pos123 : Token_Index := No_Token_Index;
      Defer_Res123 : Bare_Token_Lit := No_Bare_Lkt_Node;
      Defer_Pos124 : Token_Index := No_Token_Index;
      Defer_Res124 : Bare_Token_No_Case_Lit := No_Bare_Lkt_Node;
      Defer_Pos125 : Token_Index := No_Token_Index;
      Defer_Res125 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Defer_Pos126 : Token_Index := No_Token_Index;
      Defer_Res126 : Bare_Grammar_Cut := No_Bare_Lkt_Node;
      Defer_Pos127 : Token_Index := No_Token_Index;
      Defer_Res127 : Bare_Grammar_Skip := No_Bare_Lkt_Node;
      Defer_Pos128 : Token_Index := No_Token_Index;
      Defer_Res128 : Bare_Grammar_Null := No_Bare_Lkt_Node;
      Defer_Pos129 : Token_Index := No_Token_Index;
      Defer_Res129 : Bare_Token_Ref := No_Bare_Lkt_Node;
      Defer_Pos130 : Token_Index := No_Token_Index;
      Defer_Res130 : Bare_Grammar_Stop_Cut := No_Bare_Lkt_Node;
      Defer_Pos131 : Token_Index := No_Token_Index;
      Defer_Res131 : Bare_Parse_Node_Expr := No_Bare_Lkt_Node;
      Defer_Pos132 : Token_Index := No_Token_Index;
      Defer_Res132 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Defer_Pos133 : Token_Index := No_Token_Index;
      Defer_Res133 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Defer_Pos134 : Token_Index := No_Token_Index;
      Defer_Res134 : Bare_Grammar_Or_Expr := No_Bare_Lkt_Node;
      Defer_Pos135 : Token_Index := No_Token_Index;
      Defer_Res135 : Bare_Grammar_Rule_Ref := No_Bare_Lkt_Node;
      Defer_Pos136 : Token_Index := No_Token_Index;
      Defer_Res136 : Bare_Grammar_Discard := No_Bare_Lkt_Node;
      Row_Pos109 : Token_Index := No_Token_Index;
      Transform_Res80 : Bare_Error_Grammar_Expr := No_Bare_Lkt_Node;
      Skip_Pos2 : Token_Index := No_Token_Index;
      Skip_Dummy2 : Bare_Lkt_Node := No_Bare_Lkt_Node;
      Or_Pos23 : Token_Index := No_Token_Index;
      Or_Res23 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Diag_Mark56 : Diagnostic_Mark;
      Last_Fail23 : Fail_Info;
      Branch_Diag_Mark23 : Diagnostic_Mark;
      Branch_Last_Fail23 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Grammar_Primary_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res23 := M.Instance;
      return Or_Res23;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res23;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'grammar_primary') at parser.lkt:64:24>
--  pos=Or_Pos23, res=Or_Res23, nobt=None
Or_Pos23 := No_Token_Index;
Or_Res23 := No_Bare_Lkt_Node;
Diag_Mark56 := Parser.Last_Diag;
Last_Fail23 := Parser.Last_Fail;
Branch_Diag_Mark23 := Parser.Last_Diag;
Branch_Last_Fail23 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark56;
    Parser.Last_Fail := Last_Fail23;
--  BEGIN <Defer (for 'grammar_pick') at parser.lkt:65:11>
--  pos=Defer_Pos121, res=Defer_Res121, nobt=None
Defer_Res121 :=
   Grammar_Pick_Transform_Parse0 (Parser, Pos);
Defer_Pos121 := Parser.Current_Pos;
--  END <Defer (for 'grammar_pick') at parser.lkt:65:11>
    if Defer_Pos121 /= No_Token_Index then
        Or_Pos23 := Defer_Pos121;
        Or_Res23 := Defer_Res121;
        goto Exit_Or25;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail23.Pos then
       Branch_Diag_Mark23 := Parser.Last_Diag;
       Branch_Last_Fail23 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark56;
    Parser.Last_Fail := Last_Fail23;
--  BEGIN <Defer (for 'grammar_list_expr') at parser.lkt:66:11>
--  pos=Defer_Pos122, res=Defer_Res122, nobt=None
Defer_Res122 :=
   Grammar_List_Expr_Transform_Parse3 (Parser, Pos);
Defer_Pos122 := Parser.Current_Pos;
--  END <Defer (for 'grammar_list_expr') at parser.lkt:66:11>
    if Defer_Pos122 /= No_Token_Index then
        Or_Pos23 := Defer_Pos122;
        Or_Res23 := Defer_Res122;
        goto Exit_Or25;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail23.Pos then
       Branch_Diag_Mark23 := Parser.Last_Diag;
       Branch_Last_Fail23 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark56;
    Parser.Last_Fail := Last_Fail23;
--  BEGIN <Defer (for 'token_literal') at parser.lkt:67:11>
--  pos=Defer_Pos123, res=Defer_Res123, nobt=None
Defer_Res123 :=
   Token_Literal_Transform_Parse0 (Parser, Pos);
Defer_Pos123 := Parser.Current_Pos;
--  END <Defer (for 'token_literal') at parser.lkt:67:11>
    if Defer_Pos123 /= No_Token_Index then
        Or_Pos23 := Defer_Pos123;
        Or_Res23 := Defer_Res123;
        goto Exit_Or25;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail23.Pos then
       Branch_Diag_Mark23 := Parser.Last_Diag;
       Branch_Last_Fail23 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark56;
    Parser.Last_Fail := Last_Fail23;
--  BEGIN <Defer (for 'token_no_case_literal') at parser.lkt:68:11>
--  pos=Defer_Pos124, res=Defer_Res124, nobt=None
Defer_Res124 :=
   Token_No_Case_Literal_Transform_Parse0 (Parser, Pos);
Defer_Pos124 := Parser.Current_Pos;
--  END <Defer (for 'token_no_case_literal') at parser.lkt:68:11>
    if Defer_Pos124 /= No_Token_Index then
        Or_Pos23 := Defer_Pos124;
        Or_Res23 := Defer_Res124;
        goto Exit_Or25;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail23.Pos then
       Branch_Diag_Mark23 := Parser.Last_Diag;
       Branch_Last_Fail23 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark56;
    Parser.Last_Fail := Last_Fail23;
--  BEGIN <Defer (for 'token_pattern') at parser.lkt:69:11>
--  pos=Defer_Pos125, res=Defer_Res125, nobt=None
Defer_Res125 :=
   Token_Pattern_Or_Parse0 (Parser, Pos);
Defer_Pos125 := Parser.Current_Pos;
--  END <Defer (for 'token_pattern') at parser.lkt:69:11>
    if Defer_Pos125 /= No_Token_Index then
        Or_Pos23 := Defer_Pos125;
        Or_Res23 := Defer_Res125;
        goto Exit_Or25;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail23.Pos then
       Branch_Diag_Mark23 := Parser.Last_Diag;
       Branch_Last_Fail23 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark56;
    Parser.Last_Fail := Last_Fail23;
--  BEGIN <Defer (for 'grammar_cut') at parser.lkt:70:11>
--  pos=Defer_Pos126, res=Defer_Res126, nobt=None
Defer_Res126 :=
   Grammar_Cut_Transform_Parse0 (Parser, Pos);
Defer_Pos126 := Parser.Current_Pos;
--  END <Defer (for 'grammar_cut') at parser.lkt:70:11>
    if Defer_Pos126 /= No_Token_Index then
        Or_Pos23 := Defer_Pos126;
        Or_Res23 := Defer_Res126;
        goto Exit_Or25;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail23.Pos then
       Branch_Diag_Mark23 := Parser.Last_Diag;
       Branch_Last_Fail23 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark56;
    Parser.Last_Fail := Last_Fail23;
--  BEGIN <Defer (for 'grammar_skip') at parser.lkt:71:11>
--  pos=Defer_Pos127, res=Defer_Res127, nobt=None
Defer_Res127 :=
   Grammar_Skip_Transform_Parse0 (Parser, Pos);
Defer_Pos127 := Parser.Current_Pos;
--  END <Defer (for 'grammar_skip') at parser.lkt:71:11>
    if Defer_Pos127 /= No_Token_Index then
        Or_Pos23 := Defer_Pos127;
        Or_Res23 := Defer_Res127;
        goto Exit_Or25;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail23.Pos then
       Branch_Diag_Mark23 := Parser.Last_Diag;
       Branch_Last_Fail23 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark56;
    Parser.Last_Fail := Last_Fail23;
--  BEGIN <Defer (for 'grammar_null') at parser.lkt:72:11>
--  pos=Defer_Pos128, res=Defer_Res128, nobt=None
Defer_Res128 :=
   Grammar_Null_Transform_Parse0 (Parser, Pos);
Defer_Pos128 := Parser.Current_Pos;
--  END <Defer (for 'grammar_null') at parser.lkt:72:11>
    if Defer_Pos128 /= No_Token_Index then
        Or_Pos23 := Defer_Pos128;
        Or_Res23 := Defer_Res128;
        goto Exit_Or25;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail23.Pos then
       Branch_Diag_Mark23 := Parser.Last_Diag;
       Branch_Last_Fail23 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark56;
    Parser.Last_Fail := Last_Fail23;
--  BEGIN <Defer (for 'grammar_token') at parser.lkt:73:11>
--  pos=Defer_Pos129, res=Defer_Res129, nobt=None
Defer_Res129 :=
   Grammar_Token_Transform_Parse0 (Parser, Pos);
Defer_Pos129 := Parser.Current_Pos;
--  END <Defer (for 'grammar_token') at parser.lkt:73:11>
    if Defer_Pos129 /= No_Token_Index then
        Or_Pos23 := Defer_Pos129;
        Or_Res23 := Defer_Res129;
        goto Exit_Or25;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail23.Pos then
       Branch_Diag_Mark23 := Parser.Last_Diag;
       Branch_Last_Fail23 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark56;
    Parser.Last_Fail := Last_Fail23;
--  BEGIN <Defer (for 'grammar_stopcut') at parser.lkt:74:11>
--  pos=Defer_Pos130, res=Defer_Res130, nobt=None
Defer_Res130 :=
   Grammar_Stopcut_Transform_Parse0 (Parser, Pos);
Defer_Pos130 := Parser.Current_Pos;
--  END <Defer (for 'grammar_stopcut') at parser.lkt:74:11>
    if Defer_Pos130 /= No_Token_Index then
        Or_Pos23 := Defer_Pos130;
        Or_Res23 := Defer_Res130;
        goto Exit_Or25;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail23.Pos then
       Branch_Diag_Mark23 := Parser.Last_Diag;
       Branch_Last_Fail23 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark56;
    Parser.Last_Fail := Last_Fail23;
--  BEGIN <Defer (for 'parse_node_expr') at parser.lkt:75:11>
--  pos=Defer_Pos131, res=Defer_Res131, nobt=None
Defer_Res131 :=
   Parse_Node_Expr_Transform_Parse0 (Parser, Pos);
Defer_Pos131 := Parser.Current_Pos;
--  END <Defer (for 'parse_node_expr') at parser.lkt:75:11>
    if Defer_Pos131 /= No_Token_Index then
        Or_Pos23 := Defer_Pos131;
        Or_Res23 := Defer_Res131;
        goto Exit_Or25;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail23.Pos then
       Branch_Diag_Mark23 := Parser.Last_Diag;
       Branch_Last_Fail23 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark56;
    Parser.Last_Fail := Last_Fail23;
--  BEGIN <Defer (for 'grammar_opt') at parser.lkt:76:11>
--  pos=Defer_Pos132, res=Defer_Res132, nobt=None
Defer_Res132 :=
   Grammar_Opt_Or_Parse0 (Parser, Pos);
Defer_Pos132 := Parser.Current_Pos;
--  END <Defer (for 'grammar_opt') at parser.lkt:76:11>
    if Defer_Pos132 /= No_Token_Index then
        Or_Pos23 := Defer_Pos132;
        Or_Res23 := Defer_Res132;
        goto Exit_Or25;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail23.Pos then
       Branch_Diag_Mark23 := Parser.Last_Diag;
       Branch_Last_Fail23 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark56;
    Parser.Last_Fail := Last_Fail23;
--  BEGIN <Defer (for 'grammar_opt_error') at parser.lkt:77:11>
--  pos=Defer_Pos133, res=Defer_Res133, nobt=None
Defer_Res133 :=
   Grammar_Opt_Error_Or_Parse0 (Parser, Pos);
Defer_Pos133 := Parser.Current_Pos;
--  END <Defer (for 'grammar_opt_error') at parser.lkt:77:11>
    if Defer_Pos133 /= No_Token_Index then
        Or_Pos23 := Defer_Pos133;
        Or_Res23 := Defer_Res133;
        goto Exit_Or25;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail23.Pos then
       Branch_Diag_Mark23 := Parser.Last_Diag;
       Branch_Last_Fail23 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark56;
    Parser.Last_Fail := Last_Fail23;
--  BEGIN <Defer (for 'grammar_or_expr') at parser.lkt:78:11>
--  pos=Defer_Pos134, res=Defer_Res134, nobt=None
Defer_Res134 :=
   Grammar_Or_Expr_Transform_Parse0 (Parser, Pos);
Defer_Pos134 := Parser.Current_Pos;
--  END <Defer (for 'grammar_or_expr') at parser.lkt:78:11>
    if Defer_Pos134 /= No_Token_Index then
        Or_Pos23 := Defer_Pos134;
        Or_Res23 := Defer_Res134;
        goto Exit_Or25;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail23.Pos then
       Branch_Diag_Mark23 := Parser.Last_Diag;
       Branch_Last_Fail23 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark56;
    Parser.Last_Fail := Last_Fail23;
--  BEGIN <Defer (for 'grammar_rule_ref') at parser.lkt:79:11>
--  pos=Defer_Pos135, res=Defer_Res135, nobt=None
Defer_Res135 :=
   Grammar_Rule_Ref_Transform_Parse0 (Parser, Pos);
Defer_Pos135 := Parser.Current_Pos;
--  END <Defer (for 'grammar_rule_ref') at parser.lkt:79:11>
    if Defer_Pos135 /= No_Token_Index then
        Or_Pos23 := Defer_Pos135;
        Or_Res23 := Defer_Res135;
        goto Exit_Or25;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail23.Pos then
       Branch_Diag_Mark23 := Parser.Last_Diag;
       Branch_Last_Fail23 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark56;
    Parser.Last_Fail := Last_Fail23;
--  BEGIN <Defer (for 'grammar_discard_expr') at parser.lkt:80:11>
--  pos=Defer_Pos136, res=Defer_Res136, nobt=None
Defer_Res136 :=
   Grammar_Discard_Expr_Transform_Parse0 (Parser, Pos);
Defer_Pos136 := Parser.Current_Pos;
--  END <Defer (for 'grammar_discard_expr') at parser.lkt:80:11>
    if Defer_Pos136 /= No_Token_Index then
        Or_Pos23 := Defer_Pos136;
        Or_Res23 := Defer_Res136;
        goto Exit_Or25;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail23.Pos then
       Branch_Diag_Mark23 := Parser.Last_Diag;
       Branch_Last_Fail23 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark56;
    Parser.Last_Fail := Last_Fail23;
--  BEGIN <Skip (root of 'grammar_primary') at parser.lkt:81:11>
--  pos=Skip_Pos2, res=Transform_Res80, nobt=None
if Get_Token (Parser.TDH.all, Pos).Kind
   = From_Token_Kind (Lkt_Termination)
then
   Skip_Pos2 := No_Token_Index;
   goto Exit_Or26;
end if;
for Fn of PP.Dont_Skip loop
   Skip_Dummy2 := Fn (Parser, Pos);
   if Parser.Current_Pos /= No_Token_Index  then
      Skip_Pos2 := No_Token_Index;
      goto Exit_Or26;
   end if;
end loop;
Skip_Pos2 := Pos + 1;
--  BEGIN <Transform(<ASTNodeType ErrorGrammarExpr>) (root of 'grammar_primary') at parser.lkt:81:11>
--  pos=Row_Pos109, res=Transform_Res80, nobt=None
--  BEGIN <_Row (root of 'grammar_primary') at parser.lkt:81:11>
--  pos=Row_Pos109, res=None, nobt=None
Row_Pos109 := Pos;
pragma Warnings (Off, "referenced");
<<Exit_Row109_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_primary') at parser.lkt:81:11>
if Row_Pos109 /= No_Token_Index then
   Transform_Res80 := Allocate_Error_Grammar_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res80,
      Kind => Lkt_Error_Grammar_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos109 = Pos
                            then No_Token_Index
                            else Row_Pos109 - 1));
      Initialize_Fields_For_Error_Grammar_Expr
        (Self => Transform_Res80);
end if;
--  END <Transform(<ASTNodeType ErrorGrammarExpr>) (root of 'grammar_primary') at parser.lkt:81:11>
Transform_Res80.Token_End_Index := Pos;
declare
   Tok      : constant Token_Reference :=
     Wrap_Token_Reference
      (Parser.Unit.Context,
       Parser.TDH,
       (Pos, No_Token_Index));
   Tok_Text : constant Text_Type := Common.Text (Tok);
begin
   Append (Parser, Pos, "Skipped token " & Image (Tok_Text));
end;
<<Exit_Or26>>
--  END <Skip (root of 'grammar_primary') at parser.lkt:81:11>
    if Skip_Pos2 /= No_Token_Index then
        Or_Pos23 := Skip_Pos2;
        Or_Res23 := Transform_Res80;
        goto Exit_Or25;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail23.Pos then
       Branch_Diag_Mark23 := Parser.Last_Diag;
       Branch_Last_Fail23 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark23;
Parser.Last_Fail := Branch_Last_Fail23;
<<Exit_Or25>>
--  END <Or (root of 'grammar_primary') at parser.lkt:64:24>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos23 = No_Token_Index then
      Set_Failure
        (PP.Grammar_Primary_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Grammar_Primary_Or_Parse0_Memo, Pos, Or_Res23, Parser.Last_Diag, Or_Pos23);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos23;
   return Or_Res23;
end Grammar_Primary_Or_Parse0;
   function Grammar_Rule_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Rule_Decl
is
      Row_Pos110 : Token_Index := No_Token_Index;
      Defer_Pos137 : Token_Index := No_Token_Index;
      Defer_Res137 : Bare_Def_Id := No_Bare_Lkt_Node;
      Token_Pos144 : Token_Index := No_Token_Index;
      Token_Res144 : Token_Index := No_Token_Index;
      Defer_Pos138 : Token_Index := No_Token_Index;
      Defer_Res138 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Transform_Res81 : Bare_Grammar_Rule_Decl := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Grammar_Rule_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res81 := M.Instance;
      return Transform_Res81;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res81;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType GrammarRuleDecl>) (root of 'grammar_rule') at parser.lkt:44:21>
--  pos=Row_Pos110, res=Transform_Res81, nobt=None
--  BEGIN <_Row (root of 'grammar_rule') at parser.lkt:44:21>
--  pos=Row_Pos110, res=None, nobt=None
Row_Pos110 := Pos;
--  BEGIN <Defer (for 'def_id') at parser.lkt:44:37>
--  pos=Defer_Pos137, res=Defer_Res137, nobt=None
Defer_Res137 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos110);
Defer_Pos137 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:44:37>
if Defer_Pos137 /= No_Token_Index then
   Row_Pos110 := Defer_Pos137;
else
   Row_Pos110 := No_Token_Index;
   goto Exit_Row110_0;
end if;
--  BEGIN <Token(<WithText LeftArrow>, ) (root of 'grammar_rule') at parser.lkt:44:44>
--  pos=Token_Pos144, res=Token_Res144, nobt=None
Token_Res144 := Row_Pos110;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res144));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Left_Arrow)
   then
       Token_Pos144 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos110 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos110,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Left_Arrow,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos144 := Row_Pos110 + 1;
   end if;
end;
--  END <Token(<WithText LeftArrow>, ) (root of 'grammar_rule') at parser.lkt:44:44>
if Token_Pos144 /= No_Token_Index then
   Row_Pos110 := Token_Pos144;
else
   Row_Pos110 := No_Token_Index;
   goto Exit_Row110_0;
end if;
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:44:49>
--  pos=Defer_Pos138, res=Defer_Res138, nobt=None
Defer_Res138 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos110);
Defer_Pos138 := Parser.Current_Pos;
--  END <Defer (for 'grammar_expr') at parser.lkt:44:49>
if Defer_Pos138 /= No_Token_Index then
   Row_Pos110 := Defer_Pos138;
else
   Row_Pos110 := No_Token_Index;
   goto Exit_Row110_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row110_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_rule') at parser.lkt:44:21>
if Row_Pos110 /= No_Token_Index then
   Transform_Res81 := Allocate_Grammar_Rule_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res81,
      Kind => Lkt_Grammar_Rule_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos110 = Pos
                            then No_Token_Index
                            else Row_Pos110 - 1));
      Initialize_Fields_For_Grammar_Rule_Decl
        (Self => Transform_Res81,
         Grammar_Rule_Decl_F_Syn_Name => Defer_Res137,
         Grammar_Rule_Decl_F_Expr => Defer_Res138);
         if Defer_Res137 /= null and then Is_Incomplete (Defer_Res137) then
            Transform_Res81.Last_Attempted_Child := 0;
         elsif Defer_Res137 /= null and then not Is_Ghost (Defer_Res137) then
            Transform_Res81.Last_Attempted_Child := -1;
         end if;
         if Defer_Res138 /= null and then Is_Incomplete (Defer_Res138) then
            Transform_Res81.Last_Attempted_Child := 0;
         elsif Defer_Res138 /= null and then not Is_Ghost (Defer_Res138) then
            Transform_Res81.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType GrammarRuleDecl>) (root of 'grammar_rule') at parser.lkt:44:21>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos110 = No_Token_Index then
      Set_Failure
        (PP.Grammar_Rule_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Grammar_Rule_Transform_Parse0_Memo, Pos, Transform_Res81, Parser.Last_Diag, Row_Pos110);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos110;
   return Transform_Res81;
end Grammar_Rule_Transform_Parse0;
   function Grammar_Rule_Ref_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Rule_Ref
is
      Row_Pos111 : Token_Index := No_Token_Index;
      Defer_Pos139 : Token_Index := No_Token_Index;
      Defer_Res139 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Transform_Res82 : Bare_Grammar_Rule_Ref := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Grammar_Rule_Ref_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res82 := M.Instance;
      return Transform_Res82;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res82;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType GrammarRuleRef>) (root of 'grammar_rule_ref') at parser.lkt:135:25>
--  pos=Row_Pos111, res=Transform_Res82, nobt=None
--  BEGIN <_Row (root of 'grammar_rule_ref') at parser.lkt:135:25>
--  pos=Row_Pos111, res=None, nobt=None
Row_Pos111 := Pos;
--  BEGIN <Defer (for 'ref_id') at parser.lkt:135:40>
--  pos=Defer_Pos139, res=Defer_Res139, nobt=None
Defer_Res139 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos111);
Defer_Pos139 := Parser.Current_Pos;
--  END <Defer (for 'ref_id') at parser.lkt:135:40>
if Defer_Pos139 /= No_Token_Index then
   Row_Pos111 := Defer_Pos139;
else
   Row_Pos111 := No_Token_Index;
   goto Exit_Row111_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row111_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_rule_ref') at parser.lkt:135:25>
if Row_Pos111 /= No_Token_Index then
   Transform_Res82 := Allocate_Grammar_Rule_Ref (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res82,
      Kind => Lkt_Grammar_Rule_Ref,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos111 = Pos
                            then No_Token_Index
                            else Row_Pos111 - 1));
      Initialize_Fields_For_Grammar_Rule_Ref
        (Self => Transform_Res82,
         Grammar_Rule_Ref_F_Node_Name => Defer_Res139);
         if Defer_Res139 /= null and then Is_Incomplete (Defer_Res139) then
            Transform_Res82.Last_Attempted_Child := 0;
         elsif Defer_Res139 /= null and then not Is_Ghost (Defer_Res139) then
            Transform_Res82.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType GrammarRuleRef>) (root of 'grammar_rule_ref') at parser.lkt:135:25>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos111 = No_Token_Index then
      Set_Failure
        (PP.Grammar_Rule_Ref_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Grammar_Rule_Ref_Transform_Parse0_Memo, Pos, Transform_Res82, Parser.Last_Diag, Row_Pos111);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos111;
   return Transform_Res82;
end Grammar_Rule_Ref_Transform_Parse0;
   function Grammar_Skip_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Skip
is
      Row_Pos112 : Token_Index := No_Token_Index;
      Token_Pos145 : Token_Index := No_Token_Index;
      Token_Res145 : Token_Index := No_Token_Index;
      Token_Pos146 : Token_Index := No_Token_Index;
      Token_Res146 : Token_Index := No_Token_Index;
      Defer_Pos140 : Token_Index := No_Token_Index;
      Defer_Res140 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Token_Pos147 : Token_Index := No_Token_Index;
      Token_Res147 : Token_Index := No_Token_Index;
      Transform_Res83 : Bare_Grammar_Skip := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Grammar_Skip_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res83 := M.Instance;
      return Transform_Res83;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res83;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType GrammarSkip>) (root of 'grammar_skip') at parser.lkt:152:21>
--  pos=Row_Pos112, res=Transform_Res83, nobt=None
--  BEGIN <_Row (root of 'grammar_skip') at parser.lkt:152:21>
--  pos=Row_Pos112, res=None, nobt=None
Row_Pos112 := Pos;
--  BEGIN <Token(<WithSymbol Identifier>, skip) (root of 'grammar_skip') at parser.lkt:152:33>
--  pos=Token_Pos145, res=Token_Res145, nobt=None
Token_Res145 := Row_Pos112;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res145));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Skip)
   then
       Token_Pos145 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos112 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos112,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos145 := Row_Pos112 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, skip) (root of 'grammar_skip') at parser.lkt:152:33>
if Token_Pos145 /= No_Token_Index then
   Row_Pos112 := Token_Pos145;
else
   Row_Pos112 := No_Token_Index;
   goto Exit_Row112_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_skip') at parser.lkt:152:53>
--  pos=Token_Pos146, res=Token_Res146, nobt=None
Token_Res146 := Row_Pos112;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res146));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos146 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos112 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos112,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos146 := Row_Pos112 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'grammar_skip') at parser.lkt:152:53>
if Token_Pos146 /= No_Token_Index then
   Row_Pos112 := Token_Pos146;
else
   Row_Pos112 := No_Token_Index;
   goto Exit_Row112_0;
end if;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:152:57>
--  pos=Defer_Pos140, res=Defer_Res140, nobt=None
Defer_Res140 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos112);
Defer_Pos140 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:152:57>
if Defer_Pos140 /= No_Token_Index then
   Row_Pos112 := Defer_Pos140;
else
   Row_Pos112 := No_Token_Index;
   goto Exit_Row112_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_skip') at parser.lkt:152:66>
--  pos=Token_Pos147, res=Token_Res147, nobt=None
Token_Res147 := Row_Pos112;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res147));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos147 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos112 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos112,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos147 := Row_Pos112 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'grammar_skip') at parser.lkt:152:66>
if Token_Pos147 /= No_Token_Index then
   Row_Pos112 := Token_Pos147;
else
   Row_Pos112 := No_Token_Index;
   goto Exit_Row112_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row112_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_skip') at parser.lkt:152:21>
if Row_Pos112 /= No_Token_Index then
   Transform_Res83 := Allocate_Grammar_Skip (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res83,
      Kind => Lkt_Grammar_Skip,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos112 = Pos
                            then No_Token_Index
                            else Row_Pos112 - 1));
      Initialize_Fields_For_Grammar_Skip
        (Self => Transform_Res83,
         Grammar_Skip_F_Name => Defer_Res140);
         if Defer_Res140 /= null and then Is_Incomplete (Defer_Res140) then
            Transform_Res83.Last_Attempted_Child := 0;
         elsif Defer_Res140 /= null and then not Is_Ghost (Defer_Res140) then
            Transform_Res83.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType GrammarSkip>) (root of 'grammar_skip') at parser.lkt:152:21>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos112 = No_Token_Index then
      Set_Failure
        (PP.Grammar_Skip_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Grammar_Skip_Transform_Parse0_Memo, Pos, Transform_Res83, Parser.Last_Diag, Row_Pos112);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos112;
   return Transform_Res83;
end Grammar_Skip_Transform_Parse0;
   function Grammar_Stopcut_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Stop_Cut
is
      Row_Pos113 : Token_Index := No_Token_Index;
      Token_Pos148 : Token_Index := No_Token_Index;
      Token_Res148 : Token_Index := No_Token_Index;
      Token_Pos149 : Token_Index := No_Token_Index;
      Token_Res149 : Token_Index := No_Token_Index;
      Defer_Pos141 : Token_Index := No_Token_Index;
      Defer_Res141 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Token_Pos150 : Token_Index := No_Token_Index;
      Token_Res150 : Token_Index := No_Token_Index;
      Transform_Res84 : Bare_Grammar_Stop_Cut := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Grammar_Stopcut_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res84 := M.Instance;
      return Transform_Res84;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res84;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType GrammarStopCut>) (root of 'grammar_stopcut') at parser.lkt:107:24>
--  pos=Row_Pos113, res=Transform_Res84, nobt=None
--  BEGIN <_Row (root of 'grammar_stopcut') at parser.lkt:107:24>
--  pos=Row_Pos113, res=None, nobt=None
Row_Pos113 := Pos;
--  BEGIN <Token(<WithSymbol Identifier>, stop_cut) (root of 'grammar_stopcut') at parser.lkt:108:9>
--  pos=Token_Pos148, res=Token_Res148, nobt=None
Token_Res148 := Row_Pos113;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res148));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Stop_Cut)
   then
       Token_Pos148 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos113 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos113,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos148 := Row_Pos113 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, stop_cut) (root of 'grammar_stopcut') at parser.lkt:108:9>
if Token_Pos148 /= No_Token_Index then
   Row_Pos113 := Token_Pos148;
else
   Row_Pos113 := No_Token_Index;
   goto Exit_Row113_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_stopcut') at parser.lkt:108:33>
--  pos=Token_Pos149, res=Token_Res149, nobt=None
Token_Res149 := Row_Pos113;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res149));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos149 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos113 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos113,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos149 := Row_Pos113 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'grammar_stopcut') at parser.lkt:108:33>
if Token_Pos149 /= No_Token_Index then
   Row_Pos113 := Token_Pos149;
else
   Row_Pos113 := No_Token_Index;
   goto Exit_Row113_0;
end if;
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:108:37>
--  pos=Defer_Pos141, res=Defer_Res141, nobt=None
Defer_Res141 :=
   Grammar_Expr_Or_Parse0 (Parser, Row_Pos113);
Defer_Pos141 := Parser.Current_Pos;
--  END <Defer (for 'grammar_expr') at parser.lkt:108:37>
if Defer_Pos141 /= No_Token_Index then
   Row_Pos113 := Defer_Pos141;
else
   Row_Pos113 := No_Token_Index;
   goto Exit_Row113_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_stopcut') at parser.lkt:108:50>
--  pos=Token_Pos150, res=Token_Res150, nobt=None
Token_Res150 := Row_Pos113;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res150));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos150 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos113 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos113,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos150 := Row_Pos113 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'grammar_stopcut') at parser.lkt:108:50>
if Token_Pos150 /= No_Token_Index then
   Row_Pos113 := Token_Pos150;
else
   Row_Pos113 := No_Token_Index;
   goto Exit_Row113_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row113_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_stopcut') at parser.lkt:107:24>
if Row_Pos113 /= No_Token_Index then
   Transform_Res84 := Allocate_Grammar_Stop_Cut (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res84,
      Kind => Lkt_Grammar_Stop_Cut,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos113 = Pos
                            then No_Token_Index
                            else Row_Pos113 - 1));
      Initialize_Fields_For_Grammar_Stop_Cut
        (Self => Transform_Res84,
         Grammar_Stop_Cut_F_Expr => Defer_Res141);
         if Defer_Res141 /= null and then Is_Incomplete (Defer_Res141) then
            Transform_Res84.Last_Attempted_Child := 0;
         elsif Defer_Res141 /= null and then not Is_Ghost (Defer_Res141) then
            Transform_Res84.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType GrammarStopCut>) (root of 'grammar_stopcut') at parser.lkt:107:24>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos113 = No_Token_Index then
      Set_Failure
        (PP.Grammar_Stopcut_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Grammar_Stopcut_Transform_Parse0_Memo, Pos, Transform_Res84, Parser.Last_Diag, Row_Pos113);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos113;
   return Transform_Res84;
end Grammar_Stopcut_Transform_Parse0;
   function Grammar_Token_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Token_Ref
is
      Row_Pos114 : Token_Index := No_Token_Index;
      Token_Pos151 : Token_Index := No_Token_Index;
      Token_Res151 : Token_Index := No_Token_Index;
      Defer_Pos142 : Token_Index := No_Token_Index;
      Defer_Res142 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Row_Pos115 : Token_Index := No_Token_Index;
      Token_Pos152 : Token_Index := No_Token_Index;
      Token_Res152 : Token_Index := No_Token_Index;
      Defer_Pos143 : Token_Index := No_Token_Index;
      Defer_Res143 : Bare_Token_Lit := No_Bare_Lkt_Node;
      Token_Pos153 : Token_Index := No_Token_Index;
      Token_Res153 : Token_Index := No_Token_Index;
      Diag_Mark57 : Diagnostic_Mark;
      Transform_Res85 : Bare_Token_Ref := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Grammar_Token_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res85 := M.Instance;
      return Transform_Res85;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res85;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType TokenRef>) (root of 'grammar_token') at parser.lkt:154:22>
--  pos=Row_Pos114, res=Transform_Res85, nobt=None
--  BEGIN <_Row (root of 'grammar_token') at parser.lkt:154:22>
--  pos=Row_Pos114, res=None, nobt=None
Row_Pos114 := Pos;
--  BEGIN <Token(<WithText At>, ) (root of 'grammar_token') at parser.lkt:154:31>
--  pos=Token_Pos151, res=Token_Res151, nobt=None
Token_Res151 := Row_Pos114;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res151));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_At)
   then
       Token_Pos151 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos114 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos114,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_At,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos151 := Row_Pos114 + 1;
   end if;
end;
--  END <Token(<WithText At>, ) (root of 'grammar_token') at parser.lkt:154:31>
if Token_Pos151 /= No_Token_Index then
   Row_Pos114 := Token_Pos151;
else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;
end if;
--  BEGIN <Defer (for 'ref_id') at parser.lkt:154:35>
--  pos=Defer_Pos142, res=Defer_Res142, nobt=None
Defer_Res142 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos114);
Defer_Pos142 := Parser.Current_Pos;
--  END <Defer (for 'ref_id') at parser.lkt:154:35>
if Defer_Pos142 /= No_Token_Index then
   Row_Pos114 := Defer_Pos142;
else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;
end if;
--  BEGIN <Opt (root of 'grammar_token') at parser.lkt:154:42>
--  pos=Row_Pos115, res=Defer_Res143, nobt=None
Diag_Mark57 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'grammar_token') at parser.lkt:154:43>
--  pos=Row_Pos115, res=Defer_Res143, nobt=None
--  BEGIN <_Row (root of 'grammar_token') at parser.lkt:154:43>
--  pos=Row_Pos115, res=None, nobt=None
Row_Pos115 := Row_Pos114;
--  BEGIN <Token(<WithText LPar>, ) (root of 'grammar_token') at parser.lkt:154:48>
--  pos=Token_Pos152, res=Token_Res152, nobt=None
Token_Res152 := Row_Pos115;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res152));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos152 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos115 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos115,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos152 := Row_Pos115 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'grammar_token') at parser.lkt:154:48>
if Token_Pos152 /= No_Token_Index then
   Row_Pos115 := Token_Pos152;
else
   Row_Pos115 := No_Token_Index;
   goto Exit_Row115_0;
end if;
--  BEGIN <Defer (for 'token_literal') at parser.lkt:154:52>
--  pos=Defer_Pos143, res=Defer_Res143, nobt=None
Defer_Res143 :=
   Token_Literal_Transform_Parse0 (Parser, Row_Pos115);
Defer_Pos143 := Parser.Current_Pos;
--  END <Defer (for 'token_literal') at parser.lkt:154:52>
if Defer_Pos143 /= No_Token_Index then
   Row_Pos115 := Defer_Pos143;
else
   Row_Pos115 := No_Token_Index;
   goto Exit_Row115_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'grammar_token') at parser.lkt:154:66>
--  pos=Token_Pos153, res=Token_Res153, nobt=None
Token_Res153 := Row_Pos115;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res153));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos153 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos115 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos115,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos153 := Row_Pos115 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'grammar_token') at parser.lkt:154:66>
if Token_Pos153 /= No_Token_Index then
   Row_Pos115 := Token_Pos153;
else
   Row_Pos115 := No_Token_Index;
   goto Exit_Row115_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row115_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_token') at parser.lkt:154:43>
--  END <_Extract (root of 'grammar_token') at parser.lkt:154:43>
if Row_Pos115 = No_Token_Index then
   Defer_Res143 := No_Bare_Lkt_Node;
   Row_Pos115 := Row_Pos114;
      Parser.Last_Diag := Diag_Mark57;
end if;
--  END <Opt (root of 'grammar_token') at parser.lkt:154:42>
if Row_Pos115 /= No_Token_Index then
   Row_Pos114 := Row_Pos115;
else
   Row_Pos114 := No_Token_Index;
   goto Exit_Row114_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row114_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'grammar_token') at parser.lkt:154:22>
if Row_Pos114 /= No_Token_Index then
   Transform_Res85 := Allocate_Token_Ref (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res85,
      Kind => Lkt_Token_Ref,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos114 = Pos
                            then No_Token_Index
                            else Row_Pos114 - 1));
      Initialize_Fields_For_Token_Ref
        (Self => Transform_Res85,
         Token_Ref_F_Token_Name => Defer_Res142,
         Token_Ref_F_Expr => Defer_Res143);
         if Defer_Res142 /= null and then Is_Incomplete (Defer_Res142) then
            Transform_Res85.Last_Attempted_Child := 0;
         elsif Defer_Res142 /= null and then not Is_Ghost (Defer_Res142) then
            Transform_Res85.Last_Attempted_Child := -1;
         end if;
         if Defer_Res143 /= null and then Is_Incomplete (Defer_Res143) then
            Transform_Res85.Last_Attempted_Child := 0;
         elsif Defer_Res143 /= null and then not Is_Ghost (Defer_Res143) then
            Transform_Res85.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType TokenRef>) (root of 'grammar_token') at parser.lkt:154:22>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos114 = No_Token_Index then
      Set_Failure
        (PP.Grammar_Token_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Grammar_Token_Transform_Parse0_Memo, Pos, Transform_Res85, Parser.Last_Diag, Row_Pos114);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos114;
   return Transform_Res85;
end Grammar_Token_Transform_Parse0;
   function Id_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Id
is
      Row_Pos116 : Token_Index := No_Token_Index;
      Token_Pos154 : Token_Index := No_Token_Index;
      Token_Res154 : Token_Index := No_Token_Index;
      Transform_Res86 : Bare_Id := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Id_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res86 := M.Instance;
      return Transform_Res86;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res86;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType Id>) (root of 'id') at parser.lkt:9:11>
--  pos=Row_Pos116, res=Transform_Res86, nobt=None
--  BEGIN <_Row (root of 'id') at parser.lkt:9:11>
--  pos=Row_Pos116, res=None, nobt=None
Row_Pos116 := Pos;
--  BEGIN <Token(<WithSymbol Identifier>, ) (root of 'id') at parser.lkt:9:14>
--  pos=Token_Pos154, res=Token_Res154, nobt=None
Token_Res154 := Row_Pos116;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res154));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
   then
       Token_Pos154 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos116 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos116,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos154 := Row_Pos116 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, ) (root of 'id') at parser.lkt:9:14>
if Token_Pos154 /= No_Token_Index then
   Row_Pos116 := Token_Pos154;
else
   Row_Pos116 := No_Token_Index;
   goto Exit_Row116_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row116_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'id') at parser.lkt:9:11>
if Row_Pos116 /= No_Token_Index then
   Transform_Res86 := Allocate_Id (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res86,
      Kind => Lkt_Id,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos116 = Pos
                            then No_Token_Index
                            else Row_Pos116 - 1));
      Initialize_Fields_For_Id
        (Self => Transform_Res86);
end if;
--  END <Transform(<ASTNodeType Id>) (root of 'id') at parser.lkt:9:11>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos116 = No_Token_Index then
      Set_Failure
        (PP.Id_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Id_Transform_Parse0_Memo, Pos, Transform_Res86, Parser.Last_Diag, Row_Pos116);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos116;
   return Transform_Res86;
end Id_Transform_Parse0;
   function If_Expr_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_If_Expr
is
      Nobt19 : Boolean := False;
      Nobt20 : Boolean := False;
      Row_Pos117 : Token_Index := No_Token_Index;
      Token_Pos155 : Token_Index := No_Token_Index;
      Token_Res155 : Token_Index := No_Token_Index;
      Defer_Pos144 : Token_Index := No_Token_Index;
      Defer_Res144 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos156 : Token_Index := No_Token_Index;
      Token_Res156 : Token_Index := No_Token_Index;
      Defer_Pos145 : Token_Index := No_Token_Index;
      Defer_Res145 : Bare_Expr := No_Bare_Lkt_Node;
      Lst_Cpos18 : Token_Index := No_Token_Index;
      Tmp_List18 : Free_Parse_List;
      Row_Pos118 : Token_Index := No_Token_Index;
      Token_Pos157 : Token_Index := No_Token_Index;
      Token_Res157 : Token_Index := No_Token_Index;
      Defer_Pos146 : Token_Index := No_Token_Index;
      Defer_Res146 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos158 : Token_Index := No_Token_Index;
      Token_Res158 : Token_Index := No_Token_Index;
      Defer_Pos147 : Token_Index := No_Token_Index;
      Defer_Res147 : Bare_Expr := No_Bare_Lkt_Node;
      Row_Progress19 : Integer := 0;
      Transform_Res87 : Bare_Elsif_Branch := No_Bare_Lkt_Node;
      Transform_Has_Failed19 : Boolean := False;
      List_Pos18 : Token_Index := No_Token_Index;
      List_Res18 : Bare_Elsif_Branch_List := No_Bare_Lkt_Node;
      Diag_Mark58 : Diagnostic_Mark;
      Token_Pos159 : Token_Index := No_Token_Index;
      Token_Res159 : Token_Index := No_Token_Index;
      Defer_Pos148 : Token_Index := No_Token_Index;
      Defer_Res148 : Bare_Expr := No_Bare_Lkt_Node;
      Row_Progress20 : Integer := 0;
      Transform_Res88 : Bare_If_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed20 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.If_Expr_Transform_Parse1_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res88 := M.Instance;
      return Transform_Res88;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res88;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType IfExpr>) (root of 'if_expr') at parser.lkt:439:16>
--  pos=Row_Pos117, res=Transform_Res88, nobt=Nobt19
--  BEGIN <_Row (root of 'if_expr') at parser.lkt:439:16>
--  pos=Row_Pos117, res=None, nobt=Nobt19
Row_Pos117 := Pos;
--  BEGIN <Token(<WithText IfKw>, ) (root of 'if_expr') at parser.lkt:440:9>
--  pos=Token_Pos155, res=Token_Res155, nobt=None
Token_Res155 := Row_Pos117;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res155));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_If_Kw)
   then
       Token_Pos155 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos117 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos117,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_If_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos155 := Row_Pos117 + 1;
   end if;
end;
--  END <Token(<WithText IfKw>, ) (root of 'if_expr') at parser.lkt:440:9>
Row_Progress20 := 1;
if Token_Pos155 /= No_Token_Index then
   Row_Pos117 := Token_Pos155;
else
   Row_Pos117 := No_Token_Index;
   goto Exit_Row117_0;
end if;
--  BEGIN <Cut (root of 'if_expr') at parser.lkt:441:9>
--  pos=Row_Pos117, res=None, nobt=Nobt19
Nobt19 := True;
--  END <Cut (root of 'if_expr') at parser.lkt:441:9>
Row_Progress20 := 2;
if Row_Pos117 /= No_Token_Index then
   Row_Pos117 := Row_Pos117;
else
   Row_Pos117 := No_Token_Index;
   goto Exit_Row117_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:442:9>
--  pos=Defer_Pos144, res=Defer_Res144, nobt=None
Defer_Res144 :=
   Expr_Or_Parse0 (Parser, Row_Pos117);
Defer_Pos144 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:442:9>
Row_Progress20 := 3;
if Defer_Pos144 /= No_Token_Index then
   Row_Pos117 := Defer_Pos144;
else
   Row_Pos117 := No_Token_Index;
   goto Exit_Row117_0;
end if;
--  BEGIN <Token(<WithText ThenKw>, ) (root of 'if_expr') at parser.lkt:443:9>
--  pos=Token_Pos156, res=Token_Res156, nobt=None
Token_Res156 := Row_Pos117;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res156));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Then_Kw)
   then
       Token_Pos156 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos117 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos117,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Then_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos156 := Row_Pos117 + 1;
   end if;
end;
--  END <Token(<WithText ThenKw>, ) (root of 'if_expr') at parser.lkt:443:9>
Row_Progress20 := 4;
if Token_Pos156 /= No_Token_Index then
   Row_Pos117 := Token_Pos156;
else
   Row_Pos117 := No_Token_Index;
   goto Exit_Row117_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:444:9>
--  pos=Defer_Pos145, res=Defer_Res145, nobt=None
Defer_Res145 :=
   Expr_Or_Parse0 (Parser, Row_Pos117);
Defer_Pos145 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:444:9>
Row_Progress20 := 5;
if Defer_Pos145 /= No_Token_Index then
   Row_Pos117 := Defer_Pos145;
else
   Row_Pos117 := No_Token_Index;
   goto Exit_Row117_0;
end if;
--  BEGIN <List (root of 'if_expr') at parser.lkt:445:9>
--  pos=List_Pos18, res=List_Res18, nobt=Nobt20
    List_Pos18 := Row_Pos117;
Lst_Cpos18 := Row_Pos117;
Tmp_List18 := Get_Parse_List (Parser);
Diag_Mark58 := Parser.Last_Diag;
loop
--  BEGIN <Transform(<ASTNodeType ElsifBranch>) (root of 'if_expr') at parser.lkt:445:15>
--  pos=Row_Pos118, res=Transform_Res87, nobt=Nobt20
--  BEGIN <_Row (root of 'if_expr') at parser.lkt:445:15>
--  pos=Row_Pos118, res=None, nobt=Nobt20
Row_Pos118 := Lst_Cpos18;
--  BEGIN <Token(<WithText ElifKw>, ) (root of 'if_expr') at parser.lkt:445:27>
--  pos=Token_Pos157, res=Token_Res157, nobt=None
Token_Res157 := Row_Pos118;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res157));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Elif_Kw)
   then
       Token_Pos157 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos118 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos118,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Elif_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos157 := Row_Pos118 + 1;
   end if;
end;
--  END <Token(<WithText ElifKw>, ) (root of 'if_expr') at parser.lkt:445:27>
Row_Progress19 := 1;
if Token_Pos157 /= No_Token_Index then
   Row_Pos118 := Token_Pos157;
else
   Row_Pos118 := No_Token_Index;
   goto Exit_Row118_0;
end if;
--  BEGIN <Cut (root of 'if_expr') at parser.lkt:445:34>
--  pos=Row_Pos118, res=None, nobt=Nobt20
Nobt20 := True;
--  END <Cut (root of 'if_expr') at parser.lkt:445:34>
Row_Progress19 := 2;
if Row_Pos118 /= No_Token_Index then
   Row_Pos118 := Row_Pos118;
else
   Row_Pos118 := No_Token_Index;
   goto Exit_Row118_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:445:36>
--  pos=Defer_Pos146, res=Defer_Res146, nobt=None
Defer_Res146 :=
   Expr_Or_Parse0 (Parser, Row_Pos118);
Defer_Pos146 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:445:36>
Row_Progress19 := 3;
if Defer_Pos146 /= No_Token_Index then
   Row_Pos118 := Defer_Pos146;
else
   Row_Pos118 := No_Token_Index;
   goto Exit_Row118_0;
end if;
--  BEGIN <Token(<WithText ThenKw>, ) (root of 'if_expr') at parser.lkt:445:41>
--  pos=Token_Pos158, res=Token_Res158, nobt=None
Token_Res158 := Row_Pos118;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res158));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Then_Kw)
   then
       Token_Pos158 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos118 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos118,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Then_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos158 := Row_Pos118 + 1;
   end if;
end;
--  END <Token(<WithText ThenKw>, ) (root of 'if_expr') at parser.lkt:445:41>
Row_Progress19 := 4;
if Token_Pos158 /= No_Token_Index then
   Row_Pos118 := Token_Pos158;
else
   Row_Pos118 := No_Token_Index;
   goto Exit_Row118_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:445:48>
--  pos=Defer_Pos147, res=Defer_Res147, nobt=None
Defer_Res147 :=
   Expr_Or_Parse0 (Parser, Row_Pos118);
Defer_Pos147 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:445:48>
Row_Progress19 := 5;
if Defer_Pos147 /= No_Token_Index then
   Row_Pos118 := Defer_Pos147;
else
   Row_Pos118 := No_Token_Index;
   goto Exit_Row118_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row118_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'if_expr') at parser.lkt:445:15>
if Row_Pos118 = No_Token_Index and then Nobt20 then
   Row_Pos118 := Parser.Last_Fail.Pos;
   Transform_Has_Failed19 := True;
end if;
if Row_Pos118 /= No_Token_Index then
   Transform_Res87 := Allocate_Elsif_Branch (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res87,
      Kind => Lkt_Elsif_Branch,
      Unit => Parser.Unit,
      Token_Start_Index => Lst_Cpos18,
      Token_End_Index   => (if Row_Pos118 = Lst_Cpos18
                            then No_Token_Index
                            else Row_Pos118 - 1));
      Initialize_Fields_For_Elsif_Branch
        (Self => Transform_Res87,
         Elsif_Branch_F_Cond_Expr => Defer_Res146,
         Elsif_Branch_F_Then_Expr => Defer_Res147);
         if Defer_Res146 /= null and then Is_Incomplete (Defer_Res146) then
            Transform_Res87.Last_Attempted_Child := 0;
         elsif Defer_Res146 /= null and then not Is_Ghost (Defer_Res146) then
            Transform_Res87.Last_Attempted_Child := -1;
         end if;
         if Defer_Res147 /= null and then Is_Incomplete (Defer_Res147) then
            Transform_Res87.Last_Attempted_Child := 0;
         elsif Defer_Res147 /= null and then not Is_Ghost (Defer_Res147) then
            Transform_Res87.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed19 then
      Transform_Res87.Last_Attempted_Child :=
         Row_Progress19;
      Append (Parser, Lst_Cpos18, "Cannot parse <if_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType ElsifBranch>) (root of 'if_expr') at parser.lkt:445:15>
   exit when Row_Pos118 = No_Token_Index;
   List_Pos18 := Row_Pos118;
   Lst_Cpos18 := List_Pos18;
   Diag_Mark58 := Parser.Last_Diag;
   Tmp_List18.Nodes.Append (Transform_Res87);
      Nobt20 := False;
end loop;
Parser.Last_Diag := Diag_Mark58;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List18.Nodes.Length;
begin
   List_Res18 := Allocate_Elsif_Branch_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos117;
      Token_End := (if Lst_Cpos18 = Row_Pos117
                    then Row_Pos117
                    else List_Pos18 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos117, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res18,
      Kind              => Lkt_Elsif_Branch_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res18,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List18.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res18.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List18);
--  END <List (root of 'if_expr') at parser.lkt:445:9>
Row_Progress20 := 6;
if List_Pos18 /= No_Token_Index then
   Row_Pos117 := List_Pos18;
else
   Row_Pos117 := No_Token_Index;
   goto Exit_Row117_0;
end if;
--  BEGIN <Token(<WithText ElseKw>, ) (root of 'if_expr') at parser.lkt:446:9>
--  pos=Token_Pos159, res=Token_Res159, nobt=None
Token_Res159 := Row_Pos117;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res159));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Else_Kw)
   then
       Token_Pos159 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos117 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos117,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Else_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos159 := Row_Pos117 + 1;
   end if;
end;
--  END <Token(<WithText ElseKw>, ) (root of 'if_expr') at parser.lkt:446:9>
Row_Progress20 := 7;
if Token_Pos159 /= No_Token_Index then
   Row_Pos117 := Token_Pos159;
else
   Row_Pos117 := No_Token_Index;
   goto Exit_Row117_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:447:9>
--  pos=Defer_Pos148, res=Defer_Res148, nobt=None
Defer_Res148 :=
   Expr_Or_Parse0 (Parser, Row_Pos117);
Defer_Pos148 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:447:9>
Row_Progress20 := 8;
if Defer_Pos148 /= No_Token_Index then
   Row_Pos117 := Defer_Pos148;
else
   Row_Pos117 := No_Token_Index;
   goto Exit_Row117_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row117_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'if_expr') at parser.lkt:439:16>
if Row_Pos117 = No_Token_Index and then Nobt19 then
   Row_Pos117 := Parser.Last_Fail.Pos;
   Transform_Has_Failed20 := True;
end if;
if Row_Pos117 /= No_Token_Index then
   Transform_Res88 := Allocate_If_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res88,
      Kind => Lkt_If_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos117 = Pos
                            then No_Token_Index
                            else Row_Pos117 - 1));
      Initialize_Fields_For_If_Expr
        (Self => Transform_Res88,
         If_Expr_F_Cond_Expr => Defer_Res144,
         If_Expr_F_Then_Expr => Defer_Res145,
         If_Expr_F_Alternatives => List_Res18,
         If_Expr_F_Else_Expr => Defer_Res148);
         if Defer_Res144 /= null and then Is_Incomplete (Defer_Res144) then
            Transform_Res88.Last_Attempted_Child := 0;
         elsif Defer_Res144 /= null and then not Is_Ghost (Defer_Res144) then
            Transform_Res88.Last_Attempted_Child := -1;
         end if;
         if Defer_Res145 /= null and then Is_Incomplete (Defer_Res145) then
            Transform_Res88.Last_Attempted_Child := 0;
         elsif Defer_Res145 /= null and then not Is_Ghost (Defer_Res145) then
            Transform_Res88.Last_Attempted_Child := -1;
         end if;
         if List_Res18 /= null and then Is_Incomplete (List_Res18) then
            Transform_Res88.Last_Attempted_Child := 0;
         elsif List_Res18 /= null and then not Is_Ghost (List_Res18) then
            Transform_Res88.Last_Attempted_Child := -1;
         end if;
         if Defer_Res148 /= null and then Is_Incomplete (Defer_Res148) then
            Transform_Res88.Last_Attempted_Child := 0;
         elsif Defer_Res148 /= null and then not Is_Ghost (Defer_Res148) then
            Transform_Res88.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed20 then
      Transform_Res88.Last_Attempted_Child :=
         Row_Progress20;
      Append (Parser, Pos, "Cannot parse <if_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType IfExpr>) (root of 'if_expr') at parser.lkt:439:16>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos117 = No_Token_Index then
      Set_Failure
        (PP.If_Expr_Transform_Parse1_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.If_Expr_Transform_Parse1_Memo, Pos, Transform_Res88, Parser.Last_Diag, Row_Pos117);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos117;
   return Transform_Res88;
end If_Expr_Transform_Parse1;
   function Import_Clause_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Import
is
      Nobt21 : Boolean := False;
      Nobt22 : Boolean := False;
      Nobt23 : Boolean := False;
      Row_Pos119 : Token_Index := No_Token_Index;
      Token_Pos160 : Token_Index := No_Token_Index;
      Token_Res160 : Token_Index := No_Token_Index;
      Defer_Pos149 : Token_Index := No_Token_Index;
      Defer_Res149 : Bare_Module_Id := No_Bare_Lkt_Node;
      Row_Pos120 : Token_Index := No_Token_Index;
      Token_Pos161 : Token_Index := No_Token_Index;
      Token_Res161 : Token_Index := No_Token_Index;
      Defer_Pos150 : Token_Index := No_Token_Index;
      Defer_Res150 : Bare_Def_Id := No_Bare_Lkt_Node;
      Diag_Mark59 : Diagnostic_Mark;
      Row_Progress21 : Integer := 0;
      Transform_Res89 : Bare_Import := No_Bare_Lkt_Node;
      Transform_Has_Failed21 : Boolean := False;
      Row_Pos121 : Token_Index := No_Token_Index;
      Token_Pos162 : Token_Index := No_Token_Index;
      Token_Res162 : Token_Index := No_Token_Index;
      Defer_Pos151 : Token_Index := No_Token_Index;
      Defer_Res151 : Bare_Module_Id := No_Bare_Lkt_Node;
      Token_Pos163 : Token_Index := No_Token_Index;
      Token_Res163 : Token_Index := No_Token_Index;
      Lst_Cpos19 : Token_Index := No_Token_Index;
      Tmp_List19 : Free_Parse_List;
      Defer_Pos152 : Token_Index := No_Token_Index;
      Defer_Res152 : Bare_Imported_Name := No_Bare_Lkt_Node;
      Token_Pos164 : Token_Index := No_Token_Index;
      Token_Res164 : Token_Index := No_Token_Index;
      List_Pos19 : Token_Index := No_Token_Index;
      List_Res19 : Bare_Imported_Name_List := No_Bare_Lkt_Node;
      Diag_Mark60 : Diagnostic_Mark;
      Transform_Res90 : Bare_Import_From := No_Bare_Lkt_Node;
      Row_Pos122 : Token_Index := No_Token_Index;
      Token_Pos165 : Token_Index := No_Token_Index;
      Token_Res165 : Token_Index := No_Token_Index;
      Defer_Pos153 : Token_Index := No_Token_Index;
      Defer_Res153 : Bare_Module_Id := No_Bare_Lkt_Node;
      Token_Pos166 : Token_Index := No_Token_Index;
      Token_Res166 : Token_Index := No_Token_Index;
      Token_Pos167 : Token_Index := No_Token_Index;
      Token_Res167 : Token_Index := No_Token_Index;
      Row_Progress22 : Integer := 0;
      Transform_Res91 : Bare_Import_All_From := No_Bare_Lkt_Node;
      Transform_Has_Failed22 : Boolean := False;
      Or_Pos24 : Token_Index := No_Token_Index;
      Or_Res24 : Bare_Base_Import := No_Bare_Lkt_Node;
      Diag_Mark61 : Diagnostic_Mark;
      Last_Fail24 : Fail_Info;
      Branch_Diag_Mark24 : Diagnostic_Mark;
      Branch_Last_Fail24 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Import_Clause_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res24 := M.Instance;
      return Or_Res24;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res24;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'import_clause') at parser.lkt:22:22>
--  pos=Or_Pos24, res=Or_Res24, nobt=None
Or_Pos24 := No_Token_Index;
Or_Res24 := No_Bare_Lkt_Node;
Diag_Mark61 := Parser.Last_Diag;
Last_Fail24 := Parser.Last_Fail;
Branch_Diag_Mark24 := Parser.Last_Diag;
Branch_Last_Fail24 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark61;
    Parser.Last_Fail := Last_Fail24;
--  BEGIN <Transform(<ASTNodeType Import>) (root of 'import_clause') at parser.lkt:23:11>
--  pos=Row_Pos119, res=Transform_Res89, nobt=Nobt21
--  BEGIN <_Row (root of 'import_clause') at parser.lkt:23:11>
--  pos=Row_Pos119, res=None, nobt=Nobt21
Row_Pos119 := Pos;
--  BEGIN <Token(<WithText ImportKw>, ) (root of 'import_clause') at parser.lkt:24:13>
--  pos=Token_Pos160, res=Token_Res160, nobt=None
Token_Res160 := Row_Pos119;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res160));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Import_Kw)
   then
       Token_Pos160 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos119 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos119,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Import_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos160 := Row_Pos119 + 1;
   end if;
end;
--  END <Token(<WithText ImportKw>, ) (root of 'import_clause') at parser.lkt:24:13>
Row_Progress21 := 1;
if Token_Pos160 /= No_Token_Index then
   Row_Pos119 := Token_Pos160;
else
   Row_Pos119 := No_Token_Index;
   goto Exit_Row119_0;
end if;
--  BEGIN <Cut (root of 'import_clause') at parser.lkt:25:13>
--  pos=Row_Pos119, res=None, nobt=Nobt21
Nobt21 := True;
--  END <Cut (root of 'import_clause') at parser.lkt:25:13>
Row_Progress21 := 2;
if Row_Pos119 /= No_Token_Index then
   Row_Pos119 := Row_Pos119;
else
   Row_Pos119 := No_Token_Index;
   goto Exit_Row119_0;
end if;
--  BEGIN <Defer (for 'module_id') at parser.lkt:26:13>
--  pos=Defer_Pos149, res=Defer_Res149, nobt=None
Defer_Res149 :=
   Module_Id_Predicate_Parse0 (Parser, Row_Pos119);
Defer_Pos149 := Parser.Current_Pos;
--  END <Defer (for 'module_id') at parser.lkt:26:13>
Row_Progress21 := 3;
if Defer_Pos149 /= No_Token_Index then
   Row_Pos119 := Defer_Pos149;
else
   Row_Pos119 := No_Token_Index;
   goto Exit_Row119_0;
end if;
--  BEGIN <Opt (root of 'import_clause') at parser.lkt:27:13>
--  pos=Row_Pos120, res=Defer_Res150, nobt=Nobt22
Diag_Mark59 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'import_clause') at parser.lkt:27:14>
--  pos=Row_Pos120, res=Defer_Res150, nobt=Nobt22
--  BEGIN <_Row (root of 'import_clause') at parser.lkt:27:14>
--  pos=Row_Pos120, res=None, nobt=Nobt22
Row_Pos120 := Row_Pos119;
--  BEGIN <Token(<WithSymbol Identifier>, as) (root of 'import_clause') at parser.lkt:27:19>
--  pos=Token_Pos161, res=Token_Res161, nobt=None
Token_Res161 := Row_Pos120;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res161));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_As)
   then
       Token_Pos161 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos120 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos120,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos161 := Row_Pos120 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, as) (root of 'import_clause') at parser.lkt:27:19>
if Token_Pos161 /= No_Token_Index then
   Row_Pos120 := Token_Pos161;
else
   Row_Pos120 := No_Token_Index;
   goto Exit_Row120_0;
end if;
--  BEGIN <Cut (root of 'import_clause') at parser.lkt:27:37>
--  pos=Row_Pos120, res=None, nobt=Nobt22
Nobt22 := True;
--  END <Cut (root of 'import_clause') at parser.lkt:27:37>
if Row_Pos120 /= No_Token_Index then
   Row_Pos120 := Row_Pos120;
else
   Row_Pos120 := No_Token_Index;
   goto Exit_Row120_0;
end if;
--  BEGIN <Defer (for 'def_id') at parser.lkt:27:39>
--  pos=Defer_Pos150, res=Defer_Res150, nobt=None
Defer_Res150 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos120);
Defer_Pos150 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:27:39>
if Defer_Pos150 /= No_Token_Index then
   Row_Pos120 := Defer_Pos150;
else
   Row_Pos120 := No_Token_Index;
   goto Exit_Row120_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row120_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'import_clause') at parser.lkt:27:14>
--  END <_Extract (root of 'import_clause') at parser.lkt:27:14>
if Row_Pos120 = No_Token_Index then
   if Nobt22 then
      Row_Pos120 := Parser.Last_Fail.Pos;
      Append (Parser, Row_Pos120, "Cannot parse <import_clause>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
         if not Nobt22 then
   Defer_Res150 := No_Bare_Lkt_Node;
         end if;
       if not Nobt22 then
   Row_Pos120 := Row_Pos119;
      Parser.Last_Diag := Diag_Mark59;
       end if;
end if;
--  END <Opt (root of 'import_clause') at parser.lkt:27:13>
   Nobt21 := Nobt22;
Row_Progress21 := 4;
if Row_Pos120 /= No_Token_Index then
   Row_Pos119 := Row_Pos120;
else
   Row_Pos119 := No_Token_Index;
   goto Exit_Row119_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row119_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'import_clause') at parser.lkt:23:11>
if Row_Pos119 = No_Token_Index and then Nobt21 then
   Row_Pos119 := Parser.Last_Fail.Pos;
   Transform_Has_Failed21 := True;
end if;
if Row_Pos119 /= No_Token_Index then
   Transform_Res89 := Allocate_Import (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res89,
      Kind => Lkt_Import,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos119 = Pos
                            then No_Token_Index
                            else Row_Pos119 - 1));
      Initialize_Fields_For_Import
        (Self => Transform_Res89,
         Base_Import_F_Module_Name => Defer_Res149,
         Import_F_Renaming => Defer_Res150);
         if Defer_Res149 /= null and then Is_Incomplete (Defer_Res149) then
            Transform_Res89.Last_Attempted_Child := 0;
         elsif Defer_Res149 /= null and then not Is_Ghost (Defer_Res149) then
            Transform_Res89.Last_Attempted_Child := -1;
         end if;
         if Defer_Res150 /= null and then Is_Incomplete (Defer_Res150) then
            Transform_Res89.Last_Attempted_Child := 0;
         elsif Defer_Res150 /= null and then not Is_Ghost (Defer_Res150) then
            Transform_Res89.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed21 then
      Transform_Res89.Last_Attempted_Child :=
         Row_Progress21;
      Append (Parser, Pos, "Cannot parse <import_clause>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType Import>) (root of 'import_clause') at parser.lkt:23:11>
    if Row_Pos119 /= No_Token_Index then
        Or_Pos24 := Row_Pos119;
        Or_Res24 := Transform_Res89;
        goto Exit_Or27;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail24.Pos then
       Branch_Diag_Mark24 := Parser.Last_Diag;
       Branch_Last_Fail24 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark61;
    Parser.Last_Fail := Last_Fail24;
--  BEGIN <Transform(<ASTNodeType ImportFrom>) (root of 'import_clause') at parser.lkt:29:11>
--  pos=Row_Pos121, res=Transform_Res90, nobt=None
--  BEGIN <_Row (root of 'import_clause') at parser.lkt:29:11>
--  pos=Row_Pos121, res=None, nobt=None
Row_Pos121 := Pos;
--  BEGIN <Token(<WithText FromKw>, ) (root of 'import_clause') at parser.lkt:30:13>
--  pos=Token_Pos162, res=Token_Res162, nobt=None
Token_Res162 := Row_Pos121;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res162));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_From_Kw)
   then
       Token_Pos162 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos121 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos121,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_From_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos162 := Row_Pos121 + 1;
   end if;
end;
--  END <Token(<WithText FromKw>, ) (root of 'import_clause') at parser.lkt:30:13>
if Token_Pos162 /= No_Token_Index then
   Row_Pos121 := Token_Pos162;
else
   Row_Pos121 := No_Token_Index;
   goto Exit_Row121_0;
end if;
--  BEGIN <Defer (for 'module_id') at parser.lkt:30:20>
--  pos=Defer_Pos151, res=Defer_Res151, nobt=None
Defer_Res151 :=
   Module_Id_Predicate_Parse0 (Parser, Row_Pos121);
Defer_Pos151 := Parser.Current_Pos;
--  END <Defer (for 'module_id') at parser.lkt:30:20>
if Defer_Pos151 /= No_Token_Index then
   Row_Pos121 := Defer_Pos151;
else
   Row_Pos121 := No_Token_Index;
   goto Exit_Row121_0;
end if;
--  BEGIN <Token(<WithText ImportKw>, ) (root of 'import_clause') at parser.lkt:30:30>
--  pos=Token_Pos163, res=Token_Res163, nobt=None
Token_Res163 := Row_Pos121;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res163));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Import_Kw)
   then
       Token_Pos163 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos121 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos121,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Import_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos163 := Row_Pos121 + 1;
   end if;
end;
--  END <Token(<WithText ImportKw>, ) (root of 'import_clause') at parser.lkt:30:30>
if Token_Pos163 /= No_Token_Index then
   Row_Pos121 := Token_Pos163;
else
   Row_Pos121 := No_Token_Index;
   goto Exit_Row121_0;
end if;
--  BEGIN <List (root of 'import_clause') at parser.lkt:30:39>
--  pos=List_Pos19, res=List_Res19, nobt=None
    List_Pos19 := No_Token_Index;
Lst_Cpos19 := Row_Pos121;
Tmp_List19 := Get_Parse_List (Parser);
Diag_Mark60 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'imported_name') at parser.lkt:30:45>
--  pos=Defer_Pos152, res=Defer_Res152, nobt=None
Defer_Res152 :=
   Imported_Name_Transform_Parse1 (Parser, Lst_Cpos19);
Defer_Pos152 := Parser.Current_Pos;
--  END <Defer (for 'imported_name') at parser.lkt:30:45>
   exit when Defer_Pos152 = No_Token_Index;
   List_Pos19 := Defer_Pos152;
   Lst_Cpos19 := List_Pos19;
   Diag_Mark60 := Parser.Last_Diag;
   Tmp_List19.Nodes.Append (Defer_Res152);
--  BEGIN <Token(<WithText Comma>, ) (root of 'import_clause') at parser.lkt:30:60>
--  pos=Token_Pos164, res=Token_Res164, nobt=None
Token_Res164 := Lst_Cpos19;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res164));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos164 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Lst_Cpos19 then
          Parser.Last_Fail :=
            (Pos  => Lst_Cpos19,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Comma,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos164 := Lst_Cpos19 + 1;
   end if;
end;
--  END <Token(<WithText Comma>, ) (root of 'import_clause') at parser.lkt:30:60>
      exit when Token_Pos164 = No_Token_Index;
      Lst_Cpos19 := Token_Pos164;
end loop;
Parser.Last_Diag := Diag_Mark60;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List19.Nodes.Length;
begin
   List_Res19 := Allocate_Imported_Name_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos121;
      Token_End := (if Lst_Cpos19 = Row_Pos121
                    then Row_Pos121
                    else List_Pos19 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos121, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res19,
      Kind              => Lkt_Imported_Name_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res19,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List19.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res19.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List19);
--  END <List (root of 'import_clause') at parser.lkt:30:39>
if List_Pos19 /= No_Token_Index then
   Row_Pos121 := List_Pos19;
else
   Row_Pos121 := No_Token_Index;
   goto Exit_Row121_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row121_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'import_clause') at parser.lkt:29:11>
if Row_Pos121 /= No_Token_Index then
   Transform_Res90 := Allocate_Import_From (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res90,
      Kind => Lkt_Import_From,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos121 = Pos
                            then No_Token_Index
                            else Row_Pos121 - 1));
      Initialize_Fields_For_Import_From
        (Self => Transform_Res90,
         Base_Import_F_Module_Name => Defer_Res151,
         Import_From_F_Imported_Names => List_Res19);
         if Defer_Res151 /= null and then Is_Incomplete (Defer_Res151) then
            Transform_Res90.Last_Attempted_Child := 0;
         elsif Defer_Res151 /= null and then not Is_Ghost (Defer_Res151) then
            Transform_Res90.Last_Attempted_Child := -1;
         end if;
         if List_Res19 /= null and then Is_Incomplete (List_Res19) then
            Transform_Res90.Last_Attempted_Child := 0;
         elsif List_Res19 /= null and then not Is_Ghost (List_Res19) then
            Transform_Res90.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType ImportFrom>) (root of 'import_clause') at parser.lkt:29:11>
    if Row_Pos121 /= No_Token_Index then
        Or_Pos24 := Row_Pos121;
        Or_Res24 := Transform_Res90;
        goto Exit_Or27;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail24.Pos then
       Branch_Diag_Mark24 := Parser.Last_Diag;
       Branch_Last_Fail24 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark61;
    Parser.Last_Fail := Last_Fail24;
--  BEGIN <Transform(<ASTNodeType ImportAllFrom>) (root of 'import_clause') at parser.lkt:32:11>
--  pos=Row_Pos122, res=Transform_Res91, nobt=Nobt23
--  BEGIN <_Row (root of 'import_clause') at parser.lkt:32:11>
--  pos=Row_Pos122, res=None, nobt=Nobt23
Row_Pos122 := Pos;
--  BEGIN <Token(<WithText FromKw>, ) (root of 'import_clause') at parser.lkt:32:25>
--  pos=Token_Pos165, res=Token_Res165, nobt=None
Token_Res165 := Row_Pos122;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res165));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_From_Kw)
   then
       Token_Pos165 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos122 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos122,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_From_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos165 := Row_Pos122 + 1;
   end if;
end;
--  END <Token(<WithText FromKw>, ) (root of 'import_clause') at parser.lkt:32:25>
Row_Progress22 := 1;
if Token_Pos165 /= No_Token_Index then
   Row_Pos122 := Token_Pos165;
else
   Row_Pos122 := No_Token_Index;
   goto Exit_Row122_0;
end if;
--  BEGIN <Cut (root of 'import_clause') at parser.lkt:32:32>
--  pos=Row_Pos122, res=None, nobt=Nobt23
Nobt23 := True;
--  END <Cut (root of 'import_clause') at parser.lkt:32:32>
Row_Progress22 := 2;
if Row_Pos122 /= No_Token_Index then
   Row_Pos122 := Row_Pos122;
else
   Row_Pos122 := No_Token_Index;
   goto Exit_Row122_0;
end if;
--  BEGIN <Defer (for 'module_id') at parser.lkt:32:34>
--  pos=Defer_Pos153, res=Defer_Res153, nobt=None
Defer_Res153 :=
   Module_Id_Predicate_Parse0 (Parser, Row_Pos122);
Defer_Pos153 := Parser.Current_Pos;
--  END <Defer (for 'module_id') at parser.lkt:32:34>
Row_Progress22 := 3;
if Defer_Pos153 /= No_Token_Index then
   Row_Pos122 := Defer_Pos153;
else
   Row_Pos122 := No_Token_Index;
   goto Exit_Row122_0;
end if;
--  BEGIN <Token(<WithText ImportKw>, ) (root of 'import_clause') at parser.lkt:32:44>
--  pos=Token_Pos166, res=Token_Res166, nobt=None
Token_Res166 := Row_Pos122;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res166));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Import_Kw)
   then
       Token_Pos166 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos122 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos122,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Import_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos166 := Row_Pos122 + 1;
   end if;
end;
--  END <Token(<WithText ImportKw>, ) (root of 'import_clause') at parser.lkt:32:44>
Row_Progress22 := 4;
if Token_Pos166 /= No_Token_Index then
   Row_Pos122 := Token_Pos166;
else
   Row_Pos122 := No_Token_Index;
   goto Exit_Row122_0;
end if;
--  BEGIN <Token(<WithText Times>, ) (root of 'import_clause') at parser.lkt:32:53>
--  pos=Token_Pos167, res=Token_Res167, nobt=None
Token_Res167 := Row_Pos122;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res167));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Times)
   then
       Token_Pos167 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos122 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos122,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Times,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos167 := Row_Pos122 + 1;
   end if;
end;
--  END <Token(<WithText Times>, ) (root of 'import_clause') at parser.lkt:32:53>
Row_Progress22 := 5;
if Token_Pos167 /= No_Token_Index then
   Row_Pos122 := Token_Pos167;
else
   Row_Pos122 := No_Token_Index;
   goto Exit_Row122_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row122_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'import_clause') at parser.lkt:32:11>
if Row_Pos122 = No_Token_Index and then Nobt23 then
   Row_Pos122 := Parser.Last_Fail.Pos;
   Transform_Has_Failed22 := True;
end if;
if Row_Pos122 /= No_Token_Index then
   Transform_Res91 := Allocate_Import_All_From (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res91,
      Kind => Lkt_Import_All_From,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos122 = Pos
                            then No_Token_Index
                            else Row_Pos122 - 1));
      Initialize_Fields_For_Import_All_From
        (Self => Transform_Res91,
         Base_Import_F_Module_Name => Defer_Res153);
         if Defer_Res153 /= null and then Is_Incomplete (Defer_Res153) then
            Transform_Res91.Last_Attempted_Child := 0;
         elsif Defer_Res153 /= null and then not Is_Ghost (Defer_Res153) then
            Transform_Res91.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed22 then
      Transform_Res91.Last_Attempted_Child :=
         Row_Progress22;
      Append (Parser, Pos, "Cannot parse <import_clause>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType ImportAllFrom>) (root of 'import_clause') at parser.lkt:32:11>
    if Row_Pos122 /= No_Token_Index then
        Or_Pos24 := Row_Pos122;
        Or_Res24 := Transform_Res91;
        goto Exit_Or27;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail24.Pos then
       Branch_Diag_Mark24 := Parser.Last_Diag;
       Branch_Last_Fail24 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark24;
Parser.Last_Fail := Branch_Last_Fail24;
<<Exit_Or27>>
--  END <Or (root of 'import_clause') at parser.lkt:22:22>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos24 = No_Token_Index then
      Set_Failure
        (PP.Import_Clause_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Import_Clause_Or_Parse0_Memo, Pos, Or_Res24, Parser.Last_Diag, Or_Pos24);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos24;
   return Or_Res24;
end Import_Clause_Or_Parse0;
   function Imported_Name_Transform_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Imported_Name
is
      Nobt24 : Boolean := False;
      Nobt25 : Boolean := False;
      Row_Pos123 : Token_Index := No_Token_Index;
      Row_Pos124 : Token_Index := No_Token_Index;
      Token_Pos168 : Token_Index := No_Token_Index;
      Token_Res168 : Token_Index := No_Token_Index;
      Transform_Res92 : Bare_Imported_Id := No_Bare_Lkt_Node;
      Row_Pos125 : Token_Index := No_Token_Index;
      Token_Pos169 : Token_Index := No_Token_Index;
      Token_Res169 : Token_Index := No_Token_Index;
      Defer_Pos154 : Token_Index := No_Token_Index;
      Defer_Res154 : Bare_Def_Id := No_Bare_Lkt_Node;
      Diag_Mark62 : Diagnostic_Mark;
      Row_Progress23 : Integer := 0;
      Transform_Res93 : Bare_Imported_Name := No_Bare_Lkt_Node;
      Transform_Has_Failed23 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Imported_Name_Transform_Parse1_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res93 := M.Instance;
      return Transform_Res93;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res93;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType ImportedName>) (root of 'imported_name') at parser.lkt:18:22>
--  pos=Row_Pos123, res=Transform_Res93, nobt=Nobt25
--  BEGIN <_Row (root of 'imported_name') at parser.lkt:18:22>
--  pos=Row_Pos123, res=None, nobt=Nobt25
Row_Pos123 := Pos;
--  BEGIN <Transform(<ASTNodeType ImportedId>) (root of 'imported_name') at parser.lkt:19:9>
--  pos=Row_Pos124, res=Transform_Res92, nobt=None
--  BEGIN <_Row (root of 'imported_name') at parser.lkt:19:9>
--  pos=Row_Pos124, res=None, nobt=None
Row_Pos124 := Row_Pos123;
--  BEGIN <Token(<WithSymbol Identifier>, ) (root of 'imported_name') at parser.lkt:19:20>
--  pos=Token_Pos168, res=Token_Res168, nobt=None
Token_Res168 := Row_Pos124;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res168));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
   then
       Token_Pos168 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos124 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos124,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos168 := Row_Pos124 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, ) (root of 'imported_name') at parser.lkt:19:20>
if Token_Pos168 /= No_Token_Index then
   Row_Pos124 := Token_Pos168;
else
   Row_Pos124 := No_Token_Index;
   goto Exit_Row124_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row124_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'imported_name') at parser.lkt:19:9>
if Row_Pos124 /= No_Token_Index then
   Transform_Res92 := Allocate_Imported_Id (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res92,
      Kind => Lkt_Imported_Id,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos123,
      Token_End_Index   => (if Row_Pos124 = Row_Pos123
                            then No_Token_Index
                            else Row_Pos124 - 1));
      Initialize_Fields_For_Imported_Id
        (Self => Transform_Res92);
end if;
--  END <Transform(<ASTNodeType ImportedId>) (root of 'imported_name') at parser.lkt:19:9>
Row_Progress23 := 1;
if Row_Pos124 /= No_Token_Index then
   Row_Pos123 := Row_Pos124;
else
   Row_Pos123 := No_Token_Index;
   goto Exit_Row123_0;
end if;
--  BEGIN <Opt (root of 'imported_name') at parser.lkt:20:9>
--  pos=Row_Pos125, res=Defer_Res154, nobt=Nobt24
Diag_Mark62 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'imported_name') at parser.lkt:20:10>
--  pos=Row_Pos125, res=Defer_Res154, nobt=Nobt24
--  BEGIN <_Row (root of 'imported_name') at parser.lkt:20:10>
--  pos=Row_Pos125, res=None, nobt=Nobt24
Row_Pos125 := Row_Pos123;
--  BEGIN <Token(<WithSymbol Identifier>, as) (root of 'imported_name') at parser.lkt:20:15>
--  pos=Token_Pos169, res=Token_Res169, nobt=None
Token_Res169 := Row_Pos125;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res169));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_As)
   then
       Token_Pos169 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos125 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos125,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos169 := Row_Pos125 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, as) (root of 'imported_name') at parser.lkt:20:15>
if Token_Pos169 /= No_Token_Index then
   Row_Pos125 := Token_Pos169;
else
   Row_Pos125 := No_Token_Index;
   goto Exit_Row125_0;
end if;
--  BEGIN <Cut (root of 'imported_name') at parser.lkt:20:33>
--  pos=Row_Pos125, res=None, nobt=Nobt24
Nobt24 := True;
--  END <Cut (root of 'imported_name') at parser.lkt:20:33>
if Row_Pos125 /= No_Token_Index then
   Row_Pos125 := Row_Pos125;
else
   Row_Pos125 := No_Token_Index;
   goto Exit_Row125_0;
end if;
--  BEGIN <Defer (for 'def_id') at parser.lkt:20:35>
--  pos=Defer_Pos154, res=Defer_Res154, nobt=None
Defer_Res154 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos125);
Defer_Pos154 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:20:35>
if Defer_Pos154 /= No_Token_Index then
   Row_Pos125 := Defer_Pos154;
else
   Row_Pos125 := No_Token_Index;
   goto Exit_Row125_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row125_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'imported_name') at parser.lkt:20:10>
--  END <_Extract (root of 'imported_name') at parser.lkt:20:10>
if Row_Pos125 = No_Token_Index then
   if Nobt24 then
      Row_Pos125 := Parser.Last_Fail.Pos;
      Append (Parser, Row_Pos125, "Cannot parse <imported_name>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
         if not Nobt24 then
   Defer_Res154 := No_Bare_Lkt_Node;
         end if;
       if not Nobt24 then
   Row_Pos125 := Row_Pos123;
      Parser.Last_Diag := Diag_Mark62;
       end if;
end if;
--  END <Opt (root of 'imported_name') at parser.lkt:20:9>
   Nobt25 := Nobt24;
Row_Progress23 := 2;
if Row_Pos125 /= No_Token_Index then
   Row_Pos123 := Row_Pos125;
else
   Row_Pos123 := No_Token_Index;
   goto Exit_Row123_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row123_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'imported_name') at parser.lkt:18:22>
if Row_Pos123 = No_Token_Index and then Nobt25 then
   Row_Pos123 := Parser.Last_Fail.Pos;
   Transform_Has_Failed23 := True;
end if;
if Row_Pos123 /= No_Token_Index then
   Transform_Res93 := Allocate_Imported_Name (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res93,
      Kind => Lkt_Imported_Name,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos123 = Pos
                            then No_Token_Index
                            else Row_Pos123 - 1));
      Initialize_Fields_For_Imported_Name
        (Self => Transform_Res93,
         Imported_Name_F_Original_Name => Transform_Res92,
         Imported_Name_F_Renaming => Defer_Res154);
         if Transform_Res92 /= null and then Is_Incomplete (Transform_Res92) then
            Transform_Res93.Last_Attempted_Child := 0;
         elsif Transform_Res92 /= null and then not Is_Ghost (Transform_Res92) then
            Transform_Res93.Last_Attempted_Child := -1;
         end if;
         if Defer_Res154 /= null and then Is_Incomplete (Defer_Res154) then
            Transform_Res93.Last_Attempted_Child := 0;
         elsif Defer_Res154 /= null and then not Is_Ghost (Defer_Res154) then
            Transform_Res93.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed23 then
      Transform_Res93.Last_Attempted_Child :=
         Row_Progress23;
      Append (Parser, Pos, "Cannot parse <imported_name>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType ImportedName>) (root of 'imported_name') at parser.lkt:18:22>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos123 = No_Token_Index then
      Set_Failure
        (PP.Imported_Name_Transform_Parse1_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Imported_Name_Transform_Parse1_Memo, Pos, Transform_Res93, Parser.Last_Diag, Row_Pos123);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos123;
   return Transform_Res93;
end Imported_Name_Transform_Parse1;
   function Imports_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Import_List
is
      Lst_Cpos20 : Token_Index := No_Token_Index;
      Tmp_List20 : Free_Parse_List;
      Defer_Pos155 : Token_Index := No_Token_Index;
      Defer_Res155 : Bare_Base_Import := No_Bare_Lkt_Node;
      List_Pos20 : Token_Index := No_Token_Index;
      List_Res20 : Bare_Base_Import_List := No_Bare_Lkt_Node;
      Diag_Mark63 : Diagnostic_Mark;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Imports_List_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      List_Res20 := M.Instance;
      return List_Res20;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return List_Res20;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <List (root of 'imports') at parser.lkt:34:16>
--  pos=List_Pos20, res=List_Res20, nobt=None
    List_Pos20 := Pos;
Lst_Cpos20 := Pos;
Tmp_List20 := Get_Parse_List (Parser);
Diag_Mark63 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'import_clause') at parser.lkt:34:22>
--  pos=Defer_Pos155, res=Defer_Res155, nobt=None
Defer_Res155 :=
   Import_Clause_Or_Parse0 (Parser, Lst_Cpos20);
Defer_Pos155 := Parser.Current_Pos;
--  END <Defer (for 'import_clause') at parser.lkt:34:22>
   exit when Defer_Pos155 = No_Token_Index;
   List_Pos20 := Defer_Pos155;
   Lst_Cpos20 := List_Pos20;
   Diag_Mark63 := Parser.Last_Diag;
   Tmp_List20.Nodes.Append (Defer_Res155);
end loop;
Parser.Last_Diag := Diag_Mark63;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List20.Nodes.Length;
begin
   List_Res20 := Allocate_Base_Import_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos20 = Pos
                    then Pos
                    else List_Pos20 - 1);
   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res20,
      Kind              => Lkt_Base_Import_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res20,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List20.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res20.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List20);
--  END <List (root of 'imports') at parser.lkt:34:16>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if List_Pos20 = No_Token_Index then
      Set_Failure
        (PP.Imports_List_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Imports_List_Parse0_Memo, Pos, List_Res20, Parser.Last_Diag, List_Pos20);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := List_Pos20;
   return List_Res20;
end Imports_List_Parse0;
   function Integer_Pattern_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Integer_Pattern
is
      Row_Pos126 : Token_Index := No_Token_Index;
      Token_Pos170 : Token_Index := No_Token_Index;
      Token_Res170 : Token_Index := No_Token_Index;
      Transform_Res94 : Bare_Integer_Pattern := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Integer_Pattern_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res94 := M.Instance;
      return Transform_Res94;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res94;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType IntegerPattern>) (root of 'integer_pattern') at parser.lkt:342:24>
--  pos=Row_Pos126, res=Transform_Res94, nobt=None
--  BEGIN <_Row (root of 'integer_pattern') at parser.lkt:342:24>
--  pos=Row_Pos126, res=None, nobt=None
Row_Pos126 := Pos;
--  BEGIN <Token(<WithText Number>, ) (root of 'integer_pattern') at parser.lkt:342:39>
--  pos=Token_Pos170, res=Token_Res170, nobt=None
Token_Res170 := Row_Pos126;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res170));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Number)
   then
       Token_Pos170 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos126 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos126,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Number,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos170 := Row_Pos126 + 1;
   end if;
end;
--  END <Token(<WithText Number>, ) (root of 'integer_pattern') at parser.lkt:342:39>
if Token_Pos170 /= No_Token_Index then
   Row_Pos126 := Token_Pos170;
else
   Row_Pos126 := No_Token_Index;
   goto Exit_Row126_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row126_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'integer_pattern') at parser.lkt:342:24>
if Row_Pos126 /= No_Token_Index then
   Transform_Res94 := Allocate_Integer_Pattern (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res94,
      Kind => Lkt_Integer_Pattern,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos126 = Pos
                            then No_Token_Index
                            else Row_Pos126 - 1));
end if;
--  END <Transform(<ASTNodeType IntegerPattern>) (root of 'integer_pattern') at parser.lkt:342:24>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos126 = No_Token_Index then
      Set_Failure
        (PP.Integer_Pattern_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Integer_Pattern_Transform_Parse0_Memo, Pos, Transform_Res94, Parser.Last_Diag, Row_Pos126);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos126;
   return Transform_Res94;
end Integer_Pattern_Transform_Parse0;
   function Isa_Or_Primary_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
      Nobt26 : Boolean := False;
      Nobt27 : Boolean := False;
      Nobt28 : Boolean := False;
      Nobt29 : Boolean := False;
      Row_Pos127 : Token_Index := No_Token_Index;
      Defer_Pos156 : Token_Index := No_Token_Index;
      Defer_Res156 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos171 : Token_Index := No_Token_Index;
      Token_Res171 : Token_Index := No_Token_Index;
      Defer_Pos157 : Token_Index := No_Token_Index;
      Defer_Res157 : Bare_Pattern := No_Bare_Lkt_Node;
      Row_Progress24 : Integer := 0;
      Transform_Res95 : Bare_Isa := No_Bare_Lkt_Node;
      Transform_Has_Failed24 : Boolean := False;
      Row_Pos128 : Token_Index := No_Token_Index;
      Defer_Pos158 : Token_Index := No_Token_Index;
      Defer_Res158 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos172 : Token_Index := No_Token_Index;
      Token_Res172 : Token_Index := No_Token_Index;
      Lst_Cpos21 : Token_Index := No_Token_Index;
      Tmp_List21 : Free_Parse_List;
      Defer_Pos159 : Token_Index := No_Token_Index;
      Defer_Res159 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos173 : Token_Index := No_Token_Index;
      Token_Res173 : Token_Index := No_Token_Index;
      List_Pos21 : Token_Index := No_Token_Index;
      List_Res21 : Bare_Any_Of_List := No_Bare_Lkt_Node;
      Diag_Mark64 : Diagnostic_Mark;
      Row_Progress25 : Integer := 0;
      Transform_Res96 : Bare_Any_Of := No_Bare_Lkt_Node;
      Transform_Has_Failed25 : Boolean := False;
      Row_Pos129 : Token_Index := No_Token_Index;
      Defer_Pos160 : Token_Index := No_Token_Index;
      Defer_Res160 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos174 : Token_Index := No_Token_Index;
      Token_Res174 : Token_Index := No_Token_Index;
      Defer_Pos161 : Token_Index := No_Token_Index;
      Defer_Res161 : Bare_Expr := No_Bare_Lkt_Node;
      Row_Progress26 : Integer := 0;
      Transform_Res97 : Bare_Logic_Unify := No_Bare_Lkt_Node;
      Transform_Has_Failed26 : Boolean := False;
      Row_Pos130 : Token_Index := No_Token_Index;
      Defer_Pos162 : Token_Index := No_Token_Index;
      Defer_Res162 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos175 : Token_Index := No_Token_Index;
      Token_Res175 : Token_Index := No_Token_Index;
      Defer_Pos163 : Token_Index := No_Token_Index;
      Defer_Res163 : Bare_Logic_Propagate_Call := No_Bare_Lkt_Node;
      Transform_Res98 : Bare_Logic_Propagate := No_Bare_Lkt_Node;
      Row_Pos131 : Token_Index := No_Token_Index;
      Defer_Pos164 : Token_Index := No_Token_Index;
      Defer_Res164 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos176 : Token_Index := No_Token_Index;
      Token_Res176 : Token_Index := No_Token_Index;
      Defer_Pos165 : Token_Index := No_Token_Index;
      Defer_Res165 : Bare_Expr := No_Bare_Lkt_Node;
      Row_Progress27 : Integer := 0;
      Transform_Res99 : Bare_Logic_Assign := No_Bare_Lkt_Node;
      Transform_Has_Failed27 : Boolean := False;
      Defer_Pos166 : Token_Index := No_Token_Index;
      Defer_Res166 : Bare_Expr := No_Bare_Lkt_Node;
      Or_Pos25 : Token_Index := No_Token_Index;
      Or_Res25 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark65 : Diagnostic_Mark;
      Last_Fail25 : Fail_Info;
      Branch_Diag_Mark25 : Diagnostic_Mark;
      Branch_Last_Fail25 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
      Mem_Pos  : Token_Index := Pos;
      Mem_Res  : Bare_Expr := No_Bare_Lkt_Node;
      Mem_Mark : Diagnostic_Mark := Mark_On_Entry;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Isa_Or_Primary_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res25 := M.Instance;
      return Or_Res25;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res25;
   end if;
   Parser.Last_Diag := No_Diagnostic;
       Set_Failure
         (PP.Isa_Or_Primary_Or_Parse0_Memo,
          Pos,
          Parser.Last_Fail,
          Parser.Last_Diag);
       <<Try_Again>>
       Parser.Last_Diag := No_Diagnostic;
      Nobt26 := False;
      Nobt27 := False;
      Nobt28 := False;
      Nobt29 := False;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'isa_or_primary') at parser.lkt:405:23>
--  pos=Or_Pos25, res=Or_Res25, nobt=None
Or_Pos25 := No_Token_Index;
Or_Res25 := No_Bare_Lkt_Node;
Diag_Mark65 := Parser.Last_Diag;
Last_Fail25 := Parser.Last_Fail;
Branch_Diag_Mark25 := Parser.Last_Diag;
Branch_Last_Fail25 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark65;
    Parser.Last_Fail := Last_Fail25;
--  BEGIN <Transform(<ASTNodeType Isa>) (root of 'isa_or_primary') at parser.lkt:406:11>
--  pos=Row_Pos127, res=Transform_Res95, nobt=Nobt26
--  BEGIN <_Row (root of 'isa_or_primary') at parser.lkt:406:11>
--  pos=Row_Pos127, res=None, nobt=Nobt26
Row_Pos127 := Pos;
--  BEGIN <Defer (for 'primary') at parser.lkt:406:15>
--  pos=Defer_Pos156, res=Defer_Res156, nobt=None
Defer_Res156 :=
   Primary_Or_Parse0 (Parser, Row_Pos127);
Defer_Pos156 := Parser.Current_Pos;
--  END <Defer (for 'primary') at parser.lkt:406:15>
Row_Progress24 := 1;
if Defer_Pos156 /= No_Token_Index then
   Row_Pos127 := Defer_Pos156;
else
   Row_Pos127 := No_Token_Index;
   goto Exit_Row127_0;
end if;
--  BEGIN <Token(<WithText IsKw>, ) (root of 'isa_or_primary') at parser.lkt:406:23>
--  pos=Token_Pos171, res=Token_Res171, nobt=None
Token_Res171 := Row_Pos127;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res171));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Is_Kw)
   then
       Token_Pos171 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos127 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos127,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Is_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos171 := Row_Pos127 + 1;
   end if;
end;
--  END <Token(<WithText IsKw>, ) (root of 'isa_or_primary') at parser.lkt:406:23>
Row_Progress24 := 2;
if Token_Pos171 /= No_Token_Index then
   Row_Pos127 := Token_Pos171;
else
   Row_Pos127 := No_Token_Index;
   goto Exit_Row127_0;
end if;
--  BEGIN <Cut (root of 'isa_or_primary') at parser.lkt:406:28>
--  pos=Row_Pos127, res=None, nobt=Nobt26
Nobt26 := True;
--  END <Cut (root of 'isa_or_primary') at parser.lkt:406:28>
Row_Progress24 := 3;
if Row_Pos127 /= No_Token_Index then
   Row_Pos127 := Row_Pos127;
else
   Row_Pos127 := No_Token_Index;
   goto Exit_Row127_0;
end if;
--  BEGIN <Defer (for 'pattern') at parser.lkt:406:30>
--  pos=Defer_Pos157, res=Defer_Res157, nobt=None
Defer_Res157 :=
   Pattern_Or_Parse0 (Parser, Row_Pos127);
Defer_Pos157 := Parser.Current_Pos;
--  END <Defer (for 'pattern') at parser.lkt:406:30>
Row_Progress24 := 4;
if Defer_Pos157 /= No_Token_Index then
   Row_Pos127 := Defer_Pos157;
else
   Row_Pos127 := No_Token_Index;
   goto Exit_Row127_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row127_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'isa_or_primary') at parser.lkt:406:11>
if Row_Pos127 = No_Token_Index and then Nobt26 then
   Row_Pos127 := Parser.Last_Fail.Pos;
   Transform_Has_Failed24 := True;
end if;
if Row_Pos127 /= No_Token_Index then
   Transform_Res95 := Allocate_Isa (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res95,
      Kind => Lkt_Isa,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos127 = Pos
                            then No_Token_Index
                            else Row_Pos127 - 1));
      Initialize_Fields_For_Isa
        (Self => Transform_Res95,
         Isa_F_Expr => Defer_Res156,
         Isa_F_Pattern => Defer_Res157);
         if Defer_Res156 /= null and then Is_Incomplete (Defer_Res156) then
            Transform_Res95.Last_Attempted_Child := 0;
         elsif Defer_Res156 /= null and then not Is_Ghost (Defer_Res156) then
            Transform_Res95.Last_Attempted_Child := -1;
         end if;
         if Defer_Res157 /= null and then Is_Incomplete (Defer_Res157) then
            Transform_Res95.Last_Attempted_Child := 0;
         elsif Defer_Res157 /= null and then not Is_Ghost (Defer_Res157) then
            Transform_Res95.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed24 then
      Transform_Res95.Last_Attempted_Child :=
         Row_Progress24;
      Append (Parser, Pos, "Cannot parse <isa_or_primary>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType Isa>) (root of 'isa_or_primary') at parser.lkt:406:11>
    if Row_Pos127 /= No_Token_Index then
        Or_Pos25 := Row_Pos127;
        Or_Res25 := Transform_Res95;
        goto Exit_Or28;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail25.Pos then
       Branch_Diag_Mark25 := Parser.Last_Diag;
       Branch_Last_Fail25 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark65;
    Parser.Last_Fail := Last_Fail25;
--  BEGIN <Transform(<ASTNodeType AnyOf>) (root of 'isa_or_primary') at parser.lkt:407:11>
--  pos=Row_Pos128, res=Transform_Res96, nobt=Nobt27
--  BEGIN <_Row (root of 'isa_or_primary') at parser.lkt:407:11>
--  pos=Row_Pos128, res=None, nobt=Nobt27
Row_Pos128 := Pos;
--  BEGIN <Defer (for 'primary') at parser.lkt:407:17>
--  pos=Defer_Pos158, res=Defer_Res158, nobt=None
Defer_Res158 :=
   Primary_Or_Parse0 (Parser, Row_Pos128);
Defer_Pos158 := Parser.Current_Pos;
--  END <Defer (for 'primary') at parser.lkt:407:17>
Row_Progress25 := 1;
if Defer_Pos158 /= No_Token_Index then
   Row_Pos128 := Defer_Pos158;
else
   Row_Pos128 := No_Token_Index;
   goto Exit_Row128_0;
end if;
--  BEGIN <Token(<WithText InKw>, ) (root of 'isa_or_primary') at parser.lkt:407:25>
--  pos=Token_Pos172, res=Token_Res172, nobt=None
Token_Res172 := Row_Pos128;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res172));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_In_Kw)
   then
       Token_Pos172 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos128 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos128,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_In_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos172 := Row_Pos128 + 1;
   end if;
end;
--  END <Token(<WithText InKw>, ) (root of 'isa_or_primary') at parser.lkt:407:25>
Row_Progress25 := 2;
if Token_Pos172 /= No_Token_Index then
   Row_Pos128 := Token_Pos172;
else
   Row_Pos128 := No_Token_Index;
   goto Exit_Row128_0;
end if;
--  BEGIN <Cut (root of 'isa_or_primary') at parser.lkt:407:30>
--  pos=Row_Pos128, res=None, nobt=Nobt27
Nobt27 := True;
--  END <Cut (root of 'isa_or_primary') at parser.lkt:407:30>
Row_Progress25 := 3;
if Row_Pos128 /= No_Token_Index then
   Row_Pos128 := Row_Pos128;
else
   Row_Pos128 := No_Token_Index;
   goto Exit_Row128_0;
end if;
--  BEGIN <List (root of 'isa_or_primary') at parser.lkt:407:32>
--  pos=List_Pos21, res=List_Res21, nobt=None
    List_Pos21 := No_Token_Index;
Lst_Cpos21 := Row_Pos128;
Tmp_List21 := Get_Parse_List (Parser);
Diag_Mark64 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'primary') at parser.lkt:407:43>
--  pos=Defer_Pos159, res=Defer_Res159, nobt=None
Defer_Res159 :=
   Primary_Or_Parse0 (Parser, Lst_Cpos21);
Defer_Pos159 := Parser.Current_Pos;
--  END <Defer (for 'primary') at parser.lkt:407:43>
   exit when Defer_Pos159 = No_Token_Index;
   List_Pos21 := Defer_Pos159;
   Lst_Cpos21 := List_Pos21;
   Diag_Mark64 := Parser.Last_Diag;
   Tmp_List21.Nodes.Append (Defer_Res159);
--  BEGIN <Token(<WithText Pipe>, ) (root of 'isa_or_primary') at parser.lkt:407:52>
--  pos=Token_Pos173, res=Token_Res173, nobt=None
Token_Res173 := Lst_Cpos21;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res173));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Pipe)
   then
       Token_Pos173 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Lst_Cpos21 then
          Parser.Last_Fail :=
            (Pos  => Lst_Cpos21,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Pipe,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos173 := Lst_Cpos21 + 1;
   end if;
end;
--  END <Token(<WithText Pipe>, ) (root of 'isa_or_primary') at parser.lkt:407:52>
      exit when Token_Pos173 = No_Token_Index;
      Lst_Cpos21 := Token_Pos173;
end loop;
Parser.Last_Diag := Diag_Mark64;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List21.Nodes.Length;
begin
   List_Res21 := Allocate_Any_Of_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos128;
      Token_End := (if Lst_Cpos21 = Row_Pos128
                    then Row_Pos128
                    else List_Pos21 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos128, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res21,
      Kind              => Lkt_Any_Of_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res21,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List21.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res21.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List21);
--  END <List (root of 'isa_or_primary') at parser.lkt:407:32>
Row_Progress25 := 4;
if List_Pos21 /= No_Token_Index then
   Row_Pos128 := List_Pos21;
else
   Row_Pos128 := No_Token_Index;
   goto Exit_Row128_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row128_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'isa_or_primary') at parser.lkt:407:11>
if Row_Pos128 = No_Token_Index and then Nobt27 then
   Row_Pos128 := Parser.Last_Fail.Pos;
   Transform_Has_Failed25 := True;
end if;
if Row_Pos128 /= No_Token_Index then
   Transform_Res96 := Allocate_Any_Of (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res96,
      Kind => Lkt_Any_Of,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos128 = Pos
                            then No_Token_Index
                            else Row_Pos128 - 1));
      Initialize_Fields_For_Any_Of
        (Self => Transform_Res96,
         Any_Of_F_Expr => Defer_Res158,
         Any_Of_F_Values => List_Res21);
         if Defer_Res158 /= null and then Is_Incomplete (Defer_Res158) then
            Transform_Res96.Last_Attempted_Child := 0;
         elsif Defer_Res158 /= null and then not Is_Ghost (Defer_Res158) then
            Transform_Res96.Last_Attempted_Child := -1;
         end if;
         if List_Res21 /= null and then Is_Incomplete (List_Res21) then
            Transform_Res96.Last_Attempted_Child := 0;
         elsif List_Res21 /= null and then not Is_Ghost (List_Res21) then
            Transform_Res96.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed25 then
      Transform_Res96.Last_Attempted_Child :=
         Row_Progress25;
      Append (Parser, Pos, "Cannot parse <isa_or_primary>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType AnyOf>) (root of 'isa_or_primary') at parser.lkt:407:11>
    if Row_Pos128 /= No_Token_Index then
        Or_Pos25 := Row_Pos128;
        Or_Res25 := Transform_Res96;
        goto Exit_Or28;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail25.Pos then
       Branch_Diag_Mark25 := Parser.Last_Diag;
       Branch_Last_Fail25 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark65;
    Parser.Last_Fail := Last_Fail25;
--  BEGIN <Transform(<ASTNodeType LogicUnify>) (root of 'isa_or_primary') at parser.lkt:408:11>
--  pos=Row_Pos129, res=Transform_Res97, nobt=Nobt28
--  BEGIN <_Row (root of 'isa_or_primary') at parser.lkt:408:11>
--  pos=Row_Pos129, res=None, nobt=Nobt28
Row_Pos129 := Pos;
--  BEGIN <Defer (for 'isa_or_primary') at parser.lkt:408:22>
--  pos=Defer_Pos160, res=Defer_Res160, nobt=None
Defer_Res160 :=
   Isa_Or_Primary_Or_Parse0 (Parser, Row_Pos129);
Defer_Pos160 := Parser.Current_Pos;
--  END <Defer (for 'isa_or_primary') at parser.lkt:408:22>
Row_Progress26 := 1;
if Defer_Pos160 /= No_Token_Index then
   Row_Pos129 := Defer_Pos160;
else
   Row_Pos129 := No_Token_Index;
   goto Exit_Row129_0;
end if;
--  BEGIN <Token(<WithText TwoSidedArrow>, ) (root of 'isa_or_primary') at parser.lkt:408:37>
--  pos=Token_Pos174, res=Token_Res174, nobt=None
Token_Res174 := Row_Pos129;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res174));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Two_Sided_Arrow)
   then
       Token_Pos174 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos129 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos129,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Two_Sided_Arrow,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos174 := Row_Pos129 + 1;
   end if;
end;
--  END <Token(<WithText TwoSidedArrow>, ) (root of 'isa_or_primary') at parser.lkt:408:37>
Row_Progress26 := 2;
if Token_Pos174 /= No_Token_Index then
   Row_Pos129 := Token_Pos174;
else
   Row_Pos129 := No_Token_Index;
   goto Exit_Row129_0;
end if;
--  BEGIN <Cut (root of 'isa_or_primary') at parser.lkt:408:43>
--  pos=Row_Pos129, res=None, nobt=Nobt28
Nobt28 := True;
--  END <Cut (root of 'isa_or_primary') at parser.lkt:408:43>
Row_Progress26 := 3;
if Row_Pos129 /= No_Token_Index then
   Row_Pos129 := Row_Pos129;
else
   Row_Pos129 := No_Token_Index;
   goto Exit_Row129_0;
end if;
--  BEGIN <Defer (for 'primary') at parser.lkt:408:45>
--  pos=Defer_Pos161, res=Defer_Res161, nobt=None
Defer_Res161 :=
   Primary_Or_Parse0 (Parser, Row_Pos129);
Defer_Pos161 := Parser.Current_Pos;
--  END <Defer (for 'primary') at parser.lkt:408:45>
Row_Progress26 := 4;
if Defer_Pos161 /= No_Token_Index then
   Row_Pos129 := Defer_Pos161;
else
   Row_Pos129 := No_Token_Index;
   goto Exit_Row129_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row129_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'isa_or_primary') at parser.lkt:408:11>
if Row_Pos129 = No_Token_Index and then Nobt28 then
   Row_Pos129 := Parser.Last_Fail.Pos;
   Transform_Has_Failed26 := True;
end if;
if Row_Pos129 /= No_Token_Index then
   Transform_Res97 := Allocate_Logic_Unify (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res97,
      Kind => Lkt_Logic_Unify,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos129 = Pos
                            then No_Token_Index
                            else Row_Pos129 - 1));
      Initialize_Fields_For_Logic_Unify
        (Self => Transform_Res97,
         Logic_Unify_F_Lhs => Defer_Res160,
         Logic_Unify_F_Rhs => Defer_Res161);
         if Defer_Res160 /= null and then Is_Incomplete (Defer_Res160) then
            Transform_Res97.Last_Attempted_Child := 0;
         elsif Defer_Res160 /= null and then not Is_Ghost (Defer_Res160) then
            Transform_Res97.Last_Attempted_Child := -1;
         end if;
         if Defer_Res161 /= null and then Is_Incomplete (Defer_Res161) then
            Transform_Res97.Last_Attempted_Child := 0;
         elsif Defer_Res161 /= null and then not Is_Ghost (Defer_Res161) then
            Transform_Res97.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed26 then
      Transform_Res97.Last_Attempted_Child :=
         Row_Progress26;
      Append (Parser, Pos, "Cannot parse <isa_or_primary>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType LogicUnify>) (root of 'isa_or_primary') at parser.lkt:408:11>
    if Row_Pos129 /= No_Token_Index then
        Or_Pos25 := Row_Pos129;
        Or_Res25 := Transform_Res97;
        goto Exit_Or28;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail25.Pos then
       Branch_Diag_Mark25 := Parser.Last_Diag;
       Branch_Last_Fail25 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark65;
    Parser.Last_Fail := Last_Fail25;
--  BEGIN <Transform(<ASTNodeType LogicPropagate>) (root of 'isa_or_primary') at parser.lkt:409:11>
--  pos=Row_Pos130, res=Transform_Res98, nobt=None
--  BEGIN <_Row (root of 'isa_or_primary') at parser.lkt:409:11>
--  pos=Row_Pos130, res=None, nobt=None
Row_Pos130 := Pos;
--  BEGIN <Defer (for 'isa_or_primary') at parser.lkt:409:26>
--  pos=Defer_Pos162, res=Defer_Res162, nobt=None
Defer_Res162 :=
   Isa_Or_Primary_Or_Parse0 (Parser, Row_Pos130);
Defer_Pos162 := Parser.Current_Pos;
--  END <Defer (for 'isa_or_primary') at parser.lkt:409:26>
if Defer_Pos162 /= No_Token_Index then
   Row_Pos130 := Defer_Pos162;
else
   Row_Pos130 := No_Token_Index;
   goto Exit_Row130_0;
end if;
--  BEGIN <Token(<WithText LeftArrow>, ) (root of 'isa_or_primary') at parser.lkt:409:41>
--  pos=Token_Pos175, res=Token_Res175, nobt=None
Token_Res175 := Row_Pos130;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res175));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Left_Arrow)
   then
       Token_Pos175 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos130 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos130,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Left_Arrow,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos175 := Row_Pos130 + 1;
   end if;
end;
--  END <Token(<WithText LeftArrow>, ) (root of 'isa_or_primary') at parser.lkt:409:41>
if Token_Pos175 /= No_Token_Index then
   Row_Pos130 := Token_Pos175;
else
   Row_Pos130 := No_Token_Index;
   goto Exit_Row130_0;
end if;
--  BEGIN <Defer (for 'logic_propagate_call') at parser.lkt:409:46>
--  pos=Defer_Pos163, res=Defer_Res163, nobt=None
Defer_Res163 :=
   Logic_Propagate_Call_Transform_Parse0 (Parser, Row_Pos130);
Defer_Pos163 := Parser.Current_Pos;
--  END <Defer (for 'logic_propagate_call') at parser.lkt:409:46>
if Defer_Pos163 /= No_Token_Index then
   Row_Pos130 := Defer_Pos163;
else
   Row_Pos130 := No_Token_Index;
   goto Exit_Row130_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row130_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'isa_or_primary') at parser.lkt:409:11>
if Row_Pos130 /= No_Token_Index then
   Transform_Res98 := Allocate_Logic_Propagate (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res98,
      Kind => Lkt_Logic_Propagate,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos130 = Pos
                            then No_Token_Index
                            else Row_Pos130 - 1));
      Initialize_Fields_For_Logic_Propagate
        (Self => Transform_Res98,
         Logic_Propagate_F_Dest_Var => Defer_Res162,
         Logic_Propagate_F_Call => Defer_Res163);
         if Defer_Res162 /= null and then Is_Incomplete (Defer_Res162) then
            Transform_Res98.Last_Attempted_Child := 0;
         elsif Defer_Res162 /= null and then not Is_Ghost (Defer_Res162) then
            Transform_Res98.Last_Attempted_Child := -1;
         end if;
         if Defer_Res163 /= null and then Is_Incomplete (Defer_Res163) then
            Transform_Res98.Last_Attempted_Child := 0;
         elsif Defer_Res163 /= null and then not Is_Ghost (Defer_Res163) then
            Transform_Res98.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType LogicPropagate>) (root of 'isa_or_primary') at parser.lkt:409:11>
    if Row_Pos130 /= No_Token_Index then
        Or_Pos25 := Row_Pos130;
        Or_Res25 := Transform_Res98;
        goto Exit_Or28;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail25.Pos then
       Branch_Diag_Mark25 := Parser.Last_Diag;
       Branch_Last_Fail25 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark65;
    Parser.Last_Fail := Last_Fail25;
--  BEGIN <Transform(<ASTNodeType LogicAssign>) (root of 'isa_or_primary') at parser.lkt:410:11>
--  pos=Row_Pos131, res=Transform_Res99, nobt=Nobt29
--  BEGIN <_Row (root of 'isa_or_primary') at parser.lkt:410:11>
--  pos=Row_Pos131, res=None, nobt=Nobt29
Row_Pos131 := Pos;
--  BEGIN <Defer (for 'isa_or_primary') at parser.lkt:410:23>
--  pos=Defer_Pos164, res=Defer_Res164, nobt=None
Defer_Res164 :=
   Isa_Or_Primary_Or_Parse0 (Parser, Row_Pos131);
Defer_Pos164 := Parser.Current_Pos;
--  END <Defer (for 'isa_or_primary') at parser.lkt:410:23>
Row_Progress27 := 1;
if Defer_Pos164 /= No_Token_Index then
   Row_Pos131 := Defer_Pos164;
else
   Row_Pos131 := No_Token_Index;
   goto Exit_Row131_0;
end if;
--  BEGIN <Token(<WithText LeftArrow>, ) (root of 'isa_or_primary') at parser.lkt:410:38>
--  pos=Token_Pos176, res=Token_Res176, nobt=None
Token_Res176 := Row_Pos131;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res176));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Left_Arrow)
   then
       Token_Pos176 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos131 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos131,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Left_Arrow,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos176 := Row_Pos131 + 1;
   end if;
end;
--  END <Token(<WithText LeftArrow>, ) (root of 'isa_or_primary') at parser.lkt:410:38>
Row_Progress27 := 2;
if Token_Pos176 /= No_Token_Index then
   Row_Pos131 := Token_Pos176;
else
   Row_Pos131 := No_Token_Index;
   goto Exit_Row131_0;
end if;
--  BEGIN <Cut (root of 'isa_or_primary') at parser.lkt:410:43>
--  pos=Row_Pos131, res=None, nobt=Nobt29
Nobt29 := True;
--  END <Cut (root of 'isa_or_primary') at parser.lkt:410:43>
Row_Progress27 := 3;
if Row_Pos131 /= No_Token_Index then
   Row_Pos131 := Row_Pos131;
else
   Row_Pos131 := No_Token_Index;
   goto Exit_Row131_0;
end if;
--  BEGIN <Defer (for 'primary') at parser.lkt:410:45>
--  pos=Defer_Pos165, res=Defer_Res165, nobt=None
Defer_Res165 :=
   Primary_Or_Parse0 (Parser, Row_Pos131);
Defer_Pos165 := Parser.Current_Pos;
--  END <Defer (for 'primary') at parser.lkt:410:45>
Row_Progress27 := 4;
if Defer_Pos165 /= No_Token_Index then
   Row_Pos131 := Defer_Pos165;
else
   Row_Pos131 := No_Token_Index;
   goto Exit_Row131_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row131_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'isa_or_primary') at parser.lkt:410:11>
if Row_Pos131 = No_Token_Index and then Nobt29 then
   Row_Pos131 := Parser.Last_Fail.Pos;
   Transform_Has_Failed27 := True;
end if;
if Row_Pos131 /= No_Token_Index then
   Transform_Res99 := Allocate_Logic_Assign (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res99,
      Kind => Lkt_Logic_Assign,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos131 = Pos
                            then No_Token_Index
                            else Row_Pos131 - 1));
      Initialize_Fields_For_Logic_Assign
        (Self => Transform_Res99,
         Logic_Assign_F_Dest_Var => Defer_Res164,
         Logic_Assign_F_Value => Defer_Res165);
         if Defer_Res164 /= null and then Is_Incomplete (Defer_Res164) then
            Transform_Res99.Last_Attempted_Child := 0;
         elsif Defer_Res164 /= null and then not Is_Ghost (Defer_Res164) then
            Transform_Res99.Last_Attempted_Child := -1;
         end if;
         if Defer_Res165 /= null and then Is_Incomplete (Defer_Res165) then
            Transform_Res99.Last_Attempted_Child := 0;
         elsif Defer_Res165 /= null and then not Is_Ghost (Defer_Res165) then
            Transform_Res99.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed27 then
      Transform_Res99.Last_Attempted_Child :=
         Row_Progress27;
      Append (Parser, Pos, "Cannot parse <isa_or_primary>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType LogicAssign>) (root of 'isa_or_primary') at parser.lkt:410:11>
    if Row_Pos131 /= No_Token_Index then
        Or_Pos25 := Row_Pos131;
        Or_Res25 := Transform_Res99;
        goto Exit_Or28;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail25.Pos then
       Branch_Diag_Mark25 := Parser.Last_Diag;
       Branch_Last_Fail25 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark65;
    Parser.Last_Fail := Last_Fail25;
--  BEGIN <Defer (for 'primary') at parser.lkt:411:11>
--  pos=Defer_Pos166, res=Defer_Res166, nobt=None
Defer_Res166 :=
   Primary_Or_Parse0 (Parser, Pos);
Defer_Pos166 := Parser.Current_Pos;
--  END <Defer (for 'primary') at parser.lkt:411:11>
    if Defer_Pos166 /= No_Token_Index then
        Or_Pos25 := Defer_Pos166;
        Or_Res25 := Defer_Res166;
        goto Exit_Or28;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail25.Pos then
       Branch_Diag_Mark25 := Parser.Last_Diag;
       Branch_Last_Fail25 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark25;
Parser.Last_Fail := Branch_Last_Fail25;
<<Exit_Or28>>
--  END <Or (root of 'isa_or_primary') at parser.lkt:405:23>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
      if Or_Pos25 > Mem_Pos then
         Mem_Pos := Or_Pos25;
         Mem_Res := Or_Res25;
         Mem_Mark := Parser.Last_Diag;
         if Or_Pos25 = No_Token_Index then
            Set_Failure (PP.Isa_Or_Primary_Or_Parse0_Memo, Pos, Parser.Last_Fail, Mem_Mark);
         else
            Memos.Set_Success
              (PP.Isa_Or_Primary_Or_Parse0_Memo,
               Pos,
               Or_Res25,
               Mem_Mark,
               Or_Pos25);
         end if;
         goto Try_Again;
      elsif Mem_Pos > Pos then
         Or_Res25 := Mem_Res;
         Or_Pos25 := Mem_Pos;
         Parser.Last_Diag := Mem_Mark;
         goto No_Memo;
      end if;
   if Or_Pos25 = No_Token_Index then
      Set_Failure
        (PP.Isa_Or_Primary_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Isa_Or_Primary_Or_Parse0_Memo, Pos, Or_Res25, Parser.Last_Diag, Or_Pos25);
   end if;
       <<No_Memo>>
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos25;
   return Or_Res25;
end Isa_Or_Primary_Or_Parse0;
   function Lambda_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lambda_Expr
is
      Nobt30 : Boolean := False;
      Row_Pos132 : Token_Index := No_Token_Index;
      Token_Pos177 : Token_Index := No_Token_Index;
      Token_Res177 : Token_Index := No_Token_Index;
      Defer_Pos167 : Token_Index := No_Token_Index;
      Defer_Res167 : Bare_Lambda_Param_Decl_List := No_Bare_Lkt_Node;
      Token_Pos178 : Token_Index := No_Token_Index;
      Token_Res178 : Token_Index := No_Token_Index;
      Row_Pos133 : Token_Index := No_Token_Index;
      Token_Pos179 : Token_Index := No_Token_Index;
      Token_Res179 : Token_Index := No_Token_Index;
      Defer_Pos168 : Token_Index := No_Token_Index;
      Defer_Res168 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Diag_Mark66 : Diagnostic_Mark;
      Token_Pos180 : Token_Index := No_Token_Index;
      Token_Res180 : Token_Index := No_Token_Index;
      Defer_Pos169 : Token_Index := No_Token_Index;
      Defer_Res169 : Bare_Expr := No_Bare_Lkt_Node;
      Row_Progress28 : Integer := 0;
      Transform_Res100 : Bare_Lambda_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed28 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Lambda_Expr_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res100 := M.Instance;
      return Transform_Res100;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res100;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType LambdaExpr>) (root of 'lambda_expr') at parser.lkt:499:20>
--  pos=Row_Pos132, res=Transform_Res100, nobt=Nobt30
--  BEGIN <_Row (root of 'lambda_expr') at parser.lkt:499:20>
--  pos=Row_Pos132, res=None, nobt=Nobt30
Row_Pos132 := Pos;
--  BEGIN <Token(<WithText LPar>, ) (root of 'lambda_expr') at parser.lkt:500:9>
--  pos=Token_Pos177, res=Token_Res177, nobt=None
Token_Res177 := Row_Pos132;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res177));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos177 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos132 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos132,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos177 := Row_Pos132 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'lambda_expr') at parser.lkt:500:9>
Row_Progress28 := 1;
if Token_Pos177 /= No_Token_Index then
   Row_Pos132 := Token_Pos177;
else
   Row_Pos132 := No_Token_Index;
   goto Exit_Row132_0;
end if;
--  BEGIN <Defer (for 'lambda_param_list') at parser.lkt:500:13>
--  pos=Defer_Pos167, res=Defer_Res167, nobt=None
Defer_Res167 :=
   Lambda_Param_List_List_Parse0 (Parser, Row_Pos132);
Defer_Pos167 := Parser.Current_Pos;
--  END <Defer (for 'lambda_param_list') at parser.lkt:500:13>
Row_Progress28 := 2;
if Defer_Pos167 /= No_Token_Index then
   Row_Pos132 := Defer_Pos167;
else
   Row_Pos132 := No_Token_Index;
   goto Exit_Row132_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'lambda_expr') at parser.lkt:500:31>
--  pos=Token_Pos178, res=Token_Res178, nobt=None
Token_Res178 := Row_Pos132;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res178));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos178 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos132 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos132,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos178 := Row_Pos132 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'lambda_expr') at parser.lkt:500:31>
Row_Progress28 := 3;
if Token_Pos178 /= No_Token_Index then
   Row_Pos132 := Token_Pos178;
else
   Row_Pos132 := No_Token_Index;
   goto Exit_Row132_0;
end if;
--  BEGIN <Opt (root of 'lambda_expr') at parser.lkt:500:35>
--  pos=Row_Pos133, res=Defer_Res168, nobt=None
Diag_Mark66 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'lambda_expr') at parser.lkt:500:36>
--  pos=Row_Pos133, res=Defer_Res168, nobt=None
--  BEGIN <_Row (root of 'lambda_expr') at parser.lkt:500:36>
--  pos=Row_Pos133, res=None, nobt=None
Row_Pos133 := Row_Pos132;
--  BEGIN <Token(<WithText Colon>, ) (root of 'lambda_expr') at parser.lkt:500:41>
--  pos=Token_Pos179, res=Token_Res179, nobt=None
Token_Res179 := Row_Pos133;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res179));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos179 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos133 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos133,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Colon,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos179 := Row_Pos133 + 1;
   end if;
end;
--  END <Token(<WithText Colon>, ) (root of 'lambda_expr') at parser.lkt:500:41>
if Token_Pos179 /= No_Token_Index then
   Row_Pos133 := Token_Pos179;
else
   Row_Pos133 := No_Token_Index;
   goto Exit_Row133_0;
end if;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:500:45>
--  pos=Defer_Pos168, res=Defer_Res168, nobt=None
Defer_Res168 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos133);
Defer_Pos168 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:500:45>
if Defer_Pos168 /= No_Token_Index then
   Row_Pos133 := Defer_Pos168;
else
   Row_Pos133 := No_Token_Index;
   goto Exit_Row133_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row133_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'lambda_expr') at parser.lkt:500:36>
--  END <_Extract (root of 'lambda_expr') at parser.lkt:500:36>
if Row_Pos133 = No_Token_Index then
   Defer_Res168 := No_Bare_Lkt_Node;
   Row_Pos133 := Row_Pos132;
      Parser.Last_Diag := Diag_Mark66;
end if;
--  END <Opt (root of 'lambda_expr') at parser.lkt:500:35>
Row_Progress28 := 4;
if Row_Pos133 /= No_Token_Index then
   Row_Pos132 := Row_Pos133;
else
   Row_Pos132 := No_Token_Index;
   goto Exit_Row132_0;
end if;
--  BEGIN <Token(<WithText FatRightArrow>, ) (root of 'lambda_expr') at parser.lkt:500:55>
--  pos=Token_Pos180, res=Token_Res180, nobt=None
Token_Res180 := Row_Pos132;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res180));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Fat_Right_Arrow)
   then
       Token_Pos180 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos132 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos132,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Fat_Right_Arrow,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos180 := Row_Pos132 + 1;
   end if;
end;
--  END <Token(<WithText FatRightArrow>, ) (root of 'lambda_expr') at parser.lkt:500:55>
Row_Progress28 := 5;
if Token_Pos180 /= No_Token_Index then
   Row_Pos132 := Token_Pos180;
else
   Row_Pos132 := No_Token_Index;
   goto Exit_Row132_0;
end if;
--  BEGIN <Cut (root of 'lambda_expr') at parser.lkt:500:60>
--  pos=Row_Pos132, res=None, nobt=Nobt30
Nobt30 := True;
--  END <Cut (root of 'lambda_expr') at parser.lkt:500:60>
Row_Progress28 := 6;
if Row_Pos132 /= No_Token_Index then
   Row_Pos132 := Row_Pos132;
else
   Row_Pos132 := No_Token_Index;
   goto Exit_Row132_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:500:62>
--  pos=Defer_Pos169, res=Defer_Res169, nobt=None
Defer_Res169 :=
   Expr_Or_Parse0 (Parser, Row_Pos132);
Defer_Pos169 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:500:62>
Row_Progress28 := 7;
if Defer_Pos169 /= No_Token_Index then
   Row_Pos132 := Defer_Pos169;
else
   Row_Pos132 := No_Token_Index;
   goto Exit_Row132_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row132_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'lambda_expr') at parser.lkt:499:20>
if Row_Pos132 = No_Token_Index and then Nobt30 then
   Row_Pos132 := Parser.Last_Fail.Pos;
   Transform_Has_Failed28 := True;
end if;
if Row_Pos132 /= No_Token_Index then
   Transform_Res100 := Allocate_Lambda_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res100,
      Kind => Lkt_Lambda_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos132 = Pos
                            then No_Token_Index
                            else Row_Pos132 - 1));
      Initialize_Fields_For_Lambda_Expr
        (Self => Transform_Res100,
         Lambda_Expr_F_Params => Defer_Res167,
         Lambda_Expr_F_Return_Type => Defer_Res168,
         Lambda_Expr_F_Body => Defer_Res169);
         if Defer_Res167 /= null and then Is_Incomplete (Defer_Res167) then
            Transform_Res100.Last_Attempted_Child := 0;
         elsif Defer_Res167 /= null and then not Is_Ghost (Defer_Res167) then
            Transform_Res100.Last_Attempted_Child := -1;
         end if;
         if Defer_Res168 /= null and then Is_Incomplete (Defer_Res168) then
            Transform_Res100.Last_Attempted_Child := 0;
         elsif Defer_Res168 /= null and then not Is_Ghost (Defer_Res168) then
            Transform_Res100.Last_Attempted_Child := -1;
         end if;
         if Defer_Res169 /= null and then Is_Incomplete (Defer_Res169) then
            Transform_Res100.Last_Attempted_Child := 0;
         elsif Defer_Res169 /= null and then not Is_Ghost (Defer_Res169) then
            Transform_Res100.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed28 then
      Transform_Res100.Last_Attempted_Child :=
         Row_Progress28;
      Append (Parser, Pos, "Cannot parse <lambda_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType LambdaExpr>) (root of 'lambda_expr') at parser.lkt:499:20>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos132 = No_Token_Index then
      Set_Failure
        (PP.Lambda_Expr_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Lambda_Expr_Transform_Parse0_Memo, Pos, Transform_Res100, Parser.Last_Diag, Row_Pos132);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos132;
   return Transform_Res100;
end Lambda_Expr_Transform_Parse0;
   function Lambda_Param_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lambda_Param_Decl
is
      Row_Pos134 : Token_Index := No_Token_Index;
      Defer_Pos170 : Token_Index := No_Token_Index;
      Defer_Res170 : Bare_Def_Id := No_Bare_Lkt_Node;
      Row_Pos135 : Token_Index := No_Token_Index;
      Token_Pos181 : Token_Index := No_Token_Index;
      Token_Res181 : Token_Index := No_Token_Index;
      Defer_Pos171 : Token_Index := No_Token_Index;
      Defer_Res171 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Diag_Mark67 : Diagnostic_Mark;
      Row_Pos136 : Token_Index := No_Token_Index;
      Token_Pos182 : Token_Index := No_Token_Index;
      Token_Res182 : Token_Index := No_Token_Index;
      Defer_Pos172 : Token_Index := No_Token_Index;
      Defer_Res172 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark68 : Diagnostic_Mark;
      Transform_Res101 : Bare_Lambda_Param_Decl := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Lambda_Param_Decl_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res101 := M.Instance;
      return Transform_Res101;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res101;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType LambdaParamDecl>) (root of 'lambda_param_decl') at parser.lkt:241:26>
--  pos=Row_Pos134, res=Transform_Res101, nobt=None
--  BEGIN <_Row (root of 'lambda_param_decl') at parser.lkt:241:26>
--  pos=Row_Pos134, res=None, nobt=None
Row_Pos134 := Pos;
--  BEGIN <Defer (for 'def_id') at parser.lkt:242:9>
--  pos=Defer_Pos170, res=Defer_Res170, nobt=None
Defer_Res170 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos134);
Defer_Pos170 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:242:9>
if Defer_Pos170 /= No_Token_Index then
   Row_Pos134 := Defer_Pos170;
else
   Row_Pos134 := No_Token_Index;
   goto Exit_Row134_0;
end if;
--  BEGIN <Opt (root of 'lambda_param_decl') at parser.lkt:242:16>
--  pos=Row_Pos135, res=Defer_Res171, nobt=None
Diag_Mark67 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'lambda_param_decl') at parser.lkt:242:17>
--  pos=Row_Pos135, res=Defer_Res171, nobt=None
--  BEGIN <_Row (root of 'lambda_param_decl') at parser.lkt:242:17>
--  pos=Row_Pos135, res=None, nobt=None
Row_Pos135 := Row_Pos134;
--  BEGIN <Token(<WithText Colon>, ) (root of 'lambda_param_decl') at parser.lkt:242:22>
--  pos=Token_Pos181, res=Token_Res181, nobt=None
Token_Res181 := Row_Pos135;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res181));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos181 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos135 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos135,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Colon,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos181 := Row_Pos135 + 1;
   end if;
end;
--  END <Token(<WithText Colon>, ) (root of 'lambda_param_decl') at parser.lkt:242:22>
if Token_Pos181 /= No_Token_Index then
   Row_Pos135 := Token_Pos181;
else
   Row_Pos135 := No_Token_Index;
   goto Exit_Row135_0;
end if;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:242:26>
--  pos=Defer_Pos171, res=Defer_Res171, nobt=None
Defer_Res171 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos135);
Defer_Pos171 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:242:26>
if Defer_Pos171 /= No_Token_Index then
   Row_Pos135 := Defer_Pos171;
else
   Row_Pos135 := No_Token_Index;
   goto Exit_Row135_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row135_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'lambda_param_decl') at parser.lkt:242:17>
--  END <_Extract (root of 'lambda_param_decl') at parser.lkt:242:17>
if Row_Pos135 = No_Token_Index then
   Defer_Res171 := No_Bare_Lkt_Node;
   Row_Pos135 := Row_Pos134;
      Parser.Last_Diag := Diag_Mark67;
end if;
--  END <Opt (root of 'lambda_param_decl') at parser.lkt:242:16>
if Row_Pos135 /= No_Token_Index then
   Row_Pos134 := Row_Pos135;
else
   Row_Pos134 := No_Token_Index;
   goto Exit_Row134_0;
end if;
--  BEGIN <Opt (root of 'lambda_param_decl') at parser.lkt:242:36>
--  pos=Row_Pos136, res=Defer_Res172, nobt=None
Diag_Mark68 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'lambda_param_decl') at parser.lkt:242:37>
--  pos=Row_Pos136, res=Defer_Res172, nobt=None
--  BEGIN <_Row (root of 'lambda_param_decl') at parser.lkt:242:37>
--  pos=Row_Pos136, res=None, nobt=None
Row_Pos136 := Row_Pos134;
--  BEGIN <Token(<WithText Equal>, ) (root of 'lambda_param_decl') at parser.lkt:242:42>
--  pos=Token_Pos182, res=Token_Res182, nobt=None
Token_Res182 := Row_Pos136;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res182));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Equal)
   then
       Token_Pos182 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos136 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos136,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Equal,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos182 := Row_Pos136 + 1;
   end if;
end;
--  END <Token(<WithText Equal>, ) (root of 'lambda_param_decl') at parser.lkt:242:42>
if Token_Pos182 /= No_Token_Index then
   Row_Pos136 := Token_Pos182;
else
   Row_Pos136 := No_Token_Index;
   goto Exit_Row136_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:242:46>
--  pos=Defer_Pos172, res=Defer_Res172, nobt=None
Defer_Res172 :=
   Expr_Or_Parse0 (Parser, Row_Pos136);
Defer_Pos172 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:242:46>
if Defer_Pos172 /= No_Token_Index then
   Row_Pos136 := Defer_Pos172;
else
   Row_Pos136 := No_Token_Index;
   goto Exit_Row136_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row136_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'lambda_param_decl') at parser.lkt:242:37>
--  END <_Extract (root of 'lambda_param_decl') at parser.lkt:242:37>
if Row_Pos136 = No_Token_Index then
   Defer_Res172 := No_Bare_Lkt_Node;
   Row_Pos136 := Row_Pos134;
      Parser.Last_Diag := Diag_Mark68;
end if;
--  END <Opt (root of 'lambda_param_decl') at parser.lkt:242:36>
if Row_Pos136 /= No_Token_Index then
   Row_Pos134 := Row_Pos136;
else
   Row_Pos134 := No_Token_Index;
   goto Exit_Row134_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row134_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'lambda_param_decl') at parser.lkt:241:26>
if Row_Pos134 /= No_Token_Index then
   Transform_Res101 := Allocate_Lambda_Param_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res101,
      Kind => Lkt_Lambda_Param_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos134 = Pos
                            then No_Token_Index
                            else Row_Pos134 - 1));
      Initialize_Fields_For_Lambda_Param_Decl
        (Self => Transform_Res101,
         Lambda_Param_Decl_F_Syn_Name => Defer_Res170,
         Lambda_Param_Decl_F_Decl_Type => Defer_Res171,
         Lambda_Param_Decl_F_Default_Val => Defer_Res172);
         if Defer_Res170 /= null and then Is_Incomplete (Defer_Res170) then
            Transform_Res101.Last_Attempted_Child := 0;
         elsif Defer_Res170 /= null and then not Is_Ghost (Defer_Res170) then
            Transform_Res101.Last_Attempted_Child := -1;
         end if;
         if Defer_Res171 /= null and then Is_Incomplete (Defer_Res171) then
            Transform_Res101.Last_Attempted_Child := 0;
         elsif Defer_Res171 /= null and then not Is_Ghost (Defer_Res171) then
            Transform_Res101.Last_Attempted_Child := -1;
         end if;
         if Defer_Res172 /= null and then Is_Incomplete (Defer_Res172) then
            Transform_Res101.Last_Attempted_Child := 0;
         elsif Defer_Res172 /= null and then not Is_Ghost (Defer_Res172) then
            Transform_Res101.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType LambdaParamDecl>) (root of 'lambda_param_decl') at parser.lkt:241:26>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos134 = No_Token_Index then
      Set_Failure
        (PP.Lambda_Param_Decl_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Lambda_Param_Decl_Transform_Parse0_Memo, Pos, Transform_Res101, Parser.Last_Diag, Row_Pos134);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos134;
   return Transform_Res101;
end Lambda_Param_Decl_Transform_Parse0;
   function Lambda_Param_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lambda_Param_Decl_List
is
      Lst_Cpos22 : Token_Index := No_Token_Index;
      Tmp_List22 : Free_Parse_List;
      Defer_Pos173 : Token_Index := No_Token_Index;
      Defer_Res173 : Bare_Lambda_Param_Decl := No_Bare_Lkt_Node;
      Token_Pos183 : Token_Index := No_Token_Index;
      Token_Res183 : Token_Index := No_Token_Index;
      List_Pos22 : Token_Index := No_Token_Index;
      List_Res22 : Bare_Lambda_Param_Decl_List := No_Bare_Lkt_Node;
      Diag_Mark69 : Diagnostic_Mark;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Lambda_Param_List_List_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      List_Res22 := M.Instance;
      return List_Res22;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return List_Res22;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <List (root of 'lambda_param_list') at parser.lkt:248:26>
--  pos=List_Pos22, res=List_Res22, nobt=None
    List_Pos22 := Pos;
Lst_Cpos22 := Pos;
Tmp_List22 := Get_Parse_List (Parser);
Diag_Mark69 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'lambda_param_decl') at parser.lkt:248:32>
--  pos=Defer_Pos173, res=Defer_Res173, nobt=None
Defer_Res173 :=
   Lambda_Param_Decl_Transform_Parse0 (Parser, Lst_Cpos22);
Defer_Pos173 := Parser.Current_Pos;
--  END <Defer (for 'lambda_param_decl') at parser.lkt:248:32>
   exit when Defer_Pos173 = No_Token_Index;
   List_Pos22 := Defer_Pos173;
   Lst_Cpos22 := List_Pos22;
   Diag_Mark69 := Parser.Last_Diag;
   Tmp_List22.Nodes.Append (Defer_Res173);
--  BEGIN <Token(<WithText Comma>, ) (root of 'lambda_param_list') at parser.lkt:248:51>
--  pos=Token_Pos183, res=Token_Res183, nobt=None
Token_Res183 := Lst_Cpos22;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res183));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos183 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Lst_Cpos22 then
          Parser.Last_Fail :=
            (Pos  => Lst_Cpos22,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Comma,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos183 := Lst_Cpos22 + 1;
   end if;
end;
--  END <Token(<WithText Comma>, ) (root of 'lambda_param_list') at parser.lkt:248:51>
      exit when Token_Pos183 = No_Token_Index;
      Lst_Cpos22 := Token_Pos183;
end loop;
Parser.Last_Diag := Diag_Mark69;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List22.Nodes.Length;
begin
   List_Res22 := Allocate_Lambda_Param_Decl_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos22 = Pos
                    then Pos
                    else List_Pos22 - 1);
   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res22,
      Kind              => Lkt_Lambda_Param_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res22,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List22.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res22.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List22);
--  END <List (root of 'lambda_param_list') at parser.lkt:248:26>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if List_Pos22 = No_Token_Index then
      Set_Failure
        (PP.Lambda_Param_List_List_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Lambda_Param_List_List_Parse0_Memo, Pos, List_Res22, Parser.Last_Diag, List_Pos22);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := List_Pos22;
   return List_Res22;
end Lambda_Param_List_List_Parse0;
   function Lexer_Case_Alt_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Base_Lexer_Case_Rule_Alt
is
      Nobt31 : Boolean := False;
      Nobt32 : Boolean := False;
      Row_Pos137 : Token_Index := No_Token_Index;
      Token_Pos184 : Token_Index := No_Token_Index;
      Token_Res184 : Token_Index := No_Token_Index;
      Token_Pos185 : Token_Index := No_Token_Index;
      Token_Res185 : Token_Index := No_Token_Index;
      Token_Pos186 : Token_Index := No_Token_Index;
      Token_Res186 : Token_Index := No_Token_Index;
      Lst_Cpos23 : Token_Index := No_Token_Index;
      Tmp_List23 : Free_Parse_List;
      Defer_Pos174 : Token_Index := No_Token_Index;
      Defer_Res174 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Token_Pos187 : Token_Index := No_Token_Index;
      Token_Res187 : Token_Index := No_Token_Index;
      List_Pos23 : Token_Index := No_Token_Index;
      List_Res23 : Bare_Ref_Id_List := No_Bare_Lkt_Node;
      Diag_Mark70 : Diagnostic_Mark;
      Token_Pos188 : Token_Index := No_Token_Index;
      Token_Res188 : Token_Index := No_Token_Index;
      Defer_Pos175 : Token_Index := No_Token_Index;
      Defer_Res175 : Bare_Lexer_Case_Rule_Send := No_Bare_Lkt_Node;
      Row_Progress29 : Integer := 0;
      Transform_Res102 : Bare_Lexer_Case_Rule_Cond_Alt := No_Bare_Lkt_Node;
      Transform_Has_Failed29 : Boolean := False;
      Row_Pos138 : Token_Index := No_Token_Index;
      Token_Pos189 : Token_Index := No_Token_Index;
      Token_Res189 : Token_Index := No_Token_Index;
      Defer_Pos176 : Token_Index := No_Token_Index;
      Defer_Res176 : Bare_Lexer_Case_Rule_Send := No_Bare_Lkt_Node;
      Row_Progress30 : Integer := 0;
      Transform_Res103 : Bare_Lexer_Case_Rule_Default_Alt := No_Bare_Lkt_Node;
      Transform_Has_Failed30 : Boolean := False;
      Row_Pos139 : Token_Index := No_Token_Index;
      Transform_Res104 : Bare_Error_Lexer_Case_Rule_Alt := No_Bare_Lkt_Node;
      Skip_Pos3 : Token_Index := No_Token_Index;
      Skip_Dummy3 : Bare_Lkt_Node := No_Bare_Lkt_Node;
      Or_Pos26 : Token_Index := No_Token_Index;
      Or_Res26 : Bare_Base_Lexer_Case_Rule_Alt := No_Bare_Lkt_Node;
      Diag_Mark71 : Diagnostic_Mark;
      Last_Fail26 : Fail_Info;
      Branch_Diag_Mark26 : Diagnostic_Mark;
      Branch_Last_Fail26 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Lexer_Case_Alt_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res26 := M.Instance;
      return Or_Res26;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res26;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'lexer_case_alt') at parser.lkt:48:23>
--  pos=Or_Pos26, res=Or_Res26, nobt=None
Or_Pos26 := No_Token_Index;
Or_Res26 := No_Bare_Lkt_Node;
Diag_Mark71 := Parser.Last_Diag;
Last_Fail26 := Parser.Last_Fail;
Branch_Diag_Mark26 := Parser.Last_Diag;
Branch_Last_Fail26 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark71;
    Parser.Last_Fail := Last_Fail26;
--  BEGIN <Transform(<ASTNodeType LexerCaseRuleCondAlt>) (root of 'lexer_case_alt') at parser.lkt:49:11>
--  pos=Row_Pos137, res=Transform_Res102, nobt=Nobt31
--  BEGIN <_Row (root of 'lexer_case_alt') at parser.lkt:49:11>
--  pos=Row_Pos137, res=None, nobt=Nobt31
Row_Pos137 := Pos;
--  BEGIN <Token(<WithText IfKw>, ) (root of 'lexer_case_alt') at parser.lkt:50:13>
--  pos=Token_Pos184, res=Token_Res184, nobt=None
Token_Res184 := Row_Pos137;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res184));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_If_Kw)
   then
       Token_Pos184 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos137 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos137,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_If_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos184 := Row_Pos137 + 1;
   end if;
end;
--  END <Token(<WithText IfKw>, ) (root of 'lexer_case_alt') at parser.lkt:50:13>
Row_Progress29 := 1;
if Token_Pos184 /= No_Token_Index then
   Row_Pos137 := Token_Pos184;
else
   Row_Pos137 := No_Token_Index;
   goto Exit_Row137_0;
end if;
--  BEGIN <Cut (root of 'lexer_case_alt') at parser.lkt:51:13>
--  pos=Row_Pos137, res=None, nobt=Nobt31
Nobt31 := True;
--  END <Cut (root of 'lexer_case_alt') at parser.lkt:51:13>
Row_Progress29 := 2;
if Row_Pos137 /= No_Token_Index then
   Row_Pos137 := Row_Pos137;
else
   Row_Pos137 := No_Token_Index;
   goto Exit_Row137_0;
end if;
--  BEGIN <Token(<WithSymbol Identifier>, previous_token) (root of 'lexer_case_alt') at parser.lkt:52:13>
--  pos=Token_Pos185, res=Token_Res185, nobt=None
Token_Res185 := Row_Pos137;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res185));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Previous_Token)
   then
       Token_Pos185 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos137 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos137,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos185 := Row_Pos137 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, previous_token) (root of 'lexer_case_alt') at parser.lkt:52:13>
Row_Progress29 := 3;
if Token_Pos185 /= No_Token_Index then
   Row_Pos137 := Token_Pos185;
else
   Row_Pos137 := No_Token_Index;
   goto Exit_Row137_0;
end if;
--  BEGIN <Token(<WithText IsKw>, ) (root of 'lexer_case_alt') at parser.lkt:53:13>
--  pos=Token_Pos186, res=Token_Res186, nobt=None
Token_Res186 := Row_Pos137;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res186));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Is_Kw)
   then
       Token_Pos186 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos137 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos137,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Is_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos186 := Row_Pos137 + 1;
   end if;
end;
--  END <Token(<WithText IsKw>, ) (root of 'lexer_case_alt') at parser.lkt:53:13>
Row_Progress29 := 4;
if Token_Pos186 /= No_Token_Index then
   Row_Pos137 := Token_Pos186;
else
   Row_Pos137 := No_Token_Index;
   goto Exit_Row137_0;
end if;
--  BEGIN <List (root of 'lexer_case_alt') at parser.lkt:54:13>
--  pos=List_Pos23, res=List_Res23, nobt=None
    List_Pos23 := No_Token_Index;
Lst_Cpos23 := Row_Pos137;
Tmp_List23 := Get_Parse_List (Parser);
Diag_Mark70 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'ref_id') at parser.lkt:54:19>
--  pos=Defer_Pos174, res=Defer_Res174, nobt=None
Defer_Res174 :=
   Ref_Id_Transform_Parse0 (Parser, Lst_Cpos23);
Defer_Pos174 := Parser.Current_Pos;
--  END <Defer (for 'ref_id') at parser.lkt:54:19>
   exit when Defer_Pos174 = No_Token_Index;
   List_Pos23 := Defer_Pos174;
   Lst_Cpos23 := List_Pos23;
   Diag_Mark70 := Parser.Last_Diag;
   Tmp_List23.Nodes.Append (Defer_Res174);
--  BEGIN <Token(<WithText Pipe>, ) (root of 'lexer_case_alt') at parser.lkt:54:27>
--  pos=Token_Pos187, res=Token_Res187, nobt=None
Token_Res187 := Lst_Cpos23;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res187));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Pipe)
   then
       Token_Pos187 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Lst_Cpos23 then
          Parser.Last_Fail :=
            (Pos  => Lst_Cpos23,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Pipe,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos187 := Lst_Cpos23 + 1;
   end if;
end;
--  END <Token(<WithText Pipe>, ) (root of 'lexer_case_alt') at parser.lkt:54:27>
      exit when Token_Pos187 = No_Token_Index;
      Lst_Cpos23 := Token_Pos187;
end loop;
Parser.Last_Diag := Diag_Mark70;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List23.Nodes.Length;
begin
   List_Res23 := Allocate_Ref_Id_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos137;
      Token_End := (if Lst_Cpos23 = Row_Pos137
                    then Row_Pos137
                    else List_Pos23 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos137, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res23,
      Kind              => Lkt_Ref_Id_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res23,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List23.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res23.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List23);
--  END <List (root of 'lexer_case_alt') at parser.lkt:54:13>
Row_Progress29 := 5;
if List_Pos23 /= No_Token_Index then
   Row_Pos137 := List_Pos23;
else
   Row_Pos137 := No_Token_Index;
   goto Exit_Row137_0;
end if;
--  BEGIN <Token(<WithText ThenKw>, ) (root of 'lexer_case_alt') at parser.lkt:55:13>
--  pos=Token_Pos188, res=Token_Res188, nobt=None
Token_Res188 := Row_Pos137;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res188));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Then_Kw)
   then
       Token_Pos188 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos137 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos137,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Then_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos188 := Row_Pos137 + 1;
   end if;
end;
--  END <Token(<WithText ThenKw>, ) (root of 'lexer_case_alt') at parser.lkt:55:13>
Row_Progress29 := 6;
if Token_Pos188 /= No_Token_Index then
   Row_Pos137 := Token_Pos188;
else
   Row_Pos137 := No_Token_Index;
   goto Exit_Row137_0;
end if;
--  BEGIN <Defer (for 'lexer_case_send') at parser.lkt:56:13>
--  pos=Defer_Pos175, res=Defer_Res175, nobt=None
Defer_Res175 :=
   Lexer_Case_Send_Transform_Parse0 (Parser, Row_Pos137);
Defer_Pos175 := Parser.Current_Pos;
--  END <Defer (for 'lexer_case_send') at parser.lkt:56:13>
Row_Progress29 := 7;
if Defer_Pos175 /= No_Token_Index then
   Row_Pos137 := Defer_Pos175;
else
   Row_Pos137 := No_Token_Index;
   goto Exit_Row137_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row137_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'lexer_case_alt') at parser.lkt:49:11>
if Row_Pos137 = No_Token_Index and then Nobt31 then
   Row_Pos137 := Parser.Last_Fail.Pos;
   Transform_Has_Failed29 := True;
end if;
if Row_Pos137 /= No_Token_Index then
   Transform_Res102 := Allocate_Lexer_Case_Rule_Cond_Alt (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res102,
      Kind => Lkt_Lexer_Case_Rule_Cond_Alt,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos137 = Pos
                            then No_Token_Index
                            else Row_Pos137 - 1));
      Initialize_Fields_For_Lexer_Case_Rule_Cond_Alt
        (Self => Transform_Res102,
         Lexer_Case_Rule_Cond_Alt_F_Cond_Exprs => List_Res23,
         Lexer_Case_Rule_Cond_Alt_F_Send => Defer_Res175);
         if List_Res23 /= null and then Is_Incomplete (List_Res23) then
            Transform_Res102.Last_Attempted_Child := 0;
         elsif List_Res23 /= null and then not Is_Ghost (List_Res23) then
            Transform_Res102.Last_Attempted_Child := -1;
         end if;
         if Defer_Res175 /= null and then Is_Incomplete (Defer_Res175) then
            Transform_Res102.Last_Attempted_Child := 0;
         elsif Defer_Res175 /= null and then not Is_Ghost (Defer_Res175) then
            Transform_Res102.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed29 then
      Transform_Res102.Last_Attempted_Child :=
         Row_Progress29;
      Append (Parser, Pos, "Cannot parse <lexer_case_alt>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType LexerCaseRuleCondAlt>) (root of 'lexer_case_alt') at parser.lkt:49:11>
    if Row_Pos137 /= No_Token_Index then
        Or_Pos26 := Row_Pos137;
        Or_Res26 := Transform_Res102;
        goto Exit_Or29;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail26.Pos then
       Branch_Diag_Mark26 := Parser.Last_Diag;
       Branch_Last_Fail26 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark71;
    Parser.Last_Fail := Last_Fail26;
--  BEGIN <Transform(<ASTNodeType LexerCaseRuleDefaultAlt>) (root of 'lexer_case_alt') at parser.lkt:58:11>
--  pos=Row_Pos138, res=Transform_Res103, nobt=Nobt32
--  BEGIN <_Row (root of 'lexer_case_alt') at parser.lkt:58:11>
--  pos=Row_Pos138, res=None, nobt=Nobt32
Row_Pos138 := Pos;
--  BEGIN <Token(<WithText ElseKw>, ) (root of 'lexer_case_alt') at parser.lkt:58:35>
--  pos=Token_Pos189, res=Token_Res189, nobt=None
Token_Res189 := Row_Pos138;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res189));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Else_Kw)
   then
       Token_Pos189 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos138 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos138,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Else_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos189 := Row_Pos138 + 1;
   end if;
end;
--  END <Token(<WithText ElseKw>, ) (root of 'lexer_case_alt') at parser.lkt:58:35>
Row_Progress30 := 1;
if Token_Pos189 /= No_Token_Index then
   Row_Pos138 := Token_Pos189;
else
   Row_Pos138 := No_Token_Index;
   goto Exit_Row138_0;
end if;
--  BEGIN <Cut (root of 'lexer_case_alt') at parser.lkt:58:42>
--  pos=Row_Pos138, res=None, nobt=Nobt32
Nobt32 := True;
--  END <Cut (root of 'lexer_case_alt') at parser.lkt:58:42>
Row_Progress30 := 2;
if Row_Pos138 /= No_Token_Index then
   Row_Pos138 := Row_Pos138;
else
   Row_Pos138 := No_Token_Index;
   goto Exit_Row138_0;
end if;
--  BEGIN <Defer (for 'lexer_case_send') at parser.lkt:58:44>
--  pos=Defer_Pos176, res=Defer_Res176, nobt=None
Defer_Res176 :=
   Lexer_Case_Send_Transform_Parse0 (Parser, Row_Pos138);
Defer_Pos176 := Parser.Current_Pos;
--  END <Defer (for 'lexer_case_send') at parser.lkt:58:44>
Row_Progress30 := 3;
if Defer_Pos176 /= No_Token_Index then
   Row_Pos138 := Defer_Pos176;
else
   Row_Pos138 := No_Token_Index;
   goto Exit_Row138_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row138_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'lexer_case_alt') at parser.lkt:58:11>
if Row_Pos138 = No_Token_Index and then Nobt32 then
   Row_Pos138 := Parser.Last_Fail.Pos;
   Transform_Has_Failed30 := True;
end if;
if Row_Pos138 /= No_Token_Index then
   Transform_Res103 := Allocate_Lexer_Case_Rule_Default_Alt (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res103,
      Kind => Lkt_Lexer_Case_Rule_Default_Alt,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos138 = Pos
                            then No_Token_Index
                            else Row_Pos138 - 1));
      Initialize_Fields_For_Lexer_Case_Rule_Default_Alt
        (Self => Transform_Res103,
         Lexer_Case_Rule_Default_Alt_F_Send => Defer_Res176);
         if Defer_Res176 /= null and then Is_Incomplete (Defer_Res176) then
            Transform_Res103.Last_Attempted_Child := 0;
         elsif Defer_Res176 /= null and then not Is_Ghost (Defer_Res176) then
            Transform_Res103.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed30 then
      Transform_Res103.Last_Attempted_Child :=
         Row_Progress30;
      Append (Parser, Pos, "Cannot parse <lexer_case_alt>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType LexerCaseRuleDefaultAlt>) (root of 'lexer_case_alt') at parser.lkt:58:11>
    if Row_Pos138 /= No_Token_Index then
        Or_Pos26 := Row_Pos138;
        Or_Res26 := Transform_Res103;
        goto Exit_Or29;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail26.Pos then
       Branch_Diag_Mark26 := Parser.Last_Diag;
       Branch_Last_Fail26 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark71;
    Parser.Last_Fail := Last_Fail26;
--  BEGIN <Skip (root of 'lexer_case_alt') at parser.lkt:59:11>
--  pos=Skip_Pos3, res=Transform_Res104, nobt=None
if Get_Token (Parser.TDH.all, Pos).Kind
   = From_Token_Kind (Lkt_Termination)
then
   Skip_Pos3 := No_Token_Index;
   goto Exit_Or30;
end if;
for Fn of PP.Dont_Skip loop
   Skip_Dummy3 := Fn (Parser, Pos);
   if Parser.Current_Pos /= No_Token_Index  then
      Skip_Pos3 := No_Token_Index;
      goto Exit_Or30;
   end if;
end loop;
Skip_Pos3 := Pos + 1;
--  BEGIN <Transform(<ASTNodeType ErrorLexerCaseRuleAlt>) (root of 'lexer_case_alt') at parser.lkt:59:11>
--  pos=Row_Pos139, res=Transform_Res104, nobt=None
--  BEGIN <_Row (root of 'lexer_case_alt') at parser.lkt:59:11>
--  pos=Row_Pos139, res=None, nobt=None
Row_Pos139 := Pos;
pragma Warnings (Off, "referenced");
<<Exit_Row139_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'lexer_case_alt') at parser.lkt:59:11>
if Row_Pos139 /= No_Token_Index then
   Transform_Res104 := Allocate_Error_Lexer_Case_Rule_Alt (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res104,
      Kind => Lkt_Error_Lexer_Case_Rule_Alt,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos139 = Pos
                            then No_Token_Index
                            else Row_Pos139 - 1));
end if;
--  END <Transform(<ASTNodeType ErrorLexerCaseRuleAlt>) (root of 'lexer_case_alt') at parser.lkt:59:11>
Transform_Res104.Token_End_Index := Pos;
declare
   Tok      : constant Token_Reference :=
     Wrap_Token_Reference
      (Parser.Unit.Context,
       Parser.TDH,
       (Pos, No_Token_Index));
   Tok_Text : constant Text_Type := Common.Text (Tok);
begin
   Append (Parser, Pos, "Skipped token " & Image (Tok_Text));
end;
<<Exit_Or30>>
--  END <Skip (root of 'lexer_case_alt') at parser.lkt:59:11>
    if Skip_Pos3 /= No_Token_Index then
        Or_Pos26 := Skip_Pos3;
        Or_Res26 := Transform_Res104;
        goto Exit_Or29;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail26.Pos then
       Branch_Diag_Mark26 := Parser.Last_Diag;
       Branch_Last_Fail26 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark26;
Parser.Last_Fail := Branch_Last_Fail26;
<<Exit_Or29>>
--  END <Or (root of 'lexer_case_alt') at parser.lkt:48:23>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos26 = No_Token_Index then
      Set_Failure
        (PP.Lexer_Case_Alt_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Lexer_Case_Alt_Or_Parse0_Memo, Pos, Or_Res26, Parser.Last_Diag, Or_Pos26);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos26;
   return Or_Res26;
end Lexer_Case_Alt_Or_Parse0;
   function Lexer_Case_Rule_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lexer_Case_Rule
is
      Nobt33 : Boolean := False;
      Row_Pos140 : Token_Index := No_Token_Index;
      Token_Pos190 : Token_Index := No_Token_Index;
      Token_Res190 : Token_Index := No_Token_Index;
      Defer_Pos177 : Token_Index := No_Token_Index;
      Defer_Res177 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Token_Pos191 : Token_Index := No_Token_Index;
      Token_Res191 : Token_Index := No_Token_Index;
      Lst_Cpos24 : Token_Index := No_Token_Index;
      Tmp_List24 : Free_Parse_List;
      Defer_Pos178 : Token_Index := No_Token_Index;
      Defer_Res178 : Bare_Base_Lexer_Case_Rule_Alt := No_Bare_Lkt_Node;
      List_Pos24 : Token_Index := No_Token_Index;
      List_Res24 : Bare_Base_Lexer_Case_Rule_Alt_List := No_Bare_Lkt_Node;
      Diag_Mark72 : Diagnostic_Mark;
      Token_Pos192 : Token_Index := No_Token_Index;
      Token_Res192 : Token_Index := No_Token_Index;
      Row_Progress31 : Integer := 0;
      Transform_Res105 : Bare_Lexer_Case_Rule := No_Bare_Lkt_Node;
      Transform_Has_Failed31 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Lexer_Case_Rule_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res105 := M.Instance;
      return Transform_Res105;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res105;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType LexerCaseRule>) (root of 'lexer_case_rule') at parser.lkt:45:24>
--  pos=Row_Pos140, res=Transform_Res105, nobt=Nobt33
--  BEGIN <_Row (root of 'lexer_case_rule') at parser.lkt:45:24>
--  pos=Row_Pos140, res=None, nobt=Nobt33
Row_Pos140 := Pos;
--  BEGIN <Token(<WithText MatchKw>, ) (root of 'lexer_case_rule') at parser.lkt:46:9>
--  pos=Token_Pos190, res=Token_Res190, nobt=None
Token_Res190 := Row_Pos140;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res190));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Match_Kw)
   then
       Token_Pos190 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos140 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos140,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Match_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos190 := Row_Pos140 + 1;
   end if;
end;
--  END <Token(<WithText MatchKw>, ) (root of 'lexer_case_rule') at parser.lkt:46:9>
Row_Progress31 := 1;
if Token_Pos190 /= No_Token_Index then
   Row_Pos140 := Token_Pos190;
else
   Row_Pos140 := No_Token_Index;
   goto Exit_Row140_0;
end if;
--  BEGIN <Cut (root of 'lexer_case_rule') at parser.lkt:46:17>
--  pos=Row_Pos140, res=None, nobt=Nobt33
Nobt33 := True;
--  END <Cut (root of 'lexer_case_rule') at parser.lkt:46:17>
Row_Progress31 := 2;
if Row_Pos140 /= No_Token_Index then
   Row_Pos140 := Row_Pos140;
else
   Row_Pos140 := No_Token_Index;
   goto Exit_Row140_0;
end if;
--  BEGIN <Defer (for 'grammar_primary') at parser.lkt:46:19>
--  pos=Defer_Pos177, res=Defer_Res177, nobt=None
Defer_Res177 :=
   Grammar_Primary_Or_Parse0 (Parser, Row_Pos140);
Defer_Pos177 := Parser.Current_Pos;
--  END <Defer (for 'grammar_primary') at parser.lkt:46:19>
Row_Progress31 := 3;
if Defer_Pos177 /= No_Token_Index then
   Row_Pos140 := Defer_Pos177;
else
   Row_Pos140 := No_Token_Index;
   goto Exit_Row140_0;
end if;
--  BEGIN <Token(<WithText LBrace>, ) (root of 'lexer_case_rule') at parser.lkt:46:35>
--  pos=Token_Pos191, res=Token_Res191, nobt=None
Token_Res191 := Row_Pos140;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res191));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos191 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos140 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos140,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos191 := Row_Pos140 + 1;
   end if;
end;
--  END <Token(<WithText LBrace>, ) (root of 'lexer_case_rule') at parser.lkt:46:35>
Row_Progress31 := 4;
if Token_Pos191 /= No_Token_Index then
   Row_Pos140 := Token_Pos191;
else
   Row_Pos140 := No_Token_Index;
   goto Exit_Row140_0;
end if;
--  BEGIN <DontSkip (root of 'lexer_case_rule') at parser.lkt:46:39>
--  pos=List_Pos24, res=List_Res24, nobt=None
        PP.Dont_Skip.Append (Dontskip_Lexer_Case_Rule0_Extract_Parse0'Access);
--  BEGIN <List (root of 'lexer_case_rule') at parser.lkt:46:39>
--  pos=List_Pos24, res=List_Res24, nobt=None
    List_Pos24 := Row_Pos140;
Lst_Cpos24 := Row_Pos140;
Tmp_List24 := Get_Parse_List (Parser);
Diag_Mark72 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'lexer_case_alt') at parser.lkt:46:45>
--  pos=Defer_Pos178, res=Defer_Res178, nobt=None
Defer_Res178 :=
   Lexer_Case_Alt_Or_Parse0 (Parser, Lst_Cpos24);
Defer_Pos178 := Parser.Current_Pos;
--  END <Defer (for 'lexer_case_alt') at parser.lkt:46:45>
   exit when Defer_Pos178 = No_Token_Index;
   List_Pos24 := Defer_Pos178;
   Lst_Cpos24 := List_Pos24;
   Diag_Mark72 := Parser.Last_Diag;
   Tmp_List24.Nodes.Append (Defer_Res178);
end loop;
Parser.Last_Diag := Diag_Mark72;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List24.Nodes.Length;
begin
   List_Res24 := Allocate_Base_Lexer_Case_Rule_Alt_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos140;
      Token_End := (if Lst_Cpos24 = Row_Pos140
                    then Row_Pos140
                    else List_Pos24 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos140, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res24,
      Kind              => Lkt_Base_Lexer_Case_Rule_Alt_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res24,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List24.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res24.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List24);
--  END <List (root of 'lexer_case_rule') at parser.lkt:46:39>
        PP.Dont_Skip.Delete_Last;
--  END <DontSkip (root of 'lexer_case_rule') at parser.lkt:46:39>
Row_Progress31 := 5;
if List_Pos24 /= No_Token_Index then
   Row_Pos140 := List_Pos24;
else
   Row_Pos140 := No_Token_Index;
   goto Exit_Row140_0;
end if;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'lexer_case_rule') at parser.lkt:46:76>
--  pos=Token_Pos192, res=Token_Res192, nobt=None
Token_Res192 := Row_Pos140;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res192));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos192 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos140 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos140,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos192 := Row_Pos140 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'lexer_case_rule') at parser.lkt:46:76>
Row_Progress31 := 6;
if Token_Pos192 /= No_Token_Index then
   Row_Pos140 := Token_Pos192;
else
   Row_Pos140 := No_Token_Index;
   goto Exit_Row140_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row140_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'lexer_case_rule') at parser.lkt:45:24>
if Row_Pos140 = No_Token_Index and then Nobt33 then
   Row_Pos140 := Parser.Last_Fail.Pos;
   Transform_Has_Failed31 := True;
end if;
if Row_Pos140 /= No_Token_Index then
   Transform_Res105 := Allocate_Lexer_Case_Rule (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res105,
      Kind => Lkt_Lexer_Case_Rule,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos140 = Pos
                            then No_Token_Index
                            else Row_Pos140 - 1));
      Initialize_Fields_For_Lexer_Case_Rule
        (Self => Transform_Res105,
         Lexer_Case_Rule_F_Expr => Defer_Res177,
         Lexer_Case_Rule_F_Alts => List_Res24);
         if Defer_Res177 /= null and then Is_Incomplete (Defer_Res177) then
            Transform_Res105.Last_Attempted_Child := 0;
         elsif Defer_Res177 /= null and then not Is_Ghost (Defer_Res177) then
            Transform_Res105.Last_Attempted_Child := -1;
         end if;
         if List_Res24 /= null and then Is_Incomplete (List_Res24) then
            Transform_Res105.Last_Attempted_Child := 0;
         elsif List_Res24 /= null and then not Is_Ghost (List_Res24) then
            Transform_Res105.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed31 then
      Transform_Res105.Last_Attempted_Child :=
         Row_Progress31;
      Append (Parser, Pos, "Cannot parse <lexer_case_rule>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType LexerCaseRule>) (root of 'lexer_case_rule') at parser.lkt:45:24>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos140 = No_Token_Index then
      Set_Failure
        (PP.Lexer_Case_Rule_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Lexer_Case_Rule_Transform_Parse0_Memo, Pos, Transform_Res105, Parser.Last_Diag, Row_Pos140);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos140;
   return Transform_Res105;
end Lexer_Case_Rule_Transform_Parse0;
   function Lexer_Case_Send_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lexer_Case_Rule_Send
is
      Row_Pos141 : Token_Index := No_Token_Index;
      Token_Pos193 : Token_Index := No_Token_Index;
      Token_Res193 : Token_Index := No_Token_Index;
      Token_Pos194 : Token_Index := No_Token_Index;
      Token_Res194 : Token_Index := No_Token_Index;
      Defer_Pos179 : Token_Index := No_Token_Index;
      Defer_Res179 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Token_Pos195 : Token_Index := No_Token_Index;
      Token_Res195 : Token_Index := No_Token_Index;
      Defer_Pos180 : Token_Index := No_Token_Index;
      Defer_Res180 : Bare_Num_Lit := No_Bare_Lkt_Node;
      Token_Pos196 : Token_Index := No_Token_Index;
      Token_Res196 : Token_Index := No_Token_Index;
      Transform_Res106 : Bare_Lexer_Case_Rule_Send := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Lexer_Case_Send_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res106 := M.Instance;
      return Transform_Res106;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res106;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType LexerCaseRuleSend>) (root of 'lexer_case_send') at parser.lkt:61:24>
--  pos=Row_Pos141, res=Transform_Res106, nobt=None
--  BEGIN <_Row (root of 'lexer_case_send') at parser.lkt:61:24>
--  pos=Row_Pos141, res=None, nobt=None
Row_Pos141 := Pos;
--  BEGIN <Token(<WithSymbol Identifier>, send) (root of 'lexer_case_send') at parser.lkt:62:9>
--  pos=Token_Pos193, res=Token_Res193, nobt=None
Token_Res193 := Row_Pos141;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res193));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Send)
   then
       Token_Pos193 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos141 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos141,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos193 := Row_Pos141 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, send) (root of 'lexer_case_send') at parser.lkt:62:9>
if Token_Pos193 /= No_Token_Index then
   Row_Pos141 := Token_Pos193;
else
   Row_Pos141 := No_Token_Index;
   goto Exit_Row141_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'lexer_case_send') at parser.lkt:62:29>
--  pos=Token_Pos194, res=Token_Res194, nobt=None
Token_Res194 := Row_Pos141;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res194));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos194 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos141 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos141,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos194 := Row_Pos141 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'lexer_case_send') at parser.lkt:62:29>
if Token_Pos194 /= No_Token_Index then
   Row_Pos141 := Token_Pos194;
else
   Row_Pos141 := No_Token_Index;
   goto Exit_Row141_0;
end if;
--  BEGIN <Defer (for 'ref_id') at parser.lkt:62:33>
--  pos=Defer_Pos179, res=Defer_Res179, nobt=None
Defer_Res179 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos141);
Defer_Pos179 := Parser.Current_Pos;
--  END <Defer (for 'ref_id') at parser.lkt:62:33>
if Defer_Pos179 /= No_Token_Index then
   Row_Pos141 := Defer_Pos179;
else
   Row_Pos141 := No_Token_Index;
   goto Exit_Row141_0;
end if;
--  BEGIN <Token(<WithText Comma>, ) (root of 'lexer_case_send') at parser.lkt:62:40>
--  pos=Token_Pos195, res=Token_Res195, nobt=None
Token_Res195 := Row_Pos141;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res195));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos195 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos141 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos141,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Comma,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos195 := Row_Pos141 + 1;
   end if;
end;
--  END <Token(<WithText Comma>, ) (root of 'lexer_case_send') at parser.lkt:62:40>
if Token_Pos195 /= No_Token_Index then
   Row_Pos141 := Token_Pos195;
else
   Row_Pos141 := No_Token_Index;
   goto Exit_Row141_0;
end if;
--  BEGIN <Defer (for 'num_lit') at parser.lkt:62:44>
--  pos=Defer_Pos180, res=Defer_Res180, nobt=None
Defer_Res180 :=
   Num_Lit_Transform_Parse0 (Parser, Row_Pos141);
Defer_Pos180 := Parser.Current_Pos;
--  END <Defer (for 'num_lit') at parser.lkt:62:44>
if Defer_Pos180 /= No_Token_Index then
   Row_Pos141 := Defer_Pos180;
else
   Row_Pos141 := No_Token_Index;
   goto Exit_Row141_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'lexer_case_send') at parser.lkt:62:52>
--  pos=Token_Pos196, res=Token_Res196, nobt=None
Token_Res196 := Row_Pos141;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res196));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos196 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos141 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos141,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos196 := Row_Pos141 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'lexer_case_send') at parser.lkt:62:52>
if Token_Pos196 /= No_Token_Index then
   Row_Pos141 := Token_Pos196;
else
   Row_Pos141 := No_Token_Index;
   goto Exit_Row141_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row141_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'lexer_case_send') at parser.lkt:61:24>
if Row_Pos141 /= No_Token_Index then
   Transform_Res106 := Allocate_Lexer_Case_Rule_Send (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res106,
      Kind => Lkt_Lexer_Case_Rule_Send,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos141 = Pos
                            then No_Token_Index
                            else Row_Pos141 - 1));
      Initialize_Fields_For_Lexer_Case_Rule_Send
        (Self => Transform_Res106,
         Lexer_Case_Rule_Send_F_Sent => Defer_Res179,
         Lexer_Case_Rule_Send_F_Match_Size => Defer_Res180);
         if Defer_Res179 /= null and then Is_Incomplete (Defer_Res179) then
            Transform_Res106.Last_Attempted_Child := 0;
         elsif Defer_Res179 /= null and then not Is_Ghost (Defer_Res179) then
            Transform_Res106.Last_Attempted_Child := -1;
         end if;
         if Defer_Res180 /= null and then Is_Incomplete (Defer_Res180) then
            Transform_Res106.Last_Attempted_Child := 0;
         elsif Defer_Res180 /= null and then not Is_Ghost (Defer_Res180) then
            Transform_Res106.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType LexerCaseRuleSend>) (root of 'lexer_case_send') at parser.lkt:61:24>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos141 = No_Token_Index then
      Set_Failure
        (PP.Lexer_Case_Send_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Lexer_Case_Send_Transform_Parse0_Memo, Pos, Transform_Res106, Parser.Last_Diag, Row_Pos141);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos141;
   return Transform_Res106;
end Lexer_Case_Send_Transform_Parse0;
   function Lexer_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lexer_Decl
is
      Nobt34 : Boolean := False;
      Row_Pos142 : Token_Index := No_Token_Index;
      Token_Pos197 : Token_Index := No_Token_Index;
      Token_Res197 : Token_Index := No_Token_Index;
      Defer_Pos181 : Token_Index := No_Token_Index;
      Defer_Res181 : Bare_Def_Id := No_Bare_Lkt_Node;
      Token_Pos198 : Token_Index := No_Token_Index;
      Token_Res198 : Token_Index := No_Token_Index;
      Lst_Cpos25 : Token_Index := No_Token_Index;
      Tmp_List25 : Free_Parse_List;
      Defer_Pos182 : Token_Index := No_Token_Index;
      Defer_Res182 : Bare_Lexer_Case_Rule := No_Bare_Lkt_Node;
      Defer_Pos183 : Token_Index := No_Token_Index;
      Defer_Res183 : Bare_Full_Decl := No_Bare_Lkt_Node;
      Or_Pos27 : Token_Index := No_Token_Index;
      Or_Res27 : Bare_Lkt_Node := No_Bare_Lkt_Node;
      Diag_Mark73 : Diagnostic_Mark;
      Last_Fail27 : Fail_Info;
      Branch_Diag_Mark27 : Diagnostic_Mark;
      Branch_Last_Fail27 : Fail_Info;
      List_Pos25 : Token_Index := No_Token_Index;
      List_Res25 : Bare_Lkt_Node_List := No_Bare_Lkt_Node;
      Diag_Mark74 : Diagnostic_Mark;
      Token_Pos199 : Token_Index := No_Token_Index;
      Token_Res199 : Token_Index := No_Token_Index;
      Row_Progress32 : Integer := 0;
      Transform_Res107 : Bare_Lexer_Decl := No_Bare_Lkt_Node;
      Transform_Has_Failed32 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Lexer_Decl_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res107 := M.Instance;
      return Transform_Res107;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res107;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType LexerDecl>) (root of 'lexer_decl') at parser.lkt:35:19>
--  pos=Row_Pos142, res=Transform_Res107, nobt=Nobt34
--  BEGIN <_Row (root of 'lexer_decl') at parser.lkt:35:19>
--  pos=Row_Pos142, res=None, nobt=Nobt34
Row_Pos142 := Pos;
--  BEGIN <Token(<WithText LexerKw>, ) (root of 'lexer_decl') at parser.lkt:36:9>
--  pos=Token_Pos197, res=Token_Res197, nobt=None
Token_Res197 := Row_Pos142;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res197));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Lexer_Kw)
   then
       Token_Pos197 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos142 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos142,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Lexer_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos197 := Row_Pos142 + 1;
   end if;
end;
--  END <Token(<WithText LexerKw>, ) (root of 'lexer_decl') at parser.lkt:36:9>
Row_Progress32 := 1;
if Token_Pos197 /= No_Token_Index then
   Row_Pos142 := Token_Pos197;
else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;
end if;
--  BEGIN <Cut (root of 'lexer_decl') at parser.lkt:37:9>
--  pos=Row_Pos142, res=None, nobt=Nobt34
Nobt34 := True;
--  END <Cut (root of 'lexer_decl') at parser.lkt:37:9>
Row_Progress32 := 2;
if Row_Pos142 /= No_Token_Index then
   Row_Pos142 := Row_Pos142;
else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;
end if;
--  BEGIN <Defer (for 'def_id') at parser.lkt:38:9>
--  pos=Defer_Pos181, res=Defer_Res181, nobt=None
Defer_Res181 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos142);
Defer_Pos181 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:38:9>
Row_Progress32 := 3;
if Defer_Pos181 /= No_Token_Index then
   Row_Pos142 := Defer_Pos181;
else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;
end if;
--  BEGIN <Token(<WithText LBrace>, ) (root of 'lexer_decl') at parser.lkt:39:9>
--  pos=Token_Pos198, res=Token_Res198, nobt=None
Token_Res198 := Row_Pos142;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res198));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos198 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos142 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos142,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos198 := Row_Pos142 + 1;
   end if;
end;
--  END <Token(<WithText LBrace>, ) (root of 'lexer_decl') at parser.lkt:39:9>
Row_Progress32 := 4;
if Token_Pos198 /= No_Token_Index then
   Row_Pos142 := Token_Pos198;
else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;
end if;
--  BEGIN <DontSkip (root of 'lexer_decl') at parser.lkt:40:9>
--  pos=List_Pos25, res=List_Res25, nobt=None
        PP.Dont_Skip.Append (Dontskip_Lexer_Decl0_Extract_Parse0'Access);
--  BEGIN <List (root of 'lexer_decl') at parser.lkt:40:9>
--  pos=List_Pos25, res=List_Res25, nobt=None
    List_Pos25 := Row_Pos142;
Lst_Cpos25 := Row_Pos142;
Tmp_List25 := Get_Parse_List (Parser);
Diag_Mark74 := Parser.Last_Diag;
loop
--  BEGIN <Or (root of 'lexer_decl') at parser.lkt:40:15>
--  pos=Or_Pos27, res=Or_Res27, nobt=None
Or_Pos27 := No_Token_Index;
Or_Res27 := No_Bare_Lkt_Node;
Diag_Mark73 := Parser.Last_Diag;
Last_Fail27 := Parser.Last_Fail;
Branch_Diag_Mark27 := Parser.Last_Diag;
Branch_Last_Fail27 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark73;
    Parser.Last_Fail := Last_Fail27;
--  BEGIN <Defer (for 'lexer_case_rule') at parser.lkt:40:18>
--  pos=Defer_Pos182, res=Defer_Res182, nobt=None
Defer_Res182 :=
   Lexer_Case_Rule_Transform_Parse0 (Parser, Lst_Cpos25);
Defer_Pos182 := Parser.Current_Pos;
--  END <Defer (for 'lexer_case_rule') at parser.lkt:40:18>
    if Defer_Pos182 /= No_Token_Index then
        Or_Pos27 := Defer_Pos182;
        Or_Res27 := Defer_Res182;
        goto Exit_Or31;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail27.Pos then
       Branch_Diag_Mark27 := Parser.Last_Diag;
       Branch_Last_Fail27 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark73;
    Parser.Last_Fail := Last_Fail27;
--  BEGIN <Defer (for 'decl') at parser.lkt:40:36>
--  pos=Defer_Pos183, res=Defer_Res183, nobt=None
Defer_Res183 :=
   Decl_Transform_Parse0 (Parser, Lst_Cpos25);
Defer_Pos183 := Parser.Current_Pos;
--  END <Defer (for 'decl') at parser.lkt:40:36>
    if Defer_Pos183 /= No_Token_Index then
        Or_Pos27 := Defer_Pos183;
        Or_Res27 := Defer_Res183;
        goto Exit_Or31;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail27.Pos then
       Branch_Diag_Mark27 := Parser.Last_Diag;
       Branch_Last_Fail27 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark27;
Parser.Last_Fail := Branch_Last_Fail27;
<<Exit_Or31>>
--  END <Or (root of 'lexer_decl') at parser.lkt:40:15>
   exit when Or_Pos27 = No_Token_Index;
   List_Pos25 := Or_Pos27;
   Lst_Cpos25 := List_Pos25;
   Diag_Mark74 := Parser.Last_Diag;
   Tmp_List25.Nodes.Append (Or_Res27);
end loop;
Parser.Last_Diag := Diag_Mark74;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List25.Nodes.Length;
begin
   List_Res25 := Allocate_Lkt_Node_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos142;
      Token_End := (if Lst_Cpos25 = Row_Pos142
                    then Row_Pos142
                    else List_Pos25 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos142, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res25,
      Kind              => Lkt_Lkt_Node_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res25,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List25.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res25.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List25);
--  END <List (root of 'lexer_decl') at parser.lkt:40:9>
        PP.Dont_Skip.Delete_Last;
--  END <DontSkip (root of 'lexer_decl') at parser.lkt:40:9>
Row_Progress32 := 5;
if List_Pos25 /= No_Token_Index then
   Row_Pos142 := List_Pos25;
else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;
end if;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'lexer_decl') at parser.lkt:41:9>
--  pos=Token_Pos199, res=Token_Res199, nobt=None
Token_Res199 := Row_Pos142;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res199));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos199 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos142 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos142,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos199 := Row_Pos142 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'lexer_decl') at parser.lkt:41:9>
Row_Progress32 := 6;
if Token_Pos199 /= No_Token_Index then
   Row_Pos142 := Token_Pos199;
else
   Row_Pos142 := No_Token_Index;
   goto Exit_Row142_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row142_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'lexer_decl') at parser.lkt:35:19>
if Row_Pos142 = No_Token_Index and then Nobt34 then
   Row_Pos142 := Parser.Last_Fail.Pos;
   Transform_Has_Failed32 := True;
end if;
if Row_Pos142 /= No_Token_Index then
   Transform_Res107 := Allocate_Lexer_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res107,
      Kind => Lkt_Lexer_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos142 = Pos
                            then No_Token_Index
                            else Row_Pos142 - 1));
      Initialize_Fields_For_Lexer_Decl
        (Self => Transform_Res107,
         Lexer_Decl_F_Syn_Name => Defer_Res181,
         Lexer_Decl_F_Rules => List_Res25);
         if Defer_Res181 /= null and then Is_Incomplete (Defer_Res181) then
            Transform_Res107.Last_Attempted_Child := 0;
         elsif Defer_Res181 /= null and then not Is_Ghost (Defer_Res181) then
            Transform_Res107.Last_Attempted_Child := -1;
         end if;
         if List_Res25 /= null and then Is_Incomplete (List_Res25) then
            Transform_Res107.Last_Attempted_Child := 0;
         elsif List_Res25 /= null and then not Is_Ghost (List_Res25) then
            Transform_Res107.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed32 then
      Transform_Res107.Last_Attempted_Child :=
         Row_Progress32;
      Append (Parser, Pos, "Cannot parse <lexer_decl>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType LexerDecl>) (root of 'lexer_decl') at parser.lkt:35:19>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos142 = No_Token_Index then
      Set_Failure
        (PP.Lexer_Decl_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Lexer_Decl_Transform_Parse0_Memo, Pos, Transform_Res107, Parser.Last_Diag, Row_Pos142);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos142;
   return Transform_Res107;
end Lexer_Decl_Transform_Parse0;
   function Lexer_Family_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Lexer_Family_Decl
is
      Nobt35 : Boolean := False;
      Row_Pos143 : Token_Index := No_Token_Index;
      Token_Pos200 : Token_Index := No_Token_Index;
      Token_Res200 : Token_Index := No_Token_Index;
      Defer_Pos184 : Token_Index := No_Token_Index;
      Defer_Res184 : Bare_Def_Id := No_Bare_Lkt_Node;
      Token_Pos201 : Token_Index := No_Token_Index;
      Token_Res201 : Token_Index := No_Token_Index;
      Lst_Cpos26 : Token_Index := No_Token_Index;
      Tmp_List26 : Free_Parse_List;
      Defer_Pos185 : Token_Index := No_Token_Index;
      Defer_Res185 : Bare_Full_Decl := No_Bare_Lkt_Node;
      List_Pos26 : Token_Index := No_Token_Index;
      List_Res26 : Bare_Full_Decl_List := No_Bare_Lkt_Node;
      Diag_Mark75 : Diagnostic_Mark;
      Token_Pos202 : Token_Index := No_Token_Index;
      Token_Res202 : Token_Index := No_Token_Index;
      Row_Progress33 : Integer := 0;
      Transform_Res108 : Bare_Lexer_Family_Decl := No_Bare_Lkt_Node;
      Transform_Has_Failed33 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Lexer_Family_Decl_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res108 := M.Instance;
      return Transform_Res108;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res108;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType LexerFamilyDecl>) (root of 'lexer_family_decl') at parser.lkt:256:26>
--  pos=Row_Pos143, res=Transform_Res108, nobt=Nobt35
--  BEGIN <_Row (root of 'lexer_family_decl') at parser.lkt:256:26>
--  pos=Row_Pos143, res=None, nobt=Nobt35
Row_Pos143 := Pos;
--  BEGIN <Token(<WithSymbol Identifier>, family) (root of 'lexer_family_decl') at parser.lkt:257:9>
--  pos=Token_Pos200, res=Token_Res200, nobt=None
Token_Res200 := Row_Pos143;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res200));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_Family)
   then
       Token_Pos200 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos143 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos143,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos200 := Row_Pos143 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, family) (root of 'lexer_family_decl') at parser.lkt:257:9>
Row_Progress33 := 1;
if Token_Pos200 /= No_Token_Index then
   Row_Pos143 := Token_Pos200;
else
   Row_Pos143 := No_Token_Index;
   goto Exit_Row143_0;
end if;
--  BEGIN <Cut (root of 'lexer_family_decl') at parser.lkt:257:31>
--  pos=Row_Pos143, res=None, nobt=Nobt35
Nobt35 := True;
--  END <Cut (root of 'lexer_family_decl') at parser.lkt:257:31>
Row_Progress33 := 2;
if Row_Pos143 /= No_Token_Index then
   Row_Pos143 := Row_Pos143;
else
   Row_Pos143 := No_Token_Index;
   goto Exit_Row143_0;
end if;
--  BEGIN <Defer (for 'def_id') at parser.lkt:257:33>
--  pos=Defer_Pos184, res=Defer_Res184, nobt=None
Defer_Res184 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos143);
Defer_Pos184 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:257:33>
Row_Progress33 := 3;
if Defer_Pos184 /= No_Token_Index then
   Row_Pos143 := Defer_Pos184;
else
   Row_Pos143 := No_Token_Index;
   goto Exit_Row143_0;
end if;
--  BEGIN <Token(<WithText LBrace>, ) (root of 'lexer_family_decl') at parser.lkt:257:40>
--  pos=Token_Pos201, res=Token_Res201, nobt=None
Token_Res201 := Row_Pos143;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res201));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos201 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos143 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos143,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos201 := Row_Pos143 + 1;
   end if;
end;
--  END <Token(<WithText LBrace>, ) (root of 'lexer_family_decl') at parser.lkt:257:40>
Row_Progress33 := 4;
if Token_Pos201 /= No_Token_Index then
   Row_Pos143 := Token_Pos201;
else
   Row_Pos143 := No_Token_Index;
   goto Exit_Row143_0;
end if;
--  BEGIN <DontSkip (root of 'lexer_family_decl') at parser.lkt:257:44>
--  pos=List_Pos26, res=List_Res26, nobt=None
        PP.Dont_Skip.Append (Dontskip_Lexer_Family_Decl0_Extract_Parse0'Access);
--  BEGIN <List (root of 'lexer_family_decl') at parser.lkt:257:44>
--  pos=List_Pos26, res=List_Res26, nobt=None
    List_Pos26 := Row_Pos143;
Lst_Cpos26 := Row_Pos143;
Tmp_List26 := Get_Parse_List (Parser);
Diag_Mark75 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'decl') at parser.lkt:257:50>
--  pos=Defer_Pos185, res=Defer_Res185, nobt=None
Defer_Res185 :=
   Decl_Transform_Parse0 (Parser, Lst_Cpos26);
Defer_Pos185 := Parser.Current_Pos;
--  END <Defer (for 'decl') at parser.lkt:257:50>
   exit when Defer_Pos185 = No_Token_Index;
   List_Pos26 := Defer_Pos185;
   Lst_Cpos26 := List_Pos26;
   Diag_Mark75 := Parser.Last_Diag;
   Tmp_List26.Nodes.Append (Defer_Res185);
end loop;
Parser.Last_Diag := Diag_Mark75;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List26.Nodes.Length;
begin
   List_Res26 := Allocate_Full_Decl_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos143;
      Token_End := (if Lst_Cpos26 = Row_Pos143
                    then Row_Pos143
                    else List_Pos26 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos143, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res26,
      Kind              => Lkt_Full_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res26,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List26.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res26.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List26);
--  END <List (root of 'lexer_family_decl') at parser.lkt:257:44>
        PP.Dont_Skip.Delete_Last;
--  END <DontSkip (root of 'lexer_family_decl') at parser.lkt:257:44>
Row_Progress33 := 5;
if List_Pos26 /= No_Token_Index then
   Row_Pos143 := List_Pos26;
else
   Row_Pos143 := No_Token_Index;
   goto Exit_Row143_0;
end if;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'lexer_family_decl') at parser.lkt:257:71>
--  pos=Token_Pos202, res=Token_Res202, nobt=None
Token_Res202 := Row_Pos143;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res202));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos202 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos143 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos143,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos202 := Row_Pos143 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'lexer_family_decl') at parser.lkt:257:71>
Row_Progress33 := 6;
if Token_Pos202 /= No_Token_Index then
   Row_Pos143 := Token_Pos202;
else
   Row_Pos143 := No_Token_Index;
   goto Exit_Row143_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row143_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'lexer_family_decl') at parser.lkt:256:26>
if Row_Pos143 = No_Token_Index and then Nobt35 then
   Row_Pos143 := Parser.Last_Fail.Pos;
   Transform_Has_Failed33 := True;
end if;
if Row_Pos143 /= No_Token_Index then
   Transform_Res108 := Allocate_Lexer_Family_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res108,
      Kind => Lkt_Lexer_Family_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos143 = Pos
                            then No_Token_Index
                            else Row_Pos143 - 1));
      Initialize_Fields_For_Lexer_Family_Decl
        (Self => Transform_Res108,
         Lexer_Family_Decl_F_Syn_Name => Defer_Res184,
         Lexer_Family_Decl_F_Rules => List_Res26);
         if Defer_Res184 /= null and then Is_Incomplete (Defer_Res184) then
            Transform_Res108.Last_Attempted_Child := 0;
         elsif Defer_Res184 /= null and then not Is_Ghost (Defer_Res184) then
            Transform_Res108.Last_Attempted_Child := -1;
         end if;
         if List_Res26 /= null and then Is_Incomplete (List_Res26) then
            Transform_Res108.Last_Attempted_Child := 0;
         elsif List_Res26 /= null and then not Is_Ghost (List_Res26) then
            Transform_Res108.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed33 then
      Transform_Res108.Last_Attempted_Child :=
         Row_Progress33;
      Append (Parser, Pos, "Cannot parse <lexer_family_decl>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType LexerFamilyDecl>) (root of 'lexer_family_decl') at parser.lkt:256:26>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos143 = No_Token_Index then
      Set_Failure
        (PP.Lexer_Family_Decl_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Lexer_Family_Decl_Transform_Parse0_Memo, Pos, Transform_Res108, Parser.Last_Diag, Row_Pos143);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos143;
   return Transform_Res108;
end Lexer_Family_Decl_Transform_Parse0;
   function List_Pattern_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_List_Pattern
is
      Row_Pos144 : Token_Index := No_Token_Index;
      Token_Pos203 : Token_Index := No_Token_Index;
      Token_Res203 : Token_Index := No_Token_Index;
      Lst_Cpos27 : Token_Index := No_Token_Index;
      Tmp_List27 : Free_Parse_List;
      Defer_Pos186 : Token_Index := No_Token_Index;
      Defer_Res186 : Bare_Ellipsis_Pattern := No_Bare_Lkt_Node;
      Defer_Pos187 : Token_Index := No_Token_Index;
      Defer_Res187 : Bare_Pattern := No_Bare_Lkt_Node;
      Or_Pos28 : Token_Index := No_Token_Index;
      Or_Res28 : Bare_Pattern := No_Bare_Lkt_Node;
      Diag_Mark76 : Diagnostic_Mark;
      Last_Fail28 : Fail_Info;
      Branch_Diag_Mark28 : Diagnostic_Mark;
      Branch_Last_Fail28 : Fail_Info;
      Token_Pos204 : Token_Index := No_Token_Index;
      Token_Res204 : Token_Index := No_Token_Index;
      List_Pos27 : Token_Index := No_Token_Index;
      List_Res27 : Bare_Pattern_List := No_Bare_Lkt_Node;
      Diag_Mark77 : Diagnostic_Mark;
      Token_Pos205 : Token_Index := No_Token_Index;
      Token_Res205 : Token_Index := No_Token_Index;
      Transform_Res109 : Bare_List_Pattern := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.List_Pattern_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res109 := M.Instance;
      return Transform_Res109;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res109;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType ListPattern>) (root of 'list_pattern') at parser.lkt:343:21>
--  pos=Row_Pos144, res=Transform_Res109, nobt=None
--  BEGIN <_Row (root of 'list_pattern') at parser.lkt:343:21>
--  pos=Row_Pos144, res=None, nobt=None
Row_Pos144 := Pos;
--  BEGIN <Token(<WithText LBrack>, ) (root of 'list_pattern') at parser.lkt:344:9>
--  pos=Token_Pos203, res=Token_Res203, nobt=None
Token_Res203 := Row_Pos144;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res203));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos203 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos144 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos144,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos203 := Row_Pos144 + 1;
   end if;
end;
--  END <Token(<WithText LBrack>, ) (root of 'list_pattern') at parser.lkt:344:9>
if Token_Pos203 /= No_Token_Index then
   Row_Pos144 := Token_Pos203;
else
   Row_Pos144 := No_Token_Index;
   goto Exit_Row144_0;
end if;
--  BEGIN <List (root of 'list_pattern') at parser.lkt:344:13>
--  pos=List_Pos27, res=List_Res27, nobt=None
    List_Pos27 := No_Token_Index;
Lst_Cpos27 := Row_Pos144;
Tmp_List27 := Get_Parse_List (Parser);
Diag_Mark77 := Parser.Last_Diag;
loop
--  BEGIN <Or (root of 'list_pattern') at parser.lkt:344:19>
--  pos=Or_Pos28, res=Or_Res28, nobt=None
Or_Pos28 := No_Token_Index;
Or_Res28 := No_Bare_Lkt_Node;
Diag_Mark76 := Parser.Last_Diag;
Last_Fail28 := Parser.Last_Fail;
Branch_Diag_Mark28 := Parser.Last_Diag;
Branch_Last_Fail28 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark76;
    Parser.Last_Fail := Last_Fail28;
--  BEGIN <Defer (for 'ellipsis_pattern') at parser.lkt:344:22>
--  pos=Defer_Pos186, res=Defer_Res186, nobt=None
Defer_Res186 :=
   Ellipsis_Pattern_Transform_Parse0 (Parser, Lst_Cpos27);
Defer_Pos186 := Parser.Current_Pos;
--  END <Defer (for 'ellipsis_pattern') at parser.lkt:344:22>
    if Defer_Pos186 /= No_Token_Index then
        Or_Pos28 := Defer_Pos186;
        Or_Res28 := Defer_Res186;
        goto Exit_Or32;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail28.Pos then
       Branch_Diag_Mark28 := Parser.Last_Diag;
       Branch_Last_Fail28 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark76;
    Parser.Last_Fail := Last_Fail28;
--  BEGIN <Defer (for 'value_pattern') at parser.lkt:344:41>
--  pos=Defer_Pos187, res=Defer_Res187, nobt=None
Defer_Res187 :=
   Value_Pattern_Or_Parse1 (Parser, Lst_Cpos27);
Defer_Pos187 := Parser.Current_Pos;
--  END <Defer (for 'value_pattern') at parser.lkt:344:41>
    if Defer_Pos187 /= No_Token_Index then
        Or_Pos28 := Defer_Pos187;
        Or_Res28 := Defer_Res187;
        goto Exit_Or32;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail28.Pos then
       Branch_Diag_Mark28 := Parser.Last_Diag;
       Branch_Last_Fail28 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark28;
Parser.Last_Fail := Branch_Last_Fail28;
<<Exit_Or32>>
--  END <Or (root of 'list_pattern') at parser.lkt:344:19>
   exit when Or_Pos28 = No_Token_Index;
   List_Pos27 := Or_Pos28;
   Lst_Cpos27 := List_Pos27;
   Diag_Mark77 := Parser.Last_Diag;
   Tmp_List27.Nodes.Append (Or_Res28);
--  BEGIN <Token(<WithText Comma>, ) (root of 'list_pattern') at parser.lkt:344:57>
--  pos=Token_Pos204, res=Token_Res204, nobt=None
Token_Res204 := Lst_Cpos27;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res204));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos204 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Lst_Cpos27 then
          Parser.Last_Fail :=
            (Pos  => Lst_Cpos27,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Comma,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos204 := Lst_Cpos27 + 1;
   end if;
end;
--  END <Token(<WithText Comma>, ) (root of 'list_pattern') at parser.lkt:344:57>
      exit when Token_Pos204 = No_Token_Index;
      Lst_Cpos27 := Token_Pos204;
end loop;
Parser.Last_Diag := Diag_Mark77;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List27.Nodes.Length;
begin
   List_Res27 := Allocate_Pattern_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos144;
      Token_End := (if Lst_Cpos27 = Row_Pos144
                    then Row_Pos144
                    else List_Pos27 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos144, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res27,
      Kind              => Lkt_Pattern_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res27,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List27.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res27.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List27);
--  END <List (root of 'list_pattern') at parser.lkt:344:13>
if List_Pos27 /= No_Token_Index then
   Row_Pos144 := List_Pos27;
else
   Row_Pos144 := No_Token_Index;
   goto Exit_Row144_0;
end if;
--  BEGIN <Token(<WithText RBrack>, ) (root of 'list_pattern') at parser.lkt:344:62>
--  pos=Token_Pos205, res=Token_Res205, nobt=None
Token_Res205 := Row_Pos144;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res205));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos205 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos144 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos144,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos205 := Row_Pos144 + 1;
   end if;
end;
--  END <Token(<WithText RBrack>, ) (root of 'list_pattern') at parser.lkt:344:62>
if Token_Pos205 /= No_Token_Index then
   Row_Pos144 := Token_Pos205;
else
   Row_Pos144 := No_Token_Index;
   goto Exit_Row144_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row144_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'list_pattern') at parser.lkt:343:21>
if Row_Pos144 /= No_Token_Index then
   Transform_Res109 := Allocate_List_Pattern (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res109,
      Kind => Lkt_List_Pattern,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos144 = Pos
                            then No_Token_Index
                            else Row_Pos144 - 1));
      Initialize_Fields_For_List_Pattern
        (Self => Transform_Res109,
         List_Pattern_F_Sub_Patterns => List_Res27);
         if List_Res27 /= null and then Is_Incomplete (List_Res27) then
            Transform_Res109.Last_Attempted_Child := 0;
         elsif List_Res27 /= null and then not Is_Ghost (List_Res27) then
            Transform_Res109.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType ListPattern>) (root of 'list_pattern') at parser.lkt:343:21>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos144 = No_Token_Index then
      Set_Failure
        (PP.List_Pattern_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.List_Pattern_Transform_Parse0_Memo, Pos, Transform_Res109, Parser.Last_Diag, Row_Pos144);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos144;
   return Transform_Res109;
end List_Pattern_Transform_Parse0;
   function Logic_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
      Row_Pos145 : Token_Index := No_Token_Index;
      Defer_Pos188 : Token_Index := No_Token_Index;
      Defer_Res188 : Bare_Expr := No_Bare_Lkt_Node;
      Row_Pos146 : Token_Index := No_Token_Index;
      Token_Pos206 : Token_Index := No_Token_Index;
      Token_Res206 : Token_Index := No_Token_Index;
      Token_Pos207 : Token_Index := No_Token_Index;
      Token_Res207 : Token_Index := No_Token_Index;
      Transform_Res110 : Bare_Op_Or_Int := No_Bare_Lkt_Node;
      Row_Pos147 : Token_Index := No_Token_Index;
      Token_Pos208 : Token_Index := No_Token_Index;
      Token_Res208 : Token_Index := No_Token_Index;
      Transform_Res111 : Bare_Op_Or := No_Bare_Lkt_Node;
      Row_Pos148 : Token_Index := No_Token_Index;
      Token_Pos209 : Token_Index := No_Token_Index;
      Token_Res209 : Token_Index := No_Token_Index;
      Transform_Res112 : Bare_Op_And := No_Bare_Lkt_Node;
      Row_Pos149 : Token_Index := No_Token_Index;
      Token_Pos210 : Token_Index := No_Token_Index;
      Token_Res210 : Token_Index := No_Token_Index;
      Token_Pos211 : Token_Index := No_Token_Index;
      Token_Res211 : Token_Index := No_Token_Index;
      Transform_Res113 : Bare_Op_Logic_And := No_Bare_Lkt_Node;
      Row_Pos150 : Token_Index := No_Token_Index;
      Token_Pos212 : Token_Index := No_Token_Index;
      Token_Res212 : Token_Index := No_Token_Index;
      Token_Pos213 : Token_Index := No_Token_Index;
      Token_Res213 : Token_Index := No_Token_Index;
      Transform_Res114 : Bare_Op_Logic_Or := No_Bare_Lkt_Node;
      Or_Pos29 : Token_Index := No_Token_Index;
      Or_Res29 : Bare_Op := No_Bare_Lkt_Node;
      Diag_Mark78 : Diagnostic_Mark;
      Last_Fail29 : Fail_Info;
      Branch_Diag_Mark29 : Diagnostic_Mark;
      Branch_Last_Fail29 : Fail_Info;
      Defer_Pos189 : Token_Index := No_Token_Index;
      Defer_Res189 : Bare_Expr := No_Bare_Lkt_Node;
      Transform_Res115 : Bare_Bin_Op := No_Bare_Lkt_Node;
      Defer_Pos190 : Token_Index := No_Token_Index;
      Defer_Res190 : Bare_Expr := No_Bare_Lkt_Node;
      Or_Pos30 : Token_Index := No_Token_Index;
      Or_Res30 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark79 : Diagnostic_Mark;
      Last_Fail30 : Fail_Info;
      Branch_Diag_Mark30 : Diagnostic_Mark;
      Branch_Last_Fail30 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
      Mem_Pos  : Token_Index := Pos;
      Mem_Res  : Bare_Expr := No_Bare_Lkt_Node;
      Mem_Mark : Diagnostic_Mark := Mark_On_Entry;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Logic_Or_Parse1_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res30 := M.Instance;
      return Or_Res30;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res30;
   end if;
   Parser.Last_Diag := No_Diagnostic;
       Set_Failure
         (PP.Logic_Or_Parse1_Memo,
          Pos,
          Parser.Last_Fail,
          Parser.Last_Diag);
       <<Try_Again>>
       Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'logic') at parser.lkt:363:14>
--  pos=Or_Pos30, res=Or_Res30, nobt=None
Or_Pos30 := No_Token_Index;
Or_Res30 := No_Bare_Lkt_Node;
Diag_Mark79 := Parser.Last_Diag;
Last_Fail30 := Parser.Last_Fail;
Branch_Diag_Mark30 := Parser.Last_Diag;
Branch_Last_Fail30 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark79;
    Parser.Last_Fail := Last_Fail30;
--  BEGIN <Transform(<ASTNodeType BinOp>) (root of 'logic') at parser.lkt:364:11>
--  pos=Row_Pos145, res=Transform_Res115, nobt=None
--  BEGIN <_Row (root of 'logic') at parser.lkt:364:11>
--  pos=Row_Pos145, res=None, nobt=None
Row_Pos145 := Pos;
--  BEGIN <Defer (for 'logic') at parser.lkt:365:13>
--  pos=Defer_Pos188, res=Defer_Res188, nobt=None
Defer_Res188 :=
   Logic_Or_Parse1 (Parser, Row_Pos145);
Defer_Pos188 := Parser.Current_Pos;
--  END <Defer (for 'logic') at parser.lkt:365:13>
if Defer_Pos188 /= No_Token_Index then
   Row_Pos145 := Defer_Pos188;
else
   Row_Pos145 := No_Token_Index;
   goto Exit_Row145_0;
end if;
--  BEGIN <Or (root of 'logic') at parser.lkt:366:13>
--  pos=Or_Pos29, res=Or_Res29, nobt=None
Or_Pos29 := No_Token_Index;
Or_Res29 := No_Bare_Lkt_Node;
Diag_Mark78 := Parser.Last_Diag;
Last_Fail29 := Parser.Last_Fail;
Branch_Diag_Mark29 := Parser.Last_Diag;
Branch_Last_Fail29 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark78;
    Parser.Last_Fail := Last_Fail29;
--  BEGIN <Transform(<ASTNodeType Op.OrInt>) (root of 'logic') at parser.lkt:367:19>
--  pos=Row_Pos146, res=Transform_Res110, nobt=None
--  BEGIN <_Row (root of 'logic') at parser.lkt:367:19>
--  pos=Row_Pos146, res=None, nobt=None
Row_Pos146 := Row_Pos145;
--  BEGIN <Token(<WithText OrKw>, ) (root of 'logic') at parser.lkt:367:28>
--  pos=Token_Pos206, res=Token_Res206, nobt=None
Token_Res206 := Row_Pos146;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res206));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Or_Kw)
   then
       Token_Pos206 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos146 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos146,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Or_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos206 := Row_Pos146 + 1;
   end if;
end;
--  END <Token(<WithText OrKw>, ) (root of 'logic') at parser.lkt:367:28>
if Token_Pos206 /= No_Token_Index then
   Row_Pos146 := Token_Pos206;
else
   Row_Pos146 := No_Token_Index;
   goto Exit_Row146_0;
end if;
--  BEGIN <Token(<WithText IntMark>, ) (root of 'logic') at parser.lkt:367:33>
--  pos=Token_Pos207, res=Token_Res207, nobt=None
Token_Res207 := Row_Pos146;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res207));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Int_Mark)
   then
       Token_Pos207 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos146 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos146,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Int_Mark,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos207 := Row_Pos146 + 1;
   end if;
end;
--  END <Token(<WithText IntMark>, ) (root of 'logic') at parser.lkt:367:33>
if Token_Pos207 /= No_Token_Index then
   Row_Pos146 := Token_Pos207;
else
   Row_Pos146 := No_Token_Index;
   goto Exit_Row146_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row146_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'logic') at parser.lkt:367:19>
if Row_Pos146 /= No_Token_Index then
   Transform_Res110 := Allocate_Op_Or_Int (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res110,
      Kind => Lkt_Op_Or_Int,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos145,
      Token_End_Index   => (if Row_Pos146 = Row_Pos145
                            then No_Token_Index
                            else Row_Pos146 - 1));
end if;
--  END <Transform(<ASTNodeType Op.OrInt>) (root of 'logic') at parser.lkt:367:19>
    if Row_Pos146 /= No_Token_Index then
        Or_Pos29 := Row_Pos146;
        Or_Res29 := Transform_Res110;
        goto Exit_Or34;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail29.Pos then
       Branch_Diag_Mark29 := Parser.Last_Diag;
       Branch_Last_Fail29 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark78;
    Parser.Last_Fail := Last_Fail29;
--  BEGIN <Transform(<ASTNodeType Op.Or>) (root of 'logic') at parser.lkt:368:19>
--  pos=Row_Pos147, res=Transform_Res111, nobt=None
--  BEGIN <_Row (root of 'logic') at parser.lkt:368:19>
--  pos=Row_Pos147, res=None, nobt=None
Row_Pos147 := Row_Pos145;
--  BEGIN <Token(<WithText OrKw>, ) (root of 'logic') at parser.lkt:368:25>
--  pos=Token_Pos208, res=Token_Res208, nobt=None
Token_Res208 := Row_Pos147;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res208));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Or_Kw)
   then
       Token_Pos208 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos147 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos147,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Or_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos208 := Row_Pos147 + 1;
   end if;
end;
--  END <Token(<WithText OrKw>, ) (root of 'logic') at parser.lkt:368:25>
if Token_Pos208 /= No_Token_Index then
   Row_Pos147 := Token_Pos208;
else
   Row_Pos147 := No_Token_Index;
   goto Exit_Row147_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row147_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'logic') at parser.lkt:368:19>
if Row_Pos147 /= No_Token_Index then
   Transform_Res111 := Allocate_Op_Or (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res111,
      Kind => Lkt_Op_Or,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos145,
      Token_End_Index   => (if Row_Pos147 = Row_Pos145
                            then No_Token_Index
                            else Row_Pos147 - 1));
end if;
--  END <Transform(<ASTNodeType Op.Or>) (root of 'logic') at parser.lkt:368:19>
    if Row_Pos147 /= No_Token_Index then
        Or_Pos29 := Row_Pos147;
        Or_Res29 := Transform_Res111;
        goto Exit_Or34;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail29.Pos then
       Branch_Diag_Mark29 := Parser.Last_Diag;
       Branch_Last_Fail29 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark78;
    Parser.Last_Fail := Last_Fail29;
--  BEGIN <Transform(<ASTNodeType Op.And>) (root of 'logic') at parser.lkt:369:19>
--  pos=Row_Pos148, res=Transform_Res112, nobt=None
--  BEGIN <_Row (root of 'logic') at parser.lkt:369:19>
--  pos=Row_Pos148, res=None, nobt=None
Row_Pos148 := Row_Pos145;
--  BEGIN <Token(<WithText AndKw>, ) (root of 'logic') at parser.lkt:369:26>
--  pos=Token_Pos209, res=Token_Res209, nobt=None
Token_Res209 := Row_Pos148;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res209));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_And_Kw)
   then
       Token_Pos209 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos148 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos148,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_And_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos209 := Row_Pos148 + 1;
   end if;
end;
--  END <Token(<WithText AndKw>, ) (root of 'logic') at parser.lkt:369:26>
if Token_Pos209 /= No_Token_Index then
   Row_Pos148 := Token_Pos209;
else
   Row_Pos148 := No_Token_Index;
   goto Exit_Row148_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row148_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'logic') at parser.lkt:369:19>
if Row_Pos148 /= No_Token_Index then
   Transform_Res112 := Allocate_Op_And (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res112,
      Kind => Lkt_Op_And,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos145,
      Token_End_Index   => (if Row_Pos148 = Row_Pos145
                            then No_Token_Index
                            else Row_Pos148 - 1));
end if;
--  END <Transform(<ASTNodeType Op.And>) (root of 'logic') at parser.lkt:369:19>
    if Row_Pos148 /= No_Token_Index then
        Or_Pos29 := Row_Pos148;
        Or_Res29 := Transform_Res112;
        goto Exit_Or34;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail29.Pos then
       Branch_Diag_Mark29 := Parser.Last_Diag;
       Branch_Last_Fail29 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark78;
    Parser.Last_Fail := Last_Fail29;
--  BEGIN <Transform(<ASTNodeType Op.LogicAnd>) (root of 'logic') at parser.lkt:370:19>
--  pos=Row_Pos149, res=Transform_Res113, nobt=None
--  BEGIN <_Row (root of 'logic') at parser.lkt:370:19>
--  pos=Row_Pos149, res=None, nobt=None
Row_Pos149 := Row_Pos145;
--  BEGIN <Token(<WithText Percent>, ) (root of 'logic') at parser.lkt:370:31>
--  pos=Token_Pos210, res=Token_Res210, nobt=None
Token_Res210 := Row_Pos149;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res210));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Percent)
   then
       Token_Pos210 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos149 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos149,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Percent,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos210 := Row_Pos149 + 1;
   end if;
end;
--  END <Token(<WithText Percent>, ) (root of 'logic') at parser.lkt:370:31>
if Token_Pos210 /= No_Token_Index then
   Row_Pos149 := Token_Pos210;
else
   Row_Pos149 := No_Token_Index;
   goto Exit_Row149_0;
end if;
--  BEGIN <Token(<WithText AndKw>, ) (root of 'logic') at parser.lkt:370:35>
--  pos=Token_Pos211, res=Token_Res211, nobt=None
Token_Res211 := Row_Pos149;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res211));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_And_Kw)
   then
       Token_Pos211 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos149 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos149,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_And_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos211 := Row_Pos149 + 1;
   end if;
end;
--  END <Token(<WithText AndKw>, ) (root of 'logic') at parser.lkt:370:35>
if Token_Pos211 /= No_Token_Index then
   Row_Pos149 := Token_Pos211;
else
   Row_Pos149 := No_Token_Index;
   goto Exit_Row149_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row149_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'logic') at parser.lkt:370:19>
if Row_Pos149 /= No_Token_Index then
   Transform_Res113 := Allocate_Op_Logic_And (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res113,
      Kind => Lkt_Op_Logic_And,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos145,
      Token_End_Index   => (if Row_Pos149 = Row_Pos145
                            then No_Token_Index
                            else Row_Pos149 - 1));
end if;
--  END <Transform(<ASTNodeType Op.LogicAnd>) (root of 'logic') at parser.lkt:370:19>
    if Row_Pos149 /= No_Token_Index then
        Or_Pos29 := Row_Pos149;
        Or_Res29 := Transform_Res113;
        goto Exit_Or34;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail29.Pos then
       Branch_Diag_Mark29 := Parser.Last_Diag;
       Branch_Last_Fail29 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark78;
    Parser.Last_Fail := Last_Fail29;
--  BEGIN <Transform(<ASTNodeType Op.LogicOr>) (root of 'logic') at parser.lkt:371:19>
--  pos=Row_Pos150, res=Transform_Res114, nobt=None
--  BEGIN <_Row (root of 'logic') at parser.lkt:371:19>
--  pos=Row_Pos150, res=None, nobt=None
Row_Pos150 := Row_Pos145;
--  BEGIN <Token(<WithText Percent>, ) (root of 'logic') at parser.lkt:371:30>
--  pos=Token_Pos212, res=Token_Res212, nobt=None
Token_Res212 := Row_Pos150;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res212));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Percent)
   then
       Token_Pos212 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos150 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos150,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Percent,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos212 := Row_Pos150 + 1;
   end if;
end;
--  END <Token(<WithText Percent>, ) (root of 'logic') at parser.lkt:371:30>
if Token_Pos212 /= No_Token_Index then
   Row_Pos150 := Token_Pos212;
else
   Row_Pos150 := No_Token_Index;
   goto Exit_Row150_0;
end if;
--  BEGIN <Token(<WithText OrKw>, ) (root of 'logic') at parser.lkt:371:34>
--  pos=Token_Pos213, res=Token_Res213, nobt=None
Token_Res213 := Row_Pos150;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res213));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Or_Kw)
   then
       Token_Pos213 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos150 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos150,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Or_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos213 := Row_Pos150 + 1;
   end if;
end;
--  END <Token(<WithText OrKw>, ) (root of 'logic') at parser.lkt:371:34>
if Token_Pos213 /= No_Token_Index then
   Row_Pos150 := Token_Pos213;
else
   Row_Pos150 := No_Token_Index;
   goto Exit_Row150_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row150_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'logic') at parser.lkt:371:19>
if Row_Pos150 /= No_Token_Index then
   Transform_Res114 := Allocate_Op_Logic_Or (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res114,
      Kind => Lkt_Op_Logic_Or,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos145,
      Token_End_Index   => (if Row_Pos150 = Row_Pos145
                            then No_Token_Index
                            else Row_Pos150 - 1));
end if;
--  END <Transform(<ASTNodeType Op.LogicOr>) (root of 'logic') at parser.lkt:371:19>
    if Row_Pos150 /= No_Token_Index then
        Or_Pos29 := Row_Pos150;
        Or_Res29 := Transform_Res114;
        goto Exit_Or34;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail29.Pos then
       Branch_Diag_Mark29 := Parser.Last_Diag;
       Branch_Last_Fail29 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark29;
Parser.Last_Fail := Branch_Last_Fail29;
<<Exit_Or34>>
--  END <Or (root of 'logic') at parser.lkt:366:13>
if Or_Pos29 /= No_Token_Index then
   Row_Pos145 := Or_Pos29;
else
   Row_Pos145 := No_Token_Index;
   goto Exit_Row145_0;
end if;
--  BEGIN <Defer (for 'rel') at parser.lkt:373:13>
--  pos=Defer_Pos189, res=Defer_Res189, nobt=None
Defer_Res189 :=
   Rel_Or_Parse0 (Parser, Row_Pos145);
Defer_Pos189 := Parser.Current_Pos;
--  END <Defer (for 'rel') at parser.lkt:373:13>
if Defer_Pos189 /= No_Token_Index then
   Row_Pos145 := Defer_Pos189;
else
   Row_Pos145 := No_Token_Index;
   goto Exit_Row145_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row145_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'logic') at parser.lkt:364:11>
if Row_Pos145 /= No_Token_Index then
   Transform_Res115 := Allocate_Bin_Op (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res115,
      Kind => Lkt_Bin_Op,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos145 = Pos
                            then No_Token_Index
                            else Row_Pos145 - 1));
      Initialize_Fields_For_Bin_Op
        (Self => Transform_Res115,
         Bin_Op_F_Left => Defer_Res188,
         Bin_Op_F_Op => Or_Res29,
         Bin_Op_F_Right => Defer_Res189);
         if Defer_Res188 /= null and then Is_Incomplete (Defer_Res188) then
            Transform_Res115.Last_Attempted_Child := 0;
         elsif Defer_Res188 /= null and then not Is_Ghost (Defer_Res188) then
            Transform_Res115.Last_Attempted_Child := -1;
         end if;
         if Or_Res29 /= null and then Is_Incomplete (Or_Res29) then
            Transform_Res115.Last_Attempted_Child := 0;
         elsif Or_Res29 /= null and then not Is_Ghost (Or_Res29) then
            Transform_Res115.Last_Attempted_Child := -1;
         end if;
         if Defer_Res189 /= null and then Is_Incomplete (Defer_Res189) then
            Transform_Res115.Last_Attempted_Child := 0;
         elsif Defer_Res189 /= null and then not Is_Ghost (Defer_Res189) then
            Transform_Res115.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType BinOp>) (root of 'logic') at parser.lkt:364:11>
    if Row_Pos145 /= No_Token_Index then
        Or_Pos30 := Row_Pos145;
        Or_Res30 := Transform_Res115;
        goto Exit_Or33;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail30.Pos then
       Branch_Diag_Mark30 := Parser.Last_Diag;
       Branch_Last_Fail30 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark79;
    Parser.Last_Fail := Last_Fail30;
--  BEGIN <Defer (for 'rel') at parser.lkt:375:11>
--  pos=Defer_Pos190, res=Defer_Res190, nobt=None
Defer_Res190 :=
   Rel_Or_Parse0 (Parser, Pos);
Defer_Pos190 := Parser.Current_Pos;
--  END <Defer (for 'rel') at parser.lkt:375:11>
    if Defer_Pos190 /= No_Token_Index then
        Or_Pos30 := Defer_Pos190;
        Or_Res30 := Defer_Res190;
        goto Exit_Or33;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail30.Pos then
       Branch_Diag_Mark30 := Parser.Last_Diag;
       Branch_Last_Fail30 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark30;
Parser.Last_Fail := Branch_Last_Fail30;
<<Exit_Or33>>
--  END <Or (root of 'logic') at parser.lkt:363:14>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
      if Or_Pos30 > Mem_Pos then
         Mem_Pos := Or_Pos30;
         Mem_Res := Or_Res30;
         Mem_Mark := Parser.Last_Diag;
         if Or_Pos30 = No_Token_Index then
            Set_Failure (PP.Logic_Or_Parse1_Memo, Pos, Parser.Last_Fail, Mem_Mark);
         else
            Memos.Set_Success
              (PP.Logic_Or_Parse1_Memo,
               Pos,
               Or_Res30,
               Mem_Mark,
               Or_Pos30);
         end if;
         goto Try_Again;
      elsif Mem_Pos > Pos then
         Or_Res30 := Mem_Res;
         Or_Pos30 := Mem_Pos;
         Parser.Last_Diag := Mem_Mark;
         goto No_Memo;
      end if;
   if Or_Pos30 = No_Token_Index then
      Set_Failure
        (PP.Logic_Or_Parse1_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Logic_Or_Parse1_Memo, Pos, Or_Res30, Parser.Last_Diag, Or_Pos30);
   end if;
       <<No_Memo>>
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos30;
   return Or_Res30;
end Logic_Or_Parse1;
   function Logic_Propagate_Call_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Logic_Propagate_Call
is
      Row_Pos151 : Token_Index := No_Token_Index;
      Defer_Pos191 : Token_Index := No_Token_Index;
      Defer_Res191 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos214 : Token_Index := No_Token_Index;
      Token_Res214 : Token_Index := No_Token_Index;
      Token_Pos215 : Token_Index := No_Token_Index;
      Token_Res215 : Token_Index := No_Token_Index;
      Defer_Pos192 : Token_Index := No_Token_Index;
      Defer_Res192 : Bare_Argument_List := No_Bare_Lkt_Node;
      Token_Pos216 : Token_Index := No_Token_Index;
      Token_Res216 : Token_Index := No_Token_Index;
      Transform_Res116 : Bare_Logic_Propagate_Call := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Logic_Propagate_Call_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res116 := M.Instance;
      return Transform_Res116;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res116;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType LogicPropagateCall>) (root of 'logic_propagate_call') at parser.lkt:413:29>
--  pos=Row_Pos151, res=Transform_Res116, nobt=None
--  BEGIN <_Row (root of 'logic_propagate_call') at parser.lkt:413:29>
--  pos=Row_Pos151, res=None, nobt=None
Row_Pos151 := Pos;
--  BEGIN <Defer (for 'callable_ref') at parser.lkt:413:48>
--  pos=Defer_Pos191, res=Defer_Res191, nobt=None
Defer_Res191 :=
   Callable_Ref_Or_Parse0 (Parser, Row_Pos151);
Defer_Pos191 := Parser.Current_Pos;
--  END <Defer (for 'callable_ref') at parser.lkt:413:48>
if Defer_Pos191 /= No_Token_Index then
   Row_Pos151 := Defer_Pos191;
else
   Row_Pos151 := No_Token_Index;
   goto Exit_Row151_0;
end if;
--  BEGIN <Token(<WithText Percent>, ) (root of 'logic_propagate_call') at parser.lkt:413:61>
--  pos=Token_Pos214, res=Token_Res214, nobt=None
Token_Res214 := Row_Pos151;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res214));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Percent)
   then
       Token_Pos214 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos151 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos151,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Percent,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos214 := Row_Pos151 + 1;
   end if;
end;
--  END <Token(<WithText Percent>, ) (root of 'logic_propagate_call') at parser.lkt:413:61>
if Token_Pos214 /= No_Token_Index then
   Row_Pos151 := Token_Pos214;
else
   Row_Pos151 := No_Token_Index;
   goto Exit_Row151_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'logic_propagate_call') at parser.lkt:413:65>
--  pos=Token_Pos215, res=Token_Res215, nobt=None
Token_Res215 := Row_Pos151;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res215));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos215 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos151 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos151,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos215 := Row_Pos151 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'logic_propagate_call') at parser.lkt:413:65>
if Token_Pos215 /= No_Token_Index then
   Row_Pos151 := Token_Pos215;
else
   Row_Pos151 := No_Token_Index;
   goto Exit_Row151_0;
end if;
--  BEGIN <Defer (for 'args') at parser.lkt:413:69>
--  pos=Defer_Pos192, res=Defer_Res192, nobt=None
Defer_Res192 :=
   Args_List_Parse0 (Parser, Row_Pos151);
Defer_Pos192 := Parser.Current_Pos;
--  END <Defer (for 'args') at parser.lkt:413:69>
if Defer_Pos192 /= No_Token_Index then
   Row_Pos151 := Defer_Pos192;
else
   Row_Pos151 := No_Token_Index;
   goto Exit_Row151_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'logic_propagate_call') at parser.lkt:413:74>
--  pos=Token_Pos216, res=Token_Res216, nobt=None
Token_Res216 := Row_Pos151;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res216));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos216 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos151 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos151,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos216 := Row_Pos151 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'logic_propagate_call') at parser.lkt:413:74>
if Token_Pos216 /= No_Token_Index then
   Row_Pos151 := Token_Pos216;
else
   Row_Pos151 := No_Token_Index;
   goto Exit_Row151_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row151_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'logic_propagate_call') at parser.lkt:413:29>
if Row_Pos151 /= No_Token_Index then
   Transform_Res116 := Allocate_Logic_Propagate_Call (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res116,
      Kind => Lkt_Logic_Propagate_Call,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos151 = Pos
                            then No_Token_Index
                            else Row_Pos151 - 1));
      Initialize_Fields_For_Logic_Propagate_Call
        (Self => Transform_Res116,
         Base_Call_Expr_F_Name => Defer_Res191,
         Base_Call_Expr_F_Args => Defer_Res192);
         if Defer_Res191 /= null and then Is_Incomplete (Defer_Res191) then
            Transform_Res116.Last_Attempted_Child := 0;
         elsif Defer_Res191 /= null and then not Is_Ghost (Defer_Res191) then
            Transform_Res116.Last_Attempted_Child := -1;
         end if;
         if Defer_Res192 /= null and then Is_Incomplete (Defer_Res192) then
            Transform_Res116.Last_Attempted_Child := 0;
         elsif Defer_Res192 /= null and then not Is_Ghost (Defer_Res192) then
            Transform_Res116.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType LogicPropagateCall>) (root of 'logic_propagate_call') at parser.lkt:413:29>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos151 = No_Token_Index then
      Set_Failure
        (PP.Logic_Propagate_Call_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Logic_Propagate_Call_Transform_Parse0_Memo, Pos, Transform_Res116, Parser.Last_Diag, Row_Pos151);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos151;
   return Transform_Res116;
end Logic_Propagate_Call_Transform_Parse0;
   function Main_Rule_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Langkit_Root
is
      Nobt36 : Boolean := False;
      Row_Pos152 : Token_Index := No_Token_Index;
      Defer_Pos193 : Token_Index := No_Token_Index;
      Defer_Res193 : Bare_Module_Doc_String_Lit := No_Bare_Lkt_Node;
      Defer_Pos194 : Token_Index := No_Token_Index;
      Defer_Res194 : Bare_Base_Import_List := No_Bare_Lkt_Node;
      Defer_Pos195 : Token_Index := No_Token_Index;
      Defer_Res195 : Bare_Full_Decl_List := No_Bare_Lkt_Node;
      Token_Pos217 : Token_Index := No_Token_Index;
      Token_Res217 : Token_Index := No_Token_Index;
      Row_Progress34 : Integer := 0;
      Transform_Res117 : Bare_Langkit_Root := No_Bare_Lkt_Node;
      Transform_Has_Failed34 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Main_Rule_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res117 := M.Instance;
      return Transform_Res117;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res117;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType LangkitRoot>) (root of 'main_rule') at parser.lkt:8:18>
--  pos=Row_Pos152, res=Transform_Res117, nobt=Nobt36
--  BEGIN <_Row (root of 'main_rule') at parser.lkt:8:18>
--  pos=Row_Pos152, res=None, nobt=Nobt36
Row_Pos152 := Pos;
--  BEGIN <Cut (root of 'main_rule') at parser.lkt:8:30>
--  pos=Row_Pos152, res=None, nobt=Nobt36
Nobt36 := True;
--  END <Cut (root of 'main_rule') at parser.lkt:8:30>
Row_Progress34 := 1;
if Row_Pos152 /= No_Token_Index then
   Row_Pos152 := Row_Pos152;
else
   Row_Pos152 := No_Token_Index;
   goto Exit_Row152_0;
end if;
--  BEGIN <Defer (for 'module_doc') at parser.lkt:8:32>
--  pos=Defer_Pos193, res=Defer_Res193, nobt=None
Defer_Res193 :=
   Module_Doc_Opt_Parse0 (Parser, Row_Pos152);
Defer_Pos193 := Parser.Current_Pos;
--  END <Defer (for 'module_doc') at parser.lkt:8:32>
Row_Progress34 := 2;
if Defer_Pos193 /= No_Token_Index then
   Row_Pos152 := Defer_Pos193;
else
   Row_Pos152 := No_Token_Index;
   goto Exit_Row152_0;
end if;
--  BEGIN <Defer (for 'imports') at parser.lkt:8:43>
--  pos=Defer_Pos194, res=Defer_Res194, nobt=None
Defer_Res194 :=
   Imports_List_Parse0 (Parser, Row_Pos152);
Defer_Pos194 := Parser.Current_Pos;
--  END <Defer (for 'imports') at parser.lkt:8:43>
Row_Progress34 := 3;
if Defer_Pos194 /= No_Token_Index then
   Row_Pos152 := Defer_Pos194;
else
   Row_Pos152 := No_Token_Index;
   goto Exit_Row152_0;
end if;
--  BEGIN <Defer (for 'decls') at parser.lkt:8:51>
--  pos=Defer_Pos195, res=Defer_Res195, nobt=None
Defer_Res195 :=
   Decls_Dont_Skip_Parse0 (Parser, Row_Pos152);
Defer_Pos195 := Parser.Current_Pos;
--  END <Defer (for 'decls') at parser.lkt:8:51>
Row_Progress34 := 4;
if Defer_Pos195 /= No_Token_Index then
   Row_Pos152 := Defer_Pos195;
else
   Row_Pos152 := No_Token_Index;
   goto Exit_Row152_0;
end if;
--  BEGIN <Token(<WithText Termination>, ) (root of 'main_rule') at parser.lkt:8:57>
--  pos=Token_Pos217, res=Token_Res217, nobt=None
Token_Res217 := Row_Pos152;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res217));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Termination)
   then
       Token_Pos217 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos152 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos152,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Termination,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos217 := Row_Pos152;
   end if;
end;
--  END <Token(<WithText Termination>, ) (root of 'main_rule') at parser.lkt:8:57>
Row_Progress34 := 5;
if Token_Pos217 /= No_Token_Index then
   Row_Pos152 := Token_Pos217;
else
   Row_Pos152 := No_Token_Index;
   goto Exit_Row152_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row152_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'main_rule') at parser.lkt:8:18>
if Row_Pos152 = No_Token_Index and then Nobt36 then
   Row_Pos152 := Parser.Last_Fail.Pos;
   Transform_Has_Failed34 := True;
end if;
if Row_Pos152 /= No_Token_Index then
   Transform_Res117 := Allocate_Langkit_Root (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res117,
      Kind => Lkt_Langkit_Root,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos152 = Pos
                            then No_Token_Index
                            else Row_Pos152 - 1));
      Initialize_Fields_For_Langkit_Root
        (Self => Transform_Res117,
         Langkit_Root_F_Doc => Defer_Res193,
         Langkit_Root_F_Imports => Defer_Res194,
         Langkit_Root_F_Decls => Defer_Res195);
         if Defer_Res193 /= null and then Is_Incomplete (Defer_Res193) then
            Transform_Res117.Last_Attempted_Child := 0;
         elsif Defer_Res193 /= null and then not Is_Ghost (Defer_Res193) then
            Transform_Res117.Last_Attempted_Child := -1;
         end if;
         if Defer_Res194 /= null and then Is_Incomplete (Defer_Res194) then
            Transform_Res117.Last_Attempted_Child := 0;
         elsif Defer_Res194 /= null and then not Is_Ghost (Defer_Res194) then
            Transform_Res117.Last_Attempted_Child := -1;
         end if;
         if Defer_Res195 /= null and then Is_Incomplete (Defer_Res195) then
            Transform_Res117.Last_Attempted_Child := 0;
         elsif Defer_Res195 /= null and then not Is_Ghost (Defer_Res195) then
            Transform_Res117.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed34 then
      Transform_Res117.Last_Attempted_Child :=
         Row_Progress34;
      Append (Parser, Pos, "Cannot parse <main_rule>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType LangkitRoot>) (root of 'main_rule') at parser.lkt:8:18>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos152 = No_Token_Index then
      Set_Failure
        (PP.Main_Rule_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Main_Rule_Transform_Parse0_Memo, Pos, Transform_Res117, Parser.Last_Diag, Row_Pos152);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos152;
   return Transform_Res117;
end Main_Rule_Transform_Parse0;
   function Match_Expr_Transform_Parse3
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Match_Expr
is
      Nobt37 : Boolean := False;
      Nobt38 : Boolean := False;
      Nobt39 : Boolean := False;
      Nobt40 : Boolean := False;
      Row_Pos153 : Token_Index := No_Token_Index;
      Token_Pos218 : Token_Index := No_Token_Index;
      Token_Res218 : Token_Index := No_Token_Index;
      Defer_Pos196 : Token_Index := No_Token_Index;
      Defer_Res196 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos219 : Token_Index := No_Token_Index;
      Token_Res219 : Token_Index := No_Token_Index;
      Lst_Cpos28 : Token_Index := No_Token_Index;
      Tmp_List28 : Free_Parse_List;
      Row_Pos154 : Token_Index := No_Token_Index;
      Token_Pos220 : Token_Index := No_Token_Index;
      Token_Res220 : Token_Index := No_Token_Index;
      Defer_Pos197 : Token_Index := No_Token_Index;
      Defer_Res197 : Bare_Pattern := No_Bare_Lkt_Node;
      Token_Pos221 : Token_Index := No_Token_Index;
      Token_Res221 : Token_Index := No_Token_Index;
      Defer_Pos198 : Token_Index := No_Token_Index;
      Defer_Res198 : Bare_Expr := No_Bare_Lkt_Node;
      Row_Progress35 : Integer := 0;
      Transform_Res118 : Bare_Pattern_Match_Branch := No_Bare_Lkt_Node;
      Transform_Has_Failed35 : Boolean := False;
      Row_Pos155 : Token_Index := No_Token_Index;
      Token_Pos222 : Token_Index := No_Token_Index;
      Token_Res222 : Token_Index := No_Token_Index;
      Row_Pos156 : Token_Index := No_Token_Index;
      Defer_Pos199 : Token_Index := No_Token_Index;
      Defer_Res199 : Bare_Def_Id := No_Bare_Lkt_Node;
      Row_Pos157 : Token_Index := No_Token_Index;
      Token_Pos223 : Token_Index := No_Token_Index;
      Token_Res223 : Token_Index := No_Token_Index;
      Defer_Pos200 : Token_Index := No_Token_Index;
      Defer_Res200 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Diag_Mark80 : Diagnostic_Mark;
      Row_Progress36 : Integer := 0;
      Transform_Res119 : Bare_Match_Val_Decl := No_Bare_Lkt_Node;
      Transform_Has_Failed36 : Boolean := False;
      Token_Pos224 : Token_Index := No_Token_Index;
      Token_Res224 : Token_Index := No_Token_Index;
      Defer_Pos201 : Token_Index := No_Token_Index;
      Defer_Res201 : Bare_Expr := No_Bare_Lkt_Node;
      Row_Progress37 : Integer := 0;
      Transform_Res120 : Bare_Match_Branch := No_Bare_Lkt_Node;
      Transform_Has_Failed37 : Boolean := False;
      Or_Pos31 : Token_Index := No_Token_Index;
      Or_Res31 : Bare_Base_Match_Branch := No_Bare_Lkt_Node;
      Diag_Mark81 : Diagnostic_Mark;
      Last_Fail31 : Fail_Info;
      Branch_Diag_Mark31 : Diagnostic_Mark;
      Branch_Last_Fail31 : Fail_Info;
      List_Pos28 : Token_Index := No_Token_Index;
      List_Res28 : Bare_Base_Match_Branch_List := No_Bare_Lkt_Node;
      Diag_Mark82 : Diagnostic_Mark;
      Token_Pos225 : Token_Index := No_Token_Index;
      Token_Res225 : Token_Index := No_Token_Index;
      Row_Progress38 : Integer := 0;
      Transform_Res121 : Bare_Match_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed38 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Match_Expr_Transform_Parse3_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res121 := M.Instance;
      return Transform_Res121;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res121;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType MatchExpr>) (root of 'match_expr') at parser.lkt:415:19>
--  pos=Row_Pos153, res=Transform_Res121, nobt=Nobt37
--  BEGIN <_Row (root of 'match_expr') at parser.lkt:415:19>
--  pos=Row_Pos153, res=None, nobt=Nobt37
Row_Pos153 := Pos;
--  BEGIN <Token(<WithText MatchKw>, ) (root of 'match_expr') at parser.lkt:416:9>
--  pos=Token_Pos218, res=Token_Res218, nobt=None
Token_Res218 := Row_Pos153;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res218));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Match_Kw)
   then
       Token_Pos218 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos153 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos153,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Match_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos218 := Row_Pos153 + 1;
   end if;
end;
--  END <Token(<WithText MatchKw>, ) (root of 'match_expr') at parser.lkt:416:9>
Row_Progress38 := 1;
if Token_Pos218 /= No_Token_Index then
   Row_Pos153 := Token_Pos218;
else
   Row_Pos153 := No_Token_Index;
   goto Exit_Row153_0;
end if;
--  BEGIN <Cut (root of 'match_expr') at parser.lkt:417:9>
--  pos=Row_Pos153, res=None, nobt=Nobt37
Nobt37 := True;
--  END <Cut (root of 'match_expr') at parser.lkt:417:9>
Row_Progress38 := 2;
if Row_Pos153 /= No_Token_Index then
   Row_Pos153 := Row_Pos153;
else
   Row_Pos153 := No_Token_Index;
   goto Exit_Row153_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:418:9>
--  pos=Defer_Pos196, res=Defer_Res196, nobt=None
Defer_Res196 :=
   Expr_Or_Parse0 (Parser, Row_Pos153);
Defer_Pos196 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:418:9>
Row_Progress38 := 3;
if Defer_Pos196 /= No_Token_Index then
   Row_Pos153 := Defer_Pos196;
else
   Row_Pos153 := No_Token_Index;
   goto Exit_Row153_0;
end if;
--  BEGIN <Token(<WithText LBrace>, ) (root of 'match_expr') at parser.lkt:419:9>
--  pos=Token_Pos219, res=Token_Res219, nobt=None
Token_Res219 := Row_Pos153;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res219));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos219 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos153 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos153,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos219 := Row_Pos153 + 1;
   end if;
end;
--  END <Token(<WithText LBrace>, ) (root of 'match_expr') at parser.lkt:419:9>
Row_Progress38 := 4;
if Token_Pos219 /= No_Token_Index then
   Row_Pos153 := Token_Pos219;
else
   Row_Pos153 := No_Token_Index;
   goto Exit_Row153_0;
end if;
--  BEGIN <List (root of 'match_expr') at parser.lkt:420:9>
--  pos=List_Pos28, res=List_Res28, nobt=None
    List_Pos28 := No_Token_Index;
Lst_Cpos28 := Row_Pos153;
Tmp_List28 := Get_Parse_List (Parser);
Diag_Mark82 := Parser.Last_Diag;
loop
--  BEGIN <Or (root of 'match_expr') at parser.lkt:420:15>
--  pos=Or_Pos31, res=Or_Res31, nobt=None
Or_Pos31 := No_Token_Index;
Or_Res31 := No_Bare_Lkt_Node;
Diag_Mark81 := Parser.Last_Diag;
Last_Fail31 := Parser.Last_Fail;
Branch_Diag_Mark31 := Parser.Last_Diag;
Branch_Last_Fail31 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark81;
    Parser.Last_Fail := Last_Fail31;
--  BEGIN <Transform(<ASTNodeType PatternMatchBranch>) (root of 'match_expr') at parser.lkt:421:15>
--  pos=Row_Pos154, res=Transform_Res118, nobt=Nobt38
--  BEGIN <_Row (root of 'match_expr') at parser.lkt:421:15>
--  pos=Row_Pos154, res=None, nobt=Nobt38
Row_Pos154 := Lst_Cpos28;
--  BEGIN <Token(<WithText CaseKw>, ) (root of 'match_expr') at parser.lkt:421:34>
--  pos=Token_Pos220, res=Token_Res220, nobt=None
Token_Res220 := Row_Pos154;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res220));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Case_Kw)
   then
       Token_Pos220 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos154 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos154,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Case_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos220 := Row_Pos154 + 1;
   end if;
end;
--  END <Token(<WithText CaseKw>, ) (root of 'match_expr') at parser.lkt:421:34>
Row_Progress35 := 1;
if Token_Pos220 /= No_Token_Index then
   Row_Pos154 := Token_Pos220;
else
   Row_Pos154 := No_Token_Index;
   goto Exit_Row154_0;
end if;
--  BEGIN <Defer (for 'pattern') at parser.lkt:421:41>
--  pos=Defer_Pos197, res=Defer_Res197, nobt=None
Defer_Res197 :=
   Pattern_Or_Parse0 (Parser, Row_Pos154);
Defer_Pos197 := Parser.Current_Pos;
--  END <Defer (for 'pattern') at parser.lkt:421:41>
Row_Progress35 := 2;
if Defer_Pos197 /= No_Token_Index then
   Row_Pos154 := Defer_Pos197;
else
   Row_Pos154 := No_Token_Index;
   goto Exit_Row154_0;
end if;
--  BEGIN <Token(<WithText FatRightArrow>, ) (root of 'match_expr') at parser.lkt:421:49>
--  pos=Token_Pos221, res=Token_Res221, nobt=None
Token_Res221 := Row_Pos154;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res221));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Fat_Right_Arrow)
   then
       Token_Pos221 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos154 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos154,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Fat_Right_Arrow,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos221 := Row_Pos154 + 1;
   end if;
end;
--  END <Token(<WithText FatRightArrow>, ) (root of 'match_expr') at parser.lkt:421:49>
Row_Progress35 := 3;
if Token_Pos221 /= No_Token_Index then
   Row_Pos154 := Token_Pos221;
else
   Row_Pos154 := No_Token_Index;
   goto Exit_Row154_0;
end if;
--  BEGIN <Cut (root of 'match_expr') at parser.lkt:421:54>
--  pos=Row_Pos154, res=None, nobt=Nobt38
Nobt38 := True;
--  END <Cut (root of 'match_expr') at parser.lkt:421:54>
Row_Progress35 := 4;
if Row_Pos154 /= No_Token_Index then
   Row_Pos154 := Row_Pos154;
else
   Row_Pos154 := No_Token_Index;
   goto Exit_Row154_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:421:56>
--  pos=Defer_Pos198, res=Defer_Res198, nobt=None
Defer_Res198 :=
   Expr_Or_Parse0 (Parser, Row_Pos154);
Defer_Pos198 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:421:56>
Row_Progress35 := 5;
if Defer_Pos198 /= No_Token_Index then
   Row_Pos154 := Defer_Pos198;
else
   Row_Pos154 := No_Token_Index;
   goto Exit_Row154_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row154_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'match_expr') at parser.lkt:421:15>
if Row_Pos154 = No_Token_Index and then Nobt38 then
   Row_Pos154 := Parser.Last_Fail.Pos;
   Transform_Has_Failed35 := True;
end if;
if Row_Pos154 /= No_Token_Index then
   Transform_Res118 := Allocate_Pattern_Match_Branch (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res118,
      Kind => Lkt_Pattern_Match_Branch,
      Unit => Parser.Unit,
      Token_Start_Index => Lst_Cpos28,
      Token_End_Index   => (if Row_Pos154 = Lst_Cpos28
                            then No_Token_Index
                            else Row_Pos154 - 1));
      Initialize_Fields_For_Pattern_Match_Branch
        (Self => Transform_Res118,
         Pattern_Match_Branch_F_Pattern => Defer_Res197,
         Pattern_Match_Branch_F_Expr => Defer_Res198);
         if Defer_Res197 /= null and then Is_Incomplete (Defer_Res197) then
            Transform_Res118.Last_Attempted_Child := 0;
         elsif Defer_Res197 /= null and then not Is_Ghost (Defer_Res197) then
            Transform_Res118.Last_Attempted_Child := -1;
         end if;
         if Defer_Res198 /= null and then Is_Incomplete (Defer_Res198) then
            Transform_Res118.Last_Attempted_Child := 0;
         elsif Defer_Res198 /= null and then not Is_Ghost (Defer_Res198) then
            Transform_Res118.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed35 then
      Transform_Res118.Last_Attempted_Child :=
         Row_Progress35;
      Append (Parser, Lst_Cpos28, "Cannot parse <match_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType PatternMatchBranch>) (root of 'match_expr') at parser.lkt:421:15>
    if Row_Pos154 /= No_Token_Index then
        Or_Pos31 := Row_Pos154;
        Or_Res31 := Transform_Res118;
        goto Exit_Or35;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail31.Pos then
       Branch_Diag_Mark31 := Parser.Last_Diag;
       Branch_Last_Fail31 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark81;
    Parser.Last_Fail := Last_Fail31;
--  BEGIN <Transform(<ASTNodeType MatchBranch>) (root of 'match_expr') at parser.lkt:422:15>
--  pos=Row_Pos155, res=Transform_Res120, nobt=Nobt40
--  BEGIN <_Row (root of 'match_expr') at parser.lkt:422:15>
--  pos=Row_Pos155, res=None, nobt=Nobt40
Row_Pos155 := Lst_Cpos28;
--  BEGIN <Token(<WithText CaseKw>, ) (root of 'match_expr') at parser.lkt:423:17>
--  pos=Token_Pos222, res=Token_Res222, nobt=None
Token_Res222 := Row_Pos155;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res222));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Case_Kw)
   then
       Token_Pos222 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos155 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos155,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Case_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos222 := Row_Pos155 + 1;
   end if;
end;
--  END <Token(<WithText CaseKw>, ) (root of 'match_expr') at parser.lkt:423:17>
Row_Progress37 := 1;
if Token_Pos222 /= No_Token_Index then
   Row_Pos155 := Token_Pos222;
else
   Row_Pos155 := No_Token_Index;
   goto Exit_Row155_0;
end if;
--  BEGIN <Transform(<ASTNodeType MatchValDecl>) (root of 'match_expr') at parser.lkt:423:24>
--  pos=Row_Pos156, res=Transform_Res119, nobt=Nobt40
--  BEGIN <_Row (root of 'match_expr') at parser.lkt:423:24>
--  pos=Row_Pos156, res=None, nobt=Nobt40
Row_Pos156 := Row_Pos155;
--  BEGIN <Defer (for 'def_id') at parser.lkt:423:37>
--  pos=Defer_Pos199, res=Defer_Res199, nobt=None
Defer_Res199 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos156);
Defer_Pos199 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:423:37>
Row_Progress36 := 1;
if Defer_Pos199 /= No_Token_Index then
   Row_Pos156 := Defer_Pos199;
else
   Row_Pos156 := No_Token_Index;
   goto Exit_Row156_0;
end if;
--  BEGIN <Opt (root of 'match_expr') at parser.lkt:423:44>
--  pos=Row_Pos157, res=Defer_Res200, nobt=Nobt39
Diag_Mark80 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'match_expr') at parser.lkt:423:45>
--  pos=Row_Pos157, res=Defer_Res200, nobt=Nobt39
--  BEGIN <_Row (root of 'match_expr') at parser.lkt:423:45>
--  pos=Row_Pos157, res=None, nobt=Nobt39
Row_Pos157 := Row_Pos156;
--  BEGIN <Token(<WithText Colon>, ) (root of 'match_expr') at parser.lkt:423:50>
--  pos=Token_Pos223, res=Token_Res223, nobt=None
Token_Res223 := Row_Pos157;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res223));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos223 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos157 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos157,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Colon,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos223 := Row_Pos157 + 1;
   end if;
end;
--  END <Token(<WithText Colon>, ) (root of 'match_expr') at parser.lkt:423:50>
if Token_Pos223 /= No_Token_Index then
   Row_Pos157 := Token_Pos223;
else
   Row_Pos157 := No_Token_Index;
   goto Exit_Row157_0;
end if;
--  BEGIN <Cut (root of 'match_expr') at parser.lkt:423:54>
--  pos=Row_Pos157, res=None, nobt=Nobt39
Nobt39 := True;
--  END <Cut (root of 'match_expr') at parser.lkt:423:54>
if Row_Pos157 /= No_Token_Index then
   Row_Pos157 := Row_Pos157;
else
   Row_Pos157 := No_Token_Index;
   goto Exit_Row157_0;
end if;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:423:56>
--  pos=Defer_Pos200, res=Defer_Res200, nobt=None
Defer_Res200 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos157);
Defer_Pos200 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:423:56>
if Defer_Pos200 /= No_Token_Index then
   Row_Pos157 := Defer_Pos200;
else
   Row_Pos157 := No_Token_Index;
   goto Exit_Row157_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row157_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'match_expr') at parser.lkt:423:45>
--  END <_Extract (root of 'match_expr') at parser.lkt:423:45>
if Row_Pos157 = No_Token_Index then
   if Nobt39 then
      Row_Pos157 := Parser.Last_Fail.Pos;
      Append (Parser, Row_Pos157, "Cannot parse <match_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
         if not Nobt39 then
   Defer_Res200 := No_Bare_Lkt_Node;
         end if;
       if not Nobt39 then
   Row_Pos157 := Row_Pos156;
      Parser.Last_Diag := Diag_Mark80;
       end if;
end if;
--  END <Opt (root of 'match_expr') at parser.lkt:423:44>
   Nobt40 := Nobt39;
Row_Progress36 := 2;
if Row_Pos157 /= No_Token_Index then
   Row_Pos156 := Row_Pos157;
else
   Row_Pos156 := No_Token_Index;
   goto Exit_Row156_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row156_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'match_expr') at parser.lkt:423:24>
if Row_Pos156 = No_Token_Index and then Nobt40 then
   Row_Pos156 := Parser.Last_Fail.Pos;
   Transform_Has_Failed36 := True;
end if;
if Row_Pos156 /= No_Token_Index then
   Transform_Res119 := Allocate_Match_Val_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res119,
      Kind => Lkt_Match_Val_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos155,
      Token_End_Index   => (if Row_Pos156 = Row_Pos155
                            then No_Token_Index
                            else Row_Pos156 - 1));
      Initialize_Fields_For_Match_Val_Decl
        (Self => Transform_Res119,
         Match_Val_Decl_F_Syn_Name => Defer_Res199,
         Match_Val_Decl_F_Decl_Type => Defer_Res200);
         if Defer_Res199 /= null and then Is_Incomplete (Defer_Res199) then
            Transform_Res119.Last_Attempted_Child := 0;
         elsif Defer_Res199 /= null and then not Is_Ghost (Defer_Res199) then
            Transform_Res119.Last_Attempted_Child := -1;
         end if;
         if Defer_Res200 /= null and then Is_Incomplete (Defer_Res200) then
            Transform_Res119.Last_Attempted_Child := 0;
         elsif Defer_Res200 /= null and then not Is_Ghost (Defer_Res200) then
            Transform_Res119.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed36 then
      Transform_Res119.Last_Attempted_Child :=
         Row_Progress36;
      Append (Parser, Row_Pos155, "Cannot parse <match_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType MatchValDecl>) (root of 'match_expr') at parser.lkt:423:24>
Row_Progress37 := 2;
if Row_Pos156 /= No_Token_Index then
   Row_Pos155 := Row_Pos156;
else
   Row_Pos155 := No_Token_Index;
   goto Exit_Row155_0;
end if;
--  BEGIN <Token(<WithText FatRightArrow>, ) (root of 'match_expr') at parser.lkt:423:67>
--  pos=Token_Pos224, res=Token_Res224, nobt=None
Token_Res224 := Row_Pos155;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res224));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Fat_Right_Arrow)
   then
       Token_Pos224 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos155 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos155,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Fat_Right_Arrow,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos224 := Row_Pos155 + 1;
   end if;
end;
--  END <Token(<WithText FatRightArrow>, ) (root of 'match_expr') at parser.lkt:423:67>
Row_Progress37 := 3;
if Token_Pos224 /= No_Token_Index then
   Row_Pos155 := Token_Pos224;
else
   Row_Pos155 := No_Token_Index;
   goto Exit_Row155_0;
end if;
--  BEGIN <Cut (root of 'match_expr') at parser.lkt:423:72>
--  pos=Row_Pos155, res=None, nobt=Nobt40
Nobt40 := True;
--  END <Cut (root of 'match_expr') at parser.lkt:423:72>
Row_Progress37 := 4;
if Row_Pos155 /= No_Token_Index then
   Row_Pos155 := Row_Pos155;
else
   Row_Pos155 := No_Token_Index;
   goto Exit_Row155_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:423:74>
--  pos=Defer_Pos201, res=Defer_Res201, nobt=None
Defer_Res201 :=
   Expr_Or_Parse0 (Parser, Row_Pos155);
Defer_Pos201 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:423:74>
Row_Progress37 := 5;
if Defer_Pos201 /= No_Token_Index then
   Row_Pos155 := Defer_Pos201;
else
   Row_Pos155 := No_Token_Index;
   goto Exit_Row155_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row155_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'match_expr') at parser.lkt:422:15>
if Row_Pos155 = No_Token_Index and then Nobt40 then
   Row_Pos155 := Parser.Last_Fail.Pos;
   Transform_Has_Failed37 := True;
end if;
if Row_Pos155 /= No_Token_Index then
   Transform_Res120 := Allocate_Match_Branch (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res120,
      Kind => Lkt_Match_Branch,
      Unit => Parser.Unit,
      Token_Start_Index => Lst_Cpos28,
      Token_End_Index   => (if Row_Pos155 = Lst_Cpos28
                            then No_Token_Index
                            else Row_Pos155 - 1));
      Initialize_Fields_For_Match_Branch
        (Self => Transform_Res120,
         Match_Branch_F_Decl => Transform_Res119,
         Match_Branch_F_Expr => Defer_Res201);
         if Transform_Res119 /= null and then Is_Incomplete (Transform_Res119) then
            Transform_Res120.Last_Attempted_Child := 0;
         elsif Transform_Res119 /= null and then not Is_Ghost (Transform_Res119) then
            Transform_Res120.Last_Attempted_Child := -1;
         end if;
         if Defer_Res201 /= null and then Is_Incomplete (Defer_Res201) then
            Transform_Res120.Last_Attempted_Child := 0;
         elsif Defer_Res201 /= null and then not Is_Ghost (Defer_Res201) then
            Transform_Res120.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed37 then
      Transform_Res120.Last_Attempted_Child :=
         Row_Progress37;
      Append (Parser, Lst_Cpos28, "Cannot parse <match_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType MatchBranch>) (root of 'match_expr') at parser.lkt:422:15>
    if Row_Pos155 /= No_Token_Index then
        Or_Pos31 := Row_Pos155;
        Or_Res31 := Transform_Res120;
        goto Exit_Or35;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail31.Pos then
       Branch_Diag_Mark31 := Parser.Last_Diag;
       Branch_Last_Fail31 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark31;
Parser.Last_Fail := Branch_Last_Fail31;
<<Exit_Or35>>
--  END <Or (root of 'match_expr') at parser.lkt:420:15>
   exit when Or_Pos31 = No_Token_Index;
   List_Pos28 := Or_Pos31;
   Lst_Cpos28 := List_Pos28;
   Diag_Mark82 := Parser.Last_Diag;
   Tmp_List28.Nodes.Append (Or_Res31);
      Nobt38 := False;
      Nobt39 := False;
      Nobt40 := False;
end loop;
Parser.Last_Diag := Diag_Mark82;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List28.Nodes.Length;
begin
   List_Res28 := Allocate_Base_Match_Branch_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos153;
      Token_End := (if Lst_Cpos28 = Row_Pos153
                    then Row_Pos153
                    else List_Pos28 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos153, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res28,
      Kind              => Lkt_Base_Match_Branch_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res28,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List28.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res28.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List28);
--  END <List (root of 'match_expr') at parser.lkt:420:9>
Row_Progress38 := 5;
if List_Pos28 /= No_Token_Index then
   Row_Pos153 := List_Pos28;
else
   Row_Pos153 := No_Token_Index;
   goto Exit_Row153_0;
end if;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'match_expr') at parser.lkt:426:9>
--  pos=Token_Pos225, res=Token_Res225, nobt=None
Token_Res225 := Row_Pos153;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res225));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos225 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos153 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos153,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos225 := Row_Pos153 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'match_expr') at parser.lkt:426:9>
Row_Progress38 := 6;
if Token_Pos225 /= No_Token_Index then
   Row_Pos153 := Token_Pos225;
else
   Row_Pos153 := No_Token_Index;
   goto Exit_Row153_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row153_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'match_expr') at parser.lkt:415:19>
if Row_Pos153 = No_Token_Index and then Nobt37 then
   Row_Pos153 := Parser.Last_Fail.Pos;
   Transform_Has_Failed38 := True;
end if;
if Row_Pos153 /= No_Token_Index then
   Transform_Res121 := Allocate_Match_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res121,
      Kind => Lkt_Match_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos153 = Pos
                            then No_Token_Index
                            else Row_Pos153 - 1));
      Initialize_Fields_For_Match_Expr
        (Self => Transform_Res121,
         Match_Expr_F_Match_Expr => Defer_Res196,
         Match_Expr_F_Branches => List_Res28);
         if Defer_Res196 /= null and then Is_Incomplete (Defer_Res196) then
            Transform_Res121.Last_Attempted_Child := 0;
         elsif Defer_Res196 /= null and then not Is_Ghost (Defer_Res196) then
            Transform_Res121.Last_Attempted_Child := -1;
         end if;
         if List_Res28 /= null and then Is_Incomplete (List_Res28) then
            Transform_Res121.Last_Attempted_Child := 0;
         elsif List_Res28 /= null and then not Is_Ghost (List_Res28) then
            Transform_Res121.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed38 then
      Transform_Res121.Last_Attempted_Child :=
         Row_Progress38;
      Append (Parser, Pos, "Cannot parse <match_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType MatchExpr>) (root of 'match_expr') at parser.lkt:415:19>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos153 = No_Token_Index then
      Set_Failure
        (PP.Match_Expr_Transform_Parse3_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Match_Expr_Transform_Parse3_Memo, Pos, Transform_Res121, Parser.Last_Diag, Row_Pos153);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos153;
   return Transform_Res121;
end Match_Expr_Transform_Parse3;
   function Module_Doc_Opt_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Module_Doc_String_Lit
is
      Row_Pos158 : Token_Index := No_Token_Index;
      Lst_Cpos29 : Token_Index := No_Token_Index;
      Tmp_List29 : Free_Parse_List;
      Row_Pos159 : Token_Index := No_Token_Index;
      Token_Pos226 : Token_Index := No_Token_Index;
      Token_Res226 : Token_Index := No_Token_Index;
      Transform_Res122 : Bare_Module_Doc_String_Line := No_Bare_Lkt_Node;
      List_Pos29 : Token_Index := No_Token_Index;
      List_Res29 : Bare_Module_Doc_String_Line_List := No_Bare_Lkt_Node;
      Diag_Mark83 : Diagnostic_Mark;
      Transform_Res123 : Bare_Module_Doc_String_Lit := No_Bare_Lkt_Node;
      Diag_Mark84 : Diagnostic_Mark;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Module_Doc_Opt_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res123 := M.Instance;
      return Transform_Res123;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res123;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Opt (root of 'module_doc') at parser.lkt:15:19>
--  pos=Row_Pos158, res=Transform_Res123, nobt=None
Diag_Mark84 := Parser.Last_Diag;
--  BEGIN <Transform(<ASTNodeType ModuleDocStringLit>) (root of 'module_doc') at parser.lkt:15:20>
--  pos=Row_Pos158, res=Transform_Res123, nobt=None
--  BEGIN <_Row (root of 'module_doc') at parser.lkt:15:20>
--  pos=Row_Pos158, res=None, nobt=None
Row_Pos158 := Pos;
--  BEGIN <List (root of 'module_doc') at parser.lkt:16:9>
--  pos=List_Pos29, res=List_Res29, nobt=None
    List_Pos29 := No_Token_Index;
Lst_Cpos29 := Row_Pos158;
Tmp_List29 := Get_Parse_List (Parser);
Diag_Mark83 := Parser.Last_Diag;
loop
--  BEGIN <Transform(<ASTNodeType ModuleDocStringLine>) (root of 'module_doc') at parser.lkt:16:15>
--  pos=Row_Pos159, res=Transform_Res122, nobt=None
--  BEGIN <_Row (root of 'module_doc') at parser.lkt:16:15>
--  pos=Row_Pos159, res=None, nobt=None
Row_Pos159 := Lst_Cpos29;
--  BEGIN <Token(<WithText ModuleDocStringLine>, ) (root of 'module_doc') at parser.lkt:16:35>
--  pos=Token_Pos226, res=Token_Res226, nobt=None
Token_Res226 := Row_Pos159;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res226));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Module_Doc_String_Line)
   then
       Token_Pos226 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos159 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos159,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Module_Doc_String_Line,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos226 := Row_Pos159 + 1;
   end if;
end;
--  END <Token(<WithText ModuleDocStringLine>, ) (root of 'module_doc') at parser.lkt:16:35>
if Token_Pos226 /= No_Token_Index then
   Row_Pos159 := Token_Pos226;
else
   Row_Pos159 := No_Token_Index;
   goto Exit_Row159_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row159_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'module_doc') at parser.lkt:16:15>
if Row_Pos159 /= No_Token_Index then
   Transform_Res122 := Allocate_Module_Doc_String_Line (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res122,
      Kind => Lkt_Module_Doc_String_Line,
      Unit => Parser.Unit,
      Token_Start_Index => Lst_Cpos29,
      Token_End_Index   => (if Row_Pos159 = Lst_Cpos29
                            then No_Token_Index
                            else Row_Pos159 - 1));
end if;
--  END <Transform(<ASTNodeType ModuleDocStringLine>) (root of 'module_doc') at parser.lkt:16:15>
   exit when Row_Pos159 = No_Token_Index;
   List_Pos29 := Row_Pos159;
   Lst_Cpos29 := List_Pos29;
   Diag_Mark83 := Parser.Last_Diag;
   Tmp_List29.Nodes.Append (Transform_Res122);
end loop;
Parser.Last_Diag := Diag_Mark83;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List29.Nodes.Length;
begin
   List_Res29 := Allocate_Module_Doc_String_Line_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos158;
      Token_End := (if Lst_Cpos29 = Row_Pos158
                    then Row_Pos158
                    else List_Pos29 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos158, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res29,
      Kind              => Lkt_Module_Doc_String_Line_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res29,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List29.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res29.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List29);
--  END <List (root of 'module_doc') at parser.lkt:16:9>
if List_Pos29 /= No_Token_Index then
   Row_Pos158 := List_Pos29;
else
   Row_Pos158 := No_Token_Index;
   goto Exit_Row158_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row158_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'module_doc') at parser.lkt:15:20>
if Row_Pos158 /= No_Token_Index then
   Transform_Res123 := Allocate_Module_Doc_String_Lit (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res123,
      Kind => Lkt_Module_Doc_String_Lit,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos158 = Pos
                            then No_Token_Index
                            else Row_Pos158 - 1));
      Initialize_Fields_For_Module_Doc_String_Lit
        (Self => Transform_Res123,
         Module_Doc_String_Lit_F_Lines => List_Res29);
         if List_Res29 /= null and then Is_Incomplete (List_Res29) then
            Transform_Res123.Last_Attempted_Child := 0;
         elsif List_Res29 /= null and then not Is_Ghost (List_Res29) then
            Transform_Res123.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType ModuleDocStringLit>) (root of 'module_doc') at parser.lkt:15:20>
if Row_Pos158 = No_Token_Index then
   Transform_Res123 := No_Bare_Lkt_Node;
   Row_Pos158 := Pos;
      Parser.Last_Diag := Diag_Mark84;
end if;
--  END <Opt (root of 'module_doc') at parser.lkt:15:19>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos158 = No_Token_Index then
      Set_Failure
        (PP.Module_Doc_Opt_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Module_Doc_Opt_Parse0_Memo, Pos, Transform_Res123, Parser.Last_Diag, Row_Pos158);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos158;
   return Transform_Res123;
end Module_Doc_Opt_Parse0;
   function Module_Id_Predicate_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Module_Id
is
      Row_Pos160 : Token_Index := No_Token_Index;
      Token_Pos227 : Token_Index := No_Token_Index;
      Token_Res227 : Token_Index := No_Token_Index;
      Transform_Res124 : Bare_Module_Id := No_Bare_Lkt_Node;
      Predicate_Pos0 : Token_Index := No_Token_Index;
      Predicate_Res0 : Bare_Module_Id := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Module_Id_Predicate_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Predicate_Res0 := M.Instance;
      return Predicate_Res0;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Predicate_Res0;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Predicate (root of 'module_id') at parser.lkt:12:18>
--  pos=Predicate_Pos0, res=Predicate_Res0, nobt=None
--  BEGIN <Transform(<ASTNodeType ModuleId>) (root of 'module_id') at parser.lkt:12:18>
--  pos=Row_Pos160, res=Transform_Res124, nobt=None
--  BEGIN <_Row (root of 'module_id') at parser.lkt:12:18>
--  pos=Row_Pos160, res=None, nobt=None
Row_Pos160 := Pos;
--  BEGIN <Token(<WithSymbol Identifier>, ) (root of 'module_id') at parser.lkt:12:27>
--  pos=Token_Pos227, res=Token_Res227, nobt=None
Token_Res227 := Row_Pos160;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res227));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
   then
       Token_Pos227 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos160 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos160,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos227 := Row_Pos160 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, ) (root of 'module_id') at parser.lkt:12:27>
if Token_Pos227 /= No_Token_Index then
   Row_Pos160 := Token_Pos227;
else
   Row_Pos160 := No_Token_Index;
   goto Exit_Row160_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row160_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'module_id') at parser.lkt:12:18>
if Row_Pos160 /= No_Token_Index then
   Transform_Res124 := Allocate_Module_Id (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res124,
      Kind => Lkt_Module_Id,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos160 = Pos
                            then No_Token_Index
                            else Row_Pos160 - 1));
      Initialize_Fields_For_Module_Id
        (Self => Transform_Res124);
end if;
--  END <Transform(<ASTNodeType ModuleId>) (root of 'module_id') at parser.lkt:12:18>
if Transform_Res124 /= null
   and then Liblktlang.Implementation.Id_P_Is_Not_Type_Name (Transform_Res124)
then
    Predicate_Res0 := Transform_Res124;
    Predicate_Pos0 := Row_Pos160;
else
    Predicate_Pos0 := No_Token_Index;
    Predicate_Res0 := null;
    if Parser.Last_Fail.Pos <= Pos then
       Parser.Last_Fail := (Pos  => Pos,
                            Data => (Kind => Predicate_Fail));
    end if;
end if;
--  END <Predicate (root of 'module_id') at parser.lkt:12:18>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Predicate_Pos0 = No_Token_Index then
      Set_Failure
        (PP.Module_Id_Predicate_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Module_Id_Predicate_Parse0_Memo, Pos, Predicate_Res0, Parser.Last_Diag, Predicate_Pos0);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Predicate_Pos0;
   return Predicate_Res0;
end Module_Id_Predicate_Parse0;
   function Null_Cond_Qual_Opt_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Null_Cond_Qualifier
is
      Token_Pos228 : Token_Index := No_Token_Index;
      Token_Res228 : Token_Index := No_Token_Index;
      Opt_Res2 : Bare_Null_Cond_Qualifier := No_Bare_Lkt_Node;
      Diag_Mark85 : Diagnostic_Mark;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Null_Cond_Qual_Opt_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Opt_Res2 := M.Instance;
      return Opt_Res2;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Opt_Res2;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Opt (root of 'null_cond_qual') at parser.lkt:457:23>
--  pos=Token_Pos228, res=Opt_Res2, nobt=None
Diag_Mark85 := Parser.Last_Diag;
--  BEGIN <Token(<WithText IntMark>, ) (root of 'null_cond_qual') at parser.lkt:457:41>
--  pos=Token_Pos228, res=Token_Res228, nobt=None
Token_Res228 := Pos;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res228));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Int_Mark)
   then
       Token_Pos228 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Pos then
          Parser.Last_Fail :=
            (Pos  => Pos,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Int_Mark,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos228 := Pos + 1;
   end if;
end;
--  END <Token(<WithText IntMark>, ) (root of 'null_cond_qual') at parser.lkt:457:41>
if Token_Pos228 = No_Token_Index then
         Opt_Res2 := Allocate_Null_Cond_Qualifier_Absent (Parser.Mem_Pool);
         Initialize
           (Self              => Opt_Res2,
            Kind              => Lkt_Null_Cond_Qualifier_Absent,
            Unit              => Parser.Unit,
            Token_Start_Index => Pos,
            Token_End_Index   => No_Token_Index);
   Token_Pos228 := Pos;
      Parser.Last_Diag := Diag_Mark85;
else
      Opt_Res2 := Allocate_Null_Cond_Qualifier_Present (Parser.Mem_Pool);
      Initialize
        (Self              => Opt_Res2,
         Kind              => Lkt_Null_Cond_Qualifier_Present,
         Unit              => Parser.Unit,
         Token_Start_Index => Pos,
         Token_End_Index   => Token_Pos228 - 1);
end if;
--  END <Opt (root of 'null_cond_qual') at parser.lkt:457:23>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Token_Pos228 = No_Token_Index then
      Set_Failure
        (PP.Null_Cond_Qual_Opt_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Null_Cond_Qual_Opt_Parse0_Memo, Pos, Opt_Res2, Parser.Last_Diag, Token_Pos228);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Token_Pos228;
   return Opt_Res2;
end Null_Cond_Qual_Opt_Parse0;
   function Null_Lit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Null_Lit
is
      Nobt41 : Boolean := False;
      Nobt42 : Boolean := False;
      Row_Pos161 : Token_Index := No_Token_Index;
      Token_Pos229 : Token_Index := No_Token_Index;
      Token_Res229 : Token_Index := No_Token_Index;
      Row_Pos162 : Token_Index := No_Token_Index;
      Token_Pos230 : Token_Index := No_Token_Index;
      Token_Res230 : Token_Index := No_Token_Index;
      Defer_Pos202 : Token_Index := No_Token_Index;
      Defer_Res202 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Token_Pos231 : Token_Index := No_Token_Index;
      Token_Res231 : Token_Index := No_Token_Index;
      Diag_Mark86 : Diagnostic_Mark;
      Row_Progress39 : Integer := 0;
      Transform_Res125 : Bare_Null_Lit := No_Bare_Lkt_Node;
      Transform_Has_Failed39 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Null_Lit_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res125 := M.Instance;
      return Transform_Res125;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res125;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType NullLit>) (root of 'null_lit') at parser.lkt:502:17>
--  pos=Row_Pos161, res=Transform_Res125, nobt=Nobt41
--  BEGIN <_Row (root of 'null_lit') at parser.lkt:502:17>
--  pos=Row_Pos161, res=None, nobt=Nobt41
Row_Pos161 := Pos;
--  BEGIN <Token(<WithText NullKw>, ) (root of 'null_lit') at parser.lkt:502:25>
--  pos=Token_Pos229, res=Token_Res229, nobt=None
Token_Res229 := Row_Pos161;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res229));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Null_Kw)
   then
       Token_Pos229 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos161 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos161,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Null_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos229 := Row_Pos161 + 1;
   end if;
end;
--  END <Token(<WithText NullKw>, ) (root of 'null_lit') at parser.lkt:502:25>
Row_Progress39 := 1;
if Token_Pos229 /= No_Token_Index then
   Row_Pos161 := Token_Pos229;
else
   Row_Pos161 := No_Token_Index;
   goto Exit_Row161_0;
end if;
--  BEGIN <Cut (root of 'null_lit') at parser.lkt:502:32>
--  pos=Row_Pos161, res=None, nobt=Nobt41
Nobt41 := True;
--  END <Cut (root of 'null_lit') at parser.lkt:502:32>
Row_Progress39 := 2;
if Row_Pos161 /= No_Token_Index then
   Row_Pos161 := Row_Pos161;
else
   Row_Pos161 := No_Token_Index;
   goto Exit_Row161_0;
end if;
--  BEGIN <Opt (root of 'null_lit') at parser.lkt:502:34>
--  pos=Row_Pos162, res=Defer_Res202, nobt=Nobt42
Diag_Mark86 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'null_lit') at parser.lkt:502:35>
--  pos=Row_Pos162, res=Defer_Res202, nobt=Nobt42
--  BEGIN <_Row (root of 'null_lit') at parser.lkt:502:35>
--  pos=Row_Pos162, res=None, nobt=Nobt42
Row_Pos162 := Row_Pos161;
--  BEGIN <Token(<WithText LBrack>, ) (root of 'null_lit') at parser.lkt:502:40>
--  pos=Token_Pos230, res=Token_Res230, nobt=None
Token_Res230 := Row_Pos162;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res230));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos230 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos162 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos162,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos230 := Row_Pos162 + 1;
   end if;
end;
--  END <Token(<WithText LBrack>, ) (root of 'null_lit') at parser.lkt:502:40>
if Token_Pos230 /= No_Token_Index then
   Row_Pos162 := Token_Pos230;
else
   Row_Pos162 := No_Token_Index;
   goto Exit_Row162_0;
end if;
--  BEGIN <Cut (root of 'null_lit') at parser.lkt:502:44>
--  pos=Row_Pos162, res=None, nobt=Nobt42
Nobt42 := True;
--  END <Cut (root of 'null_lit') at parser.lkt:502:44>
if Row_Pos162 /= No_Token_Index then
   Row_Pos162 := Row_Pos162;
else
   Row_Pos162 := No_Token_Index;
   goto Exit_Row162_0;
end if;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:502:46>
--  pos=Defer_Pos202, res=Defer_Res202, nobt=None
Defer_Res202 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos162);
Defer_Pos202 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:502:46>
if Defer_Pos202 /= No_Token_Index then
   Row_Pos162 := Defer_Pos202;
else
   Row_Pos162 := No_Token_Index;
   goto Exit_Row162_0;
end if;
--  BEGIN <Token(<WithText RBrack>, ) (root of 'null_lit') at parser.lkt:502:55>
--  pos=Token_Pos231, res=Token_Res231, nobt=None
Token_Res231 := Row_Pos162;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res231));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos231 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos162 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos162,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos231 := Row_Pos162 + 1;
   end if;
end;
--  END <Token(<WithText RBrack>, ) (root of 'null_lit') at parser.lkt:502:55>
if Token_Pos231 /= No_Token_Index then
   Row_Pos162 := Token_Pos231;
else
   Row_Pos162 := No_Token_Index;
   goto Exit_Row162_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row162_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'null_lit') at parser.lkt:502:35>
--  END <_Extract (root of 'null_lit') at parser.lkt:502:35>
if Row_Pos162 = No_Token_Index then
   if Nobt42 then
      Row_Pos162 := Parser.Last_Fail.Pos;
      Append (Parser, Row_Pos162, "Cannot parse <null_lit>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
         if not Nobt42 then
   Defer_Res202 := No_Bare_Lkt_Node;
         end if;
       if not Nobt42 then
   Row_Pos162 := Row_Pos161;
      Parser.Last_Diag := Diag_Mark86;
       end if;
end if;
--  END <Opt (root of 'null_lit') at parser.lkt:502:34>
   Nobt41 := Nobt42;
Row_Progress39 := 3;
if Row_Pos162 /= No_Token_Index then
   Row_Pos161 := Row_Pos162;
else
   Row_Pos161 := No_Token_Index;
   goto Exit_Row161_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row161_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'null_lit') at parser.lkt:502:17>
if Row_Pos161 = No_Token_Index and then Nobt41 then
   Row_Pos161 := Parser.Last_Fail.Pos;
   Transform_Has_Failed39 := True;
end if;
if Row_Pos161 /= No_Token_Index then
   Transform_Res125 := Allocate_Null_Lit (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res125,
      Kind => Lkt_Null_Lit,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos161 = Pos
                            then No_Token_Index
                            else Row_Pos161 - 1));
      Initialize_Fields_For_Null_Lit
        (Self => Transform_Res125,
         Null_Lit_F_Dest_Type => Defer_Res202);
         if Defer_Res202 /= null and then Is_Incomplete (Defer_Res202) then
            Transform_Res125.Last_Attempted_Child := 0;
         elsif Defer_Res202 /= null and then not Is_Ghost (Defer_Res202) then
            Transform_Res125.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed39 then
      Transform_Res125.Last_Attempted_Child :=
         Row_Progress39;
      Append (Parser, Pos, "Cannot parse <null_lit>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType NullLit>) (root of 'null_lit') at parser.lkt:502:17>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos161 = No_Token_Index then
      Set_Failure
        (PP.Null_Lit_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Null_Lit_Transform_Parse0_Memo, Pos, Transform_Res125, Parser.Last_Diag, Row_Pos161);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos161;
   return Transform_Res125;
end Null_Lit_Transform_Parse0;
   function Num_Lit_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Num_Lit
is
      Row_Pos163 : Token_Index := No_Token_Index;
      Token_Pos232 : Token_Index := No_Token_Index;
      Token_Res232 : Token_Index := No_Token_Index;
      Transform_Res126 : Bare_Num_Lit := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Num_Lit_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res126 := M.Instance;
      return Transform_Res126;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res126;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType NumLit>) (root of 'num_lit') at parser.lkt:428:16>
--  pos=Row_Pos163, res=Transform_Res126, nobt=None
--  BEGIN <_Row (root of 'num_lit') at parser.lkt:428:16>
--  pos=Row_Pos163, res=None, nobt=None
Row_Pos163 := Pos;
--  BEGIN <Token(<WithText Number>, ) (root of 'num_lit') at parser.lkt:428:23>
--  pos=Token_Pos232, res=Token_Res232, nobt=None
Token_Res232 := Row_Pos163;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res232));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Number)
   then
       Token_Pos232 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos163 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos163,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Number,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos232 := Row_Pos163 + 1;
   end if;
end;
--  END <Token(<WithText Number>, ) (root of 'num_lit') at parser.lkt:428:23>
if Token_Pos232 /= No_Token_Index then
   Row_Pos163 := Token_Pos232;
else
   Row_Pos163 := No_Token_Index;
   goto Exit_Row163_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row163_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'num_lit') at parser.lkt:428:16>
if Row_Pos163 /= No_Token_Index then
   Transform_Res126 := Allocate_Num_Lit (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res126,
      Kind => Lkt_Num_Lit,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos163 = Pos
                            then No_Token_Index
                            else Row_Pos163 - 1));
      Initialize_Fields_For_Num_Lit
        (Self => Transform_Res126);
end if;
--  END <Transform(<ASTNodeType NumLit>) (root of 'num_lit') at parser.lkt:428:16>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos163 = No_Token_Index then
      Set_Failure
        (PP.Num_Lit_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Num_Lit_Transform_Parse0_Memo, Pos, Transform_Res126, Parser.Last_Diag, Row_Pos163);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos163;
   return Transform_Res126;
end Num_Lit_Transform_Parse0;
   function Parse_Node_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Parse_Node_Expr
is
      Nobt43 : Boolean := False;
      Row_Pos164 : Token_Index := No_Token_Index;
      Defer_Pos203 : Token_Index := No_Token_Index;
      Defer_Res203 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Token_Pos233 : Token_Index := No_Token_Index;
      Token_Res233 : Token_Index := No_Token_Index;
      Lst_Cpos30 : Token_Index := No_Token_Index;
      Tmp_List30 : Free_Parse_List;
      Defer_Pos204 : Token_Index := No_Token_Index;
      Defer_Res204 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      List_Pos30 : Token_Index := No_Token_Index;
      List_Res30 : Bare_Grammar_Expr_List := No_Bare_Lkt_Node;
      Diag_Mark87 : Diagnostic_Mark;
      Token_Pos234 : Token_Index := No_Token_Index;
      Token_Res234 : Token_Index := No_Token_Index;
      Row_Progress40 : Integer := 0;
      Transform_Res127 : Bare_Parse_Node_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed40 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Parse_Node_Expr_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res127 := M.Instance;
      return Transform_Res127;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res127;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType ParseNodeExpr>) (root of 'parse_node_expr') at parser.lkt:128:24>
--  pos=Row_Pos164, res=Transform_Res127, nobt=Nobt43
--  BEGIN <_Row (root of 'parse_node_expr') at parser.lkt:128:24>
--  pos=Row_Pos164, res=None, nobt=Nobt43
Row_Pos164 := Pos;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:129:9>
--  pos=Defer_Pos203, res=Defer_Res203, nobt=None
Defer_Res203 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos164);
Defer_Pos203 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:129:9>
Row_Progress40 := 1;
if Defer_Pos203 /= No_Token_Index then
   Row_Pos164 := Defer_Pos203;
else
   Row_Pos164 := No_Token_Index;
   goto Exit_Row164_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'parse_node_expr') at parser.lkt:130:9>
--  pos=Token_Pos233, res=Token_Res233, nobt=None
Token_Res233 := Row_Pos164;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res233));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos233 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos164 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos164,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos233 := Row_Pos164 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'parse_node_expr') at parser.lkt:130:9>
Row_Progress40 := 2;
if Token_Pos233 /= No_Token_Index then
   Row_Pos164 := Token_Pos233;
else
   Row_Pos164 := No_Token_Index;
   goto Exit_Row164_0;
end if;
--  BEGIN <Cut (root of 'parse_node_expr') at parser.lkt:131:9>
--  pos=Row_Pos164, res=None, nobt=Nobt43
Nobt43 := True;
--  END <Cut (root of 'parse_node_expr') at parser.lkt:131:9>
Row_Progress40 := 3;
if Row_Pos164 /= No_Token_Index then
   Row_Pos164 := Row_Pos164;
else
   Row_Pos164 := No_Token_Index;
   goto Exit_Row164_0;
end if;
--  BEGIN <DontSkip (root of 'parse_node_expr') at parser.lkt:132:9>
--  pos=List_Pos30, res=List_Res30, nobt=None
        PP.Dont_Skip.Append (Dontskip_Parse_Node_Expr0_Extract_Parse0'Access);
--  BEGIN <List (root of 'parse_node_expr') at parser.lkt:132:9>
--  pos=List_Pos30, res=List_Res30, nobt=None
    List_Pos30 := Row_Pos164;
Lst_Cpos30 := Row_Pos164;
Tmp_List30 := Get_Parse_List (Parser);
Diag_Mark87 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'grammar_expr') at parser.lkt:132:15>
--  pos=Defer_Pos204, res=Defer_Res204, nobt=None
Defer_Res204 :=
   Grammar_Expr_Or_Parse0 (Parser, Lst_Cpos30);
Defer_Pos204 := Parser.Current_Pos;
--  END <Defer (for 'grammar_expr') at parser.lkt:132:15>
   exit when Defer_Pos204 = No_Token_Index;
   List_Pos30 := Defer_Pos204;
   Lst_Cpos30 := List_Pos30;
   Diag_Mark87 := Parser.Last_Diag;
   Tmp_List30.Nodes.Append (Defer_Res204);
end loop;
Parser.Last_Diag := Diag_Mark87;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List30.Nodes.Length;
begin
   List_Res30 := Allocate_Grammar_Expr_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos164;
      Token_End := (if Lst_Cpos30 = Row_Pos164
                    then Row_Pos164
                    else List_Pos30 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos164, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res30,
      Kind              => Lkt_Grammar_Expr_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res30,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List30.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res30.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List30);
--  END <List (root of 'parse_node_expr') at parser.lkt:132:9>
        PP.Dont_Skip.Delete_Last;
--  END <DontSkip (root of 'parse_node_expr') at parser.lkt:132:9>
Row_Progress40 := 4;
if List_Pos30 /= No_Token_Index then
   Row_Pos164 := List_Pos30;
else
   Row_Pos164 := No_Token_Index;
   goto Exit_Row164_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'parse_node_expr') at parser.lkt:133:9>
--  pos=Token_Pos234, res=Token_Res234, nobt=None
Token_Res234 := Row_Pos164;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res234));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos234 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos164 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos164,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos234 := Row_Pos164 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'parse_node_expr') at parser.lkt:133:9>
Row_Progress40 := 5;
if Token_Pos234 /= No_Token_Index then
   Row_Pos164 := Token_Pos234;
else
   Row_Pos164 := No_Token_Index;
   goto Exit_Row164_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row164_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'parse_node_expr') at parser.lkt:128:24>
if Row_Pos164 = No_Token_Index and then Nobt43 then
   Row_Pos164 := Parser.Last_Fail.Pos;
   Transform_Has_Failed40 := True;
end if;
if Row_Pos164 /= No_Token_Index then
   Transform_Res127 := Allocate_Parse_Node_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res127,
      Kind => Lkt_Parse_Node_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos164 = Pos
                            then No_Token_Index
                            else Row_Pos164 - 1));
      Initialize_Fields_For_Parse_Node_Expr
        (Self => Transform_Res127,
         Parse_Node_Expr_F_Node_Name => Defer_Res203,
         Parse_Node_Expr_F_Sub_Exprs => List_Res30);
         if Defer_Res203 /= null and then Is_Incomplete (Defer_Res203) then
            Transform_Res127.Last_Attempted_Child := 0;
         elsif Defer_Res203 /= null and then not Is_Ghost (Defer_Res203) then
            Transform_Res127.Last_Attempted_Child := -1;
         end if;
         if List_Res30 /= null and then Is_Incomplete (List_Res30) then
            Transform_Res127.Last_Attempted_Child := 0;
         elsif List_Res30 /= null and then not Is_Ghost (List_Res30) then
            Transform_Res127.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed40 then
      Transform_Res127.Last_Attempted_Child :=
         Row_Progress40;
      Append (Parser, Pos, "Cannot parse <parse_node_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType ParseNodeExpr>) (root of 'parse_node_expr') at parser.lkt:128:24>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos164 = No_Token_Index then
      Set_Failure
        (PP.Parse_Node_Expr_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Parse_Node_Expr_Transform_Parse0_Memo, Pos, Transform_Res127, Parser.Last_Diag, Row_Pos164);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos164;
   return Transform_Res127;
end Parse_Node_Expr_Transform_Parse0;
   function Pattern_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Pattern
is
      Row_Pos165 : Token_Index := No_Token_Index;
      Defer_Pos205 : Token_Index := No_Token_Index;
      Defer_Res205 : Bare_Pattern := No_Bare_Lkt_Node;
      Token_Pos235 : Token_Index := No_Token_Index;
      Token_Res235 : Token_Index := No_Token_Index;
      Defer_Pos206 : Token_Index := No_Token_Index;
      Defer_Res206 : Bare_Pattern := No_Bare_Lkt_Node;
      Transform_Res128 : Bare_Or_Pattern := No_Bare_Lkt_Node;
      Defer_Pos207 : Token_Index := No_Token_Index;
      Defer_Res207 : Bare_Pattern := No_Bare_Lkt_Node;
      Or_Pos32 : Token_Index := No_Token_Index;
      Or_Res32 : Bare_Pattern := No_Bare_Lkt_Node;
      Diag_Mark88 : Diagnostic_Mark;
      Last_Fail32 : Fail_Info;
      Branch_Diag_Mark32 : Diagnostic_Mark;
      Branch_Last_Fail32 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Pattern_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res32 := M.Instance;
      return Or_Res32;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res32;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'pattern') at parser.lkt:307:16>
--  pos=Or_Pos32, res=Or_Res32, nobt=None
Or_Pos32 := No_Token_Index;
Or_Res32 := No_Bare_Lkt_Node;
Diag_Mark88 := Parser.Last_Diag;
Last_Fail32 := Parser.Last_Fail;
Branch_Diag_Mark32 := Parser.Last_Diag;
Branch_Last_Fail32 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark88;
    Parser.Last_Fail := Last_Fail32;
--  BEGIN <Transform(<ASTNodeType OrPattern>) (root of 'pattern') at parser.lkt:307:19>
--  pos=Row_Pos165, res=Transform_Res128, nobt=None
--  BEGIN <_Row (root of 'pattern') at parser.lkt:307:19>
--  pos=Row_Pos165, res=None, nobt=None
Row_Pos165 := Pos;
--  BEGIN <Defer (for 'fil_pattern') at parser.lkt:307:29>
--  pos=Defer_Pos205, res=Defer_Res205, nobt=None
Defer_Res205 :=
   Fil_Pattern_Or_Parse0 (Parser, Row_Pos165);
Defer_Pos205 := Parser.Current_Pos;
--  END <Defer (for 'fil_pattern') at parser.lkt:307:29>
if Defer_Pos205 /= No_Token_Index then
   Row_Pos165 := Defer_Pos205;
else
   Row_Pos165 := No_Token_Index;
   goto Exit_Row165_0;
end if;
--  BEGIN <Token(<WithText Pipe>, ) (root of 'pattern') at parser.lkt:307:41>
--  pos=Token_Pos235, res=Token_Res235, nobt=None
Token_Res235 := Row_Pos165;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res235));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Pipe)
   then
       Token_Pos235 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos165 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos165,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Pipe,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos235 := Row_Pos165 + 1;
   end if;
end;
--  END <Token(<WithText Pipe>, ) (root of 'pattern') at parser.lkt:307:41>
if Token_Pos235 /= No_Token_Index then
   Row_Pos165 := Token_Pos235;
else
   Row_Pos165 := No_Token_Index;
   goto Exit_Row165_0;
end if;
--  BEGIN <Defer (for 'pattern') at parser.lkt:307:45>
--  pos=Defer_Pos206, res=Defer_Res206, nobt=None
Defer_Res206 :=
   Pattern_Or_Parse0 (Parser, Row_Pos165);
Defer_Pos206 := Parser.Current_Pos;
--  END <Defer (for 'pattern') at parser.lkt:307:45>
if Defer_Pos206 /= No_Token_Index then
   Row_Pos165 := Defer_Pos206;
else
   Row_Pos165 := No_Token_Index;
   goto Exit_Row165_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row165_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'pattern') at parser.lkt:307:19>
if Row_Pos165 /= No_Token_Index then
   Transform_Res128 := Allocate_Or_Pattern (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res128,
      Kind => Lkt_Or_Pattern,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos165 = Pos
                            then No_Token_Index
                            else Row_Pos165 - 1));
      Initialize_Fields_For_Or_Pattern
        (Self => Transform_Res128,
         Or_Pattern_F_Left_Sub_Pattern => Defer_Res205,
         Or_Pattern_F_Right_Sub_Pattern => Defer_Res206);
         if Defer_Res205 /= null and then Is_Incomplete (Defer_Res205) then
            Transform_Res128.Last_Attempted_Child := 0;
         elsif Defer_Res205 /= null and then not Is_Ghost (Defer_Res205) then
            Transform_Res128.Last_Attempted_Child := -1;
         end if;
         if Defer_Res206 /= null and then Is_Incomplete (Defer_Res206) then
            Transform_Res128.Last_Attempted_Child := 0;
         elsif Defer_Res206 /= null and then not Is_Ghost (Defer_Res206) then
            Transform_Res128.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType OrPattern>) (root of 'pattern') at parser.lkt:307:19>
    if Row_Pos165 /= No_Token_Index then
        Or_Pos32 := Row_Pos165;
        Or_Res32 := Transform_Res128;
        goto Exit_Or36;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail32.Pos then
       Branch_Diag_Mark32 := Parser.Last_Diag;
       Branch_Last_Fail32 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark88;
    Parser.Last_Fail := Last_Fail32;
--  BEGIN <Defer (for 'fil_pattern') at parser.lkt:307:56>
--  pos=Defer_Pos207, res=Defer_Res207, nobt=None
Defer_Res207 :=
   Fil_Pattern_Or_Parse0 (Parser, Pos);
Defer_Pos207 := Parser.Current_Pos;
--  END <Defer (for 'fil_pattern') at parser.lkt:307:56>
    if Defer_Pos207 /= No_Token_Index then
        Or_Pos32 := Defer_Pos207;
        Or_Res32 := Defer_Res207;
        goto Exit_Or36;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail32.Pos then
       Branch_Diag_Mark32 := Parser.Last_Diag;
       Branch_Last_Fail32 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark32;
Parser.Last_Fail := Branch_Last_Fail32;
<<Exit_Or36>>
--  END <Or (root of 'pattern') at parser.lkt:307:16>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos32 = No_Token_Index then
      Set_Failure
        (PP.Pattern_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Pattern_Or_Parse0_Memo, Pos, Or_Res32, Parser.Last_Diag, Or_Pos32);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos32;
   return Or_Res32;
end Pattern_Or_Parse0;
   function Pattern_Arg_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Pattern_Detail
is
      Nobt44 : Boolean := False;
      Nobt45 : Boolean := False;
      Row_Pos166 : Token_Index := No_Token_Index;
      Defer_Pos208 : Token_Index := No_Token_Index;
      Defer_Res208 : Bare_Selector_Call := No_Bare_Lkt_Node;
      Token_Pos236 : Token_Index := No_Token_Index;
      Token_Res236 : Token_Index := No_Token_Index;
      Defer_Pos209 : Token_Index := No_Token_Index;
      Defer_Res209 : Bare_Pattern := No_Bare_Lkt_Node;
      Transform_Res129 : Bare_Selector_Pattern_Detail := No_Bare_Lkt_Node;
      Row_Pos167 : Token_Index := No_Token_Index;
      Defer_Pos210 : Token_Index := No_Token_Index;
      Defer_Res210 : Bare_Id := No_Bare_Lkt_Node;
      Token_Pos237 : Token_Index := No_Token_Index;
      Token_Res237 : Token_Index := No_Token_Index;
      Defer_Pos211 : Token_Index := No_Token_Index;
      Defer_Res211 : Bare_Pattern := No_Bare_Lkt_Node;
      Row_Progress41 : Integer := 0;
      Transform_Res130 : Bare_Field_Pattern_Detail := No_Bare_Lkt_Node;
      Transform_Has_Failed41 : Boolean := False;
      Row_Pos168 : Token_Index := No_Token_Index;
      Defer_Pos212 : Token_Index := No_Token_Index;
      Defer_Res212 : Bare_Expr := No_Bare_Lkt_Node;
      Predicate_Pos1 : Token_Index := No_Token_Index;
      Predicate_Res1 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos238 : Token_Index := No_Token_Index;
      Token_Res238 : Token_Index := No_Token_Index;
      Defer_Pos213 : Token_Index := No_Token_Index;
      Defer_Res213 : Bare_Pattern := No_Bare_Lkt_Node;
      Row_Progress42 : Integer := 0;
      Transform_Res131 : Bare_Property_Pattern_Detail := No_Bare_Lkt_Node;
      Transform_Has_Failed42 : Boolean := False;
      Or_Pos33 : Token_Index := No_Token_Index;
      Or_Res33 : Bare_Pattern_Detail := No_Bare_Lkt_Node;
      Diag_Mark89 : Diagnostic_Mark;
      Last_Fail33 : Fail_Info;
      Branch_Diag_Mark33 : Diagnostic_Mark;
      Branch_Last_Fail33 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Pattern_Arg_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res33 := M.Instance;
      return Or_Res33;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res33;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'pattern_arg') at parser.lkt:347:20>
--  pos=Or_Pos33, res=Or_Res33, nobt=None
Or_Pos33 := No_Token_Index;
Or_Res33 := No_Bare_Lkt_Node;
Diag_Mark89 := Parser.Last_Diag;
Last_Fail33 := Parser.Last_Fail;
Branch_Diag_Mark33 := Parser.Last_Diag;
Branch_Last_Fail33 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark89;
    Parser.Last_Fail := Last_Fail33;
--  BEGIN <Transform(<ASTNodeType SelectorPatternDetail>) (root of 'pattern_arg') at parser.lkt:348:11>
--  pos=Row_Pos166, res=Transform_Res129, nobt=None
--  BEGIN <_Row (root of 'pattern_arg') at parser.lkt:348:11>
--  pos=Row_Pos166, res=None, nobt=None
Row_Pos166 := Pos;
--  BEGIN <Defer (for 'selector_call') at parser.lkt:348:33>
--  pos=Defer_Pos208, res=Defer_Res208, nobt=None
Defer_Res208 :=
   Selector_Call_Transform_Parse0 (Parser, Row_Pos166);
Defer_Pos208 := Parser.Current_Pos;
--  END <Defer (for 'selector_call') at parser.lkt:348:33>
if Defer_Pos208 /= No_Token_Index then
   Row_Pos166 := Defer_Pos208;
else
   Row_Pos166 := No_Token_Index;
   goto Exit_Row166_0;
end if;
--  BEGIN <Token(<WithText Colon>, ) (root of 'pattern_arg') at parser.lkt:348:47>
--  pos=Token_Pos236, res=Token_Res236, nobt=None
Token_Res236 := Row_Pos166;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res236));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos236 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos166 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos166,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Colon,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos236 := Row_Pos166 + 1;
   end if;
end;
--  END <Token(<WithText Colon>, ) (root of 'pattern_arg') at parser.lkt:348:47>
if Token_Pos236 /= No_Token_Index then
   Row_Pos166 := Token_Pos236;
else
   Row_Pos166 := No_Token_Index;
   goto Exit_Row166_0;
end if;
--  BEGIN <Defer (for 'pattern') at parser.lkt:348:51>
--  pos=Defer_Pos209, res=Defer_Res209, nobt=None
Defer_Res209 :=
   Pattern_Or_Parse0 (Parser, Row_Pos166);
Defer_Pos209 := Parser.Current_Pos;
--  END <Defer (for 'pattern') at parser.lkt:348:51>
if Defer_Pos209 /= No_Token_Index then
   Row_Pos166 := Defer_Pos209;
else
   Row_Pos166 := No_Token_Index;
   goto Exit_Row166_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row166_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'pattern_arg') at parser.lkt:348:11>
if Row_Pos166 /= No_Token_Index then
   Transform_Res129 := Allocate_Selector_Pattern_Detail (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res129,
      Kind => Lkt_Selector_Pattern_Detail,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos166 = Pos
                            then No_Token_Index
                            else Row_Pos166 - 1));
      Initialize_Fields_For_Selector_Pattern_Detail
        (Self => Transform_Res129,
         Selector_Pattern_Detail_F_Call => Defer_Res208,
         Selector_Pattern_Detail_F_Sub_Pattern => Defer_Res209);
         if Defer_Res208 /= null and then Is_Incomplete (Defer_Res208) then
            Transform_Res129.Last_Attempted_Child := 0;
         elsif Defer_Res208 /= null and then not Is_Ghost (Defer_Res208) then
            Transform_Res129.Last_Attempted_Child := -1;
         end if;
         if Defer_Res209 /= null and then Is_Incomplete (Defer_Res209) then
            Transform_Res129.Last_Attempted_Child := 0;
         elsif Defer_Res209 /= null and then not Is_Ghost (Defer_Res209) then
            Transform_Res129.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType SelectorPatternDetail>) (root of 'pattern_arg') at parser.lkt:348:11>
    if Row_Pos166 /= No_Token_Index then
        Or_Pos33 := Row_Pos166;
        Or_Res33 := Transform_Res129;
        goto Exit_Or37;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail33.Pos then
       Branch_Diag_Mark33 := Parser.Last_Diag;
       Branch_Last_Fail33 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark89;
    Parser.Last_Fail := Last_Fail33;
--  BEGIN <Transform(<ASTNodeType FieldPatternDetail>) (root of 'pattern_arg') at parser.lkt:349:11>
--  pos=Row_Pos167, res=Transform_Res130, nobt=Nobt44
--  BEGIN <_Row (root of 'pattern_arg') at parser.lkt:349:11>
--  pos=Row_Pos167, res=None, nobt=Nobt44
Row_Pos167 := Pos;
--  BEGIN <Defer (for 'id') at parser.lkt:349:30>
--  pos=Defer_Pos210, res=Defer_Res210, nobt=None
Defer_Res210 :=
   Id_Transform_Parse0 (Parser, Row_Pos167);
Defer_Pos210 := Parser.Current_Pos;
--  END <Defer (for 'id') at parser.lkt:349:30>
Row_Progress41 := 1;
if Defer_Pos210 /= No_Token_Index then
   Row_Pos167 := Defer_Pos210;
else
   Row_Pos167 := No_Token_Index;
   goto Exit_Row167_0;
end if;
--  BEGIN <Token(<WithText Colon>, ) (root of 'pattern_arg') at parser.lkt:349:33>
--  pos=Token_Pos237, res=Token_Res237, nobt=None
Token_Res237 := Row_Pos167;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res237));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos237 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos167 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos167,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Colon,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos237 := Row_Pos167 + 1;
   end if;
end;
--  END <Token(<WithText Colon>, ) (root of 'pattern_arg') at parser.lkt:349:33>
Row_Progress41 := 2;
if Token_Pos237 /= No_Token_Index then
   Row_Pos167 := Token_Pos237;
else
   Row_Pos167 := No_Token_Index;
   goto Exit_Row167_0;
end if;
--  BEGIN <Cut (root of 'pattern_arg') at parser.lkt:349:37>
--  pos=Row_Pos167, res=None, nobt=Nobt44
Nobt44 := True;
--  END <Cut (root of 'pattern_arg') at parser.lkt:349:37>
Row_Progress41 := 3;
if Row_Pos167 /= No_Token_Index then
   Row_Pos167 := Row_Pos167;
else
   Row_Pos167 := No_Token_Index;
   goto Exit_Row167_0;
end if;
--  BEGIN <Defer (for 'pattern') at parser.lkt:349:39>
--  pos=Defer_Pos211, res=Defer_Res211, nobt=None
Defer_Res211 :=
   Pattern_Or_Parse0 (Parser, Row_Pos167);
Defer_Pos211 := Parser.Current_Pos;
--  END <Defer (for 'pattern') at parser.lkt:349:39>
Row_Progress41 := 4;
if Defer_Pos211 /= No_Token_Index then
   Row_Pos167 := Defer_Pos211;
else
   Row_Pos167 := No_Token_Index;
   goto Exit_Row167_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row167_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'pattern_arg') at parser.lkt:349:11>
if Row_Pos167 = No_Token_Index and then Nobt44 then
   Row_Pos167 := Parser.Last_Fail.Pos;
   Transform_Has_Failed41 := True;
end if;
if Row_Pos167 /= No_Token_Index then
   Transform_Res130 := Allocate_Field_Pattern_Detail (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res130,
      Kind => Lkt_Field_Pattern_Detail,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos167 = Pos
                            then No_Token_Index
                            else Row_Pos167 - 1));
      Initialize_Fields_For_Field_Pattern_Detail
        (Self => Transform_Res130,
         Field_Pattern_Detail_F_Id => Defer_Res210,
         Field_Pattern_Detail_F_Expected_Value => Defer_Res211);
         if Defer_Res210 /= null and then Is_Incomplete (Defer_Res210) then
            Transform_Res130.Last_Attempted_Child := 0;
         elsif Defer_Res210 /= null and then not Is_Ghost (Defer_Res210) then
            Transform_Res130.Last_Attempted_Child := -1;
         end if;
         if Defer_Res211 /= null and then Is_Incomplete (Defer_Res211) then
            Transform_Res130.Last_Attempted_Child := 0;
         elsif Defer_Res211 /= null and then not Is_Ghost (Defer_Res211) then
            Transform_Res130.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed41 then
      Transform_Res130.Last_Attempted_Child :=
         Row_Progress41;
      Append (Parser, Pos, "Cannot parse <pattern_arg>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType FieldPatternDetail>) (root of 'pattern_arg') at parser.lkt:349:11>
    if Row_Pos167 /= No_Token_Index then
        Or_Pos33 := Row_Pos167;
        Or_Res33 := Transform_Res130;
        goto Exit_Or37;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail33.Pos then
       Branch_Diag_Mark33 := Parser.Last_Diag;
       Branch_Last_Fail33 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark89;
    Parser.Last_Fail := Last_Fail33;
--  BEGIN <Transform(<ASTNodeType PropertyPatternDetail>) (root of 'pattern_arg') at parser.lkt:350:11>
--  pos=Row_Pos168, res=Transform_Res131, nobt=Nobt45
--  BEGIN <_Row (root of 'pattern_arg') at parser.lkt:350:11>
--  pos=Row_Pos168, res=None, nobt=Nobt45
Row_Pos168 := Pos;
--  BEGIN <Predicate (root of 'pattern_arg') at parser.lkt:351:13>
--  pos=Predicate_Pos1, res=Predicate_Res1, nobt=None
--  BEGIN <Defer (for 'basic_expr') at parser.lkt:351:13>
--  pos=Defer_Pos212, res=Defer_Res212, nobt=None
Defer_Res212 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos168);
Defer_Pos212 := Parser.Current_Pos;
--  END <Defer (for 'basic_expr') at parser.lkt:351:13>
if Defer_Res212 /= null
   and then Liblktlang.Implementation.Expr_P_Is_Simple_Call_Expr (Defer_Res212)
then
    Predicate_Res1 := Defer_Res212;
    Predicate_Pos1 := Defer_Pos212;
else
    Predicate_Pos1 := No_Token_Index;
    Predicate_Res1 := null;
    if Parser.Last_Fail.Pos <= Row_Pos168 then
       Parser.Last_Fail := (Pos  => Row_Pos168,
                            Data => (Kind => Predicate_Fail));
    end if;
end if;
--  END <Predicate (root of 'pattern_arg') at parser.lkt:351:13>
Row_Progress42 := 1;
if Predicate_Pos1 /= No_Token_Index then
   Row_Pos168 := Predicate_Pos1;
else
   Row_Pos168 := No_Token_Index;
   goto Exit_Row168_0;
end if;
--  BEGIN <Token(<WithText Colon>, ) (root of 'pattern_arg') at parser.lkt:351:59>
--  pos=Token_Pos238, res=Token_Res238, nobt=None
Token_Res238 := Row_Pos168;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res238));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos238 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos168 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos168,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Colon,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos238 := Row_Pos168 + 1;
   end if;
end;
--  END <Token(<WithText Colon>, ) (root of 'pattern_arg') at parser.lkt:351:59>
Row_Progress42 := 2;
if Token_Pos238 /= No_Token_Index then
   Row_Pos168 := Token_Pos238;
else
   Row_Pos168 := No_Token_Index;
   goto Exit_Row168_0;
end if;
--  BEGIN <Cut (root of 'pattern_arg') at parser.lkt:351:63>
--  pos=Row_Pos168, res=None, nobt=Nobt45
Nobt45 := True;
--  END <Cut (root of 'pattern_arg') at parser.lkt:351:63>
Row_Progress42 := 3;
if Row_Pos168 /= No_Token_Index then
   Row_Pos168 := Row_Pos168;
else
   Row_Pos168 := No_Token_Index;
   goto Exit_Row168_0;
end if;
--  BEGIN <Defer (for 'pattern') at parser.lkt:351:65>
--  pos=Defer_Pos213, res=Defer_Res213, nobt=None
Defer_Res213 :=
   Pattern_Or_Parse0 (Parser, Row_Pos168);
Defer_Pos213 := Parser.Current_Pos;
--  END <Defer (for 'pattern') at parser.lkt:351:65>
Row_Progress42 := 4;
if Defer_Pos213 /= No_Token_Index then
   Row_Pos168 := Defer_Pos213;
else
   Row_Pos168 := No_Token_Index;
   goto Exit_Row168_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row168_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'pattern_arg') at parser.lkt:350:11>
if Row_Pos168 = No_Token_Index and then Nobt45 then
   Row_Pos168 := Parser.Last_Fail.Pos;
   Transform_Has_Failed42 := True;
end if;
if Row_Pos168 /= No_Token_Index then
   Transform_Res131 := Allocate_Property_Pattern_Detail (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res131,
      Kind => Lkt_Property_Pattern_Detail,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos168 = Pos
                            then No_Token_Index
                            else Row_Pos168 - 1));
      Initialize_Fields_For_Property_Pattern_Detail
        (Self => Transform_Res131,
         Property_Pattern_Detail_F_Call => Predicate_Res1,
         Property_Pattern_Detail_F_Expected_Value => Defer_Res213);
         if Predicate_Res1 /= null and then Is_Incomplete (Predicate_Res1) then
            Transform_Res131.Last_Attempted_Child := 0;
         elsif Predicate_Res1 /= null and then not Is_Ghost (Predicate_Res1) then
            Transform_Res131.Last_Attempted_Child := -1;
         end if;
         if Defer_Res213 /= null and then Is_Incomplete (Defer_Res213) then
            Transform_Res131.Last_Attempted_Child := 0;
         elsif Defer_Res213 /= null and then not Is_Ghost (Defer_Res213) then
            Transform_Res131.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed42 then
      Transform_Res131.Last_Attempted_Child :=
         Row_Progress42;
      Append (Parser, Pos, "Cannot parse <pattern_arg>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType PropertyPatternDetail>) (root of 'pattern_arg') at parser.lkt:350:11>
    if Row_Pos168 /= No_Token_Index then
        Or_Pos33 := Row_Pos168;
        Or_Res33 := Transform_Res131;
        goto Exit_Or37;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail33.Pos then
       Branch_Diag_Mark33 := Parser.Last_Diag;
       Branch_Last_Fail33 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark33;
Parser.Last_Fail := Branch_Last_Fail33;
<<Exit_Or37>>
--  END <Or (root of 'pattern_arg') at parser.lkt:347:20>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos33 = No_Token_Index then
      Set_Failure
        (PP.Pattern_Arg_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Pattern_Arg_Or_Parse0_Memo, Pos, Or_Res33, Parser.Last_Diag, Or_Pos33);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos33;
   return Or_Res33;
end Pattern_Arg_Or_Parse0;
   function Primary_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
      Defer_Pos214 : Token_Index := No_Token_Index;
      Defer_Res214 : Bare_Lambda_Expr := No_Bare_Lkt_Node;
      Defer_Pos215 : Token_Index := No_Token_Index;
      Defer_Res215 : Bare_If_Expr := No_Bare_Lkt_Node;
      Defer_Pos216 : Token_Index := No_Token_Index;
      Defer_Res216 : Bare_Raise_Expr := No_Bare_Lkt_Node;
      Defer_Pos217 : Token_Index := No_Token_Index;
      Defer_Res217 : Bare_Try_Expr := No_Bare_Lkt_Node;
      Defer_Pos218 : Token_Index := No_Token_Index;
      Defer_Res218 : Bare_Expr := No_Bare_Lkt_Node;
      Or_Pos34 : Token_Index := No_Token_Index;
      Or_Res34 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark90 : Diagnostic_Mark;
      Last_Fail34 : Fail_Info;
      Branch_Diag_Mark34 : Diagnostic_Mark;
      Branch_Last_Fail34 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Primary_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res34 := M.Instance;
      return Or_Res34;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res34;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'primary') at parser.lkt:414:16>
--  pos=Or_Pos34, res=Or_Res34, nobt=None
Or_Pos34 := No_Token_Index;
Or_Res34 := No_Bare_Lkt_Node;
Diag_Mark90 := Parser.Last_Diag;
Last_Fail34 := Parser.Last_Fail;
Branch_Diag_Mark34 := Parser.Last_Diag;
Branch_Last_Fail34 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark90;
    Parser.Last_Fail := Last_Fail34;
--  BEGIN <Defer (for 'lambda_expr') at parser.lkt:414:21>
--  pos=Defer_Pos214, res=Defer_Res214, nobt=None
Defer_Res214 :=
   Lambda_Expr_Transform_Parse0 (Parser, Pos);
Defer_Pos214 := Parser.Current_Pos;
--  END <Defer (for 'lambda_expr') at parser.lkt:414:21>
    if Defer_Pos214 /= No_Token_Index then
        Or_Pos34 := Defer_Pos214;
        Or_Res34 := Defer_Res214;
        goto Exit_Or38;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail34.Pos then
       Branch_Diag_Mark34 := Parser.Last_Diag;
       Branch_Last_Fail34 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark90;
    Parser.Last_Fail := Last_Fail34;
--  BEGIN <Defer (for 'if_expr') at parser.lkt:414:35>
--  pos=Defer_Pos215, res=Defer_Res215, nobt=None
Defer_Res215 :=
   If_Expr_Transform_Parse1 (Parser, Pos);
Defer_Pos215 := Parser.Current_Pos;
--  END <Defer (for 'if_expr') at parser.lkt:414:35>
    if Defer_Pos215 /= No_Token_Index then
        Or_Pos34 := Defer_Pos215;
        Or_Res34 := Defer_Res215;
        goto Exit_Or38;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail34.Pos then
       Branch_Diag_Mark34 := Parser.Last_Diag;
       Branch_Last_Fail34 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark90;
    Parser.Last_Fail := Last_Fail34;
--  BEGIN <Defer (for 'raise_expr') at parser.lkt:414:45>
--  pos=Defer_Pos216, res=Defer_Res216, nobt=None
Defer_Res216 :=
   Raise_Expr_Transform_Parse0 (Parser, Pos);
Defer_Pos216 := Parser.Current_Pos;
--  END <Defer (for 'raise_expr') at parser.lkt:414:45>
    if Defer_Pos216 /= No_Token_Index then
        Or_Pos34 := Defer_Pos216;
        Or_Res34 := Defer_Res216;
        goto Exit_Or38;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail34.Pos then
       Branch_Diag_Mark34 := Parser.Last_Diag;
       Branch_Last_Fail34 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark90;
    Parser.Last_Fail := Last_Fail34;
--  BEGIN <Defer (for 'try_expr') at parser.lkt:414:58>
--  pos=Defer_Pos217, res=Defer_Res217, nobt=None
Defer_Res217 :=
   Try_Expr_Transform_Parse0 (Parser, Pos);
Defer_Pos217 := Parser.Current_Pos;
--  END <Defer (for 'try_expr') at parser.lkt:414:58>
    if Defer_Pos217 /= No_Token_Index then
        Or_Pos34 := Defer_Pos217;
        Or_Res34 := Defer_Res217;
        goto Exit_Or38;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail34.Pos then
       Branch_Diag_Mark34 := Parser.Last_Diag;
       Branch_Last_Fail34 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark90;
    Parser.Last_Fail := Last_Fail34;
--  BEGIN <Defer (for 'basic_expr') at parser.lkt:414:69>
--  pos=Defer_Pos218, res=Defer_Res218, nobt=None
Defer_Res218 :=
   Basic_Expr_Or_Parse0 (Parser, Pos);
Defer_Pos218 := Parser.Current_Pos;
--  END <Defer (for 'basic_expr') at parser.lkt:414:69>
    if Defer_Pos218 /= No_Token_Index then
        Or_Pos34 := Defer_Pos218;
        Or_Res34 := Defer_Res218;
        goto Exit_Or38;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail34.Pos then
       Branch_Diag_Mark34 := Parser.Last_Diag;
       Branch_Last_Fail34 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark34;
Parser.Last_Fail := Branch_Last_Fail34;
<<Exit_Or38>>
--  END <Or (root of 'primary') at parser.lkt:414:16>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos34 = No_Token_Index then
      Set_Failure
        (PP.Primary_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Primary_Or_Parse0_Memo, Pos, Or_Res34, Parser.Last_Diag, Or_Pos34);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos34;
   return Or_Res34;
end Primary_Or_Parse0;
   function Query_Comprehension_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Query
is
      Row_Pos169 : Token_Index := No_Token_Index;
      Token_Pos239 : Token_Index := No_Token_Index;
      Token_Res239 : Token_Index := No_Token_Index;
      Defer_Pos219 : Token_Index := No_Token_Index;
      Defer_Res219 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos240 : Token_Index := No_Token_Index;
      Token_Res240 : Token_Index := No_Token_Index;
      Defer_Pos220 : Token_Index := No_Token_Index;
      Defer_Res220 : Bare_Pattern := No_Bare_Lkt_Node;
      Row_Pos170 : Token_Index := No_Token_Index;
      Token_Pos241 : Token_Index := No_Token_Index;
      Token_Res241 : Token_Index := No_Token_Index;
      Defer_Pos221 : Token_Index := No_Token_Index;
      Defer_Res221 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark91 : Diagnostic_Mark;
      Row_Pos171 : Token_Index := No_Token_Index;
      Token_Pos242 : Token_Index := No_Token_Index;
      Token_Res242 : Token_Index := No_Token_Index;
      Defer_Pos222 : Token_Index := No_Token_Index;
      Defer_Res222 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark92 : Diagnostic_Mark;
      Transform_Res132 : Bare_Query := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Query_Comprehension_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res132 := M.Instance;
      return Transform_Res132;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res132;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType Query>) (root of 'query_comprehension') at parser.lkt:507:28>
--  pos=Row_Pos169, res=Transform_Res132, nobt=None
--  BEGIN <_Row (root of 'query_comprehension') at parser.lkt:507:28>
--  pos=Row_Pos169, res=None, nobt=None
Row_Pos169 := Pos;
--  BEGIN <Token(<WithText FromKw>, ) (root of 'query_comprehension') at parser.lkt:508:9>
--  pos=Token_Pos239, res=Token_Res239, nobt=None
Token_Res239 := Row_Pos169;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res239));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_From_Kw)
   then
       Token_Pos239 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos169 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos169,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_From_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos239 := Row_Pos169 + 1;
   end if;
end;
--  END <Token(<WithText FromKw>, ) (root of 'query_comprehension') at parser.lkt:508:9>
if Token_Pos239 /= No_Token_Index then
   Row_Pos169 := Token_Pos239;
else
   Row_Pos169 := No_Token_Index;
   goto Exit_Row169_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:508:16>
--  pos=Defer_Pos219, res=Defer_Res219, nobt=None
Defer_Res219 :=
   Expr_Or_Parse0 (Parser, Row_Pos169);
Defer_Pos219 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:508:16>
if Defer_Pos219 /= No_Token_Index then
   Row_Pos169 := Defer_Pos219;
else
   Row_Pos169 := No_Token_Index;
   goto Exit_Row169_0;
end if;
--  BEGIN <Token(<WithText MatchKw>, ) (root of 'query_comprehension') at parser.lkt:509:9>
--  pos=Token_Pos240, res=Token_Res240, nobt=None
Token_Res240 := Row_Pos169;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res240));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Match_Kw)
   then
       Token_Pos240 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos169 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos169,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Match_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos240 := Row_Pos169 + 1;
   end if;
end;
--  END <Token(<WithText MatchKw>, ) (root of 'query_comprehension') at parser.lkt:509:9>
if Token_Pos240 /= No_Token_Index then
   Row_Pos169 := Token_Pos240;
else
   Row_Pos169 := No_Token_Index;
   goto Exit_Row169_0;
end if;
--  BEGIN <Defer (for 'pattern') at parser.lkt:509:17>
--  pos=Defer_Pos220, res=Defer_Res220, nobt=None
Defer_Res220 :=
   Pattern_Or_Parse0 (Parser, Row_Pos169);
Defer_Pos220 := Parser.Current_Pos;
--  END <Defer (for 'pattern') at parser.lkt:509:17>
if Defer_Pos220 /= No_Token_Index then
   Row_Pos169 := Defer_Pos220;
else
   Row_Pos169 := No_Token_Index;
   goto Exit_Row169_0;
end if;
--  BEGIN <Opt (root of 'query_comprehension') at parser.lkt:510:9>
--  pos=Row_Pos170, res=Defer_Res221, nobt=None
Diag_Mark91 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'query_comprehension') at parser.lkt:510:10>
--  pos=Row_Pos170, res=Defer_Res221, nobt=None
--  BEGIN <_Row (root of 'query_comprehension') at parser.lkt:510:10>
--  pos=Row_Pos170, res=None, nobt=None
Row_Pos170 := Row_Pos169;
--  BEGIN <Token(<WithText SelectKw>, ) (root of 'query_comprehension') at parser.lkt:510:15>
--  pos=Token_Pos241, res=Token_Res241, nobt=None
Token_Res241 := Row_Pos170;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res241));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Select_Kw)
   then
       Token_Pos241 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos170 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos170,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Select_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos241 := Row_Pos170 + 1;
   end if;
end;
--  END <Token(<WithText SelectKw>, ) (root of 'query_comprehension') at parser.lkt:510:15>
if Token_Pos241 /= No_Token_Index then
   Row_Pos170 := Token_Pos241;
else
   Row_Pos170 := No_Token_Index;
   goto Exit_Row170_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:510:24>
--  pos=Defer_Pos221, res=Defer_Res221, nobt=None
Defer_Res221 :=
   Expr_Or_Parse0 (Parser, Row_Pos170);
Defer_Pos221 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:510:24>
if Defer_Pos221 /= No_Token_Index then
   Row_Pos170 := Defer_Pos221;
else
   Row_Pos170 := No_Token_Index;
   goto Exit_Row170_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row170_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'query_comprehension') at parser.lkt:510:10>
--  END <_Extract (root of 'query_comprehension') at parser.lkt:510:10>
if Row_Pos170 = No_Token_Index then
   Defer_Res221 := No_Bare_Lkt_Node;
   Row_Pos170 := Row_Pos169;
      Parser.Last_Diag := Diag_Mark91;
end if;
--  END <Opt (root of 'query_comprehension') at parser.lkt:510:9>
if Row_Pos170 /= No_Token_Index then
   Row_Pos169 := Row_Pos170;
else
   Row_Pos169 := No_Token_Index;
   goto Exit_Row169_0;
end if;
--  BEGIN <Opt (root of 'query_comprehension') at parser.lkt:511:9>
--  pos=Row_Pos171, res=Defer_Res222, nobt=None
Diag_Mark92 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'query_comprehension') at parser.lkt:511:10>
--  pos=Row_Pos171, res=Defer_Res222, nobt=None
--  BEGIN <_Row (root of 'query_comprehension') at parser.lkt:511:10>
--  pos=Row_Pos171, res=None, nobt=None
Row_Pos171 := Row_Pos169;
--  BEGIN <Token(<WithText IfKw>, ) (root of 'query_comprehension') at parser.lkt:511:15>
--  pos=Token_Pos242, res=Token_Res242, nobt=None
Token_Res242 := Row_Pos171;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res242));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_If_Kw)
   then
       Token_Pos242 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos171 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos171,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_If_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos242 := Row_Pos171 + 1;
   end if;
end;
--  END <Token(<WithText IfKw>, ) (root of 'query_comprehension') at parser.lkt:511:15>
if Token_Pos242 /= No_Token_Index then
   Row_Pos171 := Token_Pos242;
else
   Row_Pos171 := No_Token_Index;
   goto Exit_Row171_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:511:20>
--  pos=Defer_Pos222, res=Defer_Res222, nobt=None
Defer_Res222 :=
   Expr_Or_Parse0 (Parser, Row_Pos171);
Defer_Pos222 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:511:20>
if Defer_Pos222 /= No_Token_Index then
   Row_Pos171 := Defer_Pos222;
else
   Row_Pos171 := No_Token_Index;
   goto Exit_Row171_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row171_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'query_comprehension') at parser.lkt:511:10>
--  END <_Extract (root of 'query_comprehension') at parser.lkt:511:10>
if Row_Pos171 = No_Token_Index then
   Defer_Res222 := No_Bare_Lkt_Node;
   Row_Pos171 := Row_Pos169;
      Parser.Last_Diag := Diag_Mark92;
end if;
--  END <Opt (root of 'query_comprehension') at parser.lkt:511:9>
if Row_Pos171 /= No_Token_Index then
   Row_Pos169 := Row_Pos171;
else
   Row_Pos169 := No_Token_Index;
   goto Exit_Row169_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row169_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'query_comprehension') at parser.lkt:507:28>
if Row_Pos169 /= No_Token_Index then
   Transform_Res132 := Allocate_Query (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res132,
      Kind => Lkt_Query,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos169 = Pos
                            then No_Token_Index
                            else Row_Pos169 - 1));
      Initialize_Fields_For_Query
        (Self => Transform_Res132,
         Query_F_Source => Defer_Res219,
         Query_F_Pattern => Defer_Res220,
         Query_F_Mapping => Defer_Res221,
         Query_F_Guard => Defer_Res222);
         if Defer_Res219 /= null and then Is_Incomplete (Defer_Res219) then
            Transform_Res132.Last_Attempted_Child := 0;
         elsif Defer_Res219 /= null and then not Is_Ghost (Defer_Res219) then
            Transform_Res132.Last_Attempted_Child := -1;
         end if;
         if Defer_Res220 /= null and then Is_Incomplete (Defer_Res220) then
            Transform_Res132.Last_Attempted_Child := 0;
         elsif Defer_Res220 /= null and then not Is_Ghost (Defer_Res220) then
            Transform_Res132.Last_Attempted_Child := -1;
         end if;
         if Defer_Res221 /= null and then Is_Incomplete (Defer_Res221) then
            Transform_Res132.Last_Attempted_Child := 0;
         elsif Defer_Res221 /= null and then not Is_Ghost (Defer_Res221) then
            Transform_Res132.Last_Attempted_Child := -1;
         end if;
         if Defer_Res222 /= null and then Is_Incomplete (Defer_Res222) then
            Transform_Res132.Last_Attempted_Child := 0;
         elsif Defer_Res222 /= null and then not Is_Ghost (Defer_Res222) then
            Transform_Res132.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType Query>) (root of 'query_comprehension') at parser.lkt:507:28>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos169 = No_Token_Index then
      Set_Failure
        (PP.Query_Comprehension_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Query_Comprehension_Transform_Parse0_Memo, Pos, Transform_Res132, Parser.Last_Diag, Row_Pos169);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos169;
   return Transform_Res132;
end Query_Comprehension_Transform_Parse0;
   function Raise_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Raise_Expr
is
      Nobt46 : Boolean := False;
      Nobt47 : Boolean := False;
      Row_Pos172 : Token_Index := No_Token_Index;
      Token_Pos243 : Token_Index := No_Token_Index;
      Token_Res243 : Token_Index := No_Token_Index;
      Row_Pos173 : Token_Index := No_Token_Index;
      Token_Pos244 : Token_Index := No_Token_Index;
      Token_Res244 : Token_Index := No_Token_Index;
      Defer_Pos223 : Token_Index := No_Token_Index;
      Defer_Res223 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Token_Pos245 : Token_Index := No_Token_Index;
      Token_Res245 : Token_Index := No_Token_Index;
      Diag_Mark93 : Diagnostic_Mark;
      Defer_Pos224 : Token_Index := No_Token_Index;
      Defer_Res224 : Bare_Expr := No_Bare_Lkt_Node;
      Row_Progress43 : Integer := 0;
      Transform_Res133 : Bare_Raise_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed43 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Raise_Expr_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res133 := M.Instance;
      return Transform_Res133;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res133;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType RaiseExpr>) (root of 'raise_expr') at parser.lkt:449:19>
--  pos=Row_Pos172, res=Transform_Res133, nobt=Nobt46
--  BEGIN <_Row (root of 'raise_expr') at parser.lkt:449:19>
--  pos=Row_Pos172, res=None, nobt=Nobt46
Row_Pos172 := Pos;
--  BEGIN <Token(<WithText RaiseKw>, ) (root of 'raise_expr') at parser.lkt:449:29>
--  pos=Token_Pos243, res=Token_Res243, nobt=None
Token_Res243 := Row_Pos172;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res243));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Raise_Kw)
   then
       Token_Pos243 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos172 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos172,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Raise_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos243 := Row_Pos172 + 1;
   end if;
end;
--  END <Token(<WithText RaiseKw>, ) (root of 'raise_expr') at parser.lkt:449:29>
Row_Progress43 := 1;
if Token_Pos243 /= No_Token_Index then
   Row_Pos172 := Token_Pos243;
else
   Row_Pos172 := No_Token_Index;
   goto Exit_Row172_0;
end if;
--  BEGIN <Cut (root of 'raise_expr') at parser.lkt:449:37>
--  pos=Row_Pos172, res=None, nobt=Nobt46
Nobt46 := True;
--  END <Cut (root of 'raise_expr') at parser.lkt:449:37>
Row_Progress43 := 2;
if Row_Pos172 /= No_Token_Index then
   Row_Pos172 := Row_Pos172;
else
   Row_Pos172 := No_Token_Index;
   goto Exit_Row172_0;
end if;
--  BEGIN <Opt (root of 'raise_expr') at parser.lkt:449:39>
--  pos=Row_Pos173, res=Defer_Res223, nobt=Nobt47
Diag_Mark93 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'raise_expr') at parser.lkt:449:40>
--  pos=Row_Pos173, res=Defer_Res223, nobt=Nobt47
--  BEGIN <_Row (root of 'raise_expr') at parser.lkt:449:40>
--  pos=Row_Pos173, res=None, nobt=Nobt47
Row_Pos173 := Row_Pos172;
--  BEGIN <Token(<WithText LBrack>, ) (root of 'raise_expr') at parser.lkt:449:45>
--  pos=Token_Pos244, res=Token_Res244, nobt=None
Token_Res244 := Row_Pos173;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res244));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos244 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos173 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos173,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos244 := Row_Pos173 + 1;
   end if;
end;
--  END <Token(<WithText LBrack>, ) (root of 'raise_expr') at parser.lkt:449:45>
if Token_Pos244 /= No_Token_Index then
   Row_Pos173 := Token_Pos244;
else
   Row_Pos173 := No_Token_Index;
   goto Exit_Row173_0;
end if;
--  BEGIN <Cut (root of 'raise_expr') at parser.lkt:449:49>
--  pos=Row_Pos173, res=None, nobt=Nobt47
Nobt47 := True;
--  END <Cut (root of 'raise_expr') at parser.lkt:449:49>
if Row_Pos173 /= No_Token_Index then
   Row_Pos173 := Row_Pos173;
else
   Row_Pos173 := No_Token_Index;
   goto Exit_Row173_0;
end if;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:449:51>
--  pos=Defer_Pos223, res=Defer_Res223, nobt=None
Defer_Res223 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos173);
Defer_Pos223 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:449:51>
if Defer_Pos223 /= No_Token_Index then
   Row_Pos173 := Defer_Pos223;
else
   Row_Pos173 := No_Token_Index;
   goto Exit_Row173_0;
end if;
--  BEGIN <Token(<WithText RBrack>, ) (root of 'raise_expr') at parser.lkt:449:60>
--  pos=Token_Pos245, res=Token_Res245, nobt=None
Token_Res245 := Row_Pos173;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res245));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos245 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos173 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos173,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos245 := Row_Pos173 + 1;
   end if;
end;
--  END <Token(<WithText RBrack>, ) (root of 'raise_expr') at parser.lkt:449:60>
if Token_Pos245 /= No_Token_Index then
   Row_Pos173 := Token_Pos245;
else
   Row_Pos173 := No_Token_Index;
   goto Exit_Row173_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row173_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'raise_expr') at parser.lkt:449:40>
--  END <_Extract (root of 'raise_expr') at parser.lkt:449:40>
if Row_Pos173 = No_Token_Index then
   if Nobt47 then
      Row_Pos173 := Parser.Last_Fail.Pos;
      Append (Parser, Row_Pos173, "Cannot parse <raise_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
         if not Nobt47 then
   Defer_Res223 := No_Bare_Lkt_Node;
         end if;
       if not Nobt47 then
   Row_Pos173 := Row_Pos172;
      Parser.Last_Diag := Diag_Mark93;
       end if;
end if;
--  END <Opt (root of 'raise_expr') at parser.lkt:449:39>
   Nobt46 := Nobt47;
Row_Progress43 := 3;
if Row_Pos173 /= No_Token_Index then
   Row_Pos172 := Row_Pos173;
else
   Row_Pos172 := No_Token_Index;
   goto Exit_Row172_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:449:65>
--  pos=Defer_Pos224, res=Defer_Res224, nobt=None
Defer_Res224 :=
   Expr_Or_Parse0 (Parser, Row_Pos172);
Defer_Pos224 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:449:65>
Row_Progress43 := 4;
if Defer_Pos224 /= No_Token_Index then
   Row_Pos172 := Defer_Pos224;
else
   Row_Pos172 := No_Token_Index;
   goto Exit_Row172_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row172_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'raise_expr') at parser.lkt:449:19>
if Row_Pos172 = No_Token_Index and then Nobt46 then
   Row_Pos172 := Parser.Last_Fail.Pos;
   Transform_Has_Failed43 := True;
end if;
if Row_Pos172 /= No_Token_Index then
   Transform_Res133 := Allocate_Raise_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res133,
      Kind => Lkt_Raise_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos172 = Pos
                            then No_Token_Index
                            else Row_Pos172 - 1));
      Initialize_Fields_For_Raise_Expr
        (Self => Transform_Res133,
         Raise_Expr_F_Dest_Type => Defer_Res223,
         Raise_Expr_F_Except_Expr => Defer_Res224);
         if Defer_Res223 /= null and then Is_Incomplete (Defer_Res223) then
            Transform_Res133.Last_Attempted_Child := 0;
         elsif Defer_Res223 /= null and then not Is_Ghost (Defer_Res223) then
            Transform_Res133.Last_Attempted_Child := -1;
         end if;
         if Defer_Res224 /= null and then Is_Incomplete (Defer_Res224) then
            Transform_Res133.Last_Attempted_Child := 0;
         elsif Defer_Res224 /= null and then not Is_Ghost (Defer_Res224) then
            Transform_Res133.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed43 then
      Transform_Res133.Last_Attempted_Child :=
         Row_Progress43;
      Append (Parser, Pos, "Cannot parse <raise_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType RaiseExpr>) (root of 'raise_expr') at parser.lkt:449:19>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos172 = No_Token_Index then
      Set_Failure
        (PP.Raise_Expr_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Raise_Expr_Transform_Parse0_Memo, Pos, Transform_Res133, Parser.Last_Diag, Row_Pos172);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos172;
   return Transform_Res133;
end Raise_Expr_Transform_Parse0;
   function Ref_Id_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ref_Id
is
      Row_Pos174 : Token_Index := No_Token_Index;
      Token_Pos246 : Token_Index := No_Token_Index;
      Token_Res246 : Token_Index := No_Token_Index;
      Transform_Res134 : Bare_Ref_Id := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Ref_Id_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res134 := M.Instance;
      return Transform_Res134;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res134;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType RefId>) (root of 'ref_id') at parser.lkt:10:15>
--  pos=Row_Pos174, res=Transform_Res134, nobt=None
--  BEGIN <_Row (root of 'ref_id') at parser.lkt:10:15>
--  pos=Row_Pos174, res=None, nobt=None
Row_Pos174 := Pos;
--  BEGIN <Token(<WithSymbol Identifier>, ) (root of 'ref_id') at parser.lkt:10:21>
--  pos=Token_Pos246, res=Token_Res246, nobt=None
Token_Res246 := Row_Pos174;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res246));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
   then
       Token_Pos246 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos174 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos174,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos246 := Row_Pos174 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, ) (root of 'ref_id') at parser.lkt:10:21>
if Token_Pos246 /= No_Token_Index then
   Row_Pos174 := Token_Pos246;
else
   Row_Pos174 := No_Token_Index;
   goto Exit_Row174_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row174_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'ref_id') at parser.lkt:10:15>
if Row_Pos174 /= No_Token_Index then
   Transform_Res134 := Allocate_Ref_Id (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res134,
      Kind => Lkt_Ref_Id,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos174 = Pos
                            then No_Token_Index
                            else Row_Pos174 - 1));
      Initialize_Fields_For_Ref_Id
        (Self => Transform_Res134);
end if;
--  END <Transform(<ASTNodeType RefId>) (root of 'ref_id') at parser.lkt:10:15>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos174 = No_Token_Index then
      Set_Failure
        (PP.Ref_Id_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Ref_Id_Transform_Parse0_Memo, Pos, Transform_Res134, Parser.Last_Diag, Row_Pos174);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos174;
   return Transform_Res134;
end Ref_Id_Transform_Parse0;
   function Regex_Pattern_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Regex_Pattern
is
      Row_Pos175 : Token_Index := No_Token_Index;
      Token_Pos247 : Token_Index := No_Token_Index;
      Token_Res247 : Token_Index := No_Token_Index;
      Transform_Res135 : Bare_Regex_Pattern := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Regex_Pattern_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res135 := M.Instance;
      return Transform_Res135;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res135;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType RegexPattern>) (root of 'regex_pattern') at parser.lkt:332:22>
--  pos=Row_Pos175, res=Transform_Res135, nobt=None
--  BEGIN <_Row (root of 'regex_pattern') at parser.lkt:332:22>
--  pos=Row_Pos175, res=None, nobt=None
Row_Pos175 := Pos;
--  BEGIN <Token(<WithText String>, ) (root of 'regex_pattern') at parser.lkt:332:35>
--  pos=Token_Pos247, res=Token_Res247, nobt=None
Token_Res247 := Row_Pos175;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res247));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_String)
   then
       Token_Pos247 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos175 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos175,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_String,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos247 := Row_Pos175 + 1;
   end if;
end;
--  END <Token(<WithText String>, ) (root of 'regex_pattern') at parser.lkt:332:35>
if Token_Pos247 /= No_Token_Index then
   Row_Pos175 := Token_Pos247;
else
   Row_Pos175 := No_Token_Index;
   goto Exit_Row175_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row175_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'regex_pattern') at parser.lkt:332:22>
if Row_Pos175 /= No_Token_Index then
   Transform_Res135 := Allocate_Regex_Pattern (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res135,
      Kind => Lkt_Regex_Pattern,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos175 = Pos
                            then No_Token_Index
                            else Row_Pos175 - 1));
end if;
--  END <Transform(<ASTNodeType RegexPattern>) (root of 'regex_pattern') at parser.lkt:332:22>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos175 = No_Token_Index then
      Set_Failure
        (PP.Regex_Pattern_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Regex_Pattern_Transform_Parse0_Memo, Pos, Transform_Res135, Parser.Last_Diag, Row_Pos175);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos175;
   return Transform_Res135;
end Regex_Pattern_Transform_Parse0;
   function Rel_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
      Row_Pos176 : Token_Index := No_Token_Index;
      Token_Pos248 : Token_Index := No_Token_Index;
      Token_Res248 : Token_Index := No_Token_Index;
      Defer_Pos225 : Token_Index := No_Token_Index;
      Defer_Res225 : Bare_Expr := No_Bare_Lkt_Node;
      Transform_Res136 : Bare_Not_Expr := No_Bare_Lkt_Node;
      Defer_Pos226 : Token_Index := No_Token_Index;
      Defer_Res226 : Bare_Expr := No_Bare_Lkt_Node;
      Or_Pos35 : Token_Index := No_Token_Index;
      Or_Res35 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark94 : Diagnostic_Mark;
      Last_Fail35 : Fail_Info;
      Branch_Diag_Mark35 : Diagnostic_Mark;
      Branch_Last_Fail35 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Rel_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res35 := M.Instance;
      return Or_Res35;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res35;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'rel') at parser.lkt:377:12>
--  pos=Or_Pos35, res=Or_Res35, nobt=None
Or_Pos35 := No_Token_Index;
Or_Res35 := No_Bare_Lkt_Node;
Diag_Mark94 := Parser.Last_Diag;
Last_Fail35 := Parser.Last_Fail;
Branch_Diag_Mark35 := Parser.Last_Diag;
Branch_Last_Fail35 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark94;
    Parser.Last_Fail := Last_Fail35;
--  BEGIN <Transform(<ASTNodeType NotExpr>) (root of 'rel') at parser.lkt:377:15>
--  pos=Row_Pos176, res=Transform_Res136, nobt=None
--  BEGIN <_Row (root of 'rel') at parser.lkt:377:15>
--  pos=Row_Pos176, res=None, nobt=None
Row_Pos176 := Pos;
--  BEGIN <Token(<WithText NotKw>, ) (root of 'rel') at parser.lkt:377:23>
--  pos=Token_Pos248, res=Token_Res248, nobt=None
Token_Res248 := Row_Pos176;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res248));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Not_Kw)
   then
       Token_Pos248 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos176 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos176,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Not_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos248 := Row_Pos176 + 1;
   end if;
end;
--  END <Token(<WithText NotKw>, ) (root of 'rel') at parser.lkt:377:23>
if Token_Pos248 /= No_Token_Index then
   Row_Pos176 := Token_Pos248;
else
   Row_Pos176 := No_Token_Index;
   goto Exit_Row176_0;
end if;
--  BEGIN <Defer (for 'eq') at parser.lkt:377:29>
--  pos=Defer_Pos225, res=Defer_Res225, nobt=None
Defer_Res225 :=
   Eq_Or_Parse1 (Parser, Row_Pos176);
Defer_Pos225 := Parser.Current_Pos;
--  END <Defer (for 'eq') at parser.lkt:377:29>
if Defer_Pos225 /= No_Token_Index then
   Row_Pos176 := Defer_Pos225;
else
   Row_Pos176 := No_Token_Index;
   goto Exit_Row176_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row176_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'rel') at parser.lkt:377:15>
if Row_Pos176 /= No_Token_Index then
   Transform_Res136 := Allocate_Not_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res136,
      Kind => Lkt_Not_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos176 = Pos
                            then No_Token_Index
                            else Row_Pos176 - 1));
      Initialize_Fields_For_Not_Expr
        (Self => Transform_Res136,
         Not_Expr_F_Expr => Defer_Res225);
         if Defer_Res225 /= null and then Is_Incomplete (Defer_Res225) then
            Transform_Res136.Last_Attempted_Child := 0;
         elsif Defer_Res225 /= null and then not Is_Ghost (Defer_Res225) then
            Transform_Res136.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType NotExpr>) (root of 'rel') at parser.lkt:377:15>
    if Row_Pos176 /= No_Token_Index then
        Or_Pos35 := Row_Pos176;
        Or_Res35 := Transform_Res136;
        goto Exit_Or39;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail35.Pos then
       Branch_Diag_Mark35 := Parser.Last_Diag;
       Branch_Last_Fail35 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark94;
    Parser.Last_Fail := Last_Fail35;
--  BEGIN <Defer (for 'eq') at parser.lkt:377:35>
--  pos=Defer_Pos226, res=Defer_Res226, nobt=None
Defer_Res226 :=
   Eq_Or_Parse1 (Parser, Pos);
Defer_Pos226 := Parser.Current_Pos;
--  END <Defer (for 'eq') at parser.lkt:377:35>
    if Defer_Pos226 /= No_Token_Index then
        Or_Pos35 := Defer_Pos226;
        Or_Res35 := Defer_Res226;
        goto Exit_Or39;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail35.Pos then
       Branch_Diag_Mark35 := Parser.Last_Diag;
       Branch_Last_Fail35 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark35;
Parser.Last_Fail := Branch_Last_Fail35;
<<Exit_Or39>>
--  END <Or (root of 'rel') at parser.lkt:377:12>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos35 = No_Token_Index then
      Set_Failure
        (PP.Rel_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Rel_Or_Parse0_Memo, Pos, Or_Res35, Parser.Last_Diag, Or_Pos35);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos35;
   return Or_Res35;
end Rel_Or_Parse0;
   function Selector_Call_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Selector_Call
is
      Row_Pos177 : Token_Index := No_Token_Index;
      Defer_Pos227 : Token_Index := No_Token_Index;
      Defer_Res227 : Bare_Id := No_Bare_Lkt_Node;
      Row_Pos178 : Token_Index := No_Token_Index;
      Defer_Pos228 : Token_Index := No_Token_Index;
      Defer_Res228 : Bare_Id := No_Bare_Lkt_Node;
      Token_Pos249 : Token_Index := No_Token_Index;
      Token_Res249 : Token_Index := No_Token_Index;
      Diag_Mark95 : Diagnostic_Mark;
      Defer_Pos229 : Token_Index := No_Token_Index;
      Defer_Res229 : Bare_Expr := No_Bare_Lkt_Node;
      Transform_Res137 : Bare_Selector_Call := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Selector_Call_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res137 := M.Instance;
      return Transform_Res137;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res137;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType SelectorCall>) (root of 'selector_call') at parser.lkt:354:22>
--  pos=Row_Pos177, res=Transform_Res137, nobt=None
--  BEGIN <_Row (root of 'selector_call') at parser.lkt:354:22>
--  pos=Row_Pos177, res=None, nobt=None
Row_Pos177 := Pos;
--  BEGIN <Defer (for 'id') at parser.lkt:354:35>
--  pos=Defer_Pos227, res=Defer_Res227, nobt=None
Defer_Res227 :=
   Id_Transform_Parse0 (Parser, Row_Pos177);
Defer_Pos227 := Parser.Current_Pos;
--  END <Defer (for 'id') at parser.lkt:354:35>
if Defer_Pos227 /= No_Token_Index then
   Row_Pos177 := Defer_Pos227;
else
   Row_Pos177 := No_Token_Index;
   goto Exit_Row177_0;
end if;
--  BEGIN <Opt (root of 'selector_call') at parser.lkt:354:38>
--  pos=Row_Pos178, res=Defer_Res228, nobt=None
Diag_Mark95 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'selector_call') at parser.lkt:354:39>
--  pos=Row_Pos178, res=Defer_Res228, nobt=None
--  BEGIN <_Row (root of 'selector_call') at parser.lkt:354:39>
--  pos=Row_Pos178, res=None, nobt=None
Row_Pos178 := Row_Pos177;
--  BEGIN <Defer (for 'id') at parser.lkt:354:44>
--  pos=Defer_Pos228, res=Defer_Res228, nobt=None
Defer_Res228 :=
   Id_Transform_Parse0 (Parser, Row_Pos178);
Defer_Pos228 := Parser.Current_Pos;
--  END <Defer (for 'id') at parser.lkt:354:44>
if Defer_Pos228 /= No_Token_Index then
   Row_Pos178 := Defer_Pos228;
else
   Row_Pos178 := No_Token_Index;
   goto Exit_Row178_0;
end if;
--  BEGIN <Token(<WithText At>, ) (root of 'selector_call') at parser.lkt:354:47>
--  pos=Token_Pos249, res=Token_Res249, nobt=None
Token_Res249 := Row_Pos178;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res249));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_At)
   then
       Token_Pos249 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos178 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos178,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_At,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos249 := Row_Pos178 + 1;
   end if;
end;
--  END <Token(<WithText At>, ) (root of 'selector_call') at parser.lkt:354:47>
if Token_Pos249 /= No_Token_Index then
   Row_Pos178 := Token_Pos249;
else
   Row_Pos178 := No_Token_Index;
   goto Exit_Row178_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row178_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'selector_call') at parser.lkt:354:39>
--  END <_Extract (root of 'selector_call') at parser.lkt:354:39>
if Row_Pos178 = No_Token_Index then
   Defer_Res228 := No_Bare_Lkt_Node;
   Row_Pos178 := Row_Pos177;
      Parser.Last_Diag := Diag_Mark95;
end if;
--  END <Opt (root of 'selector_call') at parser.lkt:354:38>
if Row_Pos178 /= No_Token_Index then
   Row_Pos177 := Row_Pos178;
else
   Row_Pos177 := No_Token_Index;
   goto Exit_Row177_0;
end if;
--  BEGIN <Defer (for 'basic_expr') at parser.lkt:354:52>
--  pos=Defer_Pos229, res=Defer_Res229, nobt=None
Defer_Res229 :=
   Basic_Expr_Or_Parse0 (Parser, Row_Pos177);
Defer_Pos229 := Parser.Current_Pos;
--  END <Defer (for 'basic_expr') at parser.lkt:354:52>
if Defer_Pos229 /= No_Token_Index then
   Row_Pos177 := Defer_Pos229;
else
   Row_Pos177 := No_Token_Index;
   goto Exit_Row177_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row177_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'selector_call') at parser.lkt:354:22>
if Row_Pos177 /= No_Token_Index then
   Transform_Res137 := Allocate_Selector_Call (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res137,
      Kind => Lkt_Selector_Call,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos177 = Pos
                            then No_Token_Index
                            else Row_Pos177 - 1));
      Initialize_Fields_For_Selector_Call
        (Self => Transform_Res137,
         Selector_Call_F_Quantifier => Defer_Res227,
         Selector_Call_F_Binding => Defer_Res228,
         Selector_Call_F_Selector_Call => Defer_Res229);
         if Defer_Res227 /= null and then Is_Incomplete (Defer_Res227) then
            Transform_Res137.Last_Attempted_Child := 0;
         elsif Defer_Res227 /= null and then not Is_Ghost (Defer_Res227) then
            Transform_Res137.Last_Attempted_Child := -1;
         end if;
         if Defer_Res228 /= null and then Is_Incomplete (Defer_Res228) then
            Transform_Res137.Last_Attempted_Child := 0;
         elsif Defer_Res228 /= null and then not Is_Ghost (Defer_Res228) then
            Transform_Res137.Last_Attempted_Child := -1;
         end if;
         if Defer_Res229 /= null and then Is_Incomplete (Defer_Res229) then
            Transform_Res137.Last_Attempted_Child := 0;
         elsif Defer_Res229 /= null and then not Is_Ghost (Defer_Res229) then
            Transform_Res137.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType SelectorCall>) (root of 'selector_call') at parser.lkt:354:22>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos177 = No_Token_Index then
      Set_Failure
        (PP.Selector_Call_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Selector_Call_Transform_Parse0_Memo, Pos, Transform_Res137, Parser.Last_Diag, Row_Pos177);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos177;
   return Transform_Res137;
end Selector_Call_Transform_Parse0;
   function Stream_Concat_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
      Row_Pos179 : Token_Index := No_Token_Index;
      Defer_Pos230 : Token_Index := No_Token_Index;
      Defer_Res230 : Bare_Expr := No_Bare_Lkt_Node;
      Row_Pos180 : Token_Index := No_Token_Index;
      Token_Pos250 : Token_Index := No_Token_Index;
      Token_Res250 : Token_Index := No_Token_Index;
      Transform_Res138 : Bare_Op_Stream_Cons := No_Bare_Lkt_Node;
      Defer_Pos231 : Token_Index := No_Token_Index;
      Defer_Res231 : Bare_Expr := No_Bare_Lkt_Node;
      Transform_Res139 : Bare_Bin_Op := No_Bare_Lkt_Node;
      Defer_Pos232 : Token_Index := No_Token_Index;
      Defer_Res232 : Bare_Expr := No_Bare_Lkt_Node;
      Or_Pos36 : Token_Index := No_Token_Index;
      Or_Res36 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark96 : Diagnostic_Mark;
      Last_Fail36 : Fail_Info;
      Branch_Diag_Mark36 : Diagnostic_Mark;
      Branch_Last_Fail36 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Stream_Concat_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res36 := M.Instance;
      return Or_Res36;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res36;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'stream_concat') at parser.lkt:359:22>
--  pos=Or_Pos36, res=Or_Res36, nobt=None
Or_Pos36 := No_Token_Index;
Or_Res36 := No_Bare_Lkt_Node;
Diag_Mark96 := Parser.Last_Diag;
Last_Fail36 := Parser.Last_Fail;
Branch_Diag_Mark36 := Parser.Last_Diag;
Branch_Last_Fail36 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark96;
    Parser.Last_Fail := Last_Fail36;
--  BEGIN <Transform(<ASTNodeType BinOp>) (root of 'stream_concat') at parser.lkt:360:11>
--  pos=Row_Pos179, res=Transform_Res139, nobt=None
--  BEGIN <_Row (root of 'stream_concat') at parser.lkt:360:11>
--  pos=Row_Pos179, res=None, nobt=None
Row_Pos179 := Pos;
--  BEGIN <Defer (for 'logic') at parser.lkt:360:17>
--  pos=Defer_Pos230, res=Defer_Res230, nobt=None
Defer_Res230 :=
   Logic_Or_Parse1 (Parser, Row_Pos179);
Defer_Pos230 := Parser.Current_Pos;
--  END <Defer (for 'logic') at parser.lkt:360:17>
if Defer_Pos230 /= No_Token_Index then
   Row_Pos179 := Defer_Pos230;
else
   Row_Pos179 := No_Token_Index;
   goto Exit_Row179_0;
end if;
--  BEGIN <Transform(<ASTNodeType Op.StreamCons>) (root of 'stream_concat') at parser.lkt:360:23>
--  pos=Row_Pos180, res=Transform_Res138, nobt=None
--  BEGIN <_Row (root of 'stream_concat') at parser.lkt:360:23>
--  pos=Row_Pos180, res=None, nobt=None
Row_Pos180 := Row_Pos179;
--  BEGIN <Token(<WithText DoubleColon>, ) (root of 'stream_concat') at parser.lkt:360:37>
--  pos=Token_Pos250, res=Token_Res250, nobt=None
Token_Res250 := Row_Pos180;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res250));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Double_Colon)
   then
       Token_Pos250 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos180 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos180,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Double_Colon,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos250 := Row_Pos180 + 1;
   end if;
end;
--  END <Token(<WithText DoubleColon>, ) (root of 'stream_concat') at parser.lkt:360:37>
if Token_Pos250 /= No_Token_Index then
   Row_Pos180 := Token_Pos250;
else
   Row_Pos180 := No_Token_Index;
   goto Exit_Row180_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row180_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'stream_concat') at parser.lkt:360:23>
if Row_Pos180 /= No_Token_Index then
   Transform_Res138 := Allocate_Op_Stream_Cons (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res138,
      Kind => Lkt_Op_Stream_Cons,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos179,
      Token_End_Index   => (if Row_Pos180 = Row_Pos179
                            then No_Token_Index
                            else Row_Pos180 - 1));
end if;
--  END <Transform(<ASTNodeType Op.StreamCons>) (root of 'stream_concat') at parser.lkt:360:23>
if Row_Pos180 /= No_Token_Index then
   Row_Pos179 := Row_Pos180;
else
   Row_Pos179 := No_Token_Index;
   goto Exit_Row179_0;
end if;
--  BEGIN <Defer (for 'stream_concat') at parser.lkt:360:43>
--  pos=Defer_Pos231, res=Defer_Res231, nobt=None
Defer_Res231 :=
   Stream_Concat_Or_Parse0 (Parser, Row_Pos179);
Defer_Pos231 := Parser.Current_Pos;
--  END <Defer (for 'stream_concat') at parser.lkt:360:43>
if Defer_Pos231 /= No_Token_Index then
   Row_Pos179 := Defer_Pos231;
else
   Row_Pos179 := No_Token_Index;
   goto Exit_Row179_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row179_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'stream_concat') at parser.lkt:360:11>
if Row_Pos179 /= No_Token_Index then
   Transform_Res139 := Allocate_Bin_Op (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res139,
      Kind => Lkt_Bin_Op,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos179 = Pos
                            then No_Token_Index
                            else Row_Pos179 - 1));
      Initialize_Fields_For_Bin_Op
        (Self => Transform_Res139,
         Bin_Op_F_Left => Defer_Res230,
         Bin_Op_F_Op => Transform_Res138,
         Bin_Op_F_Right => Defer_Res231);
         if Defer_Res230 /= null and then Is_Incomplete (Defer_Res230) then
            Transform_Res139.Last_Attempted_Child := 0;
         elsif Defer_Res230 /= null and then not Is_Ghost (Defer_Res230) then
            Transform_Res139.Last_Attempted_Child := -1;
         end if;
         if Transform_Res138 /= null and then Is_Incomplete (Transform_Res138) then
            Transform_Res139.Last_Attempted_Child := 0;
         elsif Transform_Res138 /= null and then not Is_Ghost (Transform_Res138) then
            Transform_Res139.Last_Attempted_Child := -1;
         end if;
         if Defer_Res231 /= null and then Is_Incomplete (Defer_Res231) then
            Transform_Res139.Last_Attempted_Child := 0;
         elsif Defer_Res231 /= null and then not Is_Ghost (Defer_Res231) then
            Transform_Res139.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType BinOp>) (root of 'stream_concat') at parser.lkt:360:11>
    if Row_Pos179 /= No_Token_Index then
        Or_Pos36 := Row_Pos179;
        Or_Res36 := Transform_Res139;
        goto Exit_Or40;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail36.Pos then
       Branch_Diag_Mark36 := Parser.Last_Diag;
       Branch_Last_Fail36 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark96;
    Parser.Last_Fail := Last_Fail36;
--  BEGIN <Defer (for 'logic') at parser.lkt:361:11>
--  pos=Defer_Pos232, res=Defer_Res232, nobt=None
Defer_Res232 :=
   Logic_Or_Parse1 (Parser, Pos);
Defer_Pos232 := Parser.Current_Pos;
--  END <Defer (for 'logic') at parser.lkt:361:11>
    if Defer_Pos232 /= No_Token_Index then
        Or_Pos36 := Defer_Pos232;
        Or_Res36 := Defer_Res232;
        goto Exit_Or40;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail36.Pos then
       Branch_Diag_Mark36 := Parser.Last_Diag;
       Branch_Last_Fail36 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark36;
Parser.Last_Fail := Branch_Last_Fail36;
<<Exit_Or40>>
--  END <Or (root of 'stream_concat') at parser.lkt:359:22>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos36 = No_Token_Index then
      Set_Failure
        (PP.Stream_Concat_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Stream_Concat_Or_Parse0_Memo, Pos, Or_Res36, Parser.Last_Diag, Or_Pos36);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos36;
   return Or_Res36;
end Stream_Concat_Or_Parse0;
   function String_Lit_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_String_Lit
is
      Row_Pos181 : Token_Index := No_Token_Index;
      Token_Pos251 : Token_Index := No_Token_Index;
      Token_Res251 : Token_Index := No_Token_Index;
      Transform_Res140 : Bare_Single_Line_String_Lit := No_Bare_Lkt_Node;
      Row_Pos182 : Token_Index := No_Token_Index;
      Token_Pos252 : Token_Index := No_Token_Index;
      Token_Res252 : Token_Index := No_Token_Index;
      Transform_Res141 : Bare_Pattern_Single_Line_String_Lit := No_Bare_Lkt_Node;
      Defer_Pos233 : Token_Index := No_Token_Index;
      Defer_Res233 : Bare_Block_String_Lit := No_Bare_Lkt_Node;
      Or_Pos37 : Token_Index := No_Token_Index;
      Or_Res37 : Bare_String_Lit := No_Bare_Lkt_Node;
      Diag_Mark97 : Diagnostic_Mark;
      Last_Fail37 : Fail_Info;
      Branch_Diag_Mark37 : Diagnostic_Mark;
      Branch_Last_Fail37 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.String_Lit_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res37 := M.Instance;
      return Or_Res37;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res37;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'string_lit') at parser.lkt:430:19>
--  pos=Or_Pos37, res=Or_Res37, nobt=None
Or_Pos37 := No_Token_Index;
Or_Res37 := No_Bare_Lkt_Node;
Diag_Mark97 := Parser.Last_Diag;
Last_Fail37 := Parser.Last_Fail;
Branch_Diag_Mark37 := Parser.Last_Diag;
Branch_Last_Fail37 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark97;
    Parser.Last_Fail := Last_Fail37;
--  BEGIN <Transform(<ASTNodeType SingleLineStringLit>) (root of 'string_lit') at parser.lkt:431:11>
--  pos=Row_Pos181, res=Transform_Res140, nobt=None
--  BEGIN <_Row (root of 'string_lit') at parser.lkt:431:11>
--  pos=Row_Pos181, res=None, nobt=None
Row_Pos181 := Pos;
--  BEGIN <Token(<WithText String>, ) (root of 'string_lit') at parser.lkt:431:31>
--  pos=Token_Pos251, res=Token_Res251, nobt=None
Token_Res251 := Row_Pos181;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res251));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_String)
   then
       Token_Pos251 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos181 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos181,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_String,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos251 := Row_Pos181 + 1;
   end if;
end;
--  END <Token(<WithText String>, ) (root of 'string_lit') at parser.lkt:431:31>
if Token_Pos251 /= No_Token_Index then
   Row_Pos181 := Token_Pos251;
else
   Row_Pos181 := No_Token_Index;
   goto Exit_Row181_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row181_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'string_lit') at parser.lkt:431:11>
if Row_Pos181 /= No_Token_Index then
   Transform_Res140 := Allocate_Single_Line_String_Lit (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res140,
      Kind => Lkt_Single_Line_String_Lit,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos181 = Pos
                            then No_Token_Index
                            else Row_Pos181 - 1));
      Initialize_Fields_For_Single_Line_String_Lit
        (Self => Transform_Res140);
end if;
--  END <Transform(<ASTNodeType SingleLineStringLit>) (root of 'string_lit') at parser.lkt:431:11>
    if Row_Pos181 /= No_Token_Index then
        Or_Pos37 := Row_Pos181;
        Or_Res37 := Transform_Res140;
        goto Exit_Or41;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail37.Pos then
       Branch_Diag_Mark37 := Parser.Last_Diag;
       Branch_Last_Fail37 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark97;
    Parser.Last_Fail := Last_Fail37;
--  BEGIN <Transform(<ASTNodeType PatternSingleLineStringLit>) (root of 'string_lit') at parser.lkt:432:11>
--  pos=Row_Pos182, res=Transform_Res141, nobt=None
--  BEGIN <_Row (root of 'string_lit') at parser.lkt:432:11>
--  pos=Row_Pos182, res=None, nobt=None
Row_Pos182 := Pos;
--  BEGIN <Token(<WithText PString>, ) (root of 'string_lit') at parser.lkt:432:38>
--  pos=Token_Pos252, res=Token_Res252, nobt=None
Token_Res252 := Row_Pos182;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res252));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_P_String)
   then
       Token_Pos252 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos182 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos182,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_P_String,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos252 := Row_Pos182 + 1;
   end if;
end;
--  END <Token(<WithText PString>, ) (root of 'string_lit') at parser.lkt:432:38>
if Token_Pos252 /= No_Token_Index then
   Row_Pos182 := Token_Pos252;
else
   Row_Pos182 := No_Token_Index;
   goto Exit_Row182_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row182_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'string_lit') at parser.lkt:432:11>
if Row_Pos182 /= No_Token_Index then
   Transform_Res141 := Allocate_Pattern_Single_Line_String_Lit (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res141,
      Kind => Lkt_Pattern_Single_Line_String_Lit,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos182 = Pos
                            then No_Token_Index
                            else Row_Pos182 - 1));
      Initialize_Fields_For_Pattern_Single_Line_String_Lit
        (Self => Transform_Res141);
end if;
--  END <Transform(<ASTNodeType PatternSingleLineStringLit>) (root of 'string_lit') at parser.lkt:432:11>
    if Row_Pos182 /= No_Token_Index then
        Or_Pos37 := Row_Pos182;
        Or_Res37 := Transform_Res141;
        goto Exit_Or41;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail37.Pos then
       Branch_Diag_Mark37 := Parser.Last_Diag;
       Branch_Last_Fail37 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark97;
    Parser.Last_Fail := Last_Fail37;
--  BEGIN <Defer (for 'block_string_lit') at parser.lkt:433:11>
--  pos=Defer_Pos233, res=Defer_Res233, nobt=None
Defer_Res233 :=
   Block_String_Lit_Transform_Parse1 (Parser, Pos);
Defer_Pos233 := Parser.Current_Pos;
--  END <Defer (for 'block_string_lit') at parser.lkt:433:11>
    if Defer_Pos233 /= No_Token_Index then
        Or_Pos37 := Defer_Pos233;
        Or_Res37 := Defer_Res233;
        goto Exit_Or41;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail37.Pos then
       Branch_Diag_Mark37 := Parser.Last_Diag;
       Branch_Last_Fail37 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark37;
Parser.Last_Fail := Branch_Last_Fail37;
<<Exit_Or41>>
--  END <Or (root of 'string_lit') at parser.lkt:430:19>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos37 = No_Token_Index then
      Set_Failure
        (PP.String_Lit_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.String_Lit_Or_Parse0_Memo, Pos, Or_Res37, Parser.Last_Diag, Or_Pos37);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos37;
   return Or_Res37;
end String_Lit_Or_Parse0;
   function Term_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
      Nobt48 : Boolean := False;
      Row_Pos183 : Token_Index := No_Token_Index;
      Token_Pos253 : Token_Index := No_Token_Index;
      Token_Res253 : Token_Index := No_Token_Index;
      Defer_Pos234 : Token_Index := No_Token_Index;
      Defer_Res234 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos254 : Token_Index := No_Token_Index;
      Token_Res254 : Token_Index := No_Token_Index;
      Row_Progress44 : Integer := 0;
      Transform_Res142 : Bare_Paren_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed44 : Boolean := False;
      Defer_Pos235 : Token_Index := No_Token_Index;
      Defer_Res235 : Bare_Match_Expr := No_Bare_Lkt_Node;
      Defer_Pos236 : Token_Index := No_Token_Index;
      Defer_Res236 : Bare_Null_Lit := No_Bare_Lkt_Node;
      Defer_Pos237 : Token_Index := No_Token_Index;
      Defer_Res237 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Defer_Pos238 : Token_Index := No_Token_Index;
      Defer_Res238 : Bare_Block_Expr := No_Bare_Lkt_Node;
      Defer_Pos239 : Token_Index := No_Token_Index;
      Defer_Res239 : Bare_Num_Lit := No_Bare_Lkt_Node;
      Defer_Pos240 : Token_Index := No_Token_Index;
      Defer_Res240 : Bare_Big_Num_Lit := No_Bare_Lkt_Node;
      Defer_Pos241 : Token_Index := No_Token_Index;
      Defer_Res241 : Bare_String_Lit := No_Bare_Lkt_Node;
      Defer_Pos242 : Token_Index := No_Token_Index;
      Defer_Res242 : Bare_Char_Lit := No_Bare_Lkt_Node;
      Defer_Pos243 : Token_Index := No_Token_Index;
      Defer_Res243 : Bare_Query := No_Bare_Lkt_Node;
      Defer_Pos244 : Token_Index := No_Token_Index;
      Defer_Res244 : Bare_Array_Literal := No_Bare_Lkt_Node;
      Or_Pos38 : Token_Index := No_Token_Index;
      Or_Res38 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark98 : Diagnostic_Mark;
      Last_Fail38 : Fail_Info;
      Branch_Diag_Mark38 : Diagnostic_Mark;
      Branch_Last_Fail38 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Term_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res38 := M.Instance;
      return Or_Res38;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res38;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'term') at parser.lkt:483:13>
--  pos=Or_Pos38, res=Or_Res38, nobt=None
Or_Pos38 := No_Token_Index;
Or_Res38 := No_Bare_Lkt_Node;
Diag_Mark98 := Parser.Last_Diag;
Last_Fail38 := Parser.Last_Fail;
Branch_Diag_Mark38 := Parser.Last_Diag;
Branch_Last_Fail38 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark98;
    Parser.Last_Fail := Last_Fail38;
--  BEGIN <Transform(<ASTNodeType ParenExpr>) (root of 'term') at parser.lkt:484:11>
--  pos=Row_Pos183, res=Transform_Res142, nobt=Nobt48
--  BEGIN <_Row (root of 'term') at parser.lkt:484:11>
--  pos=Row_Pos183, res=None, nobt=Nobt48
Row_Pos183 := Pos;
--  BEGIN <Token(<WithText LPar>, ) (root of 'term') at parser.lkt:484:21>
--  pos=Token_Pos253, res=Token_Res253, nobt=None
Token_Res253 := Row_Pos183;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res253));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos253 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos183 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos183,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos253 := Row_Pos183 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'term') at parser.lkt:484:21>
Row_Progress44 := 1;
if Token_Pos253 /= No_Token_Index then
   Row_Pos183 := Token_Pos253;
else
   Row_Pos183 := No_Token_Index;
   goto Exit_Row183_0;
end if;
--  BEGIN <Cut (root of 'term') at parser.lkt:484:25>
--  pos=Row_Pos183, res=None, nobt=Nobt48
Nobt48 := True;
--  END <Cut (root of 'term') at parser.lkt:484:25>
Row_Progress44 := 2;
if Row_Pos183 /= No_Token_Index then
   Row_Pos183 := Row_Pos183;
else
   Row_Pos183 := No_Token_Index;
   goto Exit_Row183_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:484:27>
--  pos=Defer_Pos234, res=Defer_Res234, nobt=None
Defer_Res234 :=
   Expr_Or_Parse0 (Parser, Row_Pos183);
Defer_Pos234 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:484:27>
Row_Progress44 := 3;
if Defer_Pos234 /= No_Token_Index then
   Row_Pos183 := Defer_Pos234;
else
   Row_Pos183 := No_Token_Index;
   goto Exit_Row183_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'term') at parser.lkt:484:32>
--  pos=Token_Pos254, res=Token_Res254, nobt=None
Token_Res254 := Row_Pos183;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res254));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos254 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos183 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos183,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos254 := Row_Pos183 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'term') at parser.lkt:484:32>
Row_Progress44 := 4;
if Token_Pos254 /= No_Token_Index then
   Row_Pos183 := Token_Pos254;
else
   Row_Pos183 := No_Token_Index;
   goto Exit_Row183_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row183_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'term') at parser.lkt:484:11>
if Row_Pos183 = No_Token_Index and then Nobt48 then
   Row_Pos183 := Parser.Last_Fail.Pos;
   Transform_Has_Failed44 := True;
end if;
if Row_Pos183 /= No_Token_Index then
   Transform_Res142 := Allocate_Paren_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res142,
      Kind => Lkt_Paren_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos183 = Pos
                            then No_Token_Index
                            else Row_Pos183 - 1));
      Initialize_Fields_For_Paren_Expr
        (Self => Transform_Res142,
         Paren_Expr_F_Expr => Defer_Res234);
         if Defer_Res234 /= null and then Is_Incomplete (Defer_Res234) then
            Transform_Res142.Last_Attempted_Child := 0;
         elsif Defer_Res234 /= null and then not Is_Ghost (Defer_Res234) then
            Transform_Res142.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed44 then
      Transform_Res142.Last_Attempted_Child :=
         Row_Progress44;
      Append (Parser, Pos, "Cannot parse <term>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType ParenExpr>) (root of 'term') at parser.lkt:484:11>
    if Row_Pos183 /= No_Token_Index then
        Or_Pos38 := Row_Pos183;
        Or_Res38 := Transform_Res142;
        goto Exit_Or42;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail38.Pos then
       Branch_Diag_Mark38 := Parser.Last_Diag;
       Branch_Last_Fail38 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark98;
    Parser.Last_Fail := Last_Fail38;
--  BEGIN <Defer (for 'match_expr') at parser.lkt:485:11>
--  pos=Defer_Pos235, res=Defer_Res235, nobt=None
Defer_Res235 :=
   Match_Expr_Transform_Parse3 (Parser, Pos);
Defer_Pos235 := Parser.Current_Pos;
--  END <Defer (for 'match_expr') at parser.lkt:485:11>
    if Defer_Pos235 /= No_Token_Index then
        Or_Pos38 := Defer_Pos235;
        Or_Res38 := Defer_Res235;
        goto Exit_Or42;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail38.Pos then
       Branch_Diag_Mark38 := Parser.Last_Diag;
       Branch_Last_Fail38 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark98;
    Parser.Last_Fail := Last_Fail38;
--  BEGIN <Defer (for 'null_lit') at parser.lkt:486:11>
--  pos=Defer_Pos236, res=Defer_Res236, nobt=None
Defer_Res236 :=
   Null_Lit_Transform_Parse0 (Parser, Pos);
Defer_Pos236 := Parser.Current_Pos;
--  END <Defer (for 'null_lit') at parser.lkt:486:11>
    if Defer_Pos236 /= No_Token_Index then
        Or_Pos38 := Defer_Pos236;
        Or_Res38 := Defer_Res236;
        goto Exit_Or42;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail38.Pos then
       Branch_Diag_Mark38 := Parser.Last_Diag;
       Branch_Last_Fail38 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark98;
    Parser.Last_Fail := Last_Fail38;
--  BEGIN <Defer (for 'ref_id') at parser.lkt:487:11>
--  pos=Defer_Pos237, res=Defer_Res237, nobt=None
Defer_Res237 :=
   Ref_Id_Transform_Parse0 (Parser, Pos);
Defer_Pos237 := Parser.Current_Pos;
--  END <Defer (for 'ref_id') at parser.lkt:487:11>
    if Defer_Pos237 /= No_Token_Index then
        Or_Pos38 := Defer_Pos237;
        Or_Res38 := Defer_Res237;
        goto Exit_Or42;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail38.Pos then
       Branch_Diag_Mark38 := Parser.Last_Diag;
       Branch_Last_Fail38 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark98;
    Parser.Last_Fail := Last_Fail38;
--  BEGIN <Defer (for 'block') at parser.lkt:488:11>
--  pos=Defer_Pos238, res=Defer_Res238, nobt=None
Defer_Res238 :=
   Block_Transform_Parse2 (Parser, Pos);
Defer_Pos238 := Parser.Current_Pos;
--  END <Defer (for 'block') at parser.lkt:488:11>
    if Defer_Pos238 /= No_Token_Index then
        Or_Pos38 := Defer_Pos238;
        Or_Res38 := Defer_Res238;
        goto Exit_Or42;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail38.Pos then
       Branch_Diag_Mark38 := Parser.Last_Diag;
       Branch_Last_Fail38 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark98;
    Parser.Last_Fail := Last_Fail38;
--  BEGIN <Defer (for 'num_lit') at parser.lkt:489:11>
--  pos=Defer_Pos239, res=Defer_Res239, nobt=None
Defer_Res239 :=
   Num_Lit_Transform_Parse0 (Parser, Pos);
Defer_Pos239 := Parser.Current_Pos;
--  END <Defer (for 'num_lit') at parser.lkt:489:11>
    if Defer_Pos239 /= No_Token_Index then
        Or_Pos38 := Defer_Pos239;
        Or_Res38 := Defer_Res239;
        goto Exit_Or42;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail38.Pos then
       Branch_Diag_Mark38 := Parser.Last_Diag;
       Branch_Last_Fail38 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark98;
    Parser.Last_Fail := Last_Fail38;
--  BEGIN <Defer (for 'big_num_lit') at parser.lkt:490:11>
--  pos=Defer_Pos240, res=Defer_Res240, nobt=None
Defer_Res240 :=
   Big_Num_Lit_Transform_Parse0 (Parser, Pos);
Defer_Pos240 := Parser.Current_Pos;
--  END <Defer (for 'big_num_lit') at parser.lkt:490:11>
    if Defer_Pos240 /= No_Token_Index then
        Or_Pos38 := Defer_Pos240;
        Or_Res38 := Defer_Res240;
        goto Exit_Or42;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail38.Pos then
       Branch_Diag_Mark38 := Parser.Last_Diag;
       Branch_Last_Fail38 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark98;
    Parser.Last_Fail := Last_Fail38;
--  BEGIN <Defer (for 'string_lit') at parser.lkt:491:11>
--  pos=Defer_Pos241, res=Defer_Res241, nobt=None
Defer_Res241 :=
   String_Lit_Or_Parse0 (Parser, Pos);
Defer_Pos241 := Parser.Current_Pos;
--  END <Defer (for 'string_lit') at parser.lkt:491:11>
    if Defer_Pos241 /= No_Token_Index then
        Or_Pos38 := Defer_Pos241;
        Or_Res38 := Defer_Res241;
        goto Exit_Or42;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail38.Pos then
       Branch_Diag_Mark38 := Parser.Last_Diag;
       Branch_Last_Fail38 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark98;
    Parser.Last_Fail := Last_Fail38;
--  BEGIN <Defer (for 'char_lit') at parser.lkt:492:11>
--  pos=Defer_Pos242, res=Defer_Res242, nobt=None
Defer_Res242 :=
   Char_Lit_Transform_Parse0 (Parser, Pos);
Defer_Pos242 := Parser.Current_Pos;
--  END <Defer (for 'char_lit') at parser.lkt:492:11>
    if Defer_Pos242 /= No_Token_Index then
        Or_Pos38 := Defer_Pos242;
        Or_Res38 := Defer_Res242;
        goto Exit_Or42;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail38.Pos then
       Branch_Diag_Mark38 := Parser.Last_Diag;
       Branch_Last_Fail38 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark98;
    Parser.Last_Fail := Last_Fail38;
--  BEGIN <Defer (for 'query_comprehension') at parser.lkt:493:11>
--  pos=Defer_Pos243, res=Defer_Res243, nobt=None
Defer_Res243 :=
   Query_Comprehension_Transform_Parse0 (Parser, Pos);
Defer_Pos243 := Parser.Current_Pos;
--  END <Defer (for 'query_comprehension') at parser.lkt:493:11>
    if Defer_Pos243 /= No_Token_Index then
        Or_Pos38 := Defer_Pos243;
        Or_Res38 := Defer_Res243;
        goto Exit_Or42;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail38.Pos then
       Branch_Diag_Mark38 := Parser.Last_Diag;
       Branch_Last_Fail38 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark98;
    Parser.Last_Fail := Last_Fail38;
--  BEGIN <Defer (for 'array_literal') at parser.lkt:494:11>
--  pos=Defer_Pos244, res=Defer_Res244, nobt=None
Defer_Res244 :=
   Array_Literal_Transform_Parse0 (Parser, Pos);
Defer_Pos244 := Parser.Current_Pos;
--  END <Defer (for 'array_literal') at parser.lkt:494:11>
    if Defer_Pos244 /= No_Token_Index then
        Or_Pos38 := Defer_Pos244;
        Or_Res38 := Defer_Res244;
        goto Exit_Or42;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail38.Pos then
       Branch_Diag_Mark38 := Parser.Last_Diag;
       Branch_Last_Fail38 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark38;
Parser.Last_Fail := Branch_Last_Fail38;
<<Exit_Or42>>
--  END <Or (root of 'term') at parser.lkt:483:13>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos38 = No_Token_Index then
      Set_Failure
        (PP.Term_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Term_Or_Parse0_Memo, Pos, Or_Res38, Parser.Last_Diag, Or_Pos38);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos38;
   return Or_Res38;
end Term_Or_Parse0;
   function Token_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Token_Lit
is
      Row_Pos184 : Token_Index := No_Token_Index;
      Token_Pos255 : Token_Index := No_Token_Index;
      Token_Res255 : Token_Index := No_Token_Index;
      Transform_Res143 : Bare_Token_Lit := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Token_Literal_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res143 := M.Instance;
      return Transform_Res143;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res143;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType TokenLit>) (root of 'token_literal') at parser.lkt:119:22>
--  pos=Row_Pos184, res=Transform_Res143, nobt=None
--  BEGIN <_Row (root of 'token_literal') at parser.lkt:119:22>
--  pos=Row_Pos184, res=None, nobt=None
Row_Pos184 := Pos;
--  BEGIN <Token(<WithText String>, ) (root of 'token_literal') at parser.lkt:119:31>
--  pos=Token_Pos255, res=Token_Res255, nobt=None
Token_Res255 := Row_Pos184;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res255));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_String)
   then
       Token_Pos255 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos184 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos184,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_String,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos255 := Row_Pos184 + 1;
   end if;
end;
--  END <Token(<WithText String>, ) (root of 'token_literal') at parser.lkt:119:31>
if Token_Pos255 /= No_Token_Index then
   Row_Pos184 := Token_Pos255;
else
   Row_Pos184 := No_Token_Index;
   goto Exit_Row184_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row184_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'token_literal') at parser.lkt:119:22>
if Row_Pos184 /= No_Token_Index then
   Transform_Res143 := Allocate_Token_Lit (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res143,
      Kind => Lkt_Token_Lit,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos184 = Pos
                            then No_Token_Index
                            else Row_Pos184 - 1));
      Initialize_Fields_For_Token_Lit
        (Self => Transform_Res143);
end if;
--  END <Transform(<ASTNodeType TokenLit>) (root of 'token_literal') at parser.lkt:119:22>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos184 = No_Token_Index then
      Set_Failure
        (PP.Token_Literal_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Token_Literal_Transform_Parse0_Memo, Pos, Transform_Res143, Parser.Last_Diag, Row_Pos184);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos184;
   return Transform_Res143;
end Token_Literal_Transform_Parse0;
   function Token_No_Case_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Token_No_Case_Lit
is
      Row_Pos185 : Token_Index := No_Token_Index;
      Token_Pos256 : Token_Index := No_Token_Index;
      Token_Res256 : Token_Index := No_Token_Index;
      Token_Pos257 : Token_Index := No_Token_Index;
      Token_Res257 : Token_Index := No_Token_Index;
      Defer_Pos245 : Token_Index := No_Token_Index;
      Defer_Res245 : Bare_Token_Lit := No_Bare_Lkt_Node;
      Token_Pos258 : Token_Index := No_Token_Index;
      Token_Res258 : Token_Index := No_Token_Index;
      Transform_Res144 : Bare_Token_No_Case_Lit := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Token_No_Case_Literal_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res144 := M.Instance;
      return Transform_Res144;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res144;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType TokenNoCaseLit>) (root of 'token_no_case_literal') at parser.lkt:120:30>
--  pos=Row_Pos185, res=Transform_Res144, nobt=None
--  BEGIN <_Row (root of 'token_no_case_literal') at parser.lkt:120:30>
--  pos=Row_Pos185, res=None, nobt=None
Row_Pos185 := Pos;
--  BEGIN <Token(<WithSymbol Identifier>, no_case) (root of 'token_no_case_literal') at parser.lkt:121:9>
--  pos=Token_Pos256, res=Token_Res256, nobt=None
Token_Res256 := Row_Pos185;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res256));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Identifier)
      or else T.Symbol /= Precomputed_Symbol
        (Precomputed_Symbol_Table (Parser.TDH.Symbols),
         Precomputed_Sym_No_Case)
   then
       Token_Pos256 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos185 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos185,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Identifier,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos256 := Row_Pos185 + 1;
   end if;
end;
--  END <Token(<WithSymbol Identifier>, no_case) (root of 'token_no_case_literal') at parser.lkt:121:9>
if Token_Pos256 /= No_Token_Index then
   Row_Pos185 := Token_Pos256;
else
   Row_Pos185 := No_Token_Index;
   goto Exit_Row185_0;
end if;
--  BEGIN <Token(<WithText LPar>, ) (root of 'token_no_case_literal') at parser.lkt:121:32>
--  pos=Token_Pos257, res=Token_Res257, nobt=None
Token_Res257 := Row_Pos185;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res257));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos257 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos185 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos185,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos257 := Row_Pos185 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'token_no_case_literal') at parser.lkt:121:32>
if Token_Pos257 /= No_Token_Index then
   Row_Pos185 := Token_Pos257;
else
   Row_Pos185 := No_Token_Index;
   goto Exit_Row185_0;
end if;
--  BEGIN <Defer (for 'token_literal') at parser.lkt:121:36>
--  pos=Defer_Pos245, res=Defer_Res245, nobt=None
Defer_Res245 :=
   Token_Literal_Transform_Parse0 (Parser, Row_Pos185);
Defer_Pos245 := Parser.Current_Pos;
--  END <Defer (for 'token_literal') at parser.lkt:121:36>
if Defer_Pos245 /= No_Token_Index then
   Row_Pos185 := Defer_Pos245;
else
   Row_Pos185 := No_Token_Index;
   goto Exit_Row185_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'token_no_case_literal') at parser.lkt:121:50>
--  pos=Token_Pos258, res=Token_Res258, nobt=None
Token_Res258 := Row_Pos185;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res258));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos258 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos185 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos185,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos258 := Row_Pos185 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'token_no_case_literal') at parser.lkt:121:50>
if Token_Pos258 /= No_Token_Index then
   Row_Pos185 := Token_Pos258;
else
   Row_Pos185 := No_Token_Index;
   goto Exit_Row185_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row185_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'token_no_case_literal') at parser.lkt:120:30>
if Row_Pos185 /= No_Token_Index then
   Transform_Res144 := Allocate_Token_No_Case_Lit (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res144,
      Kind => Lkt_Token_No_Case_Lit,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos185 = Pos
                            then No_Token_Index
                            else Row_Pos185 - 1));
      Initialize_Fields_For_Token_No_Case_Lit
        (Self => Transform_Res144,
         Token_No_Case_Lit_F_Lit => Defer_Res245);
         if Defer_Res245 /= null and then Is_Incomplete (Defer_Res245) then
            Transform_Res144.Last_Attempted_Child := 0;
         elsif Defer_Res245 /= null and then not Is_Ghost (Defer_Res245) then
            Transform_Res144.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType TokenNoCaseLit>) (root of 'token_no_case_literal') at parser.lkt:120:30>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos185 = No_Token_Index then
      Set_Failure
        (PP.Token_No_Case_Literal_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Token_No_Case_Literal_Transform_Parse0_Memo, Pos, Transform_Res144, Parser.Last_Diag, Row_Pos185);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos185;
   return Transform_Res144;
end Token_No_Case_Literal_Transform_Parse0;
   function Token_Pattern_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Grammar_Expr
is
      Row_Pos186 : Token_Index := No_Token_Index;
      Defer_Pos246 : Token_Index := No_Token_Index;
      Defer_Res246 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Token_Pos259 : Token_Index := No_Token_Index;
      Token_Res259 : Token_Index := No_Token_Index;
      Defer_Pos247 : Token_Index := No_Token_Index;
      Defer_Res247 : Bare_Token_Pattern_Lit := No_Bare_Lkt_Node;
      Transform_Res145 : Bare_Token_Pattern_Concat := No_Bare_Lkt_Node;
      Defer_Pos248 : Token_Index := No_Token_Index;
      Defer_Res248 : Bare_Token_Pattern_Lit := No_Bare_Lkt_Node;
      Or_Pos39 : Token_Index := No_Token_Index;
      Or_Res39 : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Diag_Mark99 : Diagnostic_Mark;
      Last_Fail39 : Fail_Info;
      Branch_Diag_Mark39 : Diagnostic_Mark;
      Branch_Last_Fail39 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
      Mem_Pos  : Token_Index := Pos;
      Mem_Res  : Bare_Grammar_Expr := No_Bare_Lkt_Node;
      Mem_Mark : Diagnostic_Mark := Mark_On_Entry;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Token_Pattern_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res39 := M.Instance;
      return Or_Res39;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res39;
   end if;
   Parser.Last_Diag := No_Diagnostic;
       Set_Failure
         (PP.Token_Pattern_Or_Parse0_Memo,
          Pos,
          Parser.Last_Fail,
          Parser.Last_Diag);
       <<Try_Again>>
       Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'token_pattern') at parser.lkt:123:22>
--  pos=Or_Pos39, res=Or_Res39, nobt=None
Or_Pos39 := No_Token_Index;
Or_Res39 := No_Bare_Lkt_Node;
Diag_Mark99 := Parser.Last_Diag;
Last_Fail39 := Parser.Last_Fail;
Branch_Diag_Mark39 := Parser.Last_Diag;
Branch_Last_Fail39 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark99;
    Parser.Last_Fail := Last_Fail39;
--  BEGIN <Transform(<ASTNodeType TokenPatternConcat>) (root of 'token_pattern') at parser.lkt:124:11>
--  pos=Row_Pos186, res=Transform_Res145, nobt=None
--  BEGIN <_Row (root of 'token_pattern') at parser.lkt:124:11>
--  pos=Row_Pos186, res=None, nobt=None
Row_Pos186 := Pos;
--  BEGIN <Defer (for 'token_pattern') at parser.lkt:124:30>
--  pos=Defer_Pos246, res=Defer_Res246, nobt=None
Defer_Res246 :=
   Token_Pattern_Or_Parse0 (Parser, Row_Pos186);
Defer_Pos246 := Parser.Current_Pos;
--  END <Defer (for 'token_pattern') at parser.lkt:124:30>
if Defer_Pos246 /= No_Token_Index then
   Row_Pos186 := Defer_Pos246;
else
   Row_Pos186 := No_Token_Index;
   goto Exit_Row186_0;
end if;
--  BEGIN <Token(<WithText Amp>, ) (root of 'token_pattern') at parser.lkt:124:44>
--  pos=Token_Pos259, res=Token_Res259, nobt=None
Token_Res259 := Row_Pos186;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res259));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Amp)
   then
       Token_Pos259 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos186 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos186,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Amp,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos259 := Row_Pos186 + 1;
   end if;
end;
--  END <Token(<WithText Amp>, ) (root of 'token_pattern') at parser.lkt:124:44>
if Token_Pos259 /= No_Token_Index then
   Row_Pos186 := Token_Pos259;
else
   Row_Pos186 := No_Token_Index;
   goto Exit_Row186_0;
end if;
--  BEGIN <Defer (for 'token_pattern_literal') at parser.lkt:124:48>
--  pos=Defer_Pos247, res=Defer_Res247, nobt=None
Defer_Res247 :=
   Token_Pattern_Literal_Transform_Parse0 (Parser, Row_Pos186);
Defer_Pos247 := Parser.Current_Pos;
--  END <Defer (for 'token_pattern_literal') at parser.lkt:124:48>
if Defer_Pos247 /= No_Token_Index then
   Row_Pos186 := Defer_Pos247;
else
   Row_Pos186 := No_Token_Index;
   goto Exit_Row186_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row186_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'token_pattern') at parser.lkt:124:11>
if Row_Pos186 /= No_Token_Index then
   Transform_Res145 := Allocate_Token_Pattern_Concat (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res145,
      Kind => Lkt_Token_Pattern_Concat,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos186 = Pos
                            then No_Token_Index
                            else Row_Pos186 - 1));
      Initialize_Fields_For_Token_Pattern_Concat
        (Self => Transform_Res145,
         Token_Pattern_Concat_F_Left => Defer_Res246,
         Token_Pattern_Concat_F_Right => Defer_Res247);
         if Defer_Res246 /= null and then Is_Incomplete (Defer_Res246) then
            Transform_Res145.Last_Attempted_Child := 0;
         elsif Defer_Res246 /= null and then not Is_Ghost (Defer_Res246) then
            Transform_Res145.Last_Attempted_Child := -1;
         end if;
         if Defer_Res247 /= null and then Is_Incomplete (Defer_Res247) then
            Transform_Res145.Last_Attempted_Child := 0;
         elsif Defer_Res247 /= null and then not Is_Ghost (Defer_Res247) then
            Transform_Res145.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType TokenPatternConcat>) (root of 'token_pattern') at parser.lkt:124:11>
    if Row_Pos186 /= No_Token_Index then
        Or_Pos39 := Row_Pos186;
        Or_Res39 := Transform_Res145;
        goto Exit_Or43;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail39.Pos then
       Branch_Diag_Mark39 := Parser.Last_Diag;
       Branch_Last_Fail39 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark99;
    Parser.Last_Fail := Last_Fail39;
--  BEGIN <Defer (for 'token_pattern_literal') at parser.lkt:125:11>
--  pos=Defer_Pos248, res=Defer_Res248, nobt=None
Defer_Res248 :=
   Token_Pattern_Literal_Transform_Parse0 (Parser, Pos);
Defer_Pos248 := Parser.Current_Pos;
--  END <Defer (for 'token_pattern_literal') at parser.lkt:125:11>
    if Defer_Pos248 /= No_Token_Index then
        Or_Pos39 := Defer_Pos248;
        Or_Res39 := Defer_Res248;
        goto Exit_Or43;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail39.Pos then
       Branch_Diag_Mark39 := Parser.Last_Diag;
       Branch_Last_Fail39 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark39;
Parser.Last_Fail := Branch_Last_Fail39;
<<Exit_Or43>>
--  END <Or (root of 'token_pattern') at parser.lkt:123:22>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
      if Or_Pos39 > Mem_Pos then
         Mem_Pos := Or_Pos39;
         Mem_Res := Or_Res39;
         Mem_Mark := Parser.Last_Diag;
         if Or_Pos39 = No_Token_Index then
            Set_Failure (PP.Token_Pattern_Or_Parse0_Memo, Pos, Parser.Last_Fail, Mem_Mark);
         else
            Memos.Set_Success
              (PP.Token_Pattern_Or_Parse0_Memo,
               Pos,
               Or_Res39,
               Mem_Mark,
               Or_Pos39);
         end if;
         goto Try_Again;
      elsif Mem_Pos > Pos then
         Or_Res39 := Mem_Res;
         Or_Pos39 := Mem_Pos;
         Parser.Last_Diag := Mem_Mark;
         goto No_Memo;
      end if;
   if Or_Pos39 = No_Token_Index then
      Set_Failure
        (PP.Token_Pattern_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Token_Pattern_Or_Parse0_Memo, Pos, Or_Res39, Parser.Last_Diag, Or_Pos39);
   end if;
       <<No_Memo>>
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos39;
   return Or_Res39;
end Token_Pattern_Or_Parse0;
   function Token_Pattern_Literal_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Token_Pattern_Lit
is
      Row_Pos187 : Token_Index := No_Token_Index;
      Token_Pos260 : Token_Index := No_Token_Index;
      Token_Res260 : Token_Index := No_Token_Index;
      Transform_Res146 : Bare_Token_Pattern_Lit := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Token_Pattern_Literal_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res146 := M.Instance;
      return Transform_Res146;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res146;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType TokenPatternLit>) (root of 'token_pattern_literal') at parser.lkt:127:30>
--  pos=Row_Pos187, res=Transform_Res146, nobt=None
--  BEGIN <_Row (root of 'token_pattern_literal') at parser.lkt:127:30>
--  pos=Row_Pos187, res=None, nobt=None
Row_Pos187 := Pos;
--  BEGIN <Token(<WithText PString>, ) (root of 'token_pattern_literal') at parser.lkt:127:46>
--  pos=Token_Pos260, res=Token_Res260, nobt=None
Token_Res260 := Row_Pos187;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res260));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_P_String)
   then
       Token_Pos260 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos187 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos187,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_P_String,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos260 := Row_Pos187 + 1;
   end if;
end;
--  END <Token(<WithText PString>, ) (root of 'token_pattern_literal') at parser.lkt:127:46>
if Token_Pos260 /= No_Token_Index then
   Row_Pos187 := Token_Pos260;
else
   Row_Pos187 := No_Token_Index;
   goto Exit_Row187_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row187_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'token_pattern_literal') at parser.lkt:127:30>
if Row_Pos187 /= No_Token_Index then
   Transform_Res146 := Allocate_Token_Pattern_Lit (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res146,
      Kind => Lkt_Token_Pattern_Lit,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos187 = Pos
                            then No_Token_Index
                            else Row_Pos187 - 1));
      Initialize_Fields_For_Token_Pattern_Lit
        (Self => Transform_Res146);
end if;
--  END <Transform(<ASTNodeType TokenPatternLit>) (root of 'token_pattern_literal') at parser.lkt:127:30>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos187 = No_Token_Index then
      Set_Failure
        (PP.Token_Pattern_Literal_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Token_Pattern_Literal_Transform_Parse0_Memo, Pos, Transform_Res146, Parser.Last_Diag, Row_Pos187);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos187;
   return Transform_Res146;
end Token_Pattern_Literal_Transform_Parse0;
   function Try_Expr_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Try_Expr
is
      Nobt49 : Boolean := False;
      Nobt50 : Boolean := False;
      Row_Pos188 : Token_Index := No_Token_Index;
      Token_Pos261 : Token_Index := No_Token_Index;
      Token_Res261 : Token_Index := No_Token_Index;
      Defer_Pos249 : Token_Index := No_Token_Index;
      Defer_Res249 : Bare_Expr := No_Bare_Lkt_Node;
      Row_Pos189 : Token_Index := No_Token_Index;
      Token_Pos262 : Token_Index := No_Token_Index;
      Token_Res262 : Token_Index := No_Token_Index;
      Defer_Pos250 : Token_Index := No_Token_Index;
      Defer_Res250 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark100 : Diagnostic_Mark;
      Row_Progress45 : Integer := 0;
      Transform_Res147 : Bare_Try_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed45 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Try_Expr_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res147 := M.Instance;
      return Transform_Res147;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res147;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType TryExpr>) (root of 'try_expr') at parser.lkt:450:17>
--  pos=Row_Pos188, res=Transform_Res147, nobt=Nobt49
--  BEGIN <_Row (root of 'try_expr') at parser.lkt:450:17>
--  pos=Row_Pos188, res=None, nobt=Nobt49
Row_Pos188 := Pos;
--  BEGIN <Token(<WithText TryKw>, ) (root of 'try_expr') at parser.lkt:450:25>
--  pos=Token_Pos261, res=Token_Res261, nobt=None
Token_Res261 := Row_Pos188;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res261));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Try_Kw)
   then
       Token_Pos261 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos188 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos188,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Try_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos261 := Row_Pos188 + 1;
   end if;
end;
--  END <Token(<WithText TryKw>, ) (root of 'try_expr') at parser.lkt:450:25>
Row_Progress45 := 1;
if Token_Pos261 /= No_Token_Index then
   Row_Pos188 := Token_Pos261;
else
   Row_Pos188 := No_Token_Index;
   goto Exit_Row188_0;
end if;
--  BEGIN <Cut (root of 'try_expr') at parser.lkt:450:31>
--  pos=Row_Pos188, res=None, nobt=Nobt49
Nobt49 := True;
--  END <Cut (root of 'try_expr') at parser.lkt:450:31>
Row_Progress45 := 2;
if Row_Pos188 /= No_Token_Index then
   Row_Pos188 := Row_Pos188;
else
   Row_Pos188 := No_Token_Index;
   goto Exit_Row188_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:450:33>
--  pos=Defer_Pos249, res=Defer_Res249, nobt=None
Defer_Res249 :=
   Expr_Or_Parse0 (Parser, Row_Pos188);
Defer_Pos249 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:450:33>
Row_Progress45 := 3;
if Defer_Pos249 /= No_Token_Index then
   Row_Pos188 := Defer_Pos249;
else
   Row_Pos188 := No_Token_Index;
   goto Exit_Row188_0;
end if;
--  BEGIN <Opt (root of 'try_expr') at parser.lkt:450:38>
--  pos=Row_Pos189, res=Defer_Res250, nobt=Nobt50
Diag_Mark100 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'try_expr') at parser.lkt:450:39>
--  pos=Row_Pos189, res=Defer_Res250, nobt=Nobt50
--  BEGIN <_Row (root of 'try_expr') at parser.lkt:450:39>
--  pos=Row_Pos189, res=None, nobt=Nobt50
Row_Pos189 := Row_Pos188;
--  BEGIN <Token(<WithText ElseKw>, ) (root of 'try_expr') at parser.lkt:450:44>
--  pos=Token_Pos262, res=Token_Res262, nobt=None
Token_Res262 := Row_Pos189;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res262));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Else_Kw)
   then
       Token_Pos262 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos189 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos189,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Else_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos262 := Row_Pos189 + 1;
   end if;
end;
--  END <Token(<WithText ElseKw>, ) (root of 'try_expr') at parser.lkt:450:44>
if Token_Pos262 /= No_Token_Index then
   Row_Pos189 := Token_Pos262;
else
   Row_Pos189 := No_Token_Index;
   goto Exit_Row189_0;
end if;
--  BEGIN <Cut (root of 'try_expr') at parser.lkt:450:51>
--  pos=Row_Pos189, res=None, nobt=Nobt50
Nobt50 := True;
--  END <Cut (root of 'try_expr') at parser.lkt:450:51>
if Row_Pos189 /= No_Token_Index then
   Row_Pos189 := Row_Pos189;
else
   Row_Pos189 := No_Token_Index;
   goto Exit_Row189_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:450:53>
--  pos=Defer_Pos250, res=Defer_Res250, nobt=None
Defer_Res250 :=
   Expr_Or_Parse0 (Parser, Row_Pos189);
Defer_Pos250 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:450:53>
if Defer_Pos250 /= No_Token_Index then
   Row_Pos189 := Defer_Pos250;
else
   Row_Pos189 := No_Token_Index;
   goto Exit_Row189_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row189_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'try_expr') at parser.lkt:450:39>
--  END <_Extract (root of 'try_expr') at parser.lkt:450:39>
if Row_Pos189 = No_Token_Index then
   if Nobt50 then
      Row_Pos189 := Parser.Last_Fail.Pos;
      Append (Parser, Row_Pos189, "Cannot parse <try_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
         if not Nobt50 then
   Defer_Res250 := No_Bare_Lkt_Node;
         end if;
       if not Nobt50 then
   Row_Pos189 := Row_Pos188;
      Parser.Last_Diag := Diag_Mark100;
       end if;
end if;
--  END <Opt (root of 'try_expr') at parser.lkt:450:38>
   Nobt49 := Nobt50;
Row_Progress45 := 4;
if Row_Pos189 /= No_Token_Index then
   Row_Pos188 := Row_Pos189;
else
   Row_Pos188 := No_Token_Index;
   goto Exit_Row188_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row188_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'try_expr') at parser.lkt:450:17>
if Row_Pos188 = No_Token_Index and then Nobt49 then
   Row_Pos188 := Parser.Last_Fail.Pos;
   Transform_Has_Failed45 := True;
end if;
if Row_Pos188 /= No_Token_Index then
   Transform_Res147 := Allocate_Try_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res147,
      Kind => Lkt_Try_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos188 = Pos
                            then No_Token_Index
                            else Row_Pos188 - 1));
      Initialize_Fields_For_Try_Expr
        (Self => Transform_Res147,
         Try_Expr_F_Try_Expr => Defer_Res249,
         Try_Expr_F_Or_Expr => Defer_Res250);
         if Defer_Res249 /= null and then Is_Incomplete (Defer_Res249) then
            Transform_Res147.Last_Attempted_Child := 0;
         elsif Defer_Res249 /= null and then not Is_Ghost (Defer_Res249) then
            Transform_Res147.Last_Attempted_Child := -1;
         end if;
         if Defer_Res250 /= null and then Is_Incomplete (Defer_Res250) then
            Transform_Res147.Last_Attempted_Child := 0;
         elsif Defer_Res250 /= null and then not Is_Ghost (Defer_Res250) then
            Transform_Res147.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed45 then
      Transform_Res147.Last_Attempted_Child :=
         Row_Progress45;
      Append (Parser, Pos, "Cannot parse <try_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType TryExpr>) (root of 'try_expr') at parser.lkt:450:17>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos188 = No_Token_Index then
      Set_Failure
        (PP.Try_Expr_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Try_Expr_Transform_Parse0_Memo, Pos, Transform_Res147, Parser.Last_Diag, Row_Pos188);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos188;
   return Transform_Res147;
end Try_Expr_Transform_Parse0;
   function Tuple_Pattern_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Tuple_Pattern
is
      Row_Pos190 : Token_Index := No_Token_Index;
      Token_Pos263 : Token_Index := No_Token_Index;
      Token_Res263 : Token_Index := No_Token_Index;
      Lst_Cpos31 : Token_Index := No_Token_Index;
      Tmp_List31 : Free_Parse_List;
      Defer_Pos251 : Token_Index := No_Token_Index;
      Defer_Res251 : Bare_Pattern := No_Bare_Lkt_Node;
      Token_Pos264 : Token_Index := No_Token_Index;
      Token_Res264 : Token_Index := No_Token_Index;
      List_Pos31 : Token_Index := No_Token_Index;
      List_Res31 : Bare_Pattern_List := No_Bare_Lkt_Node;
      Diag_Mark101 : Diagnostic_Mark;
      Token_Pos265 : Token_Index := No_Token_Index;
      Token_Res265 : Token_Index := No_Token_Index;
      Transform_Res148 : Bare_Tuple_Pattern := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Tuple_Pattern_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res148 := M.Instance;
      return Transform_Res148;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res148;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType TuplePattern>) (root of 'tuple_pattern') at parser.lkt:346:22>
--  pos=Row_Pos190, res=Transform_Res148, nobt=None
--  BEGIN <_Row (root of 'tuple_pattern') at parser.lkt:346:22>
--  pos=Row_Pos190, res=None, nobt=None
Row_Pos190 := Pos;
--  BEGIN <Token(<WithText LPar>, ) (root of 'tuple_pattern') at parser.lkt:346:35>
--  pos=Token_Pos263, res=Token_Res263, nobt=None
Token_Res263 := Row_Pos190;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res263));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos263 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos190 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos190,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos263 := Row_Pos190 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'tuple_pattern') at parser.lkt:346:35>
if Token_Pos263 /= No_Token_Index then
   Row_Pos190 := Token_Pos263;
else
   Row_Pos190 := No_Token_Index;
   goto Exit_Row190_0;
end if;
--  BEGIN <List (root of 'tuple_pattern') at parser.lkt:346:39>
--  pos=List_Pos31, res=List_Res31, nobt=None
    List_Pos31 := No_Token_Index;
Lst_Cpos31 := Row_Pos190;
Tmp_List31 := Get_Parse_List (Parser);
Diag_Mark101 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'value_pattern') at parser.lkt:346:45>
--  pos=Defer_Pos251, res=Defer_Res251, nobt=None
Defer_Res251 :=
   Value_Pattern_Or_Parse1 (Parser, Lst_Cpos31);
Defer_Pos251 := Parser.Current_Pos;
--  END <Defer (for 'value_pattern') at parser.lkt:346:45>
   exit when Defer_Pos251 = No_Token_Index;
   List_Pos31 := Defer_Pos251;
   Lst_Cpos31 := List_Pos31;
   Diag_Mark101 := Parser.Last_Diag;
   Tmp_List31.Nodes.Append (Defer_Res251);
--  BEGIN <Token(<WithText Comma>, ) (root of 'tuple_pattern') at parser.lkt:346:60>
--  pos=Token_Pos264, res=Token_Res264, nobt=None
Token_Res264 := Lst_Cpos31;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res264));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos264 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Lst_Cpos31 then
          Parser.Last_Fail :=
            (Pos  => Lst_Cpos31,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Comma,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos264 := Lst_Cpos31 + 1;
   end if;
end;
--  END <Token(<WithText Comma>, ) (root of 'tuple_pattern') at parser.lkt:346:60>
      exit when Token_Pos264 = No_Token_Index;
      Lst_Cpos31 := Token_Pos264;
end loop;
Parser.Last_Diag := Diag_Mark101;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List31.Nodes.Length;
begin
   List_Res31 := Allocate_Pattern_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos190;
      Token_End := (if Lst_Cpos31 = Row_Pos190
                    then Row_Pos190
                    else List_Pos31 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos190, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res31,
      Kind              => Lkt_Pattern_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res31,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List31.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res31.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List31);
--  END <List (root of 'tuple_pattern') at parser.lkt:346:39>
if List_Pos31 /= No_Token_Index then
   Row_Pos190 := List_Pos31;
else
   Row_Pos190 := No_Token_Index;
   goto Exit_Row190_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'tuple_pattern') at parser.lkt:346:65>
--  pos=Token_Pos265, res=Token_Res265, nobt=None
Token_Res265 := Row_Pos190;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res265));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos265 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos190 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos190,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos265 := Row_Pos190 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'tuple_pattern') at parser.lkt:346:65>
if Token_Pos265 /= No_Token_Index then
   Row_Pos190 := Token_Pos265;
else
   Row_Pos190 := No_Token_Index;
   goto Exit_Row190_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row190_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'tuple_pattern') at parser.lkt:346:22>
if Row_Pos190 /= No_Token_Index then
   Transform_Res148 := Allocate_Tuple_Pattern (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res148,
      Kind => Lkt_Tuple_Pattern,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos190 = Pos
                            then No_Token_Index
                            else Row_Pos190 - 1));
      Initialize_Fields_For_Tuple_Pattern
        (Self => Transform_Res148,
         Tuple_Pattern_F_Sub_Patterns => List_Res31);
         if List_Res31 /= null and then Is_Incomplete (List_Res31) then
            Transform_Res148.Last_Attempted_Child := 0;
         elsif List_Res31 /= null and then not Is_Ghost (List_Res31) then
            Transform_Res148.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType TuplePattern>) (root of 'tuple_pattern') at parser.lkt:346:22>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos190 = No_Token_Index then
      Set_Failure
        (PP.Tuple_Pattern_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Tuple_Pattern_Transform_Parse0_Memo, Pos, Transform_Res148, Parser.Last_Diag, Row_Pos190);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos190;
   return Transform_Res148;
end Tuple_Pattern_Transform_Parse0;
   function Type_Decl_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Named_Type_Decl
is
      Nobt51 : Boolean := False;
      Nobt52 : Boolean := False;
      Nobt53 : Boolean := False;
      Nobt54 : Boolean := False;
      Nobt55 : Boolean := False;
      Nobt56 : Boolean := False;
      Nobt57 : Boolean := False;
      Nobt58 : Boolean := False;
      Row_Pos191 : Token_Index := No_Token_Index;
      Token_Pos266 : Token_Index := No_Token_Index;
      Token_Res266 : Token_Index := No_Token_Index;
      Defer_Pos252 : Token_Index := No_Token_Index;
      Defer_Res252 : Bare_Def_Id := No_Bare_Lkt_Node;
      Row_Pos192 : Token_Index := No_Token_Index;
      Token_Pos267 : Token_Index := No_Token_Index;
      Token_Res267 : Token_Index := No_Token_Index;
      Defer_Pos253 : Token_Index := No_Token_Index;
      Defer_Res253 : Bare_Type_Ref_List := No_Bare_Lkt_Node;
      Diag_Mark102 : Diagnostic_Mark;
      Token_Pos268 : Token_Index := No_Token_Index;
      Token_Res268 : Token_Index := No_Token_Index;
      Defer_Pos254 : Token_Index := No_Token_Index;
      Defer_Res254 : Bare_Decl_Block := No_Bare_Lkt_Node;
      Token_Pos269 : Token_Index := No_Token_Index;
      Token_Res269 : Token_Index := No_Token_Index;
      Row_Progress46 : Integer := 0;
      Transform_Res149 : Bare_Struct_Decl := No_Bare_Lkt_Node;
      Transform_Has_Failed46 : Boolean := False;
      Row_Pos193 : Token_Index := No_Token_Index;
      Token_Pos270 : Token_Index := No_Token_Index;
      Token_Res270 : Token_Index := No_Token_Index;
      Token_Pos271 : Token_Index := No_Token_Index;
      Token_Res271 : Token_Index := No_Token_Index;
      Defer_Pos255 : Token_Index := No_Token_Index;
      Defer_Res255 : Bare_Def_Id := No_Bare_Lkt_Node;
      Row_Pos194 : Token_Index := No_Token_Index;
      Token_Pos272 : Token_Index := No_Token_Index;
      Token_Res272 : Token_Index := No_Token_Index;
      Defer_Pos256 : Token_Index := No_Token_Index;
      Defer_Res256 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Diag_Mark103 : Diagnostic_Mark;
      Row_Pos195 : Token_Index := No_Token_Index;
      Token_Pos273 : Token_Index := No_Token_Index;
      Token_Res273 : Token_Index := No_Token_Index;
      Defer_Pos257 : Token_Index := No_Token_Index;
      Defer_Res257 : Bare_Type_Ref_List := No_Bare_Lkt_Node;
      Diag_Mark104 : Diagnostic_Mark;
      Token_Pos274 : Token_Index := No_Token_Index;
      Token_Res274 : Token_Index := No_Token_Index;
      Lst_Cpos32 : Token_Index := No_Token_Index;
      Tmp_List32 : Free_Parse_List;
      Row_Pos196 : Token_Index := No_Token_Index;
      Token_Pos275 : Token_Index := No_Token_Index;
      Token_Res275 : Token_Index := No_Token_Index;
      Lst_Cpos33 : Token_Index := No_Token_Index;
      Tmp_List33 : Free_Parse_List;
      Row_Pos197 : Token_Index := No_Token_Index;
      Defer_Pos258 : Token_Index := No_Token_Index;
      Defer_Res258 : Bare_Def_Id := No_Bare_Lkt_Node;
      Null_Res21 : Bare_Type_Ref_List := No_Bare_Lkt_Node;
      Transform_Res150 : Bare_Enum_Class_Alt_Decl := No_Bare_Lkt_Node;
      Token_Pos276 : Token_Index := No_Token_Index;
      Token_Res276 : Token_Index := No_Token_Index;
      List_Pos32 : Token_Index := No_Token_Index;
      List_Res32 : Bare_Enum_Class_Alt_Decl_List := No_Bare_Lkt_Node;
      Diag_Mark105 : Diagnostic_Mark;
      Transform_Res151 : Bare_Enum_Class_Case := No_Bare_Lkt_Node;
      List_Pos33 : Token_Index := No_Token_Index;
      List_Res33 : Bare_Enum_Class_Case_List := No_Bare_Lkt_Node;
      Diag_Mark106 : Diagnostic_Mark;
      Defer_Pos259 : Token_Index := No_Token_Index;
      Defer_Res259 : Bare_Decl_Block := No_Bare_Lkt_Node;
      Token_Pos277 : Token_Index := No_Token_Index;
      Token_Res277 : Token_Index := No_Token_Index;
      Row_Progress47 : Integer := 0;
      Transform_Res152 : Bare_Enum_Class_Decl := No_Bare_Lkt_Node;
      Transform_Has_Failed47 : Boolean := False;
      Row_Pos198 : Token_Index := No_Token_Index;
      Token_Pos278 : Token_Index := No_Token_Index;
      Token_Res278 : Token_Index := No_Token_Index;
      Defer_Pos260 : Token_Index := No_Token_Index;
      Defer_Res260 : Bare_Def_Id := No_Bare_Lkt_Node;
      Row_Pos199 : Token_Index := No_Token_Index;
      Token_Pos279 : Token_Index := No_Token_Index;
      Token_Res279 : Token_Index := No_Token_Index;
      Defer_Pos261 : Token_Index := No_Token_Index;
      Defer_Res261 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Diag_Mark107 : Diagnostic_Mark;
      Row_Pos200 : Token_Index := No_Token_Index;
      Token_Pos280 : Token_Index := No_Token_Index;
      Token_Res280 : Token_Index := No_Token_Index;
      Defer_Pos262 : Token_Index := No_Token_Index;
      Defer_Res262 : Bare_Type_Ref_List := No_Bare_Lkt_Node;
      Diag_Mark108 : Diagnostic_Mark;
      Token_Pos281 : Token_Index := No_Token_Index;
      Token_Res281 : Token_Index := No_Token_Index;
      Defer_Pos263 : Token_Index := No_Token_Index;
      Defer_Res263 : Bare_Decl_Block := No_Bare_Lkt_Node;
      Token_Pos282 : Token_Index := No_Token_Index;
      Token_Res282 : Token_Index := No_Token_Index;
      Row_Progress48 : Integer := 0;
      Transform_Res153 : Bare_Class_Decl := No_Bare_Lkt_Node;
      Transform_Has_Failed48 : Boolean := False;
      Row_Pos201 : Token_Index := No_Token_Index;
      Token_Pos283 : Token_Index := No_Token_Index;
      Token_Res283 : Token_Index := No_Token_Index;
      Defer_Pos264 : Token_Index := No_Token_Index;
      Defer_Res264 : Bare_Def_Id := No_Bare_Lkt_Node;
      Row_Pos202 : Token_Index := No_Token_Index;
      Token_Pos284 : Token_Index := No_Token_Index;
      Token_Res284 : Token_Index := No_Token_Index;
      Defer_Pos265 : Token_Index := No_Token_Index;
      Defer_Res265 : Bare_Type_Ref_List := No_Bare_Lkt_Node;
      Diag_Mark109 : Diagnostic_Mark;
      Token_Pos285 : Token_Index := No_Token_Index;
      Token_Res285 : Token_Index := No_Token_Index;
      Token_Pos286 : Token_Index := No_Token_Index;
      Token_Res286 : Token_Index := No_Token_Index;
      Lst_Cpos34 : Token_Index := No_Token_Index;
      Tmp_List34 : Free_Parse_List;
      Defer_Pos266 : Token_Index := No_Token_Index;
      Defer_Res266 : Bare_Enum_Lit_Decl := No_Bare_Lkt_Node;
      Token_Pos287 : Token_Index := No_Token_Index;
      Token_Res287 : Token_Index := No_Token_Index;
      List_Pos34 : Token_Index := No_Token_Index;
      List_Res34 : Bare_Enum_Lit_Decl_List := No_Bare_Lkt_Node;
      Diag_Mark110 : Diagnostic_Mark;
      Defer_Pos267 : Token_Index := No_Token_Index;
      Defer_Res267 : Bare_Decl_Block := No_Bare_Lkt_Node;
      Token_Pos288 : Token_Index := No_Token_Index;
      Token_Res288 : Token_Index := No_Token_Index;
      Row_Progress49 : Integer := 0;
      Transform_Res154 : Bare_Enum_Type_Decl := No_Bare_Lkt_Node;
      Transform_Has_Failed49 : Boolean := False;
      Row_Pos203 : Token_Index := No_Token_Index;
      Token_Pos289 : Token_Index := No_Token_Index;
      Token_Res289 : Token_Index := No_Token_Index;
      Defer_Pos268 : Token_Index := No_Token_Index;
      Defer_Res268 : Bare_Def_Id := No_Bare_Lkt_Node;
      Null_Res22 : Bare_Type_Ref_List := No_Bare_Lkt_Node;
      Token_Pos290 : Token_Index := No_Token_Index;
      Token_Res290 : Token_Index := No_Token_Index;
      Defer_Pos269 : Token_Index := No_Token_Index;
      Defer_Res269 : Bare_Decl_Block := No_Bare_Lkt_Node;
      Token_Pos291 : Token_Index := No_Token_Index;
      Token_Res291 : Token_Index := No_Token_Index;
      Row_Progress50 : Integer := 0;
      Transform_Res155 : Bare_Trait_Decl := No_Bare_Lkt_Node;
      Transform_Has_Failed50 : Boolean := False;
      Or_Pos40 : Token_Index := No_Token_Index;
      Or_Res40 : Bare_Named_Type_Decl := No_Bare_Lkt_Node;
      Diag_Mark111 : Diagnostic_Mark;
      Last_Fail40 : Fail_Info;
      Branch_Diag_Mark40 : Diagnostic_Mark;
      Branch_Last_Fail40 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Type_Decl_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res40 := M.Instance;
      return Or_Res40;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res40;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'type_decl') at parser.lkt:155:18>
--  pos=Or_Pos40, res=Or_Res40, nobt=None
Or_Pos40 := No_Token_Index;
Or_Res40 := No_Bare_Lkt_Node;
Diag_Mark111 := Parser.Last_Diag;
Last_Fail40 := Parser.Last_Fail;
Branch_Diag_Mark40 := Parser.Last_Diag;
Branch_Last_Fail40 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark111;
    Parser.Last_Fail := Last_Fail40;
--  BEGIN <Transform(<ASTNodeType StructDecl>) (root of 'type_decl') at parser.lkt:156:11>
--  pos=Row_Pos191, res=Transform_Res149, nobt=Nobt51
--  BEGIN <_Row (root of 'type_decl') at parser.lkt:156:11>
--  pos=Row_Pos191, res=None, nobt=Nobt51
Row_Pos191 := Pos;
--  BEGIN <Token(<WithText StructKw>, ) (root of 'type_decl') at parser.lkt:157:13>
--  pos=Token_Pos266, res=Token_Res266, nobt=None
Token_Res266 := Row_Pos191;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res266));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Struct_Kw)
   then
       Token_Pos266 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos191 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos191,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Struct_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos266 := Row_Pos191 + 1;
   end if;
end;
--  END <Token(<WithText StructKw>, ) (root of 'type_decl') at parser.lkt:157:13>
Row_Progress46 := 1;
if Token_Pos266 /= No_Token_Index then
   Row_Pos191 := Token_Pos266;
else
   Row_Pos191 := No_Token_Index;
   goto Exit_Row191_0;
end if;
--  BEGIN <Cut (root of 'type_decl') at parser.lkt:158:13>
--  pos=Row_Pos191, res=None, nobt=Nobt51
Nobt51 := True;
--  END <Cut (root of 'type_decl') at parser.lkt:158:13>
Row_Progress46 := 2;
if Row_Pos191 /= No_Token_Index then
   Row_Pos191 := Row_Pos191;
else
   Row_Pos191 := No_Token_Index;
   goto Exit_Row191_0;
end if;
--  BEGIN <Defer (for 'def_id') at parser.lkt:159:13>
--  pos=Defer_Pos252, res=Defer_Res252, nobt=None
Defer_Res252 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos191);
Defer_Pos252 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:159:13>
Row_Progress46 := 3;
if Defer_Pos252 /= No_Token_Index then
   Row_Pos191 := Defer_Pos252;
else
   Row_Pos191 := No_Token_Index;
   goto Exit_Row191_0;
end if;
--  BEGIN <Opt (root of 'type_decl') at parser.lkt:160:13>
--  pos=Row_Pos192, res=Defer_Res253, nobt=Nobt52
Diag_Mark102 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'type_decl') at parser.lkt:160:14>
--  pos=Row_Pos192, res=Defer_Res253, nobt=Nobt52
--  BEGIN <_Row (root of 'type_decl') at parser.lkt:160:14>
--  pos=Row_Pos192, res=None, nobt=Nobt52
Row_Pos192 := Row_Pos191;
--  BEGIN <Token(<WithText ImplementsKw>, ) (root of 'type_decl') at parser.lkt:160:19>
--  pos=Token_Pos267, res=Token_Res267, nobt=None
Token_Res267 := Row_Pos192;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res267));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Implements_Kw)
   then
       Token_Pos267 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos192 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos192,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Implements_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos267 := Row_Pos192 + 1;
   end if;
end;
--  END <Token(<WithText ImplementsKw>, ) (root of 'type_decl') at parser.lkt:160:19>
if Token_Pos267 /= No_Token_Index then
   Row_Pos192 := Token_Pos267;
else
   Row_Pos192 := No_Token_Index;
   goto Exit_Row192_0;
end if;
--  BEGIN <Cut (root of 'type_decl') at parser.lkt:160:32>
--  pos=Row_Pos192, res=None, nobt=Nobt52
Nobt52 := True;
--  END <Cut (root of 'type_decl') at parser.lkt:160:32>
if Row_Pos192 /= No_Token_Index then
   Row_Pos192 := Row_Pos192;
else
   Row_Pos192 := No_Token_Index;
   goto Exit_Row192_0;
end if;
--  BEGIN <Defer (for 'type_list') at parser.lkt:160:34>
--  pos=Defer_Pos253, res=Defer_Res253, nobt=None
Defer_Res253 :=
   Type_List_List_Parse0 (Parser, Row_Pos192);
Defer_Pos253 := Parser.Current_Pos;
--  END <Defer (for 'type_list') at parser.lkt:160:34>
if Defer_Pos253 /= No_Token_Index then
   Row_Pos192 := Defer_Pos253;
else
   Row_Pos192 := No_Token_Index;
   goto Exit_Row192_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row192_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_decl') at parser.lkt:160:14>
--  END <_Extract (root of 'type_decl') at parser.lkt:160:14>
if Row_Pos192 = No_Token_Index then
   if Nobt52 then
      Row_Pos192 := Parser.Last_Fail.Pos;
      Append (Parser, Row_Pos192, "Cannot parse <type_decl>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
         if Defer_Res253 = No_Bare_Lkt_Node then
   Defer_Res253 :=
     Allocate_Type_Ref_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res253,
      Kind              => Lkt_Type_Ref_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos191,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res253,
      Parser => Parser,
      Count  => 0);
         end if;
       if not Nobt52 then
   Row_Pos192 := Row_Pos191;
      Parser.Last_Diag := Diag_Mark102;
       end if;
end if;
--  END <Opt (root of 'type_decl') at parser.lkt:160:13>
   Nobt51 := Nobt52;
Row_Progress46 := 4;
if Row_Pos192 /= No_Token_Index then
   Row_Pos191 := Row_Pos192;
else
   Row_Pos191 := No_Token_Index;
   goto Exit_Row191_0;
end if;
--  BEGIN <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:161:13>
--  pos=Token_Pos268, res=Token_Res268, nobt=None
Token_Res268 := Row_Pos191;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res268));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos268 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos191 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos191,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos268 := Row_Pos191 + 1;
   end if;
end;
--  END <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:161:13>
Row_Progress46 := 5;
if Token_Pos268 /= No_Token_Index then
   Row_Pos191 := Token_Pos268;
else
   Row_Pos191 := No_Token_Index;
   goto Exit_Row191_0;
end if;
--  BEGIN <DontSkip (root of 'type_decl') at parser.lkt:162:13>
--  pos=Defer_Pos254, res=Defer_Res254, nobt=None
        PP.Dont_Skip.Append (Dontskip_Type_Decl0_Extract_Parse0'Access);
--  BEGIN <Defer (for 'decl_block') at parser.lkt:162:13>
--  pos=Defer_Pos254, res=Defer_Res254, nobt=None
Defer_Res254 :=
   Decl_Block_List_Parse0 (Parser, Row_Pos191);
Defer_Pos254 := Parser.Current_Pos;
--  END <Defer (for 'decl_block') at parser.lkt:162:13>
        PP.Dont_Skip.Delete_Last;
--  END <DontSkip (root of 'type_decl') at parser.lkt:162:13>
Row_Progress46 := 6;
if Defer_Pos254 /= No_Token_Index then
   Row_Pos191 := Defer_Pos254;
else
   Row_Pos191 := No_Token_Index;
   goto Exit_Row191_0;
end if;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:163:13>
--  pos=Token_Pos269, res=Token_Res269, nobt=None
Token_Res269 := Row_Pos191;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res269));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos269 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos191 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos191,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos269 := Row_Pos191 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:163:13>
Row_Progress46 := 7;
if Token_Pos269 /= No_Token_Index then
   Row_Pos191 := Token_Pos269;
else
   Row_Pos191 := No_Token_Index;
   goto Exit_Row191_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row191_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_decl') at parser.lkt:156:11>
if Row_Pos191 = No_Token_Index and then Nobt51 then
   Row_Pos191 := Parser.Last_Fail.Pos;
   Transform_Has_Failed46 := True;
end if;
if Row_Pos191 /= No_Token_Index then
   Transform_Res149 := Allocate_Struct_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res149,
      Kind => Lkt_Struct_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos191 = Pos
                            then No_Token_Index
                            else Row_Pos191 - 1));
      Initialize_Fields_For_Struct_Decl
        (Self => Transform_Res149,
         Struct_Decl_F_Syn_Name => Defer_Res252,
         Struct_Decl_F_Traits => Defer_Res253,
         Struct_Decl_F_Decls => Defer_Res254);
         if Defer_Res252 /= null and then Is_Incomplete (Defer_Res252) then
            Transform_Res149.Last_Attempted_Child := 0;
         elsif Defer_Res252 /= null and then not Is_Ghost (Defer_Res252) then
            Transform_Res149.Last_Attempted_Child := -1;
         end if;
         if Defer_Res253 /= null and then Is_Incomplete (Defer_Res253) then
            Transform_Res149.Last_Attempted_Child := 0;
         elsif Defer_Res253 /= null and then not Is_Ghost (Defer_Res253) then
            Transform_Res149.Last_Attempted_Child := -1;
         end if;
         if Defer_Res254 /= null and then Is_Incomplete (Defer_Res254) then
            Transform_Res149.Last_Attempted_Child := 0;
         elsif Defer_Res254 /= null and then not Is_Ghost (Defer_Res254) then
            Transform_Res149.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed46 then
      Transform_Res149.Last_Attempted_Child :=
         Row_Progress46;
      Append (Parser, Pos, "Cannot parse <type_decl>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType StructDecl>) (root of 'type_decl') at parser.lkt:156:11>
    if Row_Pos191 /= No_Token_Index then
        Or_Pos40 := Row_Pos191;
        Or_Res40 := Transform_Res149;
        goto Exit_Or44;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail40.Pos then
       Branch_Diag_Mark40 := Parser.Last_Diag;
       Branch_Last_Fail40 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark111;
    Parser.Last_Fail := Last_Fail40;
--  BEGIN <Transform(<ASTNodeType EnumClassDecl>) (root of 'type_decl') at parser.lkt:165:11>
--  pos=Row_Pos193, res=Transform_Res152, nobt=Nobt53
--  BEGIN <_Row (root of 'type_decl') at parser.lkt:165:11>
--  pos=Row_Pos193, res=None, nobt=Nobt53
Row_Pos193 := Pos;
--  BEGIN <Token(<WithText EnumKw>, ) (root of 'type_decl') at parser.lkt:166:13>
--  pos=Token_Pos270, res=Token_Res270, nobt=None
Token_Res270 := Row_Pos193;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res270));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Enum_Kw)
   then
       Token_Pos270 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos193 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos193,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Enum_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos270 := Row_Pos193 + 1;
   end if;
end;
--  END <Token(<WithText EnumKw>, ) (root of 'type_decl') at parser.lkt:166:13>
Row_Progress47 := 1;
if Token_Pos270 /= No_Token_Index then
   Row_Pos193 := Token_Pos270;
else
   Row_Pos193 := No_Token_Index;
   goto Exit_Row193_0;
end if;
--  BEGIN <Token(<WithText ClassKw>, ) (root of 'type_decl') at parser.lkt:167:13>
--  pos=Token_Pos271, res=Token_Res271, nobt=None
Token_Res271 := Row_Pos193;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res271));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Class_Kw)
   then
       Token_Pos271 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos193 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos193,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Class_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos271 := Row_Pos193 + 1;
   end if;
end;
--  END <Token(<WithText ClassKw>, ) (root of 'type_decl') at parser.lkt:167:13>
Row_Progress47 := 2;
if Token_Pos271 /= No_Token_Index then
   Row_Pos193 := Token_Pos271;
else
   Row_Pos193 := No_Token_Index;
   goto Exit_Row193_0;
end if;
--  BEGIN <Cut (root of 'type_decl') at parser.lkt:168:13>
--  pos=Row_Pos193, res=None, nobt=Nobt53
Nobt53 := True;
--  END <Cut (root of 'type_decl') at parser.lkt:168:13>
Row_Progress47 := 3;
if Row_Pos193 /= No_Token_Index then
   Row_Pos193 := Row_Pos193;
else
   Row_Pos193 := No_Token_Index;
   goto Exit_Row193_0;
end if;
--  BEGIN <Defer (for 'def_id') at parser.lkt:169:13>
--  pos=Defer_Pos255, res=Defer_Res255, nobt=None
Defer_Res255 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos193);
Defer_Pos255 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:169:13>
Row_Progress47 := 4;
if Defer_Pos255 /= No_Token_Index then
   Row_Pos193 := Defer_Pos255;
else
   Row_Pos193 := No_Token_Index;
   goto Exit_Row193_0;
end if;
--  BEGIN <Opt (root of 'type_decl') at parser.lkt:170:13>
--  pos=Row_Pos194, res=Defer_Res256, nobt=None
Diag_Mark103 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'type_decl') at parser.lkt:170:14>
--  pos=Row_Pos194, res=Defer_Res256, nobt=None
--  BEGIN <_Row (root of 'type_decl') at parser.lkt:170:14>
--  pos=Row_Pos194, res=None, nobt=None
Row_Pos194 := Row_Pos193;
--  BEGIN <Token(<WithText Colon>, ) (root of 'type_decl') at parser.lkt:170:19>
--  pos=Token_Pos272, res=Token_Res272, nobt=None
Token_Res272 := Row_Pos194;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res272));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos272 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos194 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos194,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Colon,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos272 := Row_Pos194 + 1;
   end if;
end;
--  END <Token(<WithText Colon>, ) (root of 'type_decl') at parser.lkt:170:19>
if Token_Pos272 /= No_Token_Index then
   Row_Pos194 := Token_Pos272;
else
   Row_Pos194 := No_Token_Index;
   goto Exit_Row194_0;
end if;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:170:23>
--  pos=Defer_Pos256, res=Defer_Res256, nobt=None
Defer_Res256 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos194);
Defer_Pos256 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:170:23>
if Defer_Pos256 /= No_Token_Index then
   Row_Pos194 := Defer_Pos256;
else
   Row_Pos194 := No_Token_Index;
   goto Exit_Row194_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row194_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_decl') at parser.lkt:170:14>
--  END <_Extract (root of 'type_decl') at parser.lkt:170:14>
if Row_Pos194 = No_Token_Index then
   Defer_Res256 := No_Bare_Lkt_Node;
   Row_Pos194 := Row_Pos193;
      Parser.Last_Diag := Diag_Mark103;
end if;
--  END <Opt (root of 'type_decl') at parser.lkt:170:13>
Row_Progress47 := 5;
if Row_Pos194 /= No_Token_Index then
   Row_Pos193 := Row_Pos194;
else
   Row_Pos193 := No_Token_Index;
   goto Exit_Row193_0;
end if;
--  BEGIN <Opt (root of 'type_decl') at parser.lkt:171:13>
--  pos=Row_Pos195, res=Defer_Res257, nobt=None
Diag_Mark104 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'type_decl') at parser.lkt:171:14>
--  pos=Row_Pos195, res=Defer_Res257, nobt=None
--  BEGIN <_Row (root of 'type_decl') at parser.lkt:171:14>
--  pos=Row_Pos195, res=None, nobt=None
Row_Pos195 := Row_Pos193;
--  BEGIN <Token(<WithText ImplementsKw>, ) (root of 'type_decl') at parser.lkt:171:19>
--  pos=Token_Pos273, res=Token_Res273, nobt=None
Token_Res273 := Row_Pos195;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res273));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Implements_Kw)
   then
       Token_Pos273 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos195 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos195,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Implements_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos273 := Row_Pos195 + 1;
   end if;
end;
--  END <Token(<WithText ImplementsKw>, ) (root of 'type_decl') at parser.lkt:171:19>
if Token_Pos273 /= No_Token_Index then
   Row_Pos195 := Token_Pos273;
else
   Row_Pos195 := No_Token_Index;
   goto Exit_Row195_0;
end if;
--  BEGIN <Defer (for 'type_list') at parser.lkt:171:32>
--  pos=Defer_Pos257, res=Defer_Res257, nobt=None
Defer_Res257 :=
   Type_List_List_Parse0 (Parser, Row_Pos195);
Defer_Pos257 := Parser.Current_Pos;
--  END <Defer (for 'type_list') at parser.lkt:171:32>
if Defer_Pos257 /= No_Token_Index then
   Row_Pos195 := Defer_Pos257;
else
   Row_Pos195 := No_Token_Index;
   goto Exit_Row195_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row195_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_decl') at parser.lkt:171:14>
--  END <_Extract (root of 'type_decl') at parser.lkt:171:14>
if Row_Pos195 = No_Token_Index then
   Defer_Res257 :=
     Allocate_Type_Ref_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res257,
      Kind              => Lkt_Type_Ref_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos193,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res257,
      Parser => Parser,
      Count  => 0);
   Row_Pos195 := Row_Pos193;
      Parser.Last_Diag := Diag_Mark104;
end if;
--  END <Opt (root of 'type_decl') at parser.lkt:171:13>
Row_Progress47 := 6;
if Row_Pos195 /= No_Token_Index then
   Row_Pos193 := Row_Pos195;
else
   Row_Pos193 := No_Token_Index;
   goto Exit_Row193_0;
end if;
--  BEGIN <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:172:13>
--  pos=Token_Pos274, res=Token_Res274, nobt=None
Token_Res274 := Row_Pos193;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res274));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos274 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos193 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos193,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos274 := Row_Pos193 + 1;
   end if;
end;
--  END <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:172:13>
Row_Progress47 := 7;
if Token_Pos274 /= No_Token_Index then
   Row_Pos193 := Token_Pos274;
else
   Row_Pos193 := No_Token_Index;
   goto Exit_Row193_0;
end if;
--  BEGIN <List (root of 'type_decl') at parser.lkt:173:13>
--  pos=List_Pos33, res=List_Res33, nobt=None
    List_Pos33 := Row_Pos193;
Lst_Cpos32 := Row_Pos193;
Tmp_List32 := Get_Parse_List (Parser);
Diag_Mark106 := Parser.Last_Diag;
loop
--  BEGIN <Transform(<ASTNodeType EnumClassCase>) (root of 'type_decl') at parser.lkt:174:17>
--  pos=Row_Pos196, res=Transform_Res151, nobt=None
--  BEGIN <_Row (root of 'type_decl') at parser.lkt:174:17>
--  pos=Row_Pos196, res=None, nobt=None
Row_Pos196 := Lst_Cpos32;
--  BEGIN <Token(<WithText CaseKw>, ) (root of 'type_decl') at parser.lkt:175:21>
--  pos=Token_Pos275, res=Token_Res275, nobt=None
Token_Res275 := Row_Pos196;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res275));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Case_Kw)
   then
       Token_Pos275 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos196 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos196,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Case_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos275 := Row_Pos196 + 1;
   end if;
end;
--  END <Token(<WithText CaseKw>, ) (root of 'type_decl') at parser.lkt:175:21>
if Token_Pos275 /= No_Token_Index then
   Row_Pos196 := Token_Pos275;
else
   Row_Pos196 := No_Token_Index;
   goto Exit_Row196_0;
end if;
--  BEGIN <List (root of 'type_decl') at parser.lkt:176:21>
--  pos=List_Pos32, res=List_Res32, nobt=None
    List_Pos32 := No_Token_Index;
Lst_Cpos33 := Row_Pos196;
Tmp_List33 := Get_Parse_List (Parser);
Diag_Mark105 := Parser.Last_Diag;
loop
--  BEGIN <Transform(<ASTNodeType EnumClassAltDecl>) (root of 'type_decl') at parser.lkt:176:27>
--  pos=Row_Pos197, res=Transform_Res150, nobt=None
--  BEGIN <_Row (root of 'type_decl') at parser.lkt:176:27>
--  pos=Row_Pos197, res=None, nobt=None
Row_Pos197 := Lst_Cpos33;
--  BEGIN <Defer (for 'def_id') at parser.lkt:176:44>
--  pos=Defer_Pos258, res=Defer_Res258, nobt=None
Defer_Res258 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos197);
Defer_Pos258 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:176:44>
if Defer_Pos258 /= No_Token_Index then
   Row_Pos197 := Defer_Pos258;
else
   Row_Pos197 := No_Token_Index;
   goto Exit_Row197_0;
end if;
--  BEGIN <Null (root of 'type_decl') at parser.lkt:176:51>
--  pos=Row_Pos197, res=Null_Res21, nobt=None
   Null_Res21 := Allocate_Type_Ref_List (Parser.Mem_Pool);
   Initialize
     (Self              => Null_Res21,
      Kind              => Lkt_Type_Ref_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Index'Max (Row_Pos197, 1),
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Null_Res21,
      Parser => Parser,
      Count  => 0);
--  END <Null (root of 'type_decl') at parser.lkt:176:51>
if Row_Pos197 /= No_Token_Index then
   Row_Pos197 := Row_Pos197;
else
   Row_Pos197 := No_Token_Index;
   goto Exit_Row197_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row197_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_decl') at parser.lkt:176:27>
if Row_Pos197 /= No_Token_Index then
   Transform_Res150 := Allocate_Enum_Class_Alt_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res150,
      Kind => Lkt_Enum_Class_Alt_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Lst_Cpos33,
      Token_End_Index   => (if Row_Pos197 = Lst_Cpos33
                            then No_Token_Index
                            else Row_Pos197 - 1));
      Initialize_Fields_For_Enum_Class_Alt_Decl
        (Self => Transform_Res150,
         Enum_Class_Alt_Decl_F_Syn_Name => Defer_Res258,
         Enum_Class_Alt_Decl_F_Traits => Null_Res21);
         if Defer_Res258 /= null and then Is_Incomplete (Defer_Res258) then
            Transform_Res150.Last_Attempted_Child := 0;
         elsif Defer_Res258 /= null and then not Is_Ghost (Defer_Res258) then
            Transform_Res150.Last_Attempted_Child := -1;
         end if;
         if Null_Res21 /= null and then Is_Incomplete (Null_Res21) then
            Transform_Res150.Last_Attempted_Child := 0;
         elsif Null_Res21 /= null and then not Is_Ghost (Null_Res21) then
            Transform_Res150.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType EnumClassAltDecl>) (root of 'type_decl') at parser.lkt:176:27>
   exit when Row_Pos197 = No_Token_Index;
   List_Pos32 := Row_Pos197;
   Lst_Cpos33 := List_Pos32;
   Diag_Mark105 := Parser.Last_Diag;
   Tmp_List33.Nodes.Append (Transform_Res150);
--  BEGIN <Token(<WithText Comma>, ) (root of 'type_decl') at parser.lkt:176:76>
--  pos=Token_Pos276, res=Token_Res276, nobt=None
Token_Res276 := Lst_Cpos33;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res276));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos276 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Lst_Cpos33 then
          Parser.Last_Fail :=
            (Pos  => Lst_Cpos33,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Comma,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos276 := Lst_Cpos33 + 1;
   end if;
end;
--  END <Token(<WithText Comma>, ) (root of 'type_decl') at parser.lkt:176:76>
      exit when Token_Pos276 = No_Token_Index;
      Lst_Cpos33 := Token_Pos276;
end loop;
Parser.Last_Diag := Diag_Mark105;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List33.Nodes.Length;
begin
   List_Res32 := Allocate_Enum_Class_Alt_Decl_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos196;
      Token_End := (if Lst_Cpos33 = Row_Pos196
                    then Row_Pos196
                    else List_Pos32 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos196, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res32,
      Kind              => Lkt_Enum_Class_Alt_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res32,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List33.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res32.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List33);
--  END <List (root of 'type_decl') at parser.lkt:176:21>
if List_Pos32 /= No_Token_Index then
   Row_Pos196 := List_Pos32;
else
   Row_Pos196 := No_Token_Index;
   goto Exit_Row196_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row196_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_decl') at parser.lkt:174:17>
if Row_Pos196 /= No_Token_Index then
   Transform_Res151 := Allocate_Enum_Class_Case (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res151,
      Kind => Lkt_Enum_Class_Case,
      Unit => Parser.Unit,
      Token_Start_Index => Lst_Cpos32,
      Token_End_Index   => (if Row_Pos196 = Lst_Cpos32
                            then No_Token_Index
                            else Row_Pos196 - 1));
      Initialize_Fields_For_Enum_Class_Case
        (Self => Transform_Res151,
         Enum_Class_Case_F_Decls => List_Res32);
         if List_Res32 /= null and then Is_Incomplete (List_Res32) then
            Transform_Res151.Last_Attempted_Child := 0;
         elsif List_Res32 /= null and then not Is_Ghost (List_Res32) then
            Transform_Res151.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType EnumClassCase>) (root of 'type_decl') at parser.lkt:174:17>
   exit when Row_Pos196 = No_Token_Index;
   List_Pos33 := Row_Pos196;
   Lst_Cpos32 := List_Pos33;
   Diag_Mark106 := Parser.Last_Diag;
   Tmp_List32.Nodes.Append (Transform_Res151);
end loop;
Parser.Last_Diag := Diag_Mark106;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List32.Nodes.Length;
begin
   List_Res33 := Allocate_Enum_Class_Case_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos193;
      Token_End := (if Lst_Cpos32 = Row_Pos193
                    then Row_Pos193
                    else List_Pos33 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos193, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res33,
      Kind              => Lkt_Enum_Class_Case_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res33,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List32.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res33.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List32);
--  END <List (root of 'type_decl') at parser.lkt:173:13>
Row_Progress47 := 8;
if List_Pos33 /= No_Token_Index then
   Row_Pos193 := List_Pos33;
else
   Row_Pos193 := No_Token_Index;
   goto Exit_Row193_0;
end if;
--  BEGIN <DontSkip (root of 'type_decl') at parser.lkt:179:13>
--  pos=Defer_Pos259, res=Defer_Res259, nobt=None
        PP.Dont_Skip.Append (Dontskip_Type_Decl1_Extract_Parse0'Access);
--  BEGIN <Defer (for 'decl_block') at parser.lkt:179:13>
--  pos=Defer_Pos259, res=Defer_Res259, nobt=None
Defer_Res259 :=
   Decl_Block_List_Parse0 (Parser, Row_Pos193);
Defer_Pos259 := Parser.Current_Pos;
--  END <Defer (for 'decl_block') at parser.lkt:179:13>
        PP.Dont_Skip.Delete_Last;
--  END <DontSkip (root of 'type_decl') at parser.lkt:179:13>
Row_Progress47 := 9;
if Defer_Pos259 /= No_Token_Index then
   Row_Pos193 := Defer_Pos259;
else
   Row_Pos193 := No_Token_Index;
   goto Exit_Row193_0;
end if;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:180:13>
--  pos=Token_Pos277, res=Token_Res277, nobt=None
Token_Res277 := Row_Pos193;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res277));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos277 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos193 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos193,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos277 := Row_Pos193 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:180:13>
Row_Progress47 := 10;
if Token_Pos277 /= No_Token_Index then
   Row_Pos193 := Token_Pos277;
else
   Row_Pos193 := No_Token_Index;
   goto Exit_Row193_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row193_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_decl') at parser.lkt:165:11>
if Row_Pos193 = No_Token_Index and then Nobt53 then
   Row_Pos193 := Parser.Last_Fail.Pos;
   Transform_Has_Failed47 := True;
end if;
if Row_Pos193 /= No_Token_Index then
   Transform_Res152 := Allocate_Enum_Class_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res152,
      Kind => Lkt_Enum_Class_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos193 = Pos
                            then No_Token_Index
                            else Row_Pos193 - 1));
      Initialize_Fields_For_Enum_Class_Decl
        (Self => Transform_Res152,
         Basic_Class_Decl_F_Syn_Name => Defer_Res255,
         Basic_Class_Decl_F_Syn_Base_Type => Defer_Res256,
         Basic_Class_Decl_F_Traits => Defer_Res257,
         Enum_Class_Decl_F_Branches => List_Res33,
         Enum_Class_Decl_F_Decls => Defer_Res259);
         if Defer_Res255 /= null and then Is_Incomplete (Defer_Res255) then
            Transform_Res152.Last_Attempted_Child := 0;
         elsif Defer_Res255 /= null and then not Is_Ghost (Defer_Res255) then
            Transform_Res152.Last_Attempted_Child := -1;
         end if;
         if Defer_Res256 /= null and then Is_Incomplete (Defer_Res256) then
            Transform_Res152.Last_Attempted_Child := 0;
         elsif Defer_Res256 /= null and then not Is_Ghost (Defer_Res256) then
            Transform_Res152.Last_Attempted_Child := -1;
         end if;
         if Defer_Res257 /= null and then Is_Incomplete (Defer_Res257) then
            Transform_Res152.Last_Attempted_Child := 0;
         elsif Defer_Res257 /= null and then not Is_Ghost (Defer_Res257) then
            Transform_Res152.Last_Attempted_Child := -1;
         end if;
         if List_Res33 /= null and then Is_Incomplete (List_Res33) then
            Transform_Res152.Last_Attempted_Child := 0;
         elsif List_Res33 /= null and then not Is_Ghost (List_Res33) then
            Transform_Res152.Last_Attempted_Child := -1;
         end if;
         if Defer_Res259 /= null and then Is_Incomplete (Defer_Res259) then
            Transform_Res152.Last_Attempted_Child := 0;
         elsif Defer_Res259 /= null and then not Is_Ghost (Defer_Res259) then
            Transform_Res152.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed47 then
      Transform_Res152.Last_Attempted_Child :=
         Row_Progress47;
      Append (Parser, Pos, "Cannot parse <type_decl>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType EnumClassDecl>) (root of 'type_decl') at parser.lkt:165:11>
    if Row_Pos193 /= No_Token_Index then
        Or_Pos40 := Row_Pos193;
        Or_Res40 := Transform_Res152;
        goto Exit_Or44;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail40.Pos then
       Branch_Diag_Mark40 := Parser.Last_Diag;
       Branch_Last_Fail40 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark111;
    Parser.Last_Fail := Last_Fail40;
--  BEGIN <Transform(<ASTNodeType ClassDecl>) (root of 'type_decl') at parser.lkt:182:11>
--  pos=Row_Pos198, res=Transform_Res153, nobt=Nobt54
--  BEGIN <_Row (root of 'type_decl') at parser.lkt:182:11>
--  pos=Row_Pos198, res=None, nobt=Nobt54
Row_Pos198 := Pos;
--  BEGIN <Token(<WithText ClassKw>, ) (root of 'type_decl') at parser.lkt:183:13>
--  pos=Token_Pos278, res=Token_Res278, nobt=None
Token_Res278 := Row_Pos198;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res278));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Class_Kw)
   then
       Token_Pos278 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos198 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos198,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Class_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos278 := Row_Pos198 + 1;
   end if;
end;
--  END <Token(<WithText ClassKw>, ) (root of 'type_decl') at parser.lkt:183:13>
Row_Progress48 := 1;
if Token_Pos278 /= No_Token_Index then
   Row_Pos198 := Token_Pos278;
else
   Row_Pos198 := No_Token_Index;
   goto Exit_Row198_0;
end if;
--  BEGIN <Cut (root of 'type_decl') at parser.lkt:184:13>
--  pos=Row_Pos198, res=None, nobt=Nobt54
Nobt54 := True;
--  END <Cut (root of 'type_decl') at parser.lkt:184:13>
Row_Progress48 := 2;
if Row_Pos198 /= No_Token_Index then
   Row_Pos198 := Row_Pos198;
else
   Row_Pos198 := No_Token_Index;
   goto Exit_Row198_0;
end if;
--  BEGIN <Defer (for 'def_id') at parser.lkt:185:13>
--  pos=Defer_Pos260, res=Defer_Res260, nobt=None
Defer_Res260 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos198);
Defer_Pos260 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:185:13>
Row_Progress48 := 3;
if Defer_Pos260 /= No_Token_Index then
   Row_Pos198 := Defer_Pos260;
else
   Row_Pos198 := No_Token_Index;
   goto Exit_Row198_0;
end if;
--  BEGIN <Opt (root of 'type_decl') at parser.lkt:186:13>
--  pos=Row_Pos199, res=Defer_Res261, nobt=Nobt55
Diag_Mark107 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'type_decl') at parser.lkt:186:14>
--  pos=Row_Pos199, res=Defer_Res261, nobt=Nobt55
--  BEGIN <_Row (root of 'type_decl') at parser.lkt:186:14>
--  pos=Row_Pos199, res=None, nobt=Nobt55
Row_Pos199 := Row_Pos198;
--  BEGIN <Token(<WithText Colon>, ) (root of 'type_decl') at parser.lkt:186:19>
--  pos=Token_Pos279, res=Token_Res279, nobt=None
Token_Res279 := Row_Pos199;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res279));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos279 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos199 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos199,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Colon,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos279 := Row_Pos199 + 1;
   end if;
end;
--  END <Token(<WithText Colon>, ) (root of 'type_decl') at parser.lkt:186:19>
if Token_Pos279 /= No_Token_Index then
   Row_Pos199 := Token_Pos279;
else
   Row_Pos199 := No_Token_Index;
   goto Exit_Row199_0;
end if;
--  BEGIN <Cut (root of 'type_decl') at parser.lkt:186:23>
--  pos=Row_Pos199, res=None, nobt=Nobt55
Nobt55 := True;
--  END <Cut (root of 'type_decl') at parser.lkt:186:23>
if Row_Pos199 /= No_Token_Index then
   Row_Pos199 := Row_Pos199;
else
   Row_Pos199 := No_Token_Index;
   goto Exit_Row199_0;
end if;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:186:25>
--  pos=Defer_Pos261, res=Defer_Res261, nobt=None
Defer_Res261 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos199);
Defer_Pos261 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:186:25>
if Defer_Pos261 /= No_Token_Index then
   Row_Pos199 := Defer_Pos261;
else
   Row_Pos199 := No_Token_Index;
   goto Exit_Row199_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row199_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_decl') at parser.lkt:186:14>
--  END <_Extract (root of 'type_decl') at parser.lkt:186:14>
if Row_Pos199 = No_Token_Index then
   if Nobt55 then
      Row_Pos199 := Parser.Last_Fail.Pos;
      Append (Parser, Row_Pos199, "Cannot parse <type_decl>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
         if not Nobt55 then
   Defer_Res261 := No_Bare_Lkt_Node;
         end if;
       if not Nobt55 then
   Row_Pos199 := Row_Pos198;
      Parser.Last_Diag := Diag_Mark107;
       end if;
end if;
--  END <Opt (root of 'type_decl') at parser.lkt:186:13>
   Nobt54 := Nobt55;
Row_Progress48 := 4;
if Row_Pos199 /= No_Token_Index then
   Row_Pos198 := Row_Pos199;
else
   Row_Pos198 := No_Token_Index;
   goto Exit_Row198_0;
end if;
--  BEGIN <Opt (root of 'type_decl') at parser.lkt:187:13>
--  pos=Row_Pos200, res=Defer_Res262, nobt=Nobt56
Diag_Mark108 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'type_decl') at parser.lkt:187:14>
--  pos=Row_Pos200, res=Defer_Res262, nobt=Nobt56
--  BEGIN <_Row (root of 'type_decl') at parser.lkt:187:14>
--  pos=Row_Pos200, res=None, nobt=Nobt56
Row_Pos200 := Row_Pos198;
--  BEGIN <Token(<WithText ImplementsKw>, ) (root of 'type_decl') at parser.lkt:187:19>
--  pos=Token_Pos280, res=Token_Res280, nobt=None
Token_Res280 := Row_Pos200;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res280));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Implements_Kw)
   then
       Token_Pos280 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos200 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos200,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Implements_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos280 := Row_Pos200 + 1;
   end if;
end;
--  END <Token(<WithText ImplementsKw>, ) (root of 'type_decl') at parser.lkt:187:19>
if Token_Pos280 /= No_Token_Index then
   Row_Pos200 := Token_Pos280;
else
   Row_Pos200 := No_Token_Index;
   goto Exit_Row200_0;
end if;
--  BEGIN <Cut (root of 'type_decl') at parser.lkt:187:32>
--  pos=Row_Pos200, res=None, nobt=Nobt56
Nobt56 := True;
--  END <Cut (root of 'type_decl') at parser.lkt:187:32>
if Row_Pos200 /= No_Token_Index then
   Row_Pos200 := Row_Pos200;
else
   Row_Pos200 := No_Token_Index;
   goto Exit_Row200_0;
end if;
--  BEGIN <Defer (for 'type_list') at parser.lkt:187:34>
--  pos=Defer_Pos262, res=Defer_Res262, nobt=None
Defer_Res262 :=
   Type_List_List_Parse0 (Parser, Row_Pos200);
Defer_Pos262 := Parser.Current_Pos;
--  END <Defer (for 'type_list') at parser.lkt:187:34>
if Defer_Pos262 /= No_Token_Index then
   Row_Pos200 := Defer_Pos262;
else
   Row_Pos200 := No_Token_Index;
   goto Exit_Row200_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row200_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_decl') at parser.lkt:187:14>
--  END <_Extract (root of 'type_decl') at parser.lkt:187:14>
if Row_Pos200 = No_Token_Index then
   if Nobt56 then
      Row_Pos200 := Parser.Last_Fail.Pos;
      Append (Parser, Row_Pos200, "Cannot parse <type_decl>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
         if Defer_Res262 = No_Bare_Lkt_Node then
   Defer_Res262 :=
     Allocate_Type_Ref_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res262,
      Kind              => Lkt_Type_Ref_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos198,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res262,
      Parser => Parser,
      Count  => 0);
         end if;
       if not Nobt56 then
   Row_Pos200 := Row_Pos198;
      Parser.Last_Diag := Diag_Mark108;
       end if;
end if;
--  END <Opt (root of 'type_decl') at parser.lkt:187:13>
   Nobt54 := Nobt56;
Row_Progress48 := 5;
if Row_Pos200 /= No_Token_Index then
   Row_Pos198 := Row_Pos200;
else
   Row_Pos198 := No_Token_Index;
   goto Exit_Row198_0;
end if;
--  BEGIN <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:188:13>
--  pos=Token_Pos281, res=Token_Res281, nobt=None
Token_Res281 := Row_Pos198;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res281));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos281 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos198 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos198,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos281 := Row_Pos198 + 1;
   end if;
end;
--  END <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:188:13>
Row_Progress48 := 6;
if Token_Pos281 /= No_Token_Index then
   Row_Pos198 := Token_Pos281;
else
   Row_Pos198 := No_Token_Index;
   goto Exit_Row198_0;
end if;
--  BEGIN <DontSkip (root of 'type_decl') at parser.lkt:189:13>
--  pos=Defer_Pos263, res=Defer_Res263, nobt=None
        PP.Dont_Skip.Append (Dontskip_Type_Decl2_Extract_Parse0'Access);
--  BEGIN <Defer (for 'decl_block') at parser.lkt:189:13>
--  pos=Defer_Pos263, res=Defer_Res263, nobt=None
Defer_Res263 :=
   Decl_Block_List_Parse0 (Parser, Row_Pos198);
Defer_Pos263 := Parser.Current_Pos;
--  END <Defer (for 'decl_block') at parser.lkt:189:13>
        PP.Dont_Skip.Delete_Last;
--  END <DontSkip (root of 'type_decl') at parser.lkt:189:13>
Row_Progress48 := 7;
if Defer_Pos263 /= No_Token_Index then
   Row_Pos198 := Defer_Pos263;
else
   Row_Pos198 := No_Token_Index;
   goto Exit_Row198_0;
end if;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:190:13>
--  pos=Token_Pos282, res=Token_Res282, nobt=None
Token_Res282 := Row_Pos198;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res282));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos282 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos198 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos198,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos282 := Row_Pos198 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:190:13>
Row_Progress48 := 8;
if Token_Pos282 /= No_Token_Index then
   Row_Pos198 := Token_Pos282;
else
   Row_Pos198 := No_Token_Index;
   goto Exit_Row198_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row198_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_decl') at parser.lkt:182:11>
if Row_Pos198 = No_Token_Index and then Nobt54 then
   Row_Pos198 := Parser.Last_Fail.Pos;
   Transform_Has_Failed48 := True;
end if;
if Row_Pos198 /= No_Token_Index then
   Transform_Res153 := Allocate_Class_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res153,
      Kind => Lkt_Class_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos198 = Pos
                            then No_Token_Index
                            else Row_Pos198 - 1));
      Initialize_Fields_For_Class_Decl
        (Self => Transform_Res153,
         Basic_Class_Decl_F_Syn_Name => Defer_Res260,
         Basic_Class_Decl_F_Syn_Base_Type => Defer_Res261,
         Basic_Class_Decl_F_Traits => Defer_Res262,
         Class_Decl_F_Decls => Defer_Res263);
         if Defer_Res260 /= null and then Is_Incomplete (Defer_Res260) then
            Transform_Res153.Last_Attempted_Child := 0;
         elsif Defer_Res260 /= null and then not Is_Ghost (Defer_Res260) then
            Transform_Res153.Last_Attempted_Child := -1;
         end if;
         if Defer_Res261 /= null and then Is_Incomplete (Defer_Res261) then
            Transform_Res153.Last_Attempted_Child := 0;
         elsif Defer_Res261 /= null and then not Is_Ghost (Defer_Res261) then
            Transform_Res153.Last_Attempted_Child := -1;
         end if;
         if Defer_Res262 /= null and then Is_Incomplete (Defer_Res262) then
            Transform_Res153.Last_Attempted_Child := 0;
         elsif Defer_Res262 /= null and then not Is_Ghost (Defer_Res262) then
            Transform_Res153.Last_Attempted_Child := -1;
         end if;
         if Defer_Res263 /= null and then Is_Incomplete (Defer_Res263) then
            Transform_Res153.Last_Attempted_Child := 0;
         elsif Defer_Res263 /= null and then not Is_Ghost (Defer_Res263) then
            Transform_Res153.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed48 then
      Transform_Res153.Last_Attempted_Child :=
         Row_Progress48;
      Append (Parser, Pos, "Cannot parse <type_decl>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType ClassDecl>) (root of 'type_decl') at parser.lkt:182:11>
    if Row_Pos198 /= No_Token_Index then
        Or_Pos40 := Row_Pos198;
        Or_Res40 := Transform_Res153;
        goto Exit_Or44;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail40.Pos then
       Branch_Diag_Mark40 := Parser.Last_Diag;
       Branch_Last_Fail40 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark111;
    Parser.Last_Fail := Last_Fail40;
--  BEGIN <Transform(<ASTNodeType EnumTypeDecl>) (root of 'type_decl') at parser.lkt:192:11>
--  pos=Row_Pos201, res=Transform_Res154, nobt=Nobt57
--  BEGIN <_Row (root of 'type_decl') at parser.lkt:192:11>
--  pos=Row_Pos201, res=None, nobt=Nobt57
Row_Pos201 := Pos;
--  BEGIN <Token(<WithText EnumKw>, ) (root of 'type_decl') at parser.lkt:193:13>
--  pos=Token_Pos283, res=Token_Res283, nobt=None
Token_Res283 := Row_Pos201;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res283));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Enum_Kw)
   then
       Token_Pos283 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos201 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos201,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Enum_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos283 := Row_Pos201 + 1;
   end if;
end;
--  END <Token(<WithText EnumKw>, ) (root of 'type_decl') at parser.lkt:193:13>
Row_Progress49 := 1;
if Token_Pos283 /= No_Token_Index then
   Row_Pos201 := Token_Pos283;
else
   Row_Pos201 := No_Token_Index;
   goto Exit_Row201_0;
end if;
--  BEGIN <Cut (root of 'type_decl') at parser.lkt:194:13>
--  pos=Row_Pos201, res=None, nobt=Nobt57
Nobt57 := True;
--  END <Cut (root of 'type_decl') at parser.lkt:194:13>
Row_Progress49 := 2;
if Row_Pos201 /= No_Token_Index then
   Row_Pos201 := Row_Pos201;
else
   Row_Pos201 := No_Token_Index;
   goto Exit_Row201_0;
end if;
--  BEGIN <Defer (for 'def_id') at parser.lkt:195:13>
--  pos=Defer_Pos264, res=Defer_Res264, nobt=None
Defer_Res264 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos201);
Defer_Pos264 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:195:13>
Row_Progress49 := 3;
if Defer_Pos264 /= No_Token_Index then
   Row_Pos201 := Defer_Pos264;
else
   Row_Pos201 := No_Token_Index;
   goto Exit_Row201_0;
end if;
--  BEGIN <Opt (root of 'type_decl') at parser.lkt:196:13>
--  pos=Row_Pos202, res=Defer_Res265, nobt=None
Diag_Mark109 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'type_decl') at parser.lkt:196:14>
--  pos=Row_Pos202, res=Defer_Res265, nobt=None
--  BEGIN <_Row (root of 'type_decl') at parser.lkt:196:14>
--  pos=Row_Pos202, res=None, nobt=None
Row_Pos202 := Row_Pos201;
--  BEGIN <Token(<WithText ImplementsKw>, ) (root of 'type_decl') at parser.lkt:196:19>
--  pos=Token_Pos284, res=Token_Res284, nobt=None
Token_Res284 := Row_Pos202;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res284));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Implements_Kw)
   then
       Token_Pos284 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos202 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos202,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Implements_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos284 := Row_Pos202 + 1;
   end if;
end;
--  END <Token(<WithText ImplementsKw>, ) (root of 'type_decl') at parser.lkt:196:19>
if Token_Pos284 /= No_Token_Index then
   Row_Pos202 := Token_Pos284;
else
   Row_Pos202 := No_Token_Index;
   goto Exit_Row202_0;
end if;
--  BEGIN <Defer (for 'type_list') at parser.lkt:196:32>
--  pos=Defer_Pos265, res=Defer_Res265, nobt=None
Defer_Res265 :=
   Type_List_List_Parse0 (Parser, Row_Pos202);
Defer_Pos265 := Parser.Current_Pos;
--  END <Defer (for 'type_list') at parser.lkt:196:32>
if Defer_Pos265 /= No_Token_Index then
   Row_Pos202 := Defer_Pos265;
else
   Row_Pos202 := No_Token_Index;
   goto Exit_Row202_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row202_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_decl') at parser.lkt:196:14>
--  END <_Extract (root of 'type_decl') at parser.lkt:196:14>
if Row_Pos202 = No_Token_Index then
   Defer_Res265 :=
     Allocate_Type_Ref_List (Parser.Mem_Pool);
   Initialize
     (Self              => Defer_Res265,
      Kind              => Lkt_Type_Ref_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos201,
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Defer_Res265,
      Parser => Parser,
      Count  => 0);
   Row_Pos202 := Row_Pos201;
      Parser.Last_Diag := Diag_Mark109;
end if;
--  END <Opt (root of 'type_decl') at parser.lkt:196:13>
Row_Progress49 := 4;
if Row_Pos202 /= No_Token_Index then
   Row_Pos201 := Row_Pos202;
else
   Row_Pos201 := No_Token_Index;
   goto Exit_Row201_0;
end if;
--  BEGIN <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:197:13>
--  pos=Token_Pos285, res=Token_Res285, nobt=None
Token_Res285 := Row_Pos201;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res285));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos285 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos201 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos201,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos285 := Row_Pos201 + 1;
   end if;
end;
--  END <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:197:13>
Row_Progress49 := 5;
if Token_Pos285 /= No_Token_Index then
   Row_Pos201 := Token_Pos285;
else
   Row_Pos201 := No_Token_Index;
   goto Exit_Row201_0;
end if;
--  BEGIN <Token(<WithText CaseKw>, ) (root of 'type_decl') at parser.lkt:198:13>
--  pos=Token_Pos286, res=Token_Res286, nobt=None
Token_Res286 := Row_Pos201;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res286));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Case_Kw)
   then
       Token_Pos286 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos201 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos201,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Case_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos286 := Row_Pos201 + 1;
   end if;
end;
--  END <Token(<WithText CaseKw>, ) (root of 'type_decl') at parser.lkt:198:13>
Row_Progress49 := 6;
if Token_Pos286 /= No_Token_Index then
   Row_Pos201 := Token_Pos286;
else
   Row_Pos201 := No_Token_Index;
   goto Exit_Row201_0;
end if;
--  BEGIN <List (root of 'type_decl') at parser.lkt:199:13>
--  pos=List_Pos34, res=List_Res34, nobt=None
    List_Pos34 := No_Token_Index;
Lst_Cpos34 := Row_Pos201;
Tmp_List34 := Get_Parse_List (Parser);
Diag_Mark110 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'enum_lit_decl') at parser.lkt:199:19>
--  pos=Defer_Pos266, res=Defer_Res266, nobt=None
Defer_Res266 :=
   Enum_Lit_Decl_Transform_Parse0 (Parser, Lst_Cpos34);
Defer_Pos266 := Parser.Current_Pos;
--  END <Defer (for 'enum_lit_decl') at parser.lkt:199:19>
   exit when Defer_Pos266 = No_Token_Index;
   List_Pos34 := Defer_Pos266;
   Lst_Cpos34 := List_Pos34;
   Diag_Mark110 := Parser.Last_Diag;
   Tmp_List34.Nodes.Append (Defer_Res266);
--  BEGIN <Token(<WithText Comma>, ) (root of 'type_decl') at parser.lkt:199:34>
--  pos=Token_Pos287, res=Token_Res287, nobt=None
Token_Res287 := Lst_Cpos34;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res287));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos287 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Lst_Cpos34 then
          Parser.Last_Fail :=
            (Pos  => Lst_Cpos34,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Comma,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos287 := Lst_Cpos34 + 1;
   end if;
end;
--  END <Token(<WithText Comma>, ) (root of 'type_decl') at parser.lkt:199:34>
      exit when Token_Pos287 = No_Token_Index;
      Lst_Cpos34 := Token_Pos287;
end loop;
Parser.Last_Diag := Diag_Mark110;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List34.Nodes.Length;
begin
   List_Res34 := Allocate_Enum_Lit_Decl_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos201;
      Token_End := (if Lst_Cpos34 = Row_Pos201
                    then Row_Pos201
                    else List_Pos34 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos201, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res34,
      Kind              => Lkt_Enum_Lit_Decl_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res34,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List34.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res34.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List34);
--  END <List (root of 'type_decl') at parser.lkt:199:13>
Row_Progress49 := 7;
if List_Pos34 /= No_Token_Index then
   Row_Pos201 := List_Pos34;
else
   Row_Pos201 := No_Token_Index;
   goto Exit_Row201_0;
end if;
--  BEGIN <DontSkip (root of 'type_decl') at parser.lkt:200:13>
--  pos=Defer_Pos267, res=Defer_Res267, nobt=None
        PP.Dont_Skip.Append (Dontskip_Type_Decl3_Extract_Parse0'Access);
--  BEGIN <Defer (for 'decl_block') at parser.lkt:200:13>
--  pos=Defer_Pos267, res=Defer_Res267, nobt=None
Defer_Res267 :=
   Decl_Block_List_Parse0 (Parser, Row_Pos201);
Defer_Pos267 := Parser.Current_Pos;
--  END <Defer (for 'decl_block') at parser.lkt:200:13>
        PP.Dont_Skip.Delete_Last;
--  END <DontSkip (root of 'type_decl') at parser.lkt:200:13>
Row_Progress49 := 8;
if Defer_Pos267 /= No_Token_Index then
   Row_Pos201 := Defer_Pos267;
else
   Row_Pos201 := No_Token_Index;
   goto Exit_Row201_0;
end if;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:201:13>
--  pos=Token_Pos288, res=Token_Res288, nobt=None
Token_Res288 := Row_Pos201;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res288));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos288 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos201 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos201,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos288 := Row_Pos201 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:201:13>
Row_Progress49 := 9;
if Token_Pos288 /= No_Token_Index then
   Row_Pos201 := Token_Pos288;
else
   Row_Pos201 := No_Token_Index;
   goto Exit_Row201_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row201_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_decl') at parser.lkt:192:11>
if Row_Pos201 = No_Token_Index and then Nobt57 then
   Row_Pos201 := Parser.Last_Fail.Pos;
   Transform_Has_Failed49 := True;
end if;
if Row_Pos201 /= No_Token_Index then
   Transform_Res154 := Allocate_Enum_Type_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res154,
      Kind => Lkt_Enum_Type_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos201 = Pos
                            then No_Token_Index
                            else Row_Pos201 - 1));
      Initialize_Fields_For_Enum_Type_Decl
        (Self => Transform_Res154,
         Enum_Type_Decl_F_Syn_Name => Defer_Res264,
         Enum_Type_Decl_F_Traits => Defer_Res265,
         Enum_Type_Decl_F_Literals => List_Res34,
         Enum_Type_Decl_F_Decls => Defer_Res267);
         if Defer_Res264 /= null and then Is_Incomplete (Defer_Res264) then
            Transform_Res154.Last_Attempted_Child := 0;
         elsif Defer_Res264 /= null and then not Is_Ghost (Defer_Res264) then
            Transform_Res154.Last_Attempted_Child := -1;
         end if;
         if Defer_Res265 /= null and then Is_Incomplete (Defer_Res265) then
            Transform_Res154.Last_Attempted_Child := 0;
         elsif Defer_Res265 /= null and then not Is_Ghost (Defer_Res265) then
            Transform_Res154.Last_Attempted_Child := -1;
         end if;
         if List_Res34 /= null and then Is_Incomplete (List_Res34) then
            Transform_Res154.Last_Attempted_Child := 0;
         elsif List_Res34 /= null and then not Is_Ghost (List_Res34) then
            Transform_Res154.Last_Attempted_Child := -1;
         end if;
         if Defer_Res267 /= null and then Is_Incomplete (Defer_Res267) then
            Transform_Res154.Last_Attempted_Child := 0;
         elsif Defer_Res267 /= null and then not Is_Ghost (Defer_Res267) then
            Transform_Res154.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed49 then
      Transform_Res154.Last_Attempted_Child :=
         Row_Progress49;
      Append (Parser, Pos, "Cannot parse <type_decl>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType EnumTypeDecl>) (root of 'type_decl') at parser.lkt:192:11>
    if Row_Pos201 /= No_Token_Index then
        Or_Pos40 := Row_Pos201;
        Or_Res40 := Transform_Res154;
        goto Exit_Or44;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail40.Pos then
       Branch_Diag_Mark40 := Parser.Last_Diag;
       Branch_Last_Fail40 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark111;
    Parser.Last_Fail := Last_Fail40;
--  BEGIN <Transform(<ASTNodeType TraitDecl>) (root of 'type_decl') at parser.lkt:203:11>
--  pos=Row_Pos203, res=Transform_Res155, nobt=Nobt58
--  BEGIN <_Row (root of 'type_decl') at parser.lkt:203:11>
--  pos=Row_Pos203, res=None, nobt=Nobt58
Row_Pos203 := Pos;
--  BEGIN <Token(<WithText TraitKw>, ) (root of 'type_decl') at parser.lkt:204:13>
--  pos=Token_Pos289, res=Token_Res289, nobt=None
Token_Res289 := Row_Pos203;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res289));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Trait_Kw)
   then
       Token_Pos289 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos203 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos203,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Trait_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos289 := Row_Pos203 + 1;
   end if;
end;
--  END <Token(<WithText TraitKw>, ) (root of 'type_decl') at parser.lkt:204:13>
Row_Progress50 := 1;
if Token_Pos289 /= No_Token_Index then
   Row_Pos203 := Token_Pos289;
else
   Row_Pos203 := No_Token_Index;
   goto Exit_Row203_0;
end if;
--  BEGIN <Cut (root of 'type_decl') at parser.lkt:205:13>
--  pos=Row_Pos203, res=None, nobt=Nobt58
Nobt58 := True;
--  END <Cut (root of 'type_decl') at parser.lkt:205:13>
Row_Progress50 := 2;
if Row_Pos203 /= No_Token_Index then
   Row_Pos203 := Row_Pos203;
else
   Row_Pos203 := No_Token_Index;
   goto Exit_Row203_0;
end if;
--  BEGIN <Defer (for 'def_id') at parser.lkt:206:13>
--  pos=Defer_Pos268, res=Defer_Res268, nobt=None
Defer_Res268 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos203);
Defer_Pos268 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:206:13>
Row_Progress50 := 3;
if Defer_Pos268 /= No_Token_Index then
   Row_Pos203 := Defer_Pos268;
else
   Row_Pos203 := No_Token_Index;
   goto Exit_Row203_0;
end if;
--  BEGIN <Null (root of 'type_decl') at parser.lkt:207:13>
--  pos=Row_Pos203, res=Null_Res22, nobt=None
   Null_Res22 := Allocate_Type_Ref_List (Parser.Mem_Pool);
   Initialize
     (Self              => Null_Res22,
      Kind              => Lkt_Type_Ref_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Index'Max (Row_Pos203, 1),
      Token_End_Index   => No_Token_Index);
   Initialize_List
     (Self   => Null_Res22,
      Parser => Parser,
      Count  => 0);
--  END <Null (root of 'type_decl') at parser.lkt:207:13>
Row_Progress50 := 4;
if Row_Pos203 /= No_Token_Index then
   Row_Pos203 := Row_Pos203;
else
   Row_Pos203 := No_Token_Index;
   goto Exit_Row203_0;
end if;
--  BEGIN <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:208:13>
--  pos=Token_Pos290, res=Token_Res290, nobt=None
Token_Res290 := Row_Pos203;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res290));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brace)
   then
       Token_Pos290 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos203 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos203,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos290 := Row_Pos203 + 1;
   end if;
end;
--  END <Token(<WithText LBrace>, ) (root of 'type_decl') at parser.lkt:208:13>
Row_Progress50 := 5;
if Token_Pos290 /= No_Token_Index then
   Row_Pos203 := Token_Pos290;
else
   Row_Pos203 := No_Token_Index;
   goto Exit_Row203_0;
end if;
--  BEGIN <DontSkip (root of 'type_decl') at parser.lkt:209:13>
--  pos=Defer_Pos269, res=Defer_Res269, nobt=None
        PP.Dont_Skip.Append (Dontskip_Type_Decl4_Extract_Parse0'Access);
--  BEGIN <Defer (for 'decl_block') at parser.lkt:209:13>
--  pos=Defer_Pos269, res=Defer_Res269, nobt=None
Defer_Res269 :=
   Decl_Block_List_Parse0 (Parser, Row_Pos203);
Defer_Pos269 := Parser.Current_Pos;
--  END <Defer (for 'decl_block') at parser.lkt:209:13>
        PP.Dont_Skip.Delete_Last;
--  END <DontSkip (root of 'type_decl') at parser.lkt:209:13>
Row_Progress50 := 6;
if Defer_Pos269 /= No_Token_Index then
   Row_Pos203 := Defer_Pos269;
else
   Row_Pos203 := No_Token_Index;
   goto Exit_Row203_0;
end if;
--  BEGIN <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:210:13>
--  pos=Token_Pos291, res=Token_Res291, nobt=None
Token_Res291 := Row_Pos203;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res291));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brace)
   then
       Token_Pos291 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos203 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos203,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brace,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos291 := Row_Pos203 + 1;
   end if;
end;
--  END <Token(<WithText RBrace>, ) (root of 'type_decl') at parser.lkt:210:13>
Row_Progress50 := 7;
if Token_Pos291 /= No_Token_Index then
   Row_Pos203 := Token_Pos291;
else
   Row_Pos203 := No_Token_Index;
   goto Exit_Row203_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row203_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_decl') at parser.lkt:203:11>
if Row_Pos203 = No_Token_Index and then Nobt58 then
   Row_Pos203 := Parser.Last_Fail.Pos;
   Transform_Has_Failed50 := True;
end if;
if Row_Pos203 /= No_Token_Index then
   Transform_Res155 := Allocate_Trait_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res155,
      Kind => Lkt_Trait_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos203 = Pos
                            then No_Token_Index
                            else Row_Pos203 - 1));
      Initialize_Fields_For_Trait_Decl
        (Self => Transform_Res155,
         Trait_Decl_F_Syn_Name => Defer_Res268,
         Trait_Decl_F_Traits => Null_Res22,
         Trait_Decl_F_Decls => Defer_Res269);
         if Defer_Res268 /= null and then Is_Incomplete (Defer_Res268) then
            Transform_Res155.Last_Attempted_Child := 0;
         elsif Defer_Res268 /= null and then not Is_Ghost (Defer_Res268) then
            Transform_Res155.Last_Attempted_Child := -1;
         end if;
         if Null_Res22 /= null and then Is_Incomplete (Null_Res22) then
            Transform_Res155.Last_Attempted_Child := 0;
         elsif Null_Res22 /= null and then not Is_Ghost (Null_Res22) then
            Transform_Res155.Last_Attempted_Child := -1;
         end if;
         if Defer_Res269 /= null and then Is_Incomplete (Defer_Res269) then
            Transform_Res155.Last_Attempted_Child := 0;
         elsif Defer_Res269 /= null and then not Is_Ghost (Defer_Res269) then
            Transform_Res155.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed50 then
      Transform_Res155.Last_Attempted_Child :=
         Row_Progress50;
      Append (Parser, Pos, "Cannot parse <type_decl>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType TraitDecl>) (root of 'type_decl') at parser.lkt:203:11>
    if Row_Pos203 /= No_Token_Index then
        Or_Pos40 := Row_Pos203;
        Or_Res40 := Transform_Res155;
        goto Exit_Or44;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail40.Pos then
       Branch_Diag_Mark40 := Parser.Last_Diag;
       Branch_Last_Fail40 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark40;
Parser.Last_Fail := Branch_Last_Fail40;
<<Exit_Or44>>
--  END <Or (root of 'type_decl') at parser.lkt:155:18>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos40 = No_Token_Index then
      Set_Failure
        (PP.Type_Decl_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Type_Decl_Or_Parse0_Memo, Pos, Or_Res40, Parser.Last_Diag, Or_Pos40);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos40;
   return Or_Res40;
end Type_Decl_Or_Parse0;
   function Type_Expr_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Expr
is
      Nobt59 : Boolean := False;
      Nobt60 : Boolean := False;
      Row_Pos204 : Token_Index := No_Token_Index;
      Defer_Pos270 : Token_Index := No_Token_Index;
      Defer_Res270 : Bare_Module_Id := No_Bare_Lkt_Node;
      Null_Res23 : Bare_Null_Cond_Qualifier := No_Bare_Lkt_Node;
      Token_Pos292 : Token_Index := No_Token_Index;
      Token_Res292 : Token_Index := No_Token_Index;
      Defer_Pos271 : Token_Index := No_Token_Index;
      Defer_Res271 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Row_Progress51 : Integer := 0;
      Transform_Res156 : Bare_Dot_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed51 : Boolean := False;
      Row_Pos205 : Token_Index := No_Token_Index;
      Defer_Pos272 : Token_Index := No_Token_Index;
      Defer_Res272 : Bare_Expr := No_Bare_Lkt_Node;
      Null_Res24 : Bare_Null_Cond_Qualifier := No_Bare_Lkt_Node;
      Token_Pos293 : Token_Index := No_Token_Index;
      Token_Res293 : Token_Index := No_Token_Index;
      Defer_Pos273 : Token_Index := No_Token_Index;
      Defer_Res273 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Row_Progress52 : Integer := 0;
      Transform_Res157 : Bare_Dot_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed52 : Boolean := False;
      Defer_Pos274 : Token_Index := No_Token_Index;
      Defer_Res274 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Or_Pos41 : Token_Index := No_Token_Index;
      Or_Res41 : Bare_Expr := No_Bare_Lkt_Node;
      Diag_Mark112 : Diagnostic_Mark;
      Last_Fail41 : Fail_Info;
      Branch_Diag_Mark41 : Diagnostic_Mark;
      Branch_Last_Fail41 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
      Mem_Pos  : Token_Index := Pos;
      Mem_Res  : Bare_Expr := No_Bare_Lkt_Node;
      Mem_Mark : Diagnostic_Mark := Mark_On_Entry;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Type_Expr_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res41 := M.Instance;
      return Or_Res41;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res41;
   end if;
   Parser.Last_Diag := No_Diagnostic;
       Set_Failure
         (PP.Type_Expr_Or_Parse0_Memo,
          Pos,
          Parser.Last_Fail,
          Parser.Last_Diag);
       <<Try_Again>>
       Parser.Last_Diag := No_Diagnostic;
      Nobt59 := False;
      Nobt60 := False;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'type_expr') at parser.lkt:275:18>
--  pos=Or_Pos41, res=Or_Res41, nobt=None
Or_Pos41 := No_Token_Index;
Or_Res41 := No_Bare_Lkt_Node;
Diag_Mark112 := Parser.Last_Diag;
Last_Fail41 := Parser.Last_Fail;
Branch_Diag_Mark41 := Parser.Last_Diag;
Branch_Last_Fail41 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark112;
    Parser.Last_Fail := Last_Fail41;
--  BEGIN <Transform(<ASTNodeType DotExpr>) (root of 'type_expr') at parser.lkt:276:11>
--  pos=Row_Pos204, res=Transform_Res156, nobt=Nobt59
--  BEGIN <_Row (root of 'type_expr') at parser.lkt:276:11>
--  pos=Row_Pos204, res=None, nobt=Nobt59
Row_Pos204 := Pos;
--  BEGIN <Defer (for 'module_id') at parser.lkt:276:19>
--  pos=Defer_Pos270, res=Defer_Res270, nobt=None
Defer_Res270 :=
   Module_Id_Predicate_Parse0 (Parser, Row_Pos204);
Defer_Pos270 := Parser.Current_Pos;
--  END <Defer (for 'module_id') at parser.lkt:276:19>
Row_Progress51 := 1;
if Defer_Pos270 /= No_Token_Index then
   Row_Pos204 := Defer_Pos270;
else
   Row_Pos204 := No_Token_Index;
   goto Exit_Row204_0;
end if;
--  BEGIN <Null (root of 'type_expr') at parser.lkt:276:29>
--  pos=Row_Pos204, res=Null_Res23, nobt=None
   Null_Res23 := Allocate_Null_Cond_Qualifier_Absent (Parser.Mem_Pool);
   Initialize
     (Self              => Null_Res23,
      Kind              => Lkt_Null_Cond_Qualifier_Absent,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos204,
      Token_End_Index   => No_Token_Index);
--  END <Null (root of 'type_expr') at parser.lkt:276:29>
Row_Progress51 := 2;
if Row_Pos204 /= No_Token_Index then
   Row_Pos204 := Row_Pos204;
else
   Row_Pos204 := No_Token_Index;
   goto Exit_Row204_0;
end if;
--  BEGIN <Token(<WithText Dot>, ) (root of 'type_expr') at parser.lkt:276:52>
--  pos=Token_Pos292, res=Token_Res292, nobt=None
Token_Res292 := Row_Pos204;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res292));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dot)
   then
       Token_Pos292 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos204 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos204,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Dot,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos292 := Row_Pos204 + 1;
   end if;
end;
--  END <Token(<WithText Dot>, ) (root of 'type_expr') at parser.lkt:276:52>
Row_Progress51 := 3;
if Token_Pos292 /= No_Token_Index then
   Row_Pos204 := Token_Pos292;
else
   Row_Pos204 := No_Token_Index;
   goto Exit_Row204_0;
end if;
--  BEGIN <Cut (root of 'type_expr') at parser.lkt:276:56>
--  pos=Row_Pos204, res=None, nobt=Nobt59
Nobt59 := True;
--  END <Cut (root of 'type_expr') at parser.lkt:276:56>
Row_Progress51 := 4;
if Row_Pos204 /= No_Token_Index then
   Row_Pos204 := Row_Pos204;
else
   Row_Pos204 := No_Token_Index;
   goto Exit_Row204_0;
end if;
--  BEGIN <Defer (for 'type_ref_id') at parser.lkt:276:58>
--  pos=Defer_Pos271, res=Defer_Res271, nobt=None
Defer_Res271 :=
   Type_Ref_Id_Predicate_Parse0 (Parser, Row_Pos204);
Defer_Pos271 := Parser.Current_Pos;
--  END <Defer (for 'type_ref_id') at parser.lkt:276:58>
Row_Progress51 := 5;
if Defer_Pos271 /= No_Token_Index then
   Row_Pos204 := Defer_Pos271;
else
   Row_Pos204 := No_Token_Index;
   goto Exit_Row204_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row204_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_expr') at parser.lkt:276:11>
if Row_Pos204 = No_Token_Index and then Nobt59 then
   Row_Pos204 := Parser.Last_Fail.Pos;
   Transform_Has_Failed51 := True;
end if;
if Row_Pos204 /= No_Token_Index then
   Transform_Res156 := Allocate_Dot_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res156,
      Kind => Lkt_Dot_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos204 = Pos
                            then No_Token_Index
                            else Row_Pos204 - 1));
      Initialize_Fields_For_Dot_Expr
        (Self => Transform_Res156,
         Dot_Expr_F_Prefix => Defer_Res270,
         Dot_Expr_F_Null_Cond => Null_Res23,
         Dot_Expr_F_Suffix => Defer_Res271);
         if Defer_Res270 /= null and then Is_Incomplete (Defer_Res270) then
            Transform_Res156.Last_Attempted_Child := 0;
         elsif Defer_Res270 /= null and then not Is_Ghost (Defer_Res270) then
            Transform_Res156.Last_Attempted_Child := -1;
         end if;
         if Null_Res23 /= null and then Is_Incomplete (Null_Res23) then
            Transform_Res156.Last_Attempted_Child := 0;
         elsif Null_Res23 /= null and then not Is_Ghost (Null_Res23) then
            Transform_Res156.Last_Attempted_Child := -1;
         end if;
         if Defer_Res271 /= null and then Is_Incomplete (Defer_Res271) then
            Transform_Res156.Last_Attempted_Child := 0;
         elsif Defer_Res271 /= null and then not Is_Ghost (Defer_Res271) then
            Transform_Res156.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed51 then
      Transform_Res156.Last_Attempted_Child :=
         Row_Progress51;
      Append (Parser, Pos, "Cannot parse <type_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType DotExpr>) (root of 'type_expr') at parser.lkt:276:11>
    if Row_Pos204 /= No_Token_Index then
        Or_Pos41 := Row_Pos204;
        Or_Res41 := Transform_Res156;
        goto Exit_Or45;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail41.Pos then
       Branch_Diag_Mark41 := Parser.Last_Diag;
       Branch_Last_Fail41 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark112;
    Parser.Last_Fail := Last_Fail41;
--  BEGIN <Transform(<ASTNodeType DotExpr>) (root of 'type_expr') at parser.lkt:277:11>
--  pos=Row_Pos205, res=Transform_Res157, nobt=Nobt60
--  BEGIN <_Row (root of 'type_expr') at parser.lkt:277:11>
--  pos=Row_Pos205, res=None, nobt=Nobt60
Row_Pos205 := Pos;
--  BEGIN <Defer (for 'type_expr') at parser.lkt:277:19>
--  pos=Defer_Pos272, res=Defer_Res272, nobt=None
Defer_Res272 :=
   Type_Expr_Or_Parse0 (Parser, Row_Pos205);
Defer_Pos272 := Parser.Current_Pos;
--  END <Defer (for 'type_expr') at parser.lkt:277:19>
Row_Progress52 := 1;
if Defer_Pos272 /= No_Token_Index then
   Row_Pos205 := Defer_Pos272;
else
   Row_Pos205 := No_Token_Index;
   goto Exit_Row205_0;
end if;
--  BEGIN <Null (root of 'type_expr') at parser.lkt:277:29>
--  pos=Row_Pos205, res=Null_Res24, nobt=None
   Null_Res24 := Allocate_Null_Cond_Qualifier_Absent (Parser.Mem_Pool);
   Initialize
     (Self              => Null_Res24,
      Kind              => Lkt_Null_Cond_Qualifier_Absent,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos205,
      Token_End_Index   => No_Token_Index);
--  END <Null (root of 'type_expr') at parser.lkt:277:29>
Row_Progress52 := 2;
if Row_Pos205 /= No_Token_Index then
   Row_Pos205 := Row_Pos205;
else
   Row_Pos205 := No_Token_Index;
   goto Exit_Row205_0;
end if;
--  BEGIN <Token(<WithText Dot>, ) (root of 'type_expr') at parser.lkt:277:52>
--  pos=Token_Pos293, res=Token_Res293, nobt=None
Token_Res293 := Row_Pos205;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res293));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dot)
   then
       Token_Pos293 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos205 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos205,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Dot,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos293 := Row_Pos205 + 1;
   end if;
end;
--  END <Token(<WithText Dot>, ) (root of 'type_expr') at parser.lkt:277:52>
Row_Progress52 := 3;
if Token_Pos293 /= No_Token_Index then
   Row_Pos205 := Token_Pos293;
else
   Row_Pos205 := No_Token_Index;
   goto Exit_Row205_0;
end if;
--  BEGIN <Cut (root of 'type_expr') at parser.lkt:277:56>
--  pos=Row_Pos205, res=None, nobt=Nobt60
Nobt60 := True;
--  END <Cut (root of 'type_expr') at parser.lkt:277:56>
Row_Progress52 := 4;
if Row_Pos205 /= No_Token_Index then
   Row_Pos205 := Row_Pos205;
else
   Row_Pos205 := No_Token_Index;
   goto Exit_Row205_0;
end if;
--  BEGIN <Defer (for 'type_ref_id') at parser.lkt:277:58>
--  pos=Defer_Pos273, res=Defer_Res273, nobt=None
Defer_Res273 :=
   Type_Ref_Id_Predicate_Parse0 (Parser, Row_Pos205);
Defer_Pos273 := Parser.Current_Pos;
--  END <Defer (for 'type_ref_id') at parser.lkt:277:58>
Row_Progress52 := 5;
if Defer_Pos273 /= No_Token_Index then
   Row_Pos205 := Defer_Pos273;
else
   Row_Pos205 := No_Token_Index;
   goto Exit_Row205_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row205_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_expr') at parser.lkt:277:11>
if Row_Pos205 = No_Token_Index and then Nobt60 then
   Row_Pos205 := Parser.Last_Fail.Pos;
   Transform_Has_Failed52 := True;
end if;
if Row_Pos205 /= No_Token_Index then
   Transform_Res157 := Allocate_Dot_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res157,
      Kind => Lkt_Dot_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos205 = Pos
                            then No_Token_Index
                            else Row_Pos205 - 1));
      Initialize_Fields_For_Dot_Expr
        (Self => Transform_Res157,
         Dot_Expr_F_Prefix => Defer_Res272,
         Dot_Expr_F_Null_Cond => Null_Res24,
         Dot_Expr_F_Suffix => Defer_Res273);
         if Defer_Res272 /= null and then Is_Incomplete (Defer_Res272) then
            Transform_Res157.Last_Attempted_Child := 0;
         elsif Defer_Res272 /= null and then not Is_Ghost (Defer_Res272) then
            Transform_Res157.Last_Attempted_Child := -1;
         end if;
         if Null_Res24 /= null and then Is_Incomplete (Null_Res24) then
            Transform_Res157.Last_Attempted_Child := 0;
         elsif Null_Res24 /= null and then not Is_Ghost (Null_Res24) then
            Transform_Res157.Last_Attempted_Child := -1;
         end if;
         if Defer_Res273 /= null and then Is_Incomplete (Defer_Res273) then
            Transform_Res157.Last_Attempted_Child := 0;
         elsif Defer_Res273 /= null and then not Is_Ghost (Defer_Res273) then
            Transform_Res157.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed52 then
      Transform_Res157.Last_Attempted_Child :=
         Row_Progress52;
      Append (Parser, Pos, "Cannot parse <type_expr>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType DotExpr>) (root of 'type_expr') at parser.lkt:277:11>
    if Row_Pos205 /= No_Token_Index then
        Or_Pos41 := Row_Pos205;
        Or_Res41 := Transform_Res157;
        goto Exit_Or45;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail41.Pos then
       Branch_Diag_Mark41 := Parser.Last_Diag;
       Branch_Last_Fail41 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark112;
    Parser.Last_Fail := Last_Fail41;
--  BEGIN <Defer (for 'type_ref_id') at parser.lkt:278:11>
--  pos=Defer_Pos274, res=Defer_Res274, nobt=None
Defer_Res274 :=
   Type_Ref_Id_Predicate_Parse0 (Parser, Pos);
Defer_Pos274 := Parser.Current_Pos;
--  END <Defer (for 'type_ref_id') at parser.lkt:278:11>
    if Defer_Pos274 /= No_Token_Index then
        Or_Pos41 := Defer_Pos274;
        Or_Res41 := Defer_Res274;
        goto Exit_Or45;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail41.Pos then
       Branch_Diag_Mark41 := Parser.Last_Diag;
       Branch_Last_Fail41 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark41;
Parser.Last_Fail := Branch_Last_Fail41;
<<Exit_Or45>>
--  END <Or (root of 'type_expr') at parser.lkt:275:18>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
      if Or_Pos41 > Mem_Pos then
         Mem_Pos := Or_Pos41;
         Mem_Res := Or_Res41;
         Mem_Mark := Parser.Last_Diag;
         if Or_Pos41 = No_Token_Index then
            Set_Failure (PP.Type_Expr_Or_Parse0_Memo, Pos, Parser.Last_Fail, Mem_Mark);
         else
            Memos.Set_Success
              (PP.Type_Expr_Or_Parse0_Memo,
               Pos,
               Or_Res41,
               Mem_Mark,
               Or_Pos41);
         end if;
         goto Try_Again;
      elsif Mem_Pos > Pos then
         Or_Res41 := Mem_Res;
         Or_Pos41 := Mem_Pos;
         Parser.Last_Diag := Mem_Mark;
         goto No_Memo;
      end if;
   if Or_Pos41 = No_Token_Index then
      Set_Failure
        (PP.Type_Expr_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Type_Expr_Or_Parse0_Memo, Pos, Or_Res41, Parser.Last_Diag, Or_Pos41);
   end if;
       <<No_Memo>>
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos41;
   return Or_Res41;
end Type_Expr_Or_Parse0;
   function Type_List_List_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Type_Ref_List
is
      Lst_Cpos35 : Token_Index := No_Token_Index;
      Tmp_List35 : Free_Parse_List;
      Defer_Pos275 : Token_Index := No_Token_Index;
      Defer_Res275 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Token_Pos294 : Token_Index := No_Token_Index;
      Token_Res294 : Token_Index := No_Token_Index;
      List_Pos35 : Token_Index := No_Token_Index;
      List_Res35 : Bare_Type_Ref_List := No_Bare_Lkt_Node;
      Diag_Mark113 : Diagnostic_Mark;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Type_List_List_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      List_Res35 := M.Instance;
      return List_Res35;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return List_Res35;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <List (root of 'type_list') at parser.lkt:285:18>
--  pos=List_Pos35, res=List_Res35, nobt=None
    List_Pos35 := No_Token_Index;
Lst_Cpos35 := Pos;
Tmp_List35 := Get_Parse_List (Parser);
Diag_Mark113 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'type_ref') at parser.lkt:285:24>
--  pos=Defer_Pos275, res=Defer_Res275, nobt=None
Defer_Res275 :=
   Type_Ref_Or_Parse0 (Parser, Lst_Cpos35);
Defer_Pos275 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:285:24>
   exit when Defer_Pos275 = No_Token_Index;
   List_Pos35 := Defer_Pos275;
   Lst_Cpos35 := List_Pos35;
   Diag_Mark113 := Parser.Last_Diag;
   Tmp_List35.Nodes.Append (Defer_Res275);
--  BEGIN <Token(<WithText Comma>, ) (root of 'type_list') at parser.lkt:285:34>
--  pos=Token_Pos294, res=Token_Res294, nobt=None
Token_Res294 := Lst_Cpos35;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res294));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos294 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Lst_Cpos35 then
          Parser.Last_Fail :=
            (Pos  => Lst_Cpos35,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Comma,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos294 := Lst_Cpos35 + 1;
   end if;
end;
--  END <Token(<WithText Comma>, ) (root of 'type_list') at parser.lkt:285:34>
      exit when Token_Pos294 = No_Token_Index;
      Lst_Cpos35 := Token_Pos294;
end loop;
Parser.Last_Diag := Diag_Mark113;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List35.Nodes.Length;
begin
   List_Res35 := Allocate_Type_Ref_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Pos;
      Token_End := (if Lst_Cpos35 = Pos
                    then Pos
                    else List_Pos35 - 1);
   else
      Token_Start := Token_Index'Max (Pos, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res35,
      Kind              => Lkt_Type_Ref_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res35,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List35.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res35.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List35);
--  END <List (root of 'type_list') at parser.lkt:285:18>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if List_Pos35 = No_Token_Index then
      Set_Failure
        (PP.Type_List_List_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Type_List_List_Parse0_Memo, Pos, List_Res35, Parser.Last_Diag, List_Pos35);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := List_Pos35;
   return List_Res35;
end Type_List_List_Parse0;
   function Type_Member_Ref_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Dot_Expr
is
      Nobt61 : Boolean := False;
      Row_Pos206 : Token_Index := No_Token_Index;
      Defer_Pos276 : Token_Index := No_Token_Index;
      Defer_Res276 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Null_Res25 : Bare_Null_Cond_Qualifier := No_Bare_Lkt_Node;
      Token_Pos295 : Token_Index := No_Token_Index;
      Token_Res295 : Token_Index := No_Token_Index;
      Defer_Pos277 : Token_Index := No_Token_Index;
      Defer_Res277 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Row_Progress53 : Integer := 0;
      Transform_Res158 : Bare_Dot_Expr := No_Bare_Lkt_Node;
      Transform_Has_Failed53 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Type_Member_Ref_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res158 := M.Instance;
      return Transform_Res158;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res158;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType DotExpr>) (root of 'type_member_ref') at parser.lkt:274:24>
--  pos=Row_Pos206, res=Transform_Res158, nobt=Nobt61
--  BEGIN <_Row (root of 'type_member_ref') at parser.lkt:274:24>
--  pos=Row_Pos206, res=None, nobt=Nobt61
Row_Pos206 := Pos;
--  BEGIN <Defer (for 'type_ref_id') at parser.lkt:274:32>
--  pos=Defer_Pos276, res=Defer_Res276, nobt=None
Defer_Res276 :=
   Type_Ref_Id_Predicate_Parse0 (Parser, Row_Pos206);
Defer_Pos276 := Parser.Current_Pos;
--  END <Defer (for 'type_ref_id') at parser.lkt:274:32>
Row_Progress53 := 1;
if Defer_Pos276 /= No_Token_Index then
   Row_Pos206 := Defer_Pos276;
else
   Row_Pos206 := No_Token_Index;
   goto Exit_Row206_0;
end if;
--  BEGIN <Null (root of 'type_member_ref') at parser.lkt:274:44>
--  pos=Row_Pos206, res=Null_Res25, nobt=None
   Null_Res25 := Allocate_Null_Cond_Qualifier_Absent (Parser.Mem_Pool);
   Initialize
     (Self              => Null_Res25,
      Kind              => Lkt_Null_Cond_Qualifier_Absent,
      Unit              => Parser.Unit,
      Token_Start_Index => Row_Pos206,
      Token_End_Index   => No_Token_Index);
--  END <Null (root of 'type_member_ref') at parser.lkt:274:44>
Row_Progress53 := 2;
if Row_Pos206 /= No_Token_Index then
   Row_Pos206 := Row_Pos206;
else
   Row_Pos206 := No_Token_Index;
   goto Exit_Row206_0;
end if;
--  BEGIN <Token(<WithText Dot>, ) (root of 'type_member_ref') at parser.lkt:274:67>
--  pos=Token_Pos295, res=Token_Res295, nobt=None
Token_Res295 := Row_Pos206;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res295));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Dot)
   then
       Token_Pos295 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos206 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos206,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Dot,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos295 := Row_Pos206 + 1;
   end if;
end;
--  END <Token(<WithText Dot>, ) (root of 'type_member_ref') at parser.lkt:274:67>
Row_Progress53 := 3;
if Token_Pos295 /= No_Token_Index then
   Row_Pos206 := Token_Pos295;
else
   Row_Pos206 := No_Token_Index;
   goto Exit_Row206_0;
end if;
--  BEGIN <Cut (root of 'type_member_ref') at parser.lkt:274:71>
--  pos=Row_Pos206, res=None, nobt=Nobt61
Nobt61 := True;
--  END <Cut (root of 'type_member_ref') at parser.lkt:274:71>
Row_Progress53 := 4;
if Row_Pos206 /= No_Token_Index then
   Row_Pos206 := Row_Pos206;
else
   Row_Pos206 := No_Token_Index;
   goto Exit_Row206_0;
end if;
--  BEGIN <Defer (for 'ref_id') at parser.lkt:274:73>
--  pos=Defer_Pos277, res=Defer_Res277, nobt=None
Defer_Res277 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos206);
Defer_Pos277 := Parser.Current_Pos;
--  END <Defer (for 'ref_id') at parser.lkt:274:73>
Row_Progress53 := 5;
if Defer_Pos277 /= No_Token_Index then
   Row_Pos206 := Defer_Pos277;
else
   Row_Pos206 := No_Token_Index;
   goto Exit_Row206_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row206_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_member_ref') at parser.lkt:274:24>
if Row_Pos206 = No_Token_Index and then Nobt61 then
   Row_Pos206 := Parser.Last_Fail.Pos;
   Transform_Has_Failed53 := True;
end if;
if Row_Pos206 /= No_Token_Index then
   Transform_Res158 := Allocate_Dot_Expr (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res158,
      Kind => Lkt_Dot_Expr,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos206 = Pos
                            then No_Token_Index
                            else Row_Pos206 - 1));
      Initialize_Fields_For_Dot_Expr
        (Self => Transform_Res158,
         Dot_Expr_F_Prefix => Defer_Res276,
         Dot_Expr_F_Null_Cond => Null_Res25,
         Dot_Expr_F_Suffix => Defer_Res277);
         if Defer_Res276 /= null and then Is_Incomplete (Defer_Res276) then
            Transform_Res158.Last_Attempted_Child := 0;
         elsif Defer_Res276 /= null and then not Is_Ghost (Defer_Res276) then
            Transform_Res158.Last_Attempted_Child := -1;
         end if;
         if Null_Res25 /= null and then Is_Incomplete (Null_Res25) then
            Transform_Res158.Last_Attempted_Child := 0;
         elsif Null_Res25 /= null and then not Is_Ghost (Null_Res25) then
            Transform_Res158.Last_Attempted_Child := -1;
         end if;
         if Defer_Res277 /= null and then Is_Incomplete (Defer_Res277) then
            Transform_Res158.Last_Attempted_Child := 0;
         elsif Defer_Res277 /= null and then not Is_Ghost (Defer_Res277) then
            Transform_Res158.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed53 then
      Transform_Res158.Last_Attempted_Child :=
         Row_Progress53;
      Append (Parser, Pos, "Cannot parse <type_member_ref>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType DotExpr>) (root of 'type_member_ref') at parser.lkt:274:24>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos206 = No_Token_Index then
      Set_Failure
        (PP.Type_Member_Ref_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Type_Member_Ref_Transform_Parse0_Memo, Pos, Transform_Res158, Parser.Last_Diag, Row_Pos206);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos206;
   return Transform_Res158;
end Type_Member_Ref_Transform_Parse0;
   function Type_Ref_Or_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Type_Ref
is
      Row_Pos207 : Token_Index := No_Token_Index;
      Defer_Pos278 : Token_Index := No_Token_Index;
      Defer_Res278 : Bare_Expr := No_Bare_Lkt_Node;
      Token_Pos296 : Token_Index := No_Token_Index;
      Token_Res296 : Token_Index := No_Token_Index;
      Defer_Pos279 : Token_Index := No_Token_Index;
      Defer_Res279 : Bare_Type_Ref_List := No_Bare_Lkt_Node;
      Token_Pos297 : Token_Index := No_Token_Index;
      Token_Res297 : Token_Index := No_Token_Index;
      Transform_Res159 : Bare_Generic_Type_Ref := No_Bare_Lkt_Node;
      Row_Pos208 : Token_Index := No_Token_Index;
      Defer_Pos280 : Token_Index := No_Token_Index;
      Defer_Res280 : Bare_Expr := No_Bare_Lkt_Node;
      Transform_Res160 : Bare_Simple_Type_Ref := No_Bare_Lkt_Node;
      Row_Pos209 : Token_Index := No_Token_Index;
      Token_Pos298 : Token_Index := No_Token_Index;
      Token_Res298 : Token_Index := No_Token_Index;
      Lst_Cpos36 : Token_Index := No_Token_Index;
      Tmp_List36 : Free_Parse_List;
      Defer_Pos281 : Token_Index := No_Token_Index;
      Defer_Res281 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Token_Pos299 : Token_Index := No_Token_Index;
      Token_Res299 : Token_Index := No_Token_Index;
      List_Pos36 : Token_Index := No_Token_Index;
      List_Res36 : Bare_Type_Ref_List := No_Bare_Lkt_Node;
      Diag_Mark114 : Diagnostic_Mark;
      Token_Pos300 : Token_Index := No_Token_Index;
      Token_Res300 : Token_Index := No_Token_Index;
      Token_Pos301 : Token_Index := No_Token_Index;
      Token_Res301 : Token_Index := No_Token_Index;
      Defer_Pos282 : Token_Index := No_Token_Index;
      Defer_Res282 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Transform_Res161 : Bare_Function_Type_Ref := No_Bare_Lkt_Node;
      Or_Pos42 : Token_Index := No_Token_Index;
      Or_Res42 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Diag_Mark115 : Diagnostic_Mark;
      Last_Fail42 : Fail_Info;
      Branch_Diag_Mark42 : Diagnostic_Mark;
      Branch_Last_Fail42 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Type_Ref_Or_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res42 := M.Instance;
      return Or_Res42;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res42;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'type_ref') at parser.lkt:280:17>
--  pos=Or_Pos42, res=Or_Res42, nobt=None
Or_Pos42 := No_Token_Index;
Or_Res42 := No_Bare_Lkt_Node;
Diag_Mark115 := Parser.Last_Diag;
Last_Fail42 := Parser.Last_Fail;
Branch_Diag_Mark42 := Parser.Last_Diag;
Branch_Last_Fail42 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark115;
    Parser.Last_Fail := Last_Fail42;
--  BEGIN <Transform(<ASTNodeType GenericTypeRef>) (root of 'type_ref') at parser.lkt:281:11>
--  pos=Row_Pos207, res=Transform_Res159, nobt=None
--  BEGIN <_Row (root of 'type_ref') at parser.lkt:281:11>
--  pos=Row_Pos207, res=None, nobt=None
Row_Pos207 := Pos;
--  BEGIN <Defer (for 'type_expr') at parser.lkt:281:26>
--  pos=Defer_Pos278, res=Defer_Res278, nobt=None
Defer_Res278 :=
   Type_Expr_Or_Parse0 (Parser, Row_Pos207);
Defer_Pos278 := Parser.Current_Pos;
--  END <Defer (for 'type_expr') at parser.lkt:281:26>
if Defer_Pos278 /= No_Token_Index then
   Row_Pos207 := Defer_Pos278;
else
   Row_Pos207 := No_Token_Index;
   goto Exit_Row207_0;
end if;
--  BEGIN <Token(<WithText LBrack>, ) (root of 'type_ref') at parser.lkt:281:36>
--  pos=Token_Pos296, res=Token_Res296, nobt=None
Token_Res296 := Row_Pos207;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res296));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Brack)
   then
       Token_Pos296 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos207 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos207,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos296 := Row_Pos207 + 1;
   end if;
end;
--  END <Token(<WithText LBrack>, ) (root of 'type_ref') at parser.lkt:281:36>
if Token_Pos296 /= No_Token_Index then
   Row_Pos207 := Token_Pos296;
else
   Row_Pos207 := No_Token_Index;
   goto Exit_Row207_0;
end if;
--  BEGIN <Defer (for 'type_list') at parser.lkt:281:40>
--  pos=Defer_Pos279, res=Defer_Res279, nobt=None
Defer_Res279 :=
   Type_List_List_Parse0 (Parser, Row_Pos207);
Defer_Pos279 := Parser.Current_Pos;
--  END <Defer (for 'type_list') at parser.lkt:281:40>
if Defer_Pos279 /= No_Token_Index then
   Row_Pos207 := Defer_Pos279;
else
   Row_Pos207 := No_Token_Index;
   goto Exit_Row207_0;
end if;
--  BEGIN <Token(<WithText RBrack>, ) (root of 'type_ref') at parser.lkt:281:50>
--  pos=Token_Pos297, res=Token_Res297, nobt=None
Token_Res297 := Row_Pos207;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res297));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Brack)
   then
       Token_Pos297 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos207 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos207,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Brack,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos297 := Row_Pos207 + 1;
   end if;
end;
--  END <Token(<WithText RBrack>, ) (root of 'type_ref') at parser.lkt:281:50>
if Token_Pos297 /= No_Token_Index then
   Row_Pos207 := Token_Pos297;
else
   Row_Pos207 := No_Token_Index;
   goto Exit_Row207_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row207_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_ref') at parser.lkt:281:11>
if Row_Pos207 /= No_Token_Index then
   Transform_Res159 := Allocate_Generic_Type_Ref (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res159,
      Kind => Lkt_Generic_Type_Ref,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos207 = Pos
                            then No_Token_Index
                            else Row_Pos207 - 1));
      Initialize_Fields_For_Generic_Type_Ref
        (Self => Transform_Res159,
         Generic_Type_Ref_F_Type_Name => Defer_Res278,
         Generic_Type_Ref_F_Args => Defer_Res279);
         if Defer_Res278 /= null and then Is_Incomplete (Defer_Res278) then
            Transform_Res159.Last_Attempted_Child := 0;
         elsif Defer_Res278 /= null and then not Is_Ghost (Defer_Res278) then
            Transform_Res159.Last_Attempted_Child := -1;
         end if;
         if Defer_Res279 /= null and then Is_Incomplete (Defer_Res279) then
            Transform_Res159.Last_Attempted_Child := 0;
         elsif Defer_Res279 /= null and then not Is_Ghost (Defer_Res279) then
            Transform_Res159.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType GenericTypeRef>) (root of 'type_ref') at parser.lkt:281:11>
    if Row_Pos207 /= No_Token_Index then
        Or_Pos42 := Row_Pos207;
        Or_Res42 := Transform_Res159;
        goto Exit_Or46;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail42.Pos then
       Branch_Diag_Mark42 := Parser.Last_Diag;
       Branch_Last_Fail42 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark115;
    Parser.Last_Fail := Last_Fail42;
--  BEGIN <Transform(<ASTNodeType SimpleTypeRef>) (root of 'type_ref') at parser.lkt:282:11>
--  pos=Row_Pos208, res=Transform_Res160, nobt=None
--  BEGIN <_Row (root of 'type_ref') at parser.lkt:282:11>
--  pos=Row_Pos208, res=None, nobt=None
Row_Pos208 := Pos;
--  BEGIN <Defer (for 'type_expr') at parser.lkt:282:25>
--  pos=Defer_Pos280, res=Defer_Res280, nobt=None
Defer_Res280 :=
   Type_Expr_Or_Parse0 (Parser, Row_Pos208);
Defer_Pos280 := Parser.Current_Pos;
--  END <Defer (for 'type_expr') at parser.lkt:282:25>
if Defer_Pos280 /= No_Token_Index then
   Row_Pos208 := Defer_Pos280;
else
   Row_Pos208 := No_Token_Index;
   goto Exit_Row208_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row208_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_ref') at parser.lkt:282:11>
if Row_Pos208 /= No_Token_Index then
   Transform_Res160 := Allocate_Simple_Type_Ref (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res160,
      Kind => Lkt_Simple_Type_Ref,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos208 = Pos
                            then No_Token_Index
                            else Row_Pos208 - 1));
      Initialize_Fields_For_Simple_Type_Ref
        (Self => Transform_Res160,
         Simple_Type_Ref_F_Type_Name => Defer_Res280);
         if Defer_Res280 /= null and then Is_Incomplete (Defer_Res280) then
            Transform_Res160.Last_Attempted_Child := 0;
         elsif Defer_Res280 /= null and then not Is_Ghost (Defer_Res280) then
            Transform_Res160.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType SimpleTypeRef>) (root of 'type_ref') at parser.lkt:282:11>
    if Row_Pos208 /= No_Token_Index then
        Or_Pos42 := Row_Pos208;
        Or_Res42 := Transform_Res160;
        goto Exit_Or46;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail42.Pos then
       Branch_Diag_Mark42 := Parser.Last_Diag;
       Branch_Last_Fail42 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark115;
    Parser.Last_Fail := Last_Fail42;
--  BEGIN <Transform(<ASTNodeType FunctionTypeRef>) (root of 'type_ref') at parser.lkt:283:11>
--  pos=Row_Pos209, res=Transform_Res161, nobt=None
--  BEGIN <_Row (root of 'type_ref') at parser.lkt:283:11>
--  pos=Row_Pos209, res=None, nobt=None
Row_Pos209 := Pos;
--  BEGIN <Token(<WithText LPar>, ) (root of 'type_ref') at parser.lkt:283:27>
--  pos=Token_Pos298, res=Token_Res298, nobt=None
Token_Res298 := Row_Pos209;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res298));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos298 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos209 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos209,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos298 := Row_Pos209 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'type_ref') at parser.lkt:283:27>
if Token_Pos298 /= No_Token_Index then
   Row_Pos209 := Token_Pos298;
else
   Row_Pos209 := No_Token_Index;
   goto Exit_Row209_0;
end if;
--  BEGIN <List (root of 'type_ref') at parser.lkt:283:31>
--  pos=List_Pos36, res=List_Res36, nobt=None
    List_Pos36 := Row_Pos209;
Lst_Cpos36 := Row_Pos209;
Tmp_List36 := Get_Parse_List (Parser);
Diag_Mark114 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'type_ref') at parser.lkt:283:37>
--  pos=Defer_Pos281, res=Defer_Res281, nobt=None
Defer_Res281 :=
   Type_Ref_Or_Parse0 (Parser, Lst_Cpos36);
Defer_Pos281 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:283:37>
   exit when Defer_Pos281 = No_Token_Index;
   List_Pos36 := Defer_Pos281;
   Lst_Cpos36 := List_Pos36;
   Diag_Mark114 := Parser.Last_Diag;
   Tmp_List36.Nodes.Append (Defer_Res281);
--  BEGIN <Token(<WithText Comma>, ) (root of 'type_ref') at parser.lkt:283:47>
--  pos=Token_Pos299, res=Token_Res299, nobt=None
Token_Res299 := Lst_Cpos36;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res299));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos299 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Lst_Cpos36 then
          Parser.Last_Fail :=
            (Pos  => Lst_Cpos36,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Comma,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos299 := Lst_Cpos36 + 1;
   end if;
end;
--  END <Token(<WithText Comma>, ) (root of 'type_ref') at parser.lkt:283:47>
      exit when Token_Pos299 = No_Token_Index;
      Lst_Cpos36 := Token_Pos299;
end loop;
Parser.Last_Diag := Diag_Mark114;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List36.Nodes.Length;
begin
   List_Res36 := Allocate_Type_Ref_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos209;
      Token_End := (if Lst_Cpos36 = Row_Pos209
                    then Row_Pos209
                    else List_Pos36 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos209, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res36,
      Kind              => Lkt_Type_Ref_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res36,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List36.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res36.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List36);
--  END <List (root of 'type_ref') at parser.lkt:283:31>
if List_Pos36 /= No_Token_Index then
   Row_Pos209 := List_Pos36;
else
   Row_Pos209 := No_Token_Index;
   goto Exit_Row209_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'type_ref') at parser.lkt:283:52>
--  pos=Token_Pos300, res=Token_Res300, nobt=None
Token_Res300 := Row_Pos209;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res300));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos300 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos209 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos209,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos300 := Row_Pos209 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'type_ref') at parser.lkt:283:52>
if Token_Pos300 /= No_Token_Index then
   Row_Pos209 := Token_Pos300;
else
   Row_Pos209 := No_Token_Index;
   goto Exit_Row209_0;
end if;
--  BEGIN <Token(<WithText RightArrow>, ) (root of 'type_ref') at parser.lkt:283:56>
--  pos=Token_Pos301, res=Token_Res301, nobt=None
Token_Res301 := Row_Pos209;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res301));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Right_Arrow)
   then
       Token_Pos301 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos209 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos209,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Right_Arrow,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos301 := Row_Pos209 + 1;
   end if;
end;
--  END <Token(<WithText RightArrow>, ) (root of 'type_ref') at parser.lkt:283:56>
if Token_Pos301 /= No_Token_Index then
   Row_Pos209 := Token_Pos301;
else
   Row_Pos209 := No_Token_Index;
   goto Exit_Row209_0;
end if;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:283:61>
--  pos=Defer_Pos282, res=Defer_Res282, nobt=None
Defer_Res282 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos209);
Defer_Pos282 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:283:61>
if Defer_Pos282 /= No_Token_Index then
   Row_Pos209 := Defer_Pos282;
else
   Row_Pos209 := No_Token_Index;
   goto Exit_Row209_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row209_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'type_ref') at parser.lkt:283:11>
if Row_Pos209 /= No_Token_Index then
   Transform_Res161 := Allocate_Function_Type_Ref (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res161,
      Kind => Lkt_Function_Type_Ref,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos209 = Pos
                            then No_Token_Index
                            else Row_Pos209 - 1));
      Initialize_Fields_For_Function_Type_Ref
        (Self => Transform_Res161,
         Function_Type_Ref_F_Param_Types => List_Res36,
         Function_Type_Ref_F_Return_Type => Defer_Res282);
         if List_Res36 /= null and then Is_Incomplete (List_Res36) then
            Transform_Res161.Last_Attempted_Child := 0;
         elsif List_Res36 /= null and then not Is_Ghost (List_Res36) then
            Transform_Res161.Last_Attempted_Child := -1;
         end if;
         if Defer_Res282 /= null and then Is_Incomplete (Defer_Res282) then
            Transform_Res161.Last_Attempted_Child := 0;
         elsif Defer_Res282 /= null and then not Is_Ghost (Defer_Res282) then
            Transform_Res161.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType FunctionTypeRef>) (root of 'type_ref') at parser.lkt:283:11>
    if Row_Pos209 /= No_Token_Index then
        Or_Pos42 := Row_Pos209;
        Or_Res42 := Transform_Res161;
        goto Exit_Or46;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail42.Pos then
       Branch_Diag_Mark42 := Parser.Last_Diag;
       Branch_Last_Fail42 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark42;
Parser.Last_Fail := Branch_Last_Fail42;
<<Exit_Or46>>
--  END <Or (root of 'type_ref') at parser.lkt:280:17>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos42 = No_Token_Index then
      Set_Failure
        (PP.Type_Ref_Or_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Type_Ref_Or_Parse0_Memo, Pos, Or_Res42, Parser.Last_Diag, Or_Pos42);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos42;
   return Or_Res42;
end Type_Ref_Or_Parse0;
   function Type_Ref_Id_Predicate_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Ref_Id
is
      Defer_Pos283 : Token_Index := No_Token_Index;
      Defer_Res283 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Predicate_Pos2 : Token_Index := No_Token_Index;
      Predicate_Res2 : Bare_Ref_Id := No_Bare_Lkt_Node;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Type_Ref_Id_Predicate_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Predicate_Res2 := M.Instance;
      return Predicate_Res2;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Predicate_Res2;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Predicate (root of 'type_ref_id') at parser.lkt:11:20>
--  pos=Predicate_Pos2, res=Predicate_Res2, nobt=None
--  BEGIN <Defer (for 'ref_id') at parser.lkt:11:20>
--  pos=Defer_Pos283, res=Defer_Res283, nobt=None
Defer_Res283 :=
   Ref_Id_Transform_Parse0 (Parser, Pos);
Defer_Pos283 := Parser.Current_Pos;
--  END <Defer (for 'ref_id') at parser.lkt:11:20>
if Defer_Res283 /= null
   and then Liblktlang.Implementation.Extensions.Id_P_Is_Type_Name (Defer_Res283)
then
    Predicate_Res2 := Defer_Res283;
    Predicate_Pos2 := Defer_Pos283;
else
    Predicate_Pos2 := No_Token_Index;
    Predicate_Res2 := null;
    if Parser.Last_Fail.Pos <= Pos then
       Parser.Last_Fail := (Pos  => Pos,
                            Data => (Kind => Predicate_Fail));
    end if;
end if;
--  END <Predicate (root of 'type_ref_id') at parser.lkt:11:20>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Predicate_Pos2 = No_Token_Index then
      Set_Failure
        (PP.Type_Ref_Id_Predicate_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Type_Ref_Id_Predicate_Parse0_Memo, Pos, Predicate_Res2, Parser.Last_Diag, Predicate_Pos2);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Predicate_Pos2;
   return Predicate_Res2;
end Type_Ref_Id_Predicate_Parse0;
   function Val_Decl_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Val_Decl
is
      Nobt62 : Boolean := False;
      Row_Pos210 : Token_Index := No_Token_Index;
      Token_Pos302 : Token_Index := No_Token_Index;
      Token_Res302 : Token_Index := No_Token_Index;
      Defer_Pos284 : Token_Index := No_Token_Index;
      Defer_Res284 : Bare_Def_Id := No_Bare_Lkt_Node;
      Row_Pos211 : Token_Index := No_Token_Index;
      Token_Pos303 : Token_Index := No_Token_Index;
      Token_Res303 : Token_Index := No_Token_Index;
      Defer_Pos285 : Token_Index := No_Token_Index;
      Defer_Res285 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Diag_Mark116 : Diagnostic_Mark;
      Token_Pos304 : Token_Index := No_Token_Index;
      Token_Res304 : Token_Index := No_Token_Index;
      Defer_Pos286 : Token_Index := No_Token_Index;
      Defer_Res286 : Bare_Expr := No_Bare_Lkt_Node;
      Row_Progress54 : Integer := 0;
      Transform_Res162 : Bare_Val_Decl := No_Bare_Lkt_Node;
      Transform_Has_Failed54 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Val_Decl_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res162 := M.Instance;
      return Transform_Res162;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res162;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType ValDecl>) (root of 'val_decl') at parser.lkt:288:17>
--  pos=Row_Pos210, res=Transform_Res162, nobt=Nobt62
--  BEGIN <_Row (root of 'val_decl') at parser.lkt:288:17>
--  pos=Row_Pos210, res=None, nobt=Nobt62
Row_Pos210 := Pos;
--  BEGIN <Token(<WithText ValKw>, ) (root of 'val_decl') at parser.lkt:288:25>
--  pos=Token_Pos302, res=Token_Res302, nobt=None
Token_Res302 := Row_Pos210;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res302));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Val_Kw)
   then
       Token_Pos302 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos210 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos210,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Val_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos302 := Row_Pos210 + 1;
   end if;
end;
--  END <Token(<WithText ValKw>, ) (root of 'val_decl') at parser.lkt:288:25>
Row_Progress54 := 1;
if Token_Pos302 /= No_Token_Index then
   Row_Pos210 := Token_Pos302;
else
   Row_Pos210 := No_Token_Index;
   goto Exit_Row210_0;
end if;
--  BEGIN <Cut (root of 'val_decl') at parser.lkt:288:31>
--  pos=Row_Pos210, res=None, nobt=Nobt62
Nobt62 := True;
--  END <Cut (root of 'val_decl') at parser.lkt:288:31>
Row_Progress54 := 2;
if Row_Pos210 /= No_Token_Index then
   Row_Pos210 := Row_Pos210;
else
   Row_Pos210 := No_Token_Index;
   goto Exit_Row210_0;
end if;
--  BEGIN <Defer (for 'def_id') at parser.lkt:288:33>
--  pos=Defer_Pos284, res=Defer_Res284, nobt=None
Defer_Res284 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos210);
Defer_Pos284 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:288:33>
Row_Progress54 := 3;
if Defer_Pos284 /= No_Token_Index then
   Row_Pos210 := Defer_Pos284;
else
   Row_Pos210 := No_Token_Index;
   goto Exit_Row210_0;
end if;
--  BEGIN <Opt (root of 'val_decl') at parser.lkt:288:40>
--  pos=Row_Pos211, res=Defer_Res285, nobt=None
Diag_Mark116 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'val_decl') at parser.lkt:288:41>
--  pos=Row_Pos211, res=Defer_Res285, nobt=None
--  BEGIN <_Row (root of 'val_decl') at parser.lkt:288:41>
--  pos=Row_Pos211, res=None, nobt=None
Row_Pos211 := Row_Pos210;
--  BEGIN <Token(<WithText Colon>, ) (root of 'val_decl') at parser.lkt:288:46>
--  pos=Token_Pos303, res=Token_Res303, nobt=None
Token_Res303 := Row_Pos211;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res303));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Colon)
   then
       Token_Pos303 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos211 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos211,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Colon,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos303 := Row_Pos211 + 1;
   end if;
end;
--  END <Token(<WithText Colon>, ) (root of 'val_decl') at parser.lkt:288:46>
if Token_Pos303 /= No_Token_Index then
   Row_Pos211 := Token_Pos303;
else
   Row_Pos211 := No_Token_Index;
   goto Exit_Row211_0;
end if;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:288:50>
--  pos=Defer_Pos285, res=Defer_Res285, nobt=None
Defer_Res285 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos211);
Defer_Pos285 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:288:50>
if Defer_Pos285 /= No_Token_Index then
   Row_Pos211 := Defer_Pos285;
else
   Row_Pos211 := No_Token_Index;
   goto Exit_Row211_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row211_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'val_decl') at parser.lkt:288:41>
--  END <_Extract (root of 'val_decl') at parser.lkt:288:41>
if Row_Pos211 = No_Token_Index then
   Defer_Res285 := No_Bare_Lkt_Node;
   Row_Pos211 := Row_Pos210;
      Parser.Last_Diag := Diag_Mark116;
end if;
--  END <Opt (root of 'val_decl') at parser.lkt:288:40>
Row_Progress54 := 4;
if Row_Pos211 /= No_Token_Index then
   Row_Pos210 := Row_Pos211;
else
   Row_Pos210 := No_Token_Index;
   goto Exit_Row210_0;
end if;
--  BEGIN <Token(<WithText Equal>, ) (root of 'val_decl') at parser.lkt:288:60>
--  pos=Token_Pos304, res=Token_Res304, nobt=None
Token_Res304 := Row_Pos210;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res304));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Equal)
   then
       Token_Pos304 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos210 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos210,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Equal,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos304 := Row_Pos210 + 1;
   end if;
end;
--  END <Token(<WithText Equal>, ) (root of 'val_decl') at parser.lkt:288:60>
Row_Progress54 := 5;
if Token_Pos304 /= No_Token_Index then
   Row_Pos210 := Token_Pos304;
else
   Row_Pos210 := No_Token_Index;
   goto Exit_Row210_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:288:64>
--  pos=Defer_Pos286, res=Defer_Res286, nobt=None
Defer_Res286 :=
   Expr_Or_Parse0 (Parser, Row_Pos210);
Defer_Pos286 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:288:64>
Row_Progress54 := 6;
if Defer_Pos286 /= No_Token_Index then
   Row_Pos210 := Defer_Pos286;
else
   Row_Pos210 := No_Token_Index;
   goto Exit_Row210_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row210_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'val_decl') at parser.lkt:288:17>
if Row_Pos210 = No_Token_Index and then Nobt62 then
   Row_Pos210 := Parser.Last_Fail.Pos;
   Transform_Has_Failed54 := True;
end if;
if Row_Pos210 /= No_Token_Index then
   Transform_Res162 := Allocate_Val_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res162,
      Kind => Lkt_Val_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos210 = Pos
                            then No_Token_Index
                            else Row_Pos210 - 1));
      Initialize_Fields_For_Val_Decl
        (Self => Transform_Res162,
         Val_Decl_F_Syn_Name => Defer_Res284,
         Val_Decl_F_Decl_Type => Defer_Res285,
         Val_Decl_F_Expr => Defer_Res286);
         if Defer_Res284 /= null and then Is_Incomplete (Defer_Res284) then
            Transform_Res162.Last_Attempted_Child := 0;
         elsif Defer_Res284 /= null and then not Is_Ghost (Defer_Res284) then
            Transform_Res162.Last_Attempted_Child := -1;
         end if;
         if Defer_Res285 /= null and then Is_Incomplete (Defer_Res285) then
            Transform_Res162.Last_Attempted_Child := 0;
         elsif Defer_Res285 /= null and then not Is_Ghost (Defer_Res285) then
            Transform_Res162.Last_Attempted_Child := -1;
         end if;
         if Defer_Res286 /= null and then Is_Incomplete (Defer_Res286) then
            Transform_Res162.Last_Attempted_Child := 0;
         elsif Defer_Res286 /= null and then not Is_Ghost (Defer_Res286) then
            Transform_Res162.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed54 then
      Transform_Res162.Last_Attempted_Child :=
         Row_Progress54;
      Append (Parser, Pos, "Cannot parse <val_decl>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType ValDecl>) (root of 'val_decl') at parser.lkt:288:17>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos210 = No_Token_Index then
      Set_Failure
        (PP.Val_Decl_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Val_Decl_Transform_Parse0_Memo, Pos, Transform_Res162, Parser.Last_Diag, Row_Pos210);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos210;
   return Transform_Res162;
end Val_Decl_Transform_Parse0;
   function Value_Pattern_Or_Parse1
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Pattern
is
      Nobt63 : Boolean := False;
      Row_Pos212 : Token_Index := No_Token_Index;
      Row_Pos213 : Token_Index := No_Token_Index;
      Token_Pos305 : Token_Index := No_Token_Index;
      Token_Res305 : Token_Index := No_Token_Index;
      Transform_Res163 : Bare_Any_Type_Pattern := No_Bare_Lkt_Node;
      Row_Pos214 : Token_Index := No_Token_Index;
      Defer_Pos287 : Token_Index := No_Token_Index;
      Defer_Res287 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Transform_Res164 : Bare_Type_Pattern := No_Bare_Lkt_Node;
      Row_Pos215 : Token_Index := No_Token_Index;
      Token_Pos306 : Token_Index := No_Token_Index;
      Token_Res306 : Token_Index := No_Token_Index;
      Defer_Pos288 : Token_Index := No_Token_Index;
      Defer_Res288 : Bare_Pattern := No_Bare_Lkt_Node;
      Token_Pos307 : Token_Index := No_Token_Index;
      Token_Res307 : Token_Index := No_Token_Index;
      Transform_Res165 : Bare_Paren_Pattern := No_Bare_Lkt_Node;
      Or_Pos43 : Token_Index := No_Token_Index;
      Or_Res43 : Bare_Pattern := No_Bare_Lkt_Node;
      Diag_Mark117 : Diagnostic_Mark;
      Last_Fail43 : Fail_Info;
      Branch_Diag_Mark43 : Diagnostic_Mark;
      Branch_Last_Fail43 : Fail_Info;
      Row_Pos216 : Token_Index := No_Token_Index;
      Token_Pos308 : Token_Index := No_Token_Index;
      Token_Res308 : Token_Index := No_Token_Index;
      Lst_Cpos37 : Token_Index := No_Token_Index;
      Tmp_List37 : Free_Parse_List;
      Defer_Pos289 : Token_Index := No_Token_Index;
      Defer_Res289 : Bare_Pattern_Detail := No_Bare_Lkt_Node;
      Token_Pos309 : Token_Index := No_Token_Index;
      Token_Res309 : Token_Index := No_Token_Index;
      List_Pos37 : Token_Index := No_Token_Index;
      List_Res37 : Bare_Pattern_Detail_List := No_Bare_Lkt_Node;
      Diag_Mark118 : Diagnostic_Mark;
      Token_Pos310 : Token_Index := No_Token_Index;
      Token_Res310 : Token_Index := No_Token_Index;
      Row_Progress55 : Integer := 0;
      Transform_Res166 : Bare_Extended_Pattern := No_Bare_Lkt_Node;
      Transform_Has_Failed55 : Boolean := False;
      Row_Pos217 : Token_Index := No_Token_Index;
      Defer_Pos290 : Token_Index := No_Token_Index;
      Defer_Res290 : Bare_Type_Ref := No_Bare_Lkt_Node;
      Transform_Res167 : Bare_Type_Pattern := No_Bare_Lkt_Node;
      Row_Pos218 : Token_Index := No_Token_Index;
      Token_Pos311 : Token_Index := No_Token_Index;
      Token_Res311 : Token_Index := No_Token_Index;
      Transform_Res168 : Bare_Null_Pattern := No_Bare_Lkt_Node;
      Defer_Pos291 : Token_Index := No_Token_Index;
      Defer_Res291 : Bare_Regex_Pattern := No_Bare_Lkt_Node;
      Row_Pos219 : Token_Index := No_Token_Index;
      Token_Pos312 : Token_Index := No_Token_Index;
      Token_Res312 : Token_Index := No_Token_Index;
      Defer_Pos292 : Token_Index := No_Token_Index;
      Defer_Res292 : Bare_Pattern := No_Bare_Lkt_Node;
      Transform_Res169 : Bare_Not_Pattern := No_Bare_Lkt_Node;
      Defer_Pos293 : Token_Index := No_Token_Index;
      Defer_Res293 : Bare_Bool_Pattern := No_Bare_Lkt_Node;
      Defer_Pos294 : Token_Index := No_Token_Index;
      Defer_Res294 : Bare_Integer_Pattern := No_Bare_Lkt_Node;
      Defer_Pos295 : Token_Index := No_Token_Index;
      Defer_Res295 : Bare_List_Pattern := No_Bare_Lkt_Node;
      Row_Pos220 : Token_Index := No_Token_Index;
      Row_Pos221 : Token_Index := No_Token_Index;
      Defer_Pos296 : Token_Index := No_Token_Index;
      Defer_Res296 : Bare_Def_Id := No_Bare_Lkt_Node;
      Transform_Res170 : Bare_Binding_Val_Decl := No_Bare_Lkt_Node;
      Row_Pos222 : Token_Index := No_Token_Index;
      Token_Pos313 : Token_Index := No_Token_Index;
      Token_Res313 : Token_Index := No_Token_Index;
      Defer_Pos297 : Token_Index := No_Token_Index;
      Defer_Res297 : Bare_Pattern := No_Bare_Lkt_Node;
      Diag_Mark119 : Diagnostic_Mark;
      Transform_Res171 : Bare_Binding_Pattern := No_Bare_Lkt_Node;
      Row_Pos223 : Token_Index := No_Token_Index;
      Token_Pos314 : Token_Index := No_Token_Index;
      Token_Res314 : Token_Index := No_Token_Index;
      Defer_Pos298 : Token_Index := No_Token_Index;
      Defer_Res298 : Bare_Pattern := No_Bare_Lkt_Node;
      Token_Pos315 : Token_Index := No_Token_Index;
      Token_Res315 : Token_Index := No_Token_Index;
      Transform_Res172 : Bare_Paren_Pattern := No_Bare_Lkt_Node;
      Defer_Pos299 : Token_Index := No_Token_Index;
      Defer_Res299 : Bare_Tuple_Pattern := No_Bare_Lkt_Node;
      Or_Pos44 : Token_Index := No_Token_Index;
      Or_Res44 : Bare_Pattern := No_Bare_Lkt_Node;
      Diag_Mark120 : Diagnostic_Mark;
      Last_Fail44 : Fail_Info;
      Branch_Diag_Mark44 : Diagnostic_Mark;
      Branch_Last_Fail44 : Fail_Info;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Value_Pattern_Or_Parse1_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Or_Res44 := M.Instance;
      return Or_Res44;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Or_Res44;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Or (root of 'value_pattern') at parser.lkt:312:22>
--  pos=Or_Pos44, res=Or_Res44, nobt=None
Or_Pos44 := No_Token_Index;
Or_Res44 := No_Bare_Lkt_Node;
Diag_Mark120 := Parser.Last_Diag;
Last_Fail44 := Parser.Last_Fail;
Branch_Diag_Mark44 := Parser.Last_Diag;
Branch_Last_Fail44 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark120;
    Parser.Last_Fail := Last_Fail44;
--  BEGIN <Transform(<ASTNodeType ExtendedPattern>) (root of 'value_pattern') at parser.lkt:313:11>
--  pos=Row_Pos212, res=Transform_Res166, nobt=Nobt63
--  BEGIN <_Row (root of 'value_pattern') at parser.lkt:313:11>
--  pos=Row_Pos212, res=None, nobt=Nobt63
Row_Pos212 := Pos;
--  BEGIN <Or (root of 'value_pattern') at parser.lkt:314:13>
--  pos=Or_Pos43, res=Or_Res43, nobt=None
Or_Pos43 := No_Token_Index;
Or_Res43 := No_Bare_Lkt_Node;
Diag_Mark117 := Parser.Last_Diag;
Last_Fail43 := Parser.Last_Fail;
Branch_Diag_Mark43 := Parser.Last_Diag;
Branch_Last_Fail43 := Parser.Last_Fail;
    Parser.Last_Diag := Diag_Mark117;
    Parser.Last_Fail := Last_Fail43;
--  BEGIN <Transform(<ASTNodeType AnyTypePattern>) (root of 'value_pattern') at parser.lkt:315:19>
--  pos=Row_Pos213, res=Transform_Res163, nobt=None
--  BEGIN <_Row (root of 'value_pattern') at parser.lkt:315:19>
--  pos=Row_Pos213, res=None, nobt=None
Row_Pos213 := Row_Pos212;
--  BEGIN <Token(<WithText Times>, ) (root of 'value_pattern') at parser.lkt:315:34>
--  pos=Token_Pos305, res=Token_Res305, nobt=None
Token_Res305 := Row_Pos213;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res305));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Times)
   then
       Token_Pos305 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos213 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos213,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Times,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos305 := Row_Pos213 + 1;
   end if;
end;
--  END <Token(<WithText Times>, ) (root of 'value_pattern') at parser.lkt:315:34>
if Token_Pos305 /= No_Token_Index then
   Row_Pos213 := Token_Pos305;
else
   Row_Pos213 := No_Token_Index;
   goto Exit_Row213_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row213_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'value_pattern') at parser.lkt:315:19>
if Row_Pos213 /= No_Token_Index then
   Transform_Res163 := Allocate_Any_Type_Pattern (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res163,
      Kind => Lkt_Any_Type_Pattern,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos212,
      Token_End_Index   => (if Row_Pos213 = Row_Pos212
                            then No_Token_Index
                            else Row_Pos213 - 1));
end if;
--  END <Transform(<ASTNodeType AnyTypePattern>) (root of 'value_pattern') at parser.lkt:315:19>
    if Row_Pos213 /= No_Token_Index then
        Or_Pos43 := Row_Pos213;
        Or_Res43 := Transform_Res163;
        goto Exit_Or48;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail43.Pos then
       Branch_Diag_Mark43 := Parser.Last_Diag;
       Branch_Last_Fail43 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark117;
    Parser.Last_Fail := Last_Fail43;
--  BEGIN <Transform(<ASTNodeType TypePattern>) (root of 'value_pattern') at parser.lkt:316:19>
--  pos=Row_Pos214, res=Transform_Res164, nobt=None
--  BEGIN <_Row (root of 'value_pattern') at parser.lkt:316:19>
--  pos=Row_Pos214, res=None, nobt=None
Row_Pos214 := Row_Pos212;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:316:31>
--  pos=Defer_Pos287, res=Defer_Res287, nobt=None
Defer_Res287 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos214);
Defer_Pos287 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:316:31>
if Defer_Pos287 /= No_Token_Index then
   Row_Pos214 := Defer_Pos287;
else
   Row_Pos214 := No_Token_Index;
   goto Exit_Row214_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row214_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'value_pattern') at parser.lkt:316:19>
if Row_Pos214 /= No_Token_Index then
   Transform_Res164 := Allocate_Type_Pattern (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res164,
      Kind => Lkt_Type_Pattern,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos212,
      Token_End_Index   => (if Row_Pos214 = Row_Pos212
                            then No_Token_Index
                            else Row_Pos214 - 1));
      Initialize_Fields_For_Type_Pattern
        (Self => Transform_Res164,
         Type_Pattern_F_Type_Name => Defer_Res287);
         if Defer_Res287 /= null and then Is_Incomplete (Defer_Res287) then
            Transform_Res164.Last_Attempted_Child := 0;
         elsif Defer_Res287 /= null and then not Is_Ghost (Defer_Res287) then
            Transform_Res164.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType TypePattern>) (root of 'value_pattern') at parser.lkt:316:19>
    if Row_Pos214 /= No_Token_Index then
        Or_Pos43 := Row_Pos214;
        Or_Res43 := Transform_Res164;
        goto Exit_Or48;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail43.Pos then
       Branch_Diag_Mark43 := Parser.Last_Diag;
       Branch_Last_Fail43 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark117;
    Parser.Last_Fail := Last_Fail43;
--  BEGIN <Transform(<ASTNodeType ParenPattern>) (root of 'value_pattern') at parser.lkt:317:19>
--  pos=Row_Pos215, res=Transform_Res165, nobt=None
--  BEGIN <_Row (root of 'value_pattern') at parser.lkt:317:19>
--  pos=Row_Pos215, res=None, nobt=None
Row_Pos215 := Row_Pos212;
--  BEGIN <Token(<WithText LPar>, ) (root of 'value_pattern') at parser.lkt:317:32>
--  pos=Token_Pos306, res=Token_Res306, nobt=None
Token_Res306 := Row_Pos215;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res306));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos306 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos215 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos215,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos306 := Row_Pos215 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'value_pattern') at parser.lkt:317:32>
if Token_Pos306 /= No_Token_Index then
   Row_Pos215 := Token_Pos306;
else
   Row_Pos215 := No_Token_Index;
   goto Exit_Row215_0;
end if;
--  BEGIN <Defer (for 'pattern') at parser.lkt:317:36>
--  pos=Defer_Pos288, res=Defer_Res288, nobt=None
Defer_Res288 :=
   Pattern_Or_Parse0 (Parser, Row_Pos215);
Defer_Pos288 := Parser.Current_Pos;
--  END <Defer (for 'pattern') at parser.lkt:317:36>
if Defer_Pos288 /= No_Token_Index then
   Row_Pos215 := Defer_Pos288;
else
   Row_Pos215 := No_Token_Index;
   goto Exit_Row215_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'value_pattern') at parser.lkt:317:44>
--  pos=Token_Pos307, res=Token_Res307, nobt=None
Token_Res307 := Row_Pos215;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res307));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos307 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos215 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos215,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos307 := Row_Pos215 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'value_pattern') at parser.lkt:317:44>
if Token_Pos307 /= No_Token_Index then
   Row_Pos215 := Token_Pos307;
else
   Row_Pos215 := No_Token_Index;
   goto Exit_Row215_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row215_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'value_pattern') at parser.lkt:317:19>
if Row_Pos215 /= No_Token_Index then
   Transform_Res165 := Allocate_Paren_Pattern (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res165,
      Kind => Lkt_Paren_Pattern,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos212,
      Token_End_Index   => (if Row_Pos215 = Row_Pos212
                            then No_Token_Index
                            else Row_Pos215 - 1));
      Initialize_Fields_For_Paren_Pattern
        (Self => Transform_Res165,
         Paren_Pattern_F_Sub_Pattern => Defer_Res288);
         if Defer_Res288 /= null and then Is_Incomplete (Defer_Res288) then
            Transform_Res165.Last_Attempted_Child := 0;
         elsif Defer_Res288 /= null and then not Is_Ghost (Defer_Res288) then
            Transform_Res165.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType ParenPattern>) (root of 'value_pattern') at parser.lkt:317:19>
    if Row_Pos215 /= No_Token_Index then
        Or_Pos43 := Row_Pos215;
        Or_Res43 := Transform_Res165;
        goto Exit_Or48;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail43.Pos then
       Branch_Diag_Mark43 := Parser.Last_Diag;
       Branch_Last_Fail43 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark43;
Parser.Last_Fail := Branch_Last_Fail43;
<<Exit_Or48>>
--  END <Or (root of 'value_pattern') at parser.lkt:314:13>
Row_Progress55 := 1;
if Or_Pos43 /= No_Token_Index then
   Row_Pos212 := Or_Pos43;
else
   Row_Pos212 := No_Token_Index;
   goto Exit_Row212_0;
end if;
--  BEGIN <_Extract (root of 'value_pattern') at parser.lkt:319:13>
--  pos=Row_Pos216, res=List_Res37, nobt=Nobt63
--  BEGIN <_Row (root of 'value_pattern') at parser.lkt:319:13>
--  pos=Row_Pos216, res=None, nobt=Nobt63
Row_Pos216 := Row_Pos212;
--  BEGIN <Token(<WithText LPar>, ) (root of 'value_pattern') at parser.lkt:319:18>
--  pos=Token_Pos308, res=Token_Res308, nobt=None
Token_Res308 := Row_Pos216;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res308));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos308 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos216 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos216,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos308 := Row_Pos216 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'value_pattern') at parser.lkt:319:18>
if Token_Pos308 /= No_Token_Index then
   Row_Pos216 := Token_Pos308;
else
   Row_Pos216 := No_Token_Index;
   goto Exit_Row216_0;
end if;
--  BEGIN <Cut (root of 'value_pattern') at parser.lkt:319:22>
--  pos=Row_Pos216, res=None, nobt=Nobt63
Nobt63 := True;
--  END <Cut (root of 'value_pattern') at parser.lkt:319:22>
if Row_Pos216 /= No_Token_Index then
   Row_Pos216 := Row_Pos216;
else
   Row_Pos216 := No_Token_Index;
   goto Exit_Row216_0;
end if;
--  BEGIN <List (root of 'value_pattern') at parser.lkt:319:24>
--  pos=List_Pos37, res=List_Res37, nobt=None
    List_Pos37 := No_Token_Index;
Lst_Cpos37 := Row_Pos216;
Tmp_List37 := Get_Parse_List (Parser);
Diag_Mark118 := Parser.Last_Diag;
loop
--  BEGIN <Defer (for 'pattern_arg') at parser.lkt:319:30>
--  pos=Defer_Pos289, res=Defer_Res289, nobt=None
Defer_Res289 :=
   Pattern_Arg_Or_Parse0 (Parser, Lst_Cpos37);
Defer_Pos289 := Parser.Current_Pos;
--  END <Defer (for 'pattern_arg') at parser.lkt:319:30>
   exit when Defer_Pos289 = No_Token_Index;
   List_Pos37 := Defer_Pos289;
   Lst_Cpos37 := List_Pos37;
   Diag_Mark118 := Parser.Last_Diag;
   Tmp_List37.Nodes.Append (Defer_Res289);
--  BEGIN <Token(<WithText Comma>, ) (root of 'value_pattern') at parser.lkt:319:43>
--  pos=Token_Pos309, res=Token_Res309, nobt=None
Token_Res309 := Lst_Cpos37;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res309));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Comma)
   then
       Token_Pos309 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Lst_Cpos37 then
          Parser.Last_Fail :=
            (Pos  => Lst_Cpos37,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Comma,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos309 := Lst_Cpos37 + 1;
   end if;
end;
--  END <Token(<WithText Comma>, ) (root of 'value_pattern') at parser.lkt:319:43>
      exit when Token_Pos309 = No_Token_Index;
      Lst_Cpos37 := Token_Pos309;
end loop;
Parser.Last_Diag := Diag_Mark118;
declare
   Token_Start, Token_End : Token_Index;
   Count                  : constant Natural := Tmp_List37.Nodes.Length;
begin
   List_Res37 := Allocate_Pattern_Detail_List (Parser.Mem_Pool);
   if Count > 0 then
      Token_Start := Row_Pos216;
      Token_End := (if Lst_Cpos37 = Row_Pos216
                    then Row_Pos216
                    else List_Pos37 - 1);
   else
      Token_Start := Token_Index'Max (Row_Pos216, 1);
      Token_End := No_Token_Index;
   end if;
   Initialize
     (Self              => List_Res37,
      Kind              => Lkt_Pattern_Detail_List,
      Unit              => Parser.Unit,
      Token_Start_Index => Token_Start,
      Token_End_Index   => Token_End);
   Initialize_List
     (Self   => List_Res37,
      Parser => Parser,
      Count  => Count);
   declare
      Vec : Bare_Lkt_Node_Vectors.Vector renames
         Tmp_List37.Nodes;
      Arr : Alloc_AST_List_Array.Element_Array_Access renames
         List_Res37.Nodes;
   begin
      Arr := Alloc_AST_List_Array.Alloc (Parser.Mem_Pool, Vec.Length);
      for I in Vec.First_Index .. Vec.Last_Index loop
         Arr (I) := Vec.Get (I);
      end loop;
   end;
end;
Release_Parse_List (Parser, Tmp_List37);
--  END <List (root of 'value_pattern') at parser.lkt:319:24>
if List_Pos37 /= No_Token_Index then
   Row_Pos216 := List_Pos37;
else
   Row_Pos216 := No_Token_Index;
   goto Exit_Row216_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'value_pattern') at parser.lkt:319:48>
--  pos=Token_Pos310, res=Token_Res310, nobt=None
Token_Res310 := Row_Pos216;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res310));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos310 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos216 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos216,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos310 := Row_Pos216 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'value_pattern') at parser.lkt:319:48>
if Token_Pos310 /= No_Token_Index then
   Row_Pos216 := Token_Pos310;
else
   Row_Pos216 := No_Token_Index;
   goto Exit_Row216_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row216_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'value_pattern') at parser.lkt:319:13>
--  END <_Extract (root of 'value_pattern') at parser.lkt:319:13>
Row_Progress55 := 2;
if Row_Pos216 /= No_Token_Index then
   Row_Pos212 := Row_Pos216;
else
   Row_Pos212 := No_Token_Index;
   goto Exit_Row212_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row212_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'value_pattern') at parser.lkt:313:11>
if Row_Pos212 = No_Token_Index and then Nobt63 then
   Row_Pos212 := Parser.Last_Fail.Pos;
   Transform_Has_Failed55 := True;
end if;
if Row_Pos212 /= No_Token_Index then
   Transform_Res166 := Allocate_Extended_Pattern (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res166,
      Kind => Lkt_Extended_Pattern,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos212 = Pos
                            then No_Token_Index
                            else Row_Pos212 - 1));
      Initialize_Fields_For_Extended_Pattern
        (Self => Transform_Res166,
         Extended_Pattern_F_Sub_Pattern => Or_Res43,
         Extended_Pattern_F_Details => List_Res37);
         if Or_Res43 /= null and then Is_Incomplete (Or_Res43) then
            Transform_Res166.Last_Attempted_Child := 0;
         elsif Or_Res43 /= null and then not Is_Ghost (Or_Res43) then
            Transform_Res166.Last_Attempted_Child := -1;
         end if;
         if List_Res37 /= null and then Is_Incomplete (List_Res37) then
            Transform_Res166.Last_Attempted_Child := 0;
         elsif List_Res37 /= null and then not Is_Ghost (List_Res37) then
            Transform_Res166.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed55 then
      Transform_Res166.Last_Attempted_Child :=
         Row_Progress55;
      Append (Parser, Pos, "Cannot parse <value_pattern>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType ExtendedPattern>) (root of 'value_pattern') at parser.lkt:313:11>
    if Row_Pos212 /= No_Token_Index then
        Or_Pos44 := Row_Pos212;
        Or_Res44 := Transform_Res166;
        goto Exit_Or47;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail44.Pos then
       Branch_Diag_Mark44 := Parser.Last_Diag;
       Branch_Last_Fail44 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark120;
    Parser.Last_Fail := Last_Fail44;
--  BEGIN <Transform(<ASTNodeType TypePattern>) (root of 'value_pattern') at parser.lkt:321:11>
--  pos=Row_Pos217, res=Transform_Res167, nobt=None
--  BEGIN <_Row (root of 'value_pattern') at parser.lkt:321:11>
--  pos=Row_Pos217, res=None, nobt=None
Row_Pos217 := Pos;
--  BEGIN <Defer (for 'type_ref') at parser.lkt:321:23>
--  pos=Defer_Pos290, res=Defer_Res290, nobt=None
Defer_Res290 :=
   Type_Ref_Or_Parse0 (Parser, Row_Pos217);
Defer_Pos290 := Parser.Current_Pos;
--  END <Defer (for 'type_ref') at parser.lkt:321:23>
if Defer_Pos290 /= No_Token_Index then
   Row_Pos217 := Defer_Pos290;
else
   Row_Pos217 := No_Token_Index;
   goto Exit_Row217_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row217_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'value_pattern') at parser.lkt:321:11>
if Row_Pos217 /= No_Token_Index then
   Transform_Res167 := Allocate_Type_Pattern (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res167,
      Kind => Lkt_Type_Pattern,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos217 = Pos
                            then No_Token_Index
                            else Row_Pos217 - 1));
      Initialize_Fields_For_Type_Pattern
        (Self => Transform_Res167,
         Type_Pattern_F_Type_Name => Defer_Res290);
         if Defer_Res290 /= null and then Is_Incomplete (Defer_Res290) then
            Transform_Res167.Last_Attempted_Child := 0;
         elsif Defer_Res290 /= null and then not Is_Ghost (Defer_Res290) then
            Transform_Res167.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType TypePattern>) (root of 'value_pattern') at parser.lkt:321:11>
    if Row_Pos217 /= No_Token_Index then
        Or_Pos44 := Row_Pos217;
        Or_Res44 := Transform_Res167;
        goto Exit_Or47;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail44.Pos then
       Branch_Diag_Mark44 := Parser.Last_Diag;
       Branch_Last_Fail44 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark120;
    Parser.Last_Fail := Last_Fail44;
--  BEGIN <Transform(<ASTNodeType NullPattern>) (root of 'value_pattern') at parser.lkt:322:11>
--  pos=Row_Pos218, res=Transform_Res168, nobt=None
--  BEGIN <_Row (root of 'value_pattern') at parser.lkt:322:11>
--  pos=Row_Pos218, res=None, nobt=None
Row_Pos218 := Pos;
--  BEGIN <Token(<WithText NullKw>, ) (root of 'value_pattern') at parser.lkt:322:23>
--  pos=Token_Pos311, res=Token_Res311, nobt=None
Token_Res311 := Row_Pos218;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res311));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Null_Kw)
   then
       Token_Pos311 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos218 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos218,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Null_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos311 := Row_Pos218 + 1;
   end if;
end;
--  END <Token(<WithText NullKw>, ) (root of 'value_pattern') at parser.lkt:322:23>
if Token_Pos311 /= No_Token_Index then
   Row_Pos218 := Token_Pos311;
else
   Row_Pos218 := No_Token_Index;
   goto Exit_Row218_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row218_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'value_pattern') at parser.lkt:322:11>
if Row_Pos218 /= No_Token_Index then
   Transform_Res168 := Allocate_Null_Pattern (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res168,
      Kind => Lkt_Null_Pattern,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos218 = Pos
                            then No_Token_Index
                            else Row_Pos218 - 1));
end if;
--  END <Transform(<ASTNodeType NullPattern>) (root of 'value_pattern') at parser.lkt:322:11>
    if Row_Pos218 /= No_Token_Index then
        Or_Pos44 := Row_Pos218;
        Or_Res44 := Transform_Res168;
        goto Exit_Or47;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail44.Pos then
       Branch_Diag_Mark44 := Parser.Last_Diag;
       Branch_Last_Fail44 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark120;
    Parser.Last_Fail := Last_Fail44;
--  BEGIN <Defer (for 'regex_pattern') at parser.lkt:323:11>
--  pos=Defer_Pos291, res=Defer_Res291, nobt=None
Defer_Res291 :=
   Regex_Pattern_Transform_Parse0 (Parser, Pos);
Defer_Pos291 := Parser.Current_Pos;
--  END <Defer (for 'regex_pattern') at parser.lkt:323:11>
    if Defer_Pos291 /= No_Token_Index then
        Or_Pos44 := Defer_Pos291;
        Or_Res44 := Defer_Res291;
        goto Exit_Or47;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail44.Pos then
       Branch_Diag_Mark44 := Parser.Last_Diag;
       Branch_Last_Fail44 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark120;
    Parser.Last_Fail := Last_Fail44;
--  BEGIN <Transform(<ASTNodeType NotPattern>) (root of 'value_pattern') at parser.lkt:324:11>
--  pos=Row_Pos219, res=Transform_Res169, nobt=None
--  BEGIN <_Row (root of 'value_pattern') at parser.lkt:324:11>
--  pos=Row_Pos219, res=None, nobt=None
Row_Pos219 := Pos;
--  BEGIN <Token(<WithText NotKw>, ) (root of 'value_pattern') at parser.lkt:324:22>
--  pos=Token_Pos312, res=Token_Res312, nobt=None
Token_Res312 := Row_Pos219;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res312));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Not_Kw)
   then
       Token_Pos312 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos219 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos219,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Not_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos312 := Row_Pos219 + 1;
   end if;
end;
--  END <Token(<WithText NotKw>, ) (root of 'value_pattern') at parser.lkt:324:22>
if Token_Pos312 /= No_Token_Index then
   Row_Pos219 := Token_Pos312;
else
   Row_Pos219 := No_Token_Index;
   goto Exit_Row219_0;
end if;
--  BEGIN <Defer (for 'value_pattern') at parser.lkt:324:28>
--  pos=Defer_Pos292, res=Defer_Res292, nobt=None
Defer_Res292 :=
   Value_Pattern_Or_Parse1 (Parser, Row_Pos219);
Defer_Pos292 := Parser.Current_Pos;
--  END <Defer (for 'value_pattern') at parser.lkt:324:28>
if Defer_Pos292 /= No_Token_Index then
   Row_Pos219 := Defer_Pos292;
else
   Row_Pos219 := No_Token_Index;
   goto Exit_Row219_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row219_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'value_pattern') at parser.lkt:324:11>
if Row_Pos219 /= No_Token_Index then
   Transform_Res169 := Allocate_Not_Pattern (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res169,
      Kind => Lkt_Not_Pattern,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos219 = Pos
                            then No_Token_Index
                            else Row_Pos219 - 1));
      Initialize_Fields_For_Not_Pattern
        (Self => Transform_Res169,
         Not_Pattern_F_Sub_Pattern => Defer_Res292);
         if Defer_Res292 /= null and then Is_Incomplete (Defer_Res292) then
            Transform_Res169.Last_Attempted_Child := 0;
         elsif Defer_Res292 /= null and then not Is_Ghost (Defer_Res292) then
            Transform_Res169.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType NotPattern>) (root of 'value_pattern') at parser.lkt:324:11>
    if Row_Pos219 /= No_Token_Index then
        Or_Pos44 := Row_Pos219;
        Or_Res44 := Transform_Res169;
        goto Exit_Or47;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail44.Pos then
       Branch_Diag_Mark44 := Parser.Last_Diag;
       Branch_Last_Fail44 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark120;
    Parser.Last_Fail := Last_Fail44;
--  BEGIN <Defer (for 'bool_pattern') at parser.lkt:325:11>
--  pos=Defer_Pos293, res=Defer_Res293, nobt=None
Defer_Res293 :=
   Bool_Pattern_Or_Parse0 (Parser, Pos);
Defer_Pos293 := Parser.Current_Pos;
--  END <Defer (for 'bool_pattern') at parser.lkt:325:11>
    if Defer_Pos293 /= No_Token_Index then
        Or_Pos44 := Defer_Pos293;
        Or_Res44 := Defer_Res293;
        goto Exit_Or47;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail44.Pos then
       Branch_Diag_Mark44 := Parser.Last_Diag;
       Branch_Last_Fail44 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark120;
    Parser.Last_Fail := Last_Fail44;
--  BEGIN <Defer (for 'integer_pattern') at parser.lkt:326:11>
--  pos=Defer_Pos294, res=Defer_Res294, nobt=None
Defer_Res294 :=
   Integer_Pattern_Transform_Parse0 (Parser, Pos);
Defer_Pos294 := Parser.Current_Pos;
--  END <Defer (for 'integer_pattern') at parser.lkt:326:11>
    if Defer_Pos294 /= No_Token_Index then
        Or_Pos44 := Defer_Pos294;
        Or_Res44 := Defer_Res294;
        goto Exit_Or47;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail44.Pos then
       Branch_Diag_Mark44 := Parser.Last_Diag;
       Branch_Last_Fail44 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark120;
    Parser.Last_Fail := Last_Fail44;
--  BEGIN <Defer (for 'list_pattern') at parser.lkt:327:11>
--  pos=Defer_Pos295, res=Defer_Res295, nobt=None
Defer_Res295 :=
   List_Pattern_Transform_Parse0 (Parser, Pos);
Defer_Pos295 := Parser.Current_Pos;
--  END <Defer (for 'list_pattern') at parser.lkt:327:11>
    if Defer_Pos295 /= No_Token_Index then
        Or_Pos44 := Defer_Pos295;
        Or_Res44 := Defer_Res295;
        goto Exit_Or47;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail44.Pos then
       Branch_Diag_Mark44 := Parser.Last_Diag;
       Branch_Last_Fail44 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark120;
    Parser.Last_Fail := Last_Fail44;
--  BEGIN <Transform(<ASTNodeType BindingPattern>) (root of 'value_pattern') at parser.lkt:328:11>
--  pos=Row_Pos220, res=Transform_Res171, nobt=None
--  BEGIN <_Row (root of 'value_pattern') at parser.lkt:328:11>
--  pos=Row_Pos220, res=None, nobt=None
Row_Pos220 := Pos;
--  BEGIN <Transform(<ASTNodeType BindingValDecl>) (root of 'value_pattern') at parser.lkt:328:26>
--  pos=Row_Pos221, res=Transform_Res170, nobt=None
--  BEGIN <_Row (root of 'value_pattern') at parser.lkt:328:26>
--  pos=Row_Pos221, res=None, nobt=None
Row_Pos221 := Row_Pos220;
--  BEGIN <Defer (for 'def_id') at parser.lkt:328:41>
--  pos=Defer_Pos296, res=Defer_Res296, nobt=None
Defer_Res296 :=
   Def_Id_Transform_Parse0 (Parser, Row_Pos221);
Defer_Pos296 := Parser.Current_Pos;
--  END <Defer (for 'def_id') at parser.lkt:328:41>
if Defer_Pos296 /= No_Token_Index then
   Row_Pos221 := Defer_Pos296;
else
   Row_Pos221 := No_Token_Index;
   goto Exit_Row221_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row221_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'value_pattern') at parser.lkt:328:26>
if Row_Pos221 /= No_Token_Index then
   Transform_Res170 := Allocate_Binding_Val_Decl (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res170,
      Kind => Lkt_Binding_Val_Decl,
      Unit => Parser.Unit,
      Token_Start_Index => Row_Pos220,
      Token_End_Index   => (if Row_Pos221 = Row_Pos220
                            then No_Token_Index
                            else Row_Pos221 - 1));
      Initialize_Fields_For_Binding_Val_Decl
        (Self => Transform_Res170,
         Binding_Val_Decl_F_Syn_Name => Defer_Res296);
         if Defer_Res296 /= null and then Is_Incomplete (Defer_Res296) then
            Transform_Res170.Last_Attempted_Child := 0;
         elsif Defer_Res296 /= null and then not Is_Ghost (Defer_Res296) then
            Transform_Res170.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType BindingValDecl>) (root of 'value_pattern') at parser.lkt:328:26>
if Row_Pos221 /= No_Token_Index then
   Row_Pos220 := Row_Pos221;
else
   Row_Pos220 := No_Token_Index;
   goto Exit_Row220_0;
end if;
--  BEGIN <Opt (root of 'value_pattern') at parser.lkt:328:49>
--  pos=Row_Pos222, res=Defer_Res297, nobt=None
Diag_Mark119 := Parser.Last_Diag;
--  BEGIN <_Extract (root of 'value_pattern') at parser.lkt:328:50>
--  pos=Row_Pos222, res=Defer_Res297, nobt=None
--  BEGIN <_Row (root of 'value_pattern') at parser.lkt:328:50>
--  pos=Row_Pos222, res=None, nobt=None
Row_Pos222 := Row_Pos220;
--  BEGIN <Token(<WithText At>, ) (root of 'value_pattern') at parser.lkt:328:55>
--  pos=Token_Pos313, res=Token_Res313, nobt=None
Token_Res313 := Row_Pos222;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res313));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_At)
   then
       Token_Pos313 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos222 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos222,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_At,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos313 := Row_Pos222 + 1;
   end if;
end;
--  END <Token(<WithText At>, ) (root of 'value_pattern') at parser.lkt:328:55>
if Token_Pos313 /= No_Token_Index then
   Row_Pos222 := Token_Pos313;
else
   Row_Pos222 := No_Token_Index;
   goto Exit_Row222_0;
end if;
--  BEGIN <Defer (for 'value_pattern') at parser.lkt:328:59>
--  pos=Defer_Pos297, res=Defer_Res297, nobt=None
Defer_Res297 :=
   Value_Pattern_Or_Parse1 (Parser, Row_Pos222);
Defer_Pos297 := Parser.Current_Pos;
--  END <Defer (for 'value_pattern') at parser.lkt:328:59>
if Defer_Pos297 /= No_Token_Index then
   Row_Pos222 := Defer_Pos297;
else
   Row_Pos222 := No_Token_Index;
   goto Exit_Row222_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row222_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'value_pattern') at parser.lkt:328:50>
--  END <_Extract (root of 'value_pattern') at parser.lkt:328:50>
if Row_Pos222 = No_Token_Index then
   Defer_Res297 := No_Bare_Lkt_Node;
   Row_Pos222 := Row_Pos220;
      Parser.Last_Diag := Diag_Mark119;
end if;
--  END <Opt (root of 'value_pattern') at parser.lkt:328:49>
if Row_Pos222 /= No_Token_Index then
   Row_Pos220 := Row_Pos222;
else
   Row_Pos220 := No_Token_Index;
   goto Exit_Row220_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row220_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'value_pattern') at parser.lkt:328:11>
if Row_Pos220 /= No_Token_Index then
   Transform_Res171 := Allocate_Binding_Pattern (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res171,
      Kind => Lkt_Binding_Pattern,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos220 = Pos
                            then No_Token_Index
                            else Row_Pos220 - 1));
      Initialize_Fields_For_Binding_Pattern
        (Self => Transform_Res171,
         Binding_Pattern_F_Decl => Transform_Res170,
         Binding_Pattern_F_Sub_Pattern => Defer_Res297);
         if Transform_Res170 /= null and then Is_Incomplete (Transform_Res170) then
            Transform_Res171.Last_Attempted_Child := 0;
         elsif Transform_Res170 /= null and then not Is_Ghost (Transform_Res170) then
            Transform_Res171.Last_Attempted_Child := -1;
         end if;
         if Defer_Res297 /= null and then Is_Incomplete (Defer_Res297) then
            Transform_Res171.Last_Attempted_Child := 0;
         elsif Defer_Res297 /= null and then not Is_Ghost (Defer_Res297) then
            Transform_Res171.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType BindingPattern>) (root of 'value_pattern') at parser.lkt:328:11>
    if Row_Pos220 /= No_Token_Index then
        Or_Pos44 := Row_Pos220;
        Or_Res44 := Transform_Res171;
        goto Exit_Or47;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail44.Pos then
       Branch_Diag_Mark44 := Parser.Last_Diag;
       Branch_Last_Fail44 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark120;
    Parser.Last_Fail := Last_Fail44;
--  BEGIN <Transform(<ASTNodeType ParenPattern>) (root of 'value_pattern') at parser.lkt:329:11>
--  pos=Row_Pos223, res=Transform_Res172, nobt=None
--  BEGIN <_Row (root of 'value_pattern') at parser.lkt:329:11>
--  pos=Row_Pos223, res=None, nobt=None
Row_Pos223 := Pos;
--  BEGIN <Token(<WithText LPar>, ) (root of 'value_pattern') at parser.lkt:329:24>
--  pos=Token_Pos314, res=Token_Res314, nobt=None
Token_Res314 := Row_Pos223;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res314));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_L_Par)
   then
       Token_Pos314 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos223 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos223,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_L_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos314 := Row_Pos223 + 1;
   end if;
end;
--  END <Token(<WithText LPar>, ) (root of 'value_pattern') at parser.lkt:329:24>
if Token_Pos314 /= No_Token_Index then
   Row_Pos223 := Token_Pos314;
else
   Row_Pos223 := No_Token_Index;
   goto Exit_Row223_0;
end if;
--  BEGIN <Defer (for 'pattern') at parser.lkt:329:28>
--  pos=Defer_Pos298, res=Defer_Res298, nobt=None
Defer_Res298 :=
   Pattern_Or_Parse0 (Parser, Row_Pos223);
Defer_Pos298 := Parser.Current_Pos;
--  END <Defer (for 'pattern') at parser.lkt:329:28>
if Defer_Pos298 /= No_Token_Index then
   Row_Pos223 := Defer_Pos298;
else
   Row_Pos223 := No_Token_Index;
   goto Exit_Row223_0;
end if;
--  BEGIN <Token(<WithText RPar>, ) (root of 'value_pattern') at parser.lkt:329:36>
--  pos=Token_Pos315, res=Token_Res315, nobt=None
Token_Res315 := Row_Pos223;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res315));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_R_Par)
   then
       Token_Pos315 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos223 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos223,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_R_Par,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos315 := Row_Pos223 + 1;
   end if;
end;
--  END <Token(<WithText RPar>, ) (root of 'value_pattern') at parser.lkt:329:36>
if Token_Pos315 /= No_Token_Index then
   Row_Pos223 := Token_Pos315;
else
   Row_Pos223 := No_Token_Index;
   goto Exit_Row223_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row223_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'value_pattern') at parser.lkt:329:11>
if Row_Pos223 /= No_Token_Index then
   Transform_Res172 := Allocate_Paren_Pattern (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res172,
      Kind => Lkt_Paren_Pattern,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos223 = Pos
                            then No_Token_Index
                            else Row_Pos223 - 1));
      Initialize_Fields_For_Paren_Pattern
        (Self => Transform_Res172,
         Paren_Pattern_F_Sub_Pattern => Defer_Res298);
         if Defer_Res298 /= null and then Is_Incomplete (Defer_Res298) then
            Transform_Res172.Last_Attempted_Child := 0;
         elsif Defer_Res298 /= null and then not Is_Ghost (Defer_Res298) then
            Transform_Res172.Last_Attempted_Child := -1;
         end if;
end if;
--  END <Transform(<ASTNodeType ParenPattern>) (root of 'value_pattern') at parser.lkt:329:11>
    if Row_Pos223 /= No_Token_Index then
        Or_Pos44 := Row_Pos223;
        Or_Res44 := Transform_Res172;
        goto Exit_Or47;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail44.Pos then
       Branch_Diag_Mark44 := Parser.Last_Diag;
       Branch_Last_Fail44 := Parser.Last_Fail;
    end if;
    Parser.Last_Diag := Diag_Mark120;
    Parser.Last_Fail := Last_Fail44;
--  BEGIN <Defer (for 'tuple_pattern') at parser.lkt:330:11>
--  pos=Defer_Pos299, res=Defer_Res299, nobt=None
Defer_Res299 :=
   Tuple_Pattern_Transform_Parse0 (Parser, Pos);
Defer_Pos299 := Parser.Current_Pos;
--  END <Defer (for 'tuple_pattern') at parser.lkt:330:11>
    if Defer_Pos299 /= No_Token_Index then
        Or_Pos44 := Defer_Pos299;
        Or_Res44 := Defer_Res299;
        goto Exit_Or47;
    end if;
    if Parser.Last_Fail.Pos >= Branch_Last_Fail44.Pos then
       Branch_Diag_Mark44 := Parser.Last_Diag;
       Branch_Last_Fail44 := Parser.Last_Fail;
    end if;
Parser.Last_Diag := Branch_Diag_Mark44;
Parser.Last_Fail := Branch_Last_Fail44;
<<Exit_Or47>>
--  END <Or (root of 'value_pattern') at parser.lkt:312:22>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Or_Pos44 = No_Token_Index then
      Set_Failure
        (PP.Value_Pattern_Or_Parse1_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Value_Pattern_Or_Parse1_Memo, Pos, Or_Res44, Parser.Last_Diag, Or_Pos44);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Or_Pos44;
   return Or_Res44;
end Value_Pattern_Or_Parse1;
   function Var_Bind_Transform_Parse0
  (Parser : in out Parser_Type;
   Pos    : Token_Index) return Bare_Var_Bind
is
      Nobt64 : Boolean := False;
      Row_Pos224 : Token_Index := No_Token_Index;
      Token_Pos316 : Token_Index := No_Token_Index;
      Token_Res316 : Token_Index := No_Token_Index;
      Defer_Pos300 : Token_Index := No_Token_Index;
      Defer_Res300 : Bare_Ref_Id := No_Bare_Lkt_Node;
      Token_Pos317 : Token_Index := No_Token_Index;
      Token_Res317 : Token_Index := No_Token_Index;
      Defer_Pos301 : Token_Index := No_Token_Index;
      Defer_Res301 : Bare_Expr := No_Bare_Lkt_Node;
      Row_Progress56 : Integer := 0;
      Transform_Res173 : Bare_Var_Bind := No_Bare_Lkt_Node;
      Transform_Has_Failed56 : Boolean := False;
   Mark_On_Entry : constant Diagnostic_Mark := Parser.Last_Diag;
   PP : constant Parser_Private_Part := +Parser.Private_Part;
   M  : Memos.Memo_Entry := Memos.Get (PP.Var_Bind_Transform_Parse0_Memo, Pos);
begin
   if M.State = Success then
      Parser.Current_Pos := M.Final_Pos;
      Append_Group (Parser.Pool, Parser.Last_Diag, M.Mark);
      Transform_Res173 := M.Instance;
      return Transform_Res173;
   elsif M.State = Failure then
      Parser.Current_Pos := No_Token_Index;
      Set_Last_Fail (Parser, M);
      return Transform_Res173;
   end if;
   Parser.Last_Diag := No_Diagnostic;
   ---------------------------
   -- MAIN COMBINATORS CODE --
   ---------------------------
--  BEGIN <Transform(<ASTNodeType VarBind>) (root of 'var_bind') at parser.lkt:290:17>
--  pos=Row_Pos224, res=Transform_Res173, nobt=Nobt64
--  BEGIN <_Row (root of 'var_bind') at parser.lkt:290:17>
--  pos=Row_Pos224, res=None, nobt=Nobt64
Row_Pos224 := Pos;
--  BEGIN <Token(<WithText BindKw>, ) (root of 'var_bind') at parser.lkt:290:25>
--  pos=Token_Pos316, res=Token_Res316, nobt=None
Token_Res316 := Row_Pos224;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res316));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Bind_Kw)
   then
       Token_Pos316 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos224 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos224,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Bind_Kw,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos316 := Row_Pos224 + 1;
   end if;
end;
--  END <Token(<WithText BindKw>, ) (root of 'var_bind') at parser.lkt:290:25>
Row_Progress56 := 1;
if Token_Pos316 /= No_Token_Index then
   Row_Pos224 := Token_Pos316;
else
   Row_Pos224 := No_Token_Index;
   goto Exit_Row224_0;
end if;
--  BEGIN <Cut (root of 'var_bind') at parser.lkt:290:32>
--  pos=Row_Pos224, res=None, nobt=Nobt64
Nobt64 := True;
--  END <Cut (root of 'var_bind') at parser.lkt:290:32>
Row_Progress56 := 2;
if Row_Pos224 /= No_Token_Index then
   Row_Pos224 := Row_Pos224;
else
   Row_Pos224 := No_Token_Index;
   goto Exit_Row224_0;
end if;
--  BEGIN <Defer (for 'ref_id') at parser.lkt:290:34>
--  pos=Defer_Pos300, res=Defer_Res300, nobt=None
Defer_Res300 :=
   Ref_Id_Transform_Parse0 (Parser, Row_Pos224);
Defer_Pos300 := Parser.Current_Pos;
--  END <Defer (for 'ref_id') at parser.lkt:290:34>
Row_Progress56 := 3;
if Defer_Pos300 /= No_Token_Index then
   Row_Pos224 := Defer_Pos300;
else
   Row_Pos224 := No_Token_Index;
   goto Exit_Row224_0;
end if;
--  BEGIN <Token(<WithText Equal>, ) (root of 'var_bind') at parser.lkt:290:41>
--  pos=Token_Pos317, res=Token_Res317, nobt=None
Token_Res317 := Row_Pos224;
declare
   T : constant Stored_Token_Data :=
      Token_Vectors.Get (Parser.TDH.Tokens, Natural (Token_Res317));
begin
   if
      T.Kind /= From_Token_Kind (Lkt_Equal)
   then
       Token_Pos317 := No_Token_Index;
       if Parser.Last_Fail.Pos <= Row_Pos224 then
          Parser.Last_Fail :=
            (Pos  => Row_Pos224,
             Data =>
               (Kind              => Token_Fail,
                Expected_Token_Id => Lkt_Equal,
                Found_Token_Id    => To_Token_Kind (T.Kind)));
       end if;
   else
          Token_Pos317 := Row_Pos224 + 1;
   end if;
end;
--  END <Token(<WithText Equal>, ) (root of 'var_bind') at parser.lkt:290:41>
Row_Progress56 := 4;
if Token_Pos317 /= No_Token_Index then
   Row_Pos224 := Token_Pos317;
else
   Row_Pos224 := No_Token_Index;
   goto Exit_Row224_0;
end if;
--  BEGIN <Defer (for 'expr') at parser.lkt:290:45>
--  pos=Defer_Pos301, res=Defer_Res301, nobt=None
Defer_Res301 :=
   Expr_Or_Parse0 (Parser, Row_Pos224);
Defer_Pos301 := Parser.Current_Pos;
--  END <Defer (for 'expr') at parser.lkt:290:45>
Row_Progress56 := 5;
if Defer_Pos301 /= No_Token_Index then
   Row_Pos224 := Defer_Pos301;
else
   Row_Pos224 := No_Token_Index;
   goto Exit_Row224_0;
end if;
pragma Warnings (Off, "referenced");
<<Exit_Row224_0>>
pragma Warnings (On, "referenced");
--  END <_Row (root of 'var_bind') at parser.lkt:290:17>
if Row_Pos224 = No_Token_Index and then Nobt64 then
   Row_Pos224 := Parser.Last_Fail.Pos;
   Transform_Has_Failed56 := True;
end if;
if Row_Pos224 /= No_Token_Index then
   Transform_Res173 := Allocate_Var_Bind (Parser.Mem_Pool);
   Initialize
     (Self => Transform_Res173,
      Kind => Lkt_Var_Bind,
      Unit => Parser.Unit,
      Token_Start_Index => Pos,
      Token_End_Index   => (if Row_Pos224 = Pos
                            then No_Token_Index
                            else Row_Pos224 - 1));
      Initialize_Fields_For_Var_Bind
        (Self => Transform_Res173,
         Var_Bind_F_Name => Defer_Res300,
         Var_Bind_F_Expr => Defer_Res301);
         if Defer_Res300 /= null and then Is_Incomplete (Defer_Res300) then
            Transform_Res173.Last_Attempted_Child := 0;
         elsif Defer_Res300 /= null and then not Is_Ghost (Defer_Res300) then
            Transform_Res173.Last_Attempted_Child := -1;
         end if;
         if Defer_Res301 /= null and then Is_Incomplete (Defer_Res301) then
            Transform_Res173.Last_Attempted_Child := 0;
         elsif Defer_Res301 /= null and then not Is_Ghost (Defer_Res301) then
            Transform_Res173.Last_Attempted_Child := -1;
         end if;
   if Transform_Has_Failed56 then
      Transform_Res173.Last_Attempted_Child :=
         Row_Progress56;
      Append (Parser, Pos, "Cannot parse <var_bind>");
      Add_Last_Fail_Diagnostic (Parser);
   end if;
end if;
--  END <Transform(<ASTNodeType VarBind>) (root of 'var_bind') at parser.lkt:290:17>
   -------------------------------
   -- END MAIN COMBINATORS CODE --
   -------------------------------
   if Row_Pos224 = No_Token_Index then
      Set_Failure
        (PP.Var_Bind_Transform_Parse0_Memo, Pos, Parser.Last_Fail, Parser.Last_Diag);
   else
      Memos.Set_Success
        (PP.Var_Bind_Transform_Parse0_Memo, Pos, Transform_Res173, Parser.Last_Diag, Row_Pos224);
   end if;
   declare
      Top : constant Diagnostic_Mark := Parser.Last_Diag;
   begin
      Parser.Last_Diag := Mark_On_Entry;
      Append_Group (Parser.Pool, Parser.Last_Diag, Top);
   end;
   Parser.Current_Pos := Row_Pos224;
   return Transform_Res173;
end Var_Bind_Transform_Parse0;

   -----------
   -- Reset --
   -----------

   procedure Reset (Parser : in out Parser_Type) is
      New_Parser : Parser_Type;
      --  We create this new parser instance to leverage creation of default
      --  values, so as to not repeat them.

      PP : Parser_Private_Part;
   begin
      --  We just keep the private part, to not have to reallocate it
      New_Parser.Private_Part := Parser.Private_Part;
      New_Parser.Last_Diag := No_Diagnostic;

      --  And then reset everything else
      Parser := New_Parser;

      --  Reset the memo tables in the private part
      PP := +Parser.Private_Part;
         Memos.Clear (PP.Args_List_Parse0_Memo);
         Memos.Clear (PP.Argument_Transform_Parse0_Memo);
         Memos.Clear (PP.Arith_1_Or_Parse1_Memo);
         Memos.Clear (PP.Arith_2_Or_Parse1_Memo);
         Memos.Clear (PP.Arith_3_Or_Parse1_Memo);
         Memos.Clear (PP.Array_Literal_Transform_Parse0_Memo);
         Memos.Clear (PP.Bare_Decl_Or_Parse0_Memo);
         Memos.Clear (PP.Basic_Expr_Or_Parse0_Memo);
         Memos.Clear (PP.Basic_Name_Or_Parse0_Memo);
         Memos.Clear (PP.Big_Num_Lit_Transform_Parse0_Memo);
         Memos.Clear (PP.Block_String_Lit_Transform_Parse1_Memo);
         Memos.Clear (PP.Block_Transform_Parse2_Memo);
         Memos.Clear (PP.Bool_Pattern_Or_Parse0_Memo);
         Memos.Clear (PP.Callable_Ref_Or_Parse0_Memo);
         Memos.Clear (PP.Char_Lit_Transform_Parse0_Memo);
         Memos.Clear (PP.Decl_Annotation_Args_Opt_Parse0_Memo);
         Memos.Clear (PP.Decl_Annotation_Transform_Parse0_Memo);
         Memos.Clear (PP.Decl_Block_List_Parse0_Memo);
         Memos.Clear (PP.Decl_Transform_Parse0_Memo);
         Memos.Clear (PP.Decls_Dont_Skip_Parse0_Memo);
         Memos.Clear (PP.Def_Id_Transform_Parse0_Memo);
         Memos.Clear (PP.Doc_Opt_Parse0_Memo);
         Memos.Clear (PP.Dontskip_Block0_Extract_Parse0_Memo);
         Memos.Clear (PP.Dontskip_Decls0_Extract_Parse0_Memo);
         Memos.Clear (PP.Dontskip_Grammar_List_Expr0_Extract_Parse0_Memo);
         Memos.Clear (PP.Dontskip_Grammar_List_Expr1_Extract_Parse0_Memo);
         Memos.Clear (PP.Dontskip_Grammar_Opt0_Extract_Parse0_Memo);
         Memos.Clear (PP.Dontskip_Grammar_Opt_Error0_Extract_Parse0_Memo);
         Memos.Clear (PP.Dontskip_Grammar_Or_Expr0_Extract_Parse0_Memo);
         Memos.Clear (PP.Dontskip_Grammar_Or_Expr1_Extract_Parse0_Memo);
         Memos.Clear (PP.Dontskip_Grammar_Pick0_Extract_Parse0_Memo);
         Memos.Clear (PP.Dontskip_Lexer_Case_Rule0_Extract_Parse0_Memo);
         Memos.Clear (PP.Dontskip_Lexer_Decl0_Extract_Parse0_Memo);
         Memos.Clear (PP.Dontskip_Lexer_Family_Decl0_Extract_Parse0_Memo);
         Memos.Clear (PP.Dontskip_Parse_Node_Expr0_Extract_Parse0_Memo);
         Memos.Clear (PP.Dontskip_Type_Decl0_Extract_Parse0_Memo);
         Memos.Clear (PP.Dontskip_Type_Decl1_Extract_Parse0_Memo);
         Memos.Clear (PP.Dontskip_Type_Decl2_Extract_Parse0_Memo);
         Memos.Clear (PP.Dontskip_Type_Decl3_Extract_Parse0_Memo);
         Memos.Clear (PP.Dontskip_Type_Decl4_Extract_Parse0_Memo);
         Memos.Clear (PP.Dynvar_Decl_Transform_Parse0_Memo);
         Memos.Clear (PP.Ellipsis_Pattern_Transform_Parse0_Memo);
         Memos.Clear (PP.Enum_Lit_Decl_Transform_Parse0_Memo);
         Memos.Clear (PP.Env_Spec_Action_Transform_Parse1_Memo);
         Memos.Clear (PP.Env_Spec_Decl_Transform_Parse1_Memo);
         Memos.Clear (PP.Eq_Or_Parse1_Memo);
         Memos.Clear (PP.Expr_Or_Parse0_Memo);
         Memos.Clear (PP.Field_Decl_Transform_Parse0_Memo);
         Memos.Clear (PP.Fil_Pattern_Or_Parse0_Memo);
         Memos.Clear (PP.Fun_Decl_Transform_Parse0_Memo);
         Memos.Clear (PP.Fun_Param_Decl_Transform_Parse0_Memo);
         Memos.Clear (PP.Fun_Param_List_List_Parse0_Memo);
         Memos.Clear (PP.Generic_Decl_Transform_Parse0_Memo);
         Memos.Clear (PP.Generic_Param_Type_Transform_Parse1_Memo);
         Memos.Clear (PP.Grammar_Cut_Transform_Parse0_Memo);
         Memos.Clear (PP.Grammar_Decl_Transform_Parse0_Memo);
         Memos.Clear (PP.Grammar_Discard_Expr_Transform_Parse0_Memo);
         Memos.Clear (PP.Grammar_Expr_Or_Parse0_Memo);
         Memos.Clear (PP.Grammar_Implicit_Pick_Transform_Parse0_Memo);
         Memos.Clear (PP.Grammar_List_Expr_Transform_Parse3_Memo);
         Memos.Clear (PP.Grammar_List_Sep_Transform_Parse0_Memo);
         Memos.Clear (PP.Grammar_Null_Transform_Parse0_Memo);
         Memos.Clear (PP.Grammar_Opt_Error_Or_Parse0_Memo);
         Memos.Clear (PP.Grammar_Opt_Or_Parse0_Memo);
         Memos.Clear (PP.Grammar_Or_Expr_Transform_Parse0_Memo);
         Memos.Clear (PP.Grammar_Pick_Transform_Parse0_Memo);
         Memos.Clear (PP.Grammar_Primary_Or_Parse0_Memo);
         Memos.Clear (PP.Grammar_Rule_Ref_Transform_Parse0_Memo);
         Memos.Clear (PP.Grammar_Rule_Transform_Parse0_Memo);
         Memos.Clear (PP.Grammar_Skip_Transform_Parse0_Memo);
         Memos.Clear (PP.Grammar_Stopcut_Transform_Parse0_Memo);
         Memos.Clear (PP.Grammar_Token_Transform_Parse0_Memo);
         Memos.Clear (PP.Id_Transform_Parse0_Memo);
         Memos.Clear (PP.If_Expr_Transform_Parse1_Memo);
         Memos.Clear (PP.Import_Clause_Or_Parse0_Memo);
         Memos.Clear (PP.Imported_Name_Transform_Parse1_Memo);
         Memos.Clear (PP.Imports_List_Parse0_Memo);
         Memos.Clear (PP.Integer_Pattern_Transform_Parse0_Memo);
         Memos.Clear (PP.Isa_Or_Primary_Or_Parse0_Memo);
         Memos.Clear (PP.Lambda_Expr_Transform_Parse0_Memo);
         Memos.Clear (PP.Lambda_Param_Decl_Transform_Parse0_Memo);
         Memos.Clear (PP.Lambda_Param_List_List_Parse0_Memo);
         Memos.Clear (PP.Lexer_Case_Alt_Or_Parse0_Memo);
         Memos.Clear (PP.Lexer_Case_Rule_Transform_Parse0_Memo);
         Memos.Clear (PP.Lexer_Case_Send_Transform_Parse0_Memo);
         Memos.Clear (PP.Lexer_Decl_Transform_Parse0_Memo);
         Memos.Clear (PP.Lexer_Family_Decl_Transform_Parse0_Memo);
         Memos.Clear (PP.List_Pattern_Transform_Parse0_Memo);
         Memos.Clear (PP.Logic_Or_Parse1_Memo);
         Memos.Clear (PP.Logic_Propagate_Call_Transform_Parse0_Memo);
         Memos.Clear (PP.Main_Rule_Transform_Parse0_Memo);
         Memos.Clear (PP.Match_Expr_Transform_Parse3_Memo);
         Memos.Clear (PP.Module_Doc_Opt_Parse0_Memo);
         Memos.Clear (PP.Module_Id_Predicate_Parse0_Memo);
         Memos.Clear (PP.Null_Cond_Qual_Opt_Parse0_Memo);
         Memos.Clear (PP.Null_Lit_Transform_Parse0_Memo);
         Memos.Clear (PP.Num_Lit_Transform_Parse0_Memo);
         Memos.Clear (PP.Parse_Node_Expr_Transform_Parse0_Memo);
         Memos.Clear (PP.Pattern_Arg_Or_Parse0_Memo);
         Memos.Clear (PP.Pattern_Or_Parse0_Memo);
         Memos.Clear (PP.Primary_Or_Parse0_Memo);
         Memos.Clear (PP.Query_Comprehension_Transform_Parse0_Memo);
         Memos.Clear (PP.Raise_Expr_Transform_Parse0_Memo);
         Memos.Clear (PP.Ref_Id_Transform_Parse0_Memo);
         Memos.Clear (PP.Regex_Pattern_Transform_Parse0_Memo);
         Memos.Clear (PP.Rel_Or_Parse0_Memo);
         Memos.Clear (PP.Selector_Call_Transform_Parse0_Memo);
         Memos.Clear (PP.Stream_Concat_Or_Parse0_Memo);
         Memos.Clear (PP.String_Lit_Or_Parse0_Memo);
         Memos.Clear (PP.Term_Or_Parse0_Memo);
         Memos.Clear (PP.Token_Literal_Transform_Parse0_Memo);
         Memos.Clear (PP.Token_No_Case_Literal_Transform_Parse0_Memo);
         Memos.Clear (PP.Token_Pattern_Literal_Transform_Parse0_Memo);
         Memos.Clear (PP.Token_Pattern_Or_Parse0_Memo);
         Memos.Clear (PP.Try_Expr_Transform_Parse0_Memo);
         Memos.Clear (PP.Tuple_Pattern_Transform_Parse0_Memo);
         Memos.Clear (PP.Type_Decl_Or_Parse0_Memo);
         Memos.Clear (PP.Type_Expr_Or_Parse0_Memo);
         Memos.Clear (PP.Type_List_List_Parse0_Memo);
         Memos.Clear (PP.Type_Member_Ref_Transform_Parse0_Memo);
         Memos.Clear (PP.Type_Ref_Id_Predicate_Parse0_Memo);
         Memos.Clear (PP.Type_Ref_Or_Parse0_Memo);
         Memos.Clear (PP.Val_Decl_Transform_Parse0_Memo);
         Memos.Clear (PP.Value_Pattern_Or_Parse1_Memo);
         Memos.Clear (PP.Var_Bind_Transform_Parse0_Memo);
   end Reset;

   -------------
   -- Destroy --
   -------------

   procedure Destroy (Parser : in out Parser_Type) is
      procedure Free is new Ada.Unchecked_Deallocation
        (Parser_Private_Part_Type, Parser_Private_Part);
      procedure Free is new Ada.Unchecked_Deallocation
        (Free_Parse_List_Record, Free_Parse_List);

      PP  : Parser_Private_Part := +Parser.Private_Part;
      Cur : Free_Parse_List renames PP.Parse_Lists;
   begin
      while Cur /= null loop
         declare
            Next : constant Free_Parse_List := Cur.Next;
         begin
            Cur.Nodes.Destroy;
            Free (Cur);
            Cur := Next;
         end;
      end loop;
      Free (PP);
   end Destroy;

   ----------------
   -- Initialize --
   ----------------

   procedure Initialize (Parser : in out Parser_Type) is
      PP : constant Parser_Private_Part :=
        new Parser_Private_Part_Type'(others => <>);
   begin
      Parser.Private_Part := +PP;
   end Initialize;

   --------------------
   -- Get_Parse_List --
   --------------------

   function Get_Parse_List (Parser : Parser_Type) return Free_Parse_List is
      PP     : constant Parser_Private_Part := +Parser.Private_Part;
      Lists  : Free_Parse_List renames PP.Parse_Lists;
      Result : Free_Parse_List;
   begin
      if Lists = null then
         Result := new Free_Parse_List_Record;

      else
         Result := Lists;
         Lists := Lists.Next;
      end if;

      return Result;
   end Get_Parse_List;

   ------------------------
   -- Release_Parse_List --
   ------------------------

   procedure Release_Parse_List
     (Parser : Parser_Type; List : in out Free_Parse_List)
   is
      PP    : constant Parser_Private_Part := +Parser.Private_Part;
      Lists : Free_Parse_List renames PP.Parse_Lists;
   begin
      List.Nodes.Clear;
      List.Next := Lists;
      Lists := List;
      List := null;
   end Release_Parse_List;

   ----------
   -- Dump --
   ----------

   procedure Dump (Parser : Parser_Type) is

      type Any_Parser is
        (Args_List_Parse0,
         Argument_Transform_Parse0,
         Arith_1_Or_Parse1,
         Arith_2_Or_Parse1,
         Arith_3_Or_Parse1,
         Array_Literal_Transform_Parse0,
         Bare_Decl_Or_Parse0,
         Basic_Expr_Or_Parse0,
         Basic_Name_Or_Parse0,
         Big_Num_Lit_Transform_Parse0,
         Block_String_Lit_Transform_Parse1,
         Block_Transform_Parse2,
         Bool_Pattern_Or_Parse0,
         Callable_Ref_Or_Parse0,
         Char_Lit_Transform_Parse0,
         Decl_Annotation_Args_Opt_Parse0,
         Decl_Annotation_Transform_Parse0,
         Decl_Block_List_Parse0,
         Decl_Transform_Parse0,
         Decls_Dont_Skip_Parse0,
         Def_Id_Transform_Parse0,
         Doc_Opt_Parse0,
         Dontskip_Block0_Extract_Parse0,
         Dontskip_Decls0_Extract_Parse0,
         Dontskip_Grammar_List_Expr0_Extract_Parse0,
         Dontskip_Grammar_List_Expr1_Extract_Parse0,
         Dontskip_Grammar_Opt0_Extract_Parse0,
         Dontskip_Grammar_Opt_Error0_Extract_Parse0,
         Dontskip_Grammar_Or_Expr0_Extract_Parse0,
         Dontskip_Grammar_Or_Expr1_Extract_Parse0,
         Dontskip_Grammar_Pick0_Extract_Parse0,
         Dontskip_Lexer_Case_Rule0_Extract_Parse0,
         Dontskip_Lexer_Decl0_Extract_Parse0,
         Dontskip_Lexer_Family_Decl0_Extract_Parse0,
         Dontskip_Parse_Node_Expr0_Extract_Parse0,
         Dontskip_Type_Decl0_Extract_Parse0,
         Dontskip_Type_Decl1_Extract_Parse0,
         Dontskip_Type_Decl2_Extract_Parse0,
         Dontskip_Type_Decl3_Extract_Parse0,
         Dontskip_Type_Decl4_Extract_Parse0,
         Dynvar_Decl_Transform_Parse0,
         Ellipsis_Pattern_Transform_Parse0,
         Enum_Lit_Decl_Transform_Parse0,
         Env_Spec_Action_Transform_Parse1,
         Env_Spec_Decl_Transform_Parse1,
         Eq_Or_Parse1,
         Expr_Or_Parse0,
         Field_Decl_Transform_Parse0,
         Fil_Pattern_Or_Parse0,
         Fun_Decl_Transform_Parse0,
         Fun_Param_Decl_Transform_Parse0,
         Fun_Param_List_List_Parse0,
         Generic_Decl_Transform_Parse0,
         Generic_Param_Type_Transform_Parse1,
         Grammar_Cut_Transform_Parse0,
         Grammar_Decl_Transform_Parse0,
         Grammar_Discard_Expr_Transform_Parse0,
         Grammar_Expr_Or_Parse0,
         Grammar_Implicit_Pick_Transform_Parse0,
         Grammar_List_Expr_Transform_Parse3,
         Grammar_List_Sep_Transform_Parse0,
         Grammar_Null_Transform_Parse0,
         Grammar_Opt_Error_Or_Parse0,
         Grammar_Opt_Or_Parse0,
         Grammar_Or_Expr_Transform_Parse0,
         Grammar_Pick_Transform_Parse0,
         Grammar_Primary_Or_Parse0,
         Grammar_Rule_Ref_Transform_Parse0,
         Grammar_Rule_Transform_Parse0,
         Grammar_Skip_Transform_Parse0,
         Grammar_Stopcut_Transform_Parse0,
         Grammar_Token_Transform_Parse0,
         Id_Transform_Parse0,
         If_Expr_Transform_Parse1,
         Import_Clause_Or_Parse0,
         Imported_Name_Transform_Parse1,
         Imports_List_Parse0,
         Integer_Pattern_Transform_Parse0,
         Isa_Or_Primary_Or_Parse0,
         Lambda_Expr_Transform_Parse0,
         Lambda_Param_Decl_Transform_Parse0,
         Lambda_Param_List_List_Parse0,
         Lexer_Case_Alt_Or_Parse0,
         Lexer_Case_Rule_Transform_Parse0,
         Lexer_Case_Send_Transform_Parse0,
         Lexer_Decl_Transform_Parse0,
         Lexer_Family_Decl_Transform_Parse0,
         List_Pattern_Transform_Parse0,
         Logic_Or_Parse1,
         Logic_Propagate_Call_Transform_Parse0,
         Main_Rule_Transform_Parse0,
         Match_Expr_Transform_Parse3,
         Module_Doc_Opt_Parse0,
         Module_Id_Predicate_Parse0,
         Null_Cond_Qual_Opt_Parse0,
         Null_Lit_Transform_Parse0,
         Num_Lit_Transform_Parse0,
         Parse_Node_Expr_Transform_Parse0,
         Pattern_Arg_Or_Parse0,
         Pattern_Or_Parse0,
         Primary_Or_Parse0,
         Query_Comprehension_Transform_Parse0,
         Raise_Expr_Transform_Parse0,
         Ref_Id_Transform_Parse0,
         Regex_Pattern_Transform_Parse0,
         Rel_Or_Parse0,
         Selector_Call_Transform_Parse0,
         Stream_Concat_Or_Parse0,
         String_Lit_Or_Parse0,
         Term_Or_Parse0,
         Token_Literal_Transform_Parse0,
         Token_No_Case_Literal_Transform_Parse0,
         Token_Pattern_Literal_Transform_Parse0,
         Token_Pattern_Or_Parse0,
         Try_Expr_Transform_Parse0,
         Tuple_Pattern_Transform_Parse0,
         Type_Decl_Or_Parse0,
         Type_Expr_Or_Parse0,
         Type_List_List_Parse0,
         Type_Member_Ref_Transform_Parse0,
         Type_Ref_Id_Predicate_Parse0,
         Type_Ref_Or_Parse0,
         Val_Decl_Transform_Parse0,
         Value_Pattern_Or_Parse1,
         Var_Bind_Transform_Parse0);

      type Memo_Entry_Key is record
         Offset : Token_Index;
         Parser : Any_Parser;
      end record;

      function "<" (Left, Right : Memo_Entry_Key) return Boolean
      is (Left.Offset < Right.Offset
          or else (Left.Offset = Right.Offset
                   and then Left.Parser < Right.Parser));

      type Memo_Entry is record
         State     : Memo_State;
         Instance  : Bare_Lkt_Node;
         Mark      : Diagnostic_Mark;
         Final_Pos : Token_Index;
      end record;

      package Memo_Entry_Maps is new Ada.Containers.Ordered_Maps
        (Key_Type => Memo_Entry_Key, Element_Type => Memo_Entry);

      TDH          : Token_Data_Handler renames Parser.TDH.all;
      PP           : constant Parser_Private_Part := +Parser.Private_Part;
      Memo_Entries : Memo_Entry_Maps.Map;
   begin
      Put_Line ("Current_Pos:" & Parser.Current_Pos'Image);
      if Parser.Last_Fail.Pos /= No_Token_Index then
         Put_Line ("Last_Fail:");
         Put_Line ("  Pos:" & Parser.Last_Fail.Pos'Image);
         Put_Line ("  Kind: " & Parser.Last_Fail.Data.Kind'Image);
         case Parser.Last_Fail.Data.Kind is
         when Token_Fail =>
            Put_Line
              ("  Expected_Token_Id: "
               & Parser.Last_Fail.Data.Expected_Token_Id'Image);
            Put_Line
              ("  Found_Token_Id: "
               & Parser.Last_Fail.Data.Found_Token_Id'Image);
         when Predicate_Fail =>
            null;
         end case;
      end if;
      if Parser.Last_Diag /= No_Diagnostic then
         Put_Line ("Diagnostics:");
         declare
            procedure Process (D : Diagnostic);

            -------------
            -- Process --
            -------------

            procedure Process (D : Diagnostic) is
            begin
               Put_Line ("  " & To_Pretty_String (D));
            end Process;
         begin
            Iterate (Parser.Pool, Parser.Last_Diag, Process'Access);
         end;
      end if;

      if PP = null then
         return;
      end if;

      --  Collect all entries from packrat tables into a single ordered map

         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Args_List_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Args_List_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Argument_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Argument_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Arith_1_Or_Parse1);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Arith_1_Or_Parse1_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Arith_2_Or_Parse1);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Arith_2_Or_Parse1_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Arith_3_Or_Parse1);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Arith_3_Or_Parse1_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Array_Literal_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Array_Literal_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Bare_Decl_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Bare_Decl_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Basic_Expr_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Basic_Expr_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Basic_Name_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Basic_Name_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Big_Num_Lit_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Big_Num_Lit_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Block_String_Lit_Transform_Parse1);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Block_String_Lit_Transform_Parse1_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Block_Transform_Parse2);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Block_Transform_Parse2_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Bool_Pattern_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Bool_Pattern_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Callable_Ref_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Callable_Ref_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Char_Lit_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Char_Lit_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Decl_Annotation_Args_Opt_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Decl_Annotation_Args_Opt_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Decl_Annotation_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Decl_Annotation_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Decl_Block_List_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Decl_Block_List_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Decl_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Decl_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Decls_Dont_Skip_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Decls_Dont_Skip_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Def_Id_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Def_Id_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Doc_Opt_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Doc_Opt_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dontskip_Block0_Extract_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dontskip_Block0_Extract_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dontskip_Decls0_Extract_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dontskip_Decls0_Extract_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dontskip_Grammar_List_Expr0_Extract_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dontskip_Grammar_List_Expr0_Extract_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dontskip_Grammar_List_Expr1_Extract_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dontskip_Grammar_List_Expr1_Extract_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dontskip_Grammar_Opt0_Extract_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dontskip_Grammar_Opt0_Extract_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dontskip_Grammar_Opt_Error0_Extract_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dontskip_Grammar_Opt_Error0_Extract_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dontskip_Grammar_Or_Expr0_Extract_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dontskip_Grammar_Or_Expr0_Extract_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dontskip_Grammar_Or_Expr1_Extract_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dontskip_Grammar_Or_Expr1_Extract_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dontskip_Grammar_Pick0_Extract_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dontskip_Grammar_Pick0_Extract_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dontskip_Lexer_Case_Rule0_Extract_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dontskip_Lexer_Case_Rule0_Extract_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dontskip_Lexer_Decl0_Extract_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dontskip_Lexer_Decl0_Extract_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dontskip_Lexer_Family_Decl0_Extract_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dontskip_Lexer_Family_Decl0_Extract_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dontskip_Parse_Node_Expr0_Extract_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dontskip_Parse_Node_Expr0_Extract_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dontskip_Type_Decl0_Extract_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dontskip_Type_Decl0_Extract_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dontskip_Type_Decl1_Extract_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dontskip_Type_Decl1_Extract_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dontskip_Type_Decl2_Extract_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dontskip_Type_Decl2_Extract_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dontskip_Type_Decl3_Extract_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dontskip_Type_Decl3_Extract_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dontskip_Type_Decl4_Extract_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dontskip_Type_Decl4_Extract_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Dynvar_Decl_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Dynvar_Decl_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Ellipsis_Pattern_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Ellipsis_Pattern_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Enum_Lit_Decl_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Enum_Lit_Decl_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Env_Spec_Action_Transform_Parse1);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Env_Spec_Action_Transform_Parse1_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Env_Spec_Decl_Transform_Parse1);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Env_Spec_Decl_Transform_Parse1_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Eq_Or_Parse1);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Eq_Or_Parse1_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Expr_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Expr_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Field_Decl_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Field_Decl_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Fil_Pattern_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Fil_Pattern_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Fun_Decl_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Fun_Decl_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Fun_Param_Decl_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Fun_Param_Decl_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Fun_Param_List_List_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Fun_Param_List_List_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Generic_Decl_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Generic_Decl_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Generic_Param_Type_Transform_Parse1);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Generic_Param_Type_Transform_Parse1_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Grammar_Cut_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Grammar_Cut_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Grammar_Decl_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Grammar_Decl_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Grammar_Discard_Expr_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Grammar_Discard_Expr_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Grammar_Expr_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Grammar_Expr_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Grammar_Implicit_Pick_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Grammar_Implicit_Pick_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Grammar_List_Expr_Transform_Parse3);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Grammar_List_Expr_Transform_Parse3_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Grammar_List_Sep_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Grammar_List_Sep_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Grammar_Null_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Grammar_Null_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Grammar_Opt_Error_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Grammar_Opt_Error_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Grammar_Opt_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Grammar_Opt_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Grammar_Or_Expr_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Grammar_Or_Expr_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Grammar_Pick_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Grammar_Pick_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Grammar_Primary_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Grammar_Primary_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Grammar_Rule_Ref_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Grammar_Rule_Ref_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Grammar_Rule_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Grammar_Rule_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Grammar_Skip_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Grammar_Skip_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Grammar_Stopcut_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Grammar_Stopcut_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Grammar_Token_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Grammar_Token_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Id_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Id_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, If_Expr_Transform_Parse1);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.If_Expr_Transform_Parse1_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Import_Clause_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Import_Clause_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Imported_Name_Transform_Parse1);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Imported_Name_Transform_Parse1_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Imports_List_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Imports_List_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Integer_Pattern_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Integer_Pattern_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Isa_Or_Primary_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Isa_Or_Primary_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Lambda_Expr_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Lambda_Expr_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Lambda_Param_Decl_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Lambda_Param_Decl_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Lambda_Param_List_List_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Lambda_Param_List_List_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Lexer_Case_Alt_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Lexer_Case_Alt_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Lexer_Case_Rule_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Lexer_Case_Rule_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Lexer_Case_Send_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Lexer_Case_Send_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Lexer_Decl_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Lexer_Decl_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Lexer_Family_Decl_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Lexer_Family_Decl_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, List_Pattern_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.List_Pattern_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Logic_Or_Parse1);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Logic_Or_Parse1_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Logic_Propagate_Call_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Logic_Propagate_Call_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Main_Rule_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Main_Rule_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Match_Expr_Transform_Parse3);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Match_Expr_Transform_Parse3_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Module_Doc_Opt_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Module_Doc_Opt_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Module_Id_Predicate_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Module_Id_Predicate_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Null_Cond_Qual_Opt_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Null_Cond_Qual_Opt_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Null_Lit_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Null_Lit_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Num_Lit_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Num_Lit_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Parse_Node_Expr_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Parse_Node_Expr_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Pattern_Arg_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Pattern_Arg_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Pattern_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Pattern_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Primary_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Primary_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Query_Comprehension_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Query_Comprehension_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Raise_Expr_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Raise_Expr_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Ref_Id_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Ref_Id_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Regex_Pattern_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Regex_Pattern_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Rel_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Rel_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Selector_Call_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Selector_Call_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Stream_Concat_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Stream_Concat_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, String_Lit_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.String_Lit_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Term_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Term_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Token_Literal_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Token_Literal_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Token_No_Case_Literal_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Token_No_Case_Literal_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Token_Pattern_Literal_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Token_Pattern_Literal_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Token_Pattern_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Token_Pattern_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Try_Expr_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Try_Expr_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Tuple_Pattern_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Tuple_Pattern_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Type_Decl_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Type_Decl_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Type_Expr_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Type_Expr_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Type_List_List_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Type_List_List_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Type_Member_Ref_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Type_Member_Ref_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Type_Ref_Id_Predicate_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Type_Ref_Id_Predicate_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Type_Ref_Or_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Type_Ref_Or_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Val_Decl_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Val_Decl_Transform_Parse0_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Value_Pattern_Or_Parse1);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Value_Pattern_Or_Parse1_Memo, Process'Access);
         end;
         declare
            procedure Process (E : Memos.Memo_Entry);

            -------------
            -- Process --
            -------------

            procedure Process (E : Memos.Memo_Entry) is
               K : constant Memo_Entry_Key :=
                 (E.Offset, Var_Bind_Transform_Parse0);
               V : constant Memo_Entry :=
                 (E.State, E.Instance, E.Mark, E.Final_Pos);
            begin
               Memo_Entries.Insert (K, V);
            end Process;
         begin
            Memos.Iterate (PP.Var_Bind_Transform_Parse0_Memo, Process'Access);
         end;

      --  Dump all entries in token stream order

      declare
         Last_Token : Token_Index := No_Token_Index;
      begin
         for Cur in Memo_Entries.Iterate loop
            declare
               K : constant Memo_Entry_Key := Memo_Entry_Maps.Key (Cur);
               V : constant Memo_Entry := Memo_Entry_Maps.Element (Cur);
            begin
               if K.Offset > Last_Token then
                  declare
                     T    : constant Stored_Token_Data :=
                       Get_Token (TDH, K.Offset);
                     Text : constant Text_Type :=
                       Liblktlang_Support.Token_Data_Handlers.Text (TDH, T);
                  begin
                     Put ("[" & K.Offset'Image & "] ");
                     Put (Image (Get_Sloc (TDH, T.Source_First)) & ": ");
                     Put (Image (Text, With_Quotes => True));
                     New_Line;
                     Last_Token := K.Offset;
                  end;
               end if;
               Put ("  [" & V.State'Image & "] ");
               Put (K.Parser'Image);
               if V.State = Success then
                  Put (": " & Trace_Image (V.Instance));
                  Put (" [to" & V.Final_Pos'Image & "]");
               end if;
               New_Line;
               declare
                  procedure Process (D : Diagnostic);

                  -------------
                  -- Process --
                  -------------

                  procedure Process (D : Diagnostic) is
                  begin
                     Put_Line ("    " & To_Pretty_String (D));
                  end Process;
               begin
                  Iterate (Parser.Pool, V.Mark, Process'Access);
               end;
            end;
         end loop;
      end;
   end Dump;

end Liblktlang.Parsers_Impl;
