grammar None_grammar {
    main_rule <- list*(or(Literal(@Number) | Identifier(@Identifier)))

}

@abstract class FooNode {
}

@abstract class RootNode : FooNode {
    var : LogicVar

    fun xref_eq (arg1 : Entity[FooNode], arg2 : Entity[FooNode]): LogicEquation

    @export fun solve_eq (arg1 : Entity[FooNode], arg2 : Entity[FooNode]): Boolean =
    self.xref_eq(arg1, arg2).solve
}

class Identifier : RootNode {

    fun xref_eq (arg1 : Entity[FooNode], arg2 : Entity[FooNode]): LogicEquation =
    %domain(self.var, [self])
}

class Literal : RootNode {

    fun is_eq (other : Entity[Literal]): Boolean = self.as_entity = other

    fun xref_eq (arg1 : Entity[FooNode], arg2 : Entity[FooNode]): LogicEquation =
    (%domain(self.var, [arg1])) and (
        %eq(self.var, arg2, eq_prop=BareLiteral.is_eq)
    )
}
