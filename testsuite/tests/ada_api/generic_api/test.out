== analysis.adb ==

Language name: Foo

Grammar rules:
  Main_Rule (default) (public): Foo_Node_List
    doc: "Parser main entry point\x0a"
  Null_Qual: Null_Qual
  Var_Decl: Var_Decl
  Def: Def
  Expr (public): Expr
    doc: "Use this to parse\x0aany kind of expression.\x0a"
  Call: Call
  Atom: Expr
  Number: Number
  Ref: Ref
  Name: Name

Token kinds:
  Termination (Default_Family)
  Lexing_Failure (Default_Family)
  Whitespace (Default_Family)
  Def (Alphanumericals)
  Var (Alphanumericals)
  Error (Alphanumericals)
  Example (Alphanumericals)
  Null_Tok (Alphanumericals)
  Comma (Punctuation)
  Dot (Punctuation)
  Semicolon (Punctuation)
  Colon (Punctuation)
  L_Par (Punctuation)
  R_Par (Punctuation)
  L_Brace (Punctuation)
  R_Brace (Punctuation)
  Equal (Punctuation)
  Plus (Punctuation)
  Minus (Default_Family)
  Less_Than (Default_Family)
  Less_Than_Or_Equal (Default_Family)
  Greater_Than (Default_Family)
  Greater_Than_Or_Equal (Default_Family)
  Number (Alphanumericals)
  Identifier (Alphanumericals)
  String (Default_Family)
  Comment (Comments, is_comment)

Token families:
  Alphanumericals
  Comments
  Punctuation
  Default_Family

Use of null token kind:
Got a Precondition_Failure exception: null token kind reference

Use of null context:
Got a Precondition_Failure exception: null context

Use of null unit:
Got a Precondition_Failure exception: null unit

Use of null node:
Got a Precondition_Failure exception: null node

Parsing example.txt...
Has example.txt? -> TRUE
Has foo.txt? -> FALSE
Line 2:
  "var a = 0;"
Traversing its parsing tree...
<FooNodeList example.txt:1:1-3:15>
<Example example.txt:1:1-1:12>
<Name example.txt:1:9-1:12>
<VarDecl example.txt:2:1-2:11>
<NullQualAbsent example.txt:1:12-1:12>
<Name example.txt:2:5-2:6>
<Number example.txt:2:9-2:10>
<VarDecl example.txt:3:1-3:15>
<NullQualAbsent example.txt:2:11-2:11>
<Name example.txt:3:5-3:6>
<Addition example.txt:3:9-3:14>
<Number example.txt:3:9-3:10>
<Ref example.txt:3:13-3:14>
<Name example.txt:3:13-3:14>

Unit.Text -> "example foo\x0avar a = 0;\x0avar b = 1 + a;\x0a# Comment\x0a"
No_Lk_Unit.Text -> Got a Precondition_Failure exception: null node

Testing Get_From_Buffer
Base:
FooNode.list[1:1-1:13]
|  VarDecl[1:1-1:13]
|  |f_is_null:
|  |  NullQual.Absent[1:1-1:1]
|  |f_name:
|  |  Name[1:5-1:8]: foo
|  |f_value:
|  |  Number[1:11-1:12]: 1
Reparsed:
FooNode.list[1:1-1:12]
|  Example[1:1-1:12]
|  |f_fld_2: <null>
|  |f_fld_1:
|  |  Name[1:9-1:12]: foo
Custom rule:
Name[1:1-1:6]: my_id

Testing diagnostics-related primitives
without_error.txt:
  Has_Diagnostics? FALSE
with_error.txt:
  Has_Diagnostics? TRUE
  with_error.txt:1:12: Expected ';', got Termination

Testing various node operations:
Root.Is_Null -> FALSE
Root.Next_Sibling.Image -> None
Root.Next_Sibling.Is_Null -> TRUE
Root.Child (2).Image -> <VarDecl example.txt:2:1-2:11>
Root.Child (2).Previous_Sibling.Image -> <Example example.txt:1:1-1:12>
[...].Previous_Sibling = [...] -> TRUE
[...].Previous_Sibling = [...].Previous_Sibling.Next_Sibling -> FALSE
Root.Children:
  -> <Example example.txt:1:1-1:12>
  -> <VarDecl example.txt:2:1-2:11>
  -> <VarDecl example.txt:3:1-3:15>

Parents (<NullQualAbsent example.txt:1:12-1:12>, With_Self => FALSE):
  <VarDecl example.txt:2:1-2:11>
  <FooNodeList example.txt:1:1-3:15>
Parents (<NullQualAbsent example.txt:1:12-1:12>, With_Self => TRUE):
  <NullQualAbsent example.txt:1:12-1:12>
  <VarDecl example.txt:2:1-2:11>
  <FooNodeList example.txt:1:1-3:15>
Parents (No_Lk_Node) = Got a Precondition_Failure exception: null node

Is_Ghost (<FooNodeList example.txt:1:1-3:15>) = FALSE
Is_Ghost (<NullQualAbsent example.txt:1:12-1:12>) = TRUE
Is_Ghost (No_Lk_Node) = Got a Precondition_Failure exception: null node

Root.Text -> "example foo\x0avar a = 0;\x0avar b = 1 + a;"
No_Lk_Node.Text -> Got a Precondition_Failure exception: null node

Root.Sloc_Range -> 1:1-3:15
No_Lk_Node.Sloc_Range -> Got a Precondition_Failure exception: null node

Root.Is_Incomplete -> FALSE
No_Lk_Node.Is_Incomplete -> Got a Precondition_Failure exception: null node

Root.Print (without slocs)
... FooNode.list
... |  Example
... |  |f_fld_2: <null>
... |  |f_fld_1:
... |  |  Name: foo
... |  VarDecl
... |  |f_is_null:
... |  |  NullQual.Absent
... |  |f_name:
... |  |  Name: a
... |  |f_value:
... |  |  Number: 0
... |  VarDecl
... |  |f_is_null:
... |  |  NullQual.Absent
... |  |f_name:
... |  |  Name: b
... |  |f_value:
... |  |  Addition
... |  |  |f_lhs:
... |  |  |  Number: 1
... |  |  |f_rhs:
... |  |  |  Ref
... |  |  |  |f_name:
... |  |  |  |  Name: a
Root.Print (with slocs)
... FooNode.list[1:1-3:15]
... |  Example[1:1-1:12]
... |  |f_fld_2: <null>
... |  |f_fld_1:
... |  |  Name[1:9-1:12]: foo
... |  VarDecl[2:1-2:11]
... |  |f_is_null:
... |  |  NullQual.Absent[1:12-1:12]
... |  |f_name:
... |  |  Name[2:5-2:6]: a
... |  |f_value:
... |  |  Number[2:9-2:10]: 0
... |  VarDecl[3:1-3:15]
... |  |f_is_null:
... |  |  NullQual.Absent[2:11-2:11]
... |  |f_name:
... |  |  Name[3:5-3:6]: b
... |  |f_value:
... |  |  Addition[3:9-3:14]
... |  |  |f_lhs:
... |  |  |  Number[3:9-3:10]: 1
... |  |  |f_rhs:
... |  |  |  Ref[3:13-3:14]
... |  |  |  |f_name:
... |  |  |  |  Name[3:13-3:14]: a
No_Lk_Node.Print -> Got a Precondition_Failure exception: null node

Check the equality operator for nodes
Got a Stale_Reference_Error exception: unit was reparsed

Testing various token operations:
No_Lk_Token.Is_Null -> TRUE
First_Token.Is_Null -> FALSE

Checking the Token->Unit backlink...
No_Lk_Token.Unit -> Got a Precondition_Failure exception: null token

Token_Count -> 15
Trivia_Count -> 14

First_Token.Kind -> Example
Last_Token.Kind -> Termination
No_Lk_Token.Kind -> Got a Precondition_Failure exception: null token

No_Lk_Token.Image -> <No Token>
First_Token.Image -> <Token Kind=Example Text="example">
Last_Token.Image -> <Token Kind=Termination Text="">
Comment_Tok.Image -> <Token Kind=Comment Text="# Comment">
Last_Token.Previous.Image -> <Token Kind=Whitespace Text="\x0a">

First_Token.Text -> "example"
Last_Token.Text -> ""
No_Lk_Token.Text -> Got a Precondition_Failure exception: null token

No_Lk_Token.Next -> <No Token>
First_Token.Next -> <Token Kind=Whitespace Text=" ">
Last_Token.Next -> <No Token>

No_Lk_Token.Previous -> <No Token>
First_Token.Previous -> <No Token>
Last_Token.Previous -> <Token Kind=Whitespace Text="\x0a">

No_Token.Is_Trivia -> FALSE
First_Token.Is_Trivia -> FALSE
Last_Token.Is_Trivia -> FALSE
Last_Token.Previous.Is_Trivia -> TRUE

First_Token.Index -> 1
Last_Token.Index -> 15

No_Token.Is_Comment -> FALSE
First_Token.Is_Comment -> FALSE
Last_Token.Is_Comment -> FALSE
Comment_Tok.Is_Comment -> TRUE

Testing ordering predicate for various cases:
First_Token < Last_Token: -> TRUE
First_Token < No_Lk_Token: -> Got a Precondition_Failure exception: tokens from different units
No_Lk_Token < Last_Token: -> Got a Precondition_Failure exception: tokens from different units
First_Token < Other_Unit -> Got a Precondition_Failure exception: tokens from different units
First_Token < Stale -> Got a Stale_Reference_Error exception: unit was reparsed
Stale < Last_Token -> Got a Stale_Reference_Error exception: unit was reparsed

Testing text range for various cases:
First_Token .. Last_Token: -> "example foo\x0avar a = 0;\x0avar b = 1 + a;\x0a# Comment\x0a"
First_Token .. No_Lk_Token: -> Got a Precondition_Failure exception: tokens from different units
No_Lk_Token .. Last_Token: -> Got a Precondition_Failure exception: tokens from different units
First_Token .. Other_Unit -> Got a Precondition_Failure exception: tokens from different units
First_Token .. Stale -> Got a Stale_Reference_Error exception: unit was reparsed
Stale .. Last_Token -> Got a Stale_Reference_Error exception: unit was reparsed

Testing token equivalence for various cases:
  Non stale references...
  Is_Equivalent (<Token Kind=Example Text="example">, <Token Kind=Var Text="var">) = FALSE
  Is_Equivalent (<Token Kind=Var Text="var">, <Token Kind=Var Text="var">) = TRUE
  Is_Equivalent (<No Token>, <Token Kind=Example Text="example">) = Got a Precondition_Failure exception: null token
  Is_Equivalent (<Token Kind=Example Text="example">, <No Token>) = Got a Precondition_Failure exception: null token

  Stale references...
  Got a Stale_Reference_Error exception: unit was reparsed
  Got a Stale_Reference_Error exception: unit was reparsed

Use of stale node reference:
Got a Stale_Reference_Error exception: unit was reparsed

Check generic/specific context type converters
<FooNodeList foo.txt:1:1-1:12>

Check generic/specific unit type converters
<FooNodeList example.txt:1:1-3:15>

Check generic/specific node type converters
Root from specific: <FooNodeList example.txt:1:1-3:15>
Root from generic: <FooNodeList example.txt:1:1-3:15>

Check generic/specific grammar rule converters
MAIN_RULE_RULE -> Main_Rule
NULL_QUAL_RULE -> Null_Qual
VAR_DECL_RULE -> Var_Decl
DEF_RULE -> Def
EXPR_RULE -> Expr
CALL_RULE -> Call
ATOM_RULE -> Atom
NUMBER_RULE -> Number
REF_RULE -> Ref
NAME_RULE -> Name
Check error case... Got a Precondition_Failure exception: null grammar rule

Check that equality takes metadata into account
N = N2 (same metadata): TRUE
N = N2 (/= metadata, field not used in eq): TRUE
N = N2 (/= metadata, field used in eq): FALSE

== introspection_types.adb ==

All types
=========

* AnalysisUnit
  ANALYSIS_UNIT_CATEGORY
* BigInt
  BIG_INT_CATEGORY
* Bool
  BOOL_CATEGORY
* Character
  CHAR_CATEGORY
* Int
  INT_CATEGORY
* SourceLocation
  SOURCE_LOCATION_CATEGORY
* SourceLocationRange
  SOURCE_LOCATION_RANGE_CATEGORY
* String
  STRING_CATEGORY
* Token
  TOKEN_CATEGORY
* Symbol
  SYMBOL_CATEGORY
* AnalysisUnitKind
  ENUM_CATEGORY
  is an enum
* LookupKind
  ENUM_CATEGORY
  is an enum
* DesignatedEnvKind
  ENUM_CATEGORY
  is an enum
* GrammarRule
  ENUM_CATEGORY
  is an enum
* BigInt.array
  ARRAY_CATEGORY
  is an array
* FooNode.array
  ARRAY_CATEGORY
  is an array
* Expr.array
  ARRAY_CATEGORY
  is an array
* AnalysisUnit.array
  ARRAY_CATEGORY
  is an array
* BigInt.iterator
  ITERATOR_CATEGORY
  is an iterator
* NodeResult
  STRUCT_CATEGORY
  is a struct
* Point
  STRUCT_CATEGORY
  is a struct
* FooNode
  STRUCT_CATEGORY
  is a node
* BaseExample
  STRUCT_CATEGORY
  is a node
* Example
  STRUCT_CATEGORY
  is a node
* Def
  STRUCT_CATEGORY
  is a node
* Expr
  STRUCT_CATEGORY
  is a node
* Addition
  STRUCT_CATEGORY
  is a node
* Call
  STRUCT_CATEGORY
  is a node
* Number
  STRUCT_CATEGORY
  is a node
* Ref
  STRUCT_CATEGORY
  is a node
* FooNodeBaseList
  STRUCT_CATEGORY
  is a node
* Expr.list
  STRUCT_CATEGORY
  is a node
* FooNode.list
  STRUCT_CATEGORY
  is a node
* Name.list
  STRUCT_CATEGORY
  is a node
* Name
  STRUCT_CATEGORY
  is a node
* NullQual
  STRUCT_CATEGORY
  is a node
* NullQual.Absent
  STRUCT_CATEGORY
  is a node
* NullQual.Present
  STRUCT_CATEGORY
  is a node
* VarDecl
  STRUCT_CATEGORY
  is a node

Language: null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
To_Index: Null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
From_Index: out of range type index: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid type index
Debug_Name: Null T argument: <No_Type_Ref>
Category: Null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Enum types
==========

Analysis_Unit_Kind ( 11)
  Default value: <No_Enum_Value_Ref>

  1: Unit_Specification
  2: Unit_Body

Lookup_Kind ( 12)
  Default value: <No_Enum_Value_Ref>

  1: Recursive
  2: Flat
  3: Minimal

Designated_Env_Kind ( 13)
  Default value: DesignatedEnvKind.none

  1: None
  2: Current_Env
  3: Named_Env
  4: Direct_Env

Grammar_Rule ( 14)
  Default value: <No_Enum_Value_Ref>

  1: Main_Rule_Rule
  2: Null_Qual_Rule
  3: Var_Decl_Rule
  4: Def_Rule
  5: Expr_Rule
  6: Call_Rule
  7: Atom_Rule
  8: Number_Rule
  9: Ref_Rule
  10: Name_Rule

Is_Enum_Type: Null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference

Invalid args for Enum_Type_Name:
Null Enum argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-enum Enum argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid enum type

Invalid args for Enum_Last_Value:
Null Enum argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-enum Enum argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid enum type

Invalid args for Enum_Default_Value:
Null Enum argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-enum Enum argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid enum type

Enum_Value_Name: Null Value argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null enum value reference

To_Index: Null Value argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null enum value reference
From_Index: out of range enum value index: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid enum value index

Arrays
======

BigInt.array
Array of BigInt

FooNode.array
Array of FooNode

Expr.array
Array of Expr

AnalysisUnit.array
Array of AnalysisUnit

Is_Array_Type: Null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference

Invalid args for Array_Element_Type:
Null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-array T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid array type

Iterator types
==============

BigInt.iteratorIterator of BigInt

Is_Iterator_Type: Null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference

Invalid args for Iterator_Element_Type:
Null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-iterator T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid iterator type

Structs
=======

Node_Result

Point

Is_Struct_Type: Null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference

Invalid args for Struct_Type_Name:
Null Struct argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-struct Struct argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid struct type

Nodes
=====

Foo_Node ( 22)
  is abstract
  base = Bad_Type_Error: trying to get base type of root node
  last derivation = Var_Decl ( 39)
  derivations:
    Base_Example ( 23)
    Def ( 25)
    Expr ( 26)
    Foo_Node_Base_List ( 31)
    Name ( 35)
    Null_Qual ( 36)
    Var_Decl ( 39)

Base_Example ( 23)
  is abstract
  base = Foo_Node ( 22)
  last derivation = Example ( 24)
  derivations:
    Example ( 24)

Example ( 24)
  base = Base_Example ( 23)
  last derivation = Example ( 24)
  derivations:
    <none>

Def ( 25)
  base = Foo_Node ( 22)
  last derivation = Def ( 25)
  derivations:
    <none>

Expr ( 26)
  is abstract
  base = Foo_Node ( 22)
  last derivation = Ref ( 30)
  derivations:
    Addition ( 27)
    Call ( 28)
    Number ( 29)
    Ref ( 30)

Addition ( 27)
  base = Expr ( 26)
  last derivation = Addition ( 27)
  derivations:
    <none>

Call ( 28)
  base = Expr ( 26)
  last derivation = Call ( 28)
  derivations:
    <none>

Number ( 29)
  is a token node (Number token)
  base = Expr ( 26)
  last derivation = Number ( 29)
  derivations:
    <none>

Ref ( 30)
  base = Expr ( 26)
  last derivation = Ref ( 30)
  derivations:
    <none>

Foo_Node_Base_List ( 31)
  is abstract
  base = Foo_Node ( 22)
  last derivation = Name_List ( 34)
  derivations:
    Expr_List ( 32)
    Foo_Node_List ( 33)
    Name_List ( 34)

Expr_List ( 32)
  is a list node
  base = Foo_Node_Base_List ( 31)
  last derivation = Expr_List ( 32)
  derivations:
    <none>

Foo_Node_List ( 33)
  is a list node
  base = Foo_Node_Base_List ( 31)
  last derivation = Foo_Node_List ( 33)
  derivations:
    <none>

Name_List ( 34)
  is a list node
  base = Foo_Node_Base_List ( 31)
  last derivation = Name_List ( 34)
  derivations:
    <none>

Name ( 35)
  is a token node (Identifier token)
  base = Foo_Node ( 22)
  last derivation = Name ( 35)
  derivations:
    <none>

Null_Qual ( 36)
  is abstract
  base = Foo_Node ( 22)
  last derivation = Null_Qual_Present ( 38)
  derivations:
    Null_Qual_Absent ( 37)
    Null_Qual_Present ( 38)

Null_Qual_Absent ( 37)
  base = Null_Qual ( 36)
  last derivation = Null_Qual_Absent ( 37)
  derivations:
    <none>

Null_Qual_Present ( 38)
  base = Null_Qual ( 36)
  last derivation = Null_Qual_Present ( 38)
  derivations:
    <none>

Var_Decl ( 39)
  base = Foo_Node ( 22)
  last derivation = Var_Decl ( 39)
  derivations:
    <none>

Is_Node_Type: Null T argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference

Invalid args for Node_Type_Name:
Null Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-node Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid node type

Invalid args for Is_Abstract:
Null Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-node Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid node type

Invalid args for Is_Concrete:
Null Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-node Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid node type

Invalid args for Base_Type:
Null Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-node Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid node type
Root Node argument: LANGKIT_SUPPORT.ERRORS.INTROSPECTION.BAD_TYPE_ERROR: trying to get base type of root node

Invalid args for Derived_Types:
Null Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-node Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid node type

Invalid args for Last_Derived_Type:
Null Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-node Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid node type

Check Type_Ref constants
Checking: FooNode type ref
Checking: Number type ref

Check Struct_Member_Ref constants
Checking: Addition.f_lhs member ref
Checking: FooNode.parent member ref

Check Is_Derived_From:
Checking: root derives from root
Checking: expr derives from root
Checking: addition derives from root
Checking: ref does not derive from number
Null Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-node Node argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid node type
Null Parent argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-node Parent argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid node type

Members
=======

For Node_Result
  N (NodeResult.n: 1)
  E (NodeResult.e: 2)

For Point
  Label (Point.label: 3)
  X (Point.x: 4)
  Y (Point.y: 5)

For Foo_Node
  Parent (FooNode.parent: 19)
  Parents (FooNode.parents: 20)
  Children (FooNode.children: 21)
  Token_Start (FooNode.token_start: 22)
  Token_End (FooNode.token_end: 23)
  Child_Index (FooNode.child_index: 24)
  Previous_Sibling (FooNode.previous_sibling: 25)
  Next_Sibling (FooNode.next_sibling: 26)
  Unit (FooNode.unit: 27)
  Is_Ghost (FooNode.is_ghost: 28)
  Full_Sloc_Image (FooNode.full_sloc_image: 29)

For Base_Example
  Parent (FooNode.parent: 19)
  Parents (FooNode.parents: 20)
  Children (FooNode.children: 21)
  Token_Start (FooNode.token_start: 22)
  Token_End (FooNode.token_end: 23)
  Child_Index (FooNode.child_index: 24)
  Previous_Sibling (FooNode.previous_sibling: 25)
  Next_Sibling (FooNode.next_sibling: 26)
  Unit (FooNode.unit: 27)
  Is_Ghost (FooNode.is_ghost: 28)
  Full_Sloc_Image (FooNode.full_sloc_image: 29)
  F_Fld_1 (BaseExample.f_fld_1: 6)
  F_Fld_2 (BaseExample.f_fld_2: 7)
  P_Id_Bool (BaseExample.p_id_bool: 30)

For Example
  Parent (FooNode.parent: 19)
  Parents (FooNode.parents: 20)
  Children (FooNode.children: 21)
  Token_Start (FooNode.token_start: 22)
  Token_End (FooNode.token_end: 23)
  Child_Index (FooNode.child_index: 24)
  Previous_Sibling (FooNode.previous_sibling: 25)
  Next_Sibling (FooNode.next_sibling: 26)
  Unit (FooNode.unit: 27)
  Is_Ghost (FooNode.is_ghost: 28)
  Full_Sloc_Image (FooNode.full_sloc_image: 29)
  P_Id_Bool (BaseExample.p_id_bool: 30)
  F_Fld_2 (BaseExample.f_fld_2: 7)
  F_Fld_1 (BaseExample.f_fld_1: 6)
  P_Prop (Example.p_prop: 31)
  P_Result (Example.p_result: 32)
  P_Id_Int (Example.p_id_int: 33)
  P_Id_Bigint (Example.p_id_bigint: 34)
  P_Id_Char (Example.p_id_char: 35)
  P_Id_Token (Example.p_id_token: 36)
  P_Id_Sloc (Example.p_id_sloc: 37)
  P_Id_Sym (Example.p_id_sym: 38)
  P_Id_Unit (Example.p_id_unit: 39)
  P_Id_Root_Node (Example.p_id_root_node: 40)
  P_Id_Name (Example.p_id_name: 41)
  P_Id_Unit_Kind (Example.p_id_unit_kind: 42)
  P_Id_Node_Array (Example.p_id_node_array: 43)
  P_Id_Expr_Array (Example.p_id_expr_array: 44)
  P_Id_Bigint_Array (Example.p_id_bigint_array: 45)
  P_Id_Unit_Array (Example.p_id_unit_array: 46)
  P_Create_Bigint_Iterator (Example.p_create_bigint_iterator: 47)
  P_Id_Bigint_Iterator (Example.p_id_bigint_iterator: 48)
  P_Id_Dflt_Bool (Example.p_id_dflt_bool: 49)
  P_Id_Dflt_Int (Example.p_id_dflt_int: 50)
  P_Id_Dflt_Char (Example.p_id_dflt_char: 51)
  P_Id_Dflt_Root_Node (Example.p_id_dflt_root_node: 52)
  P_With_Md (Example.p_with_md: 53)

For Def
  Parent (FooNode.parent: 19)
  Parents (FooNode.parents: 20)
  Children (FooNode.children: 21)
  Token_Start (FooNode.token_start: 22)
  Token_End (FooNode.token_end: 23)
  Child_Index (FooNode.child_index: 24)
  Previous_Sibling (FooNode.previous_sibling: 25)
  Next_Sibling (FooNode.next_sibling: 26)
  Unit (FooNode.unit: 27)
  Is_Ghost (FooNode.is_ghost: 28)
  Full_Sloc_Image (FooNode.full_sloc_image: 29)
  F_Name (Def.f_name: 8)
  F_Args (Def.f_args: 9)
  F_Expr (Def.f_expr: 10)

For Expr
  Parent (FooNode.parent: 19)
  Parents (FooNode.parents: 20)
  Children (FooNode.children: 21)
  Token_Start (FooNode.token_start: 22)
  Token_End (FooNode.token_end: 23)
  Child_Index (FooNode.child_index: 24)
  Previous_Sibling (FooNode.previous_sibling: 25)
  Next_Sibling (FooNode.next_sibling: 26)
  Unit (FooNode.unit: 27)
  Is_Ghost (FooNode.is_ghost: 28)
  Full_Sloc_Image (FooNode.full_sloc_image: 29)

For Addition
  Parent (FooNode.parent: 19)
  Parents (FooNode.parents: 20)
  Children (FooNode.children: 21)
  Token_Start (FooNode.token_start: 22)
  Token_End (FooNode.token_end: 23)
  Child_Index (FooNode.child_index: 24)
  Previous_Sibling (FooNode.previous_sibling: 25)
  Next_Sibling (FooNode.next_sibling: 26)
  Unit (FooNode.unit: 27)
  Is_Ghost (FooNode.is_ghost: 28)
  Full_Sloc_Image (FooNode.full_sloc_image: 29)
  F_Lhs (Addition.f_lhs: 11)
  F_Rhs (Addition.f_rhs: 12)

For Call
  Parent (FooNode.parent: 19)
  Parents (FooNode.parents: 20)
  Children (FooNode.children: 21)
  Token_Start (FooNode.token_start: 22)
  Token_End (FooNode.token_end: 23)
  Child_Index (FooNode.child_index: 24)
  Previous_Sibling (FooNode.previous_sibling: 25)
  Next_Sibling (FooNode.next_sibling: 26)
  Unit (FooNode.unit: 27)
  Is_Ghost (FooNode.is_ghost: 28)
  Full_Sloc_Image (FooNode.full_sloc_image: 29)
  F_Name (Call.f_name: 13)
  F_Args (Call.f_args: 14)

For Number
  Parent (FooNode.parent: 19)
  Parents (FooNode.parents: 20)
  Children (FooNode.children: 21)
  Token_Start (FooNode.token_start: 22)
  Token_End (FooNode.token_end: 23)
  Child_Index (FooNode.child_index: 24)
  Previous_Sibling (FooNode.previous_sibling: 25)
  Next_Sibling (FooNode.next_sibling: 26)
  Unit (FooNode.unit: 27)
  Is_Ghost (FooNode.is_ghost: 28)
  Full_Sloc_Image (FooNode.full_sloc_image: 29)

For Ref
  Parent (FooNode.parent: 19)
  Parents (FooNode.parents: 20)
  Children (FooNode.children: 21)
  Token_Start (FooNode.token_start: 22)
  Token_End (FooNode.token_end: 23)
  Child_Index (FooNode.child_index: 24)
  Previous_Sibling (FooNode.previous_sibling: 25)
  Next_Sibling (FooNode.next_sibling: 26)
  Unit (FooNode.unit: 27)
  Is_Ghost (FooNode.is_ghost: 28)
  Full_Sloc_Image (FooNode.full_sloc_image: 29)
  F_Name (Ref.f_name: 15)

For Foo_Node_Base_List
  Parent (FooNode.parent: 19)
  Parents (FooNode.parents: 20)
  Children (FooNode.children: 21)
  Token_Start (FooNode.token_start: 22)
  Token_End (FooNode.token_end: 23)
  Child_Index (FooNode.child_index: 24)
  Previous_Sibling (FooNode.previous_sibling: 25)
  Next_Sibling (FooNode.next_sibling: 26)
  Unit (FooNode.unit: 27)
  Is_Ghost (FooNode.is_ghost: 28)
  Full_Sloc_Image (FooNode.full_sloc_image: 29)

For Expr_List
  Parent (FooNode.parent: 19)
  Parents (FooNode.parents: 20)
  Children (FooNode.children: 21)
  Token_Start (FooNode.token_start: 22)
  Token_End (FooNode.token_end: 23)
  Child_Index (FooNode.child_index: 24)
  Previous_Sibling (FooNode.previous_sibling: 25)
  Next_Sibling (FooNode.next_sibling: 26)
  Unit (FooNode.unit: 27)
  Is_Ghost (FooNode.is_ghost: 28)
  Full_Sloc_Image (FooNode.full_sloc_image: 29)

For Foo_Node_List
  Parent (FooNode.parent: 19)
  Parents (FooNode.parents: 20)
  Children (FooNode.children: 21)
  Token_Start (FooNode.token_start: 22)
  Token_End (FooNode.token_end: 23)
  Child_Index (FooNode.child_index: 24)
  Previous_Sibling (FooNode.previous_sibling: 25)
  Next_Sibling (FooNode.next_sibling: 26)
  Unit (FooNode.unit: 27)
  Is_Ghost (FooNode.is_ghost: 28)
  Full_Sloc_Image (FooNode.full_sloc_image: 29)

For Name_List
  Parent (FooNode.parent: 19)
  Parents (FooNode.parents: 20)
  Children (FooNode.children: 21)
  Token_Start (FooNode.token_start: 22)
  Token_End (FooNode.token_end: 23)
  Child_Index (FooNode.child_index: 24)
  Previous_Sibling (FooNode.previous_sibling: 25)
  Next_Sibling (FooNode.next_sibling: 26)
  Unit (FooNode.unit: 27)
  Is_Ghost (FooNode.is_ghost: 28)
  Full_Sloc_Image (FooNode.full_sloc_image: 29)

For Name
  Parent (FooNode.parent: 19)
  Parents (FooNode.parents: 20)
  Children (FooNode.children: 21)
  Token_Start (FooNode.token_start: 22)
  Token_End (FooNode.token_end: 23)
  Child_Index (FooNode.child_index: 24)
  Previous_Sibling (FooNode.previous_sibling: 25)
  Next_Sibling (FooNode.next_sibling: 26)
  Unit (FooNode.unit: 27)
  Is_Ghost (FooNode.is_ghost: 28)
  Full_Sloc_Image (FooNode.full_sloc_image: 29)

For Null_Qual
  Parent (FooNode.parent: 19)
  Parents (FooNode.parents: 20)
  Children (FooNode.children: 21)
  Token_Start (FooNode.token_start: 22)
  Token_End (FooNode.token_end: 23)
  Child_Index (FooNode.child_index: 24)
  Previous_Sibling (FooNode.previous_sibling: 25)
  Next_Sibling (FooNode.next_sibling: 26)
  Unit (FooNode.unit: 27)
  Is_Ghost (FooNode.is_ghost: 28)
  Full_Sloc_Image (FooNode.full_sloc_image: 29)
  P_As_Bool (NullQual.p_as_bool: 54)

For Null_Qual_Absent
  Parent (FooNode.parent: 19)
  Parents (FooNode.parents: 20)
  Children (FooNode.children: 21)
  Token_Start (FooNode.token_start: 22)
  Token_End (FooNode.token_end: 23)
  Child_Index (FooNode.child_index: 24)
  Previous_Sibling (FooNode.previous_sibling: 25)
  Next_Sibling (FooNode.next_sibling: 26)
  Unit (FooNode.unit: 27)
  Is_Ghost (FooNode.is_ghost: 28)
  Full_Sloc_Image (FooNode.full_sloc_image: 29)
  P_As_Bool (NullQual.p_as_bool: 54)

For Null_Qual_Present
  Parent (FooNode.parent: 19)
  Parents (FooNode.parents: 20)
  Children (FooNode.children: 21)
  Token_Start (FooNode.token_start: 22)
  Token_End (FooNode.token_end: 23)
  Child_Index (FooNode.child_index: 24)
  Previous_Sibling (FooNode.previous_sibling: 25)
  Next_Sibling (FooNode.next_sibling: 26)
  Unit (FooNode.unit: 27)
  Is_Ghost (FooNode.is_ghost: 28)
  Full_Sloc_Image (FooNode.full_sloc_image: 29)
  P_As_Bool (NullQual.p_as_bool: 54)

For Var_Decl
  Parent (FooNode.parent: 19)
  Parents (FooNode.parents: 20)
  Children (FooNode.children: 21)
  Token_Start (FooNode.token_start: 22)
  Token_End (FooNode.token_end: 23)
  Child_Index (FooNode.child_index: 24)
  Previous_Sibling (FooNode.previous_sibling: 25)
  Next_Sibling (FooNode.next_sibling: 26)
  Unit (FooNode.unit: 27)
  Is_Ghost (FooNode.is_ghost: 28)
  Full_Sloc_Image (FooNode.full_sloc_image: 29)
  F_Is_Null (VarDecl.f_is_null: 16)
  F_Name (VarDecl.f_name: 17)
  F_Value (VarDecl.f_value: 18)

Detailed list of members
========================

N (NodeResult.n: 1)
  owner: NodeResult
  type: Example
  no argument

E (NodeResult.e: 2)
  owner: NodeResult
  type: Example
  no argument

Label (Point.label: 3)
  owner: Point
  type: String
  no argument

X (Point.x: 4)
  owner: Point
  type: BigInt
  no argument

Y (Point.y: 5)
  owner: Point
  type: BigInt
  no argument

F_Fld_1 (BaseExample.f_fld_1: 6)
  owner: BaseExample
  type: Name
  no argument

F_Fld_2 (BaseExample.f_fld_2: 7)
  owner: BaseExample
  type: FooNode
  no argument

F_Name (Def.f_name: 8)
  owner: Def
  type: Name
  no argument

F_Args (Def.f_args: 9)
  owner: Def
  type: Name.list
  no argument

F_Expr (Def.f_expr: 10)
  owner: Def
  type: Expr
  no argument

F_Lhs (Addition.f_lhs: 11)
  owner: Addition
  type: Expr
  no argument

F_Rhs (Addition.f_rhs: 12)
  owner: Addition
  type: Expr
  no argument

F_Name (Call.f_name: 13)
  owner: Call
  type: Name
  no argument

F_Args (Call.f_args: 14)
  owner: Call
  type: Expr.list
  no argument

F_Name (Ref.f_name: 15)
  owner: Ref
  type: Name
  no argument

F_Is_Null (VarDecl.f_is_null: 16)
  owner: VarDecl
  type: NullQual
  no argument

F_Name (VarDecl.f_name: 17)
  owner: VarDecl
  type: Name
  no argument

F_Value (VarDecl.f_value: 18)
  owner: VarDecl
  type: Expr
  no argument

Parent (FooNode.parent: 19)
  owner: FooNode
  is a property
  type: FooNode
  no argument

Parents (FooNode.parents: 20)
  owner: FooNode
  is a property
  type: FooNode.array
  arguments:
    With_Self: Bool := True

Children (FooNode.children: 21)
  owner: FooNode
  is a property
  type: FooNode.array
  no argument

Token_Start (FooNode.token_start: 22)
  owner: FooNode
  is a property
  type: Token
  no argument

Token_End (FooNode.token_end: 23)
  owner: FooNode
  is a property
  type: Token
  no argument

Child_Index (FooNode.child_index: 24)
  owner: FooNode
  is a property
  type: Int
  no argument

Previous_Sibling (FooNode.previous_sibling: 25)
  owner: FooNode
  is a property
  type: FooNode
  no argument

Next_Sibling (FooNode.next_sibling: 26)
  owner: FooNode
  is a property
  type: FooNode
  no argument

Unit (FooNode.unit: 27)
  owner: FooNode
  is a property
  type: AnalysisUnit
  no argument

Is_Ghost (FooNode.is_ghost: 28)
  owner: FooNode
  is a property
  type: Bool
  no argument

Full_Sloc_Image (FooNode.full_sloc_image: 29)
  owner: FooNode
  is a property
  type: String
  no argument

P_Id_Bool (BaseExample.p_id_bool: 30)
  owner: BaseExample
  is a property
  type: Bool
  arguments:
    Id: Bool

P_Prop (Example.p_prop: 31)
  owner: Example
  is a property
  type: Point
  arguments:
    P: Point

P_Result (Example.p_result: 32)
  owner: Example
  is a property
  type: NodeResult
  no argument

P_Id_Int (Example.p_id_int: 33)
  owner: Example
  is a property
  type: Int
  arguments:
    Id: Int

P_Id_Bigint (Example.p_id_bigint: 34)
  owner: Example
  is a property
  type: BigInt
  arguments:
    Id: BigInt

P_Id_Char (Example.p_id_char: 35)
  owner: Example
  is a property
  type: Character
  arguments:
    Id: Character

P_Id_Token (Example.p_id_token: 36)
  owner: Example
  is a property
  type: Token
  arguments:
    Id: Token

P_Id_Sloc (Example.p_id_sloc: 37)
  owner: Example
  is a property
  type: SourceLocation
  arguments:
    Id: SourceLocation

P_Id_Sym (Example.p_id_sym: 38)
  owner: Example
  is a property
  type: Symbol
  arguments:
    Id: Symbol

P_Id_Unit (Example.p_id_unit: 39)
  owner: Example
  is a property
  type: AnalysisUnit
  arguments:
    Id: AnalysisUnit

P_Id_Root_Node (Example.p_id_root_node: 40)
  owner: Example
  is a property
  type: FooNode
  arguments:
    Id: FooNode

P_Id_Name (Example.p_id_name: 41)
  owner: Example
  is a property
  type: Name
  arguments:
    Id: Name

P_Id_Unit_Kind (Example.p_id_unit_kind: 42)
  owner: Example
  is a property
  type: AnalysisUnitKind
  arguments:
    Id: AnalysisUnitKind

P_Id_Node_Array (Example.p_id_node_array: 43)
  owner: Example
  is a property
  type: FooNode.array
  arguments:
    Id: FooNode.array

P_Id_Expr_Array (Example.p_id_expr_array: 44)
  owner: Example
  is a property
  type: Expr.array
  arguments:
    Id: Expr.array

P_Id_Bigint_Array (Example.p_id_bigint_array: 45)
  owner: Example
  is a property
  type: BigInt.array
  arguments:
    Id: BigInt.array

P_Id_Unit_Array (Example.p_id_unit_array: 46)
  owner: Example
  is a property
  type: AnalysisUnit.array
  arguments:
    Id: AnalysisUnit.array

P_Create_Bigint_Iterator (Example.p_create_bigint_iterator: 47)
  owner: Example
  is a property
  type: BigInt.iterator
  no argument

P_Id_Bigint_Iterator (Example.p_id_bigint_iterator: 48)
  owner: Example
  is a property
  type: BigInt.iterator
  arguments:
    Id: BigInt.iterator

P_Id_Dflt_Bool (Example.p_id_dflt_bool: 49)
  owner: Example
  is a property
  type: Bool
  arguments:
    Id: Bool := True

P_Id_Dflt_Int (Example.p_id_dflt_int: 50)
  owner: Example
  is a property
  type: Int
  arguments:
    Id: Int := 42

P_Id_Dflt_Char (Example.p_id_dflt_char: 51)
  owner: Example
  is a property
  type: Character
  arguments:
    Id: Character := '\x00'

P_Id_Dflt_Root_Node (Example.p_id_dflt_root_node: 52)
  owner: Example
  is a property
  type: FooNode
  arguments:
    Id: FooNode := <No node>

P_With_Md (Example.p_with_md: 53)
  owner: Example
  is a property
  type: Example
  arguments:
    Md1: Bool
    Md2: Bool

P_As_Bool (NullQual.p_as_bool: 54)
  owner: NullQual
  is a property
  type: Bool
  no argument

Is_Property: Null Member argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null struct member reference

Invalid args for Members:
Null Struct argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Non-struct Struct argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid base struct type

Member_Name: Null Member argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null struct member reference

Member_Type: Null Member argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null struct member reference

To_Index: Null Member argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null struct member reference
From_Index: out of range member index: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid struct member index
Member_Last_Argument: Null Member argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null struct member reference

Invalid args for Member_Argument_Type:
Null Member argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null struct member reference
Invalid Argument argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid struct member argument

Invalid args for Member_Argument_Name:
Null Member argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null struct member reference
Invalid Argument argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid struct member argument

Invalid args for Member_Argument_Default_Value:
Null Member argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null struct member reference
Invalid Argument argument: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid struct member argument

Debug_Name: Null Member argument: <No_Struct_Member_Ref>

Name maps
=========

Enum types as UPPER
analysis_unit_kind => <No_Type_Ref>
ANALYSIS_UNIT_KIND => AnalysisUnitKind
UNIT_BODY => <No_Enum_Value_Ref>
unit_body => AnalysisUnitKind.unit_body
VAR_DECL => <No_Type_Ref>
var_decl => VarDecl
F_NAME => <No_Struct_Member_Ref>
f_name => VarDecl.f_name

Enum values as UPPER
ANALYSIS_UNIT_KIND => <No_Type_Ref>
analysis_unit_kind => AnalysisUnitKind
unit_body => <No_Enum_Value_Ref>
UNIT_BODY => AnalysisUnitKind.unit_body
VAR_DECL => <No_Type_Ref>
var_decl => VarDecl
F_NAME => <No_Struct_Member_Ref>
f_name => VarDecl.f_name

Struct types as UPPER
ANALYSIS_UNIT_KIND => <No_Type_Ref>
analysis_unit_kind => AnalysisUnitKind
UNIT_BODY => <No_Enum_Value_Ref>
unit_body => AnalysisUnitKind.unit_body
var_decl => <No_Type_Ref>
VAR_DECL => VarDecl
F_NAME => <No_Struct_Member_Ref>
f_name => VarDecl.f_name

Struct members as UPPER
ANALYSIS_UNIT_KIND => <No_Type_Ref>
analysis_unit_kind => AnalysisUnitKind
UNIT_BODY => <No_Enum_Value_Ref>
unit_body => AnalysisUnitKind.unit_body
VAR_DECL => <No_Type_Ref>
var_decl => VarDecl
f_name => <No_Struct_Member_Ref>
F_NAME => VarDecl.f_name

Invalid args for Lookup_Type
Uninitialized name map: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: uninitialized name map
Null symbol: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null symbol

Invalid args for Lookup_Enum_Value
Uninitialized name map: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: uninitialized name map
Null enum type: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Null symbol: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null symbol

Invalid args for Lookup_Struct_Member
Uninitialized name map: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: uninitialized name map
Null struct type: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Null symbol: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null symbol

== introspection_values.adb ==
Value comparisons
=================

<No_Value_Ref> = <No_Value_Ref> => TRUE
<No_Value_Ref> = False => FALSE
False = False => TRUE
True = False => FALSE
False = 1 => FALSE

Value constructors/getters
==========================

Inspect: <No_Value_Ref>
  Type_Of: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null value reference
Inspect: <No analysis unit>
  Type_Of: AnalysisUnit
Inspect: <Unit for example.txt>
  Type_Of: AnalysisUnit
Inspect: BigInt(9111111111124567890)
  Type_Of: BigInt
Inspect: True
  Type_Of: Bool
Inspect: False
  Type_Of: Bool
Inspect: 'A'
  Type_Of: Character
Inspect: 42
  Type_Of: Int
Inspect: 1:2-3:4
  Type_Of: SourceLocationRange
Inspect: "hello, world!"
  Type_Of: String
Inspect: <Token Kind=Example Text="example">
  Type_Of: Token
Inspect: 1:1
  Type_Of: SourceLocation
Inspect: Symbol("foo_bar42")
  Type_Of: Symbol
Inspect: <No node>
  Type_Of: FooNode
Inspect: <FooNodeList example.txt:1:1-3:15>
  Type_Of: FooNode.list

Enum values introspection
=========================

Create_Enum: null enum value ref: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null enum value reference
Inspect: Analysis_Unit_Kind(UNIT_SPECIFICATION)
  Type_Of: AnalysisUnitKind

Array values introspection
==========================

Create_Array: null array type: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Create_Array: null value reference: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null value reference
Create_Array: value type mismatch: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: unexpected value type
Inspect: Array of 0 FooNode elements
  Type_Of: FooNode.array
Inspect: Array of 1 FooNode elements
  Type_Of: FooNode.array
As_Array: null value: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null value reference
As_Array: value type mismatch: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: non-array value
Array_Length: null value: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null value reference
Array_Length: value type mismatch: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: non-array value
Array_Item: null value: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null value reference
Array_Item: value type mismatch: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: non-array value

Array_Item: index checks
  array: Array of 3 BigInt elements
  ( 1): BigInt(10)
  ( 2): BigInt(20)
  ( 3): BigInt(30)
  ( 4): LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: out-of-bounds array index
  ( 5): LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: out-of-bounds array index

Iterator values introspection
=============================

Iterator_Next: null value: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null value reference
Iterator_Next: value type mismatch: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: non-iterator value

Full iteration through Iterator_Next:
Inspect: Iterator on BigInt
  Type_Of: BigInt.iterator

Inspect: BigInt(1)
  Type_Of: BigInt
Inspect: BigInt(2)
  Type_Of: BigInt
Inspect: BigInt(3)
  Type_Of: BigInt

Struct values introspection
===========================

Create_Struct: null struct type: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference
Create_Struct: invalid struct type: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid struct type
Create_Struct: null value reference: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid null value
Create_Struct: value type mismatch: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: member type mismatch
Create_Struct: value count mismatch: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: NodeResult has 2 members but got 1 value(s)
Inspect: Point("hello world!", BigInt(10), BigInt(20))
  Type_Of: Point
Eval_Member: null struct value: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null value reference
Eval_Member: invalid struct type: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: invalid base struct type
Eval_Member: no such member: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: Point does not have the NodeResult.n member
Eval_Member: too many arguments: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: Point takes 0 arguments but got 1 values
Eval_Member: argument type mismatch: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: unexpected type for argument 1
Eval_Member: no such node member: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: FooNode.list does not have the BaseExample.p_id_bool member
Eval_Member: Point_Label on Point("hello world!", BigInt(10), BigInt(20)):
Inspect: "hello world!"
  Type_Of: String

Eval_Member: BaseExample.p_id_bool:
Inspect: True
  Type_Of: Bool

Eval_Member: Example.p_id_int:
Inspect: 42
  Type_Of: Int

Eval_Member: Example.p_id_bigint:
Inspect: BigInt(1234567890987654321)
  Type_Of: BigInt

Eval_Member: Example.p_id_char:
Inspect: 'A'
  Type_Of: Character

Eval_Member: Example.p_id_token:
Inspect: <Token Kind=Example Text="example">
  Type_Of: Token

Eval_Member: Example.p_id_sloc:
Inspect: 3:15
  Type_Of: SourceLocation

Eval_Member: Example.p_id_sym:
Inspect: Symbol("foobar")
  Type_Of: Symbol

Eval_Member: Example.p_id_unit:
Inspect: <Unit for example.txt>
  Type_Of: AnalysisUnit

Eval_Member: Example.p_id_root_node:
Inspect: <FooNodeList example.txt:1:1-3:15>
  Type_Of: FooNode.list

Eval_Member: Example.p_id_name:
Inspect: <No node>
  Type_Of: FooNode

Eval_Member: Example.p_id_name:
Inspect: <Name example.txt:2:5-2:6>
  Type_Of: Name

Eval_Member: Example.p_id_unit_kind:
Inspect: Analysis_Unit_Kind(UNIT_SPECIFICATION)
  Type_Of: AnalysisUnitKind

Eval_Member: Example.p_id_node_array:
Inspect: Array of 1 FooNode elements
  Type_Of: FooNode.array

Eval_Member: Example.p_id_expr_array:
Inspect: Array of 1 Expr elements
  Type_Of: Expr.array

Eval_Member: Example.p_id_bigint_iterator:
Inspect: Iterator on BigInt
  Type_Of: BigInt.iterator

Eval_Node_Member: abstract field with null derivation:
Inspect: <Name example.txt:1:9-1:12>
  Type_Of: Name

Eval_Node_Member: abstract field with concrete derivation:
Inspect: <No node>
  Type_Of: FooNode
Eval_Node_Member: null node value: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: the null node has no member
Eval_Node_Member: P_Id_Bool:
Inspect: True
  Type_Of: Bool

Eval_Syntax_Field: null node value: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: the null node has no member
Eval_Syntax_Field: non syntax field: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: syntax field expected
Eval_Syntax_Field: no such field: LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: Example does not have the VarDecl.f_name member
Eval_Syntax_Field: F_Fld_1:
  Name[1:9-1:12]: foo

Type matching
=============

Basic cases:
32 matches Int? True
32 matches Bool? False
<FooNodeList example.txt:1:1-3:15> matches Bool? False

Nodes:
... with the Value_Ref API:
<FooNodeList example.txt:1:1-3:15> matches FooNode? True
<FooNodeList example.txt:1:1-3:15> matches VarDecl? False
<No node> matches FooNode? True
<No node> matches VarDecl? True

... with the Lk_Node API:
<FooNodeList example.txt:1:1-3:15> matches FooNode? True
<FooNodeList example.txt:1:1-3:15> matches VarDecl? False
None matches FooNode? True
None matches VarDecl? True

Error cases:
<No_Value_Ref> matches Int? LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null value reference
<No node> matches <No_Type_Ref>? LANGKIT_SUPPORT.ERRORS.PRECONDITION_FAILURE: null type reference


== hash.adb ==
hash.adb: no error

Done
