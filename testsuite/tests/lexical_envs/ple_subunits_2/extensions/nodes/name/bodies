--  vim: ft=ada

function Name_P_Referenced_Unit_Or_Error
  (Node : Bare_Name; Or_Error : Boolean) return Internal_Unit
is
   N   : constant Bare_Foo_Node := Convert_From_Name (Node);
   Ctx : constant Internal_Context := N.Unit.Context;

   AB   : constant Internal_Symbol_Type_Array :=
     (Lookup_Symbol (Ctx, "a"), Lookup_Symbol (Ctx, "b"));
   ABCD : constant Internal_Symbol_Type_Array :=
     (Lookup_Symbol (Ctx, "a"), Lookup_Symbol (Ctx, "b"),
      Lookup_Symbol (Ctx, "c"), Lookup_Symbol (Ctx, "d"));

   Requested_Name : Symbol_Type_Array_Access :=
       Dispatcher_Name_P_Symbols (Node);
   Filename       : constant String := (if Requested_Name.Items in AB | ABCD
                                        then "source2.txt"
                                        else "source1.txt");
   Root       : constant Bare_Foo_Node := Get_From_File
     (Ctx, Filename, "", False, Default_Grammar_Rule).AST_Root;
   Has_Errors : Boolean := False;
begin
   for I in 1 .. Children_Count (Root) loop
      declare
         S  : constant Bare_Foo_Node := Child (Root, I);
         SN : constant Bare_Name := Scope_F_Name (Convert_To_Scope (S));
         N  : Symbol_Type_Array_Access := Dispatcher_Name_P_Symbols (SN);
      begin
         if N.Items = Requested_Name.Items then
            Has_Errors := Populate_Lexical_Env (S) or else Has_Errors;
         end if;
         Dec_Ref (N);
      end;
   end loop;
   Dec_Ref (Requested_Name);
   if Has_Errors then
      raise Property_Error;
   end if;
   return Root.Unit;
end Name_P_Referenced_Unit_Or_Error;
