class Type implements Node[Type] {
    fun property(type: Entity[Type]): Entity[Type]
    fun prop_noarg(): Entity[Type]
    fun non_entity(): Type

    fun dynamic(types: Array[Entity[Type]], arr: Array[Int]): Entity[Type]
    fun not_dynamic(arr: Array[Int]): Entity[Type]

    fun predicate(): Bool
    fun not_predicate(): Int

    fun predicate_dyn(types: Array[Entity[Type]]): Bool
    fun not_predicate_dyn(types: Array[Int]): Bool
}

val lv1 = LogicVar()
val lv2 = LogicVar()
val lv3 = LogicVar()

val eq1 : Equation = lv1 <- Type().as_entity
val eq2 : Equation = lv1 <-> lv2
val eq3 : Equation = lv2 <- Type.property%(lv3, Type().as_entity)

val no_logicvar_assign = 1 <- Type().as_entity
val non_entity_assign = lv1 <- Type()

val no_logicvar_unify1 = 1 <-> lv1
val no_logicvar_unify2 = lv1 <-> 1
val non_entity_propagate = lv2 <- Type.non_entity%(lv3)

val dyn = lv2 <- Type.dynamic%([lv1, lv2], [1, 2])
val dyn_error = lv2 <- Type.dynamic%(lv1, [1, 2])

val predicate = Type.predicate%(lv1)
val predicate_error = Type.not_predicate%(lv1)

val predicate_dyn = Type.predicate_dyn%([lv1, lv2])
val predicate_dyn_error = Type.not_predicate_dyn%([lv1], [1])

val propagate_as_bind = lv1 <- Type.prop_noarg%(Type().as_entity)
val invalid_propagate_as_bind = lv1 <- Type.prop_noarg%(1)
